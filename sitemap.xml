<search>
    
     <entry>
        <title>Hugo Next 主题</title>
        <url>https://iihui.github.io/post/hugo-next/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>hugo</tag><tag>next</tag>
        </tags>
        <content type="html">  从兰陵子处下载了Next主题，修改了主题目录下的config.toml配置文件(配置文件路径为themes/next/config.toml)。但发现有很多地方还是需要修改才能满足自己的需求，对前端了解较少，以此为记。
 修改主题 首先从这里下载Next主题,并将其放入themes目录下，然后在与themes同级的全局配置文件config.toml文件中添加：
Theme = &amp;#34;next&amp;#34; 添加代码高亮 插入Golang、Swift和Objective-C代码段时发现并不能正常高亮，查资料发现是Next主题默认不支持这几种语言的语法高亮，因此需要在themes/next/layouts/partials/head.html文件中的&amp;lt;/head&amp;gt;前添加如下代码：
 &amp;lt;link href=&amp;#34;https://cdn.bootcss.com/highlight.js/9.12.0/styles/monokai-sublime.min.css&amp;#34; rel=&amp;#34;stylesheet&amp;#34;&amp;gt;  &amp;lt;script src=&amp;#34;https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt;  &amp;lt;script src=&amp;#34;https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/go.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt;  &amp;lt;script src=&amp;#34;https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/swift.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt;  &amp;lt;script src=&amp;#34;https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/yaml.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt;  &amp;lt;script src=&amp;#34;https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/kotlin.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt;  &amp;lt;script&amp;gt;hljs.initHighlightingOnLoad();&amp;lt;/script&amp;gt; 添加底部声明 默认情况下底部声明以及微信打赏码是没有的。为了显示底部声明以及微信打赏码这些，首先必须修改themes/next/layouts/partials/widgets/weixin.html文件，添加创作共享声明和微信打赏：
&amp;lt;div class=&amp;#34;post-nav&amp;#34;&amp;gt;  &amp;lt;div style=&amp;#34;border: 1px dashed #e0e0e0; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;&amp;#34;&amp;gt;  &amp;lt;div style=&amp;#34;float:left;margin-top:0px;&amp;#34;&amp;gt;  &amp;lt;img src=&amp;#34;https://i.loli.net/2018/12/16/5c15cbd7f2b61.jpg&amp;#34; width=&amp;#34;128px&amp;#34; height=&amp;#34;128px&amp;#34;/&amp;gt;  &amp;lt;div style=&amp;#34;text-align:center;&amp;#34;&amp;gt;谢谢支持!&amp;lt;/div&amp;gt;  &amp;lt;/div&amp;gt;  &amp;lt;div&amp;gt;  &amp;lt;p style=&amp;#34;margin-top:10px;&amp;#34;&amp;gt;  标题：{{ .Title }}  &amp;lt;br /&amp;gt;作者：阿呆&amp;lt;a target=&amp;#34;_blank&amp;#34; href=&amp;#34;/&amp;#34;&amp;gt;{{ .Site.Author.name }}&amp;lt;/a&amp;gt;  &amp;lt;br /&amp;gt;地址：{{ .Permalink }}  &amp;lt;br /&amp;gt;声明：自由转载-非商用-保持署名（创作共享3.0许可证）  &amp;lt;/p&amp;gt;  &amp;lt;/div&amp;gt;  &amp;lt;/div&amp;gt;  &amp;lt;div class=&amp;#34;clear&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; 然后在themes/next/layouts/_default/single.html中添加 {{ partial &amp;quot;widgets/weixin.html&amp;quot; .}}，如下图所示：
经过上面的两个步骤，就可以添加创作共享和微信打赏，效果如下：
删除文章列表之间的横线 Next主题默认首页文章列表之间有条横线，看着觉得挺别扭的，找了一下资料，发现可以在themes/next/static/css/main.css文件中将.posts-expand .post-eof中的height设为0：
.posts-expand .post-eof {  display: block;  margin: 50px auto 10px;  width: 100%;  height: 0px;  background: #ccc;  text-align: center; } 修改文章列表信息 首页展示的文章列表中，每篇文章的信息展示如下图所示： 但是我想改成下面这样：
首先在themes/next/i18n/zh.yaml中做如下修改：
- id: Time  translation: 创建 - id: TimeUpdated  translation: 更新 - id: View  translation: 字数 - id: ReadMore  translation: 阅读全文 - id: ViewTime  translation: 时长 - id: ReadingTime  translation: &amp;#34;{{ .ReadingTime }} 分钟&amp;#34; - id: NumberOfText  translation: &amp;#34;{{ .WordCount }}字&amp;#34; 然后在themes/next/layouts/partials/post/readtime.html中做如下修改：
&amp;lt;span&amp;gt; &amp;amp;nbsp; | &amp;amp;nbsp; &amp;lt;span class=&amp;#34;post-meta-item-icon&amp;#34;&amp;gt;  &amp;lt;i class=&amp;#34;fa fa-file-word-o&amp;#34;&amp;gt;&amp;lt;/i&amp;gt; &amp;lt;/span&amp;gt; &amp;lt;span class=&amp;#34;post-meta-item-text&amp;#34;&amp;gt;{{ i18n &amp;#34;View&amp;#34; }}{{ i18n &amp;#34;Colon&amp;#34;}}&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;#34;leancloud-visitors-count&amp;#34;&amp;gt;{{ i18n &amp;#34;ReadingCount&amp;#34; .}}&amp;lt;/span&amp;gt; &amp;amp;nbsp; | &amp;amp;nbsp; &amp;lt;span class=&amp;#34;post-meta-item-icon&amp;#34;&amp;gt;  &amp;lt;i class=&amp;#34;fa fa-coffee&amp;#34;&amp;gt;&amp;lt;/i&amp;gt; &amp;lt;/span&amp;gt; &amp;lt;span class=&amp;#34;post-meta-item-text&amp;#34;&amp;gt;{{ i18n &amp;#34;ViewTime&amp;#34; }}{{ i18n &amp;#34;Colon&amp;#34;}}&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;#34;leancloud-visitors-count&amp;#34;&amp;gt;{{ i18n &amp;#34;ReadingTime&amp;#34; .}}&amp;lt;/span&amp;gt; &amp;lt;/span&amp;gt; 修改左侧菜单栏的顺序 左侧菜单栏的顺序，需要通过修改themes/next/config.toml文件中Menu.Main中的权重值weight来调整顺序：
[[Menu.Main]]  Name = &amp;#34;首页&amp;#34;  Pre = &amp;#34;home&amp;#34;  URL = &amp;#34;/&amp;#34;  Weight = 1  [[Menu.Main]]  Name = &amp;#34;标签&amp;#34;  Pre = &amp;#34;tag&amp;#34;  URL = &amp;#34;/tags/&amp;#34;  Weight = 2  [[Menu.Main]]  Name = &amp;#34;归档&amp;#34;  Pre = &amp;#34;archive&amp;#34;  URL = &amp;#34;/post/&amp;#34;  Weight = 3  [[Menu.Main]]  Name = &amp;#34;美食&amp;#34;  Pre = &amp;#34;fire&amp;#34; #tint  URL = &amp;#34;/categories/美食/&amp;#34;  Weight = 4  [[Menu.Main]]  Name = &amp;#34;后期&amp;#34;  Pre = &amp;#34;edit&amp;#34;  URL = &amp;#34;/categories/后期/&amp;#34;  Weight = 5  [[Menu.Main]]  Name = &amp;#34;旅行&amp;#34;  Pre = &amp;#34;leaf&amp;#34;  URL = &amp;#34;/categories/旅行/&amp;#34;  Weight = 6  [[Menu.Main]]  Name = &amp;#34;关于&amp;#34;  Pre = &amp;#34;user&amp;#34;  URL = &amp;#34;/about/&amp;#34;  Weight = 7 文章左侧展示目录 如果需要在文章左侧展示目录，需要在markdown文章开头添加toc = true：
--- title: Hugo next 主题问题 date: 2020-02-07 11:27:41 tags: [hugo,tool] categories: [code] toc: true --- 首页展示文章数目更改 修改首页展示的文章数目可以在themes/next/config.toml中设置Paginate字段值：
首页摘要字数更改 首页摘要的字数设置必须在与themes同级的config.toml文件中设置才会生效：
summaryLength = 100 #放在同themes同级的config.toml上才有效 设置文章置顶 想要把文章置顶，需要在markdown文章头部设置权重weight的值，如下所示：
--- title: 陈小厨作品集 date: 2020-02-03 13:28:05 tags: [美食] categories: [美食] weight: 1 toc: true --- 修改了权重值，效果如下：
从H1开始显示文章目录 不知道从什么时候开始Hugo从h2生成目录，为了设置从h1开始生成目录，需要设置全局的config.toml(即跟themes同级的config.toml)，如下所示：
[markup]  [markup.tableOfContents]  endLevel = 4  startLevel = 1  使用KaTex渲染公式 因为Markdown中的下划线和latex公式里的下划线冲突，导致Hugo中latex公式里的下标总是渲染不出来，如下图所示，看着很不舒服：
使用Katex来渲染公式可以达到正常的效果：
首先进入themes/next/layouts/partials目录，新建一个名为katex.html文件：
然后在katex.html中添加如下内容：
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;!-- CSS File --&amp;gt;  &amp;lt;head&amp;gt;  &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt;  &amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css&amp;#34; integrity=&amp;#34;sha384-D&#43;9gmBxUQogRLqvARvNLmA9hS2x//eK1FhVb9PiU86gmcrBrJAQT8okdJ4LMp2uv&amp;#34; crossorigin=&amp;#34;anonymous&amp;#34;&amp;gt;   &amp;lt;!-- JS Fle --&amp;gt;  &amp;lt;script defer src=&amp;#34;https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js&amp;#34; integrity=&amp;#34;sha384-483A6DwYfKeDa0Q52fJmxFXkcPCFfnXMoXblOkJ4JcA8zATN6Tm78UNL72AKk&#43;0O&amp;#34; crossorigin=&amp;#34;anonymous&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt;  &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 然后在themes/next/layouts/partials/header.html文件中添加如下代码：
{{ if .Params.katex}}{{ partial &amp;#34;katex.html&amp;#34; . }}{{ end }} 最后在需要渲染公式的markdown文章头部，添加katex: true：
--- title: 线性表 date: 2018-04-25T20:52:42&#43;08:00 tags: [算法] categories: [算法] toc: true katex: true --- 就可以达到如下的效果：
参考资料
 字体颜色生效 升级了Hugo版本之后，发现之前在笔记中插入的字体颜色tag都已经失效。查了相关资料，发现这是因为之前Hugo使用Blackfriday来渲染Markdown文件。从0.60版本开始，默认的 Markdown渲染器已经改成了Goldmark，而Goldmark渲染器默认不会渲染HTML tags。
为了修复这个问题，有两种不同的解决方案。第一种是把Markdown渲染引擎改回为Blackfriday。即在全局设置文件config.toml中添加：
[markup]  defaultMarkdownHandler = &amp;#34;blackfriday&amp;#34; 第二种是依然使用Goldmark来渲染，但是修改它的默认行为，即在全局设置文件config.toml中添加：
[markup]  defaultMarkdownHandler = &amp;#34;goldmark&amp;#34;  [markup.goldmark]  [markup.goldmark.renderer]  unsafe = true 参考资料
 添加代码粘贴按钮 参考资料 参考资料 参考资料 参考资料
</content>
    </entry>
    
     <entry>
        <title>一些问题的解决方案2021</title>
        <url>https://iihui.github.io/post/ios-solutions-2021/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  在开发过程中，会遇到各种问题，有时候某个问题当时已经找到了解决方案，但过了一段时间又可能会忘记。这篇文章记录一些问题的解决方案，以便后续查找。
 强制竖屏 最近使用其它SDK，业务方要求打开某个页面时强制竖屏，按对方要求传了相应参数未生效，依然能够横竖屏切换。解决方案是先在工程info.plist文件中添加Require Full Screen项，并将其值置为YES，然后在需要强制竖屏的ViewController中添加如下代码：
class ViewController: UIViewController {  override func viewDidLoad() {  super.viewDidLoad()  UIDevice.current.setValue(UIInterfaceOrientation.portrait.rawValue, forKey: &amp;#34;orientation&amp;#34;)  }   override var supportedInterfaceOrientations: UIInterfaceOrientationMask {  return .portrait  }   override var shouldAutorotate: Bool {  return true  } } keyWindow变化 系统升级到iOS 14.5.1后，发现使用UIApplication.shared.keyWindow获取到的rootViewController为nil。排查发现，在创建并使用新window后导致keyWindow发生了变化。为了防止这种变化，在显示新的window前，先保存原来的keyWindow，等释放新建的window后再还原keyWindow：
func show() {  if self.showTimes == 0 {  // iOS 14.5.1上如果不记录keyWindow，调用self.dismissVC()后会导致dismiss后keyWindow发生变化  // 从而导致取topMost时为nil，路由不能正常push或present  self.keyWindow = UIApplication.shared.keyWindow  let window = UIWindow(frame: UIScreen.main.bounds)  window.windowLevel = UIWindow.Level.normal  window.safeRootViewController = self  window.isHidden = false  window.backgroundColor = UIColor.clear  self.newWindow = window  // 防止多次点击  self.showTimes &#43;= 1  } }  @IBAction func cancelAction(_ sender: Any) {  self.dismissVC()  // 恢复keyWindow，以解决iOS 14.5.1 keyWindow发生变化的情况  self.keyWindow?.makeKeyAndVisible() } UIAlertView deprecated 测试KSCrash组件时使用XCode 12.3新建了一个demo工程，完成相关代码之后出现：UIAlertView is deprecated and unavailable for UIScene based applications, please use UIAlertController错误，参照Stack Overflow上的回答，解决了报错问题。
解决这个问题的核心是要删除UIScene相关代码，让工程恢复到旧的window架构。这个过程主要分为四步，首先需要删除工程中的SceneDelegate.swift文件：
然后在AppDelegate.swift文件中删除UIScene中相关的代码，即application(_ application: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession, options: UIScene.ConnectionOptions)和 application(_ application: UIApplication, didDiscardSceneSessions sceneSessions: Set&amp;lt;UISceneSession&amp;gt;)两个函数：
func application(_ application: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession, options: UIScene.ConnectionOptions) -&amp;gt; UISceneConfiguration {  // Called when a new scene session is being created.  // Use this method to select a configuration to create the new scene with.  return UISceneConfiguration(name: &amp;#34;Default Configuration&amp;#34;, sessionRole: connectingSceneSession.role) }  func application(_ application: UIApplication, didDiscardSceneSessions sceneSessions: Set&amp;lt;UISceneSession&amp;gt;) {  // Called when the user discards a scene session.  // If any sessions were discarded while the application was not running, this will be called shortly after application:didFinishLaunchingWithOptions.  // Use this method to release any resources that were specific to the discarded scenes, as they will not return. } 接着在AppDelegate.swift中添加属性var window: UIWindow?，以补回原本在SceneDelegate.swift文件中声明的var window: UIWindow?属性：
class AppDelegate: UIResponder, UIApplicationDelegate {  var window: UIWindow?   func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&amp;gt; Bool {  CrashReporterService.shared.startReporter()  return true  }  } 最后在工程的Info.plist文件中删除Application Scene Manifest这一行，重新编译即可运行。如果重新编译后依然报错，需要再清除一下工程的缓存（使用Shift&#43;Command&#43;K快捷键即可），然后再次编译。
禁用边缘返回手势 以push方式打开的页面，该页面默认自动拥有系统提供的「边缘返回」手势。如果要禁止系统的「边缘返回」手势，可以为UIViewController写如下扩展方法：
// 参考自https://juejin.cn/post/6860656306630590477 extension UIViewController {  // 禁止系统的边缘返回手势  func popGestureForbid() {  if let gestures = self.navigationController?.interactivePopGestureRecognizer?.view?.gestureRecognizers {  gestures.forEach({ $0.isEnabled = false })  }  } } UIWebView特殊字符 使用UIWebView加载的html文件中包含\n，&#39;等特殊字符时，如果不做任何处理直接加载的话，将会出现白屏，并且此时没有任何错误提示。因此，加载这种含有特殊字符的html文件时要特殊处理:
class HTMLUtils {  static func escapsedHTML(html: String) -&amp;gt; String{  var result = html  if !result.isEmpty {  result = result.replacingOccurrences(of: &amp;#34;\\&amp;#34;, with: &amp;#34;\\\\&amp;#34;)  result = result.replacingOccurrences(of: &amp;#34;\&amp;#34;&amp;#34;, with: &amp;#34;\\\&amp;#34;&amp;#34;)  result = result.replacingOccurrences(of: &amp;#34;&amp;#39;&amp;#34;, with: &amp;#34;\\&amp;#39;&amp;#34;)  result = result.replacingOccurrences(of: &amp;#34;\r&amp;#34;, with: &amp;#34;\\r&amp;#34;)  result = result.replacingOccurrences(of: &amp;#34;\n&amp;#34;, with: &amp;#34;\\n&amp;#34;)  }  return result  } } 允许http请求 自iOS 9.0开始，苹果默认要求App访问的url均为https。为了能在项目中支持http，需在项目中的Info.plist文件中将App Transport Security Settings下的Allow Arbitrary Loads设置为YES。如果没有这两项的话，则需先在Info.plist文件中添加。
仿导航栏添加阴影 // 设置阴影颜色 navBGView.layer.shadowColor = UIColor.lightGray.cgColor // 设置阴影偏移范围 navBGView.layer.shadowOffset = CGSize(width: 0, height: 1.8) // 设置阴影颜色的透明度 navBGView.layer.shadowOpacity = 0.2 // 设置阴影的半径 navBGView.layer.shadowRadius = 2.5 // 设置阴影路径 navBGView.layer.shadowPath = UIBezierPath.init(rect: navBGView.bounds).cgPath 可以在UINavigationController中添加扩展方法来隐藏或显示自定义的阴影。下面代码定义了两个扩展方法，其中showShadow方法用于显示阴影，hideShadow方法用于隐藏阴影：
public extension UINavigationController {  func showShadow(){  self.navigationBar.layer.shadowColor = UIColor.black.cgColor  self.navigationBar.layer.shadowOffset = CGSize(width: 0, height: 2.5)  self.navigationBar.layer.shadowOpacity = 0.15  self.navigationBar.layer.shadowRadius = 4.0  }   func hideShadow(){  self.navigationBar.layer.shadowOffset = CGSize(width: 0, height: 0)  self.navigationBar.layer.shadowColor = UIColor.white.cgColor  self.navigationBar.layer.shadowOpacity = 0.0  } } 参考资料
导航栏顶部黑屏 帮助中心中文版和英文版在iOS 15以上的系统表现不一致，发现是Top Bar设置不一致导致的。如下所示，只要改成相同就行：
毫秒级时间戳距当前时间 最近有个需求要将毫秒级的时间戳转换为xx天前，xx小时前，xx分钟前以及xx秒前。下面代码将距离当前时间小于60秒转换为几秒前，小于60分钟转换为xx分钟前，小于24小时，转换为xx小时前，小于10天前转换为xx天前，否则显示xxxx年xx月xx日：
/// 将毫秒级别的时间戳转换为约定的格式，0～60秒显示几秒前，1～60分显示xx分钟前，1～24小时显示xx小时前，1～10天显示xx天前，否则显示yyyy-MM-dd /// - Parameter timeStamp: 毫秒级别时间戳字符串 /// - Returns: 转换后的字符串 private func convertTime(timeStamp: String) -&amp;gt; String {  let currentTimeSeconds = Date().timeIntervalSince1970  if let timeDouble = Double(timeStamp) {  let timeStampSeconds = TimeInterval(timeDouble / 1000)  let reduceTime: TimeInterval = currentTimeSeconds - timeStampSeconds  // 时间差小于60秒  if reduceTime &amp;lt; 60 {  return &amp;#34;几秒前&amp;#34;  }  // 时间差大于一分钟小于60分钟内  let minutes = Int(reduceTime / 60)  if minutes &amp;lt; 60 {  return &amp;#34;\(minutes)分钟前&amp;#34;  }  // 时间差小于24小时  let hours = Int(reduceTime / 3600)  if hours &amp;lt; 24 {  return &amp;#34;\(hours)小时前&amp;#34;  }  // 时间差小于10 天  let days = Int(reduceTime / 3600 / 24)  if days &amp;lt; 10 {  return &amp;#34;\(days)天前&amp;#34;  }  let date = NSDate(timeIntervalSince1970: timeStampSeconds)  let dateFormat = DateFormatter()  dateFormat.dateFormat = &amp;#34;yyyy-MM-dd&amp;#34;  return dateFormat.string(from: date as Date)  } else {  return &amp;#34;未知时间&amp;#34;  } } GIF显示 显示gif动画有两种方式：第一种是使用UIWebView，另一种是使用UIImageView。但如果使用UIWebView显示gif的话，动画是不可以暂停的：
class ViewController: UIViewController {  override func viewDidLoad() {  super.viewDidLoad()  guard let path = Bundle.main.path(forResource: &amp;#34;demo&amp;#34;, ofType: &amp;#34;gif&amp;#34;) else {  return  }  let url = URL(fileURLWithPath: path)   do {  let gifData = try Data(contentsOf: url)  let webView = UIWebView()  webView.frame = CGRect(x: 0, y: 100, width: self.view.frame.width, height: 600)  webView.scalesPageToFit = true  webView.load(gifData, mimeType: &amp;#34;image/gif&amp;#34;, textEncodingName: String(), baseURL: NSURL() as URL)  self.view.addSubview(webView)  } catch {  debugPrint(error.localizedDescription)  }  } } 使用UIImageView播放gif首先需要从给定的gif文件中获取图片数组，然后获取gif文件的播放时长。最后将获取到的图片数组和时长赋值给UIImageView的animationImages和animationDuration实例属性：
class ViewController: UIViewController {  override func viewDidLoad() {  super.viewDidLoad()   let imageView = UIImageView()  imageView.frame = CGRect(x: 0, y: 100, width: self.view.frame.width, height: 600)  self.view.addSubview(imageView)   guard let path = Bundle.main.path(forResource: &amp;#34;demo&amp;#34;, ofType: &amp;#34;gif&amp;#34;) else {  return  }  let url = URL(fileURLWithPath: path)   do {  let gifData = try Data(contentsOf: url)  guard let imageSource = CGImageSourceCreateWithData(gifData as CFData, nil) else {  return  }  let imageCount = CGImageSourceGetCount(imageSource)   var images = [UIImage]()  var gifDuration: TimeInterval = 0  for index in 0 ..&amp;lt; imageCount {  guard let cgImage = CGImageSourceCreateImageAtIndex(imageSource, index, nil) else {  return  }  let image = UIImage(cgImage: cgImage)  images.append(image)  if index == 0 {  imageView.image = image  }   var tmpProperty: NSDictionary?  if let tmp = CGImageSourceCopyPropertiesAtIndex(imageSource, index, nil) {  tmpProperty = tmp as NSDictionary  if let property = tmpProperty {  guard let gifDic = property[kCGImagePropertyGIFDelayTime] as? NSDictionary else {  continue  }   guard let imageDuration = gifDic[kCGImagePropertyGIFDelayTime] as? NSNumber else {  continue  }  gifDuration &#43;= imageDuration.doubleValue  }  }  }   imageView.animationImages = images  imageView.animationDuration = gifDuration  imageView.animationRepeatCount = 10  imageView.startAnimating()  } catch {  debugPrint(error.localizedDescription)  }  } } 参考资料
视频编码 近期出现了在iPhone上拍摄的视频，同步到Android设备后播放不了的问题。直觉猜测应该是iPhone上拍摄视频所使用的编码不兼容Android。经过沟通，播放视频是用H5嵌入的，因为手边没有视频播放源码和可测的Android设备，为了验证猜测，尝试着先改变iPhone录制视频时的编码方式，然后写一段播放视频的H5代码，用Chrome浏览器进行测试。
if self.captureSession.canAddOutput(self.captureMovieFileOutput) {  self.captureSession.addOutput(self.captureMovieFileOutput)  if let outPutConnection = self.captureMovieFileOutput.connection(withMediaType:AVMediaTypeVideo){  let out = self.captureMovieFileOutput.outputSettings(for: outPutConnection)  } } 上面的代码便能看到视频录制时的编码方式，对比iOS 11.3，iOS 12.0以及iOS 12.01后发现输出的编码格式从avc1变成了hcv1：
因为上面代码使用的是默认编码格式，通过上面的对比发现视频的默认编码格式是会随着iOS版本发生变化的。因此需要显式指定视频的输出编码格式，即设置[AVVideoCodecKey:AVVideoCodecH264]：
if self.captureSession.canAddOutput(self.captureMovieFileOutput) {  self.captureSession.addOutput(self.captureMovieFileOutput)  if let outPutConnection = self.captureMovieFileOutput.connection(withMediaType:AVMediaTypeVideo){  if #available(iOS 10.0, *){  let outputSettings = [AVVideoCodecKey:AVVideoCodecH264]  self.captureMovieFileOutput.setOutputSettings(outputSettings, for: outPutConnection)  //let out = self.captureMovieFileOutput.outputSettings(for: outPutConnection)  }  } } 为了测试改变编码前后生成的视频文件能否在Chrome浏览器中播放，需要编写对应的html代码以播放测试视频，将视频文件放在同级目录，然后更改如下代码中的视频文件名即可：
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt;  &amp;lt;meta charset=&amp;#34;utf-8&amp;#34; /&amp;gt;  &amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34;&amp;gt;  &amp;lt;title&amp;gt;Page Title&amp;lt;/title&amp;gt;  &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1&amp;#34;&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt;  &amp;lt;video  id=&amp;#34;video&amp;#34;  src=&amp;#34;video13.mp4&amp;#34;  controls = &amp;#34;true&amp;#34;  poster=&amp;#34;images.jpg&amp;#34; //视频封面  preload=&amp;#34;auto&amp;#34;  webkit-playsinline=&amp;#34;true&amp;#34; //这个属性是ios 10中设置可以  让视频在小窗内播放，也就是不是全屏播放  playsinline=&amp;#34;true&amp;#34; //iOS微信浏览器支持小窗内播放  x-webkit-airplay=&amp;#34;allow&amp;#34;  x5-video-player-type=&amp;#34;h5&amp;#34; //启用H5播放器,是wechat安卓版特性  x5-video-player-fullscreen=&amp;#34;true&amp;#34; //全屏设置，  设置为 true 是防止横屏  x5-video-orientation=&amp;#34;portraint&amp;#34; //播放器支付的方向， landscape横屏，portraint竖屏，默认值为竖屏  &amp;lt;/video&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 使用上面这段代码在明确指定编码之前摄制的视频不可播放，修改编码之后可以播放摄制的视频。后续找到Android测试机发现显式指定编码之前摄制的视频也是不可播放，显式指定编码格式之后可以正常播放摄制的视频。
启动图片 最近App改版，启动页也要随之需要修改，但是修改lanuchScreen.storyboard中的图片和样式后，发现部分手机并未立即生效。解决这个问题，主要有三个步骤。首先，启动页用到的图片资源，不要放入到*.xcassets中，应该直接放到工程目录下：
如果启动页的图片资源需要替换，那应该将图片重命名，不要使用上次的名字。因为如果使用上次的名字，启动的时候还是会读之前的缓存图片：
最后需要删除libraryPath目录下SplashBoard/Snapshots的文件夹，即缓存文件夹libraryPath.appendingPathComponent(&amp;quot;SplashBoard&amp;quot;).appendingPathComponent(&amp;quot;Snapshots&amp;quot;)：
let path = libraryPath.appendingPathComponent(&amp;#34;SplashBoard&amp;#34;).appendingPathComponent(&amp;#34;Snapshots&amp;#34;) do {  if FileManager.default.fileExists(atPath: path.path){  try FileManager.default.removeItem(at: path)  }  } catch let error {  printDebug(msg: error.localizedDescription) } 图片裁剪为圆形 图片的圆形处理需求包括：➀将图片裁剪为圆形图。➁将图片裁剪为带外围圆圈的圆形图。两种都可以使用UIBezierPath来实现，下面第一段代码直接裁剪为圆形，第二段是将图片裁剪为带外围圆圈的圆形图：
/// 将图片裁剪为圆形图 /// - Returns:生成新的图片 func circleImage() -&amp;gt; UIImage? {  UIGraphicsBeginImageContextWithOptions(self.size, false, 0)  let imgPath = UIBezierPath(ovalIn: CGRect(x: 0, y: 0, width: self.size.width, height: self.size.height))  imgPath.addClip()  self.draw(at: CGPoint(x: 0, y: 0))  let newImg = UIGraphicsGetImageFromCurrentImageContext()  UIGraphicsEndImageContext()  return newImg }  /// 将图片裁剪为带外围⭕️的圆形图 /// - Parameters: /// - rail: 外围圆的宽度 /// - color: 外围圆的颜色 /// - Returns: 生成新的图片 func circleImageWidthRail(rail: CGFloat, color: UIColor) -&amp;gt; UIImage? {  let size = CGSize(width: self.size.width &#43; 2 * rail, height: self.size.height &#43; 2 * rail)  UIGraphicsBeginImageContextWithOptions(size, false, 0)  let path = UIBezierPath(ovalIn: CGRect(x: 0, y: 0, width: size.width, height: size.height))  color.set()  path.fill()  let imgPath = UIBezierPath(ovalIn: CGRect(x: rail, y: rail, width: self.size.width, height: self.size.height))  imgPath.addClip()  self.draw(at: CGPoint(x: rail, y: rail))  let newImg = UIGraphicsGetImageFromCurrentImageContext()  UIGraphicsEndImageContext()  return newImg } 参考资料
 局域网无线调试设备 如果Mac和iOS设备在同一局域网中，可以通过网络连接进行调试。首先在Xcode菜单栏进入到Window --&amp;gt; Devices and Simulators：
然后选中Devices找到对应的真机，鼠标左键单击以选中真机，然后在右上角勾选Connect via network，如下图所示：
勾选Connect via network后，编译安装时选择上面选中并设置的设备。若出现Xcode will continue when xxx is connected，则需要在上面的真机上右键选择Connect via IP Address...，再输入真机的IP地址：
Device Locked 如果手机已经连接上了，并且已经设置信任，但编译安装时Xcode还是出现如下提示。那么需要在Xcode的菜单栏Window--&amp;gt;Devices and Simulators，然后选中对应的设备，右键选择Unpair Device，此时手机会弹出重新信任的提示，再点一次信任即可解决。
Xcode &amp;#34;Device Locked&amp;#34; When iPhone is unlocked open url 自iOS 10开始UIApplication.shared.openURL被废弃了，需要使用open func open(_ url: URL, options: [UIApplication.OpenExternalURLOptionsKey : Any] = [:], completionHandler completion: ((Bool) -&amp;gt; Void)? = nil)。
上面的options有个参数是universalLinksOnly。如果包含universalLinksOnly选项，则只有在配置了某个应用程序打开URL时，URL才会打开。例如要打开YouTube视频，您必须安装YouTube应用。
UIApplication.shared.open(url, options: [:], completionHandler: nil) 各个选项参数说明
安全下标 extension Collection {  /// Returns the element at the specified index if it is within bounds, otherwise nil.  subscript (safe index: Index) -&amp;gt; Element? {  return indices.contains(index) ? self[index] : nil  } } 隐藏TabBar 如果在UIViewController实例中设置hidesBottomBarWhenPushed = true后，如果push到这个界面，则UITabBarController底部的tabbar将会隐藏。
在待打开的页面设置了hidesBottomBarWhenPushed = true后，使用push方式打开这个新界面之后，再使用替换window.rootViewController的方式打开另一个新的界面。但如果将替换window.rootViewController打开的新界面关闭掉，再回到push打开的界面后，底部tabbar又会出现。此时，可以使用如下代码隐藏底部的tabbar：
private func hideTabBar() {  if self.rootViewController is RootTabBarController,  let navigationController = (self.rootViewController as? RootTabBarController)?.selectedViewController as? UINavigationController,  navigationController.viewControllers.count &amp;gt; 1,  let topViewController = navigationController.topViewController {  navigationController.popViewController(animated: false)  navigationController.pushViewController(topViewController, animated: false)  } } 上面的解决问题的思路是将原来push的界面先pop掉，然后利用已经设置的hidesBottomBarWhenPushed = true属性，再重新push一次之前的界面，就可以把底部的tabbar隐藏。
如果是在viewWillAppear里面手动将tabbar隐藏，而在viewWillDisapper中将tabbar显示。这样不仅会影响整体的逻辑，而且还会出现肉眼可见的黑边：
override func viewWillAppear(_ animated: Bool) {  super.viewWillAppear(animated)  self.tabBarController?.tabBar.isHidden = true  self.tabBarController?.tabBar.isTranslucent = true }  override func viewWillDisappear(_ animated: Bool) {  super.viewWillDisappear(animated)  self.tabBarController?.tabBar.isHidden = false  self.tabBarController?.tabBar.isTranslucent = false } 强制浅色模式 自iOS 13开始，一旦使用了系统的组件和颜色，如果用户切换到了深色模式，则这些组件的颜色会随着发生变化，而此时某些使用了自定义颜色的组件对应的颜色不会改变，将会变得不统一，看起来很奇怪。
一个简单的方式是强制App为浅色模式，使得即使用户开启了深色模式后，App还是之前的浅色模式。如果要强制App为浅色模式，需在项目的Info.plist文件中将User Interface Style这一项设置为Light：
字典合并 第一个字典先提供一些默认值，对于相同的key如果第二个字典中存在相应的value，则第一个字典的value将会被第二个字典的value覆盖掉:
/// 默认字段 var defaultInfo: [String: Any] = [  &amp;#34;sys_id&amp;#34;: sysID,  &amp;#34;type&amp;#34;: action.rawValue,  &amp;#34;ystId&amp;#34;: activeUser.pid,  &amp;#34;deviceId&amp;#34;: deviceID,  &amp;#34;platform&amp;#34;: platform,  &amp;#34;pubVer&amp;#34;: pubVersion,  &amp;#34;buildVer&amp;#34;: buildVersion,  &amp;#34;deviceModel&amp;#34;: deviceModel,  &amp;#34;serverTime&amp;#34;: logTime,  &amp;#34;deviceTime&amp;#34;: deviceTimeStr,  &amp;#34;startTime&amp;#34;: logTime,  &amp;#34;endTime&amp;#34;: logTime,  &amp;#34;networkType&amp;#34;: networkInfo._networkType,  &amp;#34;networkName&amp;#34;: networkInfo._networkName,  &amp;#34;ip&amp;#34;: networkInfo.ip,  &amp;#34;inuseId&amp;#34;: inuseID,  &amp;#34;gpsLng&amp;#34;: gps.lng,  &amp;#34;gpsLat&amp;#34;: gps.lat, ] if let _args = args {  // 注意是用defaultInfo 去merge 字典_args  defaultInfo.merge(_args, uniquingKeysWith: { $1 }) } 数组分片 extension Array {  /// 数组分片  func chunked(by distance: Int) -&amp;gt; [[Element]] {  return stride(from: 0, to: count, by: distance).map {  Array(self[$0 ..&amp;lt; Swift.min($0 &#43; distance, count)])  }  } } WKWebView自动播放 因为WKWebView中设置的mediaPlaybackAllowsAirPlay和mediaPlaybackRequiresUserAction已经被废弃了，所以需要替换如下新API:
let wkConfig = WKWebViewConfiguration() wkConfig.userContentController = WKUserContentController() // 修改默认设置，允许页面内播放 wkConfig.allowsInlineMediaPlayback = true // 支持内嵌视频自动播放 //wkConfig.mediaPlaybackAllowsAirPlay = true //wkConfig.mediaPlaybackRequiresUserAction = false wkConfig.allowsAirPlayForMediaPlayback = true wkConfig.mediaTypesRequiringUserActionForPlayback = [] self.webView.scrollView.addObserver(self, forKeyPath: &amp;#34;contentSize&amp;#34;, options: .new, context: nil)  }  override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) {  if let key = keyPath, key == &amp;#34;contentSize&amp;#34;{  let fittingSize = self.webView.sizeThatFits(CGSize.zero)  self.webView.frame = CGRect(x: 0, y: noteTitleTextField.frame.height, width: fittingSize.width, height: fittingSize.height)  }  } func getLocalImage(_ userID: String?, isGetBigImg: Bool? = false) -&amp;gt; UIImage? {  guard let id = userID else { return nil }  return getImageFromPhotoNameAndPhotoType(id, isGetBigImg: isGetBigImg ?? fals } func isLoaded(_ userID: String) -&amp;gt; Bool {  lock.lock()  let isContains = hasLoadSmallPhotoDataSouceIndex.contains(userID)  lock.unlock()  return isContains } func load(_ userID: String) {  lock.lock()  hasLoadSmallPhotoDataSouceIndex.add(userID)  lock.unlock() } */ 主屏交互 自2015年苹果发布3D Touch时，iPhone 6s之后全部机型都支持该功能。3D Touch的主屏交互是在手机的桌面用力的按压应用图标，能够唤起快捷操作按钮。要实现主屏交互，首先要在info.plist文件中添加UIApplicationShortcutItem：
然后在application(_ application: UIApplication, performActionFor shortcutItem: UIApplicationShortcutItem, completionHandler: @escaping (Bool) -&amp;gt; Void)中添加处理逻辑：
func application(_ application: UIApplication, performActionFor shortcutItem: UIApplicationShortcutItem, completionHandler: @escaping (Bool) -&amp;gt; Void) { 	let type = shortcutItem.type  switch type {  //...  } } 3DTouch
多线程读写测试 /// 多线程读写测试，因为目前没有下沉，而且不能跑模拟器，所以写在这里测试 static func testMultiThreadReadAndWrite(){  let group = DispatchGroup()  let models:[MoConfigItemModel] = [MoConfigItemModel(),MoConfigItemModel()]  for _ in 0..&amp;lt;2000 {  let delaySet = TimeInterval(arc4random() % 10);  group.enter()  DispatchQueue.global().asyncAfter(deadline: .now() &#43; delaySet) {  self.lightAppConfigItems = models  group.leave()  }  let delaySetNil = TimeInterval(arc4random() % 10);  group.enter()  DispatchQueue.global().asyncAfter(deadline: .now() &#43; delaySetNil) {  self.lightAppConfigItems.append(MoConfigItemModel())  group.leave()  }  let delayGet = TimeInterval(arc4random() % 10)  group.enter()  DispatchQueue.global().asyncAfter(deadline: .now() &#43; delayGet) {  let _ = self.allConfigItems  group.leave()  }  }  let success = group.wait(timeout: .now() &#43; 12)  if success == .success {  DPrint(&amp;#34;testMultiThreadReadAndWrite Success&amp;#34; )  } } 数组去重 public extension Array where Element: Hashable {  func removeDuplicated() -&amp;gt; [Element] {  var tmpDict = [Element: Bool]()  return filter {  tmpDict.updateValue(true, forKey: $0) == nil  }  }  mutating func removeDuplicate() {  self = self.removeDuplicated()  } } 判断页面是否正显示 let isShowing = (self.isViewLoaded &amp;amp;&amp;amp; self.view.window != nil) SearchController导航栏空白 有个业务搜索使用UISearchController，但在已经点击搜索框时，再跳转到某些页面时发现页面导航栏上方有一大块空白，发现在跳转前设置self.searchController.hidesNavigationBarDuringPresentation = false，然后在界面恢复时将searchController.hidesNavigationBarDuringPresentation设置为true，也就是恢复成默认状态，可解决该问题：
public override func viewWillAppear(_ animated: Bool) {  super.viewWillAppear(animated)  // 页面重新出现的时候要将hidesNavigationBarDuringPresentation设置为true，恢复为默认状态  self.searchController.hidesNavigationBarDuringPresentation = true } 参考资料
SearchController横竖屏切换 使用UISearchController发现从竖屏到横屏时searchBar宽度显示不全，没有自动拉伸。尝试了在viewWillTransition中改变searchBar的宽度可以解决这个问题：
public override func viewWillTransition(to size: CGSize, with coordinator: UIViewControllerTransitionCoordinator) {  coordinator.animate(alongsideTransition: { [weak self] _ in  // 解决从竖屏到横屏时searchBar显示不全的问题  self?.searchController.searchBar.frame.size.width = size.width  }, completion: nil) } 参考资料1参考资料2
SignaturePlugin 后台接口有时需要对接口的query参数进行签名。因此在使用Moya进行请求时，有必要定义一个对query参数进行签名的插件，即在请求发送前进行拦截：
public struct FigureSignaturePlugin: PluginType {  public func prepare(_ request: URLRequest, target: TargetType) -&amp;gt; URLRequest {  guard let target = target as? MoTargetType, target.needsFigureSignature else {  return request  }  var request = request  switch target.task {  case .requestParameters(let parameters, _),  .downloadParameters(let parameters, _, _):  if let params = parameters as? [String: String],  let sign = params.figureSignature(with: ConfigInterfaceKey) {  request.addValue(sign, forHTTPHeaderField: &amp;#34;sign&amp;#34;)  }  default:  break  }  return request  }   public init() {  // 保证外部可用  } }  public protocol MoTargetType: TargetType {  /// 是否需要签名，签名由`FigureSignaturePlugin`插件完成。  /// 确保发送请求的Provider中添加了此插件。  var needsFigureSignature: Bool { get } }  public extension Dictionary where Key == String, Value == String {   /// 计算queries中参数签名，首先将queries按照key排列排序，然后按照key1value1key2value2...的方式拼接成字符串  /// 接着对拼接后的字符串key1value1key2value2...进行urlEncode，最后对urlEncode后的字符串做SM3HMAC  /// - Parameters:  /// - queries: 待签名参数字典  func figureSignature(with key: String) -&amp;gt; String? {  var keysJointValues: String = &amp;#34;&amp;#34;  // 先按照key的排序  let keys = self.keys.sorted()   // 一定要注意顺序  for key in keys where self[key] != nil {  keysJointValues &#43;= (key &#43; self[key]!)  }   if !keysJointValues.isEmpty, let urlEncodedStr = keysJointValues.urlEncoded, let signature = urlEncodedStr.sm3HMACToData(key: key)?.base64EncodedString() {  return signature  }  return nil  } } Moya同步请求 最近替换老代码时发现有不少地方使用了NSURLConnection.sendSynchronousRequest发送同步请求。但Moya中没有天然支持同步请求，需要自定义扩展来支持同步请求，下面的方法是借助泛型和信号量进行同步：
/// 同步网络请求 https://github.com/Moya/Moya/issues/1562 public extension MoyaProvider {  @discardableResult  func synchronousRequest&amp;lt;T: Decodable&amp;gt;(_ target: Target) throws -&amp;gt; T {  return try synchronousRequest(target).map(T.self)  }   @discardableResult  func synchronousRequest(_ target: Target) throws -&amp;gt; Moya.Response {  let semaphore = DispatchSemaphore(value: 0)  var response: Moya.Response? = nil  var error: Error? = nil  // 如果在主线程则会阻塞，因此指定callbackQueue: .global(qos: .background)  request(target, callbackQueue: .global(qos: .background)) { result in  defer {  semaphore.signal()  }  switch result {  case .success(let res):  response = res  case .failure(let err):  error = err  }  }  semaphore.wait()   guard error == nil else {  throw error!  }  return response!  } } 参考资料
ResponseObject 服务端返回的JSON格式的第一层一般是code,message,traceId，data。其中data中是真正的model，因为接口返回具有通用性，可以使用泛型来实现：
/// 服务端返回的数据模型，使用泛型实现 struct ResponseObject&amp;lt;T:Codable&amp;gt;: Codable {  var code: Int  var message: String  var dataModel: T?   enum CodingKeys: String, CodingKey {  case code = &amp;#34;code&amp;#34;  case message = &amp;#34;message&amp;#34;  case dataModel = &amp;#34;data&amp;#34;  } }  /// wifi信息 struct WifiInfoModel: Codable {  var bssid: String  var ssid: String  enum CodingKeys: String, CodingKey {  case bssid = &amp;#34;bssid&amp;#34;  case ssid = &amp;#34;ssid&amp;#34;  } }  /// 请求wifi信息 func requestWifiInfo(success: @escaping (ResponseObject&amp;lt;WifiInfoModel&amp;gt;) -&amp;gt; Void, failure: @escaping (String) -&amp;gt; Void) {  provider.request(.getWifiInfo) { result in  switch result {  case .success(let response):  do {  let model = try JSONDecoder().decode(ResponseObject&amp;lt;WifiInfoModel&amp;gt;.self, from: response.data)  if model.dataModel != nil {  success(model)  } else {  failure(model.message)  }  } catch {  failure(error.localizedDescription)  }  case .failure(let error):  failure(error.localizedDescription)  }  } } 参考资料 参考资料
JSONEncoding /// 将字典转换JSON数组，并设置请求的Content-Type为application/json; charset=utf-8 public struct JsonArrayEncoding: Moya.ParameterEncoding {  public static var `default`: JsonArrayEncoding { return JsonArrayEncoding() }   /// 将字典转换JSON数组，并设置请求的Content-Type为application/json; charset=utf-8  /// - Parameters:  /// - urlRequest: URLRequestConvertible  /// - parameters: 待转换为数组JSON的字典  /// - Throws: 若字典无法转换为JSON则会抛异常  /// - Returns: URLRequest  public func encode(_ urlRequest: URLRequestConvertible, with parameters: Parameters?) throws -&amp;gt; URLRequest {  var request = try urlRequest.asURLRequest()  if let dict = parameters {  // 将字典转换JSON数组  let json = try JSONSerialization.data(withJSONObject: [dict], options: JSONSerialization.WritingOptions.prettyPrinted)  request.setValue(&amp;#34;application/json; charset=utf-8&amp;#34;, forHTTPHeaderField: &amp;#34;Content-Type&amp;#34;)  request.httpBody = json  }  return request  }  } /// 将字典中key为[contentKey」的字段取出来，转换为JSON对象，并设置请求的Content-Type为application/json; charset=utf-8 public struct JsonContenTypeEncoding: Moya.ParameterEncoding {  public static var `default`: JsonContenTypeEncoding { return JsonContenTypeEncoding() }   /// 将字典中key为[contentKey」的字段取出来，转换为JSON对象，并设置请求的Content-Type为application/json; charset=utf-8  /// - Parameters:  /// - urlRequest: URLRequestConvertible  /// - parameters: 待转换的带contentKey字典  /// - Throws: 若字典中带contentKey的值无法转换为JSON对象则会抛异常  /// - Returns: URLRequest  public func encode(_ urlRequest: URLRequestConvertible, with parameters: Parameters?) throws -&amp;gt; URLRequest {  var request = try urlRequest.asURLRequest()  if let dict = parameters, let any = dict[&amp;#34;contentKey&amp;#34;] {  // 将字典中contentKey对应的值转换为JSON  let json = try JSONSerialization.data(withJSONObject: any, options: JSONSerialization.WritingOptions.prettyPrinted)  request.setValue(&amp;#34;application/json; charset=utf-8&amp;#34;, forHTTPHeaderField: &amp;#34;Content-Type&amp;#34;)  request.httpBody = json  }  return request  } } 资料
Result
启动时间统计 如果想要统计App的启动时间，则需要在Schema编辑时增加环境变量DYLD_PRINT_STATISTICS，并将其值设置为1。如果想要查看更详细的信息，需要添加环境变量DYLD_PRINT_STATISTICS_DETAILS，并将其值设置为1：
参考资料
跑马灯效果 /// 跑马灯移动的四个方向, 如果有需要可以自己扩展 public enum MovingDirectionType {  case left  case right  case bottom  case top } /// 速度类型 public enum SpeedType {  /// 长文字慢, 短文字快  case special  /// 不根据文字长短, 都是匀速  case normal }  /// 必选协议做到循环播放 public protocol XTMovingViewProtocol {  func drawMarqueeView(drawMarqueeView: XTMovingView, animationDidStopFinished: Bool) -&amp;gt; Void }  public class XTMovingView: UIView, CAAnimationDelegate {  /// 速度  public var speed: Float = 1.0  /// 宽  public var width: Float = 0.0  /// 高  public var height: Float = 0.0  /// 动画视图宽  public var animationViewWidth: Float = 0.0  /// 动画视图高  public var animationViewHeight: Float = 0.0  /// 是否停止  public var stop: Bool = true  /// 方向  public var moveType: MovingDirectionType = .left  /// 速度类型  public var speedType: SpeedType = .special  /// 内容  public var contentView = UIView()  /// 动画视图  public var animationView = UIView()  /// 协议  public var delegate: XTMovingViewProtocol?   required init?(coder: NSCoder) {  fatalError(&amp;#34;init(coder:) has not been implemented&amp;#34;)  }   public override init(frame: CGRect) {  super.init(frame: frame)  width = Float(frame.size.width)  height = Float(frame.size.height)  speed = 1  self.layer.masksToBounds = true  moveType = .left  animationView = UIView(frame: CGRect())  self.addSubview(animationView)  }   /// 添加Content视图  public func addContentView(v: UIView) -&amp;gt; Void {  contentView.removeFromSuperview()  v.frame = v.bounds  contentView = v  animationView.frame = v.bounds  animationView.addSubview(contentView)  /// 内部空间W  animationViewWidth = Float(animationView.frame.size.width)  /// 内部空间H  animationViewHeight = Float(animationView.frame.size.height)  }   /// 开始动画  public func startAnimation() -&amp;gt; Void {  animationView.layer.removeAnimation(forKey: &amp;#34;animationViewPosition&amp;#34;)  stop = false  /// 右边的中心  let pointRightCenter = CGPoint(x: Int(width &#43; animationViewWidth / 2), y: Int(animationViewHeight) / 2)  /// 左边的中心  let pointLeftCenter = CGPoint(x: -Int(animationViewWidth / 2), y: Int(animationViewHeight) / 2)  /// 下中心  let pointBottomCenter = CGPoint(x: Int(animationViewWidth / 2), y: Int(animationViewHeight) / 2 &#43; Int(height))  /// 上中心  let pointUpCenter = CGPoint(x: Int(animationViewWidth) / 2, y: -Int(animationViewHeight) / 2)  var fromPoint = CGPoint()  var toPoint = CGPoint()  switch moveType {  case .left:  fromPoint = pointRightCenter  toPoint = pointLeftCenter  case .right:  fromPoint = pointLeftCenter  toPoint = pointRightCenter  case .bottom:  fromPoint = pointBottomCenter  toPoint = pointUpCenter  case .top:  fromPoint = pointUpCenter  toPoint = pointBottomCenter  }   animationView.center = fromPoint  let movePath = UIBezierPath()  movePath.move(to: fromPoint)  movePath.addLine(to: toPoint)   let moveAnimation = CAKeyframeAnimation(keyPath: &amp;#34;position&amp;#34;)  moveAnimation.path = movePath.cgPath  moveAnimation.repeatCount = .infinity  moveAnimation.isRemovedOnCompletion = false   if self.speedType == .special {  moveAnimation.duration = CFTimeInterval(animationViewWidth / 30 * (1 / speed))  }   if self.speedType == .normal {  moveAnimation.duration = CFTimeInterval(2 * (1 / speed))  }   moveAnimation.delegate = self  animationView.layer.add(moveAnimation, forKey: &amp;#34;animationViewPosition&amp;#34;)  }   /// 停止动画  public func stopAnimation() -&amp;gt; Void {  stop = true  animationView.layer.removeAnimation(forKey: &amp;#34;animationViewPosition&amp;#34;)  }   public func animationDidStop(_ anim: CAAnimation, finished flag: Bool) {  delegate?.drawMarqueeView(drawMarqueeView: self, animationDidStopFinished: flag)  if flag &amp;amp;&amp;amp; !stop {  self.startAnimation()  }  }   /// 暂停  public func pauseAnimation() -&amp;gt; Void {  let layer = animationView.layer  let pausedTime = layer.convertTime(CACurrentMediaTime(), from: nil)  layer.speed = 0  layer.timeOffset = pausedTime  }   /// 重启  public func resumeAnimation() -&amp;gt; Void {  let layer = animationView.layer  let pausedTime = layer.timeOffset  layer.speed = 1  layer.timeOffset = 0  layer.beginTime = 0  let timeSincePause = layer .convertTime(CACurrentMediaTime(), from: nil) - pausedTime  layer.beginTime = timeSincePause  } }  public extension NSString {  func calculateWidthWithAttributeText(dic: Dictionary&amp;lt;NSAttributedString.Key, Any&amp;gt;) -&amp;gt; Double {  let rect = self.boundingRect(with: CGSize(width: 10000, height: 20), options: NSStringDrawingOptions.usesLineFragmentOrigin.union(NSStringDrawingOptions.usesFontLeading).union(NSStringDrawingOptions.usesDeviceMetrics), attributes: dic, context: nil)  return Double(ceil(rect.size.width))  } } public protocol JXMarqueeViewCopyable {  /// 如果视图里面有圆角、阴影等，仅通过NSKeyedArchiver、NSKeyedUnarchiver相关方法，会丢失对应信息。所以，这种特殊情况需要自定义返回。  /// 重新拷贝一份目标视图。不能返回视图自己，需要重新创建一个实例。  /// 第一种方案，实现required init?(coder aDecoder: NSCoder) 初始化器，返回一个新实例。参考CustomCopyView  /// 第二种方案，重载func copyMarqueeView() -&amp;gt; UIView方法，返回一个新实例。参考CustomCopyView  ///  /// - Returns: new view  func copyMarqueeView() -&amp;gt; UIView }  extension UIView: JXMarqueeViewCopyable {  @objc open func copyMarqueeView() -&amp;gt; UIView {  //UIView是没有遵从拷贝协议的。可以通过UIView支持NSCoding协议，间接来复制一个视图  let archivedData = NSKeyedArchiver.archivedData(withRootObject: self)  let copyView = NSKeyedUnarchiver.unarchiveObject(with: archivedData) as! UIView  return copyView  } }  public enum JXMarqueeType {  case left  case right  case reverse }  public class JXMarqueeView: UIView {  public var marqueeType: JXMarqueeType = .left  public var contentMargin: CGFloat = 12 //两个视图之间的间隔  public var frameInterval: Int = 1 //多少帧回调一次，一帧时间1/60秒  public var pointsPerFrame: CGFloat = 0.5 //每次回调移动多少点  public var contentView: UIView? {  didSet {  self.setNeedsLayout()  }  }  public var contentViewFrameConfigWhenCantMarquee: ((UIView)-&amp;gt;())? //当contentView的内容宽度没有超过显示宽度，无需开启跑马灯效果。这个时候contentView的size，默认是调用sizeToFit之后的尺寸。如果想要特殊配置，比如让contentView的size等于JXMarqueeView，就需要在该闭包自定义配置。  private let containerView = UIView()  private var marqueeDisplayLink: CADisplayLink?  private var isReversing = false   override open func willMove(toSuperview newSuperview: UIView?) {  //当视图将被移除父视图的时候，newSuperview就为nil。在这个时候，停止掉CADisplayLink，断开循环引用，视图就可以被正确释放掉了。  if newSuperview == nil {  self.stopMarquee()  }  }   public init() {  super.init(frame: CGRect.zero)   self.initializeViews()  }   override public init(frame: CGRect) {  super.init(frame: frame)   self.initializeViews()  }   required public init?(coder aDecoder: NSCoder) {  super.init(coder: aDecoder)   self.initializeViews()  }   func initializeViews() {  self.backgroundColor = UIColor.clear  self.clipsToBounds = true   containerView.backgroundColor = UIColor.clear  self.addSubview(containerView)  }   override open func layoutSubviews() {  super.layoutSubviews()   guard let validContentView = contentView else {  return  }  containerView.subviews.forEach {$0.removeFromSuperview() }   //对于复杂的视图，需要自己重写contentView的sizeThatFits方法，返回正确的size  validContentView.sizeToFit()  containerView.addSubview(validContentView)   if marqueeType == .reverse {  containerView.frame = CGRect(x: 0, y: 0, width: validContentView.bounds.size.width, height: self.bounds.size.height)  }else {  containerView.frame = CGRect(x: 0, y: 0, width: validContentView.bounds.size.width*2 &#43; contentMargin, height: self.bounds.size.height)  }   if validContentView.bounds.size.width &amp;gt; self.bounds.size.width {  validContentView.frame = CGRect(x: 0, y: 0, width: validContentView.bounds.size.width, height: self.bounds.size.height)  if marqueeType != .reverse {  let otherContentView = validContentView.copyMarqueeView()  otherContentView.frame = CGRect(x: validContentView.bounds.size.width &#43; contentMargin, y: 0, width: validContentView.bounds.size.width, height: self.bounds.size.height)  containerView.addSubview(otherContentView)  }  self.startMarquee()  }else {  if contentViewFrameConfigWhenCantMarquee != nil {  contentViewFrameConfigWhenCantMarquee!(validContentView)  }else {  validContentView.frame = CGRect(x: 0, y: 0, width: validContentView.bounds.size.width, height: self.bounds.size.height)  self.stopMarquee()  }  }  }   //如果你的contentView的内容在初始化的时候，无法确定。需要通过网络等延迟获取，那么在内容赋值之后，在调用该方法即可。  public func reloadData() {  self.setNeedsLayout()  }   fileprivate func startMarquee() {  self.stopMarquee()   if marqueeType == .right {  var frame = self.containerView.frame  frame.origin.x = self.bounds.size.width - frame.size.width  self.containerView.frame = frame  }   self.marqueeDisplayLink = CADisplayLink.init(target: self, selector: #selector(processMarquee))  self.marqueeDisplayLink?.frameInterval = self.frameInterval  self.marqueeDisplayLink?.add(to: RunLoop.main, forMode: RunLoop.Mode.common)  }   fileprivate func stopMarquee() {  self.marqueeDisplayLink?.invalidate()  self.marqueeDisplayLink = nil  }   @objc fileprivate func processMarquee() {  var frame = self.containerView.frame   switch marqueeType {  case .left:  let targetX = -(self.contentView!.bounds.size.width &#43; self.contentMargin)  if frame.origin.x &amp;lt;= targetX {  frame.origin.x = 0  self.containerView.frame = frame  }else {  frame.origin.x -= pointsPerFrame  if frame.origin.x &amp;lt; targetX {  frame.origin.x = targetX  }  self.containerView.frame = frame  }  case .right:  let targetX = self.bounds.size.width - self.contentView!.bounds.size.width  if frame.origin.x &amp;gt;= targetX {  frame.origin.x = self.bounds.size.width - self.containerView.bounds.size.width  self.containerView.frame = frame  }else {  frame.origin.x &#43;= pointsPerFrame  if frame.origin.x &amp;gt; targetX {  frame.origin.x = targetX  }  self.containerView.frame = frame  }  case .reverse:  if isReversing {  let targetX: CGFloat = 0  if frame.origin.x &amp;gt; targetX {  frame.origin.x = 0  self.containerView.frame = frame  isReversing = false  }else {  frame.origin.x &#43;= pointsPerFrame  if frame.origin.x &amp;gt; 0 {  frame.origin.x = 0  isReversing = false  }  self.containerView.frame = frame  }  }else {  let targetX = self.bounds.size.width - self.containerView.bounds.size.width  if frame.origin.x &amp;lt;= targetX {  isReversing = true  }else {  frame.origin.x -= pointsPerFrame  if frame.origin.x &amp;lt; targetX {  frame.origin.x = targetX  isReversing = true  }  self.containerView.frame = frame  }  }  }   }  } JXMarqueeView源码
微信H5支付跳转回App 使用H5调起微信支付，完成支付或者取消支付后默认是回到Safari浏览器，如果想要回到支付前的App，需要利用redirect_url和URL Schema。
class PayAssist {  /// 微信支付url前缀  private let wxPayPrefix = &amp;#34;https://wx.tenpay.com/cgi-bin/mmpayweb-bin/checkmweb?&amp;#34;  private let redirectPrefix = &amp;#34;redirect_url=&amp;#34;   /// Reference from https://juejin.cn/post/6844904038908035085 &amp;amp; https://www.cnblogs.com/panchanggui/p/11693714.html  func callAsFunction(request: URLRequest) -&amp;gt; URLRequest? {  guard let urlStr = request.url?.absoluteString.removingPercentEncoding else {  return nil  }  // prevent secondary replacement  if urlStr.hasPrefix(wxPayPrefix), !isContainPayScheme(urlStr: urlStr) {  var finalUrlStr = &amp;#34;&amp;#34;  var newScheme = &amp;#34;&amp;#34;  let startIndex = urlStr.index(urlStr.startIndex, offsetBy: wxPayPrefix.count)  var strArr = String(urlStr[startIndex..&amp;lt;urlStr.endIndex]).components(separatedBy: &amp;#34;&amp;amp;&amp;#34;)  for (index, str) in strArr.enumerated() {  if str.hasPrefix(redirectPrefix), let payUrl = str.components(separatedBy: redirectPrefix).last, let scheme = findScheme(urlStr: payUrl) {  // remember original redirect_url to use when refreshing  strArr[index] = redirectPrefix &#43; scheme  PayAssistModel.paySchemesAndUrlDict[scheme] = payUrl  newScheme = scheme  break  }  }  finalUrlStr = wxPayPrefix &#43; strArr.joined(separator: &amp;#34;&amp;amp;&amp;#34;)   guard !newScheme.isEmpty,let url = URL(string: finalUrlStr) else {  return nil  }   // construct new request and add Referer  var newRequest: URLRequest = URLRequest(url: url)  newRequest.httpMethod = &amp;#34;Get&amp;#34;  newRequest.setValue(newScheme, forHTTPHeaderField: &amp;#34;Referer&amp;#34;)  return newRequest  }  return nil  }   /// 查找当前url是否包含支持的支付系统的域名，支持则返回对应的scheme，格式为&amp;#34;xxx://&amp;#34;  private func findScheme(urlStr: String) -&amp;gt; String? {  for scheme in MoEnvConfig.current.paySchemes {  if urlStr.contains(scheme.replacingOccurrences(of: &amp;#34;://&amp;#34;, with: &amp;#34;&amp;#34;)) {  return scheme  }  }  return nil  }   /// 是否包含支持的支付系统的scheme  private func isContainPayScheme(urlStr: String) -&amp;gt; Bool {  for scheme in MoEnvConfig.current.paySchemes {  if urlStr.contains(redirectPrefix &#43; scheme) {  return true  }  }  return false  } }  navigation bar黑色 将XCode升级到13.0 并且iOS系统升级到15.0之后发现navigation bar变成了黑色（App已经强制为浅色模式），发现对于navigation bar存在:In iOS 15, UIKit has extended the usage of the scrollEdgeAppearance, which by default produces a transparent background, to all navigation bars.。解决方案如下
if #available(iOS 13.0, *) {  let appearance = UINavigationBarAppearance()  appearance.configureWithOpaqueBackground()  appearance.backgroundColor = .white  appearance.shadowColor = .clear  self.navigationController?.navigationBar.standardAppearance = appearance  self.navigationController?.navigationBar.scrollEdgeAppearance = appearance } 参考资料 参考资料 参考资料
tabbar黑色 将XCode升级到13.0 并且iOS系统升级到15.0之后发现Tabbar变成了黑色（App已经强制为浅色模式），感觉tabbar应该也应该是上面的原因导致的。解决方案如下：
if #available(iOS 15.0, *) {  let appearance = UITabBarAppearance()  appearance.configureWithOpaqueBackground()  appearance.backgroundColor = .white  appearance.shadowColor = .clear  self.tabBar.standardAppearance = appearance  self.tabBar.scrollEdgeAppearance = appearance } 还有一个更简单的解决方案，就是直接将tabbar的背景色设置为白色，即self.tabBar.backgroundColor = .white也能解决问题。
toolBar黑色 let toolAppearance = UIToolbarAppearance() toolAppearance.configureWithOpaqueBackground() UIToolbar.appearance().standardAppearance = toolAppearance UIToolbar.appearance().scrollEdgeAppearance = toolAppearance UIToolbar.appearance().backgroundColor = .white sectionHeaderTopPadding 将XCode升级到13.0 并且iOS系统升级到15.0之后发现，tableView中设置的header高度比实际的高度要高，此时需要将tableView的sectionHeaderTopPadding属性设置为0：
if #available(iOS 15.0, *) {  self.tableView.sectionHeaderTopPadding = 0 } 如果对每个tableView都重新设置一遍tableView.sectionHeaderTopPadding = 0未免太繁琐。实际上可以设置全局生效，代码如下所示：
UITableView.appearance().sectionHeaderTopPadding = 0 参考资料
decode数组 定义结构体使用Codable协议时，对应model中有codable数组时，发现使用JSONSerialization.data(withJSONObject: $0, options: .fragmentsAllowed)获取到的data无法转换为model。这是因为使用默认的encode方法时发生了异常，例如定义的结构体中有[ArdPosModel]数组：
/// 兼岗信息 var ardPosInfos: [ArdPosModel]? 但使用默认的encode方法后，存储到数据库中后ardPosInfos增加了一对括号。如果再使用默认的decode方法则会报错：
(  {  groupId = 0000000000;  orgId = 100001;  pathId = &amp;#34;&amp;#34;;  pathName = &amp;#34;\U62db\U5546\U94f6\U884c&amp;#34;;  position = &amp;#34;\U603b\U5de5&amp;#34;;  userId = 009060;  userName = &amp;#34;\U5f20\U5f66\U6625&amp;#34;;  userOrd = 0;  } ) 一种可行的解决方案是自定义encode方法，然后在对ardPosInfos序列化的时候转成字符串，然后在对ardPosInfos进行decode的时候特殊处理：
let encoder = JSONEncoder() encoder.outputFormatting = .prettyPrinted if let infos = ardPosInfos, !infos.isEmpty, let data = try? encoder.encode(infos), let str = String(data: data, encoding: String.Encoding.utf8) {  try container.encodeIfPresent(str, forKey: .ardPosInfos) } if let infos = try? container.decode(Array&amp;lt;ArdPosModel&amp;gt;.self, forKey: .ardPosInfos) {  ardPosInfos = infos } else {  if let infosStr = try? container.decode(String.self, forKey: .ardPosInfos), let data = infosStr.data(using: .utf8), let infos = try? JSONDecoder().decode([ArdPosModel].se from: data) {  ardPosInfos = infos  } } 参考资料
多关键字Decode 最近后台接口改造，新接口和旧接口一起在用，虽然返回的JSON结构是一样的，但是字段名字有一些差别。例如，新接口使用userId，而就接口使用UserID或者userID。Swift中默认的Decode需要完全匹配关键字才能反序列化，下面是多关键字解决方案：
public struct AnyKey: CodingKey {  public var stringValue: String  public var intValue: Int?  public init(stringValue: String) {  self.stringValue = stringValue  }   public init?(intValue: Int) {  self.stringValue = String(intValue)  self.intValue = intValue  } }  public extension KeyedDecodingContainer where K == AnyKey {  func decode&amp;lt;T&amp;gt;(_ type: T.Type, forMappedKey key: String, in keyMap: [String: [String]]) throws -&amp;gt; T where T: Decodable {  for key in keyMap[key] ?? [] {  if let value = try? decode(T.self, forKey: AnyKey(stringValue: key)) {  return value  }  }  return try decode(T.self, forKey: AnyKey(stringValue: key))  } } public init(from decoder: Decoder) throws {  let keyMap = [  CodingKeys.userId.rawValue: [&amp;#34;userId&amp;#34;, &amp;#34;UserID&amp;#34;, &amp;#34;userID&amp;#34;],  CodingKeys.userName.rawValue: [&amp;#34;userName&amp;#34;, &amp;#34;UserName&amp;#34;],  CodingKeys.namePinYin.rawValue: [&amp;#34;namePinyin&amp;#34;],  ]  let container = try decoder.container(keyedBy: AnyKey.self)  func decode&amp;lt;Value&amp;gt;(_ key: String) throws -&amp;gt; Value where Value: Decodable {  return try container.decode(Value.self, forMappedKey: key, in: keyMap)  }  userId = (try? decode(CodingKeys.userId.rawValue)) ?? &amp;#34;&amp;#34;  userName = (try? decode(CodingKeys.userName.rawValue)) ?? &amp;#34;&amp;#34;  namePinYin = try? decode(CodingKeys.namePinYin.rawValue) } struct Foo: Decodable {  let contentIDs: [String]   enum CodingKeys: String, CodingKey, CaseIterable {  case contentIds, Ids, IDs  }   init(from decoder: Decoder) throws {  let container = try decoder.container(keyedBy: CodingKeys.self)  if let key = container.allKeys.filter({ CodingKeys.allCases.contains($0) }).first, let ids = try container.decodeIfPresent([String].self, forKey: key) {  self.contentIDs = ids  } else {  self.contentIDs = []  }  } } 参考资料
Bool Encode 使用默认encode方法序列化Bool类型时，最终是以integer类型存储至sqlite表中，其中false以0存储，true以1存储。但如果再使用Bool类型去decode则会报类型错误，应该使用int类型，然后根据得到的值转换为Bool类型：
public init(from decoder: Decoder) throws {  let keyMap = [  CodingKeys.hasChild.rawValue: [&amp;#34;hasChild&amp;#34;],  ]  let container = try decoder.container(keyedBy: AnyKey.self)  func decode&amp;lt;Value&amp;gt;(_ key: String) throws -&amp;gt; Value where Value: Decodable {  return try container.decode(Value.self, forMappedKey: key, in: keyMap)  }   // 特殊处理hasChild  if let hasChild: Bool = try? decode(CodingKeys.hasChild.rawValue) {  self.hasChild = hasChild  } else {  let tmp: Int = try decode(CodingKeys.hasChild.rawValue)  hasChild = (tmp == 1 ? true : false)  } } wireshark 在macOS中使用wireshark需要调整系统的安全策略，即需要关闭SIP系统完整性保护。对于intel和m1芯片来说，关闭sip系统完整性保护的方法不一样，具体可以参考macwk提供的方法。如果不关闭完整性保护，使用rvictl -s xxx-xxx命令时，会提示如下错误：
Starting device xxx-xxx [FAILED] 一旦关闭sip系统完整性保护后，再执行rvictl -s xxx-xxx后，显示Starting device xxx-xxx [SUCCEEDED] with interface rvi0表示成功。如果依然报错，则需要在系统设置---&amp;gt;安全性与隐私界面点击启用系统扩展，然后关机即可，具体参考启动失败。
其中的xxx是手机的udid。可以在finder中查到，也可以在Xcode---&amp;gt;Window---&amp;gt;Devices选中对应的设备，然后在Identifier后面看到udid。
使用wireshark时，想查看http请求的响应时间，可以在Column Preferences中添加自定义字段 http.time，具体参考这里。
基本使用 时间曲线
URLComponents 学习资料
百度地图sdk版本 项目中引入了百度地图的SDK，如果想要查看百度地图SDK的版本，可以直接在控制台或代码中使用BMKGetMapApiVersion()函数来获取当前版本：
BMKGetMapApiVersion() (lldb) po BMKGetMapApiVersion() ▿ Optional&amp;lt;String&amp;gt;  - some : &amp;#34;4.3.0&amp;#34; 百度定位sdk版本 项目中引入了百度定位的SDK，如果想要查看百度定位SDK的版本，可以直接在控制台或代码中使用BMKLocationKitVersion()函数来获取当前版本：
BMKLocationKitVersion() (lldb) po BMKLocationKitVersion() ▿ Optional&amp;lt;String&amp;gt;  - some : &amp;#34;2.0.0&amp;#34; 高德定位sdk版本 项目中引入了高德定位的SDK，如果想要查看高德定位SDK的版本，可以直接在控制台或代码中使用AMapLocationVersion变量来获取当前版本：
AMapLocationVersion (lldb) po AMapLocationVersion &amp;#34;2.6.8&amp;#34; 显示Product目录 老工程使用XCode 13.1打开后发现左侧导航栏的product目录消失了。此时需要到Xcode菜单栏中的Product--&amp;gt;Show Build Folder in Finder才能打开Product目录，如下图所示：
Failed import bridging header 在工程中执行单元测试代码时出现Failed to import bridging header &#39;/Users/xxx/Downloads/xxx/xxx/Common/xxx-Bridging-Header.h&#39;错误：
Failed to import bridging header &amp;#39;/Users/xxx/Downloads/xxx/xxx/Common/xxx-Bridging-Header.h&amp;#39; 点击工程设置，再点击右上角的Info，再在Configuration下Debug或Release找到对应的Tests，发现右侧的值为None。为了解决报错，只需要将其值改为待测试的Pod Target即可：
runJavaScriptAlertPanelWithMessage 今天测试H5的时候出现了闪退，报错信息为webView:runJavaScriptAlertPanelWithMessage:initiatedByFrame:completionHandler:] was not called。出现这个错误的原因是当前显示的页面不是WebView所在的页面（可能是被其他页面遮挡了），然后又去让WebViewController执行回调，也可能是WebView所在的页面被释放掉了。
webView:runJavaScriptAlertPanelWithMessage:initiatedByFrame:completionHandler:] was not called Could not find specified service 解决方案
Permission to debug com.cnn.iphone was denied https://stackoverflow.com/questions/28039524/instruments-stopped-working-on-iphone-apps/65785028#65785028
signed with a development identity Recovery Suggestion: The app must be signed with a development identity (e.g. iOS Developer). https://stackoverflow.com/questions/18905450/cant-launch-my-app-in-instruments-at-least-one-target-failed-to-launch/19258211#19258211
The certificate for this server is invalid 最近有个业务系统使用UIWebView打开时出现了白屏。经过排查发现该证书没有过期，但是域名和证书不匹配，导致出现如下所示报错：
&amp;#34;The certificate for this server is invalid. You might be connecting to a server that is pretending to be “wi.cloud.cmbchina.com” which could put your confidential information at risk.&amp;#34; 临时的解决方案是使用私有API放开这种证书有问题的域名：
@interface NSURLRequest (MoURLRequestCertificate) &#43; (BOOL)allowsAnyHTTPSCertificateForHost:(NSString*)host; &#43; (void)setAllowsAnyHTTPSCertificate:(BOOL)allow forHost:(NSString*)host; @end @implementation NSURLRequest &#43; (BOOL)allowsAnyHTTPSCertificateForHost:(NSString*)host {  return true; } 参考资料
KingFisher erminated due to memory issue 在UITableView中使用KingFisher加载图片时，若对应的url为gif图片，滑动的时候可能出现内存问题，导致App异常退出。
debug时Xcode会提示Message from debugger: Terminated due to memory issue。此时解决方案有两种，第一种是在调用kf.setImage时在options参数中增加onlyLoadFirstFrame参数。那么此时只会加载gif的第一帧，自然也不会导致内存溢出：
setImage(with: source, placeholder: defaultImage, options: [.onlyLoadFirstFrame]) 第二种解决方案是使用KingFisher提供的AnimatedImageView。此时，当url是普通的图片时会正常显示，若是gif则会自动显示动画。但千万要注意需要把runLoopMode = .default，否则滚动的时候依然会有内存问题：
self.dkImageView.autoPlayAnimatedImage = true self.dkImageView.needsPrescaling = true self.dkImageView.backgroundDecode = true self.dkImageView.framePreloadCount = 1 self.dkImageView.runLoopMode = .default self.dkImageView.repeatCount = .once  override func prepareForReuse() {  super.prepareForReuse()  self.headerImageView.kf.cancelDownloadTask()  self.headerImageView.stopAnimating()  self.dkImageView.kf.cancelDownloadTask()  self.dkImageView.stopAnimating() } 二进制重排 如果想要获取二进制重排需要的order文件，可以直接引用AppOrderFiles组件：
pod &amp;#39;AppOrderFiles&amp;#39; 然后在Podfile文件中添加如下代码，完成必要的设置：
post_install do |installer|  installer.pods_project.targets.each do |target|  target.build_configurations.each do |config|  config.build_settings[&amp;#39;OTHER_CFLAGS&amp;#39;] = &amp;#39;-fsanitize-coverage=func,trace-pc-guard&amp;#39;  config.build_settings[&amp;#39;OTHER_SWIFT_FLAGS&amp;#39;] = &amp;#39;-sanitize-coverage=func -sanitize=undefined&amp;#39;  end  end end 最后在代码中添加以获取重排文件，重新编译安装后，再导出安装包数据，在tmp文件下找到app.order:
AppOrderFiles() { path in  debugPrint(path ?? &amp;#34;&amp;#34;) } AppOrderFiles
Library not loaded 如果项目之前没有报错，在某次编译时突然出现Library not loaded @rpath/libswiftAssetsLibrary.dylib错误，则需要清空工程缓存，重新编译。
dyld: Library not loaded: @rpath/libswiftAssetsLibrary.dylib  Referenced from: /var/containers/Bundle/Application/C219593F-9265-4F99-8947-AFBD4A430AAC/xxx.app/xxx  Reason: image not found dyld: Library not loaded: /System/Library/Frameworks/Network.framework/Network  Referenced from: /var/containers/Bundle/Application/712C7509-626F-4B42-83F3-EA3537A6D9A1/xxx.app/xxx  Reason: image not found 参考资料
443 Operation timed out 在安装
解决方案
ValidHexNumber /// 校验给定字符串是否为16进制字符串 /// - Parameter iv: iv字符串 /// - Returns: 是否合法的16进制字符串 private func isValidHexNumber(iv: String) -&amp;gt; Bool {  let chars = CharacterSet(charactersIn: &amp;#34;0123456789ABCDEF&amp;#34;).inverted  guard iv.uppercased().rangeOfCharacter(from: chars) == nil else {  return false  }  return true } private func isValidHexNumber(iv: String) -&amp;gt; Bool {  return iv.allSatisfy(\.isHexDigit) } 当前页面是否正显示 如果要判断当前页面是否正在显示，可以使用如下两种方式，代码如下所示：
/// 判断当前页面是否正在显示 private func isDisplaying() -&amp;gt;Bool {  // 参考自https://programmersought.com/article/99624367116/  return (self.isViewLoaded &amp;amp;&amp;amp; self.view.window != nil) } private func isDisplaying() -&amp;gt;Bool {  // 参考自https://stackoverflow.com/questions/2777438/how-to-tell-if-uiviewcontrollers-view-is-visible  return self.viewIfLoaded?.window != nil } duplicate symbols for architecture arm64 duplicate symbol &amp;#39;_OBJC_CLASS_$_CMBSMDLL&amp;#39; in:  /Users/xxx/Downloads/xxx/Pods/LC10_AiLabFaceRecognitionCloud/Encrypt/lib-china-sm-iphoneos.a(SMDLL.o)  /Users/xxx/Downloads/xxx/Pods/LC10_01_MPGMK/SDK/MPGMK.framework/MPGMK(SMDLL.o) duplicate symbol &amp;#39;_OBJC_METACLASS_$_CMBSMDLL&amp;#39; in:  /Users/xxx/Downloads/xxx/Pods/LC10_AiLabFaceRecognitionCloud/Encrypt/lib-china-sm-iphoneos.a(CMBSMDLL.o)  /Users/xxx/Downloads/xxx/Pods/LC10_01_MPGMK/SDK/MPGMK.framework/MPGMK(SMDLL.o) ld: 2 duplicate symbols for architecture arm64 clang: error: linker command failed with exit code 1 (use -v to see invocation) 将Other Linker Flags设置中的-force_load去掉。
参考资料
取消刷新时的动画 使用reloadRows(at: [indexPath], with: .none)对tableView某个单元格刷新时，即使第2个参数已经设置为.none，仍然有明显的刷新效果，为了取消这种动画效果，需要使用performWithoutAnimation：
UIView.performWithoutAnimation {  self.tableView.reloadRows(at: [indexPath], with: .none) } 如果在reloadData数据时有动画，但想要一种更丝滑的方式加载，即去除动画效果（Used when loading more data into UITableView for a smooth &amp;quot;infinite scroll&amp;quot; feel），可以尝试使用如下代码：
/// 流畅版reloadData，避免闪烁和动画 func reloadDataSmoothly() {  UIView.setAnimationsEnabled(false)  CATransaction.begin()  CATransaction.setCompletionBlock {  UIView.setAnimationsEnabled(true)  }  reloadData()  beginUpdates()  endUpdates()  CATransaction.commit() } 参考资料
清除WK缓存和Cookie private func clearAllCookies() {  URLCache.shared.removeAllCachedResponses()  HTTPCookieStorage.shared.cookies?.forEach(HTTPCookieStorage.shared.deleteCookie)  let types = Set([WKWebsiteDataTypeDiskCache,  WKWebsiteDataTypeMemoryCache,  WKWebsiteDataTypeOfflineWebApplicationCache,  WKWebsiteDataTypeCookies,  WKWebsiteDataTypeSessionStorage,  WKWebsiteDataTypeLocalStorage,  WKWebsiteDataTypeWebSQLDatabases,  WKWebsiteDataTypeIndexedDBDatabases])  WKWebsiteDataStore.default().fetchDataRecords(ofTypes: types) { (records) in  WKWebsiteDataStore.default().removeData(ofTypes: types, for: records) {  debugPrint(&amp;#34;WK domain cleaned cache&amp;#34;)  }  } } 如果要按照域名来清除WKWebView的缓存和Cookie，可以使用如下代码：
public extension WKWebView {   static func cleanCache(url: URL) {   HTTPCookieStorage.shared.cookies?.forEach({ (cookie) in  guard let url = url.host else {  return  }  // domain前面带.表示子域发送http请求时会自动带上  if cookie.domain == url || cookie.domain == &amp;#34;.&amp;#34; &#43; url {  HTTPCookieStorage.shared.deleteCookie(cookie)  }  })   let types = Set([WKWebsiteDataTypeDiskCache,  WKWebsiteDataTypeMemoryCache,  WKWebsiteDataTypeOfflineWebApplicationCache,  WKWebsiteDataTypeCookies,  WKWebsiteDataTypeSessionStorage,  WKWebsiteDataTypeLocalStorage,  WKWebsiteDataTypeWebSQLDatabases,  WKWebsiteDataTypeIndexedDBDatabases])  WKWebsiteDataStore.default().fetchDataRecords(ofTypes: types) { (records) in  let tmpRecord = records.filter({ url.host?.hasSuffix($0.displayName) ?? false })  WKWebsiteDataStore.default().removeData(ofTypes: types, for: tmpRecord) {  debugPrint(&amp;#34;WK domain cleaned cache&amp;#34;)  }  }  URLCache.shared.removeCachedResponse(for: URLRequest(url: url))  } } url中文编码 /// url中文转码，其中#不转码 var urlChineseEncoding: String? {  var charSet = CharacterSet.urlQueryAllowed  charSet.insert(charactersIn: &amp;#34;#&amp;#34;)  return self.addingPercentEncoding(withAllowedCharacters: charSet) } 参考资料
failed to parse error: expression failed to parse: error: Couldn&amp;#39;t realize type of self. AppCode 使用AppCode编译工程时，一直报错
点击Debug Log Settings后添加如下的设置：
#com.jetbrains.cidr.execution.deviceSupport #com.jetbrains.cidr.execution.debugger 接着重新编译，直到报错信息出来，然后再在工具栏点击Help--&amp;gt;Show Log in Finder，打开日志文件idea.log。发现有如下所示报错：
FINE - #c.j.c.e.debugger - LLDBFrontend: E0505 14:41:25.368477 338892288 TCPClient.cpp:103] ERROR, no such host as localhost 原因是hosts文件中缺少127.0.0.1 localhost，只要添加这一条即可：
127.0.0.1 localhost 互斥单选 如果要实现UITableView中的cell互斥单选，并且至少有一个cell被选中时，可以使用如下代码实现：
 override func setSelected(_ selected: Bool, animated: Bool) {  super.setSelected(selected, animated: animated)  if selected {  self.checkImgView.image = UIImage(named: checekedImgName)  } else {  self.checkImgView.image = UIImage(named: uncheckedImgName)  }  } iOS simulator 如果在模拟器上编译代码时出现Could not find module for target &#39;x86_64-apple-ios-simulator&#39;，那就是编译架构没有选择x86_64:
参考资料
didFailProvisionalLoadForFrame ST环境App出现帧框加载已中断的提示，复现步骤为编译安装ST包，但网络切到外网。拿到的报错信息如下所示：
2022-07-14 14:35:36.725525&#43;0800 CMBMobileST[83366:5125532] [Process] 0x113199c18 - [pageProxyID=18, webPageID=19, PID=83370] WebPageProxy::didFailProvisionalLoadForFrame: frameID=3, domain=WebKitErrorDomain, code=102, isMainFrame=1 调试发现是热点轻应用导致的报错，按照网上的资料，说是四种情况会出现这个，分别是：
 url未添加scheme 使用webview打开本地文件时未正确设置contentType 服务端未正确响应 重定向导致  前面两种情况可以排除，通过排查其他应用，基本也可以排除第3种情况，怀疑是第4种情况。使用下面代码临时规避：
let err = (error as NSError) switch (err.code, err.domain) { case (NSURLErrorCancelled, _), (102, &amp;#34;WebKitErrorDomain&amp;#34;):  printDebug(msg: err.localizedDescription) default:  FlashAlertView(message: error.localizedDescription, delegate: nil).show() } 参考资料
TLS10 is not accepted 使用IntelliJ IDEA连接Microsoft SQL Server时会提示The server selected protocol version TLS10 is not accepted by client preferences [TLS13, TLS12]：
[08S01] The driver could not establish a secure connection to SQL Server by using Secure Sockets Layer (SSL) encryption. Error: &amp;#34;The server selected protocol version TLS10 is not accepted by client preferences [TLS13, TLS12]&amp;#34;. ClientConnectionId:a8fbe132-f476-412f-ad23-4f53516c5007 The server selected protocol version TLS10 is not accepted by client preferences [TLS13, TLS12]. 查资料发现，这是因为IDEA版本升级后，自带的jdk版本也升级了，所以需要删除自带的jdk对应的java.security中的对应内容。java.security对应的路径为/Applications/IntelliJ IDEA.app/Contents/jbr/Contents/Home/conf/security/java.security，大约在731行注释即可：
# jdk.tls.disabledAlgorithms=SSLv3, TLSv1, TLSv1.1, RC4, DES, MD5withRSA, \  DH keySize &amp;lt; 1024, EC keySize &amp;lt; 224, 3DES_EDE_CBC, anon, NULL, \ iOS 14&#43;以上无法安装企业App 最近自动化部署改造，将待安装的ipa文件挪到其它位置，使用iOS 14以上系统验证的时候发现无法安装，但没有任何提示。测试发现，ipa的链接能够正常下载，也能够单独安装。后来服务端排查发现，虽然plist文件是放在https服务器的，但是ipa却存放在http的域名下，因此无法正常安装。
  plist文件必须是放在https服务器
  主要是对于ipa是否要放在https服务器，两种办法: 如果是域名访问ipa,必须是https服务器。如果是ip访问ipa，https和http服务器都是可以的。
参考资料
  xcframework 生成xcframework的工程设置了最低支持的版本，如果在不支持的版本的真机上编译时，会出现如下启动闪退，只需要将最低支持版本调整一下即可：
Thread 3 Crashed: 0 dyld 0x000000010a9a47d0 __abort_with_payload &#43; 8 1 dyld 0x000000010a9a3d80 abort_with_payload_wrapper_internal &#43; 104 2 dyld 0x000000010a9a3db4 fcntl &#43; 0 3 dyld 0x000000010a960b40 dyld::fastBindLazySymbol&#43; 19264 (ImageLoader**, unsigned long) &#43; 0 4 dyld 0x000000010a960c6c dyld::fastBindLazySymbol&#43; 19564 (ImageLoader**, unsigned long) &#43; 300 5 libdyld.dylib 0x00000001837d8738 _dyld_fast_stub_entry&#43; 18232 (void*, long) &#43; 80 6 libdyld.dylib 0x00000001837d7240 dyld_stub_binder &#43; 60 7 CMBMobileST 0x00000001063a5064 &#43;[MPSM3 dataDigestFromMsg:] &#43; 108 8 CMBMobileST 0x00000001063a4f5c &#43;[MPSM3 stringDigestFromMsg:] &#43; 36 Stored properties cannot be marked potentially unavailable with &amp;lsquo;@available&amp;rsquo; 如果不想大改代码，临时的解决方案如下：
#if compiler(&amp;lt;5.7) #endif 参考资料
does not contain bitcode. You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE), obtain an updated library from the vendor, or disable bitcode for this target 在设置中将对应的framework的设置中Enable Bitcode改为No即可：
error build: &amp;#39;/Users/xxx/Library/Developer/Xcode/DerivedData/xxx-fjdqujfoagssicejpisepgndqmsf/Build/Products/Debug-iphoneos/xxx/xxx.framework/xxx(xxx-dummy.o)&amp;#39; does not contain bitcode. You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE), obtain an updated library from the vendor, or disable bitcode for this target. file &amp;#39;/Users/xxx/Library/Developer/Xcode/DerivedData/xxx-fjdqujfoagssicejpisepgndqmsf/Build/Products/Debug-iphoneos/xxx/xxx.framework/xxx&amp;#39; for architecture arm64 Signing for &amp;ldquo;xxx&amp;rdquo; requires a development team. Select a development team in the Signing &amp;amp; Capabilities editor. (in target &amp;lsquo;xxx&amp;rsquo; from project &amp;lsquo;Pods&amp;rsquo; post_install do |installer|  installer.generated_projects.each do |project|  project.targets.each do |target|  target.build_configurations.each do |config|  config.build_settings[&amp;#34;DEVELOPMENT_TEAM&amp;#34;] = &amp;#34; Your Team ID &amp;#34;  end  end  end end 参考资料
</content>
    </entry>
    
     <entry>
        <title>一些问题的解决方案2022</title>
        <url>https://iihui.github.io/post/ios-solutions-2022/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> Missing Package Product 在github上拉取了uPic工程源代码，编译时出现了包缺失的错误(Missing Package Product)，具体报错信息如下图所示：
参考这个解决方案，首先打开工程，然后在菜单栏的File--&amp;gt;Packages--&amp;gt;Reset PackageCaches点击一下，等待Xcode重置缓存完成后，发现还是不能拉取依赖包：
查找资料发现Xcode中拉取Swift Package是不走系统代理的，也就是说即使打开全局代理模式，依然也不能解决SPM的拉取问题。
但是，开启全局代理模式后，在浏览器中直接访问github速度很快，说明在全局模式下访问是没问题。根据这个解决方案，需要先完全关闭Xcode，然后在终端设置临时代理：
# 设置临时代理 export all_proxy=http://127.0.0.1:31181 最后进入工程目录执行下面命令拉取依赖：
# 拉取依赖 xcodebuild -resolvePackageDependencies -scmProvider system 如果要取消临时代理，可以参考这篇文章，使用下面命令：
# 取消http代理 unset http_proxy # 取消https代理 unset https_proxy # 取消全部代理 unset ALL_PROXY iOS 16 Scanning barcode 原来的条形码识别功能正常，但用户反馈系统升级到iOS 16后发现扫描条形码很久都没反应。查资料后发现有其他开发者也遇到相同的问题。
测试后发现在iOS 16上条形码和二维码不能同时识别，目前该问题似乎已经在iOS 16.3修复了。在修复之前，发现将条形码竖着放就能正常识别。
depreciation of UIremotekeyboardwindow 原生的笔记功能是通过WebView来实现的，一些自定义功能是通过监听键盘的弹出事件，然后隐藏键盘相关的Window并显示自定义view来实现的。但这种实现方式借助了私有类UIremotekeyboardwindow。
升级到iOS 16后发现自定义的view已不能覆盖键盘视图。查资料发现UIremotekeyboardwindow在iOS 16上已被移除，当前的解决方案是在系统键盘上方增加View来显示原有功能，而不是用自定义view覆盖系统键盘所在位置。
Python添加Module 在Intellij IDEA中写python脚本时引入了第三方库，但在debug时未提示没有相应的module，只要按照这个资料操作即可解决编译报错问题。
Failed to open macho file 调试Swift脚本时出现了Failed to open macho file at xxx Too many levels of symbolic links错误信息，具体如下所示：
Failed to open macho file at /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift for reading: Too many levels of symbolic links 只需参考这个解决方案，添加如下代码即可去除上面的报错信息：
if ProcessInfo.processInfo.environment.keys.contains(&amp;#34;OS_ACTIVITY_DT_MODE&amp;#34;) {  var env = ProcessInfo.processInfo.environment  env[&amp;#34;OS_ACTIVITY_DT_MODE&amp;#34;] = nil  process.environment = env } com.sun.tools.javac.code.TypeTags 编译Java老工程后出现如下所示的错误。查资料后发现是当前工程配置的jdk版本太高，只需在工程中设置使用1.8版本的sdk可解决该报错。
com.sun.tools.javac.code.TypeTags can&amp;rsquo;t find gem cocoapods 使用rvm install 2.6.6命令安装了ruby 2.6.6版本。并使用 rvm use 2.6.6命令将ruby版本切换到2.6.6后，再执行pod lib lint --verbose File.podspec命令时出现如下错误：
/System/Library/Frameworks/Ruby.framework/Versions/2.6/usr/lib/ruby/2.6.0/rubygems.rb:283:in `find_spec_for_exe&amp;#39;: can&amp;#39;t find gem cocoapods (&amp;gt;= 0.a) with executable pod (Gem::GemNotFoundException)  from /System/Library/Frameworks/Ruby.framework/Versions/2.6/usr/lib/ruby/2.6.0/rubygems.rb:302:in `activate_bin_path&amp;#39; from /usr/local/bin/pod:23:in `&amp;lt;main&amp;gt;&amp;#39; 这是因为使用rvm安装的两个ruby版本是隔离，在原ruby版本上安装的cocoapods在新版上不适用。解决方案是执行sudo gem install cocoapods命令安装cocoapods。
find_cached_set 使用的ruby版本为2.7.2，安装的cocoapods版本是1.11.3，执行pod lib lint --verbose File.podspec出现如下错误信息：
ERROR | [iOS] xcodebuild: Returned an unsuccessful exit code.  Pods workspace available at `/var/folders/ns/9rvphkg1387_4zqncdbkbml80000gn/T/CocoaPods-Lint-20221102-21787-112wnq-MoFile/App.xcworkspace` for inspection.  /Users/hui/.rvm/rubies/ruby-2.7.2/lib/ruby/gems/2.7.0/gems/cocoapods-1.11.3/lib/cocoapods/command/lib/lint.rb:113:in `block in run&amp;#39; /Users/hui/.rvm/rubies/ruby-2.7.2/lib/ruby/gems/2.7.0/gems/cocoapods-1.11.3/lib/cocoapods/command/lib/lint.rb:75:in `each&amp;#39; /Users/hui/.rvm/rubies/ruby-2.7.2/lib/ruby/gems/2.7.0/gems/cocoapods-1.11.3/lib/cocoapods/command/lib/lint.rb:75:in `run&amp;#39; /Users/hui/.rvm/gems/ruby-2.7.2/gems/claide-1.1.0/lib/claide/command.rb:334:in `run&amp;#39; /Users/hui/.rvm/rubies/ruby-2.7.2/lib/ruby/gems/2.7.0/gems/cocoapods-1.11.3/lib/cocoapods/command.rb:52:in `run&amp;#39; /Users/hui/.rvm/rubies/ruby-2.7.2/lib/ruby/gems/2.7.0/gems/cocoapods-1.11.3/bin/pod:55:in `&amp;lt;top (required)&amp;gt;&amp;#39; /Users/hui/.rvm/gems/ruby-2.7.2/bin/pod:23:in `load&amp;#39; /Users/hui/.rvm/gems/ruby-2.7.2/bin/pod:23:in `&amp;lt;main&amp;gt;&amp;#39; 排查后发现是升级Xcode到14.0.1导致pod lib lint 失败。解决方案是将xcodebuild临时切到Xcode 13.4.1版本。可以在Xcode--&amp;gt;Preferences...--&amp;gt;Locations--&amp;gt;Command Line Tools中切换版本，修改完成后在终端中使用下面命令查看当前版本：
xcodebuild -version  # 结果 Xcode 13.4.1 Build version 13F100 如果在终端中执行xcodebuild -version命令后输出依然是原来的Xcode版本，就要检查是否已经在终端的配置文件中已经将DEVELOPER_DIR写死为某个版本。因为本机使用的是zsh，查看主目录下的.zshrc后发现之前已经写死了版本，改成13.4.1版本即可。
# 修改前 export DEVELOPER_DIR=&amp;#34;/Applications/XCode beta.app/Contents/Developer&amp;#34;  # 修改后 export DEVELOPER_DIR=&amp;#34;/Applications/XCode 13.4.1.app/Contents/Developer&amp;#34; rvm: command not found 在Intellij IDEA中运行Python脚本时，出现如下所示报错。问题的根源是当前工程未识别到rvm命令的路径，只需在环境变量中将该命令的路径加上即可：
/bin/sh: rvm: command not found simulator listed or otherwise add one 使用pod lib lint命令检查podspec文件时出现了Could not find a ios simulator (valid values: )错误提示。根据提示，只要在Xcode--&amp;gt;Window--&amp;gt;Devices and Simulators中添加一个模拟器即可解决改错误。
ERROR | [iOS] unknown: Encountered an unknown error (Could not find a `ios` simulator (valid values: ). Ensure that Xcode -&amp;gt; Window -&amp;gt; Devices has at least one `ios` simulator listed or otherwise add one 参考资料
getcwd (Errno::ENOENT) 在某个目录下执行sudo gem install cocoapods命令时出现如下错误，原因是用于启动getcwd的目录不存在了。参考这个方案，只要执行一下cd 命令即可。
Error loading RubyGems plugin &amp;#34;/Users/xxx/.rvm/rubies/ruby-2.7.2/lib/ruby/gems/2.7.0/gems/gem-wrappers-1.4.0/lib/rubygems_plugin.rb&amp;#34;: No such file or directory - getcwd (Errno::ENOENT) ERROR: While executing gem ... (Errno::ENOENT)  No such file or directory - getcwd WebKitErrorDomain Code=101 有个业务系统跳转后出现白屏，调试时出现Error Domain=WebKitErrorDomain Code=101 无法显示URL错误，具体信息如下：
Error Domain=WebKitErrorDomain Code=101 &amp;#34;无法显示URL&amp;#34; UserInfo={_WKRecoveryAttempterErrorKey=&amp;lt;WKReloadFrameErrorRecoveryAttempter: 0x2805ad7e0&amp;gt;, NSErrorFailingURLStringKey=lc07sbfweb.xxx.xxx./xxx/xxx.html, 排查发现是传入的url字符串前没有http或https协议前缀，加上协议后就能正常跳转。参考这个资料，出现白屏是因为WebView加载了它无法处理的请求。一般来说，是以下几种情况导致的：
 不合法的URL：①非http/https开头的url。②url中含有不合法的字符，此时需要对url进行编码。③url格式不正确。 不合法的系统API。例如tel://写成了tell://。 不合法的App跳转。①未在 LSApplicationQueriesSchemes添加的第三方App跳转。②未安装的App。  Disable entire UIMenuController edit menu in WKWebView 如果想要在WKWebView上禁止长按弹出原生的复制、粘贴等选项，可以覆写canPerformAction方法，让其返回false:
 public override func canPerformAction(_ action: Selector, withSender sender: Any?) -&amp;gt; Bool {  //UIMenuController.shared.isMenuVisible = false  return false  } 也可以通过注入js的方法，不让用户选择和长按：
// 禁止选择 css 配置相关 let css = &amp;#34;body{-webkit-user-select:none;-webkit-user-drag:none;user-select: none;}&amp;#34;  //css 选中样式取消 var javascript = &amp;#34;&amp;#34; javascript &#43;= &amp;#34;var style = document.createElement(&amp;#39;style&amp;#39;);&amp;#34; javascript &#43;= &amp;#34;style.type = &amp;#39;text/css&amp;#39;;&amp;#34; javascript &#43;= &amp;#34;var cssContent = document.createTextNode(&amp;#39;\(css)&amp;#39;);&amp;#34; javascript &#43;= &amp;#34;style.appendChild(cssContent);&amp;#34; javascript &#43;= &amp;#34;document.body.appendChild(style);&amp;#34; // 禁止选择 javascript &#43;= &amp;#34;document.documentElement.style.webkitUserSelect=&amp;#39;none&amp;#39;;&amp;#34; // 禁止长按 javascript &#43;= &amp;#34;document.documentElement.style.webkitTouchCallout=&amp;#39;none&amp;#39;;&amp;#34; // javascript 注入 let noneSelectScript = WKUserScript(source: javascript, injectionTime: .atDocumentEnd, forMainFrameOnly: false) wkConfig.userContentController.addUserScript(noneSelectScript) 参考这个资料，可以设置textInteractionEnabled为false来禁止文本交互。
参考资料
Disable magnification gesture in WKWebView class MyClass {  let webView = WKWebView()   init() {  super.init()  webView.scrollView.delegate = self  }   deinit() {  // Without this, it&amp;#39;ll crash when your MyClass instance is deinit&amp;#39;d  webView.scrollView.delegate = nil  } }  extension MyClass: UIScrollViewDelegate {  func viewForZooming(in scrollView: UIScrollView) -&amp;gt; UIView? {  return nil  } } 参考资料 参考资料
swift_getObjectType Thread 0 Crashed: 0 libswiftCore.dylib 0x00000001889e2d74 swift_getObjectType &#43; 40 1 libswiftCore.dylib 0x000000018860addc _bridgeNonVerbatimFromObjectiveCToAny &#43; 40 2 libswiftCore.dylib 0x000000018899273c tryBridgeNonVerbatimFromObjectiveCUniversal&#43; 3987260 (swift::HeapObject*, swift::TargetMetadata&amp;lt;swift::InProcess&amp;gt; const*, swift::OpaqueValue*) &#43; 176 3 libswiftCore.dylib 0x0000000188992814 _bridgeNonVerbatimFromObjectiveCConditional&amp;lt;A&amp;gt;&#43; 3987476 (_:_:_:) &#43; 40 4 Foundation 0x0000000188ea7b60 specialized static Dictionary._conditionallyBridgeFromObjectiveC&#43; 3439456 (_:result:) &#43; 384 5 libswiftCore.dylib 0x00000001889992e4 _tryCastFromClassToObjCBridgeable&#43; 4014820 (swift::OpaqueValue*, swift::TargetMetadata&amp;lt;swift::InProcess&amp;gt; const*, swift::OpaqueValue*, swift::TargetMetadata&amp;lt;swift::InProcess&amp;gt; const*, void*, swift::TargetMetadata&amp;lt;swift::InProcess&amp;gt; const*&amp;amp;, swift::TargetMetadata&amp;lt;swift::InProcess&amp;gt; const*&amp;amp;, bool, bool, _ObjectiveCBridgeableWitnessTable const*, swift::TargetMetadata&amp;lt;swift::InProcess&amp;gt; const*) &#43; 356 6 libswiftCore.dylib 0x0000000188997268 tryCast&#43; 4006504 (swift::OpaqueValue*, swift::TargetMetadata&amp;lt;swift::InProcess&amp;gt; const*, swift::OpaqueValue*, swift::TargetMetadata&amp;lt;swift::InProcess&amp;gt; const*, swift::TargetMetadata&amp;lt;swift::InProcess&amp;gt; const*&amp;amp;, swift::TargetMetadata&amp;lt;swift::InProcess&amp;gt; const*&amp;amp;, bool, bool) &#43; 3016 7 libswiftCore.dylib 0x0000000188996d9c tryCast&#43; 4005276 (swift::OpaqueValue*, swift::TargetMetadata&amp;lt;swift::InProcess&amp;gt; const*, swift::OpaqueValue*, swift::TargetMetadata&amp;lt;swift::InProcess&amp;gt; const*, swift::TargetMetadata&amp;lt;swift::InProcess&amp;gt; const*&amp;amp;, swift::TargetMetadata&amp;lt;swift::InProcess&amp;gt; const*&amp;amp;, bool, bool) &#43; 1788 Thread 0 name: Dispatch queue: com.apple.main-thread Thread 0 Crashed: 0 libswiftCore.dylib 0x00000001bd38da70 0x1bd149000 &#43; 2378352 1 libswiftCore.dylib 0x00000001bd38da70 0x1bd149000 &#43; 2378352 2 libswiftCore.dylib 0x00000001bd15958c 0x1bd149000 &#43; 66956 3 libswiftCore.dylib 0x00000001bd15c814 0x1bd149000 &#43; 79892 4 TouchCanvas 0x00000001022cbfa8 0x1022c0000 &#43; 49064 5 TouchCanvas 0x00000001022c90b0 0x1022c0000 &#43; 37040 https://github.com/ChatSecure/ChatSecure-iOS/issues/1034
https://github.com/apple/swift/issues/50259
https://stackoverflow.com/questions/33236829/swift-type-casting-issue
https://github.com/apple/swift/blob/main/stdlib/public/runtime/Casting.cpp
#if (selMethod==0)  // .....  #else if (selMethod==1)  // ....  #else if (selMethod==2)  // ....  #else  #error &amp;#34;Illegal selMethod definition.&amp;#34;  #endif nc -vz -w 2 ip port https://zhuanlan.zhihu.com/p/577209888
https://superuser.com/questions/1749364/git-ssh-permission-denied-in-macos-13-ventura
删除Xcode缓存 使用如下命令，可以删除Xcode的缓存：
rm -r ~/Library/Developer/Xcode/iOS\ DeviceSupport url中文转码处理 extension String {   // 转为合法的url  func urlEncoded() -&amp;gt; String {  let encodeUrlString = self.addingPercentEncoding(withAllowedCharacters:  .urlQueryAllowed)  return encodeUrlString ?? &amp;#34;&amp;#34;  }   // 还原url  func urlDecoded() -&amp;gt; String {  return self.removingPercentEncoding ?? &amp;#34;&amp;#34;  } } ShyView import UIKit  public class ShyView: UIView {   lazy var hiddenView: UIView? = {  let hiddenView: UIView  let textField = UITextField()  textField.isSecureTextEntry = true  hiddenView = textField.layer.sublayers?.first?.delegate as! UIView  hiddenView.subviews.forEach { $0.removeFromSuperview() }  hiddenView.isUserInteractionEnabled = true  return hiddenView  }()   required init?(coder: NSCoder) {  fatalError(&amp;#34;init(coder:) has not been implemented&amp;#34;)  }   public init?(_ subview: UIView) {  super.init(frame: .zero)  let textField = UITextField()  textField.isSecureTextEntry = true  guard let hiddenView = textField.layer.sublayers?.first?.delegate as? UIView  else {  print(&amp;#34;Something doesn&amp;#39;t work, please fill an issue with your OS and device version.&amp;#34;)  return nil  }  hiddenView.subviews.forEach { $0.removeFromSuperview() }  hiddenView.isUserInteractionEnabled = true  backgroundColor = .clear  hiddenView.translatesAutoresizingMaskIntoConstraints = false  addSubview(hiddenView)  NSLayoutConstraint.activate([  hiddenView.leadingAnchor.constraint(equalTo: leadingAnchor),  hiddenView.trailingAnchor.constraint(equalTo: trailingAnchor),  hiddenView.bottomAnchor.constraint(equalTo: bottomAnchor),  hiddenView.topAnchor.constraint(equalTo: topAnchor)  ])   subview.translatesAutoresizingMaskIntoConstraints = false  hiddenView.addSubview(subview)  NSLayoutConstraint.activate([  hiddenView.leadingAnchor.constraint(equalTo: subview.leadingAnchor),  hiddenView.trailingAnchor.constraint(equalTo: subview.trailingAnchor),  hiddenView.bottomAnchor.constraint(equalTo: subview.bottomAnchor),  hiddenView.topAnchor.constraint(equalTo: subview.topAnchor)  ])  } } // // ScreenShieldView.swift // Swifty // // Created by 王荣庆 on 2019/9/14. // Copyright © 2019 RyukieSama. All rights reserved. //  #if !os(macOS)  import UIKit  @available(iOS 13.0, *) public class ScreenShieldView: UIView {  @objc  public static func create(frame: CGRect = .zero) -&amp;gt; ScreenShieldView {  return ScreenShieldView(frame: frame)  }   private override init(frame: CGRect) {  super.init(frame: frame)  safeZone = makeSecureView() ?? UIView()   if let sf = safeZone {  addSubview(sf)   let layoutDefaultLowPriority = UILayoutPriority(rawValue: UILayoutPriority.defaultLow.rawValue-1)  let layoutDefaultHighPriority = UILayoutPriority(rawValue: UILayoutPriority.defaultHigh.rawValue-1)   sf.translatesAutoresizingMaskIntoConstraints = false  sf.setContentHuggingPriority(layoutDefaultLowPriority, for: .vertical)  sf.setContentHuggingPriority(layoutDefaultLowPriority, for: .horizontal)  sf.setContentCompressionResistancePriority(layoutDefaultHighPriority, for: .vertical)  sf.setContentCompressionResistancePriority(layoutDefaultHighPriority, for: .horizontal)   let top = NSLayoutConstraint.init(item: sf, attribute: .top, relatedBy: .equal, toItem: self, attribute: .top, multiplier: 1, constant: 0)  let bottom = NSLayoutConstraint.init(item: sf, attribute: .bottom, relatedBy: .equal, toItem: self, attribute: .bottom, multiplier: 1, constant: 0)  let leading = NSLayoutConstraint.init(item: sf, attribute: .leading, relatedBy: .equal, toItem: self, attribute: .leading, multiplier: 1, constant: 0)  let trailing = NSLayoutConstraint.init(item: sf, attribute: .trailing, relatedBy: .equal, toItem: self, attribute: .trailing, multiplier: 1, constant: 0)   self.addConstraints([top, bottom, leading, trailing])  }  }   required init?(coder: NSCoder) {  fatalError(&amp;#34;init(coder:) has not been implemented&amp;#34;)  }   public override func addSubview(_ view: UIView) {  guard  let safe = safeZone,  view != safeZone  else {  super.addSubview(view)  return  }  safe.addSubview(view)  }   public override func insertSubview(_ view: UIView, belowSubview siblingSubview: UIView) {  guard  let safe = safeZone,  view != safeZone  else {  super.insertSubview(view, belowSubview: siblingSubview)  return  }  safe.insertSubview(view, belowSubview: siblingSubview)  }   public override func insertSubview(_ view: UIView, aboveSubview siblingSubview: UIView) {  guard  let safe = safeZone,  view != safeZone  else {  super.insertSubview(view, aboveSubview: siblingSubview)  return  }  safe.insertSubview(view, aboveSubview: siblingSubview)  }   public override func insertSubview(_ view: UIView, at index: Int) {  guard  let safe = safeZone,  view != safeZone  else {  super.insertSubview(view, at: index)  return  }  safe.insertSubview(view, at: index)  }   public override func exchangeSubview(at index1: Int, withSubviewAt index2: Int) {  guard  let safe = safeZone  else {  super.exchangeSubview(at: index1, withSubviewAt: index2)  return  }  safe.exchangeSubview(at: index1, withSubviewAt: index2)  }   public override func bringSubviewToFront(_ view: UIView) {  guard  let safe = safeZone,  view != safeZone  else {  super.bringSubviewToFront(view)  return  }  safe.bringSubviewToFront(view)  }   public override func sendSubviewToBack(_ view: UIView) {  guard  let safe = safeZone,  view != safeZone  else {  super.sendSubviewToBack(view)  return  }  safe.sendSubviewToBack(view)  }   private func makeSecureView() -&amp;gt; UIView? {  guard isOSVersionSafe else {  return nil  }   let field = UITextField()  field.isSecureTextEntry = true  let fv = field.subviews.first  fv?.subviews.forEach { $0.removeFromSuperview() }  fv?.isUserInteractionEnabled = true   let errorMsg = &amp;#34;[ScreenShieldView log] Create safeZone failed!&amp;#34; #if DEBUG  precondition(fv != nil, errorMsg) #else  print(errorMsg) #endif   return fv  }   private var safeZone: UIView?   // Some OS version may crash, ignore them before there is a better way.  private var unsafeOSVersion: [String] {  [&amp;#34;15.1&amp;#34;]  }   private var osVersion: String {  UIDevice.current.systemVersion  }   private var isOSVersionSafe: Bool {  for version in unsafeOSVersion {  if osVersion.contains(version) {  return false  }  }  return true  }  }  #endif https://github.com/RyukieSama/Swifty
mach_vm_map (lldb) po dataURL ▿ file:///var/mobile/Containers/Data/Application/19F1736C-3989-426E-B2AB-09A0494E997B/Documents/Statistics/2022-10-01.txt  - _url : file:///var/mobile/Containers/Data/Application/19F1736C-3989-426E-B2AB-09A0494E997B/Documents/Statistics/2022-10-01.txt (lldb) po try? Data(contentsOf: dataURL) xxx(248,0x16b5f7000) malloc: *** mach_vm_map(size=818577408) failed (error code=3) *** error: can&amp;#39;t allocate region *** set a breakpoint in malloc_error_break to debug nil uitableviewcellseparatorview 在
self?.updateHeightConstraint() self?.tableView.reloadData() // 去除无网络或若网情况下iOS 16出现的一小截短分割线_uitableviewcellseparatorview self?.view.layoutIfNeeded() 水印 /// 水印 public class MoWaterMarkView: UIView {  /// 水平间距  private let horzontalSpacing: CGFloat = 70  /// 竖直间距  private let verticalSpacing: CGFloat = 85  /// 旋转角度(正旋45度 || 反旋45度)  private let rotationAngle = -(CGFloat.pi / 4.0)  /// 水印内容和时间的间距  private let contentAndTimeSapcing: CGFloat = 5.0  /// 水印字体大小  private let markFontSize: CGFloat = 15.0  /// 水印字体颜色  private let markColor = UIColor(hex: &amp;#34;000000&amp;#34;).withAlphaComponent(0.05)  /// 记录第一次show时的参数  private var view: UIView?  /// 时间水印  private var time: String?  /// 内容水印  private var content: String?   public private(set) lazy var waterMarkImgView: UIImageView = {  let imgView = UIImageView(frame: self.bounds)  imgView.contentMode = .scaleAspectFill  return imgView  }()   public override init(frame: CGRect) {  super.init(frame: frame)  self.addSubview(waterMarkImgView)  waterMarkImgView.snp.makeConstraints() { maker in  maker.leading.trailing.top.bottom.equalToSuperview()  }  }   deinit {  NotificationCenter.default.removeObserver(self)  }   required init?(coder: NSCoder) {  fatalError(&amp;#34;init(coder:) has not been implemented&amp;#34;)  }   /// 显示固定水印内容: name,sapId以及时间  /// - Parameters:  /// - parent: 待添加水印的view，水印添加到该view上  /// - name: 姓名  /// - sapId: sapId  /// - time: 时间  public static func add(to parent: UIView, name: String, sapId: String, time: String) {  let bounds = fetchBounds()  let waterView = MoWaterMarkView(frame: bounds)  waterView.view = parent  waterView.content = sapId.isEmpty ? name : &amp;#34;\(name)/\(sapId)&amp;#34;  waterView.time = time  waterView.waterMarkImgView.image = waterView.waterImage(size: bounds.size, content: waterView.content!, time: time)  parent.addSubview(waterView)  parent.bringSubviewToFront(waterView)  }   /// 显示定制水印内容&#43;时间  /// - Parameters:  /// - view: 待添加水印的view  /// - content: 定制水印文字  /// - time: 添加水印时的时间  public static func add(to parent: UIView, content: String, time: String) {  let bounds = fetchBounds()  let waterView = MoWaterMarkView(frame: bounds)  waterView.content = content  waterView.time = time  waterView.waterMarkImgView.image = waterView.waterImage(size: bounds.size, content: content, time: time)  parent.addSubview(waterView)  parent.bringSubviewToFront(waterView)  }   /// 从父view中移除水印view  private static func removeWaterView(at parent: UIView?) {  if let oldView = parent {  for item in oldView.subviews where item is MoWaterMarkView {  item.removeFromSuperview()  }  }  }   private static func fetchBounds() -&amp;gt; CGRect {  let bounds = UIScreen.main.bounds  let sideLength = 2*max(bounds.height, bounds.width)  return CGRect(x: bounds.x, y: bounds.y, width: sideLength, height: sideLength)  }   /// 显示定制水印内容&#43;时间  /// - Parameters:  /// - view: 待添加水印的view  /// - content: 定制水印文字  /// - time: 添加水印时的时间  public func show(view: UIView, content: String, time: String) {  // 添加水印之前移除旧的水印，避免多次添加  Self.removeWaterView(at: self.view)  self.view = view  self.content = content  self.time = time  let image = waterImage(size: UIScreen.main.bounds.size, content: content, time: time)  self.waterMarkImgView.image = image  view.addSubview(self)  view.bringSubviewToFront(self)  }   /// 生成水印图片  private func waterImage(size: CGSize, content: String, time: String) -&amp;gt; UIImage? {  let imgW: CGFloat = size.width  let imgH: CGFloat = size.height  // 开启上下文  UIGraphicsBeginImageContextWithOptions(size, false, 0)   // 文字内容  let string1 = content  let string2 = time  // 绘制文字的样式  let paragraphStyle = NSParagraphStyle.default.mutableCopy() as? NSMutableParagraphStyle  paragraphStyle?.alignment = NSTextAlignment.center  paragraphStyle?.lineBreakMode = .byClipping   let attributes1 = [NSAttributedString.Key.foregroundColor: markColor, NSAttributedString.Key.font: UIFont.systemFont(ofSize: markFontSize), NSAttributedString.Key.paragraphStyle: paragraphStyle]  let attributes2 = [NSAttributedString.Key.foregroundColor: markColor, NSAttributedString.Key.font: UIFont.systemFont(ofSize: markFontSize - 3), NSAttributedString.Key.paragraphStyle: paragraphStyle]   let attrStr1 = NSAttributedString(string: string1, attributes: attributes1)  let attrStr2 = NSAttributedString(string: string2, attributes: attributes2)   // 绘制文字的宽高  let str1Width = attrStr1.size().width  let str1Height = attrStr1.size().height  let str2Width = attrStr2.size().width  let str2Height = attrStr2.size().height   // 获取当前上下文  guard let context = UIGraphicsGetCurrentContext() else {  return nil  }  // 调整矩阵锚点到中心  context.concatenate(CGAffineTransform(translationX: imgW * 0.5, y: imgH * 0.5))  // 旋转矩阵  context.concatenate(CGAffineTransform(rotationAngle: rotationAngle))  // 恢复锚点位置到左上角  context.concatenate(CGAffineTransform(translationX: -imgW * 0.5, y: -imgH * 0.5))   // 对角线长度（实际绘制范围是对角线长度的正方形）  let sqrtLength: CGFloat = sqrt(pow(imgW, 2) &#43; pow(imgH, 2))   // 绘制的行数和列数  let horCount: Int = Int(sqrtLength / CGFloat(max(str1Width, str2Width) &#43; horzontalSpacing)) &#43; 1  let verCount: Int = Int(sqrtLength / CGFloat((str1Height &#43; str2Height &#43; contentAndTimeSapcing) &#43; verticalSpacing)) &#43; 1  // 此处计算出需要绘制水印文字的起始点，由于水印区域要大于图片区域所以起点在原有基础上移  let orignX: CGFloat = -imgW / 2  let orignY: CGFloat = -imgH / 2  // 在每列绘制时X坐标叠加  var tempOrignX: CGFloat = orignX  // 在每行绘制时Y坐标叠加  var tempOrignY: CGFloat = orignY   for i in 0..&amp;lt;verCount {  tempOrignX = orignX  for j in 0..&amp;lt;horCount {  string1.draw(in: CGRect(x: tempOrignX, y: tempOrignY, width: str1Width, height: str1Height), withAttributes: attributes1)  string2.draw(in: CGRect(x: tempOrignX, y: tempOrignY &#43; str1Height &#43; contentAndTimeSapcing, width: str2Width, height: str2Height), withAttributes: attributes2)  tempOrignX &#43;= max(str1Width,str2Width) &#43; horzontalSpacing  }  tempOrignY &#43;= str1Height &#43; str2Height &#43; verticalSpacing &#43; contentAndTimeSapcing  }  // 上下文获取新图片  let newImage = UIGraphicsGetImageFromCurrentImageContext()  // 关闭上下文  UIGraphicsEndImageContext()   return newImage  }   override public func hitTest(_ point: CGPoint, with event: UIEvent?) -&amp;gt; UIView? {  // 水印view不响应触摸事件  nil  }  } public extension UIView {   func addWaterText(text: NSString, color: UIColor, font: UIFont) {  let waterText: String = text as String   let textSize: CGSize = waterText.sizeWithText(font: UIFont.systemFont(ofSize: 15))  let height = UIScreen.main.bounds.size.height  let line: NSInteger = Int(height * 3.5) / 1800  let row: NSInteger = 20  let lineSpace = Int(textSize.width &#43; 30)  let rowHeight = Int(textSize.width &#43; 40)  let textWidth = Int(textSize.width)  let textHeight = Int(textSize.height)  for i in 0...line {  for j in 0...row {  let textLayer = CATextLayer()  textLayer.contentsScale = UIScreen.main.scale  textLayer.font = font  textLayer.fontSize = font.pointSize  textLayer.foregroundColor = color.cgColor  textLayer.string = waterText  let hSpace: Int = j * lineSpace  let vSpace: Int = i * rowHeight   textLayer.frame = CGRect(x: hSpace, y: vSpace, width: textWidth, height: textHeight)  textLayer.transform  textLayer.setAffineTransform(CGAffineTransform(rotationAngle: 60))  self.layer.addSublayer(textLayer)  }  }  }   func removeTextLayer(water: String) {  guard let layers = self.layer.sublayers else {  return  }  var sublayers = [CALayer]()   for (idx, layer) in layers.enumerated() where layer is CATextLayer {  if let textLayer = layer as? CATextLayer, let waterText: String = textLayer.string as? String {  guard water == waterText else {  return  }  } else {  sublayers.append(layer)  }  print(layer.frame, idx)  }  self.layer.sublayers = sublayers  } }  public extension String {  func sizeWithText(font: UIFont) -&amp;gt; CGSize {  let attributes = [NSAttributedString.Key.font: font]  let option = NSStringDrawingOptions.usesLineFragmentOrigin  let rect: CGRect = self.boundingRect(with: CGSize(width: CGFloat.greatestFiniteMagnitude, height: CGFloat.greatestFiniteMagnitude), options: option, attributes: attributes, context: nil)  return rect.size  } } public class JJWaterMarkLabel: UILabel {   /// 边长  let sideLength: CGFloat  /// 文字间距，默认值10  public var textSpacing: Int = 10  /// 行间距, 默认值30  public var lineSpacing: CGFloat = 30  /// 旋转角度，默认值-45  public var rotationAngle: CGFloat = -45 {  willSet {  self.transform = CGAffineTransform(rotationAngle: newValue * CGFloat(Double.pi) / 180 )  }  }   public override init(frame: CGRect) {  sideLength = sqrt(frame.width * frame.width &#43; frame.height * frame.height)  super.init(frame: CGRect(x: frame.origin.x, y: frame.origin.y, width: sideLength, height: sideLength))  center = CGPoint(x: frame.origin.x &#43; frame.width / 2, y: frame.origin.y &#43; frame.height / 2)  numberOfLines = 0  backgroundColor = UIColor.clear  transform = CGAffineTransform(rotationAngle: rotationAngle * CGFloat(Double.pi) / 180)  }   required init?(coder aDecoder: NSCoder) {  fatalError(&amp;#34;init(coder:) has not been implemented&amp;#34;)  }   public override func drawText(in rect: CGRect) {  /// 计算文本复制次数，得到最后的水印内容  var waterMarkContent = &amp;#34;&amp;#34;  let numberX: Int = Int(sideLength) / ((text?.count)! &#43; textSpacing)  let numberY: Int = Int(sideLength / (font.pointSize &#43; lineSpacing))  for _ in 0..&amp;lt;numberX * numberY {  waterMarkContent &#43;= text! &#43; String(repeating: &amp;#34; &amp;#34;, count: textSpacing)  }   let attributedString = NSMutableAttributedString(string: waterMarkContent, attributes: [NSAttributedString.Key.font: self.font])  let paragraphStyle = NSMutableParagraphStyle()  paragraphStyle.lineSpacing = lineSpacing  paragraphStyle.lineBreakMode = .byCharWrapping  attributedString.addAttribute(NSAttributedString.Key.paragraphStyle, value: paragraphStyle, range: NSMakeRange(0, attributedString.length))  attributedText = attributedString   super.drawText(in: rect)  } } position与anchorPoint 参考资料
Error Domain=PHPhotosErrorDomain Code=-1 用户传来一张图片，这张图片是他保存到本机比较久了，系统升级到16.0后，试图通过AirDrop传递该图片后，能够投送，但保存不了到本地。尝试将这个转换不了UIImage的图片，写入到本地相册时出现如下错误：
ParseGlobalMetaDataItemInfoAtom signalled err=-12845 (kIFFError_UnsupportedFeature) (Unsupported version for &#39;iinf&#39;) at IFFAtomParsing.c:442
if previewImg == nil, let data = try? Data(contentsOf: URL(fileURLWithPath: imgPath.homePath)) {  PHPhotoLibrary.shared().performChanges {  PHAssetCreationRequest.forAsset().addResource(with: .photo, fileURL: URL(fileURLWithPath: imgPath.homePath), optio  } completionHandler: { result, error in  debugPrint(result,error)  } }  Xcode 14 @available lazy error 之前使用@available定义的属性，升级到Xcode 14后出现了编译错误，需要将其改造为如下方式：
// Xcode会出现编译错误，Xcode 13不会 @available(iOS 14.0, *) private lazy var hapticManager: HapticManager = HapticManager()  // 需要改造成如下方式 var guardHapticManager: Any?  @available(iOS 13.0, *)  private var hapticManager: HapticManager? {  get {  if guardHapticManager == nil {  guardHapticManager = HapticManager()  }  return guardHapticManager as? HapticManager  } } 参考资料
IIS泄漏版本信息 有个应用被扫描出来泄露了版本信息，具体信息如下：
对于X-AspNet-Version这个字段，只需将web.config文件中的enableVersionHeader置为false，具体如下所示：
&amp;lt;configuration&amp;gt;  &amp;lt;system.web&amp;gt;  &amp;lt;httpRuntime requestValidationMode=&amp;#34;2.0&amp;#34; enableVersionHeader=&amp;#34;false&amp;#34;/&amp;gt;  &amp;lt;/system.web&amp;gt; &amp;lt;/configuration&amp;gt; 对于Server这个字段有两种解决方案，如果应用部署在IIS 10上，可以参考这个资料在system.webServer节点下配置requestFiltering下的removeServerHeader为true以移除Server字段：
&amp;lt;system.webServer&amp;gt;  &amp;lt;security&amp;gt;  &amp;lt;requestFiltering removeServerHeader=&amp;#34;true&amp;#34;&amp;gt;  &amp;lt;requestLimits maxAllowedContentLength=&amp;#34;1024000000&amp;#34; /&amp;gt;  &amp;lt;/requestFiltering&amp;gt;  &amp;lt;/security&amp;gt;  &amp;lt;/system.webServer&amp;gt; 如果应用部署在IIS 10以下的版本，不能真正删除 Server标头。但可以通过重写将其清空。在IIS 7&#43;（IIS 7、8.5、8.0、8.5、IIS 10.0）上，重写 outboundRules以从响应中删除 Web服务器版本信息。首先需要到官方网站根据系统版本下载URL Rewrite官方扩展插件，然后添加如下代码到Web.Config中：
&amp;lt;system.webServer&amp;gt;  &amp;lt;rewrite&amp;gt;  &amp;lt;outboundRules&amp;gt;  &amp;lt;rule name=&amp;#34;REMOVE_RESPONSE_SERVER&amp;#34;&amp;gt;  &amp;lt;match serverVariable=&amp;#34;RESPONSE_SERVER&amp;#34; pattern=&amp;#34;.*&amp;#34; /&amp;gt;  &amp;lt;action type=&amp;#34;Rewrite&amp;#34; /&amp;gt;  &amp;lt;/rule&amp;gt;  &amp;lt;/outboundRules&amp;gt;  &amp;lt;/rewrite&amp;gt; &amp;lt;/system.webServer&amp;gt; 参考资料1 参考资料2
如果还需要去掉X-Powered-By字段，可以在system.webServer节点添加如下信息：
&amp;lt;configuration&amp;gt;  &amp;lt;system.webServer&amp;gt; 　&amp;lt;httpProtocol&amp;gt; 　&amp;lt;customHeaders&amp;gt; 　&amp;lt;remove name=&amp;#34;X-Powered-By&amp;#34; /&amp;gt; 　&amp;lt;/customHeaders&amp;gt; 　&amp;lt;/httpProtocol&amp;gt;  &amp;lt;/system.webServer&amp;gt; &amp;lt;/configuration&amp;gt; 参考资料
How to get rid of the padding / insets in an UITextView 参考资料
参考资料
 self.textView.sizeToFit() // let fixedWidth = textView.frame.size.width // _ = textView.sizeThatFits(CGSize(width: fixedWidth, height: CGFloat.greatestFiniteMagnitude))   // 一定要调用layoutIfNeeded确保得到是最新的contentSize  self.view.layoutIfNeeded()   let contentHeight = textView.contentSize.height profile 不自动更新 打包时将描述文件更改为自动更新，但仍然没有自动更新描述文件的有效期。参考这个资料，可以在编译设置中的Capability修改某项，然后再打包就会自动更新描述文件：
device is incompatible with the installed version 使用真机调试时，出现了如下报错device is incompatible with the installed version of Xcode。经排查，出现这个提示可能有两种原因。
第一种情况是新设备第一次插入时Xcode处理未完成，如果等待了一段时间还是不行，可以将新设备重启几次即可。第二种是新设备的版本高于Xcode支持的版本，只要升级Xcode版本即可。
This operation can fail if the version of the OS on the device is incompatible with the installed version of Xcode. You may also need to restart your Mac and device in order to correctly detect compatibility. 参考资料
完全卸载cocoapods 参考资料
过滤html标签 func JJFilterHTML(html:String)-&amp;gt;String? {  let scanner = Scanner(string: html)  var text:NSString?  var result:String = html   while scanner.isAtEnd == false {  scanner.scanUpTo(&amp;#34;&amp;lt;&amp;#34;, into: nil)  scanner.scanUpTo(&amp;#34;&amp;gt;&amp;#34;, into: &amp;amp;text)  result = result.replacingOccurrences(of: &amp;#34;\(text ?? &amp;#34;&amp;#34;)&amp;gt;&amp;#34;, with: &amp;#34;&amp;#34;)  debugPrint(scanner.scanLocation)  }  return result } 参考资料
该方法有性能问题，可以使用下面方法过滤标签：
/// Html相关服务，目前仅提供html标签过滤功能 class MoHtmlService {   /// 使用正则表达式过滤html文件中的所有标签  func callAsFunction(with html: String) -&amp;gt; String {  guard let regex = try? NSRegularExpression(pattern: &amp;#34;&amp;lt;.*?&amp;gt;&amp;#34;, options: .caseInsensitive) else {  return html  }  let range = NSRange(location: 0, length: html.utf16.count)  return regex.stringByReplacingMatches(in: html, options: [], range: range, withTemplate: &amp;#34;&amp;#34;)  }  } WKWebView 开启滑动手势 webView.allowsBackForwardNavigationGestures = true webview加载网页http链接被转到https的问题 参考资料
强制关机 强制关机
iOS16系统，按下音量➕键然后快速按住音量减键，最后按住电源键直到手机重启。若是一直不重启，可能是按那三个键的时间间隔不符合要求，重复上述操作，直到关机。
destroy_helper_block_ crash 最近崩溃日志中出现SDWebImageManager.m destroy_helper_block_ crash次数明显增加，查询资料发现是因为SDWebImage很久没有升级，是老版本组件中的多线程导致的闪退。
参考资料
__ivar_destroyer 首先使用如下命令安装工具crashlog:
command script import lldb.macosx.crashlog https://juejin.cn/post/6844903619330834446
https://zhuanlan.zhihu.com/p/271096997
https://www.guardsquare.com/blog/making-the-most-out-of-ios-crash-reports-with-lldb
100% cpu average
Data Source: Microstackshots Shared Cache: 2FE45955-0050-316C-A5B0-CA721BE5899D slid base address 0x189a30000, slide 0x9a30000  Command: CMBMobile Path: /private/var/containers/Bundle/Application/A50B2D96-C915-4CF2-9BAC-FCC285751465/CMBMobile.app/CMBMobile Identifier: com.cmbchina.mo.moffice Version: V6.1.6 (2023032813) Beta Identifier: 1058FA94-3B3F-4E5D-B4CD-E2D7384DD5B9 PID: 2562  Event: cpu usage Action taken: Process killed CPU: 9 seconds cpu time over 9 seconds (100% cpu average), exceeding limit of 60% cpu over 15 seconds CPU limit: 9s Limit duration: 15s CPU used: 9s CPU duration: 9s Duration: 9.04s Duration Sampled: 6.99s Steps: 5  Hardware model: iPhone12,1 Active cpus: 6 failed to install provisioning profiles 开发的描述文件过期后，在安装新生成的描述文件时出现Failed to install one or more provisioning profiles on the device. Please ensure the provisioning profile is configured for this device.If not,please try to generate a new profile.参考这篇文章，重启电脑，就能够正常安装。
file not found libarclite_iphoneos.a 今天将Xcode从14.2升级到14.3版本后，编译原来的工程，出现如下错误。具体原因和解决方案参考这两篇这两篇文章文章1和文章2：
File not found: ~/Downloads/Xcode 14.3.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/arc/libarclite_iphoneos.a 第一种方式是将Xcode 14.2版本Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/目录下的arc目录完全拷贝到Xcode 14.3对应目录，接着完全关闭Xcode 14.3，再打开重新编译即可。
第二种方式是将App最低支持版本设置为11.0，把相关组件最低支持版本也设置为11.0:
post_install do |installer|  installer.pods_project.targets.each do |target|  target.build_configurations.each do |config|  config.build_settings[&amp;#39;IPHONEOS_DEPLOYMENT_TARGET&amp;#39;] = &amp;#39;13.0&amp;#39;  end  end end 如果编译还出现如下错误，重启Xcode即可：
Build service could not create build operation: unknown error while handling message: MsgHandlingError(message: &amp;#34;unable to initiate PIF transfer session (operation in progress?)&amp;#34;) xattr operation not permitted 在iterm2中执行命令sudo xattr -rd com.apple.quarantine /Applications/xxx.app后出现如下错误，经查询是因为在Ventura 13.4系统中没有给iterm2这个应用赋予访问文件夹/Applications的权限。
xattr: [Errno 1] Operation not permitted: &amp;#39;/Applications/xxx&amp;#39; 解决方案是打开System Settings---&amp;gt;Privacy &amp;amp; Security ---&amp;gt;Full Disk Access，然后找到iterm2并放开权限即可。勾选权限后，会提示要关闭Iterm，再重启即可。
unable to intall xxx 在更新sdk后，编译后，无法安装到真机里，出现了The code signature version is no longer supported错误，具体如下所示：
https://developer.apple.com/forums/thread/707086
当前有一个组件改造成了xcframework，但依赖这个库的组件执行如下所示的pod lib lint的命令：
 pod lib lint --no-clean --verbose --allow-warnings --skip-import-validation --sources=&amp;#34;xxx&amp;#34; xxxx.podspec 出现了如下所示错误，但主工程中依赖了xcframework却没有报错：
xcframework: Unable to find matching slice in &amp;#39;ios-arm64 ios-x86_64-simulator&amp;#39; for the current build architectures  error: no such module &amp;#39;xxx&amp;#39; webview加载网页http链接被转到https的问题 iOS webview加载网页http链接被转到https的问题
https://blog.csdn.net/ilinlinying/article/details/124327534?spm=1001.2101.3001.6650.2&amp;amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-124327534-blog-122500114.pc_relevant_aa&amp;amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-124327534-blog-122500114.pc_relevant_aa&amp;amp;utm_relevant_index=3
/* let sessionManager = Alamofire.SessionManager(configuration: URLSessionConfiguration.default) func getCode(url:String, completion:@escaping (String?) -&amp;gt;Void ) { sessionManager.delegate.taskWillPerformHTTPRedirection = { session, task, response, request in // 检查HTTP状态码是否为302 if response.statusCode == 302 { // 如果是302，你可以在这里处理重定向 // 例如，你可以修改重定向的URLRequest let headers = response.allHeaderFields .redirectLocation = headers[&amp;#34;Location&amp;#34;]! as! String } else { return request } let headers = response.allHeaderFields .redirectLocation = headers[&amp;#34;Location&amp;#34;]! as! String return URLRequest(url: URL(string: MYUrlConstant.redirectLocation)!) } } */ 发生了SSL错误，无法建立与该服务器的安全连接
Alamofire 获取302链接
参考资料
No such module
fatal error: unexpectedly found nil while unwrapping an Optional value ideviceinstaller -i 安装ipa提示 AFC Write error: 30 错误
(lldb) po newInfo.allValues[2]    (lldb) p newInfo.allValues[2]  (AnyObject) $R17 = (object = 0x0000000000000000) (lldb) po newInfo.allValues[2] as? UIViewController error: Execution was interrupted, reason: EXC_BAD_ACCESS (code=1, address=0x0). The process has been returned to the state before expression evaluation. Xcode 15 beta manual install simulator   打开模拟器DMG，把Runtimes文件夹复制到 Xcode 对应模拟器平台中
/Library/Developer/CoreSimulator/Profiles/Runtimes整个复制到
/Applications/Xcode-beta.app/Contents/Developer/Platforms/XROS.platform/Library/Developer/CoreSimulator/Profiles
  重启Xcode，模拟器就安装成功了。
  参考资料
xcode-select -s /Applications/Xcode-beta.app xcodebuild -runFirstLaunch xcrun simctl runtime add &amp;#34;~/Downloads/watchOS 9 beta Simulator Runtime.dmg&amp;#34; https://developer.apple.com/documentation/xcode/installing-additional-simulator-runtimes
Bundle.bundleIdentifier 因为某种原因需要固定返回一个特殊的bundle Id测试，可以使用方法交换，返回该特殊的id，代码如下：
extension Bundle {  @objc var customBundleIdentifier: String {  return &amp;#34;com.test.bundle.id&amp;#34;  } }  let originalMethod = class_getInstanceMethod(Bundle.self, #selector(getter: Bundle.bundleIdentifier)) let swizzledMethod = class_getInstanceMethod(Bundle.self, #selector(getter: Bundle.customBundleIdentifier)) method_exchangeImplementations(originalMethod!, swizzledMethod!) import ObjectiveC.runtime extension Bundle {  // 用于确保代码只被执行一次的静态属性  private static let doOnce: Void = {  let originalSelector = #selector(getter: Bundle.bundleIdentifier)  let swizzledSelector = #selector(getter: Bundle.customBundleIdentifier)   guard let originalMethod = class_getInstanceMethod(Bundle.self, originalSelector),  let swizzledMethod = class_getInstanceMethod(Bundle.self, swizzledSelector) else { return }   method_exchangeImplementations(originalMethod, swizzledMethod)  }()   // 自定义的bundleIdentifier的getter  @objc var customBundleIdentifier: String? {  // 这里返回你想要的bundleIdentifier，用于绕过SDK校验  return &amp;#34;com.your.custom.bundleIdentifier&amp;#34;  }   // 在应用启动时调用此方法来执行方法交换  static func swizzleBundleIdentifier() {  _ = Bundle.doOnce  } } extension Bundle {   // 方法交换  static func swizzleBundle() {  let originalSelector = #selector(getter: Bundle.bundleIdentifier)  let swizzledSelector = #selector(getter: Bundle.customBundleIdentifier)   guard let originalMethod = class_getInstanceMethod(Bundle.self, originalSelector),   let swizzledMethod = class_getInstanceMethod(Bundle.self, swizzledSelector) else {   return   }  method_exchangeImplementations(originalMethod, swizzledMethod)  }     // 自定义的bundleIdentifier的getter  @objc var customBundleIdentifier: String? {  // 这里返回想要的bundleIdentifier，用于绕过校验  return &amp;#34;xxx.bundleIdentifier&amp;#34;  }  }   private var privateKey: String? {   Bundle.swizzleBundle()   let key = xxx // 获取key   Bundle.swizzleBundle()   return key  } dyld: could not load inserted library &amp;#39;/System/Library/PrivateFrameworks/GPUToolsCapture.framework/GPUToolsCapture&amp;#39; because image not found https://developer.apple.com/forums/thread/736487
JSON解析
Error Domain=NSCocoaErrorDomain Code=3840 &amp;#34;Unexpected end of file during string parse (expected low-surrogate code point but did not find one). around line 1, column 457.&amp;#34; UserInfo={NSDebugDescription=Unexpected end of file during string parse (expected low-surrogate code point but did not find one). around line 1, column 457., NSJSONSerializationErrorIndex=457} https://www.jianshu.com/p/ea99580ea30f
ImageLoaderMachO::doModInitFunctions 升级到Xcode 15后，原工程编译后在iOS 11~14均出现启动闪退，闪退时的具体堆栈信息如所示：
0x000000010c375228 in ImageLoaderMachO::doModInitFunctions(ImageLoader::LinkContext const&amp;amp;) () 0x000000010c3755f0 in ImageLoaderMachO::doInitialization(ImageLoader::LinkContext const&amp;amp;) () 0x000000010c36fe8c in ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&amp;amp;, unsigned int, char const*, ImageLoader::InitializerTimingList&amp;amp;, ImageLoader::UninitedUpwards&amp;amp;) () 0x000000010c36e0d8 in ImageLoader::processInitializers(ImageLoader::LinkContext const&amp;amp;, unsigned int, ImageLoader::InitializerTimingList&amp;amp;, ImageLoader::UninitedUpwards&amp;amp;) () 0x000000010c36e1a0 in ImageLoader::runInitializers(ImageLoader::LinkContext const&amp;amp;, ImageLoader::InitializerTimingList&amp;amp;) () 0x000000010c35e80c in dyld::initializeMainExecutable() () 0x000000010c363e3c in dyld::_main(macho_header const*, unsigned long, int, char const**, char const**, char const**, unsigned long*) () 0x000000010c35d208 in dyldbootstrap::start(dyld3::MachOLoaded const*, int, char const**, dyld3::MachOLoaded const*, unsigned long*) () 0x000000010c35d038 in _dyld_start () 参考该文章，只需将OTHER_LDFLAGS的设置加上-Wl,-ld_classic 选项即可。实际上，只需要加上-ld_classic就可以解决启动闪退问题。
dyld: could not load inserted library &amp;#39;/System/Library/PrivateFrameworks/GPUToolsCapture.framework/GPUToolsCapture&amp;#39; because image not found https://developer.apple.com/forums/thread/736487
Can&amp;rsquo;t map file, errno=22 在主项目中的build setting --&amp;gt; other linker flags中添加了一个新的framework。出现了报错Can&#39;t map file, errno=22。是因为只添加到framework这一层，真正要添加的是到下面一层：
$(SRCROOT)/Pods/ddd/xxx.framework/xxx </content>
    </entry>
    
     <entry>
        <title>一些问题的解决方案2023</title>
        <url>https://iihui.github.io/post/ios-solutions-2023/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> 开启高版本调试 在macOS中调试使用WKWebViewj加载的网页，发现即使在真机上的Safari浏览器上开启了网页检测器（设置&amp;ndash;&amp;gt;高级&amp;ndash;&amp;gt;网页检测器）也无法调试，需要开启iOS 16.4及以上系统WKWebView新增的isInspectable开关：
// 高版本调试需要开启该属性，默认关闭 if #available(iOS 16.4, *) {  webView.isInspectable = true } 在macOS开启网页服务 最近在优化WKWebView弹框相关代码，需要编写相关网页进行测试。因为macOS自带Apatch服务，只需要开启并将网页放进去即可，参考如下方式。
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;zh-CN&amp;#34;&amp;gt; &amp;lt;head&amp;gt;  &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt;  &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34;&amp;gt;  &amp;lt;title&amp;gt;确认框和输入提示示例&amp;lt;/title&amp;gt;  &amp;lt;script&amp;gt;  // 确保在页面加载完成后执行  window.onload = function() {  // 使用 window.confirm 弹出确认框  var result = window.confirm(&amp;#34;您确定要继续吗？&amp;#34;);  if (result) {  // 用户点击了确定，弹出输入提示框  var userInput = window.prompt(&amp;#34;请输入您的名字：&amp;#34;);  if (userInput !== null &amp;amp;&amp;amp; userInput !== &amp;#34;&amp;#34;) {  alert(&amp;#34;您好，&amp;#34; &#43; userInput &#43; &amp;#34;！感谢您的输入。&amp;#34;);  } else {  alert(&amp;#34;您没有输入任何内容。&amp;#34;);  }  } else {  alert(&amp;#34;您点击了取消。&amp;#34;);  }  };  &amp;lt;/script&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt;  &amp;lt;h1&amp;gt;欢迎来到确认框和输入提示示例页面&amp;lt;/h1&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; WKWebView弹框
开启Apatch服务
/Users/hui/Downloads/CMBMobile/CMBMobile/View/Note/TitleView.xib UISearchDisplayController is unavailable when deploying to iOS 13.0 or later 尝试直接在Storyboard中删除UISearchDisplayController即可。
ipa中描述文件过期时间查看
 只能在苹果电脑查看 原先这个包叫 xxxx.ipa,要先将后缀改成zip 双击这个文件，会生成一个文件夹 点击 Payload 进去，右键 显示包内容 找到 embedded&amp;hellip;bileprovision 这个文件，如果不存在这个文件，一定要重新打包 Expiration Date就是描述文件的过期时间  </content>
    </entry>
    
     <entry>
        <title>一些问题的解决方案2025</title>
        <url>https://iihui.github.io/post/ios-solutions-2025/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> No Symbolic Information Found 在一台非打包的iMac上使用命令symbolicatecrash xxx1.crash ST/dsymDir/xxx2.dSYM -o xxx1.log对崩溃日志进行符号化，执行完后出现了如下错误：
No Symbolic Information Found 最开始怀疑是dsym文件和崩溃日志的uuid不同造成的。但使用命令dwarfdump --uuid xxx.dSYM得到dsym文件的uuid和崩溃日志中的uuid是相同的，也就排除了是uuid不一致导致的报错。同时，发现若使用atos命令时指定dsym目录下的target进行符号化，得到的结果却是正常的：
atos -o ST/dsymDir/xxx1.dSYM/Contents/Resources/DWARF/targetxxx -l 0x1c6573000 0x00000001c6a0da80 在问题排查过程中意外发现，使用symbolicatecrash命令时若按照atos命令那样指定dysm目录下的target也是可以符号化成功的，具体命令如下（其中xxx表示dsym文件名，xxx1表示崩溃日志文件名，xxx2表示target名）：
symbolicatecrash xxx1.crash ST/dsymDir/xxx.dSYM/Contents/Resources/DWARF/xxx2 -o xxx1.log 此外，进一步排查又发现使用symbolicatecrash命令进行符号化时若添加-d选项（明确指定添加额外的dsym文件，当uuid匹配时查询）也是能够正常符号化崩溃日志:
symbolicatecrash xxx.crash -d ST/dsymDir/xxxdSYM -o xxx.log 根据添加-d选项后终端的输出日志，发现若使用mdfind查找uuid对应的dsym文件时无任何输出，也就说找不到uuid对应的dsym文件：
mdfind &amp;#34;com_apple_xcode_dsym_uuids == A7C6DA83-B3C1-3E0C-9734-0C59CD5032C8&amp;#34; 这是因为Spotlight索引未包含文件元数据，可以通过如下方案解决。经过验证，第一次添加元数据标签成功后，后续添加dsym文件时不再需要重复添加元数据标签（直接使用mfind可以查到到相应的dsym文件）：
# 替换为你的实际 UUID 和文件路径 UUID=&amp;#34;A7C6DA83-B3C1-3E0C-9734-0C59CD5032C8&amp;#34; DSYM_PATH=&amp;#34;/path/to/xxx.dSYM&amp;#34; # 需要使用绝对路径  # 添加元数据标签 xattr -w com.apple.metadata:com_apple_xcode_dsym_uuids &amp;#34;$UUID&amp;#34; &amp;#34;$DSYM_PATH&amp;#34;  # 验证是否添加成功 mdls -name com_apple_xcode_dsym_uuids &amp;#34;$DSYM_PATH&amp;#34; 添加元数据后，再刷新索引：
# 刷新特定文件 mdimport &amp;#34;$DSYM_PATH&amp;#34;  # 或刷新整个目录 mdimport ~/Library/Developer/Xcode/Archives # 假设dSYM在此目录  # 重建整个索引（耗时较长） sudo mdutil -E / Xcode 16 编译问题 升级至Xcode 16后编译原工程出现了如下错误：
#include &amp;lt;sys/_types/_u_char.h&amp;gt;&amp;#39;; &amp;#39;u_char&amp;#39; must be declared before it is used 这是因为苹果在iOS 17/macOS 14 SDK中，移除了隐式类型声明，要求所有的类型如u_int32_t，u_char等需要从适当的系统模块导入。这也意味着现在需要显式地导入包含这些类型定义的头文件，即添加如下头文件：
#include &amp;lt;sys/types.h&amp;gt;  解决了上面错误，又出现了第二个报错：
Declaration of &amp;#39;sa_family_t&amp;#39; must be imported from module &amp;#39;Darwin.POSIX.sys.types._sa_family_t&amp;#39; before it is required 同样地，也需要显式导入如下头文件：
#include &amp;lt;sys/socket.h&amp;gt; 升级到Xcode 16.4后，发现不能调试iOS 13真机，连上手机并手动信任后出现如下错误：
Could not locate device support files。You may be able to resolve the issue by installing the latest version of Xcode from the Mac App Store or developer.apple.com. 这是因为Xcode 16将支持的最低iOS系统版本限制到15了。以前，当真机连上Xcode，Xcode会检测本地是否有相应系统的支持文件，若没有会自动下载。由于Xcode 16不再支持iOS 15以下设备了，所以现在不会自动下载iOS 15以下的设备支持文件了。
此时，需要手动下载低版本系统的支持文件，参考解决方案是到这里下载对应iOS版本的DeviceSupport文件，然后解压并移动到/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport/下，再重启Xcode，就可以正常调试低版本的真机了。
覆盖安装Xcode 从苹果官网下载新版Xcode 16覆盖之前从App Store上安装的低版本Xcode时，出现如下报错：
The operation can’t be completed because some items had to be skipped. For each item, choose File &amp;gt; Get Info, make sure “Locked” is deselected, and then check the Sharing &amp;amp; Permissions section. When you are sure the items are unlocked and not designated as Read Only or No Access, try again. 可以通过如下方式解决：
# 解锁所有文件（移除用户不可更改标志） sudo chflags -R nouchg /Applications/Xcode.app  # 将所有权赋予当前用户（替换 YOUR_USERNAME 为你的用户名） sudo chown -R YOUR_USERNAME:staff /Applications/Xcode.app  # 授予用户完全读写权限 sudo chmod -R u&#43;rw /Applications/Xcode.app 示例：如果用户名为 john，则命令为 sudo chown -R john:staff /Applications/Xcode.app。
UICollectionView 使用Xcode 16编译后，出现如下报错：
Expected dequeued view to be returned to the collection view in preparation for display. When the collection view&amp;#39;s data source is asked to provide a view for a given index path, ensure that a single view is dequeued and returned to the collection view. Avoid dequeuing views without a request from the collection view. For retrieving an existing view in the collection view, use -[UICollectionView cellForItemAtIndexPath:] or -[UICollectionView supplementaryViewForElementKind:atIndexPath:]  https://www.jianshu.com/p/1fc532f2aff4 排查发现是因为在非cellForItemAt方法中使用了如下代码：
if let indexPath = indexPath, let cell = collectionView.dequeueReusableCell(withReuseIdentifier: xxxIdentifier, for: indexPath) as? TestCell {  // } 应该改成如下方式：
collectionView.cellForItem(at: index) as? TestCell UINavigationController中查找特定View extension UINavigationController {  /// 获取导航控制器的 UIViewControllerWrapperView（仅用于调试）  func debugFindWrapperView() -&amp;gt; UIView? {  // 递归查找特定类名的视图  func findView(in view: UIView, className: String) -&amp;gt; UIView? {  if &amp;#34;\(type(of: view))&amp;#34; == className {  return view  }  for subview in view.subviews {  if let result = findView(in: subview, className: className) {  return result  }  }  return nil  }   #if DEBUG  return findView(in: self.view, className: &amp;#34;UIViewControllerWrapperView&amp;#34;)  #else  return nil // 正式环境永远返回 nil  #endif  } }  fileprivate extension UINavigationController {  /// 获取特性tag的View  func debugFindWrapperView(with tag: Int) -&amp;gt; UIView? {  // 递归查找特定类名的视图  func findView(in view: UIView, tag: Int) -&amp;gt; UIView? {  if view.tag == tag {  return view  }  for subview in view.subviews {  if let result = findView(in: subview, tag: tag) {  return result  }  }  return nil  }  return findView(in: self.view, tag: tag)  } } 安装描述文件失败 Please ensure the provisioning profile is configured for this device. If not, please try to generate a new profile. 若确定需要安装的描述文件没问题，可以尝试拔掉手机，再重新安装即可。
BIOCPROMISC: Operation not supported 为iOS设备创建虚拟接口：
rvictl -s xxx # 其中xxx表示设备id 关闭虚拟接口：
rvictl -x xxx # 其中xxx表示设备id 将设备连接到mac上后可以使用如下命令查看设备id：
idevice_id -l 在macOS上使用rvictl -s为iOS设备创建虚拟接口(如 rvi0)后，Wireshark抓包时出现BIOCPROMISC: Operation not supported on socket错误，是因为Wireshark默认尝试启用混杂模式（Promiscuous Mode），但rvi0虚拟接口不支持此模式。以下是解决方案：
方法 1：在 Wireshark中禁用混杂模式（推荐）  打开Wireshark，点击菜单栏的设置按钮，然后找到rvi0接口，取消勾选Promiscuous Mode即可。  方法 2：通过命令行工具捕获（避免 Wireshark GUI） 使用 tshark（Wireshark的命令行工具）并显式禁用混杂模式：
sudo tshark -i rvi0 -p -w output.pcap  -p：禁用混杂模式。 -w output.pcap：将捕获结果保存到文件，之后可在Wireshark中分析。  方法 3：使用tcpdump捕获后导入 Wireshark sudo tcpdump -i rvi0 -s0 -w capture.pcap  按 Ctrl&#43;C 停止捕获后，用Wireshark打开 capture.pcap 文件分析。  方法 4：修改Wireshark全局设置（备用） 编辑Wireshark配置文件：
1、关闭Wireshark。
2、创建或修改配置文件：
nano ~/.config/wireshark/preferences 3、添加以下行：
capture.disable_promiscuous_mode: TRUE 4、保存后重启Wireshark。
原因说明  rvictl创建的rvi0接口本身已完整捕获 iOS 设备的流量，无需混杂模式。 Wireshark默认启用混杂模式，但macOS的BPF系统对虚拟接口支持有限，导致BIOCPROMISC错误。  通过上述任一方法禁用混杂模式即可解决该错误，正常捕获iOS设备流量。推荐优先使用方法1或方法 2。
https://www.jianshu.com/p/67be96d313df
https://developer.baidu.com/article/details/3306592
https://www.lvtao.net/tool/macos-wireshark.html
参数介绍 过滤参数介绍
iOS 18 unsatisfied (Local network prohibited) 使用Xcode 16编译App，使用某个上传功能时出现如下错误：
NSURLErrorNWPathKey=unsatisfied (Local network prohibited) 这个错误表明应用被系统阻止访问本地网络，这是因为iOS 18有一些新变化：
 进一步加强了网络隔离策略 强化了本地网络访问的权限控制 对mDNS/Bonjour服务发现更严格限制  解决方案是要在工程的info.plist添加如下内容：
&amp;lt;key&amp;gt;NSLocalNetworkUsageDescription&amp;lt;/key&amp;gt; &amp;lt;string&amp;gt;APP_NAME需要访问本地网络以发现附近的智能设备&amp;lt;/string&amp;gt;  &amp;lt;key&amp;gt;NSBonjourServices&amp;lt;/key&amp;gt; &amp;lt;array&amp;gt;  &amp;lt;string&amp;gt;_http._tcp&amp;lt;/string&amp;gt;  &amp;lt;string&amp;gt;_printer._tcp&amp;lt;/string&amp;gt; &amp;lt;/array&amp;gt; Task冲突 在某个Swift文件开头引入了PomiseKit，即import PromiseKit，然后使用新并发模型中的Task{ }时，出现如下编译错误：
&amp;#39;Task&amp;#39; cannot be constructed because it has no accessible initializers 这是因为在PromiseKit组件中也定义了一个Task，会优先使用了这个Task，而不是标准库中的Task，解决方案是加并发模型的内部命名空间_Concurrency：
_Concurrency.Task {  // } 查看targert设置 升级了Xcode 16之后发现同一个工程的不同target有一个编译成功，另一个编译失败。根据现象，显然是因为不同target的编译设置不一样导致的，为了查看不同的target的编译设置，可以使用如下命令：
xcodebuild -workspace xxx.xcworkspace -scheme &amp;#34;xxxST&amp;#34; -configuration Debug -showBuildSettings &amp;gt; ~/Downloads/st_build_settings.txt 然后使用文本对比工具对比不同target的编译设置。
编译时删除${BUILT_PRODUCTS_DIR}/xxx/xxx.framework 执行pod update后发现pbxproj中的&amp;quot;${BUILT_PRODUCTS_DIR}/xxx/xxx.framework&amp;quot;被删了，使用如下命令可以恢复：
# 1. 完全清除现有 Pods 集成 pod deintegrate  # 2. 清理缓存 pod cache clean --all  # 3. 重新安装 pod install 修改组件最低支持版本 # Podfile  platform :ios, &amp;#39;13.0&amp;#39;  target &amp;#39;YourApp&amp;#39; do   # 批量修改所有 pods 的 deployment_target  post_install do |installer|  installer.pods_project.targets.each do |target|  target.build_configurations.each do |config|  # 设置 iOS deployment target  config.build_settings[&amp;#39;IPHONEOS_DEPLOYMENT_TARGET&amp;#39;] = &amp;#39;13.0&amp;#39;  # 可选：同时设置其他平台的 deployment target  # config.build_settings[&amp;#39;MACOSX_DEPLOYMENT_TARGET&amp;#39;] = &amp;#39;11.0&amp;#39;  # config.build_settings[&amp;#39;TVOS_DEPLOYMENT_TARGET&amp;#39;] = &amp;#39;14.0&amp;#39;  # config.build_settings[&amp;#39;WATCHOS_DEPLOYMENT_TARGET&amp;#39;] = &amp;#39;7.0&amp;#39;  end  end  end end PBXFileSystemSynchronizedRootGroup 接手别人的项目后使用pod update命令更新依赖，出现如下错误：
RuntimeError - `PBXGroup` attempted to initialize an object with unknown ISA `PBXFileSystemSynchronizedRootGroup` from attributes: `{&amp;#34;isa&amp;#34;=&amp;gt;&amp;#34;PBXFileSystemSynchronizedRootGroup&amp;#34;, &amp;#34;exceptions&amp;#34;=&amp;gt;[&amp;#34;416D36782ECD6C14005419D5&amp;#34;], &amp;#34;path&amp;#34;=&amp;gt;&amp;#34;demo&amp;#34;, &amp;#34;sourceTree&amp;#34;=&amp;gt;&amp;#34;&amp;lt;group&amp;gt;&amp;#34;}` 是因为cocoapods版本太低（实际是cocoapods的Xcodeproj版本太低），无法识别在高版本Xcode上创建的项目。需要在高版本Xcode上已创建工程的根目录由Folder转为Group（打开项目在根目录上右键会出现相应选项）。按上面方法修改后执行pod update后还是报错:
[!] [!] Xcodeproj doesn&amp;#39;t know about the following attributes {&amp;#34;minimizedProjectReferenceProxies&amp;#34;=&amp;gt;&amp;#34;1&amp;#34;, &amp;#34;preferredProjectObjectVersion&amp;#34;=&amp;gt;&amp;#34;77&amp;#34;} for the &amp;#39;PBXProject&amp;#39; isa. 这是因为低版本的Xcodeproj无法识别上面两个属性，此时需要将project.pbxproj（在finder中右键xxx.xcodeproj，显示包内容，打开project.pbxproj）中的内容删除：
minimizedProjectReferenceProxies = 1; preferredProjectObjectVersion = 77; 若按上面方式删除上面两个字段，若出现如下报错，则需要修改project.pbxproj文件中的objectVersion为支持的版本：
/Library/Ruby/Gems/2.6.0/gems/xcodeproj-1.21.0/lib/xcodeproj/project.rb:228:in `initialize_from_file&amp;#39;: [Xcodeproj] Unknown object version (56). (RuntimeError) 参考文档
指定发布版本和编译版本 使用xcodebuild命令进行打包时，可以指定编译版本和发布版本，命令如下：
xcodebuild -quiet -workspace demo.xcworkspace -scheme &amp;#34;${targetName}&amp;#34; MARKETING_VERSION=${bundleShortVersion} CURRENT_PROJECT_VERSION=${bundleVersion} 若需要在某个目录下删除非ipa和dSYM的所有文件，可以使用如下命令：
# 删除非.ipa和非.dSYM文件 find &amp;#34;$build_path&amp;#34; -type f ! -name &amp;#34;*.ipa&amp;#34; ! -name &amp;#34;*.dSYM&amp;#34; -depth 1 -delete 某个变量取两个环境变量的值，下面的变量是若$2为空，则取$demo:
bundleShortVersion=&amp;#34;${2:-$demo}&amp;#34; </content>
    </entry>
    
     <entry>
        <title>ArkTs</title>
        <url>https://iihui.github.io/post/arkts-base/</url>
        <categories>
          <category>ts</category>
        </categories>
        <tags>
          <tag>ts</tag>
        </tags>
        <content type="html"> 基本知识 类型  ArkTS是一种静态类型语言，所有数据的类型都必须在编译时确定，但如果一个变量或常量的声明包含了初始值，那么开发者就不需要显式指定其类型。
 void类型 类型void只有一个值，也是void。void类型用于指定函数没有返回值，不能用于普通变量的类型标注。因为void是引用类型，所以也可用于泛型类型参数。
class Class&amp;lt;T&amp;gt; {  //... } let instance: Class &amp;lt;void&amp;gt; Object类型 大写开头的Object是一个内置interface，它描述所有对象都具有的属性和方法。Object类型可以接受任何类型的赋值，但只能赋值给Object或any类型。Object类型不太安全，因为它允许原始类型也可以赋值给它。Object类型是所有引用类型的基类型。任何值，包括基本类型的值（它们会被自动装箱），都可以直接被赋给Object类型的变量。
let obj: Object; obj = { name: &amp;#39;John&amp;#39;, age: 25 }; // 合法 obj = [1, 2, 3]; // 合法 obj = &amp;#39;hello&amp;#39;; // 合法 obj = 123; // 合法 obj = true; // 合法 小写开头的object 类型表示非原始类型，即除string、number、bigint、boolean、symbol、null 和undefined之外的任何类型。任何对象类型都可以赋值给object类型，但是object类型只能赋值给object和any类型。object类型可以用来表示不确定的输入参数或返回值，或者用来进行疲劳性检查。
语句 使用for-of语句可遍历数组或字符串：
for (forVar of expression) {  statements }   const arr = [12, 31, 98956] for (const item of arr) {  console.log(item); }  const str = &amp;#34;Hi&amp;#34;; for (const item of str) {  console.log(item); } 语句try用于捕获或处理异常，并支持finally语句：
function processData(s: string) {  let error: Error | null = null;   try {  console.log(&amp;#39;Data processed: &amp;#39; &#43; s);  // ...  // 可能发生异常的语句  // ...  } catch (e) {  error = e as Error;  // ...  // 异常处理  // ...  } finally {  if (error != null) {  console.log(`Error caught: input=&amp;#39;${s}&amp;#39;, message=&amp;#39;${error.message}&amp;#39;`);  }  } } 函数 不需要返回值的函数的返回类型可以显式标注为void类型或省略返回类型标注，在这类函数中不需要返回语句。下面示例代码中两种函数声明方式都是有效的：
function hi1() {  console.log(&amp;#39;hi&amp;#39;); }  function hi2(): void {  console.log(&amp;#39;hi&amp;#39;); } 在函数中定义的变量和对象实例仅可以在函数内部访问，外部不能访问。如果函数中定义的变量与外部作用域中已有实例同名，则函数内的局部变量定义将覆盖外部定义。
箭头函数 函数可以定义为箭头函数（箭头函数又被称为Lambda函数），例如：
let sum = (x: number, y: number): number =&amp;gt; {  return x &#43; y; } 箭头函数的返回类型标注可以省略。若箭头函数省略返回类型标注时，返回类型通常通过函数体推断。表达式可以指定为箭头函数，使表达更简短，因此以下两种表达方式是等价的：
let sum1 = (x: number, y: number) =&amp;gt; {  return x &#43; y; }  let sum2 = (x: number, y: number) =&amp;gt; x &#43; y 闭包 闭包是由函数及声明该函数的环境组合而成的，该环境包含了这个闭包创建时作用域内的任何局部变量。在下面示例代码中，ff函数返回了一个闭包，它捕获了count变量，每次调用z，count的值会被保留并递增。
function ff(): () =&amp;gt; number {  let count = 0;  let g = (): number =&amp;gt; {  count&#43;&#43;;  return count;  };  return g; }  let z = ff(); let ret = z(); console.log(ret); ret = z(); console.log(ret);  // 执行结果 1 2 函数重载 ArkTs可以声明函数重载，重载可以指定函数的不同调用方式。即为同一个函数写入多个同名但签名不同的函数头，函数实现紧随其后。
function foo(x: number): void; /* 第一个函数定义 */ function foo(x: string): void; /* 第二个函数定义 */ function foo(x: number | string): void { /* 函数实现 */ }  foo(123); // OK，使用第一个定义 foo(&amp;#39;aa&amp;#39;); // OK，使用第二个定义 类 字段 为了减少运行时的错误和获得更好的执行性能，ArkTS要求所有字段在声明时或者构造函数中显式初始化。这和标准TS中的strictPropertyInitialization模式一样。
class Person {  name: string; // undefined   setName(n:string): void {  this.name = n;  }   getName(): string {  // 开发者使用&amp;#34;string&amp;#34;作为返回类型，这隐藏了name可能为&amp;#34;undefined&amp;#34;的事实。  // 更合适的做法是将返回类型标注为&amp;#34;string | undefined&amp;#34;，以告诉开发者这个API所有可能的返回值。  return this.name;  } }  let jack = new Person(); // 假设代码中没有对name赋值，例如调用&amp;#34;jack.setName(&amp;#39;Jack&amp;#39;)&amp;#34; jack.getName().length; // 运行时异常：name is undefined 继承 继承类继承基类的字段和方法，但不继承构造函数。继承类可以新增定义自有的字段和方法，也可以覆盖其基类定义的方法。基类也称为父类或超类，继承类也称为派生类或子类。
class Person {  name: string = &amp;#39;&amp;#39;;  private _age = 0;  get age(): number {  return this._age;  } }  class Employee extends Person {  salary: number = 0;  calculateTaxes(): number {  return this.salary * 0.42;  } } 包含implements子句的类必须实现列出的接口中定义的所有方法，但使用默认实现定义的方法除外。
interface DateInterface {  now(): string; } class MyDate implements DateInterface {  now(): string {  // 在此实现  return &amp;#39;now&amp;#39;;  } } 子类可以重写其父类中定义的方法的实现。但需要注意的是，重写的方法**必须具有与原始方法相同的参数类型和相同或派生的返回类型**。
class RectangleSize {  // ...  area(): number {  // 实现  return 0;  } }  class Square extends RectangleSize {  private side: number = 0;  area(): number {  return this.side * this.side;  } } Record类型的对象字面量 泛型Record&amp;lt;K, V&amp;gt;用于将类型（键类型）的属性映射到另一个类型（值类型）。常用对象字面量来初始化该类型的值：
let map: Record&amp;lt;string, number&amp;gt; = {  &amp;#39;John&amp;#39;: 25,  &amp;#39;Mary&amp;#39;: 21, }  map[&amp;#39;John&amp;#39;]; // 25 类型K可以是字符串类型或数值类型，而V可以是任何类型。
interface PersonInfo {  age: number;  salary: number; }  let map: Record&amp;lt;string, PersonInfo&amp;gt; = {  &amp;#39;John&amp;#39;: { age: 25, salary: 10},  &amp;#39;Mary&amp;#39;: { age: 21, salary: 20} } 抽象类 带有修饰符abstract的类称为抽象类。抽象类可用于表示一组更具体的概念所共有的概念。如果尝试创建抽象类的实例，则会发生编译时的错误：
abstract class X {  field: number;  constructor(p: number) {  this.field = p;  } }  let x = new X(666) //编译时错误：不能创建抽象类的具体实例 抽象类的子类可以是抽象类也可以是非抽象类。抽象父类的非抽象子类可以实例化。因此，执行抽象类的构造函数和该类非静态字段的字段初始化器：
abstract class Base {  field: number;  constructor(p: number) {  this.field = p;  } }  class Derived extends Base {  constructor(p: number) {  super(p);  } } 带有abstract修饰符的方法称为抽象方法，抽象方法可以被声明但不能被实现。只有抽象类内才能有抽象方法，如果非抽象类具有抽象方法，则会发生编译时错误：
class Y {  abstract method(p: string) //编译时错误：抽象方法只能在抽象类内。 } </content>
    </entry>
    
     <entry>
        <title>Ruby基础</title>
        <url>https://iihui.github.io/post/ruby/</url>
        <categories>
          <category>ruby</category>
        </categories>
        <tags>
          <tag>ruby</tag>
        </tags>
        <content type="html"> Ruby是数百种编程语言中之一，但它很特别，对许多程序员来说，它很像一种自然语言（会让人感觉出奇地像英语），同时又具有计算机所要求的清晰性。例如，如果运行下面的代码，将会打印Hello, world!字符串10次。
10.times do print &amp;#34;Hello, world!&amp;#34; end 在irb中，上面代码运行后除了会打印十次Hello, world!，还会紧跟着=&amp;gt; 10，这表明10.times do print &amp;quot;Hello, world!&amp;quot; end作为表达式的结果为10。这是因为Ruby中所有代码都是由有返回值的表达式组成的。
print &amp;#34;test&amp;#34; # 打印了test，返回值为nil test =&amp;gt; nil 在irb中上面代码执行后会打印test，并紧跟着=&amp;gt; nil。这是因为print除了打印，不会返回任何值，所以print &amp;quot;test&amp;quot;作为表达式的返回值为nil。
与许多其它编程语言不同，Ruby的行尾不需要分号（虽然使用分号也是可以的，但通常不建议这样做）。对于有经验的程序员来说，可能需要一点时间来适应，但对于新程序员来说，这个特性使Ruby更容易学习。
The variety of Ruby identifiers Variables   局部变量：局部变量名以小写字母或下划线开头，并由字母、下划线或数字组成。例如：x、string、abc、var1、start_value 和firstName都是有效的局部变量名。但请注意，在Ruby中使用多个单词组合成局部变量名时通常使用下划线而不是驼峰式命名法。例如，一般使用first_name而不是firstName。
  实例变量：在单个对象中存储信息的实例变量始终以单个@符号开头，其后包含与局部变量相同的字符集，例如@age和@last_name。虽然局部变量不能以大写字母开头，但实例变量名在@符号之后的第一个位置可以是大写字母。但通常@符号后面的第一个字符是一个小写字母。
  类变量：用于存储每个类层次结构的信息，它是以两个@@符号开头，其它与实例变量遵循相同的规则，例如，@@running_total。
  全局变量可以通过它们的前导美元符号来识别。美元符号后面的部分不遵循局部变量的命名约定。例如，全局变量$:, $1, $/,$stdin,$LOAD_PATH都是合法的全局变量名。只要以美元符号开头，它就是一个全局变量。
  在Ruby中，常量以大写字母开头，例如A, String, FirstName和STDIN都是合法的常量名。在用多个单词组成常量名时，Ruby的惯例是**使用驼峰大写字母（FirstName）或下划线分隔的全大写字母（FIRST_NAME）**。
在Ruby中，有许多预定义的关键字。例如def（方法定义）、class（类定义）、if（条件）和__FILE__（当前正在执行文件名），这样的关键字大约有40个，它们通常都是比较简短的标识符。
在Ruby中，方法名称遵循与局部变量相同的规则和惯例（除了它们能以?、!或=结尾）。在某些情况下，无法通过观察一个表达式来判断看到的是一个局部变量还是一个方法名，因为调用方法时可以省略圆括号——并且这是故意的。
Object Ruby把所有的数据结构和值，从简单的标量值（如整数和字符串常量）到复杂的数据结构（如数组）都看作是对象。每个对象都能理解一组特定的消息，每个消息都直接对应一个方法。
对象或是由字面量表示，就像双引号中的字符串一样，或是由它们被绑定的变量表示。消息的发送是通过特殊的点运算符实现的：点右边的消息被发送到点左边的对象。 实际上，还有其它更专业的方法来向对象发送消息，但点是最常见的基本方法。
在Ruby程序中，大部分的设计、逻辑和操作都围绕着对象进行。因此，在编写Ruby程序时，我们主要的工作是创建对象，赋予它们能力，并要求它们执行一些操作。
Ruby通过程序语言设计原则「面向对象」来实现通过对象操作数据。在面向对象编程 (OOP) 中，通过创建对象并要求它们执行操作并为你提供信息，来执行计算、数据操作和输入/输出操作。
在大多数面向对象的语言（包括 Ruby）中，每个对象都是特定类的实例，并且单个对象的行为至少在某种程度上由对象类中的方法定义决定。
所有Ruby对象在创建时都具有某些先天的能力，即它们知道如何执行某些方法。下面创建了一个通用的对象，并定义了一个talk方法：
obj = Object.new  def obj.talk  puts &amp;#34;I am an object.&amp;#34;  puts &amp;#34;(Do you object?)&amp;#34; end class Person  def initialize(name)  set_name(name)  end   def name  @first_name &#43; &amp;#39; &amp;#39; &#43; @last_name  end   private   def set_name(name)  first_name, last_name = name.split(/\s&#43;/)  set_first_name(first_name)  set_last_name(last_name)  end   def set_first_name(name)  @first_name = name  end   def set_last_name(name)  @last_name = name  end end  person1 = Person.new(&amp;#39;name&amp;#39;)  # 定义仅属于person1的方法 def person1.talk  puts &amp;#39;talk&amp;#39; end  person1.talk  person2 = Person.new(&amp;#39;test&amp;#39;) # person2不能调用talk方法，因为talk方法只属于person1 person2.talk  talk Uncaught exception: undefined method `talk&amp;#39; for #&amp;lt;Person:0x00007fece3188418 @first_name=&amp;#34;test&amp;#34;, @last_name=nil&amp;gt; Ruby中的方法很像数学函数：输入，计算，然后得出一个结果。为了给Ruby方法提供输入，可以用一个或多个参数来调用该方法：
obj = Object.new def obj.c2f(c)  c * 9.0 / 5 &#43; 32 end  puts obj.c2f(5) puts obj.c2f 100 #可以不使用圆括号 另一个值得注意的地方：当一个方法不需要参数时，定义时提供空圆括号是有效的Ruby语法，但*更常见的做法是省略这一对圆括号*：
def welcome_the_user()  puts &amp;#34;Hi there!&amp;#34; end  def welcome_the_user  puts &amp;#34;Hi there!&amp;#34; end  welcome_the_user() welcome_the_user  # 执行结果 Hi there! Hi there! 在Ruby中，每个方法调用都是表达式。当调用一个方法时，该调用会被评估为某种结果，这个结果是该方法的返回值。
任何方法的返回值都与该方法执行过程中最后求值的表达式的值相同。在温度转换方法obj.c2f中，最后求值的表达式是方法体的唯一一行c * 9.0 / 5 &#43; 32，所以该表达式的值就是obj.c2f方法的返回值。
Ruby可以使用关键字return来明确方法的返回值，但这个关键字的使用通常是可选的。它对于需要显式返回的场景很有用，其它情况均可以省略这个关键字：
def obj.c2f(c)  return c * 9.0 / 5 &#43; 32 end Ruby中的每个表达式都会被评估为一个对象，并且**每个对象都有一个真值**，几乎每个对象的真值都为true。唯一真值为false的是对象false和特殊的非实体对象nil。即在Ruby中，所有的东西都有一个布尔值，而有时它并不是我们所期望的那样：
if &amp;#34;abc&amp;#34;  puts &amp;#34;abc is true&amp;#34; end  if 123  puts &amp;#34;123 is true&amp;#34; end  puts &amp;#34;test&amp;#34; unless nil  # puts 作为表达式的返回值为nil，而nil的真值为false if puts &amp;#34;You&amp;#39;ll see this&amp;#34;  puts &amp;#34;but not this&amp;#34; end  abc is true 123 is true test 即使是一个新创建的对象也不是一块白板。一个对象一旦被创建，它就能对一些消息作出反应，也就是说每个对象创建时都具有某些先天能力。下面是Object对象创建时先天具有的一些方法（ruby版本不同，输出的结果会不同）：
p Object.new.methods.sort  [:!, :!=, :!~, :&amp;lt;=&amp;gt;, :==, :===, :=~, :__id__, :__send__, :class, :clone, :define_singleton_method, :display, :do_stuff, :dup, :enum_for, :eql?, :equal?, :extend, :freeze, :frozen?, :hash, :inspect, :instance_eval, :instance_exec, :instance_of?, :instance_variable_defined?, :instance_variable_get, :instance_variable_set, :instance_variables, :is_a?, :itself, :kind_of?, :method, :methods, :nil?, :object_id, :pretty_inspect, :pretty_print, :pretty_print_cycle, :pretty_print_inspect, :pretty_print_instance_variables, :private_methods, :protected_methods, :public_method, :public_methods, :public_send, :remove_instance_variable, :respond_to?, :send, :singleton_class, :singleton_method, :singleton_methods, :taint, :tainted?, :tap, :then, :to_enum, :to_s, :trust, :untaint, :untrust, :untrusted?, :yield_self] Ruby中的每个对象都有一个唯一的ID与之关联。可以调用对象的object_id方法来查看对象的id。在下面的代码中，尽管a和b名字不同，但它们所指的对象都是相同的：
a = Object.new b = a puts &amp;#34;a&amp;#39;s id is #{a.object_id}and b&amp;#39;s id is #{b.object_id}.&amp;#34;  obj = Object.new puts &amp;#34;The id of obj is #{obj.object_id}.&amp;#34;  str = &amp;#34;Strings are objects too, and this is a string!&amp;#34; puts &amp;#34;The id of the string object str is #{str.object_id}.&amp;#34;  c = 100 puts &amp;#34;And the id of the integer 100 is #{100.object_id}.&amp;#34; puts &amp;#34;And the id of var c is #{c.object_id}.&amp;#34;  string_1 = &amp;#34;Hello&amp;#34; string_2 = &amp;#34;Hello&amp;#34;  puts &amp;#34;string_1&amp;#39;s id is #{string_1.object_id}.&amp;#34; puts &amp;#34;string_2&amp;#39;s id is #{string_2.object_id}.&amp;#34;  # 执行结果 a&amp;#39;s id is 840 and b&amp;#39;s id is 840. The id of obj is 860. The id of the string object str is 880. And the id of the integer 100 is 201. And the id of var c is 201. string_1&amp;#39;s id is 900. string_2&amp;#39;s id is 920. 上面示例代码中，虽然string_1和string_2包含相同的字符串，但它们调用object_id方法后的返回值是不同，所以它们是不同的对象。在Ruby中赋予对象ID编号的作用之一是能够用它进行唯一标识，特别是能够确定两个对象是否为同一个对象。
如果有两个字符串，可以测试它们是否包含相同的字符，也可以测试它们是否为同一个对象。正如上面的示例代码，即使它们包含相同的字符，也不一定是同一个对象。
Ruby提供了多种方法来比较不同类型对象的相等性，比较对象ID是否相等只是衡量对象相等性的一种方法。现在，我们转向先天方法列表中的下一个方法：respond_to?。下面代码在发送talk消息时，可以先检查对象是否对talk响应：
if obj.respond_to?(&amp;#34;talk&amp;#34;)  obj.talk else   puts &amp;#34;Sorry, the object doesn&amp;#39;t understand the &amp;#39;talk&amp;#39; message.&amp;#34; end 实际上respond_to?方法是introspection或reflection，这两个术语是指在程序运行时检查程序的状态。Ruby提供了许多用于introspection的工具，使用方法检查某个方法是否为对象的方法就是一种introspection或reflection技术。
if ticket.respond_to?(request)  puts ticket.send(request) else  puts &amp;#34;No such information available&amp;#34; end send是一个广泛的概念：电子邮件被发送，数据被发送到I/O套接字等等。对于程序来说，定义一个叫做send的方法，与Ruby内置的send方法相冲突是很常见的事情。
因此，Ruby内置了send的一个替代方法__send__。一般来说，不会有人用这个名字定义一个新方法，所以内置的版本总是可用的。这看起来很奇怪，但从方法名称冲突的角度来看，比普通的send版本更安全。
此外，还有一个安全的，但方式不同的send 版本，叫做public_send方法。普通send和public_send的区别在于send可以调用对象的私有方法，而public_send不能。
if person2.respond_to?(&amp;#34;talk&amp;#34;)  person2.__send__(&amp;#39;talk&amp;#39;)  person2.send(&amp;#39;talk&amp;#39;)  person2.public_send(&amp;#39;talk&amp;#39;) else  puts &amp;#34;Sorry, the object doesn&amp;#39;t understand the &amp;#39;talk&amp;#39; message.&amp;#34; end 很多情况下使用点操作符来发送消息。但是，替代方法send可能是有用和强大的，也很容易出错，以至于几乎总是需要先调用response_to?方法。
如果从用户那里获取输入信息，并使用它来调用方法，这可能会出现意想不到的行为，甚至是恶意的攻击。指导原则是要小心向对象发送任意的消息，特别是当这些消息是基于用户的选择或输入时。
当调用方法时，必须提供正确数目的实参，如果提供错误数目的实参，则会出现编译错误。下面one_arg方法只接受一个参数，若调用该方法时多于一个实参时就会出现编译错误：
obj = Object.new def obj.one_arg(x)  puts &amp;#34;I require one and only one argument!&amp;#34; end obj.one_arg(1, 2, 3)  Uncaught exception: wrong number of arguments (given 3, expected 1) 如果想要一个方法接受多个参数，可以在参数前面加一个*前缀。下面的方法multi_args调用的时候可以传0个或多个参数：
obj = Object.new  def obj.multi_args(*x)  puts &amp;#34;I can take zero or more arguments! #{x}&amp;#34; end  obj.multi_args(12, 34, 56)  obj.multi_args(1, 2, 3)  I can take zero or more arguments! [12, 34, 56] I can take zero or more arguments! [1, 2, 3]  def two_or_more(a, b, *c)  puts &amp;#34;I require two or more arguments!&amp;#34;  puts &amp;#34;And sure enough, I got: &amp;#34;  p a, b, c end  two_or_more(1,2,3,4,5)  # 执行结果 I require two or more arguments! And sure enough, I got: 1 2 [3, 4, 5] 方法定义时的某些参数也可以有默认值。下面方法default_args定义时增加了第三个参数c，一个带有默认值的参数：
def default_args(a, b, c = 1)  puts &amp;#34;Values of variables: &amp;#34;, a, b, c end default_args(3,2)  # 执行结果 Values of variables: 3 2 1 在方法调用时，各类参数解析有一定的规则：
def mixed_args(a, b, *c, d)  puts &amp;#34;Arguments:&amp;#34;  p a, b, c, d end  mixed_args(1, 2, 3, 4, 5)  1 2 [3, 4] 5  mixed_args(1,2,3)  1 2 [] 3 下图提供了一个参数分配逻辑的图形表示。参数分配的优先级顺序为：首先处理必需的参数，然后是有默认值的可选参数，最后是可变参数：
也就是说，所有参数都是有顺序的。必须参数具有最高优先权，无论它们出现在参数列表的左边还是右边，所有具有默认值的参数必须出现在中间，必须参数可以放在两边：
def broken_args(x, *y, z = 1) end   syntax error, unexpected &amp;#39;=&amp;#39;, expecting &amp;#39;)&amp;#39; Local variables and variable assignment 局部变量以小写字母或下划线开始，并且以字母、数字和下划线组成。下面都是合法的局部变量名：x,_x,name,firs_name,plan9,user_ID,_。局部的意思是仅在程序的某个部分可见，惯用命名法是下划线而非驼峰命名：
def say_goodbye  x = &amp;#34;Goodbye&amp;#34;  puts x end  def start_here  x = &amp;#34;Hello&amp;#34;  puts x  say_goodbye  puts &amp;#34;Let&amp;#39;s check whether x remained the same:&amp;#34;  puts x end  start_here  # 执行结果 Hello Goodbye Let&amp;#39;s check whether x remained the same: Hello 变量赋值给人的感觉是使左边的变量被设置为右边的对象:
str = &amp;#34;Hello&amp;#34; 下面代码中，虽然只是替换了变量str的值，但是变量abc的值也被替换了。这是因为变量不持有对象的值，只是对象的引用，str只是string对象的引用。
def say_goodbye  str = &amp;#34;Hello&amp;#34;  abc = str  str.replace(&amp;#34;Goodbye&amp;#34;)  puts str  puts abc end  say_goodbye  # str和abc的结果一样 Goodbye Goodbye 在一次赋值中，如果左边是变量名，右边是一个对象，那么该变量收到的是该对象的一个引用。但在一个变量到另一个变量的赋值中（abc = str），左边的变量收到了储存在右边变量中的引用的副本，结果两个变量现在都指向同一个对象的引用。
在Ruby中有些对象是作为即时值存储在变量中的。这些对象包括整数、符号（看起来像:this），以及特殊对象true、false和nil。当把这些值赋给给一个变量时（例如x = 1），那么该变量持有该值本身，而不是值对应的引用。
但是即时值表示规则有几个有趣的变化，特别是当它涉及到整数时。首先，任何被表示为即时值的对象都是完全相同的对象，无论它被赋值到多少个变量。例如，只有一个对象100，只有一个对象false，以此类推。
x = 1 puts x.object_id y = 1 puts y.object_id  # x和y的对象id是一样的 3 3  x = false y = false puts x.object_id puts y.object_id  # x和y的对象id是一样的 0 0 整数绑定变量后导致的直接结果是Ruby缺乏前置和后置递增运算符。也就是说，不能在Ruby中进行如下方式操作整数变量：
x = 1 x&#43;&#43;  syntax error, unexpected end-of-input 对于Ruby中的每个对象，有且必须有一个或多个指向该对象的引用。如果没有指向该对象的引用，那么该对象被认为是失效的，其内存空间就会被回收并重新使用。
如果有两个或更多的变量指向同一个对象，可以在平等的基础上使用其中的任何一个变量来向该对象发送消息。引用与它们的对象可以是多对一的关系，如果把一个全新的对象分配给一个已经指向另一个对象的变量，事情就会发生变化：
str = &amp;#34;Hello&amp;#34; abc = str str = &amp;#34;Goodbye&amp;#34; puts str puts abc  # 执行结果 Goodbye Hello 在上面的代码中，给str第二次赋值时用了一个完全不同的对象。此后，str便指向了新的对象，但变量abc依然指向旧的对象。
上面这些例子使用局部变量来演示当赋值给一个已经被赋值的变量时会发生什么。但在这里看到的规则和行为并不只是针对局部变量，类、全局和实例变量都遵循同样的规则。
与静态语言不同，Ruby变量没有类型，变量可以在任何时候被绑定到任何类型的任何对象上。因此，引用和（再）赋值的语义对调用一个带参数方法时有重要影响。该方法会收到什么？该方法能用它做什么？
References and method arguments 下面代码表明在change_string方法中，变量str被分配了一个指向字符串的引用。一旦方法持有了一个引用，它通过该引用对该对象所做的任何改变都是对其它引用都是可见的：
def change_string(str)  str.replace(&amp;#34;New string content!&amp;#34;) end  s = &amp;#34;Original string content!&amp;#34; puts s # 方法中会改变传过来的参数 change_string(s) puts s  # 执行结果 Original string content! New string content! 如果想保护对象不在方法中被改变，可以使用dup方法，该方法可以复制一个对象：
def change_string(str)  str.replace(&amp;#34;New string content!&amp;#34;) end s = &amp;#34;Original string content!&amp;#34; puts s change_string(s.dup) puts s  Original string content! Original string content! 也可以冻结一个对象，这样可以防止它发生进一步变化:
def change_string(str)  str.replace(&amp;#34;New string content!&amp;#34;) end s = &amp;#34;Original string content!&amp;#34; puts s s.freeze change_string(s) puts s  Uncaught exception: can&amp;#39;t modify frozen String: &amp;#34;Original string content!&amp;#34; 需要注意的是，freeze是永久的，且没有对应的unfreeze方法。还有一个方法叫clone，它很像dup，不同的是，如果clone一个冻结的对象，clone后的新对象也是被冻结的。如果dup一个冻结的对象，dup后的新对象不会被冻结。
对于数组而言，即使调用了freeze方法，数组里面的对象仍然可能被改变，并且这是合法的。下面的代码不会产生编译错误：
numbers = [&amp;#34;one&amp;#34;, &amp;#34;two&amp;#34;, &amp;#34;three&amp;#34;] numbers.freeze # 虽然数组本身被冻结了，但还可以改变数组中的某个元素 # 只是数组不能再次被赋值 numbers[2].replace(&amp;#34;four&amp;#34;) p numbers # 执行结果 [&amp;#34;one&amp;#34;, &amp;#34;two&amp;#34;, &amp;#34;four&amp;#34;]  numbers = %w[one two three] numbers.freeze numbers[2].replace(&amp;#34;four&amp;#34;) p numbers # 执行结果[&amp;#34;one&amp;#34;, &amp;#34;two&amp;#34;, &amp;#34;four&amp;#34;] 数组调用freeze的意思是不能改变数组，即指向数组对象的引用不能再被赋值。但是，数组里面的某个对象还是可以被改变的。
Local variables and the things that look like them 当Ruby看到一个普通的单词（裸词标识符），例如s、ticket、puts或user_name这些词，会将其理解为下面三种情况之一：
 局部变量 关键字 方法调用  关键字是特殊的保留字，不能用它们作为变量名。在Ruby中方法调用可以是普通的单词（不包含圆括号），或者是一对圆括号中包含参数列表。如果普通单词后面跟上一对圆括号，显然不是局部变量。对于其它情况，可能会有一些含糊不清的地方，Ruby必须弄清楚：
 如果标识符是一个关键字，Ruby能够识别到（Ruby有一个内部关键字列表）。 如果标识符的右边有一个等号（=），那么它就是一个正在进行赋值的变量。 否则，标识符会被认为是一个局部变量或方法调用。Ruby解释器对*这两者的处理方式是相同的*。  Ruby将call推测到的局部变量或方法，这会导致标识符被评估。如果使用的标识符不是上面列出的三种中的任何一种，那么Ruby将以致命错误停止执行：
ruby -e &amp;#34;x&amp;#34;  Traceback (most recent call last): -e:1:in `&amp;lt;main&amp;gt;&amp;#39;: undefined local variable or method `x&amp;#39; for main:Object (NameError) Organizing objects with classes 使用Object.new创建一个新的对象，并为这个对象创建它自己的方法，一次定义一个新方法，这是感受Ruby以对象为中心编程的一个好方法。
定义一个类可以把方法组合成一个通用集合，这样就可以快速创建许多行为相同的对象。虽然可以为单个对象添加方法，但如果把我们的领域建模为类，就不必对每个对象都这样做了。
在Ruby中处理的所有东西要么是一个对象，要么是一个可以评估为对象的结构体，而每个对象都是某个类的实例。整数是一个类的实例，而类本身就是对象。
一个典型的类是由方法定义集合组成的。类的存在通常是为了被实例化，也就是说，创建的对象是类的实例。例如，之前创建了一个类的实例：
obj = Object.new 实际上Object是一个内置类，当在一个类上使用点符号时，就是向该类发送了一条消息。类可以响应消息，就像对象一样。事实上，类就是对象，new方法是一个构造函数，这个方法的目的是制造并返回给一个新的实例。
可以使用class关键字来定义一个类，类的命名规则和常量的一致：
class Ticket  def event  &amp;#34;Can&amp;#39;t really be specified yet...&amp;#34;  end end 现在可以创建一个新的Ticket实例，并能够调用event方法：
ticket = Ticket.new puts ticket.event  # 调用了event方法 Can&amp;#39;t really be specified yet... 为一个特定对象定义的方法（例如def ticket.price）被称为**单子方法**。在类中定义一个实例方法后，没有什么可以阻止再次定义它。也就是说，新定义的实例方法会覆盖之前定义的方法。
下面的类C定义了两个m方法，新的版本会优先使用：
class C  def m  puts &amp;#34;First definition of method m&amp;#34;  end   def m  puts &amp;#34;Second definition of method m&amp;#34;  end end  C.new.m // 调用方法m  # 执行结果 Second definition of method m 实例变量使单个对象能够记住状态，它的工作方式与其它变量很相似。可以给它们赋值，然后读取这些值，把它们加在一起，打印出来等等。但实例变量有一些区别：
 实例变量名称总是以一个@开始。 实例变量只对它们所属的对象可见。(「对一个对象可见」有一个技术上的定义，与默认的对象self有关)。 在一个类方法中初始化的实例变量可以被该类中定义的任何实例方法使用。  class Person  def set_name(string)  puts &amp;#34;Setting person&amp;#39;s name...&amp;#34;  @name = string  end   def get_name  puts &amp;#34;Returning the person&amp;#39;s name...&amp;#34;  @name  end end  joe = Person.new joe.set_name(&amp;#34;Joe&amp;#34;) puts joe.get_name  # 执行结果 Setting person&amp;#39;s name... Returning the person&amp;#39;s name... Joe 当编写一个类时，可以定义一个特殊的方法，称为initialize。如果这样做了，每次创建一个新的类的实例时，这个方法就会被自动调用：
class Ticket  def initialize  puts &amp;#34;Creating a new ticket!&amp;#34;  end end  Ticket.new  # 执行结果 Creating a new ticket! 当需要在程序中的某个点设置或改变对象的状态，核心是为实例变量赋值（或重新赋值）。也可以在任何方法中改变任何实例变量的值。例如，如果想让门票具有打折的能力，可以在Ticket类的定义中写一个实例方法:
def discount(percent)  @price = @price * (100 - percent) / 100.0 end Data, Expressions, and Flow Control 计算机程序几乎所有的时间都在操作数据或等待数据从其它地方送达。当输入文字、短语和数字，听音乐，看视频时计算机进行计算，作出决定，并向我们传递信息。要编写计算机程序，必须先了解数据及其操作的基本知识。
Numbers and Expressions 编程时，表达式是数据（例如数字或字符串）、运算符（例如&#43;或-）和变量的组合。当计算机理解这些表达式时，会产生某种形式的结果。Ruby代码是由表达式组成的，每个表达式都会被评估为一个特定的值：
5 1 &#43; 2 &amp;#34;a&amp;#34; &#43; &amp;#34;b&amp;#34; &#43; &amp;#34;c&amp;#34; 100 - 5 * (2 - 1) x &#43; y 变量是占位符或对象的引用，包括数字、文本或创建的任何类型的对象。可以随心所欲地命名变量，只是有一些限制，必须满足下面3个条件：
 变量名称必须是一个单元（中间不能有空格）。 必须以字母或下划线开头，不能以数字开头。 必须只包含字母、数字或下划线，并且区分大小写。     变量名 是否有效     x 是   Y2 是   _x 是   7x 否，字母开头   this_is_a_test 是   this is a test 否，包含空格   this&amp;rsquo;is@a&amp;rsquo;test! 否，包含特殊字符‘，@，！   this-is-a-test 否，包含特殊字符-    由于变量是值和数据的占位符，因此它们也可以用某个表达式的结果进行赋值（例如x = 2 - 1）并将其用于表达式本身（例如x - y &#43; 2）。
没有逻辑的程序仅仅是一个计算器。计算机不只是对数据进行单一操作，还使用逻辑来决定不同的行动方案。逻辑的一个基本形式是在表达式中使用比较运算符来做决定:
age = 10 puts &amp;#34;You&amp;#39;re too young to use this system&amp;#34; if age &amp;lt; 18  age = 24 puts &amp;#34;You&amp;#39;re NOT a teenager&amp;#34; unless age &amp;gt; 12 &amp;amp;&amp;amp; age &amp;lt; 20 Ruby提供了另一个更方便的between?方法。如果对象等于两个提供的边界值，或介于它们之间，会返回true，否则返回false。例如，在处理整数时，age.between?(13, 19)相当于age &amp;gt;= 13 &amp;amp;&amp;amp; age &amp;lt;= 19：
age = 18 puts &amp;#34;You&amp;#39;re a teenager&amp;#34; if age.between?(12, 20) puts和print的区别 函数puts输出内容后会自动将光标移动到下一行，但print不会换行。在下面代码中，print输出内容后不会换行，所以使用puts输出world时将紧接着hello，然后再换行，最后输出test再换行：
print(&amp;#34;hello &amp;#34;) puts(&amp;#34;world&amp;#34;) puts(&amp;#34;test&amp;#34;)  # 执行结果 # hello world # test Looping Through Numbers with Blocks and Iterators 下面代码中，首先取了5，然后调用其times方法（这个方法对于所有的数值类型都适用）。此时，不是向times方法传递数据，而是传递代码，即do和end之间的代码。然后，times方法将会连续使用该代码5次:
5.times do puts &amp;#34;Test&amp;#34; end 另一种方式是用花括号代替do和end。尽管鼓励do和end用于多行代码块，但花括号使代码在单行上更易于阅读。因此，下面代码执行后结果完全相同：
5.times { puts &amp;#34;Test&amp;#34;}  # 执行结果 Test Test Test Test Test  5.times { puts _1 }  # 执行结果 0 1 2 3 4 也就说，对于单行代码建议使用花括号，多行代码块建议使用do和end。这是一种惯例，几乎所有Ruby开发者都遵循这种风格。
在Ruby中，有一种创建循环的机制称为迭代器，迭代器用于逐个遍历列表中的东西。还有其它迭代器可用于数值类型，下面是3个常用的迭代器：
1.upto(5) { ...code to loop here... }  10.downto(5) { ...code to loop here... }  0.step(50, 5) { ...code to loop here... }   1.upto(5) { puts _1 }  # 执行结果 1 2 3 4 5  9.downto(7) { puts _1 }  # 执行结果 9 8 7  6.step(20, 6) { puts _1 }  # 执行结果 6 12 18  30.step(10, -4) { puts _1 }  # 执行结果 30 26 22 18 14 10 目前为止还不知道每一步迭代的数字，若知道迭代数字就可以在循环中使用它做一些事情。上面的所有迭代器都会自动将当前迭代的状态作为参数传递给循环代码，实际上可以将其提取到一个变量中使用：
1.upto(5) do |number|  puts number end  6.downto(1) do |i|  puts i end  1.step(50, 10) do |i|  puts i end # 执行结果 1 11 21 31 41  10.times do |i|  puts i end 需要注意的是，有些方法会执行代码块并传递数据，然后这些数据能够捕获到变量中。上面示例代码中，对整数可用的upto方法将每次迭代的值传递到代码块中，我们将其captured到变量number中，以便在代码块中使用。
Floating Point Numbers 默认情况下，Ruby将没有小数点的数字视为整数。当使用10 / 3 时，实际上是要求Ruby将两个整数相除，结果也是一个整数。因此，下面代码运行后的结果为3，而不是3.333：
puts 10 / 3 如果将代码做一些小小的改动：
puts 10 / 3.0 puts 10.0 / 3 puts 10.0 / 3.0 那么，上面3个表达式输出的结果是3.3333333333333335。上面代码中Ruby处理Float类型的数字对象，并返回一个Float，并提供期望的精度级别。
在某些情况下，无法控制传入的数字，但仍希望将它们被视为浮点数。考虑下面这种情况，用户输入两个要除的数字，而这些数字需要一个精确的结果：
x = 10 y = 3 puts x / y 上面代码中两个输入数字都是整数，所以结果只会是一个整数。幸运的是，整数有一种特殊的方法可以即时将自身转换为浮点数，只需像下面这样重写代码即可：
x = 10 y = 3 puts x.to_f / y 相似地，浮点数也可以转换为整型，只要使用to_i方法即可：
puts(5.7.to_i) puts(5.7.to_int)  # 执行结果 5 5 Constants 考虑一些永远不会改变的值——例如pi的值，这些不变的值称为常量。在Ruby中可以用以大写字母开头的变量名来表示：
Pi = 3.141592  puts(Math::PI) # 3.141592653589793  Math::PI = 34 # warning: already initialized constant Math::PI puts(Math::PI) # 34 如果尝试改变Pi的值，虽然目前是可以的，但编译器会产生警告already initialized constant Pi。需要注意的是，修改常量不会出现编译错误，只是一个警告，但不建议这样做。
实际上，目前在Ruby中可以改变常量的值，但编译器会发出明确的警告信息。将来，Ruby可能会对常量实施更严格的控制，因此尽量不要在程序中给常量重新赋值。
Text and Strings 字符串是任意长度的文本字符（包括数字、字母、空格和符号）的集合。Ruby中所有字符串都是String类型，可以通过调用字符串的类方法class来证实：
puts &amp;#34;Hello world&amp;#34;.class # String 如同数值类型，字符串也可以使用操作符：
x = &amp;#34;Test&amp;#34; y = &amp;#34;String&amp;#34; puts &amp;#34;Success!&amp;#34; if x &#43; y == &amp;#34;TestString&amp;#34;  # 执行结果 Success! 需要注意的是，双引号仅适用单行字符串，如果想要字符串文本跨越多行，可以使用如下方式：
x = %q{This is a test of the multi line capabilities} puts x  # 执行结果 This is a test of the multi line capabilities 上面例子中，多行字符串以%q{}包裹。实际上分隔符使用一对花括号是非必须的，也可以使用&amp;lt;和&amp;gt;，或（和），或者简单地使用自己选择的其它定界符，例如！和！。下面代码将以完全相同的方式工作：
x = %q!This is a test of the multi line capabilities! puts x  x = %q&#43;This is a test of the multi line capabilities&#43; puts x 如果使用感叹号作为分隔符，那么字符串文本中的任何感叹号都会导致多行字符串提前结束，Ruby会认为剩余的字符串文本都是错误的，所以应该谨慎地选择多行字符串的分隔符：
x = %q!This is a test of the multi line! capabilities! puts x  # Uncaught exception: undefined method `capabilities!&amp;#39; for main:Object 构建多行字符串字面量的另一种方法是使用here文档或heredoc，这个概念在许多其它编程语言中都可以找到。它的工作方式与前面的示例代码类似，不同之处在于**分隔符可以是多个字符**：
x = &amp;lt;&amp;lt;END_MY_STRING_PLEASE This is the string And a second line END_MY_STRING_PLEASE puts x  # 执行结果 This is the string And a second line  x = &amp;lt;&amp;lt;END_TEST This is the string And a second line END_TEST puts x  # 执行结果 This is the string And a second line 在上面示例代码中，&amp;lt;&amp;lt;标记字符串字面量的开头，然后使用END_MY_STRING_PLEASE作为字符串常量的分隔符。字符串真正的内容从下一个新行开始，分隔符在最后一行再次重复时表示字符串字面量结束。
当比较字符串时，实际上比较的是字符串中每个字符对应的数字，即字符的ASCII码值。如前所述，字符在计算机内存中存储为数字，每个字母和符号都有一个值，称为ASCII码值。
puts &amp;#34;Success!&amp;#34; if &amp;#34;Test&amp;#34; &#43; &amp;#34;String&amp;#34; == &amp;#34;TestString&amp;#34; puts &amp;#34;abc&amp;#34; * 5 puts &amp;#34;x&amp;#34; &amp;gt; &amp;#34;y&amp;#34;  # 执行结果 Success! abcabcabcabcabc false 可以通过字符的ord方法获取ASCII值。相应地，也可以通过chr函数将ASCII码值转换为相应字符：
puts &amp;#34;x&amp;#34;.ord #Integer puts 120.chr #String  # 执行结果 120 x 插值是指将表达式的结果插入到字符串常量中的过程。在字符串中进行插值的方法是将表达式放在#{}内。下面是一个简单的例子：
x = 10 y = 20 puts &amp;#34;#{x}&#43; #{y}= #{x &#43; y}&amp;#34; # 10 &#43; 20 = 30 puts &amp;#34;100 * 5 = #{100 * 5}&amp;#34; # 100 * 5 = 500 x = &amp;#34;cat&amp;#34; puts &amp;#34;The #{x}in the hat&amp;#34; # The cat in the hat puts &amp;#34;It&amp;#39;s a #{&amp;#34;bad &amp;#34; * 5}world&amp;#34; # It&amp;#39;s a bad bad bad bad bad world  # 执行结果 10 &#43; 20 = 30 100 * 5 = 500 The cat in the hat It&amp;#39;s a bad bad bad bad bad world Regular Expressions 正则表达式本质上是一个搜索查询，不要与表达式混淆。如果想要替换字符串中的某些字符，可以使用sub方法。但是sub只替换第一次出现的字符，如果要做全局替换，需要使用gsub方法：
puts &amp;#34;foobar&amp;#34;.sub(&amp;#39;bar&amp;#39;, &amp;#39;foo&amp;#39;) # foofoo puts &amp;#34;this is a test&amp;#34;.gsub(&amp;#39;i&amp;#39;, &amp;#39;&amp;#39;) # ths s a test  # 执行结果 foofoo ths s a test 如果要替换开头的两个字符，可以使用如下方式：
x = &amp;#34;This is a test&amp;#34; puts x.sub(/^../, &amp;#39;Hello&amp;#39;)  # 执行结果 Hellois is a test 上面的代码中，sub方法的第一个参数不是字符串，而是一个正则表达式。在正则表达式中^是一个锚点，意味着正则表达式将从字符串中行的开头开始匹配。其中的.代表任何字符。也就是说，/^../意味着「紧随一行开始之后的任何两个字符」。因此，This is a test的Th被替换为Hello。类似地，下面代码替换行字符串最后两个字符为Hello：
x = &amp;#34;This is a test&amp;#34; puts x.sub(/..$/, &amp;#39;Hello&amp;#39;)  # 执行结果 This is a teHello  x = &amp;lt;&amp;lt;TEST this is a test dddd TEST puts x.sub(/..$/, &amp;#39;Hello&amp;#39;) # $表示行尾  # 执行结果 this is a tesHello dddd 如果想锚定一个字符串的绝对开始或结束，可以分别使用\A和\Z（字母均为大写），而^和$则只是锚定一个字符串中的行的开始和结束:
x = &amp;lt;&amp;lt;TEST This is a test dd TEST puts x.sub(/..\Z/, &amp;#39;Hello&amp;#39;)  # 执行结果 This is a test Hello  x = &amp;lt;&amp;lt;TEST This is a test dd TEST puts x.sub(/\A../, &amp;#39;NA&amp;#39;)  # 执行结果 NAis is a test dd 如果想遍历一个字符串中的每个字符，怎么办呢？scan就是我们要找的迭代器方法。下面代码中，scan方法扫描字符串以查找与传递给它的正则表达式匹配的任何内容：
&amp;#34;xyz&amp;#34;.scan(/./) { |letter| puts letter }  # 执行结果 x y z 上面示例代码中，提供了一次查找单个字符的正则表达式。这就是在输出中分别得到x、y和z的原因。每个字母都被输入到块中，赋值给letter，然后打印到屏幕上。
&amp;#34;This is a test&amp;#34;.scan(/../) { |x| puts x } 上面代码中，一次扫描两个字符，执行结果如下：
Th is  i s a te st 实际上，上面扫描的结果中是包含空格的，如果想要只包含数字和字母，可以使用如下方式：
&amp;#34;This is a test&amp;#34;.scan(/\w\w/) { |x| puts x }  Th is is te st 上面的\w表示任何数字和字母字符以及下划线。在正则表达式中，有一些用反斜杠表示的特殊字符，它们具有特殊含义，如下表所示：
参考上表，可以很轻松地从字符串中提取所有数字：
&amp;#34;The car costs $1000 and the cat costs $10&amp;#34;.scan(/\d&#43;/) do |x|  puts x end  # 执行结果 1000 10 在上面\d后面跟着的&#43;被称为修饰器，它表示尽可能多地匹配，并且至少匹配一个。如果不添加&#43;，则只会匹配一个数字：
&amp;#34;The car costs $1000 and the cat costs $10&amp;#34;.scan(/\d/) do |x|  puts x end  # 执行结果 # 1 # 0 # 0 # 0 # 1 # 0 还有其它类型的修饰符，如下表所示：
在正则表达式中，还有一个重要的方面是字符类，它允许匹配一组特定的字符。例如，可以扫描字符串中的所有元音字符：
&amp;#34;This is a test&amp;#34;.scan(/[aeiou]/) { |x| puts x }  # 执行结果 # i # i # a # e 也可以在方括号内指定字符范围：
&amp;#34;This is a test&amp;#34;.scan(/[a-m]/) { |x| puts x }  # 执行结果 # h # i # i # a # e 进行替换并从字符串中提取某些文本很有用，但有时只想检查某个字符串是否与选择的模式匹配。如果字符串包含任何元音，你可能希望快速确定：
puts &amp;#34;String has vowels&amp;#34; if &amp;#34;This is a test&amp;#34; =~ /[aeiou]/  # 执行结果 String has vowels 在上面的代码中=~是匹配运算符，如果字符串与运算符后面的正则表达式匹配，则表达式会返回第一个匹配项的位置（在上面这种情况下返回的是2——逻辑上为true，因此满足if条件）。当然，也可以做相反的事情：
puts &amp;#34;String contains no digits&amp;#34; unless &amp;#34;This is a test&amp;#34; =~ /[0-9]/  # 执行结果 String contains no digits 上面代码的意思是除非0到9的数字范围与测试字符串匹配，否则告诉用户字符串中没有数字。也可以使用String类提供的match方法。=~根据正则表达式是否匹配字符串，返回第一个匹配项的位置或nil，而match提供了更多的功能。
puts &amp;#34;String has vowels&amp;#34; if &amp;#34;This is a test&amp;#34;.match(/[aeiou]/)  # 执行结果 String has vowels 在正则表达式中，如果用圆括号（）括住表达式的一部分，则与正则表达式该部分匹配的数据将与其余部分分开使用，match允许访问此数据：
x = &amp;#34;This is a test&amp;#34;.match(/(\w&#43;) (\w&#43;)/) puts x[0] puts x[1] puts x[2]  # 执行结果 This is This is 字符串的match方法返回一个MatchData对象，它可以像数组一样被访问。第一个元素（x[0]）包含由整个正则表达式匹配的数据。剩下的每个连续的元素都包含被正则表达式的每个匹配组所匹配的数据。在上面的例子中，第一个（\w&#43;）匹配的是This，第二个（\w&#43;）匹配的是is。
Arrays and Lists 数组是**对象的有序集合**。有序的意思是可以根据一致的、连续的数字索引从这个集合中选择对象。数组中的对象可以是hash，file handle，classes，true和false，以及其它任意对象。
在数组中，每个元素都用逗号与其相邻元素隔开，方括号用于表示数组字面量。数组中的每个元素都可以使用索引访问，索引是从0开始，如果索引越界不会发生闪退现象，而是取到空值nil：
x = [1, 2, 3, 4] puts x[2] # 3 puts x[4] # nil puts x[4] == nil #true  a = Array.new(3, &amp;#34;5&amp;#34;) puts a # 执行结果 5 5 5  a = Array.new(3) { |i| 10 * (i &#43; 1) } p a # 执行结果 [10, 20, 30]   a = [1, 2, &amp;#34;three&amp;#34;, 4, []] p a # 执行结果 [1, 2, &amp;#34;three&amp;#34;, 4, []]  string = &amp;#34;A string&amp;#34; p string.respond_to?(:to_ary) p string.respond_to?(:to_a) p Array(string)  # 执行结果 false false [&amp;#34;A string&amp;#34;]  # 定义了string的转换为数组的方法 def string.to_a  split(//) end  p Array(string) # 执行结果 [&amp;#34;A&amp;#34;, &amp;#34; &amp;#34;, &amp;#34;s&amp;#34;, &amp;#34;t&amp;#34;, &amp;#34;r&amp;#34;, &amp;#34;i&amp;#34;, &amp;#34;n&amp;#34;, &amp;#34;g&amp;#34;]  p %w{ Joe Leo III } p %w(David\ A.\ Black is a Rubyist.)  # 执行结果 [&amp;#34;Joe&amp;#34;, &amp;#34;Leo&amp;#34;, &amp;#34;III&amp;#34;] [&amp;#34;David A. Black&amp;#34;, &amp;#34;is&amp;#34;, &amp;#34;a&amp;#34;, &amp;#34;Rubyist.&amp;#34;] 数组不需要设置预定义元素，可以像下面这样先创建一个空数组。然后使用&amp;lt;&amp;lt;操作符往数组末尾添加新的元素，或者使用数组的push方法添加新元素：
x = [] x &amp;lt;&amp;lt; &amp;#34;test&amp;#34; p x x.push(&amp;#34;hello&amp;#34;) p x  # 执行结果 [&amp;#34;test&amp;#34;] [&amp;#34;test&amp;#34;, &amp;#34;hello&amp;#34;] 也可以从数组中一个个移除元素。Ruby中的数组可以充当栈，遵循「后进先出」原则，新的元素被推送到数组的末尾并从末尾被弹出:
x = [] x &amp;lt;&amp;lt; &amp;#34;Word&amp;#34; x &amp;lt;&amp;lt; &amp;#34;Play&amp;#34; x &amp;lt;&amp;lt; &amp;#34;Fun&amp;#34; puts x.pop # 影响原数组 puts x.pop puts x.length p x  # 执行结果 Fun Play 1 [&amp;#34;Word&amp;#34;] 如果数组中的元素都是字符串，可以使用join方法将所有元素连接起来：
x = [&amp;#34;Word&amp;#34;, &amp;#34;Play&amp;#34;, &amp;#34;Fun&amp;#34;] puts x.join, x.join(&amp;#34;,&amp;#34;)  # 执行结果 WordPlayFun Word,Play,Fun 也可以使用split方法将字符串分隔成数组：
puts &amp;#34;Short sentence. Another. No more.&amp;#34;.split(/\./).inspect  # 执行结果 [&amp;#34;Short sentence&amp;#34;, &amp;#34; Another&amp;#34;, &amp;#34; No more&amp;#34;] 因为在正则表达式中.表示任意字符，所以使用\.来表示真正的点符号（加上反斜杠来对其进行转义，转义是专门表示一个字符以明确其含义的过程）。几乎所有的内置类均有inspect方法，它提供了对象的文本表示：
puts &amp;#34;Words with lots of spaces&amp;#34;.split(/\s&#43;/).inspect  # 执行结果 [&amp;#34;Words&amp;#34;, &amp;#34;with&amp;#34;, &amp;#34;lots&amp;#34;, &amp;#34;of&amp;#34;, &amp;#34;spaces&amp;#34;] p方法也很重要，它是inspect的替代方法，前面的代码也可以这样写：
p &amp;#34;Words with lots of spaces&amp;#34;.split(/\s&#43;/)  # 执行结果 [&amp;#34;Words&amp;#34;, &amp;#34;with&amp;#34;, &amp;#34;lots&amp;#34;, &amp;#34;of&amp;#34;, &amp;#34;spaces&amp;#34;] p是puts的一个非常有用的替代品，它可以自动显示后面表达式返回对象的结构。这个方法几乎不需要在生产应用中使用它，但对于调试和学习来说是非常好的。
Array Iteration 对于数组，可以使用each方法进行迭代，也可以使用collect方法即时转换数组。map方法从功能上说是等同于collect方法：
p [1, 2, 3, 4].collect { |element| element * 2 } p [1, 2, 3, 4].map { |element| element * 2 }  # 执行结果 [2, 4, 6, 8] [2, 4, 6, 8]   x = [12, 34, 56, 78, 90] p x x.collect { |item| 2 * item } p x  # 执行结果 [12, 34, 56, 78, 90] [12, 34, 56, 78, 90]   x = [12, 34, 56, 78, 90] p x x.collect! { |item| 2 * item } # !表示会改变原有数组 p x x.map! { |item| 2*item} # !表示会改变原有数组 p x  # 执行结果 [12, 34, 56, 78, 90] [24, 68, 112, 156, 180] [48, 136, 224, 312, 360] 数组也可以直接使用&#43;和-操作符：
x = [1, 2, 3] y = [&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;] z = x &#43; y p z  x = [1, 2, 3, 4, 5] y = [1, 2, 3] z = x - y p z  # 执行结果 [1, 2, 3, &amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;] [4, 5] 数组的empty?方法可以用于检查数组中元素是否为空。而include?方法可以用于判断数组中是否包含某个元素：
x = [] puts &amp;#34;x is empty&amp;#34; if x.empty?  x = [1, 2, 3] p x.include?(&amp;#34;x&amp;#34;) p x.include?(3)  # 执行结果 x is empty false true 数组的first方法用于获取第一个元素，last方法用于获取最后一个元素。如果在first和last方法中传递一个数字，那么将从数组的开头或结尾获取该数量的元素：
x = [1, 2, 3] puts x.first puts x.last puts x.first(2).join(&amp;#34;-&amp;#34;) puts x.last(2).join(&amp;#34;,&amp;#34;)  # 执行结果 1 3 1-2 2,3 Hashes 数组是对象的集合，Hash也是对象的集合。但是，Hash用了不同的存储格式来定义集合中的每个对象，它更像一个字典，而不是一个列表。Hash没有保证先后顺序，只是键和值之间的简单链接。数组和hash是紧密连接的，从某种意义来说，数组也是一种hash，只不过其key是整数。
dictionary = { cat: &amp;#34;feline animal&amp;#34;, dog: &amp;#34;canine animal&amp;#34; } p dictionary.size p dictionary.keys p dictionary.values p dictionary[:dog] #获取value p dictionary[:nor] #nil  # 执行结果 2 [:cat, :dog] [&amp;#34;feline animal&amp;#34;, &amp;#34;canine animal&amp;#34;] &amp;#34;canine animal&amp;#34; nil  hash = { red: &amp;#34;ruby&amp;#34;, white: &amp;#34;diamond&amp;#34;, green: &amp;#34;emerald&amp;#34; } hash.each_with_index do |(key, value), i|  puts &amp;#34;Pair #{i}is: #{key}/#{value}&amp;#34; end  # 执行结果 Pair 0 is: red/ruby Pair 1 is: white/diamond Pair 2 is: green/emerald Hash中的key和value可以是任何类型对象，因此可以使用一个数组作为Hash的key。可以使用each方法遍历Hash中的每一个元素：
x = { &amp;#34;a&amp;#34; =&amp;gt; 1, &amp;#34;b&amp;#34; =&amp;gt; 2 , 5 =&amp;gt; 34 } x.each { |key, value| puts &amp;#34;#{key}equals #{value}&amp;#34; }  y = { &amp;#34;a&amp;#34;: 34, &amp;#34;5&amp;#34;: 67 } y.each { |key, value| puts &amp;#34;#{key}equals #{value}&amp;#34; } # 执行结果 a equals 1 b equals 2 5 equals 34  a equals 34 5 equals 67 从Ruby 1.9开始，元素插入到Hash中的顺序将会被记住，使用each方法时会按这个顺序进行迭代。如果想要删除Hash中的元素，可以使用delete方法：
x = { a: 1, b: 2 } x.delete(:a) p x  # 执行结果 {:b=&amp;gt;2} 如果想要按条件删除Hash中的value，可以使用delete_if方法：
x = { a: 100, b: 20 } x.delete_if { |key, value| value &amp;lt; 25 } p x  # 执行结果 {:a=&amp;gt;100} Hash中也可能有Hash（因为key和value可以是任何类型对象），甚至数组中也包含Hash。因为一切都是对象，而Hash和数组可以包含任何其它对象，所以可以使用Hash和数组创建巨大的树结构：
people = {  fred: { name: &amp;#34;Fred Elliott&amp;#34;, age: 63, gender: &amp;#34;male&amp;#34;,  favorite_painters: [&amp;#34;Monet&amp;#34;, &amp;#34;Constable&amp;#34;, &amp;#34;Da Vinci&amp;#34;] },  janet: { name: &amp;#34;Janet S Porter&amp;#34;, age: 55, gender: &amp;#34;female&amp;#34; } }  puts people[:fred][:age] puts people[:janet][:gender] puts people[:janet]  # 执行结果 63 female {:name=&amp;gt;&amp;#34;Janet S Porter&amp;#34;, :age=&amp;gt;55, :gender=&amp;gt;&amp;#34;female&amp;#34;} Flow Control 因为unless正好是if的反义词，所以unless能以完全相同的方式工作:
age = 10 unless age &amp;gt;= 18 puts &amp;#34;You&amp;#39;re too young to use this system&amp;#34; puts &amp;#34;So we&amp;#39;re going to exit your program now&amp;#34; end  # 执行结果 You&amp;#39;re too young to use this system So we&amp;#39;re going to exit your program now 关键字if和unless均可以搭配else一起使用，但unless不能搭配elsif使用：
x = 12 Const = 13 if x &amp;lt; Const  puts &amp;#34;x &amp;lt; #{Const}&amp;#34; else  puts &amp;#34;x &amp;gt;= #{Const}&amp;#34; end  unless x &amp;lt; Const  puts &amp;#34;x &amp;gt;= #{Const}&amp;#34; else  puts &amp;#34;x &amp;lt; #{Const}&amp;#34; end  # 执行结果 x &amp;lt; 13 x &amp;lt; 13 三元运算符是if/else的简单模式：
age = 10 type = age &amp;lt; 18 ? &amp;#34;child&amp;#34; : &amp;#34;adult&amp;#34; puts &amp;#34;You are a &amp;#34; &#43; type  # 执行结果 You are a child 如果判断条件有多个分支，也可以使用elsif:
fruit = &amp;#34;orange&amp;#34; if fruit == &amp;#34;orange&amp;#34;  color = &amp;#34;orange&amp;#34; elsif fruit == &amp;#34;apple&amp;#34;  color = &amp;#34;green&amp;#34; elsif fruit == &amp;#34;banana&amp;#34;  color = &amp;#34;yellow&amp;#34; else  color = &amp;#34;unknown&amp;#34; end puts color  orange 如果有多个条件分支，也可以使用case，下面的代码和上面的代码是一样的效果：
fruit = &amp;#34;orange&amp;#34; case fruit when &amp;#34;orange&amp;#34;  color = &amp;#34;orange&amp;#34; when &amp;#34;apple&amp;#34;  color = &amp;#34;green&amp;#34; when &amp;#34;banana&amp;#34;  color = &amp;#34;yellow&amp;#34; else  color = &amp;#34;unknown&amp;#34; end puts color  orange case还有另一个使用技巧，由于所有的Ruby表达式都返回一个结果，因此按照如下方式可以使前面的示例代码更短：
fruit = &amp;#34;orange&amp;#34; color = case fruit  when &amp;#34;orange&amp;#34;  &amp;#34;orange&amp;#34;  when &amp;#34;apple&amp;#34;  &amp;#34;green&amp;#34;  when &amp;#34;banana&amp;#34;  &amp;#34;yellow&amp;#34;  else  &amp;#34;unknown&amp;#34;  end puts color  # 执行结果 orange 使用case语句和模式匹配提供了一种简单的方法来解构复杂对象并使用它们的数据。可以将模式匹配与case语句一起使用。不使用case/when，而是使用case/in以及in语句之后的模式：
case response in { data: data, code: code }  puts &amp;#34;Success #{data}, Code: #{code}&amp;#34; in { error: error, code: code }  puts &amp;#34;Error: #{error}, Code: #{code}&amp;#34; end until也可用作循环：
x = 1 until x &amp;gt; 99  puts x  x = x * 2 end  # 执行结果 1 2 4 8 16 32 64 实际上，until也可以单独放在一行：
i = 1 i = i * 2 until i &amp;gt; 65 puts i  # 执行结果 128 在{}或do end中的代码本质上是匿名方法或函数。在代码块中可以使用编号参数而不使用显式变量，编号参数对于提供参数名称不会为代码添加任何其它含义的情况很有用：
x = [5, 8, 9] x.each do  puts _1 end  y = { a: 1, b: 21 } y.each do  puts _1, _2 end  # 执行结果 5 8 9 a 1 b 21 实际上，也可以编写自己的方法来处理代码块。下面定义的each_vowel方法，能够接受代码块做为参数，是由方法定义中变量名code_block之前的&amp;amp;符号指定：
def each_vowel(&amp;amp;code_block)  %w{a e i o u}.each { |vowel| code_block.call(vowel) } end  each_vowel { |vowel| puts vowel }  # 执行结果 a e i o u 上面的each_vowel方法，还有另一种可供选择的方式来实现。即使用yield方法，它可以自动检测到任何代码块，并能获取代码块的控制权：
def each_vowel  %w{a e i o u}.each { |vowel| yield vowel} end each_vowel { |vowel| puts vowel } 需要特别注意的是：任何时候只能传递一个代码块，不可能接受两个或多个代码块作为方法的参数。但是，代码块本身可能不接受、接受一个或多个参数。
Range类提供了一种to_a方法将Range对象转换为数组：
(&amp;#39;A&amp;#39;..&amp;#39;Z&amp;#39;).to_a.each { |letter| print letter } Symbols是抽象的引用，通常由一个以冒号为前缀的短字符串表示。例如:blue、:good和:name都是Symbols，下面是一个简单
current_situation = :good puts &amp;#34;Everything is fine&amp;#34; if current_situation == :good puts &amp;#34;PANIC!&amp;#34; if current_situation == :bad current_situation = &amp;#34;good&amp;#34; puts &amp;#34;Everything is fine&amp;#34; if current_situation == &amp;#34;good&amp;#34; puts &amp;#34;PANIC!&amp;#34; if current_situation == &amp;#34;bad&amp;#34; 上面的两段代码会产生一样的结果，但不尽相同。第二段代码中，每次使用字符串good或bad时，都会独立创建一个存储在内存中的新对象。而Symbols只会初始化一次。
current_situation = :good other_situation = :good puts current_situation.object_id, other_situation.object_id  current_str = &amp;#34;good&amp;#34; other_str = &amp;#34;bad&amp;#34; puts current_str.object_id, other_str.object_id  # 执行结果 2263708 2263708 940 960 Classes, Objects, and Modules 在Ruby中，没有必要使用return从方法中返回值。默认情况下，方法中的最后一个表达式用作返回值。下面定义了一个Square类，其中initialize是一个特殊的方法，在创建当前类的实例时调用：
class Square  def initialize(side_length)  @side_length = side_length  end   def area  @side_length * @side_length  end end  a = Square.new(10) b = Square.new(5) puts a.area puts b.area  # 执行结果 100 25 Local Variables x = 10 puts x 像x这种变量称为局部变量，它只能在定义它的地方使用。如果在另外的方法或者对象方法中使用上面的x，则会出现编译错误：
x = 10 puts x  def basic_method  puts x end basic_method  # 在定义的方法中直接使用局部变量x，出现编译错误 undefined local variable or method `x&amp;#39; for main:Object (NameError) 上面代码出现编译错误，是因为一旦进入到basic_method中，就不再与创建的变量x在同一范围内。因为x是一个局部变量，只存在定义它的地方。
x = 10 def basic_method  x = 50  puts x end basic_method puts x  # 执行结果 50 10 Global Variables Ruby也支持全局变量，在应用程序中的任何地方都可用，包括内部类或对象。全局变量可能很有用，但在Ruby中并不常用，它们与面向对象编程的理念不太吻合。如果要定义全局变量，需要在变量名前加一个$：
def basic_method  puts $x end  $x = 10 # 在全局变量定义之后调用方法 basic_method  # 打印的结果 10 Instance or Object Variables 实例变量（也称为对象变量）之所以如此命名，是因为它们的作用域在当前对象内并与当前对象相关联。实例变量使用前缀@开头，下面定义了实例变量@side_length：
class Square  def initialize(side_length)  @side_length = side_length  end   def area  @side_length * @side_length  end end  a = Square.new(10) b = Square.new(5) puts a.area puts b.area  # 执行结果 100 25 Class Variables 类变量的作用范围在类本身内，而不是和该类的特定对象关联。类变量定义时使用两个@作为前缀，通常用于存储与具体对象无关的信息：
class Square  def initialize  if defined?(@@number_of_squares)  @@number_of_squares &#43;= 1  else  @@number_of_squares = 1  end  end   #类方法  def self.count  @@number_of_squares  end end  a = Square.new b = Square.new puts Square.count  # 执行结果 2 Class Methods vs. Instance Methods 在下面定义的Square类中，initialize和area方法均为实例方法，它们与Square类的具体实例相关。因此，调用时需要先有Square类的实例：
class Square  def initialize(side_length)  @side_length = side_length  end   def area  @side_length * @side_length  end end  squ = Square.new(5) puts squ.area  # 执行结果 25 如果要定义类方法，只需要在方法名前加self.，self表示当前类。下面self.test_method为类方法，如果没有self.前缀则方法默认为实例方法：
class Square  def self.test_method  puts &amp;#34;Hello from the Square class!&amp;#34;  end   def test_method  puts &amp;#34;Hello from an instance of class Square!&amp;#34;  end end  Square.test_method Square.new.test_method  # 执行结果 Hello from the Square class! Hello from an instance of class Square! Inheritance 面向对象一个有趣的概念是继承，它允许产生一个类的分类法。继承的好处是层次较低的类可以获得较高层次的特性，也可以添加它们自己的特性。Ruby的继承功能相当简单，任何类都可以继承另一个类的特征和功能，但一个类只能继承一个其它的类:
class ParentClass  def method1  puts &amp;#34;Hello from method1 in the parent class&amp;#34;  end   def method2  puts &amp;#34;Hello from method2 in the parent class&amp;#34;  end end  class ChildClass &amp;lt; ParentClass  # 覆写method2方法  def method2  puts &amp;#34;Hello from method2 in the child class&amp;#34;  end end  # 创建对象实例 my_object = ChildClass.new my_object.method1 my_object.method2  # 执行结果 Hello from method1 in the parent class Hello from method2 in the child class 下面代码中，使用super时会查找继承链并调用下一个最高层次类的同名方法。下面代码中，在 Doctor的name方法中使用super时，会查找Person中的同名name方法。
class Person  def initialize(name)  @name = name  end   def name  @name  end end  class Doctor &amp;lt; Person  def name  &amp;#34;Dr. &amp;#34; &#43; super # super表示调用父类的同名name方法  end end  class NewDoctor &amp;lt; Doctor  def name  &amp;#34;New &amp;#34; &#43; super  end end  puts Doctor.new(&amp;#34;Test&amp;#34;).name puts NewDoctor.new(&amp;#34;Test&amp;#34;).name  # 执行结果 Dr. Test New Dr. Test 以这种方式使用继承的好处：在通用类中实现通用功能，然后只需在更具体的子类中实现具体的功能。这可以节省大量的重复工作，并且如果对父类进行了修改，子类也会继承这些修改。
Overriding Existing Methods 因为Ruby是一种动态语言，所以可以覆盖现有的类和方法。一些Ruby库和扩展（add-ons）覆盖了核心类提供的方法，以扩展Ruby的功能。
下面这个demo说明了为什么总是需要谨慎行事，注意应用程序中正在发生的事情。如果代码依赖于计算字符串长度的方法，而该长度方法被重写，将会出现异常的结果：
puts &amp;#34;test&amp;#34;.length puts &amp;#34;N&amp;#34;.length class String  def length  20  end end  puts &amp;#34;test&amp;#34;.length puts &amp;#34;N&amp;#34;.length  # 执行结果 # 被覆写之前结果正常 4 1 # 被覆写后调用length后返回均为20 20 20 上面代码在String类的length方法被复写之前，输出的结果都是正常的。但当length方法被覆写后，再调用length输出的结果均为20。
实际上，我们的代码也可以覆盖自定义的方法。下面代码中，首先定义了Dog类，然后定义了一个talk方法。接着又重新打开了Dog类，就地重定义了talk方法：
class Dog  def talk  puts &amp;#34;Woof!&amp;#34;  end end  my_dog = Dog.new my_dog.talk  class Dog  def talk  puts &amp;#34;Howl!&amp;#34;  end end  my_dog.talk  # 执行结果 # 覆写之前执行的结果 Woof! # 覆写之后的执行结果 Howl! 这种重新打开类并添加和重新定义方法的能力在面向对象语言中是比较少见的。虽然它允许执行一些有趣的技巧，但它也会导致相同的代码部分以不同的方式运行，这取决于所依赖的某些类在应用程序中是否被改变，正如之前对String的length方法的重新定义所展示的那样。
Reflection and Discovering an Object’s Methods 反射是计算机程序在运行和使用时可以检查、分析和修改自身的过程。Ruby将反射发挥到了极致，允许在运行自己的代码的同时，改变语言本身的大量功能。
在Ruby中，几乎所有对象都有可能查询到它所定义的方法，这是反射的另一部分。任何对象的methods方法（除非methods方法本身被重载了），都会返回该对象可用的方法数组，通常是一个比自定义方法多得多的方法数组：
a = &amp;#34;This is a test&amp;#34; puts a.methods.join(&amp;#39; &amp;#39;)  # 某个ruby版本执行结果 unicode_normalize unicode_normalize! ascii_only? to_r unpack encode! unpack1 % include? * &#43; pretty_print count partition &#43;@ -@ &amp;lt;=&amp;gt; &amp;lt;&amp;lt; to_c == === sum =~ next [] casecmp casecmp? insert []= match match? bytesize empty? eql? succ! next! upto index rindex replace clear chr getbyte setbyte scrub! scrub undump byteslice freeze inspect capitalize upcase dump downcase! swapcase downcase hex capitalize! upcase! lines length size codepoints succ split swapcase! bytes oct prepend grapheme_clusters concat start_with? reverse reverse! to_str to_sym crypt ord strip end_with? to_s to_i to_f center intern gsub ljust chars delete_suffix sub rstrip scan chomp rjust lstrip chop! delete_prefix chop sub! gsub! delete_prefix! chomp! strip! lstrip! rstrip! squeeze delete_suffix! tr tr_s delete each_line tr! tr_s! delete! squeeze! slice each_byte each_char each_codepoint each_grapheme_cluster b slice! rpartition encoding force_encoding valid_encoding? hash unicode_normalized? encode clamp between? &amp;lt;= &amp;gt;= &amp;gt; &amp;lt; pretty_print_inspect pretty_print_instance_variables pretty_print_cycle dup itself yield_self then taint tainted? untaint untrust untrusted? trust frozen? methods singleton_methods protected_methods private_methods public_methods instance_variables instance_variable_get instance_variable_set instance_variable_defined? remove_instance_variable instance_of? kind_of? is_a? tap display class singleton_class clone public_send method public_method singleton_method define_singleton_method pretty_inspect extend to_enum enum_for !~ nil? respond_to? object_id send __send__ ! != __id__ equal? instance_eval instance_exec 上面打印的结果，取决于当前机器环境和Ruby版本。结果中也包含了一些其它的反射性方法，例如：protected_ methods、private_methods和public_methods都揭示了以不同方式封装的方法。
另一个有趣的方法是instance_variables，它返回实例相关的所有实例变量的名称（相对于类变量而言）。下面代码中，打印了实例变量@name和@age：
class Person  # 两个实例属性  attr_accessor :name, :age end  p = Person.new p.name = &amp;#34;Fred&amp;#34; p.age = 20 puts p.instance_variables  # 执行结果 @name @age Encapsulation 封装描述了数据和方法捆绑在一起成为一个单元一起运行的方式。封装可以使功能隐藏在类中，并控制外部世界能够如何操作对象中的数据，下面是一个Person类的例子：
class Person  def initialize(name)  set_name(name)  end   def name  @first_name &#43; &amp;#39; &amp;#39; &#43; @last_name  end   def set_name(name)  first_name, last_name = name.split(/\s&#43;/)  set_first_name(first_name)  set_last_name(last_name)  end   def set_first_name(name)  @first_name = name  end   def set_last_name(name)  @last_name = name  end end 在之前的示例代码中，使用attr_accessor :name来声明属性，并且能够十分简单地使用name。上面的示例代码是为了说明封装的概念。
在上面的代码中，first_name和last_name存储在Person类中，当Person实例生成时，name被分割为两部分，并分别赋值给first_name和last_name。
一种可能的原因是想在应用程序中使用完整的name，但数据库设计可能要求把first_name和last_name放在不同列中。因此，需要在类定义的代码中处理这个差异。
上面这种方法的另一个好处是，可以在把数据赋值给对象变量之前对其进行检查。例如，在set_first_name和set_last_name方法中，可以检查name是否包含足够的字符以被认为是有效的name。
p = Person.new(&amp;#34;Fred Bloggs&amp;#34;) puts p.name  # 执行结果 Fred Bloggs 仍然可以发现一些问题：
p = Person.new(&amp;#34;Fred Bloggs&amp;#34;) p.set_last_name(&amp;#34;Smith&amp;#34;) puts p.name  # 执行结果 Fred Smith 实际上我们只想通过设置name来修改first_name和last_name，然而set_first_name和set_last_name这两个方法依然是公开的，可以通过Person的实例直接调用。幸运的是可以使用封装来解决这个问题：
class Person  def initialize(name)  set_name(name)  end   def name  @first_name &#43; &amp;#39; &amp;#39; &#43; @last_name  end   private  def set_name(name)  first_name, last_name = name.split(/\s&#43;/)  set_first_name(first_name)  set_last_name(last_name)  end   def set_first_name(name)  @first_name = name  end   def set_last_name(name)  @last_name = name  end end  p = Person.new(&amp;#34;Fred Bloggs&amp;#34;) p.set_last_name(&amp;#34;Smith&amp;#34;)  Uncaught exception: private method set_last_name called for Person:0x00007fa79e101a60 上面添加了private关键字，表明从这个关键字出现的地方开始在这个类中声明的任何方法都应该保持私有。因此，上面代码运行后会出现编译错误：Uncaught exception: private method set_last_name called for Person:0x00007fa79e101a60。
而private关键字的反面是public，可以在一个方法之前放上private关键字，那么其后定义的方法都是私有方法。之后再使用public关键字时，其后的方法都是公开的：
class Person   def anyone_can_access_this  ...  end   private  def this_is_private  ...  end   public  def another_public_method  ...  end end 也可以使用private作为一个命令，其后紧跟代表方法的符号。下面示例代码是告诉Ruby，方法this_is_private和this_is_also_private都是私有的：
class Person  def anyone_can_access_this; ...; end  def this_is_private; ...; end  def this_is_also_private; ...; end  def another_public_method; ...; end private :this_is_private, :this_is_also_private end 不管选择将private作为方法前的指令，还是直接将其放在方法名前，都是可以的。但需要注意的是private命令声明必须在方法定义之后。
除了public和private，Ruby支持第三种形式的封装，叫做protected。它能让一个方法在类的范围内成为私有的，而不是在一个单独的对象实例内。
例如，无法在该对象及其方法的作用域之外直接调用private方法。但是，可以从属于同一类成员的任何对象的方法范围内调用protected方法：
class Person  def initialize(age)  @age = age  end   def age  @age  end   def age_difference_with(other_person)  (self.age - other_person.age).abs  end   protected :age end  fred = Person.new(34) chris = Person.new(25) puts chris.age_difference_with(fred) # 直接调用protected方法会报错 puts chris.age  # 编译报错 Uncaught exception: protected method `age&amp;#39; called for #&amp;lt;Person:0x00007fdb990660b8 @age=25&amp;gt; 在上面的例子中，使用protected指令设置的保护方法age不能直接使用，除非是在属于Person类的方法中使用。但是，如果把age变成私有的，前面的例子就会失败，因为other_ person.age将无法通过编译。这是因为private使得方法只能被特定对象的方法所访问。
Polymorphism 多态是指编写可以同时处理多种类型的代码。例如，&#43;方法适用于数字相加、字符串连接和数组相加，&#43;的作用完全取决于想要把什么类型的东西加在一起。
class Animal  attr_accessor :name   def initialize(name)  @name = name  end  end  class Cat &amp;lt; Animal  def talk  &amp;#34;Meaow!&amp;#34;  end end  class Dog &amp;lt; Animal  def talk  &amp;#34;Woof!&amp;#34;  end end   animals = [Cat.new(&amp;#34;Flossie&amp;#34;), Dog.new(&amp;#34;Clive&amp;#34;), Cat.new(&amp;#34;Max&amp;#34;)] animals.each do |animal|  puts animal.talk end  # 执行结果 Meaow! Woof! Meaow! 上面定义了3个类，Animal,Cat和Dog。数组animals中包含了两个Cat对象实例和一个Dog对象实例，在循环迭代时会调用talk方法，打印的结果是Meaow!，Woof!，Meaow!。
一些内置的类，例如Array, Hash, String已经实现一些多态方法。例如，可以在许多内置类上调用to_s方法，将对象的内容作为一个字符串返回：
puts 1000.to_s puts [1, 2, 3].to_s puts ({ name: &amp;#39;Fred&amp;#39;, age: 10 }).to_s  # 打印结果 1000 [1, 2, 3] {:name=&amp;gt;&amp;#34;Fred&amp;#34;, :age=&amp;gt;10} Nested Classes 可以在类中再定义类，这种类被称为内嵌类。当想把类分成几组，而不是把它们都分开时，内嵌类会很有用。下面在Drawing中定义了两个内嵌类：
class Drawing  class Line  end   class Circle  end end 内嵌类的定义和普通类的定义一样，但是使用方式上有差异。如果要从Drawing之外访问Line和Circle，必须使用Drawing::Line和Drawing::Circle：
class Drawing  def self.give_me_a_circle  Circle.new  end   class Line  end   class Circle  def what_am_i  &amp;#34;This is a circle&amp;#34;  end  end end  a = Drawing.give_me_a_circle puts a.what_am_i b = Drawing::Circle.new puts b.what_am_i c = Drawing::Circle.new puts c.what_am_i  # 打印的结果 This is a circle This is a circle This is a circle The Scope of Constants 常量是值在整个应用程序中不变且永久存在的特殊变量。从这个意义上说，常量的作用似乎类似于全局变量，但其实不然。常量是在当前类的范围内定义的，其所有子类都可以使用，除非它们被重载。
def circumference_of_circle(radius)  2 * Pi * radius end  Pi = 3.141592 puts circumference_of_circle(10)  class OtherPlanet  # Pi虽然是常量，但也可以被重置  Pi = 4.5   def self.circumference_of_circle(radius)  radius * 2 * Pi  end end  puts OtherPlanet.circumference_of_circle(10) puts OtherPlanet::Pi puts OtherPlanet.circumference_of_circle(10)  # 打印的结果 # Pi未被赋值前的结果 62.83184 # Pi被重新赋值后的结果 90.0 4.5 90.0 上面示例说明常量在类的上下文中具有作用域。OtherPlanet类有自己的Pi定义。但是，如果没有在这里重新定义Pi，那么最初的Pi就会被OtherPlanet使用，因为OtherPlanet类是在全局范围内定义的。
Modules, Namespaces, and Mix-Ins 模块提供了一种方式将Ruby的类、方法和常量收集到一个单独命名的单元中。这样可以避免与现有的类、方法和常量发生冲突，也可以把模块的功能加入到自定义的类中。首先，来看看如何使用模块来创建命名空间，以避免同名冲突。
Namespaces Ruby的一个常用功能是将其它文件中的代码包含到当前程序中。在包含其它文件时，可能很快就会遇到冲突，尤其是当包含的文件或库又包含了多个文件时，不能保证任何被包含的文件（或被包含在一长串包含链中的文件）都不会与已经编写或处理过的代码发生冲突。
# number_stuff文件 def random  rand(1000000) end puts random  # 某个可能的执行结果 373411 上面定义的random方法返回0到999999之间的随机数。这个方法可能在一个远程文件中，它很容易被遗忘，如果有另一个文件也定义了同名方法，就会造成问题：
# letter_stuff文件 def random  (rand(26) &#43; 65).chr end 上面方法产生A到Z的随机字母。现在有两个名为random的方法了，如果第一个random方法所在文件为number_stuff.rb，第二个random方法所在文件为letter_stuff.rb。require是一个Ruby语句，用于加载另一个文件中的代码，下面的代码就会出现问题：
require &amp;#39;./number_stuff&amp;#39; require &amp;#39;./letter_stuff&amp;#39;  puts random 可以看到，当代码运行后，使用的是字母版的random方法，这是因为上面出现了名字冲突，数字版的random被数字版的random覆盖。
这就是所谓的名字冲突，模块有助于解决这些冲突，它提供了可以包含任何数量的类、方法和常量的命名空间，并允许直接处理它们。上面示例中的冲突可以使用module解决：
module NumberStuff  def self.random  rand (1000000)  end end  module LetterStuff  def self.random  (rand(26) &#43; 65).chr  end end  puts NumberStuff.random puts LetterStuff.random 下面代码定义了两个模块，第一个module中定义了一个Ruler类，它有一个length属性。第二个模块也定义了一个Ruler类，它包含了name属性：
module ToolBox  class Ruler  attr_accessor :length  end end  module Country  class Ruler  attr_accessor :name  end end  a = ToolBox::Ruler.new a.length = 50 b = Country::Ruler.new b.name = &amp;#34;Genghis Khan from Moskau&amp;#34;  puts a.length, b.name  # 执行结果 50 Genghis Khan from Moskau Mix-Ins 因为Ruby不支持多重继承，所以不具备同时从多个类中继承的能力。Ruby的继承功能只允许创建简单的类树，避免了多重继承系统所带来的混乱。
但是，在某些情况下，在不同类之间共享功能是很有用的。在这个意义上，模块就像一种方法、类和常量的捆绑，它可以被包含在其它类中。例如，用模块提供的方法来扩展该类:
module UsefulFeatures  def class_name  self.class.to_s  end end  class Person  include UsefulFeatures end  x = Person.new puts x.class_name  # 执行结果 Person 上面代码中，UsefulFeatures看起来像是一个类。但模块是组织工具，不是类。class_ name方法存在于模块中，然后被包含在Person类中，下面是另一个例子：
module AnotherModule  def do_stuff  puts &amp;#34;This is a test&amp;#34;  end end  # 导入模块后可以直接使用其中的方法 include AnotherModule do_stuff  # 执行结果 This is a test 从上面示例代码中可以看出，即使没有在类的定义中，也可以在当前作用域中include一个模块，然后直接使用模块里面的方法：
# 需要先include该模块 include AnotherModule # 然后直接使用里面的方法 do_stuff 也就是说，include接收一个模块并将其内容包含在当前范围内。Kernel模块包含了所有「标准」命令（如load、require、exit、puts和eval）。这些方法不是直接在对象的范围内定义的，而是通过默认包含Kernel模块实现。
然而，我们更感兴趣的是Ruby提供的模块，可以在自己的类中包含这些模块来立即获得更多的功能。其中两个模块是Enumerable和Comparable。
Enumerable 数组类已经pre-included了Enumerable模块提供的方法，这个模块提供了大约20个相关的方法，包括collect, detect, find, find_all, include?, max, min, select, sort, and to_a：
p [1, 2, 3, 4].collect { |i| i.to_s &#43; &amp;#34;x&amp;#34; } # 检测到就返回一个，detect是find的别名 p [1, 2, 3, 4].detect { |i| i.between?(2, 3) } p [1, 2, 3, 4].select { |i| i.between?(2, 3) } p [4, 1, 3, 2].sort p [1, 2, 3, 4].max p [1, 2, 3, 4].min  # 执行结果 [&amp;#34;1x&amp;#34;, &amp;#34;2x&amp;#34;, &amp;#34;3x&amp;#34;, &amp;#34;4x&amp;#34;] 2 [2, 3] [1, 2, 3, 4] 4 1 可以在自定义类中实现each方法，下面是一个示例：
class AllVowels  VOWELS = %w{a e i o u}   def each  VOWELS.each { |v| yield v }  end end  x = AllVowels.new x.each { |v| puts v }  # 执行结果 a e i o u 因为已经在AllVowels类中定义了each方法，又默认包含了Enumerable模块，所以能使用相应的迭代方法：
class AllVowels  include Enumerable  VOWELS = %w{a e i o u}   def each  VOWELS.each { |v| yield v }  end end  x = AllVowels.new p x.collect { |i| i &#43; &amp;#34;x&amp;#34; } p x.detect { |i| i &amp;gt; &amp;#34;j&amp;#34; } p x.select { |i| i &amp;gt; &amp;#34;j&amp;#34; } p x.sort p x.max p x.min  # 执行结果 [&amp;#34;ax&amp;#34;, &amp;#34;ex&amp;#34;, &amp;#34;ix&amp;#34;, &amp;#34;ox&amp;#34;, &amp;#34;ux&amp;#34;] &amp;#34;o&amp;#34; [&amp;#34;o&amp;#34;, &amp;#34;u&amp;#34;] [&amp;#34;a&amp;#34;, &amp;#34;e&amp;#34;, &amp;#34;i&amp;#34;, &amp;#34;o&amp;#34;, &amp;#34;u&amp;#34;] &amp;#34;u&amp;#34; &amp;#34;a&amp;#34; Comparable 模块Comparable提供了比较操作符，例如&amp;lt;,&amp;lt;=,==,&amp;gt;=,&amp;gt;以及between?方法。为了提供这些方法，Comparable模块在包含它的类上使用&amp;lt;=&amp;gt;比较操作符。如果提供的参数高于该对象的值，则&amp;lt;=&amp;gt;操作符返回-1，如果相等则返回0，如果对象的值大于提供的参数则返回1:
p 1 &amp;lt;=&amp;gt; 2 p 1 &amp;lt;=&amp;gt; 1 p 2 &amp;lt;=&amp;gt; 1  # 执行结果 -1 0 1 有了这个简单的方法，Comparable模块可以提供其它基本的比较运算符和between?方法。下面自定义类实现方法&amp;lt;=&amp;gt;，然后可以使用&amp;lt;,&amp;lt;=,==,&amp;gt;=,&amp;gt;以及between?方法：
class Song  include Comparable  attr_accessor :length   def &amp;lt;=&amp;gt;(other)  @length &amp;lt;=&amp;gt; other.length  end   def initialize(song_name, length)  @song_name = song_name  @length = length  end end  a = Song.new(&amp;#39;Rock around the clock&amp;#39;, 143) b = Song.new(&amp;#39;Bohemian Rhapsody&amp;#39;, 544) c = Song.new(&amp;#39;Minute Waltz&amp;#39;, 60)  p a &amp;lt; b p b &amp;gt;= c p c &amp;gt; a p a.between?(c,b)  # 执行结果 true true false true Using Mix-Ins with Namespaces and Classes 在前面的示例中，定义了模块后可以借助::来访问模块中定义的类。如果想访问的时候去掉模块前缀，使用include将模块的方法包含在当前类和作用域中，但它也包含了模块中存在的类（如果有的话），并使它们也可以在本地访问。
module ToolBox  class Ruler  attr_accessor :length  end end  module Country  class Ruler  attr_accessor :name  end end  a = ToolBox::Ruler.new a.length = 50 b = Country::Ruler.new b.name = &amp;#34;Genghis Khan of Moskau&amp;#34;  # 包含Country模块后可以直接使用name include Country c = Ruler.new c.name = &amp;#34;King Henry VIII&amp;#34; puts a.length, b.name, c.name  # 执行结果 50 Genghis Khan of Moskau King Henry VIII Projects and Libraries 随着对Ruby越来越熟悉并发现它的更多用途，很可能希望从编写单个小程序（少于100行左右）转向由多个部分组成的更复杂的应用程序和系统。因此，大型应用程序和系统通常被称为项目，其管理方式与简单的单文件脚本不同。
在 Ruby中分离功能的最常见方法是将不同的类放在不同的文件中。这样，只需将文件复制到其它项目中，就能编写可在多个项目中使用的类。
Projects and Using Code from Other Files 下面代码会出现编译错误：
puts &amp;#34;This is a test&amp;#34;.vowels.join(&amp;#39;-&amp;#39;)  # 出现编译错误 undefined method `vowels&amp;#39; for &amp;#34;This is a test&amp;#34;:String 编译错误是因为String类默认并没有提供vowels方法。可以在同一个文件中为String类编写一个扩展，如果将此定义和puts放在同一个文件中，则不会出现编译错误：
class String  def vowels  self.scan(/[aeiou]/i)  end end  puts &amp;#34;This is a test&amp;#34;.vowels.join(&amp;#39;-&amp;#39;)  # 执行结果 i-i-a-e 不过，可能想编写一些方法添加到String中，并在多个程序中使用。与其每次都复制粘贴代码，不如将其复制到一个单独的文件中，然后使用require命令将外部文件加载到当前程序中。例如，把这段代码放到一个名为string_extensions.rb的文件中：
# string_extensions.rb文件 class String  def vowels  self.scan(/[aeiou]/i)  end end  # 在另外一个文件vowel_test.rb中包含string_extensions require &amp;#39;./string_extensions&amp;#39; puts &amp;#34;This is a test&amp;#34;.vowels.join(&amp;#39;-&amp;#39;) 如果运行vowel_test.rb，就会出现预期的结果。第一行require &#39;./string_extensions&#39; 简单地从当前目录（以./符号表示）加载string_extensions.rb文件，并像本地代码一样进行处理。这意味着，在这种情况下，只需一行即可使用vowels方法。
Ruby默认情况下不会将当前目录包含在搜索Ruby文件的目录路径中，因此可以使用 ./或require_relative来指定当前目录。因此，本例在操作上与前例完全相同：
require_relative &amp;#39;string_extensions&amp;#39; puts &amp;#34;This is a test&amp;#34;.vowels.join(&amp;#39;-&amp;#39;) 除了require和require_relative，还可以使用load将外部源代码文件加载到程序中。例如，这段代码的功能似乎与前面的代码相同
load &amp;#39;string_extensions.rb&amp;#39; puts &amp;#34;This is a test&amp;#34;.vowels.join(&amp;#39;-&amp;#39;) 实际上load需要完整的文件名，包括后缀.rb，而require则假定后缀为.rb。在这种情况下，输出结果是一样的，但让我们换个例子看看有什么不同，把下面代码放到.rb文件中：
puts &amp;#34;Hello from a.rb&amp;#34; 然后在另一个文件b.rb中放入如下代码：
require_relative &amp;#39;a&amp;#39; puts &amp;#34;Hello from b.rb&amp;#34; require_relative &amp;#39;a&amp;#39; puts &amp;#34;Hello again from b.rb&amp;#34;  # 执行结果 Hello from a.rb Hello rom b.rb Hello again from b.rb 但如果使用load，同样的代码运行结果不同：
load &amp;#39;a.rb&amp;#39; puts &amp;#34;Hello from b.rb&amp;#34; load &amp;#39;a.rb&amp;#39; puts &amp;#34;Hello again from b.rb&amp;#34;  # 执行结果 Hello from a.rb Hello from b.rb Hello from a.rb Hello again from b.rb 使用load方式时，每次使用load文件时，代码都会被加载并重新处理。而require和require_relative只处理外部文件一次。Ruby程序员几乎总是使用require或require_relative，而不是load。load的效果只有在外部文件中的代码已更改或包含将立即执行的active代码时才有用。
Inclusions from Other Directories 实际上，load和require和不同的方法查找要加载的文件。load和require_ relative可以加载本地文件，但require不能。默认情况下，这些其他目录是Ruby存储其自身文件和库的各种目录，但必要时可以覆盖这些目录。
Ruby将用于搜索包含文件的目录列表存储在一个名为$:的特殊变量中（或也可以使用 $LOAD_PATH）。可以使用irb查看$:默认包含哪些内容：
$:.each { |d| puts d }  # 执行结果 /Users/xxx/.rvm/gems/ruby-3.2.0/gems/debase-3.0.0.beta.11/lib /Users/xxx/.rvm/gems/ruby-3.2.0/extensions/x86_64-darwin-21/3.2.0/debase-3.0.0.beta.11 /Users/xxx/.rvm/gems/ruby-3.2.0/gems/ruby-debug-ide-3.0.0.beta.17/lib /Applications/RubyMine.app/Contents/plugins/ruby/rb/testing/patch/common /Applications/RubyMine.app/Contents/plugins/ruby/rb/testing/patch/testunit /Users/xxx/.rvm/rubies/ruby-3.2.0/lib/ruby/site_ruby/3.2.0 /Users/xxx/.rvm/rubies/ruby-3.2.0/lib/ruby/site_ruby/3.2.0/x86_64-darwin21 /Users/xxx/.rvm/rubies/ruby-3.2.0/lib/ruby/site_ruby /Users/xxx/.rvm/rubies/ruby-3.2.0/lib/ruby/vendor_ruby/3.2.0 /Users/xxx/.rvm/rubies/ruby-3.2.0/lib/ruby/vendor_ruby/3.2.0/x86_64-darwin21 /Users/xxx/.rvm/rubies/ruby-3.2.0/lib/ruby/vendor_ruby /Users/xxx/.rvm/rubies/ruby-3.2.0/lib/ruby/3.2.0 /Users/xxx/.rvm/rubies/ruby-3.2.0/lib/ruby/3.2.0/x86_64-darwin21 如果想添加目录，可以使用如下方式：
$:.push &amp;#39;/your/directory/here&amp;#39; Logic and Including Code require和load都像Ruby程序中的普通代码一样。可以将它们放在Ruby代码中的任何位置，例如，它们的行为就如同在该位置被处理一样：
Advanced Ruby Features Dynamic Code Execution 作为一种动态解释型语言，Ruby能够执行动态创建的代码。这样做的方法是使用eval方法，例如下面的代码执行后打印结果为4。
eval &amp;#34;puts 2 &#43; 2&amp;#34; 上面eval表达式的返回值并非4，而是nil，因为puts作为表达式的放回值为nil。如果要返回4，必须这样写：
puts eval(&amp;#34;2 &#43; 2&amp;#34;) 下面是一个使用字符串和插值的更复杂的示例：
my_number = 15 my_code = %{#{my_number}* 2} puts my_code puts eval(my_code)  15 * 2 30 实际上eval方法只是执行（或求值）传递给它的代码并返回结果。最上面的例子是让eval执行puts 2 &#43; 2，上面的例子是执行15 * 2。
Bindings 在Ruby中，绑定是对上下文、作用域或执行状态的引用。绑定包括变量的当前值和执行环境的其它细节。可以将绑定传递给eval并让eval在这个传递绑定执行代码，而不是当前绑定。通过这种方式，可以将eval要执行的代码与当前代码的执行上下文分开：
def binding_elsewhere  x = 20  return binding end remote_binding = binding_elsewhere x = 10 eval(&amp;#34;puts x&amp;#34;) eval(&amp;#34;puts x&amp;#34;, remote_binding)  # 打印的结果 10 20 上面的代码表明eval接受一个可选的bindling参数，这个参数是方法binding_elsewhere返回的，它包含了binding_elsewhere的上下文。
eval(&amp;#34;x = 10&amp;#34;) eval(&amp;#34;x = 50&amp;#34;, remote_binding) eval(&amp;#34;puts x&amp;#34;) eval(&amp;#34;puts x&amp;#34;, remote_binding)  # 打印的结果 10 50 在上面的代码中有两个bindling在起作用：默认bindling和remote_ binding（来自binding_elsewhere方法）。第一个x的值是在默认bindling中设置，另一个是在remote_ binding中设置的。
Other Forms of eval 尽管eval在当前上下文（或bindling提供的上下文）中执行代码，但class_eval、module_eval和instance_eval可以分别在类、模块和对象实例上下文中执行代码。class_eval非常适合动态向类添加方法:
class Person end  def add_accessor_to_person(accessor_name)  Person.class_eval %{attr_accessor :#{accessor_name}} end  person = Person.new add_accessor_to_person :name add_accessor_to_person :gender person.name = &amp;#34;Carleton DiLeo&amp;#34; person.gender = &amp;#34;male&amp;#34; puts &amp;#34;#{person.name}is #{person.gender}&amp;#34;  # 打印的结果 Carleton DiLeo is male 在上面的示例中，使用add_accessor_to_person方法将访问器动态添加到Person类。在使用 add_accessor_to_person方法之前，名称和性别访问器都不存在于Person中。代码的关键部分class_eval方法通过使用字符串插值来为Person创建所需的属性。
字符串插值使eval方法成为动态生成不同特征的强大工具。这种能力是大多数编程语言中看不到的一种能力，并且在诸如Ruby on Rails之类的系统中发挥了巨大的作用。
可以在前面的例子中更进一步，通过class_eval强大功能放在一个新的方法中，定义在Class类中（所有其它的类都来自于此），为每个类添加一个add_accessor方法：
class Class  def add_accessor(accessor_name)  self.class_eval %{ attr_accessor :#{accessor_name}}  end end  class Person end  person = Person.new Person.add_accessor :name Person.add_accessor :gender person.name = &amp;#34;Carleton DiLeo&amp;#34; person.gender = &amp;#34;male&amp;#34; puts &amp;#34;#{person.name}is #{person.gender}&amp;#34;  # 打印的结果 Carleton DiLeo is male 因为add_accessor是在一个类中使用的，这个方法调用将一直进行到Class类中定义的add_accessor方法。
class SomethingElse  add_accessor :whatever end ever = SomethingElse.new ever.whatever = &amp;#34;test&amp;#34; puts ever.whatever  # 打印的结果 test 回到更简单的技术，使用instance_eval有点像使用常规eval，但作用在对象（而不是方法）的上下文中。在下面示例中，使用instance_eval在对象范围内执行代码：
class MyClass  def initialize  @my_variable = &amp;#39;Hello, world!&amp;#39;  end end  obj = MyClass.new obj.instance_eval { puts @my_variable }  # 打印的结果 Hello, world! Creating Your Own Version of attr_accessor 到目前为止，已经在自定义的类中使用attr_accessor方法来快速生成实例变量的访问函数。例如，在可能手写下面这样的代码：
class Person  def name  @name  end   def name=(name)  @name = name  end end 上面的代码允许使用puts person.name和person.name = &#39;Fred&#39;。同样地，也可以使用attr_accessor添加属性：
class Person  attr_accessor :name end 这样定义的类更加简洁，并且与普通版本具有完全相同的功能。现在是时候问这个问题了，attr_accessor是如何工作的？
class Class  def add_accessor(accessor_name)  self.class_eval %{ def #{accessor_name}@#{accessor_name}end def #{accessor_name}=(value) @#{accessor_name}= value end }  end end Running Other Programs from Ruby 有三种简单的方法运行另一个程序:
 system方法（定义在Kernel模块中） backtick syntax 限定的输入字元（%x{}）  x = system(&amp;#34;ls&amp;#34;) puts x x = `ls` #backtick syntax puts x  # 执行结果 letter_stuff.rb	number_stuff.rb	test.rb true letter_stuff.rb number_stuff.rb test.rb 上面的第一行代码中，ls的输出会打印在控制台，并且x的值等于true。而在第3行中，x的值包含list命令的输出。也就是说，想运行另一个程序而不关心它的输出时，使用system是理想的，而当你想返回程序的输出时，应该使用backticks方式。
%x{}的功能等同于使用backticks，例如%x{ls}:
y = %x{ls} puts y  # 执行结果 letter_stuff.rb number_stuff.rb test.rb Transferring Execution to Another Program 有时想要停止当前程序的执行并立即跳到另一个程序。要结束当前程序并调用另一个程序，只需使用exec方法来代替system:
exec &amp;#34;ruby letter_stuff.rb&amp;#34; # 下面代码不会执行，因为exec会结束当前程序 puts &amp;#34;This will never be displayed&amp;#34; Running Two Programs at the Same Time Forking是指一个程序的实例（一个进程）复制自己，导致该程序的两个进程同时运行。fork是Kernel模块提供的方法，用于创建当前进程的分叉。它在父进程中返回子进程的进程ID，但在子进程中返回nil&amp;ndash;可以用它来确定一个脚本在哪个进程中。
下面的例子将当前进程分叉为两个进程，并且只在子进程（由分叉产生的进程）中执行exec命令：
if fork.nil?  exec &amp;#34;ruby letter_stuff.rb&amp;#34; end puts &amp;#34;This Ruby script now runs alongside letter_stuff.rb&amp;#34; 如果另一个程序（被exec执行后）预计在某个时间点完成，想在父程序中做某些事情之前等待它完成执行，可以使用Process.wait来等待所有子进程完成后再继续：
child = fork do  sleep 3  puts &amp;#34;Child says &amp;#39;hi&amp;#39;!&amp;#34; end  puts &amp;#34;Waiting for the child process...&amp;#34; Process.wait child puts &amp;#34;All done!&amp;#34;  # 执行结果 Waiting for the child process... Child says &amp;#39;hi&amp;#39;! All done! 在Windows版本的Ruby中，分叉是不可能的，因为该平台上不支持POSIX-style分叉，应当使用对应的spawn()方法。
Threads 线程是执行线程的简称。用线程把一个程序的执行分成多个部分，可以同时运行。例如，一个被设计为同时给数千人发送电子邮件的程序可能会将任务分成20个不同的线程，这些线程都会同时发送电子邮件。
这种并行性比一个接一个地处理要快，特别是在有多CPU的系统上，因为不同的执行线程可以在不同的处理器上运行。即使在单CPU上它也可以更快，因为与其浪费时间等待远程机器的响应，不如继续进行其它操作。
Ruby 1.8并不支持传统意义上的线程。通常，线程能力是由操作系统提供的，并且在不同的系统中有所不同。然而，Ruby 1.8提供了Ruby的线程能力，这意味着它们缺乏传统系统级线程的一些能力。在Ruby 1.9中，Ruby开始使用基于系统的线程，这也是是Rubyists中所期望的结果。
虽然Ruby 1.9和2.x的线程是系统（原生）线程，但为了与1.8代码保持兼容，全局解释器锁（GIL）被保留下来，所以线程不会真正同时运行。这意味着本节所涉及的所有内容都与1.8、1.9、2.0及以后的所有版本有关。本章的下一个主要部分将介绍Ruby 1.9及更高版本的替代品&amp;ndash;fibers，它现在支持非阻塞并发。
threads = [] 10.times do  thread = Thread.new do  10.times { |i| print i; $stdout.flush; sleep rand(2) }  end  threads &amp;lt;&amp;lt; thread end  threads.each { |thread| thread.join }  0000000123012001145611112312345678234512323454279234233346648445756757567958586867689967987878989999 一旦创建了线程，就要等待所有的线程在程序结束前完成。可以通过循环浏览线程中的所有线程对象并调用每个线程的join方法来等待。join方法使主进程等待，直到一个线程的执行完成后再继续。通过这种方式，可以确保在退出之前所有的线程都完成了。
Fibers 在Ruby 1.9及以后的版本中提供了线程的替代品Fibers。在Ruby 3中Fiber被重写了，它不再对IO操作进行阻塞，并支持非阻塞的fibers。
fibers是轻量级的执行单元，它可以控制自己的调度（通常被称为合作调度）。线程通常会持续运行，而fibers一旦执行完某些任务就会移交控制权。
与常规方法不同，一旦fibers交出控制权，它就会继续存在，并可以随意恢复。简而言之，fibers在实用上类似于线程，但fibers并不被安排在一起运行，我们必须手动控制fibers的调度。
sg = Fiber.new do  s = 0  loop do  square = s * s  Fiber.yield square  s &#43;= 1  end end 10.times { puts sg.resume }  # 执行的结果 0 1 4 9 16 25 36 49 64 81 上面的代码中，使用block创建了一个fiber。创建的fiber将会完全独立运行，直到Fiber.yield方法将控制权交还给告诉fiber运行的东西（上面的代码是sg.resume方法的调用）。另外，若fiber运行结束，在fiber中最后执行表达式的值将被返回。
当恢复fiber执行时，可以将数据传回fiber，也可以从fiber中接收数据。例如，调整一下平方数发生器的fiber以支持接收一个可选的新基数来提供平方数：
sg = Fiber.new do  s = 0  loop do  square = s * s  s &#43;= 1  s = Fiber.yield(square) || s  end end  puts sg.resume puts sg.resume puts sg.resume puts sg.resume puts sg.resume 40 puts sg.resume puts sg.resume puts sg.resume 0 puts sg.resume puts sg.resume  # 执行后的结果 0 1 4 9 1600 1681 1764 0 1 4 Ruby 3引入了创建非阻塞fiber的能力。创建一个非阻塞fiber很简单：在构造函数中指定参数blocking 为false。这个选项可以防止阻塞操作，如I/O、sleep等的阻塞。
non_blocking = Fiber.new(blocking: false) do  puts &amp;#34;Blocking Fiber? #{Fiber.current.blocking?}&amp;#34;  # Will not block  sleep 2 end 1.times { puts non_blocking.resume }  # 打印结果 Blocking Fiber? false 2 当正确使用时，非阻塞fiber将提高性能，因为多个操作是一次性执行的。由于非阻塞fiber是选择加入的，Ruby 3不会破坏现有的代码。默认情况下，在Ruby 3中，fiber中的所有I/O操作都是无阻塞的。
在某些情况下，使用fiber而不是线程的动机是效率。创建数百个fiber比创建同等的线程要快得多，因为线程是在操作系统层面创建的。此外，fiber还有显著的内存效率优势。
Fiber最大的好处之一是在其他库中实现轻量级的I/O管理例程，所以即使你不直接使用fiber，你最终也可能从其他地方的使用中获益。
Organizing objects with classes Object是一个内置类，当在一个类上使用点符号时，就是向这个类发送了一个信息。如同对象一样，类也可以接受消息。事实上，类就是对象。
在类定义时，用class关键字。类名是用常量名的规则来命名的，这是一种特殊的标识符。而常量用于存储信息和在程序运行过程中不会改变的值。
class C  def m  puts &amp;#34;First definition of method m&amp;#34;  end   def m  puts &amp;#34;Second definition of method m&amp;#34;  end end  C.new.m  # 打印的结果 Second definition of method m 上面代码运行后，将会看到打印的是Second definition of method m。即当我们override一个方法时，最新定义的版本才具有高优先级。
Reopening classes 在大多数情况下，定义一个类时会创建一个类的定义块：
class C  # class code here  end 但是，也可以重新打开一个类以增加一些或改变某些东西。下面代码中，首先打开了类的定义，增加了方法x，然后关闭。接着又打开，增加了方法y，然后又关闭：
class C  def x  end end  class C  def y  end end 分解类定义的一个原因是将它们分散在多个文件中。如果需要一个包含类定义的文件（也许在运行时从另一个文件中加载它），而在需要第二个文件的文件中也有同一个类的部分定义，这两个定义就会被合并。这不是你随意做的事情：这一定是程序的设计要求一个类部分地在一个地方定义，部分地在另一个地方定义的情况。
Ruby有一个Time类，它可以操作时间，使他们格式化为时间戳。可以使用UNIX样式的日期格式字符串来获得所需的格式:
puts Time.new.strftime(&amp;#34;%m-%d-%y&amp;#34;)  # 打印的结果 09-18-22 除了内置的Time类，Ruby还有一个名为time.rb的程序文件，它包含了对Time类的各种增强和补充。time.rb通过重新打开Time类来实现增强Time类目的。如果在Ruby源代码树的lib子目录或Ruby安装中查找文件time.rb，将会看到：
class Time  class &amp;lt;&amp;lt; Time   #  # A hash of timezones mapped to hour differences from UTC. The  # set of time zones corresponds to the ones specified by RFC 2822  # and ISO 8601.  #  ZoneOffset = { # :nodoc:  &amp;#39;UTC&amp;#39; =&amp;gt; 0,  方法xmlschema是在time.rb中定义的，内置的Time类并没有该方法。下面代码在使用require &#39;time&#39;前会出现编译错误，一旦导入time.rb，则不会出现编译错误：
t = Time.new t.xmlschema  # 编译出现错误 Uncaught exception: undefined method `xmlschema&amp;#39; for xxx # 需要先require &amp;#39;time&amp;#39; require &amp;#39;time&amp;#39; t.xmlschema 09-25-22 虽然可以将单个类代码分布在多个文件或同一文件中的多个位置，但最好不要这样做。对于Time扩展，大家建议了一种统一可能性：首先给Time对象所有扩展方法，而不是将这些方法分离到单独的库中。这种统一可能会在Ruby的后续版本中实现。
Ruby 1.9及以上版本允许在实际源代码文件中使用任何支持的字符集。所需要做的就是在第一行或第二行（如果使用的是shebang行）加入一个注释，其中包含编码:
# coding:utf-8 debug 在Gemfile中添加如下内容
 gem &amp;#39;debase&amp;#39;  gem &amp;#39;ruby-debug-ide&amp;#39; [IPC] Connection::waitForSyncReply: Timed-out while waiting for reply for WebPage_TouchEventSync from process 584, id=20  // 网络异常导致的同步问题 No SDK specified 使用Intellij Idea调试Ruby代码时，如果出现如下提示，根本原因是未识别到当前工程为Ruby工程，只需按照参考资料操作即可：
No Ruby interpreter configured for the project Error running &amp;#39;study&amp;#39; No SDK specified public extension UIView {  func makeSecure() {  DispatchQueue.main.async {  let field = UITextField()  field.isSecureTextEntry = true  field.backgroundColor = .clear  self.addSubview(field)  field.centerYAnchor.constraint(equalTo: self.centerYAnchor).isActive = true  field.centerXAnchor.constraint(equalTo: self.centerXAnchor).isActive = true  self.layer.superlayer?.addSublayer(field.layer)  field.layer.sublayers?.first?.addSublayer(self.layer)  }  } } 参考资料
public extension UIView {  func setScreenCaptureProtection() {  guard superview != nil else {  for subview in subviews { // to avoid layer cyclic crash, when it is a topmost view, adding all its subviews in textfield&amp;#39;s layer, TODO:Find a better logic.  subview.setScreenCaptureProtection()  }  return  }  let guardTextField = UITextField()  guardTextField.backgroundColor = .clear  guardTextField.translatesAutoresizingMaskIntoConstraints = false  guardTextField.isSecureTextEntry = true  addSubview(guardTextField)  guardTextField.isUserInteractionEnabled = true  sendSubviewToBack(guardTextField)  layer.superlayer?.addSublayer(guardTextField.layer)  guardTextField.layer.sublayers?.first?.addSublayer(layer)  guardTextField.topAnchor.constraint(equalTo: self.topAnchor, constant: 0).isActive = true  guardTextField.bottomAnchor.constraint(equalTo: self.bottomAnchor, constant: 0).isActive = true  guardTextField.leadingAnchor.constraint(equalTo: self.leadingAnchor, constant: 0).isActive = true  guardTextField.trailingAnchor.constraint(equalTo: self.trailingAnchor, constant: 0).isActive = true  } } public class ShyView: UIView {   lazy var hiddenView: UIView? = {  let hiddenView: UIView  let textField = UITextField()  textField.isSecureTextEntry = true  hiddenView = textField.layer.sublayers?.first?.delegate as! UIView  hiddenView.subviews.forEach { $0.removeFromSuperview() }  hiddenView.isUserInteractionEnabled = true  return hiddenView  }()   required init?(coder: NSCoder) {  fatalError(&amp;#34;init(coder:) has not been implemented&amp;#34;)  }   public init?(_ subview: UIView) {  super.init(frame: .zero)  let textField = UITextField()  textField.isSecureTextEntry = true  guard let hiddenView = textField.layer.sublayers?.first?.delegate as? UIView  else {  print(&amp;#34;Something doesn&amp;#39;t work, please fill an issue with your OS and device version.&amp;#34;)  return nil  }  hiddenView.subviews.forEach { $0.removeFromSuperview() }  hiddenView.isUserInteractionEnabled = true  backgroundColor = .clear  hiddenView.translatesAutoresizingMaskIntoConstraints = false  addSubview(hiddenView)  NSLayoutConstraint.activate([  hiddenView.leadingAnchor.constraint(equalTo: leadingAnchor),  hiddenView.trailingAnchor.constraint(equalTo: trailingAnchor),  hiddenView.bottomAnchor.constraint(equalTo: bottomAnchor),  hiddenView.topAnchor.constraint(equalTo: topAnchor)  ])   subview.translatesAutoresizingMaskIntoConstraints = false  hiddenView.addSubview(subview)  NSLayoutConstraint.activate([  hiddenView.leadingAnchor.constraint(equalTo: subview.leadingAnchor),  hiddenView.trailingAnchor.constraint(equalTo: subview.trailingAnchor),  hiddenView.bottomAnchor.constraint(equalTo: subview.bottomAnchor),  hiddenView.topAnchor.constraint(equalTo: subview.topAnchor)  ])  } } /bin/sh: pod: command not found private func getRectInfo() -&amp;gt; (CGRect, CGRect, UIInterfaceOrientation)? {  let semaphore = DispatchSemaphore(value: 0)  var info: (scanFrame: CGRect, viewFrame: CGRect, orientation: UIInterfaceOrientation)? = nil  DispatchQueue.main.safeAsync { [weak self] in  guard let strongSelf = self else {  semaphore.signal()  return  }  info?.scanFrame = strongSelf.scanView.frame  info?.viewFrame = strongSelf.view.frame  info?.orientation = strongSelf.interfaceOrientation  semaphore.signal()  }  semaphore.wait()  return info } dyld: unloaded: /Developer/usr/lib/libBacktraceRecording.dylib dyld: unloaded: /Developer/usr/lib/libMainThreadChecker.dylib dyld: unloaded: /Developer/Library/PrivateFrameworks/MTLToolsDeviceSupport.framework/libMTLInterpose.dylib dyld: unloaded: /Developer/Library/PrivateFrameworks/DTDDISupport.framework/libViewDebuggerSupport.dylib dyld: Library not loaded: /System/Library/Frameworks/Network.framework/Network  Referenced from: /var/containers/Bundle/Application/xxx/xxx.app/xxx  Reason: image not found  if let fileAttributes = try? FileManager.default.attributesOfItem(atPath: fileUrl.path), let bytes = fileAttributes[.size] as? UInt64 {  sizes = bytes } </content>
    </entry>
    
     <entry>
        <title>Parallels Desktop 使用</title>
        <url>https://iihui.github.io/post/tool-parallel/</url>
        <categories>
          <category>tool</category>
        </categories>
        <tags>
          <tag>tool</tag>
        </tags>
        <content type="html"> 安装Windows 使用Parallels Desktop 17.1.1安装Windows 10虚拟机时出现报错信息：NetWork initialization failed. Your virtual machine will contine working normally but will have no network connection.，如下图所示：
参考这篇文章，此时需要以管理员身份修改/Library/Preferences/Parallels/network.desktop.xml文件。即将文件中UseKextless对应的值改为0:
按照上面方法改完之后，不会再出现上图所示的报错。但在安装过程中又出现了Operation Failed. Failed to execute the operation.错误信息。参考这个视频，首先在菜单栏选中Actions--&amp;gt;Configure，如下图所示：
然后依次选中Hardware--&amp;gt;CPU &amp;amp; Memory--&amp;gt;Advanced，再在弹出的设置框中将Hypevisor中的选项更改为Parallels，步骤如下图所示：
虚拟网络 在Parallels的桥接模式下，虚拟机可以和宿主机通信，也可以与宿主机同一局域网下并处于同一网段的其它设备通信，多个虚拟机之间也可以相互通信，也可以连接互联网。也就是桥接模式相当于为虚拟机新分配了一个局域网地址。
但这种桥接模式有一个问题，如果用的是笔记本电脑，一旦笔记本的网络发生变化（切换网络），虚拟机的ip地址也会随之变化。虽然可以为虚拟机设置固定ip，一旦宿主机网络发生改变，虚拟机固定的ip和当前宿主机的网络不在同一网段下的话，就无法再继续通信了。
网段发生变更时，如果不固定虚拟机ip，即动态ip，每次开机都需要先查看虚拟机的ip地址，然后使用新ip地址才能远程连接，这样太麻烦。如果固定ip的话，因为宿主机的网段发生变化后，又无法实现通信。两种方式都都有缺点，当前的需求如下：
 宿主机和虚拟机之间可以正常通信。 多个虚拟机之间可以正常通信。 宿主机同一局域网下且网段相同的设备可以和虚拟机之间实现通信。 虚拟机可以正常连接互联网。  参考这篇文章的解决方案，首先在Parallels的Prefrences–-&amp;gt;Network中勾选Enable IPv4 DHCP，接着设置起始和结束地址以及子网掩码：
刚刚的设置相当于在宿主机新加了一块虚拟网卡给虚拟机使用，宿主的网卡可以和同一局域网下同一网段的其它设备通信，同时宿主机的虚拟网卡也可以实现宿主机和虚拟机之间通讯。
如下图所示，然后设置端口转发规则。这个设置是为了让宿主机处于同一局域网且同一网段的其他设备与虚拟机通信。
设置完好之后，就可以使用ifconfig命令就可以查看虚拟机的ip地址:
</content>
    </entry>
    
     <entry>
        <title>Rider 使用</title>
        <url>https://iihui.github.io/post/tool-rider/</url>
        <categories>
          <category>tool</category>
        </categories>
        <tags>
          <tag>tool</tag>
        </tags>
        <content type="html"> 在CrossOver上安装 在Mac上使用CrossOver可以安装Windows软件，正常来说应该也可以利用CrossOver安装Windows版的Rider。因为Rider 2021.3.3只支持64位系统，如果想要在CrossOver中安装Rider，需要先安装64位的Bottle，可以选择Win7或者Win10。
因为Rider 2021.3.3依赖.NET Framework，所以需要在新安装的64位Bottle中先安装.NET Framework 4.7.2，这样才能成功安装Rider 2021.3.3。
IIS Express 如果想把Rider中的工程发布到IIS Express，可以参考这篇文章。若下载安装IIS Express后出现Cannot open assembly &#39;C:/Program Files (x86)/IIS Express/iisexpress.exe&#39;: File does not contain a valid CIL image错误。
如果发布时出现错误：IIS express请求已结束: http://localhost:52915/，且HTTP状态码为403.14，那么就要按照这篇文章操作。
ServiceModel 如果发布.Net应用后出现如下所示的报错，可以参考这篇文章：
离线安装数据库驱动 因为在内网无法安装数据库驱动，因此需要先从互联网下载驱动jar文件，然后在Data Sources and Drivers中选中某个数据库，再在Driver Files下面选中Custom JARs，导入下载的驱动文件即可：
IIS部署应用 使用IIS部署Web应用时，首先应当创建一个应用池，以免需要重启时影响其它的应用。如下图所示，先添加一个YY应用池，然后在Default Web Site下新建一个应用，如下图第2和第3步所示：
重启Default Web Site后如果点击某个目录，出现如下图所示的错误，那大概率就是IIS的设置不对。需要将World Wide Web Services目录下的Application Development Features下的ASP勾选一下：
参考资料
重启之后访问一下网站，最后以管理员身份运行Rider后在菜单栏选择Run---&amp;gt;Attach to Process选项，并在弹出的窗口中选择w3wp ... YY，然后打个断点，如果断点是变成了实心，则说明是成功的，否则失败:
如果Attach失败，需要先清理工程，然后重现编译，并且将Default Web Site重启一下，最后再打开一下部署的网页，回到Rider后再重新使用Attach to Process即可。
添加已有文件 如果使用Rider把某个已有的文件添加到项目中，但是编译之后又没看到这个文件，那么就是该文件的属性中的Build action没有设置为Content：
添加machineKey 参考链接
Keep Alive 配置 Min Pool Size=2;Max Pool Size=50;Connection Timeout=15;Keep Alive=60  Server=myServerAddress;Database=myDataBase;Uid=myUsername;Pwd=myPassword; Keepalive=10; 参考资料
参考资料
参考此文章，首先在Web.config文件中关闭应用程序的调试模式：
&amp;lt;system.web&amp;gt; &amp;lt;compilation debug=&amp;#34;false&amp;#34; /&amp;gt; &amp;lt;/system.web&amp;gt; 然后在工程中添加自定义错误页面，并在Web.config文件中添加如下代码：
&amp;lt;system.web&amp;gt; &amp;lt;customErrors mode=&amp;#34;RemoteOnly&amp;#34; defaultRedirect=&amp;#34;error.html&amp;#34;/&amp;gt; &amp;lt;/system.web&amp;gt; 无法识别的特性removeServerHeader 只需要Web.Config文件中删除removeServerHeader=&amp;ldquo;true&amp;quot;即可。
Http Error 403.14 Forbidden 如果再调试时出现A default document is not configured for the requested URL, and directory browsing is not enabled on the server错误，大概率是IIS里面没有开启**Directory browsing **，需要检查一下。如果发现IIS里面没有Directory browsing这个选项，则需要到控制面板---&amp;gt;程序--&amp;gt;开启或关闭windows程序---&amp;gt;Internet Information Services --&amp;gt;World Wide Web Services---&amp;gt;Common HTTP Features--&amp;gt;Directory Browsing开启即可。
参考资料
IIS Express/iisexpress.exe doesn&amp;rsquo;t exist 在Windows上使用Rider调试应用，运行时出现IIS Express/iisexpress.exe doesn&#39;t exist报错。这是因为本机没有安装IIS Express，到这里下载IIS Express，然后安装即可。
发布网站无法显示图片和CSS文件 本地调试可以正常显示图片和CSS文件资源，但在其他资源上却不能正常显示图片和css资源文件。
https://blog.csdn.net/yzm272/article/details/86506615
Rider远程调试 首先在windows上开启ssh远程配置权限，如果使用Add-WindowsCapability命令时报错The requested operation requires elevation，则需要以管理员身份打开PowerShell，再执行命令：
# 在 Windows 上启用 SSH 服务 # 1. 设置 -&amp;gt; 应用 -&amp;gt; 可选功能 -&amp;gt; 添加功能 -&amp;gt; OpenSSH 服务器 # 2. 启动服务：services.msc -&amp;gt; OpenSSH SSH Server -&amp;gt; 启动  # 或者使用 PowerShell Add-WindowsCapability -Online -Name OpenSSH.Server~~~~0.0.1.0 Start-Service sshd Set-Service -Name sshd -StartupType &amp;#39;Automatic&amp;#39; 修改Paralles Desktop虚拟机密码命令：
# 首先获取虚拟机 UUID $ prlctl list UUID STATUS IP_ADDR NAME {fdf05394-dc61-4d07-b6e5-e81ef5277a64} running - Ubuntu 22.04 ARM64  # 设定用户密码 $ prlctl set fdf05394-dc61-4d07-b6e5-e81ef5277a64 --userpasswd &amp;lt;USERNAME&amp;gt;:&amp;lt;PASSWORD&amp;gt; Authentication tokens updated successfully. Success. The operation was successfully completed.  The VM has been successfully configured. </content>
    </entry>
    
     <entry>
        <title>TypeScript基础</title>
        <url>https://iihui.github.io/post/ts-base/</url>
        <categories>
          <category>ts</category>
        </categories>
        <tags>
          <tag>ts</tag>
        </tags>
        <content type="html"> TypeScript的7种基本类型为：
 null undefined boolean string number bigint symbol  若声明变量时不显式标注类型，编译器会推断该变量的类型为any，表示该变量可以被赋为任何类型的值。如果声明变量时既不标注类型也不初始化，接着立即使用typeof得到的结果为undefined（即类型为undefined）。是因为TypeScript编译成JavaScript后，未初始化变量的默认值为undefined，所以使用typeof得到的类型就是undefined：
let rocker; // Type: any console.log(typeof rocker) // 运行结果为undefined  rocker = &amp;#34;Joan Jett&amp;#34; // 此时类型为string rocker.toUpperCase() // JOAN JETT console.log(rocker) // Joan Jett console.log(typeof rocker) // string  rocker = 19.58 // 此时类型为number console.log(rocker, typeof rocker) // 19.58 number console.log(typeof rocker) // number 函数的可选参数必须放在必需参数之后，若将可选参数放在必需参数前，会出现编译错误。下面示例代码会出现编译错误：A required parameter cannot follow an optional parameter。
// 编译错误：A required parameter cannot follow an optional parameter function hello3(x?: string, y: number) {  console.log(x, y) } 函数中具有默认值的参数若不位于参数列表的末尾，调用时不能省略该参数，此时如果要触发默认值，必须显式地传入undefined。下面示例代码中，函数的第一个参数传入了undefined，触发了x的默认值3：
function hello3(x = 3, y: number) {  console.log(x, y) }  hello3(undefined, 890)  // 执行结果 3 890 空值合并二元运算符??用于检查左侧表达式的求值是否等于null或undefined（二者其一）。若左侧表达式为null或undefined，则表达式的结果为右侧表达式，否则结果为左侧表达式。
const a = null const b = undefined const c = null  // 因为表达式左侧为null或undefined,所以表达式均为右侧的 console.log(a ?? 1, b ?? 2) // 因为a是null所以 a ?? c取c的值 console.log(a ?? c) // 因为a是null所以 a ?? b取b的值 console.log(a ?? b)  // 执行结果 1 2 null undefined 在访问对象属性时，如果该属性是undefined或者null，可选链运算符都会返回undefined。下面示例代码中，getSpouseNick的返回类型必须为string | null | undefined，因为this.spouse?.nick的值可能是null或undefined。可选链可以任意长，即可以包含任意数量的?.运算符。
class Person {  nick: string | null = null  spouse?: Person   setSpouse(spouse: Person): void {  this.spouse = spouse  }   getSpouseNick(): string | null | undefined {  // nick的类型是string | null，但使用了?操作符  // 所以this.spouse?.nick的类型可能为undefined  return this.spouse?.nick  }   constructor(nick: string) {  this.nick = nick  this.spouse = undefined  }  }  const person: Person = new Person(&amp;#39;nick&amp;#39;) // person.spouse的值为undefined console.log(person.spouse) // 因为spouse的值为undefined，所以最终值为undefined console.log(person.spouse?.nick)  // 执行结果 undefined undefined 作为对比，在下面示例代码中，因为属性spouse的默认值是null，若不改变值，则使用可选操作符?后得到的值为undefined：
class Person {  nick: string | null = null;  spouse?: Person | null = null;   setSpouse(spouse: Person): void {  this.spouse = spouse;  }   getSpouseNick(): string | null | undefined {  return this.spouse?.nick;  }  }  const person: Person = new Person() // person.spouse的值为null console.log(person.spouse) // spouse的值为null使用了可选链后得到的nick的值为undefined console.log(person.spouse?.nick)  // 执行结果 null undefined Modules JavaScript编程语言最近才规范了文件之间如何共享代码。ECMAScript 2015增加了ECMAScript Modules以规范文件间的import和export语法。
在module文件中声明的任何内容都只能在该文件中使用，除非该文件中有明确的export语句。下面代码中，test.ts文件从同级的./values文件中导入了value，并导出了一个doubled常量值：
// values.ts 中的代码 export const value = 12  // test.ts 中的代码 import { value } from &amp;#34;./values&amp;#34; export const doubled = value * 2; 如果在某一个模块中声明的变量和另一个模块中声明的变量同名，一般不会冲突。只有当在一个文件中导入了另一个文件中的同名变量时，才会产生冲突。
// a.ts export const shared = &amp;#34;Cher&amp;#34;;  // b.ts export const shared = &amp;#34;Cher&amp;#34;;  // c.ts import { shared } from &amp;#34;./a&amp;#34;; // 编译错误：Import declaration conflicts with local declaration of &amp;#39;shared&amp;#39;.  export const shared = &amp;#34;Cher&amp;#34;; // 编译错误：Individual declarations in merged declaration &amp;#39;shared&amp;#39; must be all exported or all local.  // 若不加export同样会出现编译错误，因为有同名变量 // Import declaration conflicts with local declaration of &amp;#39;shared&amp;#39;. const shared = &amp;#34;Cher&amp;#34;; 如果文件是脚本，TypeScript会将其视为全局作用域，这意味着其它所有脚本文件都可以访问其中的内容。也就是说，在某个脚本文件中声明的变量不能与其它脚本文件中声明的变量同名。
下面a.ts和b.ts文件均会被认为是脚本，因为它们中没有export和import语句。这意味着，如果在这两个文件中存在同名变量，就会产生冲突：
// a.ts const shared = &amp;#34;Cher&amp;#34;;  // b.ts const shared = &amp;#34;Cher&amp;#34;; // 编译错误：Cannot redeclare block-scoped variable &amp;#39;shared&amp;#39;. 根据ECMAScript规范，如果要将一个没有export或import语句的文件变成模块，可以在文件的某个地方添加一个export {};语句来强制让它成为一个模块。
// a.ts const shared = &amp;#34;Cher&amp;#34;;  // b.ts const shared = &amp;#34;Cher&amp;#34;; export {}; Unions and Literals  联合：将值的允许类型扩展为两种或两种以上的可能类型。窄化：减少值的允许类型，使其不属于一种或多种可能的类型。联合和窄化是一种强大的概念，允许对代码做出比其他主流语言更智能的推断。
 Union Types 下面变量mathematician的类型既可以是undefined，也可以是string，这种非此即彼的类型称为联合类型。联合类型是一个奇妙的概念，它可以让我们在代码中处理这样的情况：暂时还不知道某个值的确切类型，但确定它是两个或多个类型之一。
// 变量类型为string | undefined let mathematician = Math.random() &amp;gt; 0.5 ? undefined : &amp;#34;Mark Goldberg&amp;#34;; TypeScript使用管道操作符|来连接可能的类型：
let mathematician: string | undefined = Math.random() &amp;gt; 0.5 ? undefined : &amp;#34;Mark Goldberg&amp;#34;; 在变量在有初始值的情况下，也显式地将其类型标注为联合类型有时很有用。下面示例代码中，thinker一开始是null，但在某些情况下可能是字符串。将变量thinker的类型显式标注为string | null联合类型，意味着后续给它赋予字符串类型的值是允许的：
let thinker: string | null = null; if (Math.random() &amp;gt; 0.5) {  thinker = &amp;#34;Susanne Langer&amp;#34;; }  // 每次执行时生成随机数不同，结果就会不同 // 结果可能是Susanne Langer string 或 null object // null使用typeof拿到的结果为object console.log(thinker, typeof thinker) 联合类型可以放置在任何需要类型标注的地方。当已知值是一个联合类型时，只允许访问联合中所有子类型都存在的共有成员。如果尝试访问的属性不是联合类型所有子类型的共有属性或共有方法（函数），会出现编译错误。
下面代码中，physicist是一个number | string联合类型变量。因为方法toString()在两个子类型中都存在，所以可以直接调用。但是，toUpperCase方法仅存在于string类型，而toFixed方法仅存在于number类型。所以，如果直接调用toUpperCase和toFixed都会出现编译错误：
// physicist变量类型为string | number let physicist = Math.random() &amp;gt; 0.5 ? &amp;#34;Marie Curie&amp;#34; : 84; physicist.toString()  // 编译错误：Property &amp;#39;toUpperCase&amp;#39; does not exist on type &amp;#39;string | number&amp;#39;. // Property &amp;#39;toUpperCase&amp;#39; does not exist on type &amp;#39;number&amp;#39;. physicist.toUpperCase()  // 编译错误：Property &amp;#39;toFixed&amp;#39; does not exist on type &amp;#39;string | number&amp;#39;. // Property &amp;#39;toFixed&amp;#39; does not exist on type &amp;#39;string&amp;#39; physicist.toFixed() 需要注意的是，限制访问不存在于联合类型所有子类型的属性或方法是一种安全措施。如果一个对象还不确定是包含某个属性的子类型，TypeScript则认为尝试访问该子类型特有的属性是不安全的。
如果要使用仅存在于联合类型中某个子类型的属性或方法，我们的代码需向TypeScript表明在当前位置该值的类型就是某个具体的子类型，这一过程被称为窄化（narrowing）。
Narrowing 窄化是指在代码的某个位置推断出一个变量的类型比其声明时的类型更具体（类型范围更窄）。一旦知道一个值的类型比声明时的类型范围更窄，允许将该值的类型视为这个更具体（更窄）的类型。用于窄化类型范围的逻辑检查称为类型保护。下面介绍TypeScript可以用来从代码中窄化类型的两种常见类型保护。
Assignment Narrowing 如果直接赋值给一个联合类型变量，会立即将变量的类型缩小为该值的类型。下面代码中，变量admiral声明为number | string联合类型。一旦变量被赋值为字符串&amp;quot;Grace Hopper&amp;quot;，编译器就知道它现在是字符串类型：
let admiral: string | null admiral = &amp;#34;Grace Hopper&amp;#34;; admiral.toUpperCase(); // Ok: string // 编译错误：Property &amp;#39;toFixed&amp;#39; does not exist on type &amp;#39;string&amp;#39;. Did you mean &amp;#39;fixed&amp;#39;? admiral.toFixed(); 当变量的类型显式地标注为联合类型并且同时有一个初始值时，赋值窄化就会发挥作用。编译器知道，虽然变量以后可能会接收联合类型其它子类型的值，但它初始时只是初始值对应的类型。
let inventor: number | string = &amp;#34;Hedy Lamarr&amp;#34;; // 窄化为string类型 inventor.toUpperCase(); // 编译错误：Property &amp;#39;toFixed&amp;#39; does not exist on type &amp;#39;string&amp;#39; inventor.toFixed(); Conditional Checks 除了赋值窄化，窄化变量类型的常见方法是使用if语句，检查变量是否等于某个已知值。编译器非常聪明，知道在if语句中，变量类型必须与已知值类型相同：
// scientist的类型为string | number let scientist = Math.random() &amp;gt; 0.5 ? &amp;#34;Rosalind Franklin&amp;#34; : 51  if (scientist === &amp;#34;Rosalind Franklin&amp;#34;) {  console.log(scientist.toUpperCase()) // ROSALIND FRANKLIN }  // 出了if语句，变量的类型既可能是string也可能是number // 因此调用string类型的toUpperCase()方法会出现错误 // Property &amp;#39;toUpperCase&amp;#39; does not exist on type &amp;#39;string | number&amp;#39;. Property &amp;#39;toUpperCase&amp;#39; does not exist on type &amp;#39;number&amp;#39;. scientist.toUpperCase() 除了在if条件中直接对值进行检查，还可以使用typeof操作符窄化变量的类型。下面示例代码中，在if中使用typeof检查变量的类型是否为string：
// 变量scientist类型为联合类型string | number let scientist = Math.random() &amp;gt; 0.5 ? &amp;#34;Rosalind Franklin&amp;#34; : 51; // if中使用typeof窄化类型 if (typeof scientist === &amp;#39;string&amp;#39;) {  console.log(scientist.toUpperCase()) } else {  console.log(scientist.toFixed()) } 来自!和else语句对类型窄化同样有效：
// 变量researcher类型为联合类型string | number let researcher = Math.random() &amp;gt; 0.5 ? &amp;#34;Rosalind Franklin&amp;#34; : 51; if (typeof researcher === &amp;#34;string&amp;#34;) {  researcher.toUpperCase(); // Ok: string } else {  researcher.toFixed(); // Ok: number } Literal Types 介绍了联合和窄化用于处理可能是两种或两种以上类型的变量后，再来介绍一下字面量类型。字面量类型是对应基础类型的更具体版本，这与其它语言区别较大：
// 类型为&amp;#34;Hypatia&amp;#34; const philosopher = &amp;#34;Hypatia&amp;#34;  // 使用typeof打印出来的值还是string console.log(typeof philosopher) // string 上面代码中，philosopher是什么类型？乍一看，你可能认为是字符串，没错，philosopher的确是字符串。但是，常量philosopher并不是一个普通的字符串，它是具体的&amp;quot;Hypatia&amp;quot;。从技术上讲，常量philosopher的类型是更具体的&amp;quot;Hypatia&amp;quot;类型（比string类型更具体，类型更窄）。
这就是字面类型的概念：是基本类型的某个特定值，而不是对应基本类型的任何其它值。字符串基本类型代表了所有可能存在的字符串集合，而字符串字面量类型&amp;quot;Hypatia&amp;quot;只代表了这一特定字符串。
如果将一个变量声明为const，并直接赋值给它一个字面值，TypeScript将推断这个常量的类型是这个字面值类型。这就是为什么在IDE中将鼠标悬停在带有初始字面值的const常量上时，会显示常量的类型为字面值，而不是对应的基本类型。
// philosopher的类型为Hypatia // 即下面的声明类似const philosopher: &amp;#34;Hypatia&amp;#34; = &amp;#34;Hypatia&amp;#34; const philosopher = &amp;#34;Hypatia&amp;#34; 可以把每个基本类型看作是其所有可能字面值的联合类型。换句话说，基本类型是该类型所有可能字面值的集合。除了boolean，null和undefined类型，所有其它基本类型（例如number和string）均有无限多的字面值类型。在TypeScript代码中会出现的常见类型如下：
 boolean: 只有true | false null和undefined只有一个字面值，就是它们自己 number：0 | 1 | 2 | ... | 0.1 | 0.2 | ... string:&amp;quot;&amp;quot; | &amp;quot;a&amp;quot; | &amp;quot;b&amp;quot; | &amp;quot;c&amp;quot; | ... | &amp;quot;aa&amp;quot; | &amp;quot;ab&amp;quot; | &amp;quot;ac&amp;quot; | ...  需要注意的是，联合类型允许将字面值类型和基本类型混合使用。例如，下面变量lifespan表示可以用任何数值或已知的几种字符串字面值来表示：
let lifespan: number | &amp;#34;ongoing&amp;#34; | &amp;#34;uncertain&amp;#34;; lifespan = 89; // Ok lifespan = &amp;#34;ongoing&amp;#34;; // Ok // 编译错误：Type &amp;#39;true&amp;#39; is not assignable to type &amp;#39;number | &amp;#34;ongoing&amp;#34; | &amp;#34;uncertain&amp;#34;&amp;#39;. lifespan = true; Literal Assignability 我们已经知道，不同的基本类型（如number和string）是不能相互赋值的。同样地，同一基本类型中的不同字面量类型（如0和1）也不能互相赋值，下面代码会出现编译错误：
// specificallyAda的类型为Ada let specificallyAda: &amp;#34;Ada&amp;#34; specificallyAda = &amp;#39;Ada&amp;#39; // 执行结果为string console.log(typeof specificallyAda) // 打印出来仍是字符串string // 编译错误: Type &amp;#39;&amp;#34;B&amp;#34;&amp;#39; is not assignable to type &amp;#39;&amp;#34;Ada&amp;#34;&amp;#39;. specificallyAda = &amp;#39;B&amp;#39; 需要注意的是，基本类型的变量不能赋值给对应的字面量类型，但字面量类型可以赋值给相应的基本类型。因为任何特定的字面量字符串值仍然是字符串，下面代码不会出现编译错误：
let specificallyAda: &amp;#34;Ada&amp;#34;; specificallyAda = &amp;#39;Ada&amp;#39; let someString = &amp;#34;&amp;#34;; // Type: string // 可以将字面量类型赋值给器基本类型变量 someString = specificallyAda Strict Null Checking 在处理可能存在undefined值时，字面值联合的作用尤其明显。TypeScript是现代编程语言浪潮的一部分，这些语言利用严格的空值检查来解决可怕的billion-dollar mistake。
billion-dollar mistake billion-dollar mistake是一个术语，指许多类型系统在需要不同类型的地方允许null值。在没有strict null checking的语言中，像下面这样将null赋值给string类型的变量是允许的：
const firstName: string = null; // 如果是严格类型检查就会出现错误 // Type &amp;#39;null&amp;#39; is not assignable to type &amp;#39;string&amp;#39;. TypeScript编译器包含大量选项，可以改变运行方式。严格空值检查（strictNullChecks）是最有用的选项之一，它表示是否启用严格null值检查。概括来讲，禁用strictNullChecks（设置为false）意味着会为每个类型添加| null | undefined，从而允许任何变量都能接收null或undefined。
如果将strictNullChecks选项设置为false，下面代码会被认为是安全的。但这种方式是错误的，当使用变量nameMaybe调用toLowerCase方法时，它可能是undefined的：
let nameMaybe = Math.random() &amp;gt; 0.5 ? &amp;#34;Tony Hoare&amp;#34; : undefined; // Potential runtime error: Cannot read property &amp;#39;toLowerCase&amp;#39; of undefined. nameMaybe.toLowerCase() 如果开启了严格空值检查（strictNullChecks设置为false），下面代码将会出现编译错误：&#39;nameMaybe&#39; is possibly &#39;undefined&#39;。
let nameMaybe = Math.random() &amp;gt; 0.5 ? &amp;#34;Tony Hoare&amp;#34; : undefined; // &amp;#39;nameMaybe&amp;#39; is possibly &amp;#39;undefined&amp;#39;. nameMaybe.toLowerCase() 如果没有严格空值检查，就很难确定我们的代码是否会因意外的null或undefined而出错。最佳实践是启用strictNullChecks选项。这样做有助于防止代码崩溃，并消除billion-dollar mistake错误。
Truthiness Narrowing 在JavaScript中，除了false, 0, -0, 0n, &amp;quot;&amp;quot;, null, undefined, NaN八个为falsy值，其它都是truthy值。如果变量的某些可能值是truthy的，可以通过真值（truthiness)检查以窄化变量类型。
const zeroNaN = 0n if (zeroNaN) {  console.log(&amp;#39;true&amp;#39;) } else {  console.log(&amp;#39;false&amp;#39;) }  // 执行结果 false  let falseTest: string | null = null // null或者空字符串都会走到if语句中 if (!falseTest) {  console.log(&amp;#34;false&amp;#34;) }  // 执行结果 false 下面代码中，变量geneticist的类型是string | undefined，因为undefined是falsy值。代码进入第一个if语句体的前提是变量geneticist的值为truthy的，所以在if语句体中推断出它是string类型且值是非空字符串：
let geneticist = Math.random() &amp;gt; 0.5 ? &amp;#34;Barbara McClintock&amp;#34; : undefined;  // 如果变量是truthy的，则它一定不是undefined，一定是字符串 if (geneticist) {  console.log(geneticist.toUpperCase()) // BARBARA MCCLINTOCK }  let falsyTest: string | undefined | null // falsyTest为空字符串,undefined,null都会走到if语句中 // 测试时可以将falsyTest设置为null,undefined,&amp;#34;&amp;#34; if (!falsyTest) {  console.log(&amp;#34;false&amp;#34;) }  // 执行结果 false 逻辑运算符执行truthy值检查也同样有效，即使用&amp;amp;&amp;amp;和?运算符。但需要注意的是，运算符&amp;amp;&amp;amp;返回的是第一个falsy值或最后一个 truthy值，而不会将运算结果自动转换成true/false:
// 变量geneticist类型为string | undefined let geneticist = Math.random() &amp;gt; 0.5 ? &amp;#34;Barbara McClintock&amp;#34; : undefined;  // 执行结果可能为undefined或BARBARA MCCLINTOCK console.log(geneticist &amp;amp;&amp;amp; geneticist.toUpperCase())  // 执行结果可能为undefined或BARBARA MCCLINTOCK console.log(geneticist?.toUpperCase())   // test1变量的类型为联合类型：string ｜ undefined // const test1: string | undefined // 其类型不是boolean，这一点要特别注意！！！ const test1 = geneticist &amp;amp;&amp;amp; geneticist.toUpperCase()  // 而下面变量test的类型是boolean // const test2: boolean const test2 = !(geneticist &amp;amp;&amp;amp; geneticist.toUpperCase())  // 需要注意的是：!! 是一种简洁地将各种类型值转换为规范布尔值的手段 // 在需要准确获取布尔判断结果的诸多场景下都比较有用 const test3 = !!(geneticist &amp;amp;&amp;amp; geneticist.toUpperCase()) 需要注意的是，真值检查不能反过来使用。若知道类型为string | undefined变量的值是falsy的，并不能推断出这个值是空字符串还是undefined。
下面代码中，变量biologist的类型为string | false。虽然在if语句体中可以窄化类型为字符串，但else语句体包含了biologist的值是空字符串，也就是说在else里变量的类型依然为string | false：
// biologist的类型为联合类型 string | false // let biologist: string | false let biologist = Math.random() &amp;gt; 0.5 &amp;amp;&amp;amp; &amp;#34;Rachel Carson&amp;#34;; if (biologist) {  biologist // 类型此时一定为string } else {  biologist // 类型此时为false | string } Variables Without Initial Values 在JavaScript中，若变量没有初始值，则其默认值是undefined。这在类型系统typescript中出现了一种情况：如果将一个变量声明为不包括undefined的类型，然后尝试在赋值前使用它，会出现什么情况。
实际上，TypeScript很聪明，知道在变量赋值之前，其值是undefined。如果在赋值前尝试使用该变量的值，会出现编译错误。即使在未赋值前尝试使用?来访问变量的属性也会出现编译错误：
let mathematician: string; // 即使使用?来访问属性，也会出现编译错误！！！ // Variable &amp;#39;mathematician&amp;#39; is used before being assigned. mathematician?.length; 请注意，如果变量的类型中包括undefined，在未初始化时就使用变量，不会出现编译错误。在变量类型中添加| undefined是向TypeScript编译器说明，在使用前无需初始化，因为undefined是变量的有效值。
let mathematician: string | undefined; // 变量类型包含了undefined，使用前无需初始化 console.log(mathematician) console.log(mathematician?.length)  // 执行结果 undefined undefined 需要特别注意的是，在设置了严格空值检查模式下（在tsconfig.json文件中的compilerOptions下设置&amp;quot;strict&amp;quot;: true），定义联合类型变量时，如果类型中只包含了 | null，但不包含 | undefined，也需要初始化，否则会出现编译错误：
let mathematician1: string | null // 未初始化时就使用会出现编译错误 // Variable &amp;#39;mathematician1&amp;#39; is used before being assigned. console.log(mathematician1)  let mathematician2: string | undefined // 未初始化不会出现编译错误，执行后打印的undefined console.log(mathematician2)  // tsconfig.json中包含严格模式的设置 {  &amp;#34;compilerOptions&amp;#34;: {  &amp;#34;target&amp;#34;: &amp;#34;ES2022&amp;#34;,  &amp;#34;module&amp;#34;: &amp;#34;CommonJS&amp;#34;,  &amp;#34;outDir&amp;#34;: &amp;#34;out&amp;#34;,  &amp;#34;sourceMap&amp;#34;: true,  &amp;#34;strict&amp;#34;: true  },  &amp;#34;exclude&amp;#34;: [  &amp;#34;node_modules&amp;#34;  ],  &amp;#34;ts-node&amp;#34;: {  &amp;#34;files&amp;#34;: true  } } Type Aliases 大多数联合类型的子类型只有两到三个。但是，有时可能会遇到一些较长的联合类型，如果这种联合类型出现次数较多，使用起来会不太方便。
let rawDataFirst: boolean | number | string | null | undefined; let rawDataSecond: boolean | number | string | null | undefined; let rawDataThird: boolean | number | string | null | undefined; TypeScript可以定义类型别名，即为重复使用的类型（单一或联合类型）分配更简洁的名称。类型别名按照如下方式声明，按照惯例，类型别名以大驼峰命名（即遵循类型命名规范）：
type MyName = ...; 前面5种类型的联合，可以使用type定义别名类型，简写成如下形式：
type RawData = boolean | number | string | null | undefined; let rawDataFirst: RawData; let rawDataSecond: RawData; let rawDataThird: RawData; 类型别名是一项便捷功能，当代码中使用的联合类型开始变得复杂，就可以使用它。目前，只包括长联合类型，以后还将包括数组、函数和对象类型等。
Type Aliases Are Not JavaScript 类型别名与类型标注一样，编译后不会输出到JavaScript文件中。也就是说，因为类型别名仅存在于类型系统，所以不能在运行时的代码中引用它们。
type RawData = boolean | number | string | null | undefined;  // 编译错误：&amp;#39;RawData&amp;#39; only refers to a type, but is being used as a value here. // RawData仅表示类型，但在此处却作为值使用 console.log(RawData)  // 直接使用基本类型也是报错的 // &amp;#39;string&amp;#39; only refers to a type, but is being used as a value here. console.log(string);  let rawData: RawData = false console.log(rawData) console.log(typeof rawData)  // 执行结果 false boolean 如果试图访问运行时不存在的内容，会出现编译错误：
// 定义一个类型 type User = {  id: number;  name: string;  isAdmin: boolean; } // 定义一个符合该类型的对象 const user: User = {  id: 1,  name: &amp;#34;Alice&amp;#34;,  isAdmin: true }  // 因为别名类型User仅存在编译时，不存在运行时 // 尝试在运行时检查类型会出现错误 // &amp;#39;User&amp;#39; only refers to a type, but is being used as a value here. if (user instanceof User) {  console.log(&amp;#34;This is a User&amp;#34;); } Combining Type Aliases 在定义某个类型别名时也可以引用其它的类型别名，使得新的类型别名更简洁。类型别名相互引用有时很有用，当一个类型别名是一个联合类型时，它可能包含另一个类型别名。
type Id = number | string type IdMaybe = Id | undefined | null 需要注意的是，类型别名在定义时不必按使用顺序声明。可以让在文件中较前定义的类型别名引用在文件中较后定义的别名。上面代码可以重写，将IdMaybe放在Id之前声明，也不会出现编译错误：
// 别名Id的定义在后，使用在前 type IdMaybe = Id | undefined | null // 别名Id的定义在后，使用在前 type Id = number | string  let id: IdMaybe console.log(id) // undefined Objects TypeScript将类型分为两类。第一类是基本类型，包括number、boolean、string、symbol、bigint及其子类型。第二类是复合类型，涵盖所有对象的子类型，由其它复合类型或基本类型构成。
在某些情况下，需要操作复合类型的值，可能是为了修改特定属性，也可能是为了确保不会传递任何基本类型值。例如，Object.create方法会创建一个新对象，并将它的原型作为第一个参数。该参数必须是复合类型，否则运行时的JavaScript代码会崩溃：
// Argument of type &amp;#39;number&amp;#39; is not assignable to parameter of type &amp;#39;object&amp;#39; Object.create(2); 在 TypeScript中，有三种类型看似功能相同：空对象类型 {}、大写O开头的Object表示的对象接口，以及小写o 开头的object表示的对象类型。那么复合类型该使用哪一种呢？
{}和Object允许的值大致相同，即除null或undefined之外的所有值（前提是严格模式或strictNullChecks已开启），下面：
let obj: {}; // Similar to Object obj = 32; obj = &amp;#34;Hello&amp;#34;; obj = true; obj = () =&amp;gt; {  console.log(&amp;#34;Hello&amp;#34;) }; obj = undefined; // Error obj = null; // Error obj = {name: &amp;#34;Stefan&amp;#34;, age: 40}; obj = []; obj = /.*/; 接口Object兼容所有具有Object prototype的值，即来自所有基本类型和复合类型的所有值。但是，Object是TypeScript中定义的接口，它对某些函数有特定要求。例如toString方法（即 toString() =&amp;gt; string），作为任何非空值的组成部分，属于Object原型的一部分。若赋值时使用了不同的toString方法，TypeScript将报错：
let okObj: {} = {  toString() {  return false;  } };  // 出现编译错误 // Type &amp;#39;() =&amp;gt; boolean&amp;#39; is not assignable to type &amp;#39;() =&amp;gt; string&amp;#39; let obj: Object = {  toString() {  return false;  } } 由于这种行为，Object可能会造成一些混淆，因此在大多数情况下，使用{}即可。TypeScript允许小写的object类型，这更符合我们的需求，因为它允许任何复合类型，但不允许基本类型：
let obj: object; obj = 32; // Error obj = &amp;#34;Hello&amp;#34;; // Error obj = true; // Error obj = () =&amp;gt; {  console.log(&amp;#34;Hello&amp;#34;) }; obj = undefined; // Error obj = null; // Error obj = {name: &amp;#34;Stefan&amp;#34;, age: 40}; obj = []; obj = /.*/; Object Types 使用{}创建对象字面量时，TypeScript会根据其属性将其视为新的对象类型。新对象类型具有与对象字面量相同的属性名和对应值类型。访问对象属性的值时可以使用value.member或等同的value[&#39;member&#39;]。
下面代码中，TypeScript认为常量poet的类型是一个对象，该对象有born和name两个属性，属性born的值类型为number，name属性的值类型为string。访问这两个属性是允许的，但试图访问任何其它不存在的属性都会出现编译错误：
// const poet: { born: number, name: string } const poet = {  born: 1935,  name: &amp;#34;Mary Oliver&amp;#34;, };  console.log(poet.born, poet.name, poet[&amp;#39;born&amp;#39;], poet[&amp;#39;name&amp;#39;])  // 访问不存在的属性会出现编译错误，这与联合类型只能访问子类型的共有属性或方法是一样的 // Property &amp;#39;end&amp;#39; does not exist on type &amp;#39;{ born: number; name: string; }&amp;#39; poet.end; 对象类型是TypeScript理解JavaScript代码的核心概念。除null和undefined之外的每个对象值都有一组成员，必须了解对象类型中的每个值，才能对其进行类型检查。
console.log(typeof null) console.log(typeof undefined)  // 执行结果 object undefined Declaring Object Types 从现有的对象中直接推断出类型固然是好的，但有些场景需要显式标注变量为对象类型。此时，需要一种方式描述对象类型，将其与满足对象类型的值区分开来。对象类型使用与对象字面量相似的语法来描述，但与属性名对应的是其值的类型而不是相应的值。若对象类型变量出现赋值相关的编译错误时，显示的是声明对象类型时的语法，清晰易读。
// 先声明，声明时未被初始化 // 定义时最后一个分号是可以省略 let poetLater: {  born: number;  name: string; };  poetLater = {born: 123, name: &amp;#39;678&amp;#39;} console.log(poetLater) // { born: 123, name: &amp;#39;678&amp;#39; }  // 编译错误：Type &amp;#39;number&amp;#39; is not assignable to type &amp;#39;{ born: number; name: string; }&amp;#39;. poetLater = 123  // 定义时属性之间也可以使用逗号分隔 // 定义时最后一个逗号也是可以去掉的 let poetLater: {  born: number,  name: string, };  // 定义时属性之间也可以用换行符分隔，不需要分号或逗号 let poetLater: {  born: number  name: string }  // 需要注意的是字面量属性之间必须使用逗号分隔！！！ poetLater = {born: 123, name: &amp;#39;678&amp;#39;} console.log(poetLater.born, poetLater.name) // 123 678 Aliased Object Types 声明对象变量时，重复写类似{ born: number; name: string; }这样的对象类型很快就会觉得厌烦，也容易出错。常见的做法是使用type创建类型别名，为对象类型赋予一个新名字。
// 使用type创建类型别名 type Poet = {  born: number;  name: string; };  /* // 属性之间也使用逗号分隔，使用换行也可以 type Poet = { born: number, name: string, }; type Poet = { born: number name: string }; const poet: Poet = {born: 123, name: &amp;#34;werr&amp;#34;} console.log(poet) */  let poetLater: Poet; poetLater = {  born: 1935,  name: &amp;#34;Sara Teasdale&amp;#34;, };  // 编译错误：Type &amp;#39;string&amp;#39; is not assignable to type &amp;#39;Poet&amp;#39;. poetLater = &amp;#34;Emily Dickinson&amp;#34;; Structural Typing TypeScript的类型系统是structural typed的，这意味着任何满足类型的值都可以用作该类型的值。换句话说，当标注一个参数或变量是一个特定对象类型时，就是在声明无论使用什么对象值，它们都需要具有这些属性。
下面WithFirstName和WithLastName别名对象类型都只声明了一个字符串类型的成员。常量hasBoth同时有这两种成员，因此可以赋值给这两种别名对象类型中的任何一种变量：
type WithFirstName = { firstName: string; }; type WithLastName = { lastName: string; };  const hasBoth = {firstName: &amp;#34;Lucille&amp;#34;, lastName: &amp;#34;Clifton&amp;#34;}; // 不直接使用类型字面量而是使用变量赋值避开了属性检查 let withFirstName: WithFirstName = hasBoth; let withLastName: WithLastName = hasBoth;  console.log(withFirstName) console.log(withLastName) console.log(hasBoth);  // 执行结果 { firstName: &amp;#39;Lucille&amp;#39;, lastName: &amp;#39;Clifton&amp;#39; } { firstName: &amp;#39;Lucille&amp;#39;, lastName: &amp;#39;Clifton&amp;#39; } { firstName: &amp;#39;Lucille&amp;#39;, lastName: &amp;#39;Clifton&amp;#39; } 需要注意的是，Structural typing与Duck typing不同，后者源于「如果它看起来像鸭子，叫起来像鸭子，那它可能就是鸭子」。JavaScript是Duck typing的，而TypeScript是Structural typing的。
 Structural typing是指有一个静态系统来检查类型，在TypeScript中这个静态系统就是类型检查器。 Duck typing使用之前不检查对象类型，直到运行时才检查类型。  Usage Checking  给对象变量赋值时至少会触发两种检查，第一种是属性缺少检查，第二种是属性对应值的类型检查。若使用字面量赋值，还会触发第三种检查，即多余属性检查。
 当向显式标注为对象类型的变量赋值时，编译器将检查该值是否可赋值给这个对象类型。首先，对象值必须包含对象类型的所有必需属性。如果对象值中缺少对象类型所需的任何成员，将会出现编译错误。
type FirstAndLastNames = {  first: string;  last: string; };  const hasBoth: FirstAndLastNames = {  first: &amp;#34;Sarojini&amp;#34;,  last: &amp;#34;Naidu&amp;#34;, };  // 赋值时字面量缺少属性，会出现编译错误 // Property &amp;#39;last&amp;#39; is missing in type &amp;#39;{ first: string; }&amp;#39; but required in type &amp;#39;FirstAndLastNames&amp;#39;. const hasOnlyOne: FirstAndLastNames = {first: &amp;#34;Sappho&amp;#34;}; 因为对象类型既指定了所需属性的名称，也指定了这些属性对应值的类型，所以也不允许两者之间值的类型不匹配。如果对象属性的对应值类型不匹配，也会出现编译错误。
type TimeRange = { start: Date; }; // 编译错误: Type &amp;#39;string&amp;#39; is not assignable to type &amp;#39;Date&amp;#39;. const hasDateStr: TimeRange = {  start: &amp;#34;1999-02-13&amp;#34;, }  // 下面属性对应的值的类型是正确的，不会出现编译错误 const hasDate: TimeRange = {  start: new Date(), } console.log(hasDate) Excess Property Checking 若一个变量声明为对象类型，并且使用字面量初始化时，若字面量中的字段多于其类型所描述的字段时，也会出现编译错误（适用于函数形参声明）。因此，将变量显式标注为对象类型是一种让类型检查程序确保变量恰好只包含该类型预期字段的方法。
type Poet = {  born: number;  name: string; }  const poetMatch: Poet = {  born: 1928,  name: &amp;#34;Maya Angelou&amp;#34; };  const extraProperty: Poet = {  activity: &amp;#34;walking&amp;#34;,  born: 1935,  name: &amp;#34;Mary Oliver&amp;#34;, };  // 编译错误：Object literal may only specify known properties, and &amp;#39;activity&amp;#39; does not exist in type &amp;#39;Poet&amp;#39;. 但需要注意的是，只有在标注为对象类型的位置创建的对象字面量才会触发多余属性检查。若提供已有常量或变量存储的对象字面量可以绕过多余属性检查，下面示例代码绕过了多余属性检查：
type Poet = {  born: number;  name: string; }  const poetMatch: Poet = {  born: 1928,  name: &amp;#34;Maya Angelou&amp;#34; };  const existingObject = {  born: 1935,  name: &amp;#34;Mary Oliver&amp;#34;,  // 相对于Poet类型来说，activity是多余属性  activity: &amp;#34;walking&amp;#34;, };  // 使用变量绕过多余属性检查 const extraProperty: Poet = existingObject console.log(poetMatch)  // 执行结果 { activity: &amp;#39;walking&amp;#39;, born: 1935, name: &amp;#39;Mary Oliver&amp;#39; } 在需要对象类型的任何地方使用字面量创建新对象时，都会触发多余属性检查，即创建的对象字面量必须与标注的对象类型匹配。禁止多余属性能确保代码整洁并按照期望的方式运行，因为通常在对象类型中声明的多余属性是书写时输入了错误的属性名。
借助结构化类型系统，可以通过类型推断的载体变量创建有趣的模式，并在软件的不同部分复用同一变量，而这些部分之间无需存在任何关联，Student、Person和Studing存在部分重叠，但彼此无关。createPerson返回的对象需兼容这三种类型。若过度添加类型标注，将导致创建大量冗余类型和检查逻辑，既无实际效益又徒增负担。
type Person = {  name: string;  age: number; }; type Studying = {  semester: number; }; type Student = {  id: string;  age: number;  semester: number; }; function createPerson() {  return {name: &amp;#34;Stefan&amp;#34;, age: 39, semester: 25, id: &amp;#34;XPA&amp;#34;}; } function printPerson(person: Person) {  console.log(person.name, person.age); } function studyForAnotherSemester(student: Studying) {  student.semester&#43;&#43;; } function isLongTimeStudent(student: Student) {  return student.age - student.semester / 2 &amp;gt; 30 &amp;amp;&amp;amp; student.semester &amp;gt; 20; } const me = createPerson(); // All work! printPerson(me); studyForAnotherSemester(me); isLongTimeStudent(me); Nested Object Types 由于JavaScript对象中可以嵌入其它对象成员，因此TypeScript的对象类型也必须能够表示嵌套的对象类型。嵌套类型语法与之前相同，但使用{ ... }对象类型来代替基础类型。
// 创建别名类型 type Poem = {  author: {  firstName: string;  lastName: string;  };  name: string; };  // Ok const poemMatch: Poem = {  author: {  firstName: &amp;#34;Sylvia&amp;#34;,  lastName: &amp;#34;Plath&amp;#34;,  },  name: &amp;#34;Lady Lazarus&amp;#34;, };  // 创建字面量对象作为初始值会触发属性检查 // 编译错误:Object literal may only specify known properties, and &amp;#39;name&amp;#39; does not exist in type &amp;#39;{ firstName: string; lastName: string; }&amp;#39; const poemMismatch: Poem = {  author: {  name: &amp;#34;Sylvia Plath&amp;#34;,  },  name: &amp;#34;Tulips&amp;#34;, }; 声明Poem类型的另一种方法是将author属性提取到别名对象类型Author中。若将对象类型中的嵌套类型提取到别名类型中，在编译出现错误时提供更详细的信息，有助于排查和定位问题。
type Author = {  firstName: string;  lastName: string; };  type Poem = {  author: Author;  name: string; };  // 编译错误：Object literal may only specify known properties, and &amp;#39;name&amp;#39; does not exist in type &amp;#39;Author&amp;#39; const poemMismatch: Poem = {  author: {  name: &amp;#34;Sylvia Plath&amp;#34;,  },  name: &amp;#34;Tulips&amp;#34;, };  /* // 也可以使用,分隔属性 type Author = { firstName: string, lastName: string, }; type Poem = { author: Author, name: string, }; */ 通常来说，为嵌套对象类型创建一个别名类型是个好主意，这样既能使具有嵌套类型的代码更易读，也能使TypeScript的错误信息更清晰易读。
Optional Properties 对象类型的属性不一定都是必需属性，可以在属性的类型标注的:前加上?来表示它是一个可选属性（这种方式与Swift区别很大）。下面示例代码中，Book中的author属性是可选的：
type Book = {  author?: string;  pages: number; };  const ok: Book = {  author: &amp;#34;Rita Dove&amp;#34;,  pages: 80, };  const normal: Book = {  pages: 80, };  console.log(normal) // 执行结果 // 打印结果时不会显示可选类型 {pages: 80}  // 不能缺少必需属性，否则会出现编译错误 // Property &amp;#39;pages&amp;#39; is missing in type &amp;#39;{ author: string; }&amp;#39; but required in type &amp;#39;Book&amp;#39;. const missing: Book = {  author: &amp;#34;Rita Dove&amp;#34;, }; 需要注意的是，可选属性与属性的类型标注为包括undefined的联合类型是不同的。声明为可选属性，属性可以不存在（此时属性对应值为undefined）。但使用| undefined声明的属性，其值必须存在，即便该属性的值就是undefined也不能省略。
type Writers = {  author: string | undefined;  editor?: string; };  const hasRequired: Writers = {  author: undefined, };  // 但定义变量时，若是带undefined的联合类型可以不初始化 let test: string | undefined console.log(test)  // 对象中属性为undefined的联合类型时必须赋初值 // 触发属性检查，author属性必须有，且必须提供值 // Property &amp;#39;author&amp;#39; is missing in type &amp;#39;{}&amp;#39; but required in type &amp;#39;Writers&amp;#39;. const missingRequired: Writers = {}; 请特别注意，对象类型中某个属性的类型标注为与undefined的联合，与普通变量类型标注为undefined的联合区别较大。对象类型中属性的类型是包含了undefined的联合类型时也需要初始化，而普通变量变量不需要初始化。
Unions of Object Types  如果变量的初始值可能是多种对象类型之一，TypeScript将推断变量的类型为对象类型的联合。该联合类型为每种可能的类型提供一个成分，类型上的每种可能属性都将出现在每个组成元素中，尽管它们在没有初始值的任何类型中都是可选类型。
 Inferred Object-Type Unions 下面代码中，常量poem的值一定有name属性，可能有pages或rhymes属性。常量poem的类型被推断为{name: string, pages: number, rhymes?: undefined} | {name: string, rhymes: boolean, pages?: undefined} 。也就是说编译器在推断对象类型的联合时，非共有属性均是可选的，并且对应的值类型是undefined:
// poem的类型被推断为{name: string, pages: number, rhymes?: undefined} | {name: string, rhymes: boolean, pages?: undefined} const poem = Math.random() &amp;gt; 0.5 ? {  name: &amp;#34;The Double Image&amp;#34;,  pages: 7 } : {  name: &amp;#34;Her Kind&amp;#34;,  rhymes: true };  poem.name // 类型为 string poem.pages; // 类型为 number | undefined poem.rhymes; // 类型为 boolean | undefined  // 执行后的可能结果:The Double Image 7 undefined console.log(poem.name, poem.pages, poem.rhymes, typeof poem) // 执行后的可能结果：string undefined boolean console.log(typeof poem.name, typeof poem.pages, typeof poem.rhymes);  console.log(poem) // 执行结果是下面二者之一，可选类型不会打印出来！！！ {name: &amp;#39;Her Kind&amp;#39;, rhymes: true} {name: &amp;#39;The Double Image&amp;#39;, pages: 7} Explicit Object-Type Unions 也可以通过对象类型的联合来更明确地标注对象类型，这样做需要写更多代码，好处是能更多地控制对象类型。但需要注意的是，如果是对象类型的联合，则只允许访问存在于联合类型所有子类型上的属性。这与上面将变量推断为对象类型的联合有明显区别：
type PoemWithPages = {  name: string;  pages: number; };  type PoemWithRhymes = {  name: string;  rhymes: boolean; };  // 定义别名类型，该类型是对象类型的联合 type Poem = PoemWithPages | PoemWithRhymes;  const poem: Poem = Math.random() &amp;gt; 0.5 ? {name: &amp;#34;The Double Image&amp;#34;, pages: 7} : {name: &amp;#34;Her Kind&amp;#34;, rhymes: true};  // 访问联合类型所有子类型的共有属性，不会出现编译错误 poem.name;  // 因为pages属性不一定有，所以会编译错误 // Property &amp;#39;pages&amp;#39; does not exist on type &amp;#39;Poem&amp;#39;. // Property &amp;#39;pages&amp;#39; does not exist on type &amp;#39;PoemWithRhymes&amp;#39;. poem.pages;  // 因为rhymes属性不一定有，所以会编译错误 // Property &amp;#39;rhymes&amp;#39; does not exist on type &amp;#39;Poem&amp;#39;. // Property &amp;#39;rhymes&amp;#39; does not exist on type &amp;#39;PoemWithPages&amp;#39;. poem.rhymes; Narrowing Object Types 如果类型检查器发现在某个位置的代码只有在联合类型值包含特定属性的情况下才能运行，那么会将联合类型窄化到只包含该属性的子类型。换句话说，如果在代码中检查对象，类型窄化功能也适用。
type PoemWithPages = {  name: string;  pages: number; };  type PoemWithRhymes = {  name: string;  rhymes: boolean; };  type Poem = PoemWithPages | PoemWithRhymes;  const poem: Poem = Math.random() &amp;gt; 0.5 ? {name: &amp;#34;The Double Image&amp;#34;, pages: 7} : {name: &amp;#34;Her Kind&amp;#34;, rhymes: true};  // pages若在poem中，则可以访问该属性，不能直接使用.来访问属性，因为还不确定是否有该属性 // 如果直接使用.操作符访问属性将出现编译错误 if (&amp;#34;pages&amp;#34; in poem) {  console.log(poem.pages) } else {  // 如果没有pages，那么必定有属性rhymes  console.log(poem.rhymes) } 请注意，TypeScript不允许使用if (poem.pages)这样的真值检查，因为还不确定变量中是否有该属性。试图访问可能不存在的对象属性会被视为错误，即使用起来的方式看起来像是类型保护。
Discriminated Unions JavaScript和TypeScript中另一种流行的联合类型对象形式是在对象上设置一个属性，用于指示对象具体是哪种类型。这种类型被称为判别联合(discriminated union)，指示对象类型的属性被称为discriminant。TypeScript能够对在discriminant属性上进行类型保护的代码执行类型窄化。
// type表示判别类型 type PoemWithPages = {  name: string;  pages: number;  type: &amp;#39;pages&amp;#39;; };  type PoemWithRhymes = {  name: string;  rhymes: boolean;  type: &amp;#39;rhymes&amp;#39;; };  type Poem = PoemWithPages | PoemWithRhymes;  const poem: Poem = Math.random() &amp;gt; 0.5 ? {  name: &amp;#34;The Double Image&amp;#34;,  pages: 7,  type: &amp;#34;pages&amp;#34; } : {  name: &amp;#34;Her Kind&amp;#34;,  rhymes: true,  type: &amp;#34;rhymes&amp;#34; };  if (poem.type === &amp;#34;pages&amp;#34;) {  // 进行了类型窄化  console.log(`It&amp;#39;s got pages: ${poem.pages}`); } else {  // 进行了类型窄化  console.log(`It rhymes: ${poem.rhymes}`); } Intersection Types 联合类型表示一个值的类型可能是两个或多个不同类型中的一个。TypeScript同样允许同时表示多种类型，即intersection（交叉）类型。intersection类型通常与别名对象类型一起使用，以创建合并多个现有类型的新类型。
// 使用type定义新类型时可以使用分号，逗号，或换行来分隔属性 type Artwork = {  genre: string;  name: string; };  type Writing = {  pages: number;  name: string; };  // 定义新的交叉类型 type WrittenArt = Artwork &amp;amp; Writing;  // 必须同时具有name,pages和genre属性 const writtenAndArt: WrittenArt = {  name: &amp;#39;test&amp;#39;,  genre: &amp;#39;man&amp;#39;,  pages: 123, }  console.log(writtenAndArt) // 执行结果 { name: &amp;#39;test&amp;#39;, genre: &amp;#39;man&amp;#39;, pages: 123 } Intersection类型可以与联合类型结合使用。在某些场景这种结合有助于只在一种类型中描述discriminated unions，省略重复定义的共有属性。下面示例代码中，使用交叉与联合类型的交叉省略了重复定义属性author：
type ShortPoem = { author: string } &amp;amp; (| {  kigo: string;  type: &amp;#34;haiku&amp;#34;; } | {  meter: number;  type: &amp;#34;villanelle&amp;#34;; });  /* 可以去掉第一个用于联合的 | type ShortPoem = { author: string } &amp;amp; ({ kigo: string; type: &amp;#34;haiku&amp;#34;; } | { meter: number; type: &amp;#34;villanelle&amp;#34;; }); */  const morningGlory: ShortPoem = {  author: &amp;#34;Fukuda Chiyo-ni&amp;#34;,  kigo: &amp;#34;Morning Glory&amp;#34;,  type: &amp;#34;haiku&amp;#34;, };  // 下面会出现编译错误： Type &amp;#39;{ author: string; type: &amp;#34;villanelle&amp;#34;; }&amp;#39; is not assignable to type &amp;#39;{ author: string; } &amp;amp; { meter: number; type: &amp;#34;villanelle&amp;#34;; }&amp;#39;. const oneArt: ShortPoem = {  author: &amp;#34;Elizabeth Bishop&amp;#34;,  type: &amp;#34;villanelle&amp;#34;, }; Dangers of Intersection Types Intersection（交叉类型）是一个有用的概念，但使用时很容易让自己或TypeScript编译器感到困惑。建议在使用交叉类型时尽量简化代码。
当创建了复杂的交叉类型（如与联合类型交叉）时，赋值错误信息就会变得难以理解。这是类型编程语言的一个共同主题：创建的类型越复杂，就越难理解来自类型检查器给出的错误信息。
以前面代码片段中的ShortPoem为例，如果将该类型拆分为一系列别名对象类型，TypeScript就可以打印这些别名，可读性就会大大提高：
type ShortPoemBase = {  author: string };  type Haiku = ShortPoemBase &amp;amp; {  kigo: string;  type: &amp;#34;haiku&amp;#34; };  type Villanelle = ShortPoemBase &amp;amp; {  meter: number;  type: &amp;#34;villanelle&amp;#34; };  type ShortPoem = Haiku | Villanelle;  // 编译错误：Type &amp;#39;{ author: string; type: &amp;#34;villanelle&amp;#34;; }&amp;#39; is not assignable to type &amp;#39;ShortPoem&amp;#39;. const oneArt: ShortPoem = {  author: &amp;#34;Elizabeth Bishop&amp;#34;,  type: &amp;#34;villanelle&amp;#34;, }; never 使用&amp;amp;声明Intersection类型很容易被滥用，创建出一种不可能的类型。基本类型不能作为交叉类型的成员组合在一起，因为一个值不可能同时是多个基本类型。如果尝试将两个基本类型交叉在一起，就会产生never类型：
// 一个变量不可能既是number又是string类型，所以NotPossible的类型为never type NotPossible = number &amp;amp; string  // 编译错误：Type &amp;#39;number&amp;#39; is not assignable to type &amp;#39;never&amp;#39;. let notPossible: NotPossible = 123 类型never被称为bottom type或empty type。底层类型是指不可能的值，也是无法到达的类型。需要注意的是，不能向标注为底层类型的位置提供任何类型值，否则会出现编译错误：
type NotPossible = number &amp;amp; string // 编译错误：Type &amp;#39;number&amp;#39; is not assignable to type &amp;#39;never&amp;#39;. let notNumber: NotPossible = 0; // 编译错误：Type &amp;#39;number&amp;#39; is not assignable to type &amp;#39;never&amp;#39;. let notString: never = &amp;#34;&amp;#34;; 大多数项目很少使用never类型，never偶尔会出现在代码中表示不可能的状态。但多数情况下，很可能是误用Intersection（交叉）产生的错误类型。
Functions 前面介绍了如何使用类型标注来声明变量和常量的类型。现在，可以看看如何对函数的形参类型和返回值类型进行同样的标注。
Function Parameters 下面定义的函数入参只有一个song，并在函数体中打印了这个参数的值。但在声明该函数时形参并没有显式地标注类型，那么编译器会认为这个参数的类型是any：
function sing(song) {  console.log(`Singing: ${song}!`); }  // 编译错误 Parameter &amp;#39;song&amp;#39; implicitly has an &amp;#39;any&amp;#39; type. 但如果编译选项设置的是严格模式（在tsconfig.json文件中的compilerOptions下设置&amp;quot;strict&amp;quot;: true），上面代码会出现编译错误：Parameter &#39;song&#39; implicitly has an &#39;any&#39; type。与变量的类型标注一样，允许使用类型标注函数形参的类型。例如，可以使用: string告诉编译器形参song的类型是字符串类型：
function sing(song: string) {  console.log(`Singing: ${song}!`); } Required Parameters JavaScript函数允许使用任意数量的实参(arguments)调用函数，而TypeScript假定函数中声明的所有参数都是必需的。如果使用错误数量或类型的实参数来调用函数，将会出现编译错误。
如果函数调用的实参过少或过多，TypeScript的实参计数器就会发挥作用。下面函数singTwo声明时有两个参数，因此传递1个或3个参数都是不允许的。实际上，强制要求向函数提供必需的参数，有助于执行类型安全。如果不能确保这些参数值都存在，可能会导致代码出现意外行为。
function singTwo(first: string, second: string) {  console.log(`${first}/ ${second}`); }  // 编译错误：Expected 2 arguments, but got 1. singTwo(&amp;#34;Ball and Chain&amp;#34;)  // 编译错误：Expected 2 arguments, but got 3. singTwo(&amp;#34;Go Your Own Way&amp;#34;, &amp;#34;The Chain&amp;#34;, &amp;#34;Dreams&amp;#34;); 形参（parameter）是指函数声明的预期参数。实参（arguments）是指函数调用时提供给形参的值。上面示例代码中，first和second是形参，而&amp;quot;Ball and Chain&amp;quot;等字符串是实参。
Optional Parameters TypeScript允许将形参标注为可选参数，即在其类型标注的:前添加?（类似于对象类型的可选属性）。函数调用时可以不向可选参数提供实参，因为它们的类型总是以| undefined作为联合类型。
下面announceSong函数中，singer形参被标记为可选参数，它的类型是string | undefined。对于可选参数，函数的调用者可以不提供实参（此时其值为undefined）。如果主动提供了singer对应的实参，它的值可能是一个字符串或undefined：
// 声明singer为可选参数，且为最后一个形参 function announceSong(song: string, singer?: string) {  console.log(`Song: ${song}`);  if (singer) {  console.log(`Singer: ${singer}`);  } }  announceSong(&amp;#34;Greensleeves&amp;#34;); // Ok announceSong(&amp;#34;Greensleeves&amp;#34;, undefined); // Ok announceSong(&amp;#34;Chandelier&amp;#34;, &amp;#34;Sia&amp;#34;); // Ok  // 上面三次调用的执行结果 Song: Greensleeves Song: Greensleeves Song: Chandelier Singer: Sia  // 在调用函数时，如果没有为可选参数提供实参，其值为undefined function announceSong(song: string, singer?: string) {  console.log(`Song: ${song}`);  console.log(`Singer: ${singer}`); }  announceSong(&amp;#34;test&amp;#34;)  // 执行结果 Song: test Singer: undefined // 可选参数未传入实参时，值为undefined 可选参数与包含| undefined的联合类型参数不同。调用函数时，未用?标记为可选的参数必需提供实参，即使其值是undefined。函数的可选参数必须放在必需参数后面，若将可选参数放在必需参数前，会出现编译错误。
// 将可选参数放到必需参数前出现编译错误 // A required parameter cannot follow an optional parameter. function announceSong(song?: string, singer: string) {  console.log(`Song: ${song}`);  console.log(`Singer: ${singer}`); } 如果定义的函数参数列表后面有多个可选参数，调用时若想略过前面的可选参数，则必需显式传入值undefined，否则编译器会认为实参是传给前面的可选形参。下面定义的announceSong函数，如果只想给函数最后一个参数传入有效实参，则需要将前面的参数都传入undefined：
function announceSong(song?: string, singer?: string, name?: string) {  console.log(`Song: ${song}`);  console.log(`Singer: ${singer}`);  console.log(name) }  announceSong(&amp;#39;test&amp;#39;) announceSong(undefined, &amp;#39;test&amp;#39;) announceSong(undefined, undefined, &amp;#39;test&amp;#39;)  // 执行结果 Song: test Singer: undefined undefined  Song: undefined Singer: test undefined  Song: undefined Singer: undefined test Default Parameters 若函数定义时参数有默认值且没有指明类型，编译器会根据默认值推断形参的类型。下面rateSong函数中，参数rating的类型被推断为number：
function rateSong(song: string, rating = 0) {  console.log(`${song}gets ${rating}/5 stars!`); }  rateSong(&amp;#34;Photograph&amp;#34;); // Ok rateSong(&amp;#34;Set Fire to the Rain&amp;#34;, 5); // Ok rateSong(&amp;#34;Set Fire to the Rain&amp;#34;, undefined); // Ok  // 会出现编译错误：Argument of type &amp;#39;string&amp;#39; is not assignable to parameter of type &amp;#39;number&amp;#39;. rateSong(&amp;#34;At Last!&amp;#34;, &amp;#34;100&amp;#34;); 具有默认值的参数若不位于形参列表的末尾，调用时则不能省略该参数，如果要触发默认值，必须显式地传入undefined。但需要特别注意的是，undefined是用来触发默认值的，不是传入的真正实参。
function hello3(x = 3, y: number) {  console.log(x, y) }  hello3(undefined, 890) // 执行结果 3 890  // 如果省略默认参数则会出现编译错误: Expected 2 arguments, but got 1. hello3(13) Rest Parameters 在JavaScript中展开操作符...必须是函数声明的最后一个参数，表示从该参数开始传递给函数的所有rest参数都应存储在一个数组中。需要特别注意的是，一个函数只能有一个rest参数。
// 编译错误： A rest parameter must be last in a parameter list. function singAllTheSongs(...songs: string[], singer: string) {  for (const song of songs) {  console.log(`${song}, by ${singer}`);  } }  // 一个函数只能有一个rest parameters function singAllTheSongs(...songs: string[], ...singer: [number]) {  for (const song of songs) {  console.log(`${song}, by ${singer}`);  } }  // 编译错误error TS1014: A rest parameter must be last in a parameter list. 函数中若**同时有可选参数和可变参数时，可变参数需要放到最后，否则会出现编译错误。也就是说，对于函数最后一个参数来说，可变参数具有更高优先级**：
function singTwo(first?: string, ...second: string[]) {  console.log(`${first}/ ${second}`); }  // 这样定义会出现编译错误，因为可变参数在前面 function singTwo1(...first: string[], second?: string[]) {  console.log(`${first}/ ${second}`); } // 编译错误  A rest parameter must be last in a parameter list. 在TypeScript中允许标注rest参数的类型，与普通参数类似，只是在末尾添加了[]语法，表示这是一个数组。下面函数singAllTheSongs第二个形参允许接受0个或多个字符串类型的实参：
function singAllTheSongs(singer: string, ...songs: string[]) {  for (const song of songs) {  console.log(`${song}, by ${singer}`);  } }  singAllTheSongs(&amp;#34;Alicia Keys&amp;#34;); // Ok singAllTheSongs(&amp;#34;Lady Gaga&amp;#34;, &amp;#34;Bad Romance&amp;#34;, &amp;#34;Just Dance&amp;#34;, &amp;#34;Poker Face&amp;#34;); // Ok  // 执行结果 Bad Romance, by Lady Gaga Just Dance, by Lady Gaga Poker Face, by Lady Gaga Return Types 如果编译器知道函数所有可能的返回值，就能推断出函数的返回类型。下面示例代码中，因为函数singSongs返回一个number值，所以编译器推断函数的返回类型为number：
function singSongs(songs: string[]) {  for (const song of songs) {  console.log(`${song}`);  }  return songs.length; } 如果函数体中包含多个不同返回语句，编译器将返回类型推断为所有可能返回值类型的联合。下面函数getSongAt的返回类型将被推断为string | undefined：
function getSongAt(songs: string[], index: number) {  return index &amp;lt; songs.length ? songs[index] : undefined; } Explicit Return Types 如同变量声明，通常不建议使用类型标注来显式声明函数的返回值类型。不过，在某些情况下显式地标注函数的返回类型很有用：
 可能希望强制具有多种可能返回值的函数始终返回相同类型的值。 TypeScript编译器拒绝尝试推断递归函数的返回类型。 加快超大型项目中的TypeScript类型检查速度。  函数声明时的返回值类型标注位于参数列表的右圆括号之后，左大括号{之前：
// 使用function定义的函数可以在其定义前被调用 console.log(singSongsRecursive([&amp;#39;000&amp;#39;]))  function singSongsRecursive(songs: string[], count = 0): number {  return songs.length ? singSongsRecursive(songs.slice(1), count &#43; 1) : count; } 对于箭头函数（也称为lambdas表达式）来说，返回类型标注正好位于箭头=&amp;gt;之前，箭头之后是函数体。下面定义了两个箭头函数receive和singSongsRecursive：
const receive = (song: string): number =&amp;gt; {  return song.length } console.log(receive(&amp;#39;67890&amp;#39;)); // 执行结果为5  // 定义递归箭头函数 const singSongsRecursive = (songs: string[], count = 0): number =&amp;gt; songs.length ? singSongsRecursive(songs.slice(1), count &#43; 1) : count;  const len = singSongsRecursive([&amp;#39;13&amp;#39;, &amp;#39;345&amp;#39;, &amp;#39;890&amp;#39;]) console.log(len) // 3  console.log(singSongsRecursive([&amp;#39;2&amp;#39;, &amp;#39;45&amp;#39;, &amp;#39;99090&amp;#39;], 10)) // 执行结果为13 若函数体中返回语句对应的值不能赋值给函数标注的返回类型，会出现编译错误。下面示例代码中，函数的返回类型标注为Date | undefined，但在函数体中却返回了string：
function getSongRecordingDate(song: string): Date | undefined {  switch (song) {  case &amp;#34;Strange Fruit&amp;#34;:  return new Date(&amp;#39;April 20, 1939&amp;#39;); // Ok  case &amp;#34;Greensleeves&amp;#34;:  // 编译错误: Type &amp;#39;string&amp;#39; is not assignable to type &amp;#39;Date&amp;#39;.  return &amp;#34;unknown&amp;#34;;  default:  return undefined; // Ok  } } 但需要注意的是，使用function定义的函数可以在其定义前被调用，而箭头函数不能在定义前调用（否则会出现编译错误）。
// 先使用后定义 test()  function test() {  console.log(&amp;#34;Test&amp;#34;) } Function Types JavaScript允许将函数作为值传递。这意味着需要一种方法来声明用于存放函数类型的参数或变量。函数类型标注语法与箭头函数类似，只是用类型代替了函数体。下面变量nothingInGivesString的类型标注为一个无参数，返回一个字符串的函数：
// 猜测是因为已经有冒号了，所以不使用冒号来定义返回值类型 let nothingInGivesString: () =&amp;gt; string; 下面变量inputAndOutput的类型标注是一个函数，该函数有一个string[]字符串数组类型的形参，一个可选的形参count，并返回一个number类型值：
let inputAndOutput: (songs: string[], count?: number) =&amp;gt; number; 函数类型常用于描述回调：
const songs = [&amp;#39;123&amp;#39;, &amp;#39;789&amp;#39;, &amp;#39;778&amp;#39;]  function runOnSongs(songs: string[], getSongAt: (index: number) =&amp;gt; string) {  for (let i = 0; i &amp;lt; songs.length; i &#43;= 1) {  console.log(getSongAt(i));  } }  function runOnSongs2(songs: string[], getSongAt: (index: number) =&amp;gt; [string, number]) {  for (let i = 0; i &amp;lt; songs.length; i &#43;= 1) {  console.log(getSongAt(i));  } }  function getSongAt(index: number) {  return `${songs[index]}`; }  // 调用函数 runOnSongs(songs, getSongAt); Function Type Parentheses 函数类型可以放置在任何需要类型标注的地方，包括联合类型。在联合类型中，可以使用圆括号来表示哪一部分是函数返回值哪一部分是联合类型的函数子类型：
// 定义了一个函数类型变量，该函数的返回的类型是string和undefine的联合 // Type is a function that returns a union: string | undefined let returnsStringOrUndefined: () =&amp;gt; string | undefined; // 定义了一个变量，该变量的类型是函数类型和undefined的联合 // Type is either undefined or a function that returns a string let maybeReturnsString: (() =&amp;gt; string) | undefined; Parameter Type Inferences 如果必须为编写的每个函数（包括用作参数的内联函数）声明参数类型，将会非常麻烦。幸运的是，可以推断出函数中的参数类型，即使用函数声明时相同位置的参数类型。
下面示例代码中，变量singer是一个接收字符串类型形参的函数，因此赋值给singer的函数中的song参数也是一个字符串类型。声明和定义分开时，定义的参数名可以和声明时不一致：
let singer: (song: string) =&amp;gt; string;  // 下面形参song的类型被推断为string singer = function (song) {  let str = `Singing: ${song.toUpperCase()}!`  console.log(str)  return str }  singer(&amp;#39;test&amp;#39;)  // 形参名可以和定义时可以不一致！！！ singer = function (singer) {  let str = `Singing: ${singer.toUpperCase()}!`  console.log(str)  return str } 实际上，作为实参传递给函数类型形参的函数，其参数类型也能被推断出来。下面示例代码中，参数song和index的类型被推断为string和number:
const songs = [&amp;#34;Call Me&amp;#34;, &amp;#34;Jolene&amp;#34;, &amp;#34;The Chain&amp;#34;];  // 省略了第3个数组参数，这里有个疑问为什么可以省略第3个参数？？？ songs.forEach((song, index) =&amp;gt; {  console.log(`${song}is at index ${index}`); }); Function Type Aliases 用于创建类型别名的type也可以用于函数类型。下面示例代码中，类型别名StringToNumber是一个接收string并返回number的函数，这意味着别名类型StringToNumber可以用来标注函数变量的类型：
type StringToNumber = (input: string) =&amp;gt; number; let stringToNumber: StringToNumber;  // input被推断为字符串类型 stringToNumber = (input) =&amp;gt; input.length; console.log(stringToNumber(&amp;#39;1233199&amp;#39;)) // 7  stringToNumber = function (input) {  return 123 } console.log(stringToNumber(&amp;#39;3455&amp;#39;)) // 123 类似地，函数的类型别名也可以用于函数形参的声明：
type NumberToString = (input: number) =&amp;gt; string;  function usesNumberToString(numberToString: NumberToString) {  console.log(`The string is: ${numberToString(1234)}`); } More Return Types 接下来看两个特殊的函数返回值类型，void和never。有些函数并不返回任何值，它们要么没有return语句，要么只有无返回值的return语句。TypeScript允许使用void关键字来说明这种不返回任何值的函数的返回类型。
在返回类型声明为void的函数体中不能返回任何值，否则会出现编译错误。下面函数logSong被声明为返回void类型，因此在函数体中不允许有返回值。在函数体中出现了return true，所以会出现编译错误：
function logSong(song: string | undefined): void {  // 空字符串或undefined直接返回  if (!song) {  return; // Ok  }  console.log(`${song}`);  // 出现编译错误：Type &amp;#39;boolean&amp;#39; is not assignable to type &amp;#39;void&amp;#39;  // 无返回值的函数不能返回值  return true; } 在**箭头函数类型声明时（不使用function关键字声明的函数），void作为返回类型很有用。在函数类型声明时，将函数返回类型标注void时，它表示函数中的任何返回值都将被忽略**。下面示例代码中，songLogger变量代表了一个函数，它接受一个string参数，并且不返回任何值：
let songLogger: (song: string) =&amp;gt; void;  songLogger = (song) =&amp;gt; {  console.log(`${song}`); };  songLogger(&amp;#34;Heart of Glass&amp;#34;); // Ok  // 下面函数类型声明时使用void作为返回类型 // 但实参函数中有返回值时也会被忽略 let songLogger: (song: string) =&amp;gt; void; songLogger = (song: string) =&amp;gt; {  console.log(song);  // 虽然有参数参数返回，但会被忽略，不会出现编译错误！！！  return song; }  let test = songLogger(&amp;#34;HerKind1&amp;#34;); console.log(test);  // 执行结果 HerKind1 HerKind1  // 不会出现编译错误 let arrT: () =&amp;gt; void = () =&amp;gt; {  return &amp;#34;ddd&amp;#34; }  const songs = [&amp;#34;Call Me&amp;#34;, &amp;#34;Jolene&amp;#34;, &amp;#34;The Chain&amp;#34;]; songs.forEach((song, index) =&amp;gt; {  console.log(`${song}is at index ${index}`);  // 即使有返回值也会被忽略  return &amp;#34;&amp;#34; });   function test11(): void {  // }  // 不能重新赋值 // Cannot assign to &amp;#39;test11&amp;#39; because it is a function test11 = () =&amp;gt; {  return &amp;#34;ddd&amp;#34; } 请注意，尽管JavaScript函数在没有真实返回值的情况下默认会返回undefined，但返回类型**void并不等同于undefined。void意味着函数的返回值将被忽略，而undefined则是要返回的字面量**。此外，若尝试将void类型值赋给类型包括undefined的变量，将会出现编译错误：
function returnsVoid() {  return }  let lazyValue: string | undefined // 将void赋值给变量出现编译错误 // Type &amp;#39;void&amp;#39; is not assignable to type &amp;#39;string | undefined&amp;#39;. lazyValue = returnsVoid() 返回值undefined和void之间的区别，对于忽略传递到形参为函数类型的，并且该形参函数的返回类型标注为void的实参函数的任何返回值特别有用。例如，数组的内置forEach方法声明的形参函数的返回类型为void，它可以忽略任何传入的实参函数的返回值。
// forEach的定义 forEach(callbackfn: (value: T, index: number, array: T[]) =&amp;gt; void, thisArg?: any): void; 下面saveRecords函数中，records.push(record)返回一个数值（数组push()方法的返回值，表示数组的元素个数），但仍允许作为传递给newRecords.forEach的箭头函数的返回值，因为这个返回值会被忽略：
let records = [&amp;#39;123&amp;#39;, &amp;#39;456&amp;#39;]  function saveRecords(newRecords: string[]) {  // records.push有返回值，且没有使用大括号，因此records.push就是箭头函数的返回值  // 实际上传入的实参是有返回值，但被忽略了  newRecords.forEach(record =&amp;gt; records.push(record)); }  saveRecords([&amp;#39;21&amp;#39;, &amp;#39;Come On Over&amp;#39;, &amp;#39;The Bodyguard&amp;#39;]) console.log(records) // [ &amp;#39;123&amp;#39;, &amp;#39;456&amp;#39;, &amp;#39;21&amp;#39;, &amp;#39;Come On Over&amp;#39;, &amp;#39;The Bodyguard&amp;#39; ] void类型不属于JavaScript，仅是TypeScript的一个关键字，用于声明函数的返回值类型。需要注意的是，它表示函数的返回值不打算被使用，而不是表示返回值可以被返回。
Never Returns 有些函数不仅没有返回值，而且根本不返回。永不返回的函数是那些抛出错误或运行无限循环的函数（希望是故意的）。如果一个函数永远不返回，那么显式添加: never类型标注，表示调用该函数后的任何代码都不会运行。
function fail(message: string): never {  throw new Error(`Invariant failure: ${message}.`); }  try {  fail(&amp;#34;123&amp;#34;) } catch (e) {  console.error((e as Error).message) }  // 执行结果 Invariant failure: 123. 下面fail函数只是抛出一个错误，它有助于控制流分析，将参数param窄化为string，即参数param的类型不为string，则会抛出异常。虽然没有标注返回类型，编译器推断返回类型是void，而不是never：
function workWithUnsafeParam(param: unknown) {  if (typeof param !== &amp;#34;string&amp;#34;) {  fail(`param should be a string, not ${typeof param}`)  }  // 类型窄化为string  console.log(param.toUpperCase())  // 编译错误: Property &amp;#39;toFixed&amp;#39; does not exist on type &amp;#39;string&amp;#39;  // console.log(param.toFixed()); }  workWithUnsafeParam(&amp;#39;1233&amp;#39;)  // 执行结果 1233 需要注意的是，返回类型为void指的是函数不返回任何内容，而never指的是永远不返回内容的函数。never is not the same as void. void is for a function that returns nothing. never is for a function that never returns.
Function Overloads 有些JavaScript函数可以使用完全不同的实参来调用，而这些实参集不能只用可选参数或可变参数来表示。这些函数可以使用一种被称为重载签名（overload signatures）的语法来描述：在最终实现签名和函数体之前，多次声明不同版本的形参和返回类型。
在决定是否对重载函数的调用发出语法错误时，TypeScript只会查看函数的重载签名。实现签名只用于函数的内部逻辑。
function createDate(timestamp: number): Date; function createDate(month: number, day: number, year: number): Date; function createDate(monthOrTimestamp: number, day?: number, year?: number) {  return day === undefined || year === undefined ? new Date(monthOrTimestamp) : new Date(year, monthOrTimestamp, day); }  createDate(554356800); // Ok createDate(7, 27, 1987); // Ok 函数的重载签名与类型系统的其它语法一样，在编译输出为JavaScript后会被删除。一般来说，最好保持函数简单，尽可能避免使用函数重载。
Call-Signature Compatibility 重载函数实现所使用的签名就是该函数的实现所使用的参数类型和返回类型。因此，函数重载签名中的返回类型和每个参数都必须可以可赋值给实现签名中同一索引处的参数。换句话说，重载函数的实现签名必须与所有重载签名兼容。下面示例代码中，因为实现签名和所有的重载签名不兼容，会出现编译错误：
function format(data: string): string; // Ok function format(data: string, needle: string, haystack: string): string; // Ok function format(getData: () =&amp;gt; string): string;  // This overload signature is not compatible with its implementation signature. function format(data: string, needle?: string, haystack?: string) {  return needle &amp;amp;&amp;amp; haystack ? data.replace(needle, haystack) : data; } Arrays TypeScript通过记住数组中初始的数据类型，并且只允许数组对该数据类型进行操作，从而遵守了每个数组只使用一种数据类型的最佳实践。
const warriors = [&amp;#34;Artemisia&amp;#34;, &amp;#34;Boudica&amp;#34;]; // Ok: &amp;#34;Zenobia&amp;#34; is a string warriors.push(&amp;#34;Zenobia&amp;#34;); // 编译错误：Argument of type &amp;#39;boolean&amp;#39; is not assignable to parameter of type &amp;#39;string&amp;#39;. warriors.push(true); 通常，编译器通常会尝试从初始赋值来推断类型，数组也不例外。根据数组的初始成员推断数组类型与根据变量的初始值推断变量类型类似。
Array Types 如同其它变量声明，数组变量声明时也可以不初始化。同样地，在严格模式下，如果数组变量未初始化之前就使用会出现编译错误：
let arrayOfNumbers: number[];  // 因为已标注了类型且未初始化 // 所以未初始化前就使用会编译报错 // Variable &amp;#39;arrayOfNumbers&amp;#39; is used before being assigned. console.log(typeof arrayOfNumbers) console.log(arrayOfNumbers[0])  arrayOfNumbers = [4, 8, 15, 16, 23, 42];  // 初始化之后才可以使用，此时不会出现编译错误 console.log(typeof arrayOfNumbers) // 打印出来的值为Object Array and Function Types 如果涉及数组和函数类型时可能需要使用圆括号来区分数组类型中的内容。圆括号可用于指明类型中哪一部分是函数的返回值，哪一部分是数组内容。
// Type is a function that returns an array of strings let createStrings: () =&amp;gt; string[];  // Type is an array of functions that each return a string let stringCreators: (() =&amp;gt; string)[]; Union-Type Arrays 可以使用联合类型来标注数组中元素是多个可能的类型。将数组类型与联合类型一起使用时，可能需要使用圆括号来指明中哪一部分是数组的内容，哪一部分是联合类型的内容。在数组联合类型中使用圆括号非常重要，以下两种类型并不相同：
// Type is either a number or an array of strings let stringOrArrayOfNumbers: string | number[]  // Type is an array of elements that are each either a number or a string let arrayOfStringOrNumbers: (string | number)[] 如果同一个数组中的元素类型不同，编译器就会从数组的声明中推断它是一个union类型的数组。换句话说，使用字面量初始化数组变量时，数组中元素的类型是数组中所有可能元素类型的联合。
// namesMaybe的类型是(string | undefined)[] const namesMaybe = [  &amp;#34;Aqualtune&amp;#34;,  &amp;#34;Blenda&amp;#34;,  undefined, ]  console.log(namesMaybe) console.log(typeof namesMaybe)  // 执行结果 [&amp;#34;Aqualtune&amp;#34;, &amp;#34;Blenda&amp;#34;, undefined] object Evolving Any Arrays 若初始值为空的数组变量不加上类型标注，则数组的类型将被推断为any[]。这意味着该数组可以接收任何内容，若不小心添加了可能不正确的值，会抵消类型检查器的好处。
// Type: any[] let values = []; values.push(&amp;#39;&amp;#39;); values[1] = 0; console.log(values, typeof values) // [ &amp;#39;&amp;#39;, 0 ] object 如同变量，如果允许数组的元素是any类型，也就违背了类型检查的目的。当精确地知道变量是什么类型时，编译器会工作得更好。
Multidimensional Arrays 一个二维数组，有两个[]，三维数组有3个[]，四维数组有4个[]，5个数组有5个[]，依此类推：
// 声明二维数组，下面两种方式均可以 let arrayOfArraysOfNumbers1: number[][]; let arrayOfArraysOfNumbers2: (number[])[];  arrayOfArraysOfNumbers1 = [[1, 2, 3], [2, 4, 6], [3, 6, 9],]; arrayOfArraysOfNumbers2 = [[1, 2, 3], [2, 5, 8], [4, 7, 11],];  console.log(arrayOfArraysOfNumbers1, arrayOfArraysOfNumbers2) Array Members TypeScript基于索引访问数组中的元素。下面定义的常量defenders类型为string[]，因此接收数组中元素的常量defender的类型是string:
const defenders = [&amp;#34;Clarenza&amp;#34;, &amp;#34;Dina&amp;#34;]; // Type: string const defender = defenders[0]; 联合类型数组的成员都是同一种联合类型。下面常量soldiersOrDates的类型为(string | Date)[]，因此常量soldierOrDate的类型也为string | Date：
const soldiersOrDates = [&amp;#34;Deborah Sampson&amp;#34;, new Date(1782, 6, 3)]; // 即使不显式标注类型，编译器可以推断出类型为: Date | string const soldierOrDate = soldiersOrDates[0]; Caveat: Unsound Members 众所周知，TypeScript的类型系统在技术上是不健全的，它可以使类型在多数情况下是正确的，但有时对值类型的理解可能是不正确的，数组尤其是类型系统不健全的根源。
默认情况下，TypeScript假设所有数组成员的访问都会返回相应成员，尽管在JavaScript中，访问数组元素的索引大于数组的长度会得到undefined。下面这段代码编译没有任何问题，但运行时会报错，因为访问了undefined，但它没有length属性：
function withElements(elements: string[]) {  // 不会出现编译错误  console.log(elements[9001].length) }  // 运行时错误：Cannot read properties of undefined (reading &amp;#39;length&amp;#39;) withElements([&amp;#34;It&amp;#39;s&amp;#34;, &amp;#34;over&amp;#34;]) TypeScript故意不确保检索到的数组成员是否存在，它认为上面示例代码片段中的elements[9001]是字符串类型，而不是undefined类型。
Spreads and Rests 在函数定义时可以使用...表示可变参数，在数组中也有同样的操作符...，被称为spread操作符，表示将数组展开。同样的符号，代表不同的含义，需要特别注意。
Spreads 可以使用...展开操作符将将数组连接在一起，结果数组将包含来自输入数组的所有值。如果输入数组的元素类型相同，则结果数组的元素类型也相同。如果将两个不同类型的数组展开在一起创建一个新数组，新数组将被推断为联合类型数组。
// 数组类型为 string[] const soldiers = [&amp;#34;Harriet Tubman&amp;#34;, &amp;#34;Joan of Arc&amp;#34;, &amp;#34;Khutulun&amp;#34;]; // 数组类型为 number[] const soldierAges = [90, 19, 45];  // 数组类型为 (string | number)[] const conjoined = [...soldiers, ...soldierAges]; // [ &amp;#39;Harriet Tubman&amp;#39;, &amp;#39;Joan of Arc&amp;#39;, &amp;#39;Khutulun&amp;#39;, 90, 19, 45 ]  // 数组类型为string[] console.log([...soldiers, ...soldiers]); Spreading Rest Parameters 编译器可识别...展开操作符，即可将一个数组展开作为可变形参的实参并执行类型检查。数组作为实参传递给可变形参时必须具有相同类型，下面代码中展开数组warriors是允许的：
function logWarriors(greeting: string, ...names: string[]) {  for (const name of names) {  console.log(`${greeting}, ${name}!`);  } }  const warriors = [&amp;#34;Cathay Williams&amp;#34;, &amp;#34;Lozen&amp;#34;, &amp;#34;Nzinga&amp;#34;] // 可变参数和数组并不是同一回事 logWarriors(&amp;#34;Hello&amp;#34;, ...warriors);  // 执行结果 Hello, Cathay Williams! Hello, Lozen! Hello, Nzinga! Tuples 与对象类似，JavaScript数组是组织复杂对象数据的常用方式。与其他示例中编写典型的Person对象不同，你可以逐个存储条目：
const person = [&amp;#34;Stefan&amp;#34;, 40]; // name and age 使用数组而非对象的优势在于数组元素没有属性名称。当你通过解构将每个元素赋值给变量时，便能轻松地为其指定自定义名称：
const person = {  name: &amp;#34;Stefan&amp;#34;,  age: 40, }; const {name, age} = person; 然而，在使用TypeScript并依赖类型推断时，这种模式可能会引发一些问题。默认情况下，TypeScript会根据赋值操作推断数组类型。数组是开放式的集合，每个位置都包含相同的元素：
// const person: (string | number)[] const person = [&amp;#34;Stefan&amp;#34;, 40]; 因此TypeScript认为person是一个数组，其中每个元素可以是字符串或数字，并且允许在最初两个元素之后存在大量元素。这意味着在解构时，每个元素的类型也是字符串或数字：
const [name, age] = person; // name: string | number // age: string | number 虽然数组在理论上可以是任意大小，但有时使用固定大小的数组（称为元组）也很有用。元组中的每个元素都有特定类型，这个类型可能比数组所有可能成员的联合类型更具体。声明元组类型的语法与数组字面量相似，只是用类型代替了元素值。
// 元组类型，中括号里面是类型 let yearAndWarrior: [number, string]; yearAndWarrior = [530, &amp;#34;Tomyris&amp;#34;]; // Ok console.log(yearAndWarrior[0], yearAndWarrior[1]); 在JavaScript中，元组通常与数组解构一起使用，以便一次赋值多个变量。例如，可以根据条件判断设置两个变量的初始值。下面使用元组来解构数组的元素，得到的类型和直接访问某个元素得到的结果不一样：
// 因为是使用字面量直接解构，所以year的类型为number,warrior的类型为string // 注意year和warrior类型不是sting | number let [year, warrior] = Math.random() &amp;gt; 0.5 ? [340, &amp;#34;Archidamia&amp;#34;] : [1828, &amp;#34;Rani of Jhansi&amp;#34;]; console.log(year, warrior) // 每次执行结果可能不同，结果为340 Archidamia 或1828 Archidamia console.log(typeof year, typeof warrior); // number string  // other的类型为string ｜ number let other = (Math.random() &amp;gt; 0.5 ? [340, &amp;#34;Archidamia&amp;#34;] : [1828, &amp;#34;Rani of Jhansi&amp;#34;])[0]; Tuple Assignability 在TypeScript中元组类型视为比变长数组更特殊的类型，这意味着变长数组类型不能赋值给元组类型。下面代码中，变量pairLoose是数组类型(boolean | number)[]，即数组中元素类型是(boolean | number)。
// 推断为数组类型，数组中元素的类型为 (boolean | number)[] const pairLoose = [false, 123]  // 编译错误: Type &amp;#39;(number | boolean)[]&amp;#39; is not assignable to type &amp;#39;[boolean, number]&amp;#39; // Target requires 2 element(s) but source may have fewer. const pairTupleLoose: [boolean, number] = pairLoose 上面代码中，如果将变量pairLoose的类型声明为[boolean, number]，那么赋值就是允许的，也不会出现编译错误，因为元组类型比数组更特殊：
const pairLoose: [boolean, number] = [false, 123] const pairTupleLoose: [boolean, number] = pairLoose 需要注意的是，不同长度的元组也不能相互赋值。因为在声明元组时，编译器已经知道当前元组中有多少个成员，每个成员的类型是什么：
const tupleThree: [boolean, number, string] = [false, 1583, &amp;#34;Nzinga&amp;#34;]; const tupleTwoExact: [boolean, number] = [tupleThree[0], tupleThree[1]];  // 编译错误：Type &amp;#39;[boolean, number, string]&amp;#39; is not assignable to type &amp;#39;[boolean, number]&amp;#39;. // Source has 3 element(s) but target allows only 2. const tupleTwoExtra: [boolean, number] = tupleThree; 因为元组被视为数组，但在长度和元素类型上有更具体的信息，所以用于存储传递给函数的实参特别有用。编译器能够将作为实参传递给函数使用...操作符展开的元组提供精确的类型检查。
function logPair(name: string, value: number) {  console.log(`${name}has ${value}`); }  // pairArray的类型为数组 (string | number)[] const pairArray = [&amp;#34;Amage&amp;#34;, 1];  // 因为pariArray是数组，展开后的元素类型为string | number // 得到的元素类型和函数logPair的类型不一致，会出现编译错误 // A spread argument must either have a tuple type or be passed to a rest parameter. logPair(...pairArray);  const pairTupleIncorrect: [number, string] = [1, &amp;#34;Amage&amp;#34;]; // 编译错误:Argument of type &amp;#39;number&amp;#39; is not assignable to parameter of type &amp;#39;string&amp;#39;. // 元组被展开后，对应的类型顺序不对，也会出现编译错误 logPair(...pairTupleIncorrect);  // 元组类型被展开，编译不会报错 const pairTupleCorrect: [string, number] = [&amp;#34;Amage&amp;#34;, 1]; logPair(...pairTupleCorrect); // Ok 如果想在rest parameters tuples上做文章，可以将它们与数组混合，为多个函数调用存储参数。下面代码中trios.forEach(trio =&amp;gt; logTrio(...trio))是安全的，因为...trio中的每个元素恰好与函数logTrio的参数类型相匹配。即元组...trio被展开为两个实参，第一个是string类型，第二个是[number, boolean]类型。
function logTrio(name: string, value: [number, boolean]) {  console.log(`${name}has ${value[0]}(${value[1]}`); }  const trios: [string, [number, boolean]][] = [  [&amp;#34;Amanitore&amp;#34;, [1, true]],  [&amp;#34;Æthelflæd&amp;#34;, [2, false]],  [&amp;#34;Ann E. Dunwoody&amp;#34;, [3, false]]];  // 下面方式不会出现编译错误 trios.forEach(trio =&amp;gt; logTrio(...trio)); // Ok 但是，使用trios.forEach(logTrio)是不可行的，因为它试图将整个[string, [number, boolean]]作为参数传递，但函数logTrio的第一个参数类型要求是string，所以会出现类型不匹配的错误：
// 下面会出现编译错误 trios.forEach(logTrio); // Argument of type &amp;#39;(name: string, value: [number, boolean]) =&amp;gt; void&amp;#39; is not assignable to parameter of type &amp;#39;(value: [string, [number, boolean]], index: number, array: [string, [number, boolean]][]) =&amp;gt; void&amp;#39;. // Types of parameters &amp;#39;name&amp;#39; and &amp;#39;value&amp;#39; are incompatible. // Type &amp;#39;[string, [number, boolean]]&amp;#39; is not assignable to type &amp;#39;string&amp;#39;. Tuple Inferences 编译器通常将创建的数组字面量视为长度可变的数组，而不是元组。若一个数组字面量被用作变量的初始值或函数的返回值，那么编译器将推断它是一个可变长度的数组，而不是一个固定长度的元组。
// 使用[]包围的里面的值是非字面量的，编译器默认推断为数组，而不是元组 function firstCharAndSize(input: string) {  // 推断为数组类型, (string | number)[]  return [input[0], input.length]; }  // 这里和对数组字面量的解构有很大区别！！！ // firstChar的类型为 string | number // size的类型也为string | number const [firstChar, size] = firstCharAndSize(&amp;#34;Gudit&amp;#34;);  // 使用[]包围的字面量赋值有些区别，year推断为number类型，warrior推断为string类型 let [year, warrior] = Math.random() &amp;gt; 0.5 ? [340, &amp;#34;Archidamia&amp;#34;] : [1828, &amp;#34;Rani of Jhansi&amp;#34;]; Explicit tuple types 元组可能会被用于类型标注，例如函数的返回值类型标注。如果一个函数的返回类型声明为元组类型，并且在函数里返回一个数组字面量，则这个数组字面量会被推断为元组而不是可变数组。
function firstCharAndSizeExplicit(input: string): [string, number] {  // 在函数里面返回字面量，但因为函数显式声明了返回类型为元组  // 所以字面量被推断为元组，而不是可变长度数组  return [input[0], input.length]; }  // firstChar的类型: string // size的类型: number const [firstChar, size] = firstCharAndSizeExplicit(&amp;#34;Cathay Williams&amp;#34;); Const asserted tuples 显式标注元组类型比较麻烦，TypeScript提供被称为const断言的as const操作符，该操作符放在值的后面。const断言告诉编译器在推断该值类型时，应当使用该值最直白的只读形式。
如果将const断言放在数组字面量之后，表示数组字面量应被视为元组，并且元组类型被推断为字面量，即不可以被修改的（read only）。下面示例代码中，因为readonlyTuple[0]也是readonly的，所以不能再被赋值：
// Type: (string | number)[] const unionArray = [1157, &amp;#34;Tomoe&amp;#34;]  // 只读元组 // Type: readonly [1157, &amp;#34;Tomoe&amp;#34;] const readonlyTuple = [1157, &amp;#34;Tomoe&amp;#34;] as const  // Cannot assign to &amp;#39;0&amp;#39; because it is a read-only property. readonlyTuple[0] = 12  // 使用变量接收只读元组，编译器推断变量的类型是只读的元组：readonly [1157, &amp;#34;Tomoe&amp;#34;] let readonlyTuple = [1157, &amp;#34;Tomoe&amp;#34;] as const; // 使用let声明，整体是可以重新赋值的，即能指向新的地方 readonlyTuple = [1157, &amp;#34;Tomoe&amp;#34;] console.log(readonlyTuple, readonlyTuple[0], readonlyTuple[1])  // readonlyTuple的类型是readOnly的[1157, &amp;#34;Tomoe&amp;#34;]， // 即使指向了新的元组，修改元组中的元素依然会编译错误，因为其属性仍然是不可修改的 // Cannot assign to &amp;#39;0&amp;#39; because it is a read-only property // 从编译错误信息来看，即使使用索引访问数组，但其也是属性！！！ readonlyTuple[0] = 12 请注意，const断言不仅将数组字面量转换为固定大小的元组，还向编译器表明，元组是只读的，不能在希望允许修改值的地方使用。
下面代码中，pairMutable中的元素是允许被修改的，因为它是普通的元组类型。但是，断言as const使得常量pairConst中的成员也不允许被修改：
const pairMutable: [number, string] = [1157, &amp;#34;Tomoe&amp;#34;]; pairMutable[0] = 1247; // Ok  // 下面赋值是可以的，但pairAlsoMutable不能整体被赋值 const pairAlsoMutable: [number, string] = [1157, &amp;#34;Tomoe&amp;#34;] as const; // 直接改变元组中的值是允许的！！！ // 因为pairAlsoMutable声明时只表明指向是不可修改的，但其中的元素依然是可以被修改的 pairAlsoMutable[0] = 1233  // pariConst的类型相当于字面量的[1157,&amp;#34;Tomoe&amp;#34;] const pairConst = [1157, &amp;#34;Tomoe&amp;#34;] as const;  // 直接改变元组中的值是不允许的 // Cannot assign to &amp;#39;0&amp;#39; because it is a read-only property pairConst[0] = 1247; 在实践中，只读元组作为函数返回值很方便。因为函数中返回的元组值通常会立即解构，所以只读元组不会妨碍函数的使用。下面示例代码中，使用let解构as const断言后的元组，可以修改解构后的变量的值，这一点与只读元组变量有很大区别，因为firstChar是否能赋值是由使用const还是let声明解构决定的：
function firstCharAndSizeAsConst(input: string) {  return [input[0], input.length] as const; }  // 函数返回的元组立即被解构 // firstChar的类型是string，size的类型是number const [firstChar, size] = firstCharAndSizeAsConst(&amp;#34;Ching Shih&amp;#34;); console.log(firstChar, size)  // 出现编译错误:Cannot assign to &amp;#39;firstChar&amp;#39; because it is a constant. firstChar = &amp;#39;chear&amp;#39;  // 函数返回的元组立即被解构 let [firstChar1, size1] = firstCharAndSizeAsConst(&amp;#34;Ching Shih&amp;#34;); console.log(firstChar1, size1)  // 不会出现编译错误，因为是使用let定义的解构 firstChar1 = &amp;#39;chear&amp;#39; Interfaces  接口是声明具有相关名称对象的另一种方法。接口在许多方面与别名对象类型相似，但由于其错误信息更易读、编译器性能更快以及与类的互操作性更好，通常更受青睐。编译器对接口的可赋值性检查和错误信息的展示与对象类型大致相同。
 Type Aliases Versus Interfaces 下面是定义类型别名描述对象的语法，属性之间既可以使用;也可以使用逗号,还可以使用换行符来分隔：
type Poet = {  born: number;  name: string; }; 下面是使用interface声明的等效语法，如同使用type定义对象别名类型一样，既可以使用分号，也可以逗号或换行符来分隔属性：
// 可以在定义后面添加分号 interface Poet {  born: number;  name: string; }  // 定义时属性间既可以使用分号也可以使用逗号 interface Poet {  born: number,  name: string, }  // 也可以使用换行符区分属性 interface Poet {  born: number  name: string } 上面三种语法基本一致。喜欢使用分号的开发人员通常会将分号放在类型别名定义的右大括号之后，而接口定义之后的右大括号通常不加分号。这种偏好反映了使用;声明变量，不使用;声明类或函数。尽管接口和类型别名相似，但类型别名type和interface有一些关键区别：
 interface可以merge在一起增强，这一特性在使用第三方代码时尤其有用。 接口可以用来对class的结构进行类型检查，而类型别名则不能。 对于类型检查程序来说，接口的工作速度通常更快。因为它们声明了一个named类型，可以更容易在内部缓存，而不是像类型别名那样动态复制粘贴一个新的对象字面量。 因为接口被认为是named的对象，不是unnamed对象字面量的别名，所以它们的错误信息在某些情况下更具可读性。  Types of Properties Optional Properties 与对象类型一样，接口中的属性不一定都是对象的必需属性。可以在接口定义时，在属性类型标注的:前加上?以表示该属性是可选的。
interface Book {  author?: string;  pages: number; };  const ok: Book = {  author: &amp;#34;Rita Dove&amp;#34;,  pages: 80, };  const missing: Book = {  pages: 80 }; 和对象类型以及别名类型定义类似，若接口中属性值的类型是包含了undefined的联合类型，如果在初始化的时候没有为该属性提供初始值，也会出现编译错误：
interface Book {  author?: string;  pages: number | undefined; };  const book: Book = {  author: &amp;#34;Jose&amp;#34;, }  // 编译错误 Property &amp;#39;pages&amp;#39; is missing in type &amp;#39;{ author: string; }&amp;#39; but required in type &amp;#39;Book&amp;#39;. Read-Only Properties 有时，希望禁止重新赋值接口的某个属性值。允许在接口属性名称前添加一个readonly修饰符，表示该属性一旦设置，就不能再被修改。也就是说readonly属性可以正常读取，但不能被重新赋值。
interface Page {  readonly text: string; }  function read(page: Page) {  // Ok: reading the text property doesn&amp;#39;t attempt to modify it  console.log(page.text);  // 出现编译错误：Cannot assign to &amp;#39;text&amp;#39; because it is a read-only property.  page.text &#43;= &amp;#34;!&amp;#34;; } 需要注意的是，修饰符readonly只存在于类型系统，编译成JavaScript后，该修饰符会被删除。属性添加readonly修饰符后，依靠的是类型检查器，只能防止在开发过程中属性被修改，不能防止在运行过程中被修改。
Functions and Methods 在JavaScript中对象成员为函数比较常见。因此，允许将interface的成员声明为函数类型。TypeScript提供了两种将接口成员声明为函数的方法：
 方法语法：声明接口成员是一个打算作为对象成员调用的函数，如member(): void。 属性语法：声明接口成员等同于独立函数，如member: () =&amp;gt; void。  下面接口HasBothFunctionTypes中声明的method和property都是函数，可以不带实参调用，并返回一个字符串：
interface HasBothFunctionTypes {  method(): string; // 方法语法，类似使用function声明函数（去掉关键字function）  property: () =&amp;gt; string; // 属性语法，箭头函数声明方式 }  const hasBoth: HasBothFunctionTypes = {  property: () =&amp;gt; &amp;#34;&amp;#34;,  method() {  return &amp;#34;&amp;#34;;  } };  hasBoth.property(); hasBoth.method() 上面两种方式声明的函数都支持可选修饰器?，表明它们对于当前定义的接口来说不是必需的成员：
interface OptionalFunctions {  optionalProperty?: () =&amp;gt; string;  optionalMethod?(): string; }  const t1: OptionalFunctions = {}  const t2: OptionalFunctions = {  optionalProperty:() =&amp;gt; {  return &amp;#34;&amp;#34;  },  optionalMethod(): string {  return &amp;#34;&amp;#34;  } } 方法和属性声明多数情况下可以互换，它们之间的主要区别如下：
 方法不能声明为readonly，但属性可以。 同名接口合并时，认为方法和属性是不同的（需要特别注意）。  TypeScript的未来版本可能会添加某些选项，对方法和属性函数之间的差异进行更严格地区分。目前，推荐按照如下原则：
 如果知道底层函数可能会引用this，建议使用方法method。 其它情况则建议使用属性。  Call Signatures 接口和对象类型均可以声明call signatures，调用签名是类型系统对值如何像函数一样被调用的描述。只有按照call signatures声明的方式调用的值才可以赋值给interface，即具有可赋值参数和返回类型的函数。
声明call signatures看起来和声明函数类型相似，可以理解为使用function声明函数时去掉function和函数名。下面代码中，变量typedFunctionAlias和typedCallSignature的类型描述了相同的函数参数和返回类型：
interface CallSignature {  // 调用签名，相当于接口中函数语法去掉函数名  (input: string): number; }  type FunctionAlias = (input: string) =&amp;gt; number; const typedFunctionAlias: FunctionAlias = (input) =&amp;gt; input.length; // Ok  const typedCallSignature: CallSignature = (input) =&amp;gt; input.length; // Ok 此外，call signatures可用于描述附加了一些自定义属性的函数。编译器会识别添加到函数声明中的属性，并将其添加到函数声明的类型中。
interface FunctionWithCount {  count: number;  (): void; }  let hasCallCount: FunctionWithCount; function keepsTrackOfCalls() {  keepsTrackOfCalls.count &#43;= 1;  console.log(`I&amp;#39;ve been called ${keepsTrackOfCalls.count}times!`); } keepsTrackOfCalls.count = 0; hasCallCount = keepsTrackOfCalls; // Ok  hasCallCount()  function doesNotHaveCount() {  console.log(&amp;#34;No idea!&amp;#34;); }  // 编译错误:Property &amp;#39;count&amp;#39; is missing in type &amp;#39;() =&amp;gt; void&amp;#39; but required in type &amp;#39;FunctionWithCount&amp;#39;. hasCallCount = doesNotHaveCount; Index Signatures 有些JavaScript项目创建的对象可以使用任意字符串key存储值。对于这种「容器」对象来说，为接口的每一个可能的key声明一个属性是不切实际的。
TypeScript提供了一种称为index signature的语法，允许接口接收任意的key，并返回该key对应值的类型。常见的是string类型的key，这是因为JavaScript对象查找属性时会将key隐式地转换为字符串。索引签名看起来像普通的属性定义，只是在键后面加上了类型，并用数组中括号将其括起来：
interface WordCounts {  [i: string]: number; }  const counts: WordCounts = {}; counts.apple = 0; // Ok counts.banana = 1; // Ok // 编译错误：Type &amp;#39;boolean&amp;#39; is not assignable to type &amp;#39;number&amp;#39;. counts.cherry = false; 虽然索引签名便于将值赋值给对象，但并非完全类型安全。因为索引签名表示，无论访问的是什么属性，对象都应该返回一个值，这一点和数组的索引相似。
interface DatesByName {  [i: string]: Date; }  const publishDates: DatesByName = {  Frankenstein: new Date(&amp;#34;1 January 1818&amp;#34;), };  // webStrom中没有提示 console.log(publishDates.Frankenstein) // Type: Date console.log(publishDates.Frankenstein.toString()); console.log(publishDates.Beloved) // undefined // 运行时错误：Cannot read properties of undefined (reading &amp;#39;toString&amp;#39;) console.log(publishDates.Beloved.toString()) 如果要存储键值对，并且无法提前知道键的值，通常使用Map更安全。Map的get方法总是返回带有| undefined的类型，表示键可能不存在。
Mixing properties and index signatures 接口可以包含显式命名属性和catchall string索引签名。但有一个限制：每个显式命名属性的类型必须可以赋值给其catchall索引签名的类型。可以认为将它们混合在一起就是告诉TypeScript，命名的属性会给出一个更具体的类型，而其它属性都会返回索引签名的类型。
interface HistoricalNovels {  // 类型不一致，出现编译错误  // Property &amp;#39;Oroonoko&amp;#39; of type &amp;#39;string&amp;#39; is not assignable to &amp;#39;string&amp;#39; index type &amp;#39;number&amp;#39;.  Oroonoko: string;  [i: string]: number; }   interface HistoricalNovels {  Oroonoko: number;  [i: string]: number; }  const novels: HistoricalNovels = {  Outlander: 2001,  Oroonoko: 1688, };  // 编译错误：Property &amp;#39;Oroonoko&amp;#39; is missing in type &amp;#39;{ Outlander: number; }&amp;#39; but required in type &amp;#39;HistoricalNovels&amp;#39; const missingOroonoko: HistoricalNovels = {  Outlander: 2003, }; 使用属性和索引签名的混合的一个常用技巧是为命名属性使用比索引签名的基本类型更具体的字面量类型。只要命名属性的类型可以分配给索引签名的类型&amp;ndash;这对于字面类型和基本类型都是正确。
interface ChapterStarts {  preface: 0;  [i: string]: number; }  const correctPreface: ChapterStarts = {  preface: 0,  night: 1,  shopping: 5 }; Numeric index signatures 仅管在JavaScript将对象属性查找键隐式地转换为字符串，但有时只允许将数字作为对象的键也是可取的。索引签名可以使用数字类型代替字符串，但与命名属性一样，它的类型必须可以赋值给catchall字符串索引签名。
interface MoreNarrowNumbers {  [i: number]: string;  [i: string]: string | undefined; }  const mixesNumbersAndStrings: MoreNarrowNumbers = {  0: &amp;#39;&amp;#39;,  key1: &amp;#39;&amp;#39;,  key2: undefined, }  // 下面会出现编译错误，因为数值索引的值类型不能赋值给字符串索引值的类型 // 因为数值键对应的值类型多了一个undefined类型 interface MoreNarrowStrings {  [i: number]: string | undefined;  // Error: &amp;#39;number&amp;#39; index type &amp;#39;string | undefined&amp;#39; // is not assignable to &amp;#39;string&amp;#39; index type &amp;#39;string&amp;#39;.  [i: string]: string; } Nested Interfaces 如同对象类型可以嵌套其它对象类型作为属性值的类型一样，接口类型也可以拥有本身就是接口类型（或对象类型）的属性。下面定义的接口Novel，它的属性setting的值类型是Setting就是接口：
interface Novel {  author: { name: string; };  setting: Setting; }  interface Setting {  place: string;  year: number; }  let myNovel: Novel; // Ok myNovel = {  author: {  name: &amp;#39;Jane Austen&amp;#39;,  },  setting: {  place: &amp;#39;England&amp;#39;,  year: 1812,  } }; Interface Extensions 有时，可能会有多个看起来相似的interface。一个interface可能包含另一个interface的所有成员，只是增加了一些额外的成员。TypeScript允许一个接口extend另一个接口，即声明它复制了另一个接口的所有成员。
可以在接口名后添加extends关键字和待扩展的接口名，以标记当前接口扩展了另一个接口。下面示例代码中，接口Novella扩展了接口Writing，因此要求对象至少同时拥有Novella的pages和Writing的title成员：
interface Writing {  title: string; }  interface Novella extends Writing {  pages: number; }  let myNovella: Novella = {  pages: 195,  title: &amp;#34;Ethan Frome&amp;#34;, };  // 编译错误：Property &amp;#39;pages&amp;#39; is missing in type &amp;#39;{ title: string; }&amp;#39; but required in type &amp;#39;Novella&amp;#39;. let missingPages: Novella = {  title: &amp;#34;The Awakening&amp;#34;, }  // 编译错误：Object literal may only specify known properties, and &amp;#39;strategy&amp;#39; does not exist in type &amp;#39;Novella&amp;#39;. // 对象字面量会触发多余属性检查 let extraProperty: Novella = {  pages: 300,  strategy: &amp;#34;baseline&amp;#34;,  style: &amp;#34;Naturalism&amp;#34; };  // 使用变量暂存对象字面量规避多余属性检查 let extraProperty1 = {  pages: 300,  strategy: &amp;#34;baseline&amp;#34;,  style: &amp;#34;Naturalism&amp;#34;,  title: &amp;#34;test&amp;#34; };  // 这样赋值不会出现编译错误 myNovella = extraProperty1 Overridden Properties 派生接口可以通过再次声明类型不同但同名的属性来覆盖或替换其基础接口的属性。类型检查器会强制要求覆盖的属性必须可赋值给其基接口对应的属性，也就是说override属性的类型范围只能缩小不能扩大。目的是确保派生接口类型的实例始终可赋值给基接口类型的变量。
实际上，大多数派生接口在重新声明属性时，是为了使得这些属性成为一个联合类型的更具体的子类型，也可能是为了使属性的类型成为一个从基接口类型扩展而来的类型。
interface WithNullableName {  name: string | null; }  interface WithNonNullableName extends WithNullableName {  // 类型更具体，是正确的  name: string; }  // 编译错误，子接口对应属性的类型没有窄化 // Interface &amp;#39;WithNumericName&amp;#39; incorrectly extends interface &amp;#39;WithNullableName&amp;#39;. interface WithNumericName extends WithNullableName {  name: number | string; } Extending Multiple Interfaces TypeScript中的接口定义时可以声明为扩展多个其它接口。即派生接口的extends关键字之后，存在多个用逗号分隔的接口名，派生接口将接收所有基础接口的所有成员。
interface GivesNumber {  giveNumber(): number; }  interface GivesString {  giveString(): string; }  interface GivesBothAndEither extends GivesNumber, GivesString {  giveEither(): number | string; }  function useGivesBoth(instance: GivesBothAndEither) {  instance.giveEither(); // Type: number | string  instance.giveNumber(); // Type: number  instance.giveString(); // Type: string } 将一个接口标注为扩展多个其它接口，既可以减少代码重复，又可以使对象更容易跨越不同的代码区域重复使用。
Interface Merging 接口的一个重要特性是可以合并。接口合并意味着，如果在同一作用域中声明了两个名称相同的接口，它们就会合并成一个更大的接口，合并后的接口包含同名接口所有声明的字段。
interface Merged {  fromFirst: string; }  interface Merged {  fromSecond: number; } 接口merge在日常开发中并不经常使用，建议尽量避免使用该功能。因为，如果在多个地方声明同一个接口，会使得代码比较难理解和混乱。
但是，接口合并对于增强来自外部包或内置的全局接口（如Window）特别有用。例如，当使用默认的编译器选项时，在一个文件中声明带有myEnvironmentVariable属性的Window接口，就可以使用window.myEnvironmentVariable：
interface Window {  myEnvironmentVariable: string; }  window.myEnvironmentVariable; Member Naming Conflicts 请注意，合并后的接口不能以不同类型多次声明同名的属性。如果一个接口中已经声明了一个属性，那么以后合并的接口中必须使用相同的类型。但是，合并后的接口可以定义一个名称相同但签名不同的方法，这样做会为该方法创建一个重载。
interface MergedMethods {  // 名称相同的方法  different(input: string): string; }  interface MergedMethods {  // 名称相同的方法，但签名不同  different(input: number): string; // Ok }  // 因为属性的类型相同，下面代码不会出现编译错误 interface Page {  readonly text: string }  function read1(page: Page) {  console.log(page.text); }  interface Page {  readonly text: string }  function read2(page: Page) {  console.log(page.text); } Classes Class Methods TypeScript对类中方法的理解与对独立函数的理解相同。除非显式地标注类型或给出默认值，否则方法形参的类型被推断为any。若编译选项设置的是严格模式，形参不允许省略类型标注。
调用类中方法时需要给出正确的实参数量和正确的类型，否则会出现编译错误。如果函数不是递归的，返回类型通常可以被编译器推断出来。
class Greeter {  greet(name: string) {  console.log(`${name}, do your stuff!`);  } }  new Greeter().greet(&amp;#34;Miss Frizzle&amp;#34;) // Miss Frizzle, do your stuff! 类构造函数的形参与其它方法相同。编译器会执行类型检查，以确保调用构造方法时提供了数量正确、类型正确的实参。
class Greeted {  constructor(message: string) {  console.log(`As I always say: ${message}!`);  } }  new Greeted(&amp;#34;take chances, make mistakes, get messy&amp;#34;); // 执行结果 As I always say: take chances, make mistakes, get messy! Class Properties 在TypeScript中，若要读取或写入类的属性，必须在类中明确声明。类属性声明语法与接口相同，名称后跟一个类型标注。不同于JavaScrpit，TypeScript不会试图通过构造函数中的赋值来推断类中可能存在的成员，也就是说类中的属性均必须事先声明才能使用：
class FieldTrip {  destination: string;   constructor(destination: string) {  this.destination = destination; // Ok  console.log(`We&amp;#39;re going to ${this.destination}!`);  // 编译错误：Property &amp;#39;nonexistent&amp;#39; does not exist on type &amp;#39;FieldTrip&amp;#39;.  this.nonexistent = destination;  }  } 显式地声明类的属性可以让TypeScript快速地了解类的实例中哪些属性是存在的，哪些是不存在的。与JavaScript不同，若访问类中不存在的属性，会出现编译错误。
class FieldTrip {  destination: string;   constructor(destination: string) {  this.destination = destination; // Ok  console.log(`We&amp;#39;re going to ${this.destination}!`);  } }  const trip = new FieldTrip(&amp;#34;planetarium&amp;#34;) // 访问存在的属性，没有问题 console.log(trip.destination) // 访问未声明的属性会出现编译错误 // Property &amp;#39;nonexistent&amp;#39; does not exist on type &amp;#39;FieldTrip&amp;#39;. console.log(trip.nonexistent) Function Properties 下面WithMethod类定义了一个myMethod方法，所有WithMethod的实例都可以引用该方法。这种方式定义的方法，不会为每个类的实例创建一个副本：
class WithMethod {  myMethod() {  //  } }  console.log(new WithMethod().myMethod === new WithMethod().myMethod)  // 执行结果 true 若在类中，使用函数形式定义的方法属性不能先声明，然后再在构造方法中赋予初值。下面示例代码中，因为method没有在声明的时候给出实现，会出现编译错误：
class TestClass {  // Function implementation is missing or not immediately following the declaration.  method(): string  constructor() {  this.method = () =&amp;gt; {  return &amp;#34;method&amp;#34;  }  } } 另一种定义方法的语法是声明一个属性，其值恰好是一个函数。这种方式将会为类的每个实例创建一个新函数，这对于箭头函数可能很有用，因为箭头函数的this作用域应始终指向类的当前实例。
下面WithProperty类定义了属性myProperty，它的类型为() =&amp;gt; void。每个类的实例都会创建一个新副本，两个不同实例比较该属性时总是返回false：
class WithProperty {  myProperty: () =&amp;gt; void  constructor() {  this.myProperty = () =&amp;gt; {  // ...  }  } }  console.log(new WithProperty().myProperty === new WithProperty().myProperty)  // 执行结果 false 属性函数的形参和返回值类型与独立函数相同:
class WithPropertyParameters {  takesParameters = (input: boolean) =&amp;gt; input ? &amp;#34;Yes&amp;#34; : &amp;#34;No&amp;#34;; }  const instance = new WithPropertyParameters(); console.log(instance.takesParameters(true))  // 执行结果 Yes Initialization Checking 如果启用了严格的编译器设置，编译器将检查所声明的每个属性（属性值类型不包括undefined的属性）是否在构造函数中赋值。
这种严格初始化检查非常有用，可以防止因意外忘记为相关属性赋值。下面定义的类WithValue，在构造函数中因没有为属性unused赋初始值，会出现编译错误：
class WithValue {  immediate = 0; // Ok  later: number; // Ok (set in the constructor)  // 类中的属性值的类型包含了undefined与对象类型和接口类型不同  mayBeUndefined: number | undefined; // Ok (allowed to be undefined)，这与Object有区别  unused: number;   constructor() {  this.later = 1;  } }  // 编译错误: Property &amp;#39;unused&amp;#39; has no initializer and is not definitely assigned in the constructor. 对于**类中属性的值类型包含了undefined类型来说，与对象类型以及接口类型有很大区别，在构造函数中可以初始化该属性，也可以不初始化**。若没有严格的初始化检查，类实例可能会被允许访问一个可能为undefined的值，即使类型系统规定不能这样做。
Definitely assigned properties 尽管严格的初始检查在多数情况下很有用。但在某些情况下，可能会遇到故意在类构造函数之后取消检查类的某个属性的情况。如果绝对确定某个属性不需要应用严格初始化检查，可以在其名称后添加一个!来禁用属性检查。这样做可以向编译器申明，该属性将在首次使用前一定会被赋值，不会是undefined。
class ActivitiesQueue {  pending!: string[]; // Ok   initialize(pending: string[]) {  this.pending = pending;  }   next() {  return this.pending.pop();  } }  const activities = new ActivitiesQueue(); activities.initialize([&amp;#39;eat&amp;#39;, &amp;#39;sleep&amp;#39;, &amp;#39;learn&amp;#39;]) activities.next(); Optional Properties 和接口相似，类也可以声明可选属性。可选属性与属性值类型为包含| undefined的联合类型大致相同。如果没有在构造函数中明确设置可选属性的初始值，严格的初始化检查也不会在意。下面定义的OptionalProperty类中，它的property属性是可选的。因此，无论是否有严格的属性初始化检查，都允许在类的构造函数中不赋值可选属性：
class MissingInitializer {  property?: string; }  // 正确的使用方式 console.log(new MissingInitializer().property?.length)  // 错误的使用方式，会出现编译错误：Object is possibly &amp;#39;undefined&amp;#39; console.log(new MissingInitializer().property.length) Read-Only Properties 与接口类型，类定义时也可以在属性前面添加readonly关键词。关键词readonly仅存在于类型系统，当编译为JavaScript文件后，关键字readonly会被移除。
需要注意的是，声明为只读的属性只能在声明处或构造函数中赋初始值。任何其它位置（包括类本身的其它方法）只能读取属性，不能修改属性（修改属性时会出现编译错误）。
class Quote {  // 只读属性只能在声明处或构造函数中赋初始值  readonly text: string;   constructor(text: string) {  this.text = text;  }   emphasize() {  // 编译错误: Cannot assign to &amp;#39;text&amp;#39; because it is a read-only property.  // 已经在构造函数中设置了初始值，所以不能再赋值  this.text &#43;= &amp;#34;!&amp;#34;;  } }  let quote = new Quote(&amp;#34;this is a test&amp;#34;); console.log(quote.text)  // 只读属性不能重新被赋值 quote.text = &amp;#34;Hello world&amp;#34;; 类中定义的**非字面量类型的只读属性**，即使在声明的时候也初始化了，在构造函数中还可以再初始化一次，不会出现编译错误：
class Quote {  readonly text: string = &amp;#34;123&amp;#34;  constructor(text?: string) {  if (text) {  this.text = text  }  } } const quote1 = new Quote(&amp;#34;quote&amp;#34;) const quote2 = new Quote() console.log(quote1.text) console.log(quote2.text)  // 执行结果 quote 123 与其它属性相比，声明为只读且同时初始化为基础类型字面量的属性有一个特性：它们会被推断为其值的字面量类型，而不是对应基本类型，这样的属性在类构造函数中也不能重新赋值（真正意义的只能赋值一次），这与const断言相似。
TypeScript对于这种激进的字面量初始类型窄化感觉良好，因为知道其值以后不会改变。类似于使用const断言定义变量会比let变量使用更窄的类型。下面代码中，在构造函数中变量explicit可以再次被赋值（在其它函数中不能赋值），但implicit不能再次被赋值。
class RandomQuote {  // 显式声明为string类型，在初始化器中可以被修改  readonly explicit: string = &amp;#34;Home is the nicest word there is.&amp;#34;;  // 推断为字面量类型，一旦赋值就不可修改  readonly implicit = &amp;#34;Home is the nicest word there is.&amp;#34;;   constructor() {  if (Math.random() &amp;gt; 0.5) {  // 非字面量类型，在初始化器中可以赋值  this.explicit = &amp;#34;We start learning the minute we&amp;#39;re born.&amp;#34;  // 没有显式标注类型，并使用字面量进行初始化  // 即使在构造函数中重新赋值也会出现编译错误，因为已经初始化一次了  this.implicit = &amp;#34;We start learning the minute we&amp;#39;re born.&amp;#34;  }  } }  // 编译错误 Type &amp;#39;&amp;#34;We start learning the minute we&amp;#39;re born.&amp;#34;&amp;#39; is not assignable to type &amp;#39;&amp;#34;Home is the nicest word there is.&amp;#34;&amp;#39;. Classes as Types 类在类型系统中相对独特，因为类声明既创建了运行时值（类本身），也创建了可用于类型标注的类型。下面示例代码中，类Teacher用于标注变量teacher，以告诉编译器它应该只能被那些能够赋值给Teacher类的值（例如Teacher类的实例）：
class Teacher {  sayHello() {  console.log(&amp;#34;Take chances, make mistakes, get messy!&amp;#34;);  } }  let teacher: Teacher; teacher = new Teacher() teacher.sayHello()  // 编译错误：Type &amp;#39;string&amp;#39; is not assignable to type &amp;#39;Teacher&amp;#39;. tearcher = &amp;#34;Wahoo!&amp;#34; 有趣的是，TypeScript会将任何恰好包含当前类中所有相同成员的对象类型视为可赋值给当前类。这是因为TypeScript是structural typing的，因此只关心对象的形状，而不关心它们是如何声明的。
class SchoolBus {  getAbilities() {  return [&amp;#34;magic&amp;#34;, &amp;#34;shapeshifting&amp;#34;];  } }  function withSchoolBus(bus: SchoolBus) {  console.log(bus.getAbilities()); }  withSchoolBus(new SchoolBus());  // 下面这种调用方式是可以的 // 因为类也是structural typing的 withSchoolBus({  getAbilities: () =&amp;gt; [&amp;#34;transmogrification&amp;#34;] }) Classes and Interfaces TypeScript允许在定义类时在类名后添加implements关键字和接口名称，从而声明当前类遵循某个interface。这样声明是告诉编译器，类的实例可以赋值给这些接口中的任何一个。
interface Learner {  name: string;  study(hours: number): void; }  class Student implements Learner {  name: string;  constructor(name: string) {  this.name = name;  }   study(hours: number) {  for (let i = 0; i &amp;lt; hours; i &#43;= 1) {  console.log(&amp;#34;...studying...&amp;#34;);  }  } }  let leaner: Learner = new Student(&amp;#34;Hui&amp;#34;) leaner.study(2)  // 执行结果 ...studying... ...studying... 将一个类标记为实现了某个接口并不会改变该类的使用方式。如果该类与某个接口相匹配，TypeScript的类型检查器允许在需要该接口实例的地方使用该类的实例。
Implementing Multiple Interfaces 在TypeScript中一个类可以实现任意多个接口，接口名之间用逗号隔开。下面示例代码中，类在实现接口Graded时必需具有grades属性，在实现接口Reporter时必需有report属性（一个箭头函数）。
interface Graded {  grades: number[]; }  interface Reporter {  report: () =&amp;gt; string; }  // 下面类ReportCard是正常的，因为实现了grades和report class ReportCard implements Graded, Reporter {  grades: number[];   constructor(grades: number[]) {  this.grades = grades;  }   report() {  return this.grades.join(&amp;#34;, &amp;#34;);  } }  // 下面会出现编译错误，因为Empty没有真正实现接口 // 如果实现了接口，需要把所有属性和接口都生成一遍 class Empty implements Graded, Reporter {  // 没有任何实现 } Extending a Class TypeScript将类型检查也添加到了JavaScript的类扩展（或子类）概念中。首先，基类中声明的任何非私有方法或属性都可以在子类（也称为派生类）中使用。
class Teacher {  teach() {  console.log(&amp;#34;The surest test of discipline is its absence.&amp;#34;)  } }  class StudentTeacher extends Teacher {  learn() {  console.log(&amp;#34;I cannot afford the luxury of a closed mind.&amp;#34;)  } }  const teacher = new StudentTeacher(); teacher.teach(); // Ok (defined on base) teacher.learn(); // Ok (defined on subclass)  // 出现编译错误：Property &amp;#39;other&amp;#39; does not exist on type &amp;#39;StudentTeacher&amp;#39;. teacher.other(); Extension Assignability 子类从父类中继承成员如同子接口扩展父接口，子类的实例拥有父类的所有成员，因此可以在需要父类实例的地方使用。如果父类不具备子类的所有成员，那么当需要更具体的子类时，就无法使用它。
class Lesson {  subject: string  constructor(subject: string) {  this.subject = subject  } }  class OnlineLesson extends Lesson {  url: string  constructor(subject: string, url: string) {  super(subject)  this.url = url  } }  let lesson: Lesson lesson = new Lesson(&amp;#34;coding&amp;#34;) // Ok lesson = new OnlineLesson(&amp;#34;coding&amp;#34;, &amp;#34;oreilly.com&amp;#34;) // Ok let online: OnlineLesson online = new OnlineLesson(&amp;#34;coding&amp;#34;, &amp;#34;oreilly.com&amp;#34;) // Ok  // 出现编译错误 // Property &amp;#39;url&amp;#39; is missing in type &amp;#39;Lesson&amp;#39; but required in type &amp;#39;OnlineLesson&amp;#39;. // 因为是结构类型，父类中缺少子类中的成员url online = new Lesson(&amp;#34;coding&amp;#34;) 根据结构类型的特点，如果子类上的所有成员都已经存在父类中（例如子类自定义属性均是可选的），那么允许使用父类的实例来代替子类。下面示例代码中，因为子类自定义属性都是可选类型，所以赋值是允许的：
class PastGrades {  grades: number[] = [] }  class LabeledPastGrades extends PastGrades {  label?: string }  let subClass: LabeledPastGrades subClass = new LabeledPastGrades() // Ok // 因为子类扩展父类时，其自定义属性时可选的， // 所以父类相当于拥有子类的所有属性 subClass = new PastGrades() // Ok Overridden Constructors 与JavaScript一样，TypeScript并**不要求子类必须定义自己的构造函数。没有自定义构造函数的子类会隐式地使用父类的构造函数。在JavaScript中，子类若声明了自己的构造函数，必须先通过super关键字调用父类的构造函数** 。
子类构造函数可以声明任何形参，而无需考虑父类构造函数对形参的要求。因为TypeScript的类型检查器会确保调用父类构造函数时使用了正确的参数。
class GradeAnnouncer {  message: string;  constructor(grade: number) {  this.message = grade &amp;gt;= 65 ? &amp;#34;Maybe next time...&amp;#34; : &amp;#34;You pass!&amp;#34;;  } }  class PassingAnnouncer extends GradeAnnouncer {  constructor() {  // 子类中定义了自己的构造函数，所以必须使用super调用父类的构造函数  super(100);  } } 根据JavaScript的规则，子类的构造器在使用this或super之前必须调用父类的构造器。若在调用父类的构造函数之前使用this或super会出现编译错误：
class GradesTally {  grades: number[] = [];  addGrades(...grades: number[]) {  this.grades.push(...grades)  return this.grades.length  } }  class ContinuedGradesTally extends GradesTally {  constructor(previousGrades: number[]) {  // 在使用this之前需要调用父类的构造函数会出现编译错误  // 出现编译错误:Constructors for derived classes must contain a &amp;#39;super&amp;#39; call.  this.grades = [...previousGrades]  } }  // 下面这样先调用基类的构造函数才不会出现编译错误 class ContinuedGradesTally extends GradesTally {  constructor(previousGrades: number[]) {  super();  // 展开操作符  this.grades = [...previousGrades]  console.log(&amp;#34;Starting with length&amp;#34;, this.grades.length)  } } Overridden Methods  TypeScript有一套基于结构类型的系统，判断类型兼容性时，会比较两个类型的结构。当涉及到函数时，函数参数是逆变的，而返回值是协变的。
 TypeScript中的「协变」和「逆变」是描述父子类型在复杂类型（如函数、数组）中如何传递的规则。可以使用生活中的例子比喻：
 协变：买了一个装苹果的箱子（Apple[]），可以当作装水果的箱子（Fruit[]）用，因为苹果是水果的子类型。 逆变：要求一个能处理所有水果的机器（参数是Fruit），可以替换成只能处理苹果的机器（参数是Apple），但反过来可能不安全。  通俗的理解，协变是子类型可以替代父类型，方向一致，常见场景是函数返回值、数组、对象属性。函数返回值类型是协变的。如果B是A的子类型，则返回值类型为B的函数可以赋值给返回值类型为A的函数变量。换句话说，函数的返回类型关系保持一致。
为什么需要协变？返回值类型的协变是安全的。如果函数返回一个更具体的子类型，它可以安全替代返回更宽泛父类型的函数，因为子类型拥有父类型的所有成员。
下面示例代码中，因为Dog是Animal的子类型，返回Dog的函数可以替代返回Animal的函数。调用函数getAnimal()时，实际得到的是Dog，但使用者只关心父接口Animal的属性和方法，因此是安全的。
interface Animal {  name: string }  interface Dog extends Animal {  bark(): void }  // 协变示例：Dog是Animal的子类型，返回值类型是协变的 let getAnimal: () =&amp;gt; Animal = () =&amp;gt; ({name: &amp;#34;动物&amp;#34;});  let getDog: () =&amp;gt; Dog = () =&amp;gt; ({name: &amp;#34;旺财&amp;#34;, bark: () =&amp;gt; console.log(&amp;#34;汪汪！&amp;#34;)});  // 安全：将返回Dog的函数赋值给返回Animal的函数类型 getAnimal = getDog; // ✅ 允许（协变）  const animal = getAnimal() console.log(animal.name);  // 执行结果 旺财 逆变是指父类型可以替代子类型（方向相反），常见场景是函数参数。如果B是A的子类型，则参数类型为A的函数是参数类型为B的函数的子类型。换句话说，函数参数的子类型关系是反向的。
为什么需要逆变？同样是为了保证类型安全。如果一个函数期望接收一个更宽泛的类型（例如Animal），它可以安全地替换一个需要更具体类型（例如Dog）的函数。
下面示例代码中，当FeedAnimal（参数为父类型）赋值给FeedDog（参数为子类型）时，实际调用feedDog(new Dog())时，函数内部会以Animal类型处理参数。由于Dog具备Animal的所有属性，所以是安全的。反之，在函数中可能访问子类型的独有属性（如bark），导致运行时错误（实际类型是父类型的实例）。
type FeedAnimal = (animal: Animal) =&amp;gt; void; type FeedDog = (dog: Dog) =&amp;gt; void;  // 逆变示例：FeedAnimal是FeedDog 的子类型 var feedAnimal: FeedAnimal = (animal) =&amp;gt; console.log(`喂养 ${animal.name}`);  var feedDog: FeedDog = (dog) =&amp;gt; { dog.bark(); };  // 安全：将父类型函数赋值给子类型变量 // 实际调用是的FeedAnimal类型的实例 feedDog = feedAnimal; // ✅ 允许（逆变）  // 危险：将子类型函数赋值给父类型变量（需要关闭strictFunctionTypes） // feedAnimal = feedDog; // ❌ 默认报错（除非关闭严格模式）  // 下面方式使用会出现编译错误 // feedDog({name: &amp;#34;1233&amp;#34;});  // 这样调用才可以，因为声明时形参是Dog类型 // feeDog指向的feedAnimal，执行的是feeAnimal方法 feedDog({  name: &amp;#34;1233&amp;#34;,  bark: () =&amp;gt; console.log(&amp;#34;汪汪！&amp;#34;) })  // 执行结果，实际调用的是feedAnimal 喂养 1233 子类可以重新声明与父类同名的新方法，只要子类上的方法可以赋值给父类对应的方法即可，即只要满足子类中同名的新方法中的参数类型是父类型，或者返回类型是子类型。
class GradeCounter {  countGrades(grades: string[], letter: string) {  return grades.filter(grade =&amp;gt; grade === letter).length;  } }  class FailureCounter extends GradeCounter {  countGrades(grades: string[]) {  return super.countGrades(grades, &amp;#34;F&amp;#34;);  } }  // 上面声明FailureCounter时不会出现编译错误 // 到下面声明AnyFailureChecker会出现编译错误，因为返回值类型不同 class AnyFailureChecker extends GradeCounter {  countGrades(grades: string[]) {  // 返回类型是bool，不是number  return super.countGrades(grades, &amp;#34;F&amp;#34;) !== 0;  } }  // 编译错误 Property &amp;#39;countGrades&amp;#39; in type &amp;#39;AnyFailureChecker&amp;#39; is not assignable to the same property in base type &amp;#39;GradeCounter&amp;#39;. 因为较少参数的函数类型是可以赋值给多参数的同类型函数。参数少的函数可以赋值给参数多的函数类型（即参数多的兼容参数少的），这是因为：
  调用时的参数冗余不会导致错误，当一个函数（参数少）被赋值给另一个参数更多的函数类型时，实际调用时多余的参数会被忽略。例如，参数多的函数可能接受3个参数，但实际调用的函数（参数少）只用到了前2个，此时不会引发运行时错误。
  适配JavaScript常见模式，在JavaScript中，开发者经常忽略不用的参数（例如回调函数仅使用部分参数），TypeScript需要兼容这种习惯。
  // 基础参数数量兼容 let name11: (x: number, y: number) =&amp;gt; number let name12: (x: number) =&amp;gt; number name11 = (x: number, y: number): number =&amp;gt; {  return x &#43; y } name12 = (x: number) =&amp;gt; {  return x } name11 = name12  // 数组的`forEach`方法 const arr = [&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;]; // 回调函数类型：(value: string, index: number, array: string[]) =&amp;gt; void arr.forEach((value) =&amp;gt; console.log(value)); // ✅ 忽略 index 和 array 参数  // 这里，参数少的回调函数（只接受`value`）可以赋值给参数多的函数类型，因为多余的参数（`index`和`array`）不会被使用 这种设计有助于实现多态，子类减少不必要的参数，往往意味着它简化或者特化了父类的逻辑，这在很多场景下是合理的需求。比如，父类的某个方法为了通用性设计了很多配置相关的参数，子类在特定场景下复用该方法时，一些参数固定不变，所以子类就省略了这些固定不变的参数，让代码更加简洁，同时又能融入基于父类构建的多态调用体系。
Overridden Properties 子类也可能显式地重新声明父类的同名属性，只要子类同名属性的类型可以赋值给父类上的类型即可（类似于协变）。与重载方法一样，子类必须在结构上与父类相匹配。
大多数重新声明属性的子类，要么是为了使这些属性成为联合类型更具体的子类型（通常是联合类型的某个子类型），要么是为了使这些属性成为一种从基类属性类型扩展而来的类型，或添加非继承的其它属性。
class Assignment {  grade?: number; }  class GradedAssignment extends Assignment {  grade: number;  constructor(grade: number) {  super();  this.grade = grade;  } } 假设基类有一个属性，它的类型是Animal，在子类里重新声明这个属性，把该属性的类型改成Dog（假设Dog是从Animal继承或扩展而来的类型，也就是class Dog extends Animal），子类的属性类型就是对基类属性类型的扩展，在保持继承体系的同时，还可以添加子类特有的属性或方法，增强代码的复用性与扩展性。这种方式遵循了面向对象编程中的继承原则，在类型层面强化了类之间的层次关系，同时借助TypeScript的类型系统保障类型一致性。
Abstract Classes 有时，创建的基类本身并不声明某些方法的实现，而是期望子类实现这些方法。将一个类标记为抽象类的方法是在类名前面和任何抽象方法前面添加abstract关键字。这些抽象方法声明跳过了在抽象基类中提供方法体的过程，它们的声明方式与接口相同。
abstract class School {  readonly name: string  constructor(name: string) {  this.name = name  }  abstract getStudentTypes(): string[] }  // 子类Preschool继承了School类 class Preschool extends School {  getStudentTypes() {  return [&amp;#34;preschooler&amp;#34;]  } } 需要注意的是，抽象类不能实例化，非抽象类才能被实例化。
Member Visibility JavaScript可以在类的成员名称前加上#，将其标记为private成员。私有类成员只能被该类的实例访问。若类外的代码试图访问私有方法或属性，JavaScript运行时会抛出错误，以强制执行这种私有性。
TypeScript对类的可见性的支持早于JavaScript，在TypeScript不仅支持#形式的私有类成员，也允许对类方法和属性（仅存在于类型系统中）的隐私性定义进行细微的调整。TypeScript中成员可见性是通过在类成员声明的名称前添加以下关键字来实现的：
 public(默认的)：允许在任何地方使用，这是默认的可见性（若不添加任何关键词默认是该可见性）。 protected: 只允许在类本身或其子类中使用。 private：只允许在类里面使用。  需要注意的是，上面的关键字仅存在于类型系统，当代码编译为JavaScript后，这些关键词就会被移除。下面示例代码中，类Base声明了两个public成员，一个protected成员，一个private成员，一个#表示的私有成员：
class Base {  // 默认是public的访问权限  isPublicImplicit = 0;  public isPublicExplicit = 1;  protected isProtected = 2;  private isPrivate = 3;  #truePrivate = 4; }  class Subclass extends Base {  examples() {  this.isPublicImplicit; // Ok  this.isPublicExplicit; // Ok  this.isProtected; // Ok  // this.isPrivate;  // this.#truePrivate;  } }  new Subclass().isPublicImplicit; // Ok new Subclass().isPublicExplicit; // Ok // 编译错误：Property &amp;#39;isProtected&amp;#39; is protected and only accessible within class &amp;#39;Base&amp;#39; and its subclasses. new Subclass().isProtected; Static Field Modifiers JavaScript允许使用static关键字声明类本身的成员（而非类的实例）。TypeScript支持单独使用static关键字，也支持将它与readonly一起使用，或者和可见性关键字（比如public、private、protected等）中的某一个一起使用。
但需要注意的是，当组合使用这些关键字时，可见性关键字要放在首位，接着是static关键字，最后才是readonly关键字。
class Question {  // &amp;#39;protected&amp;#39; modifier must precede &amp;#39;static&amp;#39; modifier.  // static protected readonly name: string = &amp;#34;Test&amp;#34;;  protected static readonly answer: &amp;#34;bash&amp;#34;;  protected static readonly prompt = &amp;#34;What&amp;#39;s an ogre&amp;#39;s favorite programming language?&amp;#34;;   guess(getAnswer: (prompt: string) =&amp;gt; string) {  const answer = getAnswer(Question.prompt);  if (answer === Question.answer) {  console.log(&amp;#34;You got it!&amp;#34;);  } else {  console.log(&amp;#34;Try again...&amp;#34;)  }  console.log(Question.answer);  } }  let question = new Question() question.guess((prompt: string) =&amp;gt; {  return prompt; })  // 执行结果 Try again... undefined  // 编译错误：保护成员只能在类中或子类中使用 Question.answer;  class Test {  // 不能添加readonly关键字而不初始化  public static answer: &amp;#34;bash&amp;#34;;  static {  // 在静态构造器中初始化静态成员  Test.answer = &amp;#39;bash&amp;#39;;  } }  class Test {  public static readonly answer: &amp;#34;bash&amp;#34;;  static {  // 因为没有初始化，所以执行结果为undefined  console.log(Test.answer);  } } Type Modifiers 现在，已经了解TypeScript类型系统如何与现有JavaScript结构（如数组、类和对象）协同工作，接下来将进一步介绍类型系统本身。
Top Types 在TypeScript中顶层类型或通用类型是一种可以代表类型系统中任何可能值的类型。所有类型的值都可以赋值给顶层类型的变量或常量，但相反时不一定正确，因为顶层类型区分any和unknwon。如果需要完全禁用声明类型，可以使用any，如果需要更谨慎处理，可以使用unknown。
any any类型可以作为顶层类型，表示没有任何限制，该类型的变量可以被赋予任意类型的值。类型any可用于允许接受任何类型的地方，例如作为console.log的参数:
let anyValue: any; anyValue = &amp;#34;Lucille Ball&amp;#34;; // Ok anyValue = 123; // Ok console.log(anyValue); // Ok console.log(typeof anyValue); // number 使用any就是明确告诉编译器不需要执行类型检查。这种类型检查的缺失有时会有用，但有时也会触发异常。下面代码不会出现编译错误，但运行时会报错：
function greetComedian(name: any) {  // 此时无编译错误，但传入不能调用toUpperCase方法的实参时会出现运行时错误  console.log(`Announcing ${name.toUpperCase()}!`); }  // 运行正常 greetComedian(&amp;#34;Bea Arthur&amp;#34;);  // 传入非字符串类型值时会出现运行错误 // name.toUpperCase is not a function at greetComedian greetComedian(123)  let x: any = &amp;#39;hello&amp;#39;; // 编译不报错，但运行时会报错 x(1) // 编译不报错，但运行时会报错 x.foo = 100; 由于any是所有值都相容的类型，因此可以不受限制地访问任意属性，下面代码在编译时不会出现错误，但运行时会出现错误Cannot read properties of undefined (reading &#39;experience&#39;) at Object：
const name: any = &amp;#34;Stefan&amp;#34;; // This is ok for TypeScript, but will crash in JavaScript console.log(name.profession.experience[0].level);  // 出现运行时错误 // Cannot read properties of undefined (reading &amp;#39;experience&amp;#39;) at Object 因为上面这些原因，应当尽量避免使用any类型。从集合论的角度看，any类型可以看成是所有其它类型的全集，包含了一切可能的类型。这种类型被称为Top Type，涵盖了所有下层类型。
类型any除了关闭类型检查，还有一个很大的问题，因为any类型变量的可赋值性是双向的，它会「污染」其它变量。因为any类型也兼容所有子类型（never除外），即any类型变量可以赋值给其他任何类型的变量（没有类型检查），导致其它变量跟着出错。
let x: any = &amp;#39;hello&amp;#39;; let y: number; y = x; // 不报错，因为编译器不会检查x的类型 y * 123 // 告诉编译器y也不需要类型检查，因此也不会报错，运行时返回的是NaN  // 因为一直认为y是number类型，所以编译时不报错 // 运行时报错：y.toFixed is not a function y.toFixed()   const me: any = &amp;#34;Stefan&amp;#34;; // Good! const name: string = me; // Bad, but ok for the type system. const age: number = me; unknown 为了解决any类型污染其它类型的问题，引入了unknown类型，它是一种真正的顶层类型。类型unknown和any类似，所有对象都可以赋值给标注为unknown类型的变量。类型any与unknown的主要区别在于，TypeScript对unknown类型的值有更严格的限制：
 不允许直接访问unkonwn类型值的方法和属性，需要先转换为特定类型后才能使用相关方法或属性。 类型为unknown的变量不可赋值给非顶级类型的（即非any或unknown）变量。  如果直接访问类型为unknown类型值的属性，会出现编译错误：
function greetComedian(name: unknown) {  // 不能直接访问unknown类型变量的方法或属性  console.log(`Announcing ${name.toUpperCase()}!`); }  // 编译错误：&amp;#39;name&amp;#39; is of type &amp;#39;unknown&amp;#39;. 允许在代码中访问unknwon类型值的唯一方法是窄化值的类型范围。例如，使用instanceof或typeof或使用类型断言。
function greetComedianSafety(name: unknown) {  if (typeof name === &amp;#39;string&amp;#39;) {  console.log(`Announcing ${name.toUpperCase()}!`); // Ok  } else {  console.log(&amp;#34;Well, I&amp;#39;m off.&amp;#34;);  } }  greetComedianSafety(&amp;#34;Betty White&amp;#34;); greetComedianSafety({});  // 执行结果 // Announcing BETTY WHITE! // Well, I&amp;#39;m off. Type Predicates 使用instanceof和typeof，可以窄化类型范围。对于直接使用有限检查集窄化类型来说，这一切都很好。如果用函数来包装类型窄化逻辑，会使得原来的窄化失去作用。
// 将窄化封装成函数 function isNumberOrString(value: unknown) {  return [&amp;#39;number&amp;#39;, &amp;#39;string&amp;#39;].includes(typeof value); }  function logValueIfExists(value: number | string | null | undefined) {  // Type of value: number | string | null | undefined  if (isNumberOrString(value)) {  // 调用isNumberOrString只知道返回true，并不知道具体类型  // 编译错误：&amp;#39;value&amp;#39; is possibly &amp;#39;null&amp;#39; or &amp;#39;undefined&amp;#39;.  value.toString();  } else {  console.log(&amp;#34;Value does not exist:&amp;#34;, value);  } } TypeScript有一种特殊语法，用于返回布尔值的函数，以指示参数是否为特定类型。这种特殊的语法被称为type predicate(类型谓词)，有时也被称为user-defined type guard，表示开发者正在创建自己的类型保护，类似instanceof或typeof。
function typePredicate(input: WideType): input is NarrowType; 可以修改上面定义的函数isNumberOrString，使其具有明确的输入类型，即限制函数入参value的类型为string | number。
function isNumberOrString(value: unknown): value is number | string {  return [&amp;#39;number&amp;#39;, &amp;#39;string&amp;#39;].includes(typeof value); }  function logValueIfExists(value: number | string | null | undefined) {  // 无编译错误  if (isNumberOrString(value)) {  value.toString();  } else {  console.log(&amp;#34;Value does not exist:&amp;#34;, value);  } } 类型谓词通常用于检查一个已知接口实例的对象是否是一个更具体接口实例。下面代码中，接口StandupComedian扩展自Comedian，而在函数isStandupComedian中使用类型谓词限制value的类型:
interface Comedian {  funny: boolean }  interface StandupComedian extends Comedian {  routine: string }  function isStandupComedian(value: Comedian): value is StandupComedian {  return &amp;#39;routine&amp;#39; in value }  function workWithComedian(value: Comedian) {  if (isStandupComedian(value)) { // Type of value: StandupComedian  console.log(value.routine) // Ok  }  // Type of value: Comedian  // 编译错误: Property &amp;#39;routine&amp;#39; does not exist on type &amp;#39;Comedian&amp;#39;.  console.log(value.routine) } 但需要注意的是，因为类型谓词在false情况下也会窄化类型范围，如果类型谓词不仅检查输入类型，还过多地检查其它条件，可能会出现令人惊讶的结果。
function isLongString(input: string | undefined): input is string {  // !!的含义就是为了将结果转为真正的boolean值  return !!(input &amp;amp;&amp;amp; input.length &amp;gt;= 7) }  function workWithText(text: string | undefined) {  // 使用了类型谓词，则认为if里面全部是string  // else里面是undefined  if (isLongString(text)) { // Type of text: string  console.log(&amp;#34;Long text:&amp;#34;, text.length)  } else {  // Type of text: undefined  // 编译错误 Property &amp;#39;length&amp;#39; does not exist on type &amp;#39;never&amp;#39;.  console.log(&amp;#34;Short text:&amp;#34;, text?.length)  } } 上面示例代码中，因为else部分推断的类型必须是undefined，而函数isLongString为false时的类型推断是长度小于7的字符串，两部分交叉的结果是never，因此编译器给出的提示是never类型。
因为类型谓词除了验证类型外，还可以验证其他，所以很容易被滥用。一般建议尽可能避免使用它们，多数情况下，简单的类型谓词就足够使用了。
Type Operators 并非所有类型都可以只使用关键字或现有类型的名称来表示。有时，需要创建一种新类型，将两者结合起来，对现有类型的属性进行一些转换。
keyof JavaScript对象可以使用动态键访问成员，动态键通常（但不一定）是string。在类型系统中表示这些键可能很棘手。使用诸如catchall primitive将允许非法的容器键值。
这就是为什么TypeScript在使用更严格的编译设置时，直接使用ratings[key]会报错。如下所示，类型string允许的值很可能不允许作为Ratings接口上的属性，而且Ratings在定义时并没有允许任何字符串键的索引签名：
interface Ratings {  audience: number;  critics: number; }  function getRating(ratings: Ratings, key: string): number {  return ratings[key]; }  // Element implicitly has an &amp;#39;any&amp;#39; type because expression of type &amp;#39;string&amp;#39; can&amp;#39;t be used to index type &amp;#39;Ratings&amp;#39;. 一种可行的方法是对允许的键使用字面量联合。这样可以更准确地限制容器中存在的键，下面代码使用了字面量联合类型来限制键的范围：
interface Ratings {  audience: number;  critics: number; }  function getRating(ratings: Ratings, key: &amp;#39;audience&amp;#39; | &amp;#39;critics&amp;#39;): number {  return ratings[key]; // Ok }  const ratings: Ratings = {audience: 66, critics: 84}; getRating(ratings, &amp;#39;audience&amp;#39;); 但如果接口有很多属性时，必须把每个成员的key对应的字面量放到联合类型中。若接口的属性发生变化时，需要随时更新允许的key。这样后续维护就会变得非常麻烦。
TypeScript提供了keyof操作符，它接收现有类型，并返回该类型允许的所有键的联合。在任何需要使用类型的地方，可以将它放在类型名称的前面。下面代码中，keyof Ratings等同于&#39;audience&#39; | &#39;critic&#39;：
interface Ratings {  audience: number;  critics: number; }  function getCountKeyof(ratings: Ratings, key: keyof Ratings): number {  return ratings[key]; }  interface RatingsExt extends Ratings {  test: number }  function getCountKeyof(ratings: RatingsExt, key: keyof RatingsExt): number {  return ratings[key]; }  const ratingsExt: RatingsExt = {  audience: 66,  critics: 84,  test: 124 };  // 继承的键也是可用的 console.log(getCountKeyof(ratingsExt, &amp;#39;test&amp;#39;)) console.log(getCountKeyof(ratingsExt, &amp;#39;audience&amp;#39;)) console.log(getCountKeyof(ratingsExt, &amp;#39;critics&amp;#39;)) keyof是基于现有类型的键创建联合类型的一项强大功能。它还能与TypeScript中的其它类型操作符很好地结合，实现一些非常有趣的模式。
typeof TypeScript提供的另一个类型操作符是typeof，它会返回所提供值的类型。如果手动编写值的类型复杂得令人讨厌的时候，这个操作符就非常有用。
const original = {  medium: &amp;#34;movie&amp;#34;,  title: &amp;#34;Mean Girls&amp;#34;, };  let adaptation: typeof original;  // 可以使用...展开对象类型，后面的属性会覆盖展开后的属性 adaptation = {...original, medium: &amp;#34;play&amp;#34;}; console.log(adaptation);  // 执行结果 { medium: &amp;#39;play&amp;#39;, title: &amp;#39;Mean Girls&amp;#39; } 尽管typeof类型操作符从外观上看很像运行时的typeof操作符，后者返回相应的值类型的字符串描述，但两者是不同的。也就是说，它们只是巧合地使用了同一个词。
请记住：JavaScript操作符typeof是一个运行时操作符，返回对应值类型的字符串名称。typeScript中的typeof因为是类型操作符，所以只能在类型中使用，不会出现在编译后的代码中。
keyof typeof typeof检索值的类型，keyof检索类型允许的键。typeScript允许将这两个关键字串联起来，以简洁地检索值对应类型上允许的键。将它们组合在一起，typeof类型操作符在处理keyof类型操作时变得非常有用。
const ratings = {  imdb: 8.4,  metacritic: 82, };  function logRating(key: keyof typeof ratings) {  console.log(ratings[key]); } Type Assertions 当我们的代码是「强类型」时，若所有值都有精确的类型，此时TypeScript的效果最好。顶层类型和类型保护等特性可以让类型检查程序理解复杂的代码。但是，有时并不能百分之百准确地告诉类型系统值的准确类型。
例如，JSON.parse故意返回顶层类型any。我们无法安全地告知类型系统，传递给JSON.parse的特定字符串值应返回任何特定的值类型。
TypeScript提供了一种语法，用于覆盖类型系统对值类型的理解。即type assertion，也被称为type cast。如果一个值的类型不同，可以在as关键字后面加上一个类型，TypeScript将遵从断言，将该值视为该类型。类型断言也称为类型强制转换，如果转换失败会抛出异常，因此在使用时要格外注意 。
const rawData = `[&amp;#34;grace&amp;#34;, &amp;#34;frankie&amp;#34;]`; // Type: any JSON.parse(rawData); // Type: string[] JSON.parse(rawData) as string[]; // Type: [string, string] JSON.parse(rawData) as [string, string]; // Type: [&amp;#34;grace&amp;#34;, &amp;#34;frankie&amp;#34;] JSON.parse(rawData) as [&amp;#34;grace&amp;#34;, &amp;#34;frankie&amp;#34;]; 类型断言仅存在于类型系统，当编译为JavaScript后，它们会与类型系统语法的其它部分一起被删除。上面代码编译为JavaScript后将变成如下：
const rawData = `[&amp;#34;grace&amp;#34;, &amp;#34;frankie&amp;#34;]`; // Type: any const re1 = JSON.parse(rawData); // Type: string[] const re2 = JSON.parse(rawData) as string[]; // Type: [string, string] const re3 = JSON.parse(rawData) as [string, string]; // Type: [&amp;#34;grace&amp;#34;, &amp;#34;frankie&amp;#34;] const re4 = JSON.parse(rawData) as [&amp;#34;grace&amp;#34;, &amp;#34;frankie&amp;#34;];  console.log(re1, re2); console.log(re3, re4);  // 执行结果 [ &amp;#39;grace&amp;#39;, &amp;#39;frankie&amp;#39; ] [ &amp;#39;grace&amp;#39;, &amp;#39;frankie&amp;#39; ] [ &amp;#39;grace&amp;#39;, &amp;#39;frankie&amp;#39; ] [ &amp;#39;grace&amp;#39;, &amp;#39;frankie&amp;#39; ] TypeScript的最佳实践是尽可能避免使用类型断言。我们写的代码最好是能完全准确类型化的，不需要使用断言来干扰编译器对其类型的理解。但有时类型断言是有用的，甚至是必要的。
Asserting Caught Error Types 错误处理是类型断言可能派上用场的另一个地方。一般来说，我们不清楚在catch代码块中捕获的错误是什么类型，因为try代码块中的代码可能会意外地抛出与预期不同的对象。此外，虽然JavaScript的最佳实践是始终抛出Error类的实例，但**有些项目却会抛出字符串字面量或其它出人意料的值**。
如果确信某个代码区域只会抛出Error类的实例，可以使用类型断言将捕获的断言视为Error。下面代码将访问捕获的error的message属性，并假定该error是Error类的实例：
try {  // code that may throw an error } catch (error) {  console.warn(&amp;#34;Oh no!&amp;#34;, (error as Error).message); } 比较安全的做法是使用类型窄化形式，如使用instanceof检查，以确保抛出的错误是预期的类型。下面示例代码检查抛出的错误是否为Error类的实例，以确定是记录message还是记录错误本身：
try {  // (code that may throw an error) } catch (error) {  console.warn(&amp;#34;Oh no!&amp;#34;, error instanceof Error ? error.message : error) } Non-Null Assertions 类型断言的另一个常见场景是从变量中移除null或undefined，因为这些变量理论上可能包含null或undefined，但实际上并不包含，所以要手动去除。
这种情况十分常见，TypeScript为此提供了一种速记方法。使用!表示同样的意思，不用写出as和值的完整类型，无论该值是否包含null和undefined。换句话说，!表示变量的类型不是null或undefined。
let maybeDate = Math.random() &amp;gt; 0.5 ? undefined : new Date(); // Asserted type: Date maybeDate as Date; // Asserted type: Date maybeDate!; 在使用Map.get等API时，非空断言尤其有用，这些API会返回一个值，如果该键对应的值不存在时，则返回undefined。
const seasonCounts = new Map([[&amp;#34;I Love Lucy&amp;#34;, 6], [&amp;#34;The Golden Girls&amp;#34;, 7],]); // Type: number | undefined const maybeValue = seasonCounts.get(&amp;#34;I Love Lucy&amp;#34;); // Error: Object is possibly &amp;#39;undefined&amp;#39;. console.log(maybeValue.toFixed());  // Type: number const knownValue = seasonCounts.get(&amp;#34;I Love Lucy&amp;#34;)!; // 除非十分确认，否则上面代码会有运行时报错 console.log(knownValue.toFixed()); // Ok Type Assertion Caveats 如同any类型一样，类型断言是TypeScript类型系统的一个必要逃生舱口。因此，与any类型一样，如果有其它方案，应当避免使用断言。
通常情况下，在代码中使用更准确的类型比使用断言更好。因为，有时断言往往是错误的，要么在编写代码时已经是错误的，要么是在代码库变化后产生的错误。下面代码无编译错误，但运行时会报错：
const seasonCounts = new Map([[&amp;#34;I Love Lucy&amp;#34;, 6], [&amp;#34;The Golden Girls&amp;#34;, 7]]); // 不会出现编译错误，但会出现运行错误 // 运行时错误：Cannot read properties of undefined (reading &amp;#39;toFixed&amp;#39;) const knownValue = seasonCounts.get(&amp;#34;I Love Lucy 11&amp;#34;)!; console.log(knownValue.toFixed());  // 运行时会出现错误，应当捕获异常 try {  const knownValue = seasonCounts.get(&amp;#34;I Love Lucy 11&amp;#34;)!;  console.log(knownValue.toFixed()); } catch (err) {  console.log(err instanceof Error ? err.message : err); } finally {  console.log(&amp;#39;finally&amp;#39;); } 作为对比，如果使用类型声明，在编译就会报错，使用类型断言，需要在运行时才会报错：
interface Entertainer {  acts: string[];  name: string; }  // 编译错误: Property &amp;#39;acts&amp;#39; is missing in type &amp;#39;{ name: string; }&amp;#39; but required in type &amp;#39;Entertainer&amp;#39;. // const declared: Entertainer = {name: &amp;#34;Moms Mabley&amp;#34;,}; const asserted = {name: &amp;#34;Moms Mabley&amp;#34;,} as Entertainer; // Ok, but...  // 运行时错误: Cannot read properties of undefined (reading &amp;#39;join&amp;#39;) console.log(asserted.acts.join(&amp;#34;, &amp;#34;)); 需要注意的是，类型断言被允许的前提是其中一个类型可以赋值给另一个类型。如果类型断言发生在两个完全不相关的类型之间，就会出现编译错误。例如，在两个基本类型之间直接使用类型断言是不允许的。下面代码中，string类型使用类型断言为number会出现编译错误：
// Conversion of type &amp;#39;string&amp;#39; to type &amp;#39;number&amp;#39; may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to &amp;#39;unknown&amp;#39; first. let myValue = &amp;#34;Stella!&amp;#34; as number;  // 下面这样使用双重断言可以转换成功，但十分危险 let myValueDouble = &amp;#34;1337&amp;#34; as unknown as number; console.log(myValueDouble) Const Assertions const断言通常用于表示任何值（数组、基础类型值等）都应被视为其自身的恒定不变版本。具体来说，const断言会对其接收到的任意类型应用以下三条规则：
 数组会被认为是readonly的元组，而不是可变的数组。 字面量被视为字面量类型，而不是对应的基础类型。 对象上的属性被认为是只读的。  // Type: (number | string)[] let arr = [0, &amp;#39;&amp;#39;]; // 类型被推断为readonly的元组，即: readonly [0, &amp;#39;&amp;#39;] // 即使是用let声明了typle，但const的优先级更高 let typle = [0, &amp;#39;&amp;#39;] as const; // typle不能再被赋值，也不能修改其对应的数组元素 // 编译错误：Cannot assign to &amp;#39;0&amp;#39; because it is a read-only property. typle[0] = 12   class classA {  // text的类型是字面量&amp;#39;const&amp;#39;  text = &amp;#39;const&amp;#39; as const } Literals to Primitives 对于类型系统来说，将字面量理解为特定的字面量类型，而不是将其扩大到对应的基础类型，在某些情况非常有用。例如，与返回元组的函数类似，一个函数返回一个特定的字面量类型而非对应的基础类型，这可能会很有用。下面示例代码中，getNameConst的返回类型是更具体的&amp;quot;Maria Bamford&amp;quot;类型，而不是对应的基础类型string。
// Type: () =&amp;gt; string const getName = () =&amp;gt; &amp;#34;Maria Bamford&amp;#34;; // Type: () =&amp;gt; &amp;#34;Maria Bamford&amp;#34; const getNameConst = () =&amp;gt; &amp;#34;Maria Bamford&amp;#34; as const; 让值的特定字段成为更具体的字面量类型也可能是有用的。许多流行的库都要求值的判别字段是一个特定的字面量，这样它们的代码类型就能更具体地对值进行推断：
interface Joke {  quote: string  // style属性是字面量类型的联合  style: &amp;#34;story&amp;#34; | &amp;#34;one-liner&amp;#34; }  function tellJoke(joke: Joke) {  if (joke.style === &amp;#34;one-liner&amp;#34;) {  console.log(joke.quote)  } else {  console.log(joke.quote.split(&amp;#34;\n&amp;#34;))  } }  // Type: { quote: string; style: &amp;#34;one-liner&amp;#34; } const narrowJoke = {  quote: &amp;#34;If you stay alive for no other reason do it for spite.&amp;#34;,  style: &amp;#34;one-liner&amp;#34; as const, }  tellJoke(narrowJoke) // OK  // 下面的wideObject类型为{ quote: string; style: string } const wideObject = {  quote: &amp;#34;Time flies when you are anxious!&amp;#34;,  style: &amp;#34;one-liner&amp;#34;, }  // 会出现编译错误 tellJoke(wideObject) Read-Only Objects 对象字面量（如用作变量初始值的对象字面量）通常会拓宽属性类型，这与let变量初始值的拓宽方式相同。字符串值（如 &amp;quot;apple&amp;quot;）变成了基本类型string，数组字面量变成了可变数组而不是元组。如果这些值中的一部分或全部以后要用于需要其特定字面量类型的地方，这可能会带来不便。
断言值字面类型为const时，推断类型会尽可能具体。所有成员属性都变成只读，字面量被视为自己的字面类型，而不是对应的基本类型，数组变成只读元组。换句话说，对一个值字面量类型应用const断言会使该值字面类型不可变，并递归地对其所有成员应用相同的const断言逻辑。
// 返回类型为字符串字面量的联合 function describePreference(preference: &amp;#34;maybe&amp;#34; | &amp;#34;no&amp;#34; | &amp;#34;yes&amp;#34;) {  switch (preference) {  case &amp;#34;maybe&amp;#34;:  return &amp;#34;I suppose...&amp;#34;;  case &amp;#34;no&amp;#34;:  return &amp;#34;No thanks.&amp;#34;;  case &amp;#34;yes&amp;#34;:  return &amp;#34;Yes please!&amp;#34;;  } }  // Type: { movie: string, standup: string } const preferencesMutable = {  movie: &amp;#34;maybe&amp;#34;,  standup: &amp;#34;yes&amp;#34;, };  // 严格类型检测，传入的实参类型为string，而非字面量 // 编译错误：Argument of type &amp;#39;string&amp;#39; is not assignable to parameter of type &amp;#39;&amp;#34;maybe&amp;#34; | &amp;#34;no&amp;#34; | &amp;#34;yes&amp;#34;&amp;#39; describePreference(preferencesMutable.movie);  preferencesMutable.movie = &amp;#34;no&amp;#34;; // Ok  // Type: readonly { readonly movie: &amp;#34;maybe&amp;#34;, readonly standup: &amp;#34;yes&amp;#34; } const preferencesReadonly = {  movie: &amp;#34;maybe&amp;#34;,  standup: &amp;#34;yes&amp;#34;, } as const  describePreference(preferencesReadonly.movie) // Ok  // 编译错误：Cannot assign to &amp;#39;movie&amp;#39; because it is a read-only property. preferencesReadonly.movie = &amp;#34;no&amp;#34; 需要注意的是，类型断言只能暂时欺骗编译器，无法避免运行时错误。因此，滥用类型断言可能会导致运行时错误，下面代码不会出现编译错误，但会出现运行时错误：
interface Cat {  name: string  run(): void }  interface Fish {  name: string  swim(): void }  function isFish(animal: Cat | Fish) {  // 传入的类型可能是Cat  // 使用类型断言，因为cat没有swim方法，可能会出现运行时错误  (animal as Fish).swim() }  const cat: Cat = {  name: &amp;#34;Hello&amp;#34;,  run(): void {  console.log(this.name)  } }  isFish(cat)  // 出现运行时错误  animal.swim is not a function  // 需要使用try catch避免运行时错误 try {  (animal as Fish).swim() } catch (e) {  console.log((e as Error).message) } 下面示例代码中，使用instanceof判断变量是否为某个类的实例是合适的。但某些情况下，ApiError和HttpError不是一个类，而是接口类型。接口是一个类型，并不是一个真正的值，它在编译结果中会被删除，因此无法使用instanceof来做运行时判断。
class ApiError extends Error {  code: number = 0 }  class HttpError extends Error {  statusCode: number = 200 }  function isApiError(error: Error) {  return error instanceof ApiError } 此时只能使用类型断言来处理：
interface ApiError extends Error {  code: number }  interface HttpError extends Error {  statusCode: number }  function isApiError(error: Error) {  return (error as ApiError).code === 23 } Generics 目前为止，所学到的所有类型语法都用于完全已知的类型。有时，一段代码可能会根据不同的调用方式与各种不同类型协同工作。我们需要一种方法来说明输入类型与函数返回类型之间的关系，TypeScript使用泛型捕捉类型之间的关系。
在Typescript中，函数等泛型构造可以声明任意数量的类型参数，泛型构造的每次使用都会确定这些类型。这些类型参数在泛型构造中表示类型，以表示构造的每个实例中都可能不同的某种类型。类型参数可以为泛型构造的每个实例提供不同的类型（称为类型参数），但在当前实例中将保持一致。
按照惯例，类型参数通常使用单字母（如T和U）或PascalCase名称（如Key和Value）。可以使用&amp;lt;和&amp;gt;声明泛型，如someFunction&amp;lt;T&amp;gt;或SomeInterface&amp;lt;T&amp;gt;。
Generic Functions 要使函数具有泛型功能，可以在参数圆括号之前，用一对尖括号声明类型参数名。接下来，该类型参数就可以在函数体中的形参类型标注、返回类型标注以及函数中使用。
function identity&amp;lt;T&amp;gt;(input: T) {  return input }  const numeric = identity(&amp;#34;me&amp;#34;) // Type: &amp;#34;me&amp;#34; const stringy = identity(123) // Type: 123 console.log(stringy, numeric) // me 123 箭头函数也可以声明为泛型，也是在形参圆括号前用尖括号封装类型参数。下面定义的箭头泛型函数和上面定义的普通泛型函数效果是一样的：
const identity = &amp;lt;T&amp;gt;(input: T) =&amp;gt; input console.log(identity(12)) // 12 console.log(identity(&amp;#39;133&amp;#39;)) // 133  // 箭头泛型 const arrowVal = &amp;lt;T&amp;gt;(value: T) =&amp;gt; value console.log(arrowVal(&amp;#39;898989&amp;#39;)) 但需要注意的是，在.tsx文件中泛型箭头语法有一些限制，因为它与JSX语法冲突。修改相关的配置可以支持JSX和React。
Explicit Generic Call Types 多数情况下，在调用泛型函数时，能够根据函数的调用方式推断出类型实参。例如，在前面的identity函数中，类型检查器根据提供给它的实参来推断泛型函数的类型实参。
不幸的是，与类成员和变量类型一样，有时函数调用时没有足够的信息来告知编译器类型参数应解析成什么类型。如果一个泛型构造器被提供给另一个泛型构造器，则可能会发生这种情况。对于无法推断的类型参数，则认为是unknown类型。
function logWrapper&amp;lt;Input&amp;gt;(callback: (input: Input) =&amp;gt; void) {  return (input: Input) =&amp;gt; {  console.log(&amp;#34;Input:&amp;#34;, input)  callback(input)  } }  // 正常 const test = logWrapper((input: string) =&amp;gt; {  console.log(input.length) })  test(&amp;#39;1233&amp;#39;) // 上面代码的执行结果 Input: 1234 4  // 若未指明类型，编译器默认推断为unknown // 出现编译错误：&amp;#39;input&amp;#39; is of type &amp;#39;unknown&amp;#39;. // unkonwn不能直接访问属性，必须进行类型转换 const log1 = logWrapper((input) =&amp;gt; {  console.log(input.length) })  // 下面代码不会出现编译错误 const log1 = logWrapper((input: number) =&amp;gt; {  console.log(input.toFixed()) }) log1(133.456) 为了避免使用默认的类型unknown，泛型函数调用时可能需要显式标注泛型的类型实参。编译器将对泛型函数调用执行类型检查，以确保显式标注的类型参数是正确的。
function logWrapper&amp;lt;Input&amp;gt;(callback: (input: Input) =&amp;gt; void) {  return (input: Input) =&amp;gt; {  console.log(&amp;#34;Input:&amp;#34;, input)  callback(input)  }; }  const test = logWrapper&amp;lt;string&amp;gt;((input) =&amp;gt; {  console.log(input.length) });   test(&amp;#34;Hello world&amp;#34;)  const log1 = logWrapper&amp;lt;string&amp;gt;((input) =&amp;gt; {  console.log(&amp;#34;input length:&amp;#34;, input.length) }) log1(&amp;#34;133.456&amp;#34;)  // 执行结果 Input: Hello world study.ts:2311 input length: 7 Multiple Function Type Parameters 泛型函数可以定义任意数量的类型参数，类型参数之间用逗号隔开。泛型函数每次调用时都可以为每个类型参数确定相应的实际类型。
function makeTuple&amp;lt;First, Second&amp;gt;(first: First, second: Second) {  return [first, second] as const }  // 因为使用了const，所以let tuple: readonly [boolean, string] let tuple = makeTuple(true, &amp;#34;abc&amp;#34;)  // 下面修改tuple会出现编译错误：Cannot assign to &amp;#39;0&amp;#39; because it is a read-only property. tuple[0] = false  // 返回值是{key: Key, value: Value} function makePair&amp;lt;Key, Value&amp;gt;(key: Key, value: Value) {  return {key, value} }  makePair(123, &amp;#39;123&amp;#39;) makePair&amp;lt;string, number&amp;gt;(&amp;#34;abc&amp;#34;, 123); makePair&amp;lt;&amp;#34;abc&amp;#34;, 123&amp;gt;(&amp;#34;abc&amp;#34;, 123); 在声明泛型函数时，尽量不要超过两个类型参数。与普通函数的参数一样，在泛型函数中使用的类型参数越多，代码就越难阅读和理解。
Generic Interfaces 接口也可以声明为泛型，它们遵循与函数类似的泛型规则：可以在接口名后面添加&amp;lt;和&amp;gt;，尖括号中可以声明任意数量的类型参数。需要注意的是，使用泛型接口类型时，需要显式标注类型实参，否则会出现编译错误。
interface Box&amp;lt;T&amp;gt; {  inside: T }  // 使用泛型接口类型时，需要显式标注类型实参，否则会出现编译错误 // 编译错误： Generic type &amp;#39;Box&amp;lt;T&amp;gt;&amp;#39; requires 1 type argument(s) let d: Box = {  inside: 123 }  // 正常 let stringyBox: Box&amp;lt;string&amp;gt; = {  inside: &amp;#34;abc&amp;#34;, };  let numberBox: Box&amp;lt;number&amp;gt; = {  inside: 123, }  // 声明的参数类型和实际使用的类型不同时会出现编译错误 // Type &amp;#39;boolean&amp;#39; is not assignable to type &amp;#39;number&amp;#39;. let incorrectBox: Box&amp;lt;number&amp;gt; = {  inside: false, } 实际上，内置的Array就是一个泛型接口，它使用类型参数T来表示存储在数组里的元素类型，它的pop和push方法的声明大致如下：
interface Array&amp;lt;T&amp;gt; {  pop(): T | undefined;  push(...items: T[]): number;  // ... } Inferred Generic Interface Types 如同泛型函数，泛型接口的类型实参也可以从使用中推断出来。TypeScript会尽力从提供给标注为泛型接口类型的形参对应的实参值推断出泛型接口对应的具体类型：
interface LinkedNode&amp;lt;Value&amp;gt; {  next?: LinkedNode&amp;lt;Value&amp;gt;;  value: Value; }  function getLast&amp;lt;Value&amp;gt;(node: LinkedNode&amp;lt;Value&amp;gt;): Value {  return node.next ? getLast(node.next) : node.value; }  // Inferred Value type argument: Date let lastDate = getLast({  value: new Date(&amp;#34;09-13-1993&amp;#34;), });  // Inferred Value type argument: string let lastFruit = getLast({  next: {  value: &amp;#34;banana&amp;#34;,  }, value: &amp;#34;apple&amp;#34;, });  // Inferred Value type argument: number let lastMismatch = getLast({  next: {  value: 123  },  // 类型不一致，会出现编译错误  // Error: type &amp;#39;boolean&amp;#39; is not assignable to type &amp;#39;number&amp;#39;.  value: false, } 请注意，如果接口声明时是泛型的，则任何引用该接口类型的地方都必须提供相应的类型实参，否则会出现编译错误。下面示例代码中，因为使用泛型类型标注时没有提供类型实参，所以会出现编译错误：
interface CrateLike&amp;lt;T&amp;gt; {  contents: T; }  // Generic type &amp;#39;CrateLike&amp;lt;T&amp;gt;&amp;#39; requires 1 type argument(s). let missingGeneric: CrateLike = {contents: &amp;#34;??&amp;#34;};  // 类型标注指定了类型实参，所以不会出现编译错误 let missingGeneric1: CrateLike&amp;lt;string&amp;gt; = {contents: &amp;#34;??&amp;#34;}; Generic Classes 如同interface，class也支持泛型，并且支持任意数量的类型参数。创建的每一个类的实例可能使用不同的类型实参。下面定义的泛型类声明了两个类型参数key和value:
class Secret&amp;lt;Key, Value&amp;gt; {  key: Key;  value: Value;   constructor(key: Key, value: Value) {  this.key = key;  this.value = value;  }   getValue(key: Key): Value | undefined {  return this.key === key ? this.value : undefined;  } }  const storage = new Secret(12345, &amp;#34;luggage&amp;#34;); // Type: Secret&amp;lt;number, string&amp;gt; const value1 = storage.getValue(1987); // Type: string | undefined const value2 = storage.getValue(12345); console.log(value1, value2) // undefined luggage Explicit Generic Class Types 实例化泛型类和调用泛型函数类似，如果类型参数可以从构造器中的参数中推断出来，就可以省略显式的类型实参标注。如果省略了类型实参，编译器却推断不出来类型实参，则使用默认的unknown。例如，上面示例代码使用了new Secret(12345, &amp;quot;luggage&amp;quot;)，可以推断出类型实参为number和string：
const storage = new Secret(12345, &amp;#34;luggage&amp;#34;); // Type: Secret&amp;lt;number, string&amp;gt; storage.getValue(1987); // Type: string | undefined 下面定义了泛型类CurriedCallback，类的构造器中接受一个泛型函数作为入参，如果泛型函数有已知的类型（例如来自显式类型参数类型标注），那么类实例中的input类型参数就可以推断出来。
class CurriedCallback&amp;lt;Input&amp;gt; {  #callback: (input: Input) =&amp;gt; void;  constructor(callback: (input: Input) =&amp;gt; void) {  this.#callback = (input: Input) =&amp;gt; {  console.log(&amp;#34;Input:&amp;#34;, input);  callback(input);  };  }  call(input: Input) {  this.#callback(input);  } }  // Type: CurriedCallback&amp;lt;string&amp;gt; new CurriedCallback((input: string) =&amp;gt; {  console.log(input.length); });  // 显式声明类型实参，构造器的入参就可以省略类型标注 new CurriedCallback&amp;lt;string&amp;gt;((input) =&amp;gt; {  console.log(input.length); })  // 既不能从构造器中推断出类型，也未显式标注类型 // 所以会出现编译错误 // Type: CurriedCallback&amp;lt;unknown&amp;gt; new CurriedCallback((input) =&amp;gt; {  // 编译错误：&amp;#39;input&amp;#39; is of type &amp;#39;unknown&amp;#39;  // unknown需要类型窄化才可以访问属性  console.log(input.length); }) Extending Generic Classes 泛型类可以作为普通类的基类。但需要注意的是，编译器不会尝试从使用中推断基类的类型参数，任何没有默认值的类型参数都需要使用显式类型标注。
class Quote&amp;lt;T&amp;gt; {  lines: T;  constructor(lines: T) {  this.lines = lines;  } }  class SpokenQuote extends Quote&amp;lt;string[]&amp;gt; {  speak() {  console.log(this.lines.join(&amp;#34;\n&amp;#34;));  } }  new Quote(&amp;#34;The only real failure is the failure to try.&amp;#34;).lines; new Quote([4, 8, 15, 16, 23, 42]).lines; new SpokenQuote([&amp;#34;Greed is so destructive.&amp;#34;, &amp;#34;It destroys everything&amp;#34;,]).lines;  // 实参类型不对，会出现编译错误：Type &amp;#39;number&amp;#39; is not assignable to type &amp;#39;string&amp;#39;. new SpokenQuote([4, 8, 15, 16, 23, 42]); 泛型派生类也可以将自己的类型参数传递给基类。需要注意的是，派生泛型类中的类型参数名不必与基类泛型声明时使用的名称一致：
class AttributedQuote&amp;lt;Value&amp;gt; extends Quote&amp;lt;Value&amp;gt; {  speaker: string   constructor(value: Value, speaker: string) {  super(value);  this.speaker = speaker;  } }  const value = new AttributedQuote(  &amp;#34;The road to success is always under construction.&amp;#34;,  &amp;#34;Lily Tomlin&amp;#34;); console.log(value.speaker); Implementing Generic Interfaces 泛型类也可以通过提供必要的类型参数来实现泛型接口。这与extends泛型基类的原理类似：基接口上的任何类型参数都必须由实现类来声明。
interface ActingCredit&amp;lt;Role&amp;gt; {  role: Role; }  class MoviePart implements ActingCredit&amp;lt;string&amp;gt; {  role: string;  speaking: boolean;   constructor(role: string, speaking: boolean) {  this.role = role;  this.speaking = speaking;  } }  const part = new MoviePart(&amp;#34;Miranda Priestly&amp;#34;, true); console.log(part.role); Method Generics 类方法可以在类实例之外声明自己的泛型方法。对类中泛型方法的每次调用，对应的每个类型参数都可能有不同的类型实参。
class CreatePairFactory&amp;lt;Key&amp;gt; {  key: Key;  constructor(key: Key) {  this.key = key;  }  // 类中泛型方法中的类型参数和泛型类定义时使用的类型参数不同  createPair&amp;lt;Value&amp;gt;(value: Value) {  return {key: this.key, value};  } } const factory = new CreatePairFactory(&amp;#34;role&amp;#34;); const numberPair = factory.createPair(10); const stringPair = factory.createPair(&amp;#34;Sophie&amp;#34;); Static Class Generics 类的静态成员独立于实例成员，与类的任何特定实例无关。它们无法访问任何类实例或任何类实例特有的类型信息。因此，虽然静态类方法可以声明自己的类型参数，但**它们不能访问泛型类声明时的任何类型参数**。
class BothLogger&amp;lt;OnInstance&amp;gt; {   instanceLog(value: OnInstance) {  console.log(value);  return value;  }   static staticLog&amp;lt;OnStatic&amp;gt;(value: OnStatic) {  // 静态方法不能使用泛型类的类型参数  let fromInstance: OnInstance;  console.log(value);  return value;  }  }  // 出现编译错误： Static members cannot reference class type parameters. Generic Type Aliases 类型别名也支持泛型，每一个泛型别名类型可以有任意数量的类型参数。泛型别名通常与函数一起使用，用于标注泛型函数的类型。
type Nullish&amp;lt;T&amp;gt; = T | null | undefined;  type CreatesValue&amp;lt;Input, Output&amp;gt; = (input: Input) =&amp;gt; Output;  const funTest: CreatesValue&amp;lt;string, number&amp;gt; = (input: string) =&amp;gt; input.length; console.log(funTest(&amp;#39;123333&amp;#39;)); Generic Discriminated Unions 在TypeScript中，判别联合能优雅地将JavaScript常见模式与TypeScript的类型窄化完美地结合在一起。我最喜欢的判别联合用法是添加一个类型参数，以创建一个泛型的Result类型，它可以代表成功的数据结果，也可以代表失败的错误结果。
该Result泛型有一个succeeded判别式，必须使用该判别式才能确定结果是成功还是失败。这意味着任何返回Result的操作都可以表示错误或数据result，并确保使用者需要检查结果是否成功：
type Result&amp;lt;Data&amp;gt; = FailureResult | SuccessfulResult&amp;lt;Data&amp;gt;;  interface FailureResult {  error: Error;  succeeded: false; }  interface SuccessfulResult&amp;lt;Data&amp;gt; {  data: Data;  succeeded: true; }  function handleResult(result: Result&amp;lt;string&amp;gt;) {  if (result.succeeded) {  // 正常  result.data  console.log(`We did it! ${result.data}`);  } else {  console.error(`Awww... ${result.error}`);  }   // 没有类型窄化会出现编译错误  // Property &amp;#39;data&amp;#39; does not exist on type &amp;#39;Result&amp;lt;string&amp;gt;&amp;#39;.  result.data } 将泛型和discriminated types结合在一起，能为像Result这样的可重用类型提供绝佳的定义方式。
Generic Modifiers TypeScript包含允许修改泛型参数行为的语法，下面介绍泛型默认类型参数和类型参数约束。
Generic Defaults 到目前为止，如果在类型标注中使用泛型，或者将其作为类的扩展或实现的基类，那么它必须为每个类型参数提供一个类型实参。可以在类型参数的声明后加上一个=符号和一个默认类型，避免显式地提供类型参数。
interface Quote&amp;lt;T = string&amp;gt; {  value: T; }  let explicit: Quote&amp;lt;number&amp;gt; = {value: 123}; let implicit: Quote = {value: &amp;#34;Be yourself. The world worships the original.&amp;#34;};  // 不显式标注类型，则表示使用默认的类型参数 // 编译错误：Type &amp;#39;number&amp;#39; is not assignable to type &amp;#39;string&amp;#39;. let mismatch: Quote = {value: 123};  interface KeyValuePair&amp;lt;Key, Value = Key&amp;gt; {  key: Key;  value: Value; }  let allExplicit: KeyValuePair&amp;lt;string, number&amp;gt; = {  key: &amp;#34;rating&amp;#34;,  value: 10, };  let oneDefaulting: KeyValuePair&amp;lt;string&amp;gt; = {  key: &amp;#34;rating&amp;#34;,  value: &amp;#34;ten&amp;#34;, };  // 只提供了第一个类型实参，第二个默认和第一个相同 // 编译错误： Generic type &amp;#39;KeyValuePair&amp;lt;Key, Value&amp;gt;&amp;#39; requires between 1 and 2 type arguments. let firstMissing: KeyValuePair = {  key: &amp;#34;rating&amp;#34;,  value: 10, } 需要注意的是，所有缺省类型参数都必须在类型参数列表的最后，这与可选参数类似。也就是说，没有默认值的类型参数不能排在有默认值的类型参数之后。
// 正常 function inTheEnd&amp;lt;First, Second, Third = number, Fourth = string&amp;gt;() {  // }  // 有默认值的类型参数放在了中间，会出现编译错误:Required type parameters may not follow optional type parameters. function inTheMiddle&amp;lt;First, Second = boolean, Third = number, Fourth&amp;gt;() {  // } Constrained Generic Types 默认情况下，泛型的实参类型可以是任何类型：类、接口、基本类型、联合等。但是，有些函数只能用于有限的类型集。在泛型中，允许一个类型参数声明自己需要extends另一个类型，这就是类型约束。泛型类型约束的语法是在类型参数名称后加上extends关键字，然后再加上要约束它的类型。
interface WithLength {  length: number; }  function logWithLength&amp;lt;T extends WithLength&amp;gt;(input: T) {  console.log(`Length: ${input.length}`);  return input; }  logWithLength({length: 123}) // Length：123 keyof and Constrained Type Parameters 关键词keyof也可以用于泛型中的类型约束。将extends和keyof一起使用，可以将key限定在某个类型参数的所有key之内。
function get&amp;lt;T, Key extends keyof T&amp;gt;(container: T, key: Key) {  return container[key]; }  const roles = {favorite: &amp;#34;Fargo&amp;#34;, others: [&amp;#34;Almost Famous&amp;#34;, &amp;#34;Burn After Reading&amp;#34;, &amp;#34;Nomadland&amp;#34;],}; const favorite = get(roles, &amp;#34;favorite&amp;#34;) const others = get(roles, &amp;#34;others&amp;#34;)  // 编译错误：Argument of type &amp;#39;&amp;#34;extras&amp;#34;&amp;#39; is not assignable to parameter of type &amp;#39;&amp;#34;favorite&amp;#34; | &amp;#34;others&amp;#34;&amp;#39;.   const missing = get(roles, &amp;#34;extras&amp;#34;); Promises JavaScript中的Promise表示仍在等待处理的事情，例如网络请求。每个Promise都提供了注册回调的方法，以防待执行操作resolve（成功完成）或 reject（抛出异常）。
Promise能够在任意值类型上表示类似地操作，这与TypeScript泛型非常契合。在TypeScript类型系统中，Promises使用Promise类表示，该类有一个类型参数，代表最终解析的值。
Creating Promises Promise类的构造器中只有单个参数，这个参数的类型取决于泛型Promise类中声明的类型参数，Promise类的简化版本大致如下：
class PromiseLike&amp;lt;Value&amp;gt; {  constructor(executor: (  resolve: (value: Value) =&amp;gt; void,  reject: (reason: unknown) =&amp;gt; void,  ) =&amp;gt; void,  ) {  /* ... */  } } 上面的构造函数中，需要传入的是单个函数，该函数有两个入参，返回类型为void，每个入参又是一个函数。一般来说，要创建一个最终要与值解析的Promise，就必须明确声明Promise的类型参数。
通常需要显式声明泛型类Promise的类型实参，如果没有显式地标注类型实参，编译器则认为类型实参为unknown。向Promise构造函数明确提供类型实参，编译器会解析Promise实例的类型。
const resolvesUnknown = new Promise((resolve) =&amp;gt; {  setTimeout(() =&amp;gt; resolve(&amp;#34;Done!&amp;#34;), 1000); })  // Type: Promise&amp;lt;string&amp;gt; const resolvesString = new Promise&amp;lt;string&amp;gt;((resolve) =&amp;gt; {  setTimeout(() =&amp;gt; resolve(&amp;#34;Done!&amp;#34;), 1000); }); Promise的泛型方法.then方法引入了一个新的类型参数，代表Promise返回的resolve值。下面示例中，创建了一个textEventually的Promise（等待1秒后，resolve了一个string类型的值）。接着，创建了一个lengthEventually，等待一秒后resolve出一个number：
// Type: Promise&amp;lt;string&amp;gt; const textEventually = new Promise&amp;lt;string&amp;gt;((resolve) =&amp;gt; {  setTimeout(() =&amp;gt; resolve(&amp;#34;Done!&amp;#34;), 1000); });  // Type: Promise&amp;lt;number&amp;gt; const lengthEventually = textEventually.then((text) =&amp;gt; text.length) Async Functions 在JavaScript中任何以async关键字声明的函数都返回一个Promise。如果在async函数中返回的值不是Thenable的（一个对象能使用.then方法，几乎总是一个Promise），返回值会被封装在一个Promise中，就像调用了Promise.resolve一样。TypeScript可以识别这一点，并会推断async函数的返回类型始终是Promise的。
下面示例代码中，函数lengthAfterSecond返回一个Promise&amp;lt;number&amp;gt;。因为lengthImmediately标记为async的，所以它的返回类型也被推为Promise&amp;lt;number&amp;gt;：
async function lengthAfterSecond(text: string) {  await new Promise((resolve) =&amp;gt; setTimeout(resolve, 1000))  return text.length; }  // Type: (text: string) =&amp;gt; Promise&amp;lt;number&amp;gt; async function lengthImmediately(text: string) {  return text.length; } 因此，在async函数上手动声明的任何返回类型都必须是Promise类型，即使在函数的实现中没有明确提及任何Promise：
async function givesPromiseForString(): Promise&amp;lt;string&amp;gt; {  return &amp;#34;Done!&amp;#34;; }  // 函数声明时使用了async关键字但返回类型的标注不是promise，会出现编译错误 async function givesString(): string {  // 编译错误: The return type of an async function or method must be  // the global Promise&amp;lt;T&amp;gt; type. Did you mean to write &amp;#39;Promise&amp;lt;string&amp;gt;&amp;#39;?  return &amp;#34;Done!&amp;#34;; } Using Generics Right 如前面的Promise&amp;lt;Value&amp;gt;实现一样，虽然泛型可在代码中描述类型提供很大的灵活性，但它们也会很快变得相当复杂。刚接触TypeScript时可能经常会经历一个过度使用泛型的阶段，以至于代码读起来令人困惑。TypeScript的最佳实践通常是在必要时才使用泛型。
The Golden Rule of Generics 有一个快速测试方法可以帮助确定函数是否需要类型参数，那就是类型参数至少要使用两次。泛型描述的是类型之间的关系，如果一个泛型类型参数只出现在一次，它就不可能定义多个类型之间的关系。
在泛型函数中，每个类型参数都应该用于一个形参，还至少用于一个其它参数和/或函数的返回类型。下面示例中，泛型函数logInput只使用了Input类型形参一次：
function logInput&amp;lt;Input extends string&amp;gt;(input: Input) {  console.log(&amp;#34;Hi!&amp;#34;, input); } 在函数体中，函数logInput中的类型参数后没有做任何操作，例如返回或声明更多参数。因此，声明Input类型参数的用处不大。可以重写logInput，不需要声明为泛型：
function logInput(input: string) {  console.log(&amp;#34;Hi!&amp;#34;, input); } Declaration Files 尽管用TypeScript编写代码很棒，但有时还需要能够在TypeScript项目中处理原始JavaScript文件。许多软件包都是使用JavaScript而不是TypeScript编写的。即便是使用TypeScript编写的软件包也是以JavaScript文件的形式发布的。
此外，TypeScript项目还需要一种方法来获知环境特定功能（如全局变量和API）的type shapes。例如，在Node.js中运行的项目可能可以访问浏览器中不可用的内置Node模块，反之亦然。
TypeScript允许将类型声明与其实现分开。类型声明通常放在以.d.ts扩展名结尾的文件中，称为声明文件。声明文件通常放在项目中，随项目编译的npm包一起构建和发布，或作为独立的typings包共享。
Declaration Files .d.ts文件的工作原理与.ts文件类似，但有一个明显的限制，不允许包含运行时代码。.d.ts文件只包含对可用运行时值、接口、模块和一般类型的描述。它们不能包含任何可编译为JavaScript的运行时代码。可以像导入其它TypeScript源文件一样导入声明文件。
// types.d.ts export interface Character {  catchphrase?: string;  name: string; }  // index.ts import {Character} from &amp;#34;./types&amp;#34;; export const character: Character = {  catchphrase: &amp;#34;Yee-haw!&amp;#34;,  name: &amp;#34;Sandy Cheeks&amp;#34;, }; 在TypeScript里，像声明一些外部模块、全局变量、或者在.d.ts（类型声明文件）里去描述一些已有代码（比如JavaScript库）的类型信息等场景，就是所谓的环境上下文。声明文件创建所谓的ambient context（上下文），表示在代码中只能声明类型而不能声明值的区域。
Declaring Runtime Values 虽然定义文件不能创建函数或变量等运行时值，但它们可以使用declare关键字声明这些构造的存在。这样做可以告知类型系统，某些外部因素（比如网页中的&amp;lt;script&amp;gt;标签）已经以特定的类型创建了该名称下的（相应）值。通过使用declare关键字在定义文件里进行声明，其意义在于让类型系统 “知晓”，虽然定义文件没去创建相应的值，但是在别的地方（像网页中通过&amp;lt;script&amp;gt;标签引入外部脚本这种外部手段）已经创建好了对应名称并且有着特定类型的一些值了。
这样类型系统就能基于这些声明去做类型检查等相关工作，确保代码在类型层面的正确性和兼容性等，避免出现类型不匹配之类的错误。 例如，在TypeScript项目中如果要使用某个已有的、没有自带类型声明的JavaScript库，就可以通过编写定义文件用declare关键字去声明库中暴露出来的函数、变量等的类型，以便TypeScript能正确处理对这些内容的使用情况。
使用declare声明变量的语法与普通变量声明的语法相似，只是不允许使用初始值。下面示例代码段成功地声明了一个已声明的变量，但在试图为初始化变量赋值时却出现了类型错误。
// 合法声明 declare let declared: string; // 不合法声明，会出现编译错误，因为不能包括可执行的代码 declare let initializer: string = &amp;#34;Wanda&amp;#34;; 函数和类的声明也与普通的变量相似，但在声明时不能有函数体或方法体，即不能有相关实现。下面示例代码中的canGrantWish函数和方法在没有函数体的情况下的声明是正确的，但grantWish函数因为有了函数体而出现语法错误：
// 正常，因为没有函数体 declare function canGrantWish(wish: string): boolean; // Ok  // 会出现编译错误，因为有函数体 declare function grantWish(wish: string) { return true; }  class Fairy {  // 正常  canGrantWish(wish: string): boolean; // Ok  // 出现编译错误，因为里面有方法体  grantWish(wish: string) {  return true;  } } 对于环境上下文（ambient context）中声明函数和变量时，隐式any规则同样适用。由于在环境上下文里没办法通过函数体内部的逻辑、或者变量初始值这些常规方式来让TypeScript编译器推断出准确类型，所以只能通过手动添加显式类型标注的方式，明确告诉编译器这个函数的参数、返回值是什么类型，变量又是什么类型等，这样才能避免它们被默认当作any类型去处理。
尽管在.d.ts中使用declare关键字进行类型声明最为常见，但在声明文件之外也可以使用declare关键字。模块或脚本文件中也可以使用declare，当一个全局可用的变量仅打算在该文件中使用时，这么做可能就很有用了。下面示例代码中，变量myGlobalValue定义在一个index.ts文件中，因此可以在这个文件中使用：
// index.ts declare const myGlobalValue: string; console.log(myGlobalValue); // Ok 当存在某个变量，它在全局范围内是可以被访问到的（也就是全局可用变量），但又只想让它在当前这个特定的文件中使用，不想让它影响到项目里的其他文件，此时在这个文件里使用declare关键字来声明这个变量就很合适。
例如，在一个单独的模块文件moduleA.ts中，有一个全局变量localGlobalVar，它只是在moduleA.ts内部用于一些临时的计算或者逻辑处理并且和其它模块没有关系，就可以写成declare var localGlobalVar: string;这种形式进行变量声明，这样既能体现它是全局可用的（在本文件内的全局概念），又能限定它的使用范围就在这个文件中，避免和其它模块产生不必要的冲突或者混淆。
需要注意的是，仅管在.d.ts文件中，无论是否有declare，都允许接口的类型声明。而函数或变量等在runtime constructs没有declare的情况下会出现编译错误：
// index.d.ts interface Writer {} // Ok declare interface Writer {} // Ok  declare const fullName: string; // Ok: type is the primitive string declare const firstName: &amp;#34;Liz&amp;#34;; // Ok: type is the literal &amp;#34;value&amp;#34;   // Error: Top-level declarations in .d.ts files must // start with either a &amp;#39;declare&amp;#39; or &amp;#39;export&amp;#39; modifier. const lastName = &amp;#34;Lemon&amp;#34;; Global Values 因为没有导入或导出语句的TypeScript文件被视为脚本而非模块。因此，在其中声明的类型在全局范围内可用。在没有导入或导出语句的定义文件可以利用这种特性在全局范围内声明类型。全局定义文件对于声明应用程序中所有文件都可用的全局类型或变量特别有用。
下面代码中，globals.d.ts文件全局声明了一个const version: string。因此，尽管没有主动导入globals.d.ts中的version，在version.ts文件也能引用全局的version变量：
// globals.d.ts declare const version: string;  // version.ts export function logVersion() {  console.log(`Version: ${version}`); // Ok } 全局声明值最常用于使用全局变量的浏览器应用程序中。虽然大多数现代网络框架一般都使用ECMAScript模块等较新的技术，但全局变量存储仍然非常有用，尤其是在较小的项目中。
如果发现无法自动访问.d.ts文件中声明的全局类型，需要检查.d.ts文件是否导入和导出了任何内容。即使是一次导出也会导致整个文件不再在全局范围内可用。
Global Interface Merging 变量并不是类型系统中唯一可以设置为全局的东西，许多类型声明都是为全局API和值而存在的。因为接口会与其它同名的接口合并，所以在全局脚本上下文中声明接口（如不包含任何import或export语句的.d.ts文件）会在全局范围内对该接口进行补充。
例如，依赖于服务端设置的全局变量的网页应用可能希望将其声明为存在于全局的Window 接口上。接口合并将允许types/window.d.ts这样的文件声明一个存在于Window类型全局window变量：
&amp;lt;script type = &amp;#34;text/javascript&amp;#34; &amp;gt; window.myVersion = &amp;#34;3.1.1&amp;#34;; &amp;lt;/script&amp;gt;  // types/window.d.ts interface Window {  myVersion: string; }  // index.ts export function logWindowVersion() {  console.log(`Window version is: ${window.myVersion}`);  window.alert(&amp;#34;Built-in window types still work! Hooray!&amp;#34;) } Global Augmentations 在.d.ts文件中避免使用import或export语句，以保持该文件的全局范围作用域并不总是可行的。有时，Mudule文件中声明的类型会在全局范围内使用。
在这种情况下，TypeScript允许使用一种语法来声明代码块的全局性。这样做会将该代码块的内容标记为全局上下文，即使其上下文并非如此：
// types.d.ts // (module context) declare global {  // (global context) } // (module context) 如下所示，type/data.d.ts文件导出了一个Data接口，随后被types/globals.d.ts和运行时index.ts导入该接口：
// types/data.d.ts export interface Data {  version: string; }  // types/globals.d.ts import { Data } from &amp;#34;./data&amp;#34;;  declare global {  const globallyDeclared: Data; }  declare const locallyDeclared: Data; 这样，index.ts就可以访问globallyDeclared变量，而无需导入，但仍需要导入Data：
// index.ts import { Data } from &amp;#34;./types/data&amp;#34;;  function logData(data: Data) { // Ok  console.log(`Data version is: ${data.version}`); }  logData(globallyDeclared); // 编译错误 logData(locallyDeclared); 如何让全局声明和模块声明很好地结合在一起是一件棘手的事情。正确使用TypeScript的declare和global关键字可以描述哪些类型定义在项目中全局可用。
Built-In Declarations 既然已经了解了声明是如何工作的，那么是时候揭开它在TypeScript中的神秘面纱了：它一直在为类型检查提供动力。全局对象（如数组（Array）、函数（Function）、映射（Map）和集合（Set）等）是类型系统需要了解的构造示例，但并未在我们的代码中声明。它们由代码要运行的runtime提供，例如Deno、Node、Web浏览器等。
Library Declarations 所有JavaScript运行时都存在的Array和Function等内置全局对象都是在文件中声明，文件名如lib.[target].d.ts。target是项目所针对的JavaScript的最小支持版本，如ES5、ES2020或ESNext。
内置库定义文件（或称lib文件）相当庞大，因为它们代表JavaScript内置API的全部内容。例如，内置数组类型的成员由一个全局数组interface表示，该接口的开头是这样的：
// lib.es5.d.ts  interface Array&amp;lt;T&amp;gt; {  /** * Gets or sets the length of the array. This is a number one higher than the highest index in the array. */  length: number;  /** * Returns a string representation of an array. */  toString(): string;  /** * Returns a string representation of an array. The elements are converted to string using their toLocaleString methods. */  toLocaleString(): string; } Lib文件作为TypeScript npm软件包的一部分发布，可以在软件包中找到它们，路径类似node_modules/typescript/lib/lib.es5.d.ts。对于VS Code等使用自己打包的TypeScript版本进行代码类型检查的集成开发环境，可以右键单击代码中的内置方法（如数组的forEach），然后选择“Go to Definition”等选项，找到正在使用的lib文件。
Library targets 默认情况下，TypeScript将根据提供给tsc CLI和/或项目tsconfig.json的目标设置（默认为“es5”），包含相应的lib文件。新版本JavaScript的连续lib文件会使用接口合并功能相互构建。例如，ES2015中添加的 EPSILON和isFinite等静态Number成员都列在lib.es2015.d.ts中。
interface NumberConstructor {  /** * The value of Number.EPSILON is the difference between 1 and the smallest value greater than 1 * that is representable as a Number value, which is approximately: * 2.2204460492503130808472633361816 x 10‍−‍16. */  readonly EPSILON: number;   /** * Returns true if passed value is finite. * Unlike the global isFinite, Number.isFinite doesn&amp;#39;t forcibly convert the parameter to a * number. Only finite values of the type number, result in true. * @param number A numeric value. */  isFinite(number: unknown): boolean;   /** * Returns true if the value passed is an integer, false otherwise. * @param number A numeric value. */  isInteger(number: unknown): boolean;  ... } TypeScript项目将包括JavaScript所有版本目标的lib文件，直至其最小目标。例如，目标为es2016的项目将包含lib.es5.d.ts、lib.es2015.d.ts和lib.es2016.d.ts。
DOM Declarations 除了JavaScript语言本身，最常被引用的类型声明领域是网络浏览器。网络浏览器类型通常被称为DOM类型，涵盖了localStorage等API和HTMLElement等主要在网络浏览器中可用的类型。DOM类型与其它lib.*.d.ts声明文件一起存储在lib.dom.d.ts文件中。
全局DOM类型和许多内置全局一样，通常用全局interface来描述。例如，用于本地存储（localStorage）和会话存储（sessionStorage）的存储接口大致是这样开始的。
interface Storage {  /** * Returns the number of key/value pairs. * * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Storage/length) */  readonly length: number;  /** * Removes all key/value pairs, if there are any. * * Dispatches a storage event on Window objects holding an equivalent Storage object. * * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Storage/clear) */  clear(): void;  /** * Returns the current value associated with the given key, or null if the given key does not exist. * * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Storage/getItem) */  getItem(key: string): string | null;  ... } 在未覆盖lib编译器选项的项目中，TypeScript默认包含DOM类型。这有时会让开发人员感到困惑，因为他们无法访问类型系统声称存在的document和localStorage等全局API。
Module Declarations 声明文件的另一个重要特点是可以描述模块的shape。可以在模块的字符串名称前使用declare关键字，以告知类型系统该模块的内容。下面my-example-lib模块在modules.d.ts声明脚本文件中声明，然后在index.ts文件中使用：
// modules.d.ts declare module &amp;#34;my-example-lib&amp;#34; {  export const value: string; }  // index.ts import {value} from &amp;#34;my-example-lib&amp;#34;;  console.log(value); // Ok 在我们的代码中，不会经常用到declare module。它主要用于通配符module声明和后面涉及的package types。
Wildcard Module Declarations 模块声明的一个常见用途是告诉网络应用，某个特定的非JavaScript/TypeScript文件扩展名可以导入到代码中。模块声明可以包含单个*通配符，表示与该模式匹配的任何模块看起来都是一样的。
例如，许多Web项目（如create-react-app和create-next-app等流行的React启动程序中预置的项目）都支持CSS模块，以便将CSS文件中的样式导入为可在运行时使用的对象。它们可能会使用以下模式定义模块：&amp;quot;*.module.css&amp;quot;
// styles.d.ts declare module &amp;#34;*.module.css&amp;#34; {  const styles: { [i: string]: string };  export default styles; }  // component.ts import styles from &amp;#34;./styles.module.css&amp;#34;; styles.anyClassName; // Type: string 使用通配符模块来表示本地文件并不完全安全。TypeScript没有提供确保导入模块路径与本地文件匹配的机制。有些项目会使用Webpack等构建系统和/或从本地文件生成.d.ts文件，以确保导入的模块路径匹配。
Package Types 现在已经了解了如何在项目中声明类型，是时候介绍在包之间使用类型了。使用TypeScript编写的项目通常仍会分发包含编译后.js输出的包。它们通常使用.d.ts文件来声明这些JavaScript文件背后的TypeScript类型系统形状。
declaration TypeScript提供了一个declaration选项，可为输入文件创建.d.ts输出和JavaScript输出。例如，给定以下 index.ts源文件：
// index.ts export const greet = (text: string) =&amp;gt; {  console.log(`Hello, ${text}!`); }； 使用declaration，es2015的某个module，以及es2015的target，下面输出将会产生：
// index.d.ts export declare const greet: (text: string) =&amp;gt; void;  // index.js export const greet = (text) =&amp;gt; {  console.log(`Hello, ${text}!`); } 自动生成的.d.ts文件是项目创建供用户使用的类型定义的最佳方式。一般建议，大多数使用TypeScript编写的软件包在生成.js文件输出时，也应将.d.ts与这些文件捆绑在一起。
Dependency Package Types TypeScript能够检测并利用捆绑在项目的node_modules依赖项中的.d.ts文件。这些文件将告知类型系统该包导出的类型形状，就像它们是在同一项目中编写或用declare模块块声明的一样。一个典型的npm模块如果自带.d.ts声明文件，其文件结构可能类似于这样：
lib/  index.js  index.d.ts package.json Enum 因为enum编译后是一个对象，所以*不能有与它同名的变量，对象，函数和类等*。若在相同作用域内存在与枚举同名的变量、对象、函数或类，将会出现编译错误。
// 下面代码因为枚举和变量名重复了，会出现编译错误 // Enum declarations can only merge with namespace or other enum declarations. enum Test1 {  Local = &amp;#39;local&amp;#39;,  Remote = &amp;#39;remote&amp;#39; }  // 因为有和枚举同名的常量，会出现编译错误 // Enum declarations can only merge with namespace or other enum declarations const Test1 = &amp;#39;890&amp;#39;  // 编译错误，因为枚举和类名重复，会出现编译错误 // Enum declarations can only merge with namespace or other enum declarations. enum Test2 {  A,  B }  class Test2 {  // 类的定义部分 } property 枚举的成员不要求强制赋初始值，若没有初始值，默认从0开始逐一增1，按顺序为每个成员赋值。下面第一个示例中，枚举成员对应值分别为0，1，2。第二段示例代码中，枚举成员对应值为0,4,5:
enum Foo {  A,  B,  C, }  console.log(Foo.A, Foo.B, Foo.C) // 0 1 2 enum Foo {  A,  B = 4,  C, } console.log(Foo.A, Foo.B, Foo.C) // 0 4 5 与其它语言不同的是，enum中属性的值可以是小数。若枚举中某个成员（属性）没有初始值，则其后属性的值也依次在上一个值的基础上&#43;1。下面示例代码，属性的值依次是0.12,1.12,2.12:
enum Foo {  A = 0.12,  B,  C }  console.log(Foo.A, Foo.B, Foo.C) // 0.12 1.12 2.12 但enum属性（成员）的值不能是BigInt类型，否则会出现编译错误：
// 编译错误：Type &amp;#39;bigint&amp;#39; is not assignable to type &amp;#39;number&amp;#39; as required for computed enum member values. enum Foo {  A = 1n, } 不同于Swift，在TypeScript中enum不同属性（成员）对应的值可以相同，但属性名一定不能相同。
enum Foo {  A = 0.12,  B = 0.5,  C = 0.12,  D = 12,  R = 0.12 }  console.log(Foo.R, Foo.C, Foo.B)  // 执行结果 0.12 0.12 0.5 如果只设置第一个属性的值，后面成员的值就会从这个值开始依次递增（在上一个值的基础上自动&#43;1）。
enum Color {  Red = 7,  Green, // 8  Blue, // 9 }  console.log(Color.Blue) // 执行结果 9  // 或者 enum Color {  Red, // 0  Green = 7,  Blue, // 8 }  console.log(Color.Blue, Color.Red);  // 执行结果 8 0 enum所有属性对应的值都是只读的，不能重新被赋值。下面实例代码中，因为重新赋值枚举中的属性Red，会出现编译错误：
enum Color {  Red,  Green,  Blue, }  // 编译报错:Cannot assign to &amp;#39;Blue&amp;#39; because it is a read-only property. Color.Red = 4; 为了强调这一点，通常定义枚举时在enum关键字前面加上const修饰，表示该枚举是常量，不能再次被赋值。加上const还有一个好处，编译为JavaScript代码后，枚举的成员会被替换成对应的值，可以提升性能。
const enum Color {  Red,  Green,  Blue, } 实际上，普通枚举会被编译成JavaScript对象，而const enum在编译时会被完全内联（inline），不会生成任何JavaScript代码。减少生成的代码体积，能够提升运行时性能。此外，因为普通枚举在运行时生成一个全局对象，可能与其它代码产生命名冲突，const enum不会生成任何运行时标识符，完全通过内联值工作。
enum成员的值也可以是计算属性。但需要注意的是，如果定义枚举时在关键字enum前添加了const修饰符，就不能再使用计算属性定义其中的成员。
enum Bool {  No = 123,  // 非const枚举可以使用计算属性  Yes = Math.random(), }  let numb = 12 // 正常 enum Test {  No = 123,  Yes = Math.random() &#43; numb,  Third = getNum(12)  }   function getNum(x: number): number {  return Math.random() &#43; x  }  // 出现编译错误 // const enum member initializers must be constant expressions. const enum Test1 {  No = 123,  Yes = Math.random() &#43; numb,  } enum成员的值除了设置为number，还可以设置为string类型。也就是说，enum也可以作为一组字符串的集合，示例如下所示：
enum Direction {  Up = &amp;#34;UP&amp;#34;,  Down = &amp;#34;DOWN&amp;#34;,  Left = &amp;#34;LEFT&amp;#34;,  Right = &amp;#34;RIGHT&amp;#34;, } 需要注意的是，字符串枚举的所有成员都必须显式设置对应值。如果成员值没有显式设置为string，则值默认为number的，且其位置必须放在字符串成员之前。也就是说，在枚举定义时，一旦设置了字符串的成员，其后的成员一定要赋初值，否则会出现编译错误：
enum Foo {  A, // 0  B = &amp;#34;hello&amp;#34;,  C, // 报错 Enum member must have initializer } enum成员可以是字符串和数值的混合，如果要使用默认的数值，则成员必需放在字符串值成员之前。下面定义的枚举Foo第一个成员使用了默认的number，然后是string，再是number：
enum Foo {  zero,  One = &amp;#34;One&amp;#34;,  Two = &amp;#34;Two&amp;#34;,  Three = 3,  Four = 4, } enum的成员除了number和string，不允许使用其它类型值。需要特别注意的是，若变量类型是字符串的枚举，不能使用字符串直接赋值该变量，这跟数值enum变量不一样。
enum Enum {  One = &amp;#34;One&amp;#34;,  Two = &amp;#34;Two&amp;#34;,  Three = 3,  Four = 4, }  function test(a: Enum) {  console.log(a) }  test(3) // 正常  // 编译错误:Argument of type &amp;#39;&amp;#34;One&amp;#34;&amp;#39; is not assignable to parameter of type &amp;#39;Enum&amp;#39;. test(&amp;#34;One&amp;#34;) 还需要注意的是，enum的字符串类型成员的值不能使用运行时才能计算的表达式赋值。
enum MyEnum {  A = &amp;#34;one&amp;#34;,  // 使用表达式时会出现编译错误  // Type &amp;#39;string&amp;#39; is not assignable to type &amp;#39;number&amp;#39; as required for computed enum member values.  B = [&amp;#34;T&amp;#34;, &amp;#34;w&amp;#34;, &amp;#34;o&amp;#34;].join(&amp;#34;&amp;#34;), }  enum MyEnum {  A = &amp;#34;one&amp;#34;,  // 会出现编译错误  // Type &amp;#39;string&amp;#39; is not assignable to type &amp;#39;number&amp;#39; as required for computed enum member values.  B = &amp;#34;T&amp;#34;.repeat(12) }  // 下面是正常的，因为&amp;#34;T&amp;#34; &#43; &amp;#34;B&amp;#34;编译时就能确定值 enum MyEnum {  A = &amp;#34;one&amp;#34;,  B = &amp;#34;T&amp;#34; &#43; &amp;#34;B&amp;#34; } merge 同名的enum可以合并，但有一些需要注意的地方，首先是合并时不能有同名的成员（或被称为属性），否则会出现编译报错：
enum Foo {  A, }  // 因为有同名的属性会出现编译错误:Duplicate identifier &amp;#39;A&amp;#39;. enum Foo {  A = 2 } 同名enum合并时，只允许同名枚举的某一个定义中的第一个成员省略初始值(不能同时第一个成员省略)，否则会出现编译错误：
enum Foo {  A, }  // 编译错误：In an enum with multiple declarations, only one declaration can omit an initializer for its first enum element. enum Foo {  B }  // 下面定义同名枚举的方式是正确的 // 因为仅有一个枚举定义的第一个成员省略了值，所以不会出现编译错误 enum Foo {  A, } enum Foo {  B = 12,  C } 同名enum合并的另一个限制，所有枚举定义必须同为const或者非const，不允许混合使用，否则会出现编译错误。同名枚举合并的最大用处是补充外部定义的enum。
enum Foo {  A, }  // 编译错误：Enum declarations can only merge with namespace or other enum declarations. const enum Foo {  B = 1, } reverse map 枚举的反向映射，是指通过枚举属性的值获取到属性名，但*仅限于非const的number类型的枚举*：
enum Foo {  A = 1,  B = 2,  C = 4, }  console.log(Foo[3], Foo[4] === &amp;#39;C&amp;#39;) // undefined true  // 如果是const会出现编译错误 const enum Foo {  A = 0,  B = 1,  C = 4 }  // 编译错误：A const enum member can only be accessed using a string literal console.log(Foo[3], Foo[4] === &amp;#39;C&amp;#39;) 因为枚举中不同属性名的属性值可以相同，所以在使用反向映射时，相同值的反向映射会取到在枚举定义时最后一个值对应的属性：
enum Foo {  A = 1,  B = 2,  C = 4,  D = 1, }  // Foo[1]拿到的反向映射值为D console.log(Foo[3], Foo[4] === &amp;#39;C&amp;#39;, Foo[1] === &amp;#39;A&amp;#39;)  // 执行结果 undefined true false 枚举的反向映射只发生在数值成员上。对于字符串成员值的枚举，不存在反向映射，因为字符串枚举编译后只有一组赋值。
enum Foo {  A = 1,  B = 2,  C = 4,  D = &amp;#39;CHEN&amp;#39;, }  // 编译错误:Element implicitly has an &amp;#39;any&amp;#39; type because index expression is not of type &amp;#39;number&amp;#39;. console.log(Foo[3], Foo[&amp;#39;CHEN&amp;#39;]) 需要特别注意的是，常量枚举也没有反向映射，因为它在编译时会被完全内联。下面示例代码会出现编译错误：
const enum ConstDirection {  Up,  Down } // 编译错误 // A const enum member can only be accessed using a string literal. console.log(ConstDirection[0] == &amp;#39;Up&amp;#39;); 参考资料1
NameSpaces 命名空间namespace是一种将相关代码组织在一起的方式，通常用于建立一个容器，容器内部的所有变量和函数，默认都必须在这个容器里使用。下面示例代码中，函数isString只能在命名空间Utils中使用，如果在外部直接使用函数isString，会出现编译错误。
namespace Utils {  function isString(value: any) {  return typeof value === &amp;#39;string&amp;#39;  }  // 在内部使用不会报错  console.log(isString(&amp;#39;test&amp;#39;)) }  // 在外部直接使用命名空间中的函数编译报错 // Cannot find name &amp;#39;isString&amp;#39;. Did you mean &amp;#39;String&amp;#39;? console.log(isString(&amp;#39;test&amp;#39;)) 如果想要在命名空间以外使用其中的内部成员，就必须在该成员前面加上export关键字，表示对外导出该成员（即声明对外可见），否则会出现编译错误：
namespace Utils {  function isString(value: any) {  return typeof value === &amp;#39;string&amp;#39;  }  console.log(isString(&amp;#39;test&amp;#39;)) }  // 下面会出现编译错误：Property &amp;#39;isString&amp;#39; does not exist on type &amp;#39;typeof Utils&amp;#39;. // 因为isString前没有添加export console.log(Utils.isString(&amp;#39;test&amp;#39;)) 下面示例代码中，在Utils中使用export调整函数isString的可见性：
namespace Utils {  // 只有添加export后才不会出现编译错误  export function isString(value: any) {  return typeof value === &amp;#39;string&amp;#39;  } }  console.log(Utils.isString(&amp;#39;test&amp;#39;)) // 执行结果 true 编译成JavaScript代码后，命名空间Utils变成了JavaScript的一个对象，凡是在命名空间中export的内部成员，都成为了该对象的属性。也就是说namespace会变成一个值，保留在编译后的代码中，这一点要小心，它不是纯类型代码。
namespace Utils {  export function isString(value: any) {  return typeof value === &amp;#39;string&amp;#39;  }  console.log(isString(&amp;#39;test&amp;#39;)) }  namespace App {  import isString = Utils.isString;  console.log(isString(&amp;#39;yes&amp;#39;)) } 在namespace内部还可以使用import命令导入外部成员，相当于给外部成员起别名。当外部成员的名字比较长时，通过别名能够简化代码。
namespace Utils {  export function isString(value: any) {  return typeof value === &amp;#34;string&amp;#34;;  } }  namespace App {  import isString = Utils.isString;   // 等同于Utils.isString(&amp;#34;yes&amp;#34;);  isString(&amp;#34;yes&amp;#34;); } 也可以在命名空间外部使用import导入命名空间内的成员：
namespace Shapes {  export namespace Polygons {  export class Triangle {  //  }  } }  // 在外部使用import导入 import polygons = Shapes.Polygons; 命名空间也可以嵌套：
namespace Utils {  export namespace Messaging {  export function log(msg: string) {  console.log(msg);  }  } }  Utils.Messaging.log(&amp;#34;Test namespace&amp;#34;)  // 执行结果 Test namespace 命名空间与模块的作用是一致的，都是把相关代码组织在一起，对外导出内容。区别是一个文件只能有一个模块，但可以有多个namespace。由于模块可以取代namespace，而且是JavaScript的标准语法，不需要编译转换，所以通常建议使用模块。如果namespace的代码放在一个单独的文件里，那么引入这个文件需要使用三斜杠的语法。
/// &amp;lt;reference path = &amp;#34;SomeFileName.ts&amp;#34; /&amp;gt; export 命名空间本身也支持使用export命令输出，供其它文件使用：
// shapes.ts export namespace Shapes {   export class Triangle {  // ...  }   export class Square {  // ...  }  } 其它文件可以使用import命名加载这个命名空间：
// 写法一 import { Shapes } from &amp;#39;./shapes&amp;#39;; let t = new Shapes.Triangle();  // 写法二 import * as shapes from &amp;#34;./shapes&amp;#34;; let t = new shapes.Shapes.Triangle(); 更好的方法是建议使用模块，采用模块的输出和输入：
// shapes.ts export class Triangle {  /* ... */ } export class Square {  /* ... */ }  // shapeConsumer.ts import * as shapes from &amp;#34;./shapes&amp;#34;; let t = new shapes.Triangle(); merge 多个同名的namespace能够自动合并，这一点跟interface一样。
namespace Animals {  export class Cat {  //  } }  namespace Animals {   export interface Legged {  numberOfLegs: number;  }   export class Dog {  //  } }  // 等同于 namespace Animals {   export interface Legged {  numberOfLegs: number;  }   export class Cat {  //  }   export class Dog {  //  } } 这样做的目的是，如果同名的命名空间分布在不同的文件中，TypeScript会将它们合并在一起，这样就比较方便扩展别人的代码。合并命名空间时，命名空间中的非export的成员不会被合并，它们只能在各自的命名空间中使用。
namespace N {  const a = 0;   export function foo() {  console.log(a); // 正确  } }  namespace N {  export function bar() {  foo(); // 正确  console.log(a); // 报错  } }  // 出现编译报错 Cannot find name &amp;#39;a&amp;#39; 命名空间还可以跟同名函数合并，但要求同名函数必须在命名空间之前声明。这样做是为了确保先创建出一个函数对象，而同名的命名空间就相当于给这个函数对象添加额外的属性。
function f() {  return f.version; }  namespace f {  export const version = &amp;#39;1.0&amp;#39;; }  f() // &amp;#39;1.0&amp;#39; f.version // &amp;#39;1.0&amp;#39; 命名空间也能与同名class合并，也要求class必须在命名空间之前声明，原因同上。
class C {  foo = 1; }  namespace C {  export const bar = 2; }  C.bar // 2 命名空间还能与同名枚举合并，但此时不要求枚举在命名空间之前声明：
namespace E {  export function foo() {  console.log(E.C);  } }  enum E {  A,  B,  C, }  E.foo() // 2 但需要注意的是，枚举成员与命名空间export成员不允许同名：
enum E {  A,  B, }  namespace E {  export function A() {} } // 编译错误：Duplicate identifier &amp;#39;A&amp;#39;.  参考资料2
WK中使用sock5代理
openAdapter
Module 若文件中包含import或export语句，就是一个模块，反之则是一个全局的脚本文件。模块本身就是一个作用域，但它不是全局作用域，模块内部的代码默认仅内部可见。若想暴露module中的代码给外部使用，需使用export声明，其它文件若想使用module内定义的export项，必须使用import导入。
如果一个文件不包含export语句，但是希望把它当作一个模块（让内部代码对外不可见），可以在文件头部添加export {};。这条语句会让当前文件被当作模块处理，即文件内的所有代码变成了仅内部可见。
export {}; TypeScript模块除了支持所有ES模块的语法，特别之处在于允许export和import类型。下面示例代码中，当前文件导出一个类型别名Bool。既可以把类型定义和导出写在一行，也可以写成两行。
export type Bool = true | false;  // 一行拆成两行，先定义类型别名，再导出类型 type Bool = true | false; export { Bool }; export default export 在一个模块（.ts文件）中只能有一个默认导出，语法为export default expression;。其中expression可以是一个类、函数、对象等。下面示例代码中，默认导出一个函数add。如果同一个文件中默认导出了多个项，则会出现编译错误：
// mathUtils.ts export default function add(a: number, b: number): number {  return a &#43; b; }  // 同一个文件中如果有两个默认导出，则会出现编译错误 // Cannot redeclare exported variable &amp;#39;default&amp;#39;. export default function add1(a: number, b: number): number {  return a &#43; b; } named export 可以在一个模块中导出多个具名的变量、函数、类等。具名导出(named export)的语法是export const/function/class/interface name = value;，即在定义的最前面加上export关键词。
// stringUtils.ts export const joinStrings = (str1: string, str2: string): string =&amp;gt; {  return str1 &#43; str2; };  export function splitString(str: string, separator: string): string[] {  return str.split(separator); } re-export 可以在一个模块中导出另一个模块的内容。语法为export { name1, name2 } from&#39;modulePath&#39;;。例如，有一个utils目录，其中mathUtils.ts和stringUtils.ts是两个工具模块，现在创建了一个index.ts来重导出这些工具：
// utils/index.ts export {add} from &amp;#39;./mathUtils&amp;#39;; export {joinStrings, splitString} from &amp;#39;./stringUtils&amp;#39;; 将多个文件的内容重导出到同一个文件中时，其它模块就可以通过导入utils/index.ts来使用所有重导出的内容：
// main.ts import {add, joinStrings, splitString} from &amp;#39;./utils&amp;#39;;  console.log(add(1, 2)); console.log(joinStrings(&amp;#34;Good&amp;#34;, &amp;#34;bye&amp;#34;)); console.log(splitString(&amp;#34;Good,bye&amp;#34;, &amp;#34;,&amp;#34;)); 在一个模块中，具名导出的名称必须是唯一的。若尝试使用相同的名称导出两个不同的内容，会出现编译错误（这其实和export没有多大关系，就是重定义了两个同名变量而出现的编译错误）：
export const value = 1; export const value = 2;  // 编译错误 Cannot redeclare block-scoped variable &amp;#39;value&amp;#39;. export type 同样地，export type语句也有两种方法，表示导出的是类型。
type A = &amp;#34;a&amp;#34;; type B = &amp;#34;b&amp;#34;;  // 方法一 export { type A, type B };  // 方法二 export type { A, B }; import 若上面的模块文件为a.ts，在另一个文件b.ts就可以使用import语句导入这个类型。下面示例代码中，import语句导入的是一个类型。文件写成了./a，并没有加上后缀名 ，这是因为TypeScript允许加载模块时，省略模块文件的后缀名，它会自动定位，将./a定位到./a.ts。
import { Bool } from &amp;#34;./a&amp;#34;;  let foo: Bool = true; all import 若想import某个模块中的所有export内容，语法为import * as moduleName from&#39;modulePath&#39;;。若有一个名为mathUtils的模块，里面包含了一些数学工具函数，如add和subtract，模块路径为./mathUtils，可以使用如下方式导入模块中所有export内容：
import * as math from &amp;#39;./mathUtils&amp;#39;;  console.log(math.add(1, 2)); named import 当只需要模块中的某些特定的导出内容时，可以使用具名导入（named import）。语法是import {Name1, Name2} from&#39;modulePath&#39;;。例如，如果mathUtils模块导出了add和subtract函数，可以按下面方式具名导入：
import {add, subtract} from &amp;#39;./mathUtils&amp;#39;;  console.log(add(1, 2)); console.log(subtract(3, 1)); default import 一个模块仅能有一个默认导出，默认导入的语法是import defaultExportedName from&#39;modulePath&#39;;（没有大括号）。例如，有一个模块person中默认导出了一个名为Person的类，可以使用如下方式导入：
import Person from &amp;#39;./person&amp;#39;;  const p = new Person(); rename import 无论是具名导入还是默认导入，都可以对导入的内容进行重命名。对于具名导入，语法是import {exportedName1 as newName1, exportedName2 as newName2} from&#39;modulePath&#39;;：
import {add as sum, subtract as diff} from &amp;#39;./mathUtils&amp;#39;;  console.log(sum(1, 2)); console.log(diff(3, 1)); 但对于默认导入，因为它没有大括号且每个模块仅允许一个默认导出，所以语法变成了import newName from&#39;modulePath&#39;;，即对应的重命名导入也不需要使用as关键字。若在person模块默认导出了Person类，重命名默认导入方式如下：
import Human from &amp;#39;./person&amp;#39;;  const h = new Human(); type import 在一条import语句中，可以同时导入变量和类型。下面示例代码中，文件a.ts的export语句导出了一个接口类型A和一个普通的变量a，另一个文件b.ts则在同一条语句中导入了这个类型和变量。
// a.ts export interface A {  foo: string; }  export let a = 123;  // b.ts import { A, a } from &amp;#34;./a&amp;#34;; 这样不利于区分类型和普通变量，容易造成混淆。为了解决这个问题，TypeScript提供了两种方案。第一种是在待导入类型前加上type关键字，表示要导入的是一个类型。
import { type A, a } from &amp;#34;./a&amp;#34;; 第二种是使用import type语句：
// 正确 import type { A } from &amp;#34;./a&amp;#34;; 使用import type时，也可以导入默认类型。假如有一个模块person默认导出了一个Person类，就可以使用type默认导入Person：
import type Person from &amp;#34;./Person&amp;#34;; 使用import type还可以导入一个名称空间下的所有类型，写法如下：
import type * as NewType from &amp;#34;moduleA&amp;#34; </content>
    </entry>
    
     <entry>
        <title>iOS 14 编程基础</title>
        <url>https://iihui.github.io/post/ios-fundamentals/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> Object 在Swift中，万物皆为对象，这是什么意思呢？这取决于我们所说的「对象」是什么，以及所说的「万物」是指什么。简单地说，对象就是可以向其发送消息的东西，而消息指的是一个命令式指令。在Swift中，发送消息的语法是点表示法：以对象开始，然后紧跟一个点，最后紧跟消息。
万物皆为对象是一种暗示：即使是「最原始的」语言实体也可以接收消息。例如，1在多数编程语言中仅仅是字面意义上的含义，而在Swift中可以按照如下方式使用：
1.description 从上面的代码可以看出，1确实是一个对象，因为它可以接收description这样的消息。在表达式1&#43;2中，如同1是一个对象一样，&#43;实际上是一个消息（运算符语法消息）。在Swift中，每个名词都是一个对象，而每个动词都是一个消息。
在Swift中，检验一个东西是否为对象的最终标准是看能否修改它。一个对象类型可以在Swift中被扩展，这意味着可以在这个类型上定义自己的消息，即该对象类型是可以被修改的。
例如，通常不能向一个整数字面量发送sayHello消息，但可以通过扩展来改变一个Int类型，使得可以向其实例发送sayHello消息：
extension Int {  func sayHello() {  debugPrint(&amp;#34;Hello, I&amp;#39;m \(self)&amp;#34;)  } } 在Swift中，1是对象，在Objective-C中，它是标量内置类型。但在Swift中，不存在标量类型，所有类型都是对象类型，这就是「万物皆为对象」的真正含义。
在许多其它语言中，对象是类或者类的实例。在Swift中，也有类的概念，但字面量1既不是类，也不是类的实例。在Swift中，字面量1的类型是Int，该类型是一个结构体。
在Swift中有三种对象类型，它们依次是类，结构体以及枚举类型。它们都是非常明确的对象类型，并且它们之间的相似性远大于差异性。实际上，在Swift 5.5中，还有第4种对象类型，那就是actors。
一个完整的Swift命令为一条语句，一般使用换行符来分隔语句。一个Swift文件一般由多行文本组成，通常一行一条语句。如果想要一行包含多条语句，则需要使用分号分隔：
print(&amp;#34;hello&amp;#34;); print(&amp;#34;world&amp;#34;) 如果一个语句太长，实际上是可以拆成多行的，但是拆分的位置应当尽量在合理的地方。如下示例代码，左括号是一个较好的位置：
print(  &amp;#34;world&amp;#34;) 在Swift编码习惯中，花括号后面都是紧跟换行符，并且为了使代码更清晰，通常会进行缩进，Xcode中也会强化这种约定：
class Dog {  func bark() {  print(&amp;#34;woof&amp;#34;)  } } 但实际上这只是一种编码惯例，Swift编译器并不在乎这些。下面示例代码将花括号后面没有紧跟换行符，而是将类的定义写在一行也是合法的：
class Dog { func bark() { print(&amp;#34;woof&amp;#34;) }} Swift是一种编译语言，这意味着代码必须先经过编译，通过编译器将语句转换为计算机可以理解的较低级别的形式，然后才能运行并执行这些代码。
Variables 变量是对象的名称，从技术上来说，一个变量指向一个对象，是这个对象的引用。非严格地说，变量就是一个存放对象的盒子，这个对象可能会发生变化或者盒子的对象可能被另一个对象取代，但这个名字有其自身的完整性。变量所指向的对象就是变量的值。
在Swift中，所有变量都必须先声明后使用。变量声明通常伴随着初始化，即作为声明的一部分增加一个等号，并且立即给变量一个初始值：
var two = 2 用let声明的是一个常量，它的值只能赋一次（可以先声明后面再初始化一次，或者声明的同时初始化，但必须保证只赋值一次）。一旦初始化后，如果试图再次改变let声明的常量的值，就会出现编译错误。
变量都有一个类型，这个类型是在变量声明时就确定了的，并且不能被更改。在下面的例子中，变量two声明时的类型是Int，因此不能使用String类型来覆盖它：
var two = 2 two = &amp;#34;hello&amp;#34; // 编译错误：Cannot assign value of type &amp;#39;String&amp;#39; to type &amp;#39;Int&amp;#39; 按照惯例，类型名字以大写字母开头，变量名以小写字母开头。如果违反了这种规范，代码仍然能够通过编译，但强烈建议不要这么做。
Functions 通常来说，可执行代码必须放在一个函数体内。但有一个例外，在main.swift文件中，可以在其顶层（任何函数体之外）放置可执行代码。
一个函数是一批可执行语句的集合，可以作为一个批次来运行。函数体由花括号包围，通常一个函数有一个名字（也有匿名函数），通过函数声明获得这个名字:
func sum(a: Int, b: Int) -&amp;gt; Int {  return a &#43; b } The Structure of a Swift File 一个Swift程序可以由一个或多个文件组成。在Swift中，一个文件是一个有意义的单元，而且对于可以放在文件里的代码结构有明确的规定。通常来说，只有下面的东西可以放在Swift文件的顶层：
  模块导入语句，例如：import UIKit。module是更高层次的单元，一个模块包含多个文件，同一个模块里的文件默认能够自动看到各自。一个App属于一个module，里面的文件能够看到各自。在一个module中，不通过import不能看到另一个module中的文件。
  全局变量和常量声明：文件顶层声明的变量，被称为全局变量，包括以let和var声明的变量。同一个模块中任何文件中的所有代码都将能够看到并访问它，无需依赖任何对象。
var str = &amp;#34;test&amp;#34; let cons = 13   全局函数声明：在文件顶层声明的函数为全局函数，默认情况下，同一个模块中的任何文件中的代码都可以看到并访问它，而无需依赖任何对象。
  对象类型声明：包括class,struct,enum,protocol等对象类型的声明。
  import UIKit var one = 1 let constant = 1 func changeOne() {  // ... } class Manny {  // ... } struct Moe {  // ... } enum Jack {  // ... } 在上面示例代码中，花括号里的内容可以是变量声明、函数声明和对象类型声明。事实上，任何花括号里面都可以包含变量声明、函数声明和对象类型的声明。
像one = two或debugPrint(&amp;quot;hello&amp;quot;)这样的语句是可执行语句，一般不能放在文件的顶层，而是将其放在函数体中（除了main.swift中的顶层可以有可执行语句）。在下面的代码中，func changeOne()是一个函数声明，可执行代码放在花括号中以形成函数体:
var one = 1 func changeOne() {  let two = 2  // 可执行语句  one = two } 同样地，可执行代码不能直接放在类Manny声明的花括号内，因为那是类声明的顶层，而不是函数体内。但是一个类声明可以包含一个函数声明，并且该函数声明中可以包含可执行代码。
Scope and Lifetime 在Swift程序中，所有事物都有一个作用域。作用域指的是能够被其它事物看到的能力。事物可以嵌套在其它事物内部，形成嵌套层次结构。
事物作用域的可见规则：事物可以看到它们自己所在的层次和包含它们的更高层次的事物，这些层次依次是：
 module：模块是一个作用域。 file：文件是一个作用域。 {}：花括号是一个作用域。  当某个事物被声明时，它一定是在上面层次结构中的某个级别声明的。它在层次结构中的位置级别决定了是否可以被其它事物看到。作用域是共享信息的一种非常重要方式，首先来看下面的代码段：
var one = 1  func changeOne() {  let two = 2   /// 内部函数  func sayTwo() {  debugPrint(two)  }   class Klass {  // 内部类实现  }   struct Struct {  // 内部结构体实现  }   enum Enum {  // 内部枚举实现  }  one = two }  class Manny {  let name = &amp;#34;manny&amp;#34;   func sayName() {  debugPrint(name)  }   class Klass {  // 内部类实现  }   struct Struct {  // 内部结构体实现  }   enum Enum {  // 内部枚举实现  } }  struct Moe {  let name = &amp;#34;moe&amp;#34;   func sayName() {  debugPrint(name)  }   class Klass {  // 内部类实现  }   struct Struct {  // 内部结构体实现  }   enum Enum {  // 内部枚举实现  } }  enum Jack {  var name: String {  return &amp;#34;jack&amp;#34;  }   func sayName() {  debugPrint(name)  }   class Klass {  // 内部类实现  }   struct Struct {  // 内部结构体实现  }   enum Enum {  // 内部枚举实现  } } 在上面代码中，类Manny中声明的所有函数都可以看到Manny顶层声明的name。类Manny、Jack和Moe中的代码都能看到文件顶层声明的函数、变量和常量。
对于一个事物而言，只要包含它的scope（范围）存在，那么这个东西就会存在。在上面的代码中，只要文件存在，变量one就存在。也就是说只要程序运行，变量one就存在，因为它是全局的。但是在Manny顶层声明的实例变量只有在Manny实例存在时才会有效。
代码中的事物都有生命周期，实际上等同于它们的作用域。一个事物只要包含它的作用域存在，它就存在。上面代码中，只要文件存在（也就是程序运行时），变量one就存在，因为它是全局的。
变量声明、函数声明和对象类型声明可以出现在任何的花括号中。一般来说，在更深层次声明的东西生命周期更短，对于下面这段代码：
func silly() {  if true {  class Cat { 	// Cat实现...  }  var one = 1  one = one &#43; 1  } } 如果函数silly被调用，执行路径就会进入到if结构中。在这里，类Cat被声明，然后变量one被声明并生成，接着one = one &#43; 1被执行，最后作用域结束，此时类Cat和变量one都会自动消失。在它们短暂的生命中，类Cat和变量one对于代码的其它部分来说是完全不可见的。
Object Members 在对象类型（类，结构体和枚举）的声明中，顶层声明的常量和变量被称为属性，顶层声明的函数被称为方法。在一个对象类型声明时，顶层声明的属性和方法或其它对象统称对象成员。对象成员具有特殊意义，因为它定义了可以向该对象发送的消息：
class Manny {  let name = &amp;#34;manny&amp;#34;   func sayName() {  debugPrint(name)  }   class Klass {  //  }   struct Struct {  //  }   enum Enum {  //  } } Namespaces 命名空间是指程序的一个命名区域。对于命名空间外的事物，如果想访问命名空间内的事物，就需要先使用该命名区域的名字，以破除该区域的障碍，否则就不能访问该命名区域内的事物。
这是一件好事，因为这样允许相同名字的事物在不同的地方使用而不发生冲突。显然，命名空间和作用域是密切相关的概念。
命名空间有助于解释在一个对象的顶层声明内嵌另一个对象声明的重要意义。下面代码在Manny中以内嵌方式声明了Klass，这样有效地将Klass隐藏在Manny里面：
class Manny {  let name = &amp;#34;manny&amp;#34;   func sayName() {  // print name  debugPrint(name)  }   class Klass {  // 内部类实现  }   struct Struct {  // 内部结构体实现  }   enum Enum {  // 内部枚举实现  } } 在上面代码中，类Manny是一个命名空间，类Klass声明在其中，在类Manny内部的代码可以直接看到并使用类Klass，但在Manny之外的代码不能直接看到和使用类Klass。
如果想要看到和使用在Manny内部声明的Klass，必须明确地使用命名空间的名字，以解除命名空间所代表的障碍。要做到这一点，需要先使用Manny的名字（它代表命名空间），然后是一个点，最后是Klass。简而言之，现在必须使用Manny.Klass来访问类Manny内部声明的Klass类：
class Manny {  let name = &amp;#34;manny&amp;#34;   func sayName() {  debugPrint(name)  }   class Klass {  func test() {  // ...  }  }   struct Struct {  // 内部结构体实现  }   enum Enum {  // 内部枚举实现  } }  struct Moe {  let name = &amp;#34;moe&amp;#34;   func sayName() {  debugPrint(name)  }   class Klass {  func test() {  // 使用命名空间来访问Klass  Manny.Klass().test()  }  }   struct Struct {  // 内部结构体实现  }   enum Enum {  // 内部枚举实现  } } 命名空间本身不提供秘密和隐私，它只提供一种便利性。在上面代码中，类Manny中定义了一个Klass类，同时在结构体Moe中也定义了一个Klass，但它们并不冲突。因为它们是定义在不同的命名空间中，如果有必要，可以使用Manny.Klass和Moe.Klass来进行区分。
实际上，message-sending消息发送允许我们看到不能直接看到的作用域。结构体Moe里面的代码不能直接看到Manny里面声明的Klass，但可以通过一个简单的步骤看到它，即Manny.Klass。这是因为Moe里的代码能看到类Manny，而Manny是在`Moe内部代码能看到的层次上声明的。
class Klass {  func test() {  Manny.Klass().test()  } } Modules 顶层的命名空间是module（模块）。App是一个module，因此也是一个命名空间，该命名空间的名称默认为应用程序的名字。若应用程序的名称为MyApp，并且在某个文件顶层声明一个类Manny，那么这个类的真实名字是MyApp.Manny。但通常不需要使用这个带前缀的真实名字，因为应用程序中的代码已经在同一个命名空间内，可以直接看到类Manny。
在当前文件中导入一个模块后，该模块内的所有顶层声明对于当前文件的代码都是可见的，因此不必显式地使用模块的名字来引用这些顶层声明。例如，Cocoa的Foundation框架是一个module，NSString是在Foundation顶层声明的。因此，当在代码中import Foundation后，可以直接使用NSString而不必使用Foundation.NSString这样带命名空间的真实名字。
实际上Swift本身也是在一个模块中定义的，即Swift module。但我们不必手动导入它，因为编译器总是隐含地导入了Swift module。也可以在文件中加入import Swift来显式地导入，但没必要这样做，因为编译器会提示module swift is already imported。
上面这个事实非常重要，因为它解释了一个重要的谜题：像debugPrint和print这样的函数到底是从哪里来的，为什么在任何地方都可以使用它们。debugPrint和print实际上是在Swift module顶层声明的一个函数，因为编译器已经隐含地导入了Swift模块，所以我们的代码可以直接看到Swift module所有的顶层声明，当然也包括debugPrint和print。
因此，debugPrint函数如同当前文件的其它顶层函数一样，也变成了一个普通的顶层函数，它对我们的代码来说是全局的。因此，可以直接使用它而不需要指定命名空间，也可以在使用的时候明确指定它的命名空间，即使用Swift.debugPrint(&amp;quot;hello&amp;quot;)，但通常不这样做，因为这样很冗余。
但是，你的应用程序模块可能会掩盖导入的任何其它模块的东西。也就是说，如果声明一个与导入模块中同名的东西，就会失去直接使用导入的东西而不用指定命名空间的神奇能力。假如在代码中声明一个同名的debugPrint函数，那么编译器将会自动隐藏Swift module中的debugPrint函数，即自定义代码中声明的debugPrint函数具有更高的优先级，为了调用Swift的debugPrint函数，现在必须明确地使用有命名空间，即Swift.debugPrint。
Swift.debugPrint(&amp;#34;test&amp;#34;) Instances 对象类型（类、结构和枚举）有一个重要的共同特点：它们可以被实例化。实际上，声明一个对象类型时，只是定义了一个类型，实例化是为了生成该类型的实例。
class Dog {  func bark() {  debugPrint(&amp;#34;woof&amp;#34;)  } } 上面的代码只是声明了Dog类型，即描述了如果有一只狗，它应该是什么样的，实际上目前还没有任何Dog对象。为了得到一只真正的Dog，必须制造一只，而制造一只真正的Dog的过程就是实例化Dog的过程。
在Swift中，实例的生成可以通过使用对象类型的名称作为函数名并调用该函数来实现（被称为初始化器）。当在一个对象类型的名称上加上圆括号时，就是在向该对象类型发送一种非常特殊的信息—实例化你自己（生成一个该类型的实例）。
let fido = Dog() 上面这段代码做了两件事，首先是实例化了Dog，得到了一个Dog实例。接着，把这个实例放到了一个名叫fido的盒子中。即声明了一个变量，并通过把Dog的实例赋值给它来完成初始化这个变量，现在fido是一个Dog的实例。
现在有一个Dog的实例，可以向它发送instance messages（实例消息），实例消息包括实例属性和实例方法。在对象类型的声明中，属性和方法默认是实例属性和实例方法，不能把它们作为该对象类型的消息来使用。如果想要发送实例消息，就必须先生成一个实例：
let fido = Dog() fido.bark() 如果想要发送类型消息，则需要声明为static或class函数，或者声明static或class属性。下面代码中声明了static和class属性和方法：
class Test {  /// static属性  static var test = &amp;#34;test&amp;#34;  /// class属性，不能为存储属性  class var name: String {  return &amp;#34;name&amp;#34;  }   /// static方法  static func testFunc() {  //  }   /// class 方法  class func nameFunc() {  //  }  } 在上面代码中用class声明name属性时只能为计算属性，不能声明为存储属性，否则会出现编译错误：Class stored properties not supported in classes; did you mean &#39;static&#39;?。
即使没有实例这样的东西，对象类型本身也是一个对象，因为可以向对象类型发送消息，Manny.Klass就是一个很好的例子。为什么会需要实例呢？这主要与实例属性的性质有关，实例属性的值是针对特定实例定义的，这就是实例真正有用和强大的地方。
class Dog {  var name = &amp;#34;&amp;#34;   func bark() {  debugPrint(&amp;#34;woof&amp;#34;)  } } 上面的声明之后，可以生成多个Dog实例，每一个Dog实例都有自己的name值。但多个实例的行为是相似的，它们都可以调用bark方法。
let dog1 = Dog() dog1.name = &amp;#34;Fido&amp;#34; var dog2 = Dog() dog2.name = &amp;#34;Rover&amp;#34;  print(dog1.name) // &amp;#34;Fido&amp;#34; print(dog2.name) // &amp;#34;Rover&amp;#34;  dog2 = dog1 print(dog2.name) // &amp;#34;Fido&amp;#34; 一个实例不仅对其属性的值负责，而且对其属性的生命周期负责。假设创建了一个Dog实例，并为它的name属性赋值为Fido。只要不将属性name的值替换为其它值，并且此实例一直存在，这个实例就会使字符串Fido保持活跃状态。
也就是说一个实例既是代码又是数据。实例的代码指的是它的类型声明，与该类型的所有实例共享。但数据只属于实例，只要实例持续存在，数据就可以持续存在，实例在每个时刻都有一个状态，即实例属性值完整集合。
一个类的声明实际上定义了一个命名空间。这个命名空间**要求其它对象使用额外的点标记来引用该空间内的内容**。命名空间本身并没有关闭任何可见性的大门，但访问权限private关键字可以。
The Keyword self 一个实例是一个对象，而对象是消息的接收者。因此，一个实例需要一种向自己发送消息的方法，这可以通过使用关键字self来实现。
class Dog {  var name = &amp;#34;name&amp;#34;  var whatADogSays = &amp;#34;woof&amp;#34;   func bark() {  debugPrint(self.whatADogSays)  }   func speak() {  self.bark()  } } 以小写字母开头的self仅出现在实例方法中，当在一个实例代码中使用self时，它指的是当前这个实例。如果表达式self.name出现在Dog实例方法中，这意味着当前Dog实例的name属性，也就是此时代码正在运行的那个。
在实例方法中使用self关键字是可选的，即是可以省略的。如果省略了信息接收者，而要发送的信息又可以发送给self，那么编译器默认会把self作为信息的接收者。
作为一个编码风格问题，显式地使用self或许是一个好习惯，因为省略self的代码更难阅读和理解。而且在有些情况下，必须显式使用self，所以显式的使用self或许更好。
Privacy 命名空间本身并未关闭任何可见性的大门，但这种可见性屏障有时是十分需要的。因为并非一个由实例存储的所有数据都是为了被另一个实例所改变，甚至有时要求对其它实例是不可见的。
也不是每个实例的方法都想要被其它实例调用。基于对象的编程语言通常都需要一种方法来赋予其对象成员以隐私——一种使其它对象更难看到这些属性和方法的方式。
一个类声明定义了一个命名空间。这个命名空间要求其他对象使用点操作符来引用命名空间内的内容。命名空间本身并不会关闭任何可见性之门，private关键字可以关闭这些可见性大门。
class Dog {  var name = &amp;#34;name&amp;#34;  var whatADogSays = &amp;#34;woof&amp;#34;   func bark() {  debugPrint(self.whatADogSays)  }   func speak() {  debugPrint(self.whatADogSays)  } } 在上面的声明中，其它对象可以更改实例属性whatADogSays。并且bark和speak方法都使用了该属性，一旦改变属性whatADogSays的值，则bark和speak方法中使用的值也会随之变化。下面代码中，当一个Dog实例调用bark方法时，它却说meow，这似乎有点不合理:
let fido = Dog() fido.whatADogSays = &amp;#34;meow&amp;#34; fido.bark() // meow 此时，我们可能想到把属性whatADogSays声明为常量，这样就没人可以修改它了。但这个带来了两个问题。第一，假设想要Dog的一个实例本身可以修改属性whatADogSays，此时需要将其声明为var，否则连实例本身也不能修改。
另外，假设除非调用bark和speak方法时，其他时候我们不想要任何其它对象知道这只Dog将会怎么叫。即使使用let声明，其他对象仍然可以读取whatADogSays的值。为了解决这个问题，Swift提供了private关键字。
为了避免whatADogSays属性被随意修改，可以用private限定只能被当前实例的方法修改，不能被实例直接修改，其他类型也看不到该属性。
class Dog {  var name = &amp;#34;&amp;#34;  private  var whatADogSays = &amp;#34;woof&amp;#34;   func bark() {  print(self.whatADogSays)  }   func speak() {  print(self.whatADogSays)  } } 现在whatADogSays是私有属性，它不能被其他类型的对象看到。Dog实例可以访问whatADogSays，但Cat实例中使用Dog实例时，不能访问属性whatADogSays：
class Cat {  func tryToChangeWhatADogSays() {  let fido = Dog()  fido.whatADogSays = &amp;#34;meow&amp;#34; // compile error: &amp;#39;whatADogSays&amp;#39; is inaccessible due to &amp;#39;private&amp;#39; protection level   } } Reserved Words 某些术语，如class和func和var和let和if以及private和import，在Swift中是保留的关键字。这意味着不能将它们用作标识符，如作为类、函数或变量的名字。如果尝试这样做，将会出现编译错误。如果需要强制将保留字成作为标识符，需要反引号将其括起来，下面这个代码看起来非常混乱，但是是合法的：
class `func` {  func `if`() {  let `class` = 1  } } 实例不是凭空产生的，必须实例化一个类型才能获得这个类型的一个实例。通常说来，程序中很大一部分操作是实例化类型。当然，你会希望这些实例持续存在，因此将每个新创建的实例赋值给一个变量，以保存、命名并赋予它生命周期。
functions 没有什么比声明和调用函数更能说明Swift的语法特点了。下面是一个简单有效的函数声明，它期望有两个Int入参，然后把它们加在一起：
func sum(_ x: Int, _ y: Int) -&amp;gt; Int {  let result = x &#43; y  return result } 函数声明的语法是非常严格和明确的，除非完全理解它，否则也就无法使用Swift。把上面函数的第一行拆分成几个部分，这样就可以单独地标记它们：
func sum ①  (_ x:Int, _ y:Int) ②③  -&amp;gt; Int { ④⑤  let result = x &#43; y ⑥  return result ⑦ }   函数定义以关键字func开始，后面跟着函数名，上面示例中的函数名是sum。函数名是函数调用必须使用的名称，即为了运行函数中所包含的代码必须使用函数名。
  函数名后面紧跟着参数列表，参数列表至少由一对圆括号组成。如果定义的函数需要参数，它们以逗号隔开列在圆括号内。每个参数都有严格的格式：外部参数名，空格，内部参数名，冒号，参数类型。
  上面的函数在参数名前有一个下划线和空格，下划线表示调用该函数时可以省略外部参数名。
  如果函数有返回值，在圆括号后面紧跟的将会是箭头运算符-&amp;gt;，在其后跟着的是函数返回类型。
  使用花括号把函数体（实际的可执行代码）括起来。
  在花括号里面，参数已经生效，其类型在参数列表中已经被指定。
  如果函数要返回一个值，它需要在函数体中使用关键字return（函数中仅有一行可以省略return语句），其后紧跟着返回值。该值的类型必须与先前在函数声明时的返回值类型相匹配。
  Parameters 上面定义的sum函数有两个参数：第一个是Int类型，名字是x，第二个也是Int类型，名字为y。事实上，参数x和y的定义只是为了让参数值在函数体中使用。
函数体中的代码不会运行，除非其它地方的代码调用此函数并为其参数传递指定类型的值。如果调用这个函数时没有传递参数，或者提供的值都不是Int，编译器将报错。
参数声明的意思大概是：我们正在声明x和y，以便在函数中使用它们。这些变量是函数的局部变量（或称为内部变量），只有在当前函数体中才可以看到它们，函数外便无法再使用，它们与可能在其他函数或更高层次范围内使用的任何其它同名的x和y均不同。
Return Value 在函数体中的关键字return其实做了两件事，首先是返回其后跟着的值，其次是结束当前函数的执行。虽然return语句之后可以包含其它代码，但这些代码不会被执行，并且还会产生编译警告。
在Swift 5.1前，在有返回值的函数中即使只有一条语句也必须显式使用return语句。但从Swift 5.1开始，有返回值的函数中如果只有一条语句时可以省略return关键字，这个特性主要是方便SwiftUI。
在函数声明花括号前的那一部分可以看成是一种契约，用于约定当前函数的输入和输出是怎么样的。根据这个契约，该函数期望有一定数量的入参，每个参数都有特定的类型，并产生一定类型的结果。因此，在函数调用时必须遵守这个契约。
花括号内的函数体将函数参数作为局部变量使用，关键字return后面的返回值类型必须与函数声明时的返回类型一致，否则会出现编译错误。
如果想要忽略函数的返回值，可以将函数调用的返回值分配给_（没有名称的变量）来消除编译器警告。例如，上面的sum调用可以如下使用：
_ = sum(4,5) 如果被调用的函数是自定义的，可以在函数声明的时候使用@discardableResult标记，表明这个返回值可以不处理，以消除编译警告：
@discardableResult func sum(_ x: Int, _ y: Int) -&amp;gt; Int {  let result = x &#43; y  return result } Void Return Type and Parameters 函数定义时没有规定一定需要返回值，如果一个函数定义时没有返回值，下面3种写法都是可行的，但是推荐使用第三种写法，即去掉Void或者()：
func say1(_ s: String) -&amp;gt; Void {  debugPrint(s) }  func say2(_ s: String) -&amp;gt; () {  debugPrint(s) }  func say3(_ s: String) {  debugPrint(s) } 若一个函数没有返回值，那么它的函数体中就不需要包含return语句。如果包含了return语句，那么它只能由return这个词单独组成，其目的纯粹是在当前位置上结束当前函数的执行。
函数定义时也没有规定一定需要参数。如果函数没有参数则参数列表为空，但此时也不能省略参数列表括号并且在函数调用时也不能省略括号（实际上有一种特殊情况可以省略函数调用时的圆括号）。
func greet() -&amp;gt; String {  return &amp;#34;howdy&amp;#34; } 因此，函数声明的时候可以同时没有参数和返回值：
func greet1() -&amp;gt; Void {  print(&amp;#34;howdy&amp;#34;) }  func greet2() -&amp;gt; () {  print(&amp;#34;howdy&amp;#34;) }  func greet3() {  print(&amp;#34;howdy&amp;#34;) } Function Signature 如果函数声明的时候忽略外部和内部参数名，可以通过输入和输出类型来完全描述一个函数的特征。为此，把参数类型写在参数列表括号里，后面是箭头运算符和输出类型：
(Int, Int) -&amp;gt; Int 上面是一个合法的表达式，表示接收两个Int类型参数并返回一个Int类型函数的签名。这个签名描述了所有具有这种顺序和数量的参数、类型、并返回这种类型的结果的函数。一个函数的签名实际上就是它的类型&amp;mdash;函数的类型。
一个函数的签名必须包括参数列表（不带内外参数名，只有参数类型）和返回类型，其中的参数列表和返回值都可以为空。一个不带参数和没有返回值的函数签名可以写成()-&amp;gt; Void或()-&amp;gt;()：
func newTest(completion: @escaping () -&amp;gt; ()) {  completion() }  func newTest2(completion: @escaping () -&amp;gt; Void) {  completion() } External Parameter Names 一个函数可以外化其参数名称，在调用函数的时候使用这个参数名称，这个名称被称为外部参数名或外部参数标签。外部参数名称也是函数名称的一部分，并且必须作为参数的标签出现在对该函数的调用中。外部参数标签有如下作用：
  它阐明了每个参数的目的，一个参数标签（外部参数）可以提供一个线索，说明该参数如何影响该函数。
  它将一个函数与另一个函数区分开来：两个在圆括号前具有相同名称和相同签名的函数，但具有不同的外部参数名称，是两个不同的函数「这个有待考证😂」。
  外部参数标签有助于Swift与Objective-C和Cocoa对接，在这两个地方，方法的参数几乎都有外部名称。
  外部参数名在Swift中非常常见，以至于有一条规则：默认情况下，所有参数名都会自动外部化，即使用内部名称作为其外部名称。如果想改变这种默认行为，有两种方式：
  如果想要参数的外部名称和内部名称不同，需要在内部名称前加一个外部名称并以空格分隔开，调用的时候就可以使用此外部参数名。
  如果需要去除一个参数的外部名称，则需要在内部名称前加上下划线和一个空格，此表示不使用外部参数，调用该函数时可以省略该参数名。
func echoString(_ s: String, times: Int) -&amp;gt; String {  var result = &amp;#34;&amp;#34;  for _ in 1...times {  result &#43;= s  }  return result } 上面的函数中，第一个参数只有内部名称，第二个参数既有内部名称也有外部名称，并且他们的名称相同，即times。
  外部名称的存在**并不意味着调用可以使用与声明不同的参数顺序**。下面的echo(string:times:)需要一个String参数和一个Int参数，必须按此顺序调用：
func echo(string s: String, times n: Int) -&amp;gt; String {  var result = &amp;#34;&amp;#34;  for _ in 1...n {  result &#43;= s  }  return result } Overloading 在Swift中函数重载是合法的，这意味着两个函数具有相同的名字（包括相同的外部参数名称），但有着不同的函数签名是可以共存的。需要注意的是，两个基本名称（函数名）相同但外部参数名称不同的函数并不构成重载，它们是两个名称不同的函数「有些地方说这也是一种重载，个人看来也是合理的」。
重载之所以有效是因为Swift进行严格的类型区分。Swift可以在函数声明和函数调用时把重载函数区分出来。因此，Swift清楚地知道say(&amp;quot;what&amp;quot;)和say(1)是不同的。
需要注意的是重载也适用于函数的返回类型。两个具有相同名称和参数的函数可以有不同的返回类型。但调用时的上下文必须明确，即必须清楚调用者期望的返回类型，否则编译器会报错。下面两个重载函数是可以并存的：
func say() -&amp;gt; String {  return &amp;#34;one&amp;#34; }  func say() -&amp;gt; Int {  return 1 } 如果在调用的时候直接使用let result = say()会发生编译错误，因为编译器还不知道要调用哪个函数。因此，如果有返回类型重载的函数调用时必须明确指定返回类型：
let result: String = say() let test: Int = say() 上下文本身可能会消除歧义。假设有另一个没有重载的函数，它需要一个字符串参数，那么就可以直接使用giveMeAString(say())：
func giveMeAString(_ s: String) {  print(&amp;#34;thanks!&amp;#34;) } giveMeAString(say()) let result = say() &#43; &amp;#34;two&amp;#34; 在say() &#43; &amp;quot;two&amp;quot;中，因为只有字符串才能和字符串相加，所以此时say()只能返回字符串。也可以在函数调用时使用方法名和关键字as以及所需方法的签名来明确区分重载。这个语法看起来有点奇怪，因为**整个表达式必须用两对圆括号括起来，其中第一对圆括号表示类型转换，最后的一对圆括号表明这是一个函数调用**:
let result = (say as () -&amp;gt; String)() Default Parameter Values 参数可以有默认值（缺省值），这意味着对于**有默认值的参数调用者可以完全省略该参数，不提供任何值**。如果有默认值的参数在调用时省略该参数，表示使用默认值。如果要在函数声明中指定一个缺省值，只需在参数类型后面追加上=和缺省值即可：
class Dog {  func say(_ s: String, times: Int = 1) {  for _ in 1 ... times {  debugPrint(s)  }  } } 实际上，上面的say相当于两个函数。其中一个只有一个未标记的参数func say(_ s: String)，并且在函数体中times=1；另一个既有未标记的参数也有一个times参数func say(_ s: String, times: Int)。
Variadic Parameters 在函数中同类型的参数个数是可变的，即调用者可以根据需要提供该参数类型的多个值，用逗号隔开。实际上，函数体将以数组形式接收这些值。要在函数声明中表明一个参数是可变的，只需要在类型后面加上三个点：
func sayStrings(_ arrayOfStrings: String ...) {  for s in arrayOfStrings {  debugPrint(s)  } } sayStrings(&amp;#34;34&amp;#34;,&amp;#34;456&amp;#34;,&amp;#34;678&amp;#34;,&amp;#34;9899&amp;#34;) 其它参数可以跟在可变参数后面，但它必须有一个外部标签来标识可变参数在调用中的结束位置。全局的print和debugPrint函数第一个参数实际上是可变的，所以可以一次打印多个值。debugPrint函数中还有一些默认参数，这些参数确定了输出的细节：默认的分隔符(输出多个值时的分隔符号)是一个空格，默认的终止符是一个换行符，可以在调用的时候改变其中之一或全部：
public func print(_ items: Any..., separator: String = &amp;#34; &amp;#34;, terminator: String = &amp;#34;\n&amp;#34;) public func debugPrint(_ items: Any..., separator: String = &amp;#34; &amp;#34;, terminator: String = &amp;#34;\n&amp;#34;) 在Swift 5.3之前，一个函数至多可以声明一个可变参数，但从Swift 5.4开始这个限制被移除了,一个函数可以有多个可变参数。下面的testVariadicParameters有4个可变参数。因为每个可变参数在函数内部都以数组的形式接受的，所以打印出来也是数组形式：
func testVariadicParameters(first: String..., second: String..., third: Int..., forth: [String]...) {  debugPrint(first)  debugPrint(second)  debugPrint(third)  debugPrint(forth) }  testVariadicParameters(first: &amp;#34;1&amp;#34;, &amp;#34;2&amp;#34;, &amp;#34;3&amp;#34;, second: &amp;#34;name&amp;#34;, &amp;#34;This&amp;#34;, &amp;#34;true&amp;#34;, third: 1, 2, 45, 89, forth: [&amp;#34;TT&amp;#34;], [&amp;#34;KK&amp;#34;])  [&amp;#34;1&amp;#34;, &amp;#34;2&amp;#34;, &amp;#34;3&amp;#34;] [&amp;#34;name&amp;#34;, &amp;#34;This&amp;#34;, &amp;#34;true&amp;#34;] [1, 2, 45, 89] [[&amp;#34;TT&amp;#34;], [&amp;#34;KK&amp;#34;]] 如果第2个可变参数没有和第一个可变参数相邻，那么可以不需要外部参数名：
func sayStrings(_ array: String..., other: String, _ array2: String...) {  for s in array {  print(s)  }  print(other)  for s in array2 {  print(s)  } } sayStrings(&amp;#34;Manny&amp;#34;, &amp;#34;Moe&amp;#34;, &amp;#34;Jack&amp;#34;, other: &amp;#34;Matt&amp;#34;, &amp;#34;Groucho&amp;#34;, &amp;#34;Harpo&amp;#34;, &amp;#34;Chico&amp;#34;) 不幸的是，Swift语言中存在一个漏洞：无法将数组转换为以逗号分隔的参数列表（类似于Ruby中的 splatting）。如果使用的是某种类型的数组，那么不能在需要该类型的可变参数的地方使用它。
Ignored Parameters 如同外部参数一样，如果**内部参数名称为下划线，则说明该内部参数名称会被忽略**。即使省略了内部参数，函数调用者也必须提供实参，但它在函数体中没有内部名字。在下面的例子中，内部参数名字已经省略，也就是说无法使用这个参数，因此使用外部参数名会出现编译错误：
func say(_ s: String, test times: Int, loudly _: Bool) {  debugPrint(s)  debugPrint(times)  debugPrint(loudly) // Cannot find &amp;#39;loudly&amp;#39; in scope  debugPrint(test) // Cannot find &amp;#39;test&amp;#39; in scope }  say(&amp;#34;test&amp;#34;, test:12, loudly: false) Modifiable Parameters 在函数内的参数，本质上是一个局部变量。默认情况下（不声明为inout时）函数参数是用let隐式声明的常量。因为函数内的参数是常量，所以不能对它进行赋值操作：
func say(_ s: String, times: Int, loudly: Bool) {  loudly = true // compile error  } 如果在函数体内需要对参数进行赋值，你可能想到的一种方式是声明一个同名的变量，然后将参数的值赋值给刚定义的变量，这样就可以改变值：
func say(_ s: String, times: Int, loudly: Bool) {  var loudly = loudly  loudly = true // local var } 但上面只是改变新定义的本地loudly变量，不会改变传进来入参loudly的值。如果想要改变函数传进来实参的值，需要按如下方式进行：
  参数的类型必须声明为inout，关键字inout放在类型前面。
  调用函数时，传入的实参必须是用var声明的，而不能是let声明，因为只有用var声明的变量才能被改变。
  调用函数时，传入的必须是实参的地址，而不是实参本身，即需要在变量名前加&amp;amp;符号。
  func say(_ s: String, times: Int, loudly: inout Bool) {  loudly = true } var loudly = false say(&amp;#34;test&amp;#34;, times: 1, loudly: &amp;amp;loudly) 当调用带有inout参数的函数时，始终设置其地址作为参数传递给该参数的变量，即使该函数没有对该参数进行任何更改。
有一种常见的情况是，在函数体中可以修改参数的值而不必把它声明为inout。当参数是一个类的实例时，可以直接修改实例的值，这是类的一个特殊功能，与其他两种对象类型（枚举和结构体）不同。
class Dog {  var name = &amp;#34;&amp;#34; }  func changeName(of d: Dog, to newName: String) {  d.name = newName }  let d = Dog() d.name = &amp;#34;Fido&amp;#34;  debugPrint(d.name) // &amp;#34;Fido&amp;#34; changeName(of: d, to: &amp;#34;Rover&amp;#34;) debugPrint(d.name) // &amp;#34;Rover&amp;#34; 在上面的例子中changeName函数的第一个参数并没有声明为inout，但在函数体中确实改变了Dog的实例d的属性。虽然传入的实参是用let声明的，但也能改变类实例的属性name，这说明**类的实例本身是可变的**。
从技术上讲，我们说类是引用类型，而其他类型的对象则是值类型。当把一个结构体的实例作为参数传递给一个函数时，实际上是得到了该结构体实例的一个副本。但是，当把一个类的实例作为参数传递给一个函数时，传递的是该类实例本身的引用。
class A {  var name = &amp;#34;A&amp;#34; } struct B {  var name = &amp;#34;B&amp;#34; }  var a: A = A() {  didSet {  debugPrint(oldValue)  } }  var b: B = B() {  didSet {  debugPrint(oldValue)  } }  a.name = &amp;#34;aaa&amp;#34; b.name = &amp;#34;bbb&amp;#34; // Command.B(name: &amp;#34;B&amp;#34;) 上面代码改变类的实例a的name属性时didSet没有调用，而改变结构体的实例b的属性name时，didSet调用了，说明生成了一个结构体实例副本。
Calling Objective-C with Modifiable Parameters 当使用Cocoa时，可能会遇到该模式的变化。Cocoa API是用C和Objective-C编写的，因此可能会看到一些神秘的类型，例如UnsafeMutablePointer，而不是Swift中的inout。然而，作为调用者的角度来看，这是同一件事：你将准备一个var变量并传递其地址。
例如，UIColor的RGBA成分的问题，它由四个成分：红色、绿色、蓝色和alpha值。给定UIColor的函数返回该颜色的成分，需要一次返回四个值——这是Objective-C无法做到的。UIColor方法getRed(_:green:blue:alpha:)返回一个布尔值，以说明是否提取成功：
func getRed(_ red: UnsafeMutablePointer&amp;lt;CGFloat&amp;gt;, green: UnsafeMutablePointer&amp;lt;CGFloat&amp;gt;, blue: UnsafeMutablePointer&amp;lt;CGFloat&amp;gt;, alpha: UnsafeMutablePointer&amp;lt;CGFloat&amp;gt;) -&amp;gt; Bool let c = UIColor.purple var r : CGFloat = 0 var g : CGFloat = 0 var b : CGFloat = 0 var a : CGFloat = 0 c.getRed(&amp;amp;r, green: &amp;amp;g, blue: &amp;amp;b, alpha: &amp;amp;a) // now r, g, b, a are 0.5, 0.0, 0.5, 1.0 Called by Objective-C with Modifiable Parameters 有时Cocoa想要使用UnsafeMutablePointer参数调用Swift函数，用到的技术是赋值UnsafeMutablePointer的指针属性。
func popoverPresentationController(_ popoverPresentationController: UIPopoverPresentationController, willRepositionPopoverTo rect: UnsafeMutablePointer&amp;lt;CGRect&amp;gt;, in view: AutoreleasingUnsafeMutablePointer&amp;lt;UIView&amp;gt;) {  view.pointee = self.button2  rect.pointee = self.button2.bounds } Function in Function 函数可以在任何地方声明，在函数体中声明函数也是合法的。声明在函数内的函数称为本地函数（内部函数），它可以被同一范围内的后续（本地函数声明后）代码所调用，但在其它地方完全不可见。
对于那些唯一目的是协助另一个函数的函数来说，内部函数是一种优雅的架构。如果只有函数A需要调用函数B，那么函数B还不如打包在函数A里面。
func checkPair(_ p1: Piece, and p2: Piece) -&amp;gt; Path? {  // ...  func addPathIfValid(_ midpt1: Point, _ midpt2: Point) {  // ...  }  for y in -1 ... _yct {  addPathIfValid((p1.x, y), (p2.x, y))  }  for x in -1 ... _xct {  addPathIfValid((x, p1.y), (x, p2.y))  }  // ... } 内部函数实际上是一个局部变量，其类型是函数类型。因此，一个**局部函数不能与同一作用域中的局部变量同名，并且两个局部函数也不能在同一作用域中同名**。此限制已经被移除，两个同名的内部函数，但签名不同时可以共存：
func test1() {  debugPrint(&amp;#34;test1&amp;#34;) } func test1(x: Int) {  debugPrint(x) } Recursion 在函数中调用自己的函数被称为递归函数。递归可能会产生无限循环，所以需要在递归函数中写出正确的终止逻辑，防止无限递归下去，导致内存占用过高，手机发烫：
func countDownFrom(_ ix: Int) {  debugPrint(ix)  if ix &amp;gt; 0 { // stopper  countDownFrom(ix - 1) // recurse  } }  countDownFrom(5) // 5, 4, 3, 2, 1, 0 Function as Value 在Swift中函数是一等公民，这意味着任何使用值的地方都可以使用函数。即一个函数可以被赋值给一个变量，能够将一个函数作为另一个函数调用的参数被传递，也可以将其作为另一个函数的返回值。
Swift是强类型的语言，当函数作为值传递时，必须类型相匹配，实际上函数的签名就是它的类型。为了使函数类型更简洁，可以使用typealias给一个函数类型起个别名，这个名字可以是描述性的：
// 函数类型别名 typealias VoidVoidFunction = () -&amp;gt; Void  func doTest(test: VoidVoidFunction) {  test() }  doTest {  debugPrint(&amp;#34;doTest 1&amp;#34;) }  doTest() {  debugPrint(&amp;#34;doTest 2&amp;#34;) } 使用一个函数作为值的主要目的是**可以在尚不确定函数具体是什么的情况下调用该函数**。下面示例代码是一个极简单的例子，只是为了展示函数作为值使用时的结构和语法：
func doThis(_ f: () -&amp;gt; Void) {  f() } 上面doThis函数接受一个参数，未返回任何值。它通过f()来调用它接受的函数参数。所以doThis仅是一个调用另一个函数的简单函数。但它这样做时事先并不知道要调用什么函数，这就是函数作为一等公民的力量。在声明了doThis这个函数后，需要把一个函数作为参数传给它才能调用：
typealias VoidVoidFunction = () -&amp;gt; Void func dothis(_ f: VoidVoidFunction) {  f() }  func doThis(_ f: () -&amp;gt; Void) {  f() }  func whatToDo() {  debugPrint(&amp;#34;I did it&amp;#34;) }  doThis(whatToDo) //I did it 为了使函数类型更清晰，可以利用Swift的类型别名特性为函数类型命名。该名称可以是描述性的，并且避免了可能令人困惑的箭头运算符：
typealias VoidVoidFunction = () -&amp;gt; ()  func dothis(_ f: VoidVoidFunction) {  f() } Anonymous Functions 下面代码中，声明函数whatToAnimate和whatToDoLater只是为了调用UIView.animate时作为参数传递。其实并不一定需要whatToAnimate和whatToDoLater这两个函数名字，因为它们只是在代码最后一行使用了，之后便没有再使用了：
func whatToAnimate() {  debugPrint(&amp;#34;animations&amp;#34;) }  func whatToDoLater(finished: Bool) {  debugPrint(&amp;#34;finished: \(finished)&amp;#34;) }  UIView.animate(withDuration: 0.4, animations: whatToAnimate, completion: whatToDoLater) //open class func animate(withDuration duration: TimeInterval, animations: @escaping () -&amp;gt; Void, completion: ((Bool) -&amp;gt; Void)? = nil) 在调用UIView.animate(withDuration:animations:completion:)方法时如果只传递函数体，不专门声明一个带名字的函数，将会更简洁。
一个*无名的函数体被称为匿名函数*，这在Swift中匿名函数十分常见。要形成一个匿名函数，需要做以下两件事：
 首先，创建一个函数体，即一对花括号(此时无需加函数声明，即不使用func xxx)。 接着，如果有必要，将函数的参数列表和返回类型作为花括号内的第一件事来表达，然后是关键字in：  { () -&amp;gt; () in  debugPrint(&amp;#34;animations&amp;#34;) }  { (finished: Bool) -&amp;gt; () in  debugPrint(&amp;#34;finished: \(finished)&amp;#34;) } Using Anonymous Functions Inline 知道怎么创建匿名函数，就可以使用它们了。在UIView.animate调用时可以创建匿名函数，并作为参数传递：
UIView.animate(withDuration: 0.4,  animations: { () -&amp;gt; () in  self.myButton.frame.origin.y &#43;= 20  },  completion: {  (finished: Bool) -&amp;gt; () in  print(&amp;#34;finished: \(finished)&amp;#34;)  } ) 对于imageOfSize函数，也可以使用匿名函数：
func drawing() {  let p = UIBezierPath(roundedRect: CGRect(x: 0, y: 0, width: 45, height: 20), cornerRadius: 8)  p.stroke() } let image = imageOfSize(CGSize(width: 45, height: 20), drawing) let image = imageOfSize(CGSize(width: 45, height: 20), { () -&amp;gt; () in  let p = UIBezierPath(roundedRect: CGRect(x: 0, y: 0, width: 45, height: 20), cornerRadius: 8)  p.stroke() }) Anonymous Function Abbreviated Syntax 匿名函数在Swift中很常见，也很重要，所以Swift提供了一些创建匿名函数的便捷方式。
省略返回值类型和箭头操作符 如果编译器已经知道匿名函数的返回值，则可以省略箭头操作符和返回值类型：
UIView.animate(withDuration: 0.4, animations: { () in // 省略了箭头操作符和返回值类型Void  debugPrint(&amp;#34;animations&amp;#34;) }, completion: { (finished: Bool) in // 省略了箭头操作符和返回值类型  debugPrint(&amp;#34;finished: \(finished)&amp;#34;) })  func testName(count: Int, test: (Int) -&amp;gt; String) {  debugPrint(test(count)) }  testName(count: 3) { (count: Int) in // 省略了箭头操作符和返回值类型String  return &amp;#34;test:\(count)&amp;#34; }  debugPrint({ (count: Int) in // 省略了箭头操作符和返回值类型String，这里使用了define&amp;amp;call  return &amp;#34;\(count)&amp;#34; }(13)) // 13  func doThis(completion: @escaping () -&amp;gt; String) {  completion() }  doThis() { () in // 省略了箭头操作符和返回值类型String  return &amp;#34;doThis&amp;#34; } 编译器有时可能无法准确推断出匿名函数的返回类型，此时会出现编译错误。如果出现这种情况，就不能使用这种省略箭头操作符和返回值的便捷方式，而应该提供一个具有箭头和返回值类型的in表达式。
无参数时省略in关键字 如果一个匿名函数没有参数，并且箭头操作符和返回类型（是一起的）可以省略，那么关键字in也可以省略。下面代码中传递给animations的匿名函数省略了返回类型和in关键字:
UIView.animate(withDuration: 0.4, animations: {  // 没有参数省略了箭头操作符和返回值类型以及in关键字  debugPrint(&amp;#34;animations&amp;#34;) }, completion: { (finished: Bool) in  debugPrint(&amp;#34;finished: \(finished)&amp;#34;) })  func doThis(completion: @escaping () -&amp;gt; String) {  completion() }  doThis() { () // 无参数，有返回值 省略了关键关键字in  return &amp;#34;doThis&amp;#34; } 省略参数类型 如果匿名函数有参数，并且*编译器已经知道参数的类型，则匿名函数中参数的类型可以省略*。下面代码中传递给completion的匿名函数省略了参数类型，即Bool：
UIView.animate(withDuration: 0.4, animations: {  debugPrint(&amp;#34;animations&amp;#34;) }, completion: { (finished) in // 省略了参数类型  debugPrint(&amp;#34;finished: \(finished)&amp;#34;) })  func testName(count: Int, test: (Int) -&amp;gt; String) {  debugPrint(test(count)) }  testName(count: 2) { (count) in // 省略了参数类型和返回值类型  return &amp;#34;test:\(count)&amp;#34; }  debugPrint({ (count) in // 省略了参数类型和返回值类型  return &amp;#34;\(count)&amp;#34; }(13)) // 13 省略参数列表圆括号 如果*匿名函数的参数类型可以省略，那么参数列表的圆括号也可以省略*。下面代码中传递给completion的匿名函数，既省略了参数类型也省略了圆括号：
UIView.animate(withDuration: 0.4, animations: {  debugPrint(&amp;#34;animations&amp;#34;) }, completion: { finished in // 省略了参数类型和参数列表圆括号以及返回值类型  debugPrint(&amp;#34;finished: \(finished)&amp;#34;) })  func testName(count: Int, test: (Int) -&amp;gt; String) {  debugPrint(test(count)) }  testName(count: 2) { count in // 省略了参数类型和参数列表圆括号以及返回值类型  return &amp;#34;test:\(count)&amp;#34; }  debugPrint({ count in // 省略了参数类型和参数列表圆括号以及返回值类型  return &amp;#34;\(count)&amp;#34; }(13)) // 13 有参数列表省略in表达式 如果匿名函数的返回类型可以省略，并且编译器已经知道参数的类型，也可以省略in表达式。在匿名函数体中可以直接引用参数，$0表示第一个参数，$1表示第二个参数，依此类推：
UIView.animate(withDuration: 0.4, animations: {  debugPrint(&amp;#34;animations&amp;#34;) }, completion: {  debugPrint(&amp;#34;finished: \($0)&amp;#34;) })  func testName(count: Int, test: (Int) -&amp;gt; String) {  debugPrint(test(count)) }  testName(count: 2) {  return &amp;#34;test:\($0)&amp;#34; }  debugPrint({  return &amp;#34;\($0)&amp;#34; }(13)) // 13 省略参数名 如果匿名函数不需要使用参数，则可以在in表达式的参数列表中*用下划线代替其名称，表示在匿名函数中不使用该参数*。下面代码中，传递给completion的匿名函数，使用下划线代替了参数名：
UIView.animate(withDuration: 0.4, animations: {  debugPrint(&amp;#34;animations&amp;#34;) }, completion: { _ in // *  debugPrint(&amp;#34;finished!&amp;#34;) }) 如果一个匿名函数有参数，可以省略in表达式，使用$0,$1...来使用参数。或者可以保留in表达式，给参数命名，或者用下划线忽略它们。但不能省略in表达式而不使用参数的魔法名称$0,$1，一旦这样做了，代码将无法通过编译。
省略函数标签 如果匿名函数是函数调用中传递的最后一个参数。可以*在最后一个参数之前用右括号来关闭函数调用，然后只放匿名函数体，不放任何标签*，这就是尾部闭包语法：
UIView.animate(withDuration: 0.4, animations: {  debugPrint(&amp;#34;animations&amp;#34;) }) { _ in  debugPrint(&amp;#34;finished!&amp;#34;) } 在上面代码中，因为completion:是方法中的最后一个参数，所以可以在调用的括号外传递匿名函数，使用不带标签的尾部闭包语法。但是，实际上animate函数中接受两个函数参数，animations也是匿名函数，但它依然在括号里。
从Swift 5.3开始，多个匿名函数参数可以使用尾部闭包语法。当这样做时，第一个匿名函数不需要标签，但其余的函数都需要它们的标签：
UIView.animate(withDuration: 0.4) {  debugPrint(&amp;#34;animations&amp;#34;) } completion: { _ in  debugPrint(&amp;#34;finished!&amp;#34;) } 省略函数调用圆括号 如果使用了尾部闭包，并且如果所调用的函数除了传递给它的函数之外没有其它函数参数，可以从调用中省略圆括号。这是唯一可以从函数调用中省略圆括号的情况：
// 只有一个参数，该参数是函数类型 func doThis(_ f: () -&amp;gt; Void) {  f() }  doThis { // 省略调用圆括号  debugPrint(&amp;#34;Howdy&amp;#34;) }  // 有其它非函数类型参数，并最后一个参数是函数类型 func doThis(name: String, _ f: () -&amp;gt; Void) {  f() }  doThis(name: &amp;#34;trr&amp;#34;) { // 省略调用圆括号  debugPrint(&amp;#34;Howdy&amp;#34;) } 省略return关键字 如果匿名函数体恰好只由一个语句组成，并且该语句包含返回一个带有关键字return的值，实际上关键字return是可以省略的：
func greeting() -&amp;gt; String {  return &amp;#34;Howdy&amp;#34; }  func performAndPrint(_ f: () -&amp;gt; String) {  let s = f()  print(s) }  performAndPrint {  greeting() // meaning: return greeting() } 在编写匿名函数时，会经常发现已经利用了所有允许的省略写法。此外，有时会通过将整个匿名函数与函数调用放在一行中来缩短代码行数。因此，涉及匿名函数的Swift代码可以非常紧凑：
let arr = [2, 4, 6, 8] let arr2 = arr.map {$0*2} Define and Call 在Swift中，常见的模式是定义一个匿名函数并调用它。如下所示，花括号定义了一个匿名函数体，圆括号表示调用该匿名函数，此结构被称为定义和调用（define-and-call）：
{ // ... code goes here }() 使用define-and-call，可以在真正需要的时候采取行动，而不是事先做一系列准备工作。例如，有一个常见场景，创建和配置NSMutableParagraphStyle实例，然后将它作为参数调用NSMutableAttributedString的实例方法addAttribute(_:value:range:)，如下所示：
let para = NSMutableParagraphStyle() para.headIndent = 10 para.firstLineHeadIndent = 10 // ... more configuration of para ...  // content is an NSMutableAttributedString content.addAttribute(  .paragraphStyle,  value: para,  range: NSRange(location: 0, length: 1)) 上面的代码看起来很丑。实际上，para是在调用addAttribute(_:value:range:)时将它作为value:参数传递进去的，因此在调用时再创建和配置会更好。这看起来像是需要使用匿名函数的场景，除了value:参数不是一个函数，而是一个NSMutableParagraphStyle对象。
可以使用define-and-call解决上面问题，即使用一个产生NSMutableParagraphStyle对象的匿名函数，并立即调用它传递作为value的实参：
let content = NSMutableAttributedString() content.addAttribute(.paragraphStyle, value: {  let para = NSMutableParagraphStyle()  para.headIndent = 10  para.firstLineHeadIndent = 10  // ... more configuration of para ... return para  return para }(), range: NSRange(location: 0, length: content.length)) Closures Just like functions, closures enable us to define a group of code statements that can be called as one unit, which can both accept input and produce output. The difference, however, is that closures can be defined inline — right at the point where we want to use them —which is incredibly useful in a number of different situations.
Closures can both be stored as properties and local variables, and can also be passed as arguments to functions (or other closures).
Swift的函数都是闭包，这意味着在**函数内可以捕获在函数体外的外部变量**。下面代码中，函数bark可以看到在其函数体外声明的变量和函数：
class Dog {  var whatThisDogSays = &amp;#34;woof&amp;#34;  func bark() {  print(self.whatThisDogSays)  } }  对于上面的bark函数来说，whatThisDogSays是一个外部变量，因为它是在bark函数体之外声明的，但*它的作用域仍在bark函数体内*，因此bark函数内的代码可以看到它。 函数体内的代码引用了外部变量whatThisDogSays。  函数bark是可以作为值传递的。也就是说，它可以从一种环境传递到另一种环境。当这种事情发生时，对于whatThisDogSays的引用会发生什么？先来看一下下面代码：
func doThis(_ f: () -&amp;gt; ()) {  f() }  let d = Dog() d.whatThisDogSays = &amp;#34;arf&amp;#34; let barkFunction = d.bark doThis(barkFunction) // 打印结果arf 上面打印的结果看起来是正常的，但是我们没有直接调用d.dark，而是创建了一个Dog的实例，并把它的bark方法作为值传doThis函数作为参数，在doThis中，方法bark被调用。
whatThisDogSays是Dog的实例属性，在函数doThis中并没有whatThisDogSays引用。事实上，在doThis函数中也没有Dog的实例，但f()调用仍然正常。函数d.bark，当它被传递的时候，显然是把变量whatThisDogSays一起传递的。
更进一步，改变上面这个例子，把设置d.whatThisDogSays的那一行移到把d.bark赋值给变量barkFunction之后，如下所示：
func doThis(_ f: () -&amp;gt; ()) {  f() }  let d = Dog() let barkFunction = d.bark doThis(barkFunction) // woof d.whatThisDogSays = &amp;#34;arf&amp;#34; doThis(barkFunction) // arf 当创建了Dog的实例d和变量barkFunction，更改d的属性也会改变barkFunction的输出。显然当d.bark赋值给barkFunction后，实例d和barkFunction都持有对同一个Dog实例的引用。
这是因为*赋值给barkFunction的d.bark引用了self，也就是Dog实例*。当说函数是一个闭包并且捕获在函数体中引用的外部变量时，就是上面的意思。
func delay(by seconds: TimeInterval,  on queue: DispatchQueue = .main,  closure: @escaping () -&amp;gt; Void) {  queue.asyncAfter(  deadline: .now() &#43; seconds,  execute: closure  ) } How Closures Improve Code 可以使用函数是闭包这一事实让代码变得更通用。为了说明函数是闭包，使用之前的一个示例，它接受绘图指令并执行以生成图像：
func imageOfSize(_ size: CGSize, _ whatToDraw: () -&amp;gt; ()) -&amp;gt; UIImage {  UIGraphicsBeginImageContextWithOptions(size, false, 0)  whatToDraw()  let result = UIGraphicsGetImageFromCurrentImageContext()!  UIGraphicsEndImageContext()  return result } 以尾闭包的方式调用上面的函数：
let image = imageOfSize(CGSize(width: 45, height: 20)) {  let p = UIBezierPath(roundedRect: CGRect(x: 0, y: 0, width: 45, height: 20), cornerRadius: 8)  p.stroke() } 上面代码调用创建了给定大小的并包含指定大小圆角的图片。但上面包含了重复代码，即CGSize(width:45, height:20)重复了两次。为了防止重复，可以在一开始就把size放到一个变量中：
let sz = CGSize(width: 45, height: 20) let image = imageOfSize(sz) {  let p = UIBezierPath(roundedRect: CGRect(origin: CGPoint.zero, size: sz), cornerRadius: 8)  p.stroke() } 在上面的代码中，常量sz是在比匿名函数更高层次声明的，因此在匿名函数中能够看见和引用它。但需要注意的是，匿名函数只是一个函数体，如果imageOfSize不调用，匿名函数就不会被执行。
当在函数体内的表达式CGRect(origin:CGPoint.zero, size:sz)中引用sz时，因为函数体是一个闭包，现在捕获了它的值。
当函数imageOfSize调用whatToDraw时，whatToDraw变成了一个函数，函数体内引用了变量sz，这是没有问题，尽管在imageOfSize附近没有sz。
再进一步，到目前为止我们一直在硬编码所需圆角矩形的大小。不过，我们经常要创建各种大小的圆角矩形图像。那么将上面代码打包成一个函数是有意义的，其中sz不是一个固定值，而是一个入参，然后该函数将返回一个图像：
func makeRoundedRectangle(_ sz: CGSize) -&amp;gt; UIImage {  let image = imageOfSize(sz) {  let p = UIBezierPath(roundedRect: CGRect(origin: CGPoint.zero, size: sz), cornerRadius: 8)  p.stroke()  }  return image } 在上面的makeRoundedRectangle函数中，参数sz不再是硬编码值（固定值），事先我们并不知道它将会是什么。当调用makeRoundedRectangle时，sz将会有一个值，并且在匿名函数会捕获sz，所以当imageOfSize调用匿名函数时，匿名函数内的sz的值和传递给makeRoundedRectangle的值一样。
上面的代码变得非常紧凑。要调用makeRoundedRectangle，先提供size，然后返回图像。可以一次完成调用、获取图像并显示该图像：
self.iv.image = makeRoundedRectangle(CGSize(width:45, height:20)) Function Returning Function 实际上可以更进一步，相比于返回一个图像，函数可以返回一个生成指定大小圆角矩形图片的函数。函数可以用作值，我们已经将一个函数作为参数传递给另一个函数。
相似地，函数也可以返回函数，现在我们将从函数调用后接收一个函数作为其结果，也就是返回一个生成指定大小圆角矩形图片的函数：
func makeRoundedRectangleMaker(_ sz: CGSize) -&amp;gt; () -&amp;gt; UIImage { ①  func f() -&amp;gt; UIImage { ②  let im = imageOfSize(sz) {  let p = UIBezierPath(roundedRect: CGRect(origin: CGPoint.zero, size: sz), cornerRadius: 8)  p.stroke()  }  return im  }  return f ③ }   函数makeRoundedRectangleMaker的类型（签名）到底是什么？它是(CGSize) -&amp;gt; () -&amp;gt; UIImage。该表达式有两个箭头运算符，需要注意的是每个箭头运算符之后的所有内容都是一个返回值类型。因此上面的函数接受一个参数CGSize，并且返回一个签名为() -&amp;gt; UIImage的函数。
  在函数makeRoundedRectangleMaker内第一步是定义一个函数（内部函数），这个内部函数没有入参，返回一个UIImage，并将这个函数命名为f。这个函数的工作方式既简单又熟悉：它调用imageOfSize，传递给它一个匿名函数，该函数生成一个圆角矩形的图像，然后返回该图像。
  最后，返回内部函数f。也就是履行了之前的约定：makeRoundedRectangleMaker将返回一个不带参数并返回一个UIImage的函数。
  但是，也许你仍然会对makeRoundedRectangleMaker感到惊讶，不知道该怎么使用它，如果调用他们会得到什么。让我们尝试一下，如果按照下面这样做会得到什么：
let maker = makeRoundedRectangleMaker(CGSize(width:45, height:20)) 该代码运行后的变量maker的是什么？它是一个函数，是一个不带参数的函数，当它被调用时，会生成一个大小为(45,20)的圆角矩形的图像。可以通过调用maker来证实这一点：
let maker = makeRoundedRectangleMaker(CGSize(width:45, height:20)) self.iv.image = maker() 再次将注意力转向makeRoundedRectangleMaker函数的实现，编写makeRoundedRectangleMaker不是为了说明一个函数可以返回一个函数。而是为了说明闭包，让我们思考一下environment是如何被捕获的。
func makeRoundedRectangleMaker(_ sz: CGSize) -&amp;gt; () -&amp;gt; UIImage {   func f() -&amp;gt; UIImage {  let im = imageOfSize(sz) {  let p = UIBezierPath(roundedRect: CGRect(origin: CGPoint.zero, size: sz),  cornerRadius: 8)  p.stroke()  }  return im  }  return f } 函数f没有参数。但是，在f的函数体内却两次引用了sz。在函数f内部可以看到sz，即外部函数makeRoundedRectangleMaker的入参。函数f在makeRoundedRectangleMaker被调用时捕获了sz，并在f返回并赋值给maker时保留该引用：
let maker = makeRoundedRectangleMaker(CGSize(width:45, height:20)) 这就是为什么maker现在是一个函数，当它被调用时，创建和返回了size为(45,20)的图片，生成图像大小值已被纳入到maker中。
从另一角度，makeRoundedRectangleMaker是一个工厂函数，用于创建类似于maker的系列函数，每个函数都生成一个特定大小的图像。这个函数说明了闭包的力量。
实际上，可以以更Swiftier的方式重写makeRoundedRectangleMaker，在函数f中，没有必要创建im变量，可以直接返回imageOfSize：
func makeRoundedRectangleMaker(_ sz: CGSize) -&amp;gt; () -&amp;gt; UIImage {  func f() -&amp;gt; UIImage {  return imageOfSize(sz) {  let p = UIBezierPath(roundedRect: CGRect(origin: CGPoint.zero, size: sz), cornerRadius: 8)  p.stroke()  }  }  return f } 实际上也没有必要声明f，然后再返回f，可以直接返回匿名函数：
func makeRoundedRectangleMaker(_ sz: CGSize) -&amp;gt; () -&amp;gt; UIImage {  return {  return imageOfSize(sz) {  let p = UIBezierPath(roundedRect: CGRect(origin: CGPoint.zero, size: sz), cornerRadius: 8)  p.stroke()  }  } } 但在上面的匿名函数中除了一个return语句，没有其它语句。imageOfSize中的匿名函数参数由多个语句组成，但imageOfSize调用本身仍然只是一个语句。因此可以省略imageOfSize前的return关键字：
func makeRoundedRectangleMaker(_ sz: CGSize) -&amp;gt; () -&amp;gt; UIImage {  return {  imageOfSize(sz) {  let p = UIBezierPath(roundedRect: CGRect(origin: CGPoint.zero, size: sz), cornerRadius: 8)  p.stroke()  }  } } 实际上，也可以省略最后的那个return，但不建议这样做，因为这样看起来很不直观：
func makeRoundedRectangleMaker(_ sz: CGSize) -&amp;gt; () -&amp;gt; UIImage {  {  imageOfSize(sz) {  let p = UIBezierPath(roundedRect: CGRect(origin: CGPoint.zero, size: sz), cornerRadius: 8)  p.stroke()  }  } } Closure Setting a Captured Variable 闭包通过其捕捉环境的能力所获得的力量比目前为止所展示的还要强大。如果闭包能够捕获一个外部变量的引用，并且该变量是可设置的，则闭包可以设置该变量：
func pass100(_ f: (Int) -&amp;gt; ()) {  f(100) }  var x = 0 print(x) // 0 func setX(newX: Int) {  x = newX }  pass100(setX) print(x) // 100 上面的代码中，因为传入到pass100中的函数setX包含了x，不仅包含它，而且能够捕获它，并且修改了x的值。函数pass100函数能够像直接调用setX一样轻松地设置x。
Closure Preserving Captured Environment When a closure captures its environment, it preserves that environment even if nothing else does.
当一个闭包捕获它所在的环境，即使其它什么都不做，闭包也会保留该环境。下面是一个让你大吃一惊的例子：一个修改函数的函数：
func countAdder(_ f: @escaping () -&amp;gt; ()) -&amp;gt; () -&amp;gt; () {  var ct = 0  return {  ct = ct &#43; 1  print(&amp;#34;count is \(ct)&amp;#34;)  f()  } } 上面的函数countAdder接受一个函数入参（使用@escaping标记），并且返回一个函数作为调用它的结果。它返回的函数调用它接收的函数参数，并做了额外工作：它增加一个变量并报告结果。所以现在试着猜测当运行下面这段代码时会发生什么：
func greet() {  print(&amp;#34;howdy&amp;#34;) }  let countedGreet = countAdder(greet) countedGreet()  countedGreet()  countedGreet()  // 运行结果 count is 1 howdy count is 2 howdy count is 3 howdy 上面定义了一个函数greet，在这个函数中打印howdy。函数countAdder返回一个新函数，我们将其命名为countedGreet。然后调用countedGreet 三次，以下是控制台打印的内容：
count is 1 howdy count is 2 howdy count is 3 howdy 显然，countAdder已经为传递给它的函数添加了报告调用次数的能力。维持这个计数的变量到底在哪里？在countAdder中，ct是一个局部变量，它并未声明在匿名函数内部，这是故意的。如果它在匿名函数中声明，那么每次调用countedGreet时ct将被设置为0，将不会正常计数。
相反ct声明在匿名函数外，只被初始化为0一次，然后被匿名函数捕获。这个变量作为countedGreet环境的一部分被保存下来（它在countedGreet之外的某个神秘的保留变量的环境世界中），所以每次countedGreet被调用时它都能被递增。
一个值在闭包中被捕获，这意味着在代码块被执行前，代码块都能引用这些值。
Escaping Closures A closure is supposed to be no escaping when the closure is passed as an argument to the function, and is called before the function returns. The closure isn’t used outside of the function.
A closure is said to escape a function when the closure is passed as an argument to the function, but is called after the function returns.
如果将一个作为值传递的函数被保存供以后某个时刻执行，而不是立即调用它，那么它是一个随时间推移捕获并保存其环境的闭包。这样的闭包被称为逃逸闭包(escaping closure)。
换句话说，说一个闭包逃逸了，就是在传入闭包的方法结束之前该闭包还没有被调用。在编写异步代码时经常会出现这种情况。
在某些情况下，闭包的类型必须标记为escaping。编译器会检测违反这个规则的情况，如果对于是否需要加escaping有疑惑，不必担心，只要让编译器检查并提示添加就可以了。
下面函数是合法的，无需标记为escaping。因为**它接受一个函数作为参数，并且在函数内直接调用了这个函数**，即funcCaller方法结束之前会调用f：
func funcCaller(f: () -&amp;gt; ()) {  f() } 下面函数也是合法的，尽管它返回一个稍后执行的函数，但**它是在函数内部创建了那个匿名函数**，而不是作为参数传递进来的。它返回的函数是一个逃逸闭包，但函数返回值的类型不必标记为@escaping，也就是说@escaping标记只针对于入参：
func funcMaker() -&amp;gt; () -&amp;gt; () {  // 内部创建的匿名函数  return {  print(&amp;#34;hello world&amp;#34;)  } } 但是，下面的函数是不合法的，会出现编译错误。因为它接受了一个函数作为入参，并且返回了这个函数供后续某个时刻执行：
func funcPasser(f: () -&amp;gt; ()) -&amp;gt; () -&amp;gt; () {  return f }  // 出现如下的编译错误 Using non-escaping parameter &amp;#39;f&amp;#39; in a context expecting an @escaping closure 解决方案是将函数入参标f记为@escaping，编译器也会提醒需要这样做：
func funcPasser(f: @escaping () -&amp;gt; ()) -&amp;gt; () -&amp;gt; () {  return f } 逃逸闭包的第二个特点是当在函数体内引用self的属性或方法时，编译器会坚持需要明确地使用self。那是因为这样的引用捕获了self，编译器希望通过使用self来承认这个事实：
let f1 = funcPasser {  print(view.bounds) // Implicit use of &amp;#39;self&amp;#39; in closure; use &amp;#39;self.&amp;#39; to make capture semantics explicit }  let f2 = funcPasser {  print(self.view.bounds) // ok } Capture Lists 有时，可能希望一个函数引用外部的变量，只是为了获取它的值，但不捕获该变量。Swift提供了一种巧妙的语法来做到这一点，但这种方式**仅限于函数是匿名函数时**才能使用。在匿名函数体的开头，放置方括号，里面包含对外部环境中变量的引用的逗号分隔列表，这称为捕获列表。
如果在匿名函数中有一个捕获列表，那么必须在它后面加上关键字in。如果已经存在in表达式，则捕获列表位于参数名称之前即可。
捕获列表就好像这些值已作为参数而不是通过闭包捕获传递给匿名函数一样。这就像是用let声明的参数一样。首先看一下没有捕获列表的情况：
var x = 0 let f: () -&amp;gt; () = {  print(x) } f() // 0  x = 1  f() // 1 在上面的函数中，由于捕获到了变量的值，那么打印的值分别是0和1。而在下面的代码中，因为添加了捕获列表，下面代码执行两次打印的值均为0:
var x = 0 let f: () -&amp;gt; () = { [x] in  print(x) } f() // 0  x = 1  f() // 0 因为使用了捕获列表，f在声明时已经将变量x的值捕获为0。实际上，x的行为类似于传递给f的普通参数，它是一个常量。
另一种方式去验证这个，就是如果f尝试设置x的值，编译器会出现：Cannot assign to value: &amp;lsquo;x&amp;rsquo; is an immutable capture错误：
var x = 0 let f: () -&amp;gt; () = { [x] in  x = 5 // Cannot assign to value: &amp;#39;x&amp;#39; is an immutable capture  print(x) } 对捕获列表中的值重命名也是合法的。捕获列表可以使用[y=x]来重命名捕获的值，这种方式好像将x作为参数传递给匿名函数，但现在该参数的名称为y。当原始名称有问题时，或者当要传入的值是需要在赋值的时候被计算时，这种方式很有用：
var x = 0 let f: () -&amp;gt; () = { [ y = x] in  print(x0) } f() // 0  x = 1  f() // 0 下面代码中，使用捕获的变量计算出一个新的常量y，计算的时机发生在f定义时，因此不管在定义后x是否被重新赋值，y的计算都是在f定义的时候：
var x = 0 let f: () -&amp;gt; () = { [ y = x &#43; 5] in  print(x0) } f() // 5  x = 1  f() // 5   var x = 0 // 函数f定义的时候就捕获到了x的值 let f: () -&amp;gt; () = { [ y = x &#43; 5] in  print(x0) }  // 此时改变x的值，对闭包没有作用 x = 1  f() // 5 作为参数传递给registerUndo的匿名函数是一个逃逸闭包。捕获列表声明了一个常量oldCenter并将其值设置为self.center。因此，self.center的值在闭包定义时就立即进行求值，而不是稍后在调用匿名函数本身时再进行求值（此时 self.center的值可能已经被更改了）。
self.undoer.registerUndo(withTarget: self) { [oldCenter = self.center] myself in  myself.setCenterUndoably(oldCenter) } 捕获列表的另一个用途是解决在逃逸闭包中需要明确添加self关键字的硬性要求。下面代码中，需要明确地添加self，因为这是一个逃逸闭包。但是很多人不喜欢明确地使用self，如果这个匿名函数多次隐含地使用self，则可能需要多次明确地使用self。
let f2 = funcPasser {  print(self.view.bounds) } 从Swift 5.3开始，可以把self放在捕获列表中，这能够满足编译器的要求，并且也不必明确使用self来访问属性和方法，即可以省略self：
let f2 = funcPasser { [self] in  print(view.bounds) // ok  } 在闭包中也可以直接使用weak接收外部变量 ，不仅仅是self:
download(imageURL, completion: { [weak imageViewController] result in  // ... })  download(imageURL, completion: { [weak imageViewController, weak imageFinalizer] result in  // ... }) weak strong unowned ARC是一个编译时功能，它是苹果的自动内存管理工具，代表的是自动引用计数Automatic Reference Counting，这意味着只有当对象的强引用计数为零时，对象才能被释放出内存。
强引用本质上是一个普通的引用，但它本身很特别，因为它通过增加引用计数来保护被引用的对象不被释放。强引用在Swift中几乎随处可见。
事实上，声明一个属性默认就是强引用的。 一般来说，当对象的层次关系是线性的，使用强引用就是安全的。也就是说，当强引用的层次结构总是从上到下时，使用强引用总是安全的。
class Kraken {  // strong reference to child.  let tentacle = Tentacle() }  class Tentacle {  // strong reference to child  let sucker = Sucker() }  class Sucker {  // } 上面示例是一个线性层次结构。Kraken的定义中对Tentacle实例的引用是一个强引用，并且Tentacle对Sucker实例的引用也是强引用。这个层次结构从Kraken一直到Sucker。
同样地，在动画的blocks中，引用的层次也是相似的。因为animateWithDuration是UIView静态方法，下面的闭包是parent，self是child：
UIView.animate(withDuration: 0.3) {  self.view.alpha = 0.0 } 弱引用只是一个指向对象的指针，它不保护指向的对象不被ARC释放。强引用会使对象的引用计数增加1，但弱引用不会增加计数。
此外，当对象被成功被释放时，弱引用会自动被置为nil。这确保了当访问弱引用时，要么访问的是一个有效的对象，要么是nil。
在Swift中，所有的弱引用都不是常量，并且是optional的，因为当不再有任何强引用这个对象时，弱引用终将被置为nil。下面代码编译时会出现&#39;weak&#39; must be a mutable variable, because it may change at runtime错误：
class Kraken {  // let is a constant! All weak variables MUST be mutable.  weak let tentacle = Tentacle() } 上面代码中tentacle被定义为一个常量，它在初始化后不能再被赋值。因为如果没有持有这个对象的强引用后，那么弱引用就会被置为nil，所以Swift编译器要求在定义弱变量时使用var，而不能使用let。
在可能存在循环引用（retain cycles）的场景，应当使用弱变量。循环引用是指两个对象相互强引用对方。如果两个对象之间存在强引用，ARC将不会在每个实例上生成适当的释放信息代码，因为它们在保持彼此的生命：
如果变量是在闭包的作用域之外声明的，那么在闭包的作用域内引用该变量就会对该对象产生另一个强引用。唯一的例外是使用值语义的变量，如Swift中的Int、String、Array和Dictionary。
首先来看下面代码：
class Kraken {  var notificationObserver: ((Notification) -&amp;gt; Void)?  init() {  notificationObserver = NotificationCenter.default.addObserver(forName: &amp;#34;humanEnteredKrakensLair&amp;#34;, object: nil, queue: .main) { notification in  self.eatHuman()  }  }   deinit {  NotificationCenter.default.removeObserver(notificationObserver)  } } 上面代码产生了一个循环引用。notificationObserver持有闭包，当调用eatHuman时，在这个闭包中会捕获到self，并强持有它。最好的方法是在deinit函数中清理通知观察者，但deinit不会被ARC调用，因为闭包中有一个对Kraken实例的强引用。
其它可能发生这种情况是在使用NSTimers和NSThread的地方。修复方法是在闭包的捕获列表中使用一个对self的弱引用，这能够打破强引用循环：
let closure = { [weak self] in  self?.doSomething() //Remember, all weak variables are Optionals! } 为什么对self的弱引用在方括号内，这看起来很奇怪。在Swift中，看到方括号就会想到数组。可以在闭包中指定多个捕获值：
//Look at that sweet, sweet Array of capture values. let closure = { [weak self, unowned krakenInstance] in  // weak variables are Optionals!  self?.doSomething()  // unowned variables are not.  krakenInstance.eatMoreHumans() } 这看起来更像一个数组。所以，现在理解为什么捕获值要放在方括号里了。通过在闭包的捕获列表中添加[weak self]可以修复上面的循环引用问题：
NotificationCenter.default.addObserver(forName: &amp;#34;humanEnteredKrakensLair&amp;#34;, object: nil, queue: .main) { [weak self] notification in //The retain cycle is fixed by using capture lists!  self?.eatHuman() //self is now an optional! } 需要使用weak和unowned的另一个地方是使用协议在类之间应用代理，因为类是引用类型，所以可能出现循环引用。在Swift中结构体和枚举也可以遵循协议，但它们是值语义，不会出现循环引用。
class Kraken: LossOfLimbDelegate {  let tentacle = Tentacle()   init() {  tentacle.delegate = self  }   func limbHasBeenLost() {  startCrying()  }   func startCrying() {  //  }   deinit {  debugPrint(&amp;#34;Kraken&amp;#34;)  } }  protocol LossOfLimbDelegate {  func limbHasBeenLost() }  class Tentacle {  var delegate: LossOfLimbDelegate?   func cutOffTentacle() {  delegate?.limbHasBeenLost()  }   deinit {  debugPrint(&amp;#34;Tentacle&amp;#34;)  } }  lef f = {  let k1 = Kraken() } 在上面代码中，Tentacle以代理属性的方式强持有了Kraken。与此同时，Kraken中也以属性的方式强引用了Tentacle实例。在上面的场景中，定义delegate属性时，使用weak即可破解这种循环引用：
weak var delegate: LossOfLimbDelegate? 但是，加上weak后会编译出现错误&#39;weak&#39; must not be applied to non-class-bound &#39;any LossOfLimbDelegate&#39;; consider adding a protocol conformance that has a class bound。这种情况，必须限定协议的遵循者，让协议继承class。
// The protocol now inherits class protocol LossOfLimbDelegate: class {  func limbHasBeenLost() }  Using &amp;#39;class&amp;#39; keyword to define a class-constrained protocol is deprecated; use &amp;#39;AnyObject&amp;#39; instead  protocol LossOfLimbDelegate: AnyObject {  func limbHasBeenLost() } Use a class-only protocol when the behavior defined by that protocol’s requirements assumes or requires that a conforming type has reference semantics rather than value semantics
使用weak和unowned大致相同，但还是有些区别。unowned和weak引用，都不会增加引用对象的强引用计数。在Swift中unowned引用有一个额外的好处，它确保捕获的引用的对象不是一个可选对象，这使得在使用捕获的引用前不用判断它是否为nil。
此外，unowned引用是不会被置为nil的，这意味着当对象被释放时，不会将引用自动置为nil。也就是说在某些情况下，使用unowned引用，可能会导致指针悬空的情况。
弱引用和无主引用都不会增加强引用次数。它们都可以被用来打破循环引用。那么，我们什么时候使用它们呢？根据苹果的文档：
Use a weak reference whenever it is valid for that reference to become nil at some point during its lifetime. Conversely, use an unowned reference when you know that the reference will never be nil once it has been set during initialization.
如同隐式解包optional类型，如果能够保证引用在使用的时候不会被置为nil，就可以使用unowned来解除循环引用，否则就需要使用weak来解除循环引用。
class RetainCycle {  var closure: (() -&amp;gt; Void)!  var string = &amp;#34;Hello&amp;#34;   init() {  closure = {  self.string = &amp;#34;Hello, World!&amp;#34;  debugPrint(self.string)  }  }   deinit {  debugPrint(&amp;#34;deinit RetainCycle&amp;#34;)  } }   let f1 = {  // Initialize the class and activate the retain cycle.  let retainCycleInstance = RetainCycle()  // At this point we can guarantee the captured self inside the closure will not be nil.  // Any further code after this (especially code that alters self&amp;#39;s reference) needs to be judged on whether or not unowned still works here.  retainCycleInstance.closure() }  f1() 在上面例子中，闭包中捕获了self，并且是强引用的。而在RetainCycle中，强引用了closure闭包。此时，可以使用[unowned self]来打破循环引用：
closure = { [unowned self] in  self.string = &amp;#34;Hello, World!&amp;#34; } 上面这种情况我们假设了self不会被置为nil，这是因为生成RetainCycle实例后，立即调用了它的属性closure闭包。
Define a capture in a closure as an unowned reference when the closure and the instance it captures will always refer to each other, and will always be deallocated at the same time
如果知道这个引用将被正确清除，并且两个引用彼此相互依赖（一个不能没有另一个），那么应该优先选择unowned而不是weak：
class Kraken {  let petName = &amp;#34;Krakey-poo&amp;#34;  lazy var businessCardName: () -&amp;gt; String = { [unowned self] in  return &amp;#34;Mr. Kraken AKA &amp;#34; &#43; self.petName  } } 在上面代码中，使用unowned self 解决循环引用问题。Kraken在它的生命周期内持有businessCardName闭包，同时businessCardName闭包在它的生命周期内也持有Karaken。它们是相互依赖的，所以它们总是在同一时间被删除。但千万不能与lazy属性中使用define-and-call相混淆：
class Kraken {  let petName = &amp;#34;Krakey-poo&amp;#34;  lazy var businessCardName: String = {  return &amp;#34;Mr. Kraken AKA &amp;#34; &#43; self.petName  }() } 在上面定义中，unowned self是不需要的。因为实际上没有任何东西持有生成lazy属性的闭包，只是将闭包生成的结果赋值给属性，并在第一次使用后立即清除闭包（并会减去捕获self的强引用计数）。
class Kraken2 {  let petName = &amp;#34;Krakey-poo&amp;#34;  lazy var businessCardName: String = {  return &amp;#34;Mr. Kraken AKA &amp;#34; &#43; self.petName  }()   init() {  debugPrint(&amp;#34;Create Kraken2&amp;#34;)  }  deinit {  debugPrint(&amp;#34;Kraken2&amp;#34;)  } }  var kraken: Kraken2? = Kraken2() kraken = Kraken2() kraken?.businessCardName kraken = nil  // 执行后的结果，两个实例都正常释放了 &amp;#34;Create Kraken2&amp;#34; &amp;#34;Create Kraken2&amp;#34; &amp;#34;Kraken2&amp;#34; &amp;#34;Kraken2&amp;#34; 参考资料
Implicit capturing 当定义一个逃逸闭包时，即一个闭包要么被存储在一个属性中，要么被另一个逃逸闭包所捕获。逃逸闭包将隐含地捕获任何在其内被引用的对象、值和函数。由于这样的闭包可能会在后面某个时间点被执行，它们需要保持对其所有依赖关系的强引用，以防止它们在此期间被释放。
Whenever we’re defining an escaping closure — that is, a closure that either gets stored in a property, or captured by another escaping closure — it’ll implicitly capture any objects, values and functions that are referenced within it. Since such closures may be executed at a later time, they need to maintain strong references to all of their dependencies in order to prevent them from being deallocated in the meantime.
在下面代码中，延迟了几秒钟执行闭包，所以当闭包实际运行时，presenter视图控制器有可能已经从应用程序的视图层次中删除了。虽然在这种情况下，这不会是一场灾难，但可以说，只有当视图控制器仍然被其它对象（大概是其父视图控制器或窗口）保留时，才应该显示确认按钮。
func presentDelayedConfirmation(in presenter: UIViewController) {  let queue = DispatchQueue.main   queue.asyncAfter(deadline: .now() &#43; 3) {  let alert = UIAlertController(  title: &amp;#34;...&amp;#34;,  message: &amp;#34;...&amp;#34;,  preferredStyle: .alert  )   // By simply refering to &amp;#39;presenter&amp;#39; here, our closure  // will automatically capture that instance, and retain  // it until the closure itself gets released from memory:  presenter.present(alert, animated: true)  } } 这就是捕获列表的作用，它使我们能够自定义一个给定的闭包如何捕获它所指向的任何对象或值。使用捕获列表，可以指示上面的闭包以弱引用方式捕获presenter视图控制器，而不是强方式（这是默认的）。
这样，如果presenter不被代码中的其它部分引用，视图控制器就会被释放，从而使内存更快地被释放，并且也不会有非必要的操作被执行：
func presentDelayedConfirmation(in presenter: UIViewController) {  let queue = DispatchQueue.main   // A capture list is defined using a set of square brackets  // directly following a closure&amp;#39;s opening curly bracket:  queue.asyncAfter(deadline: .now() &#43; 3) { [weak presenter] in  // Here we verify that our presenter is still in memory,  // otherwise we can return early:  guard let presenter = presenter else { return }   let alert = UIAlertController(  title: &amp;#34;...&amp;#34;,  message: &amp;#34;...&amp;#34;,  preferredStyle: .alert  )   presenter.present(alert, animated: true)  } } 当需要引用self时，捕获列表也许更加有用，特别是在闭包中引用self会导致循环引用时。循环引用是指两个对象或闭包互相引用，这会导致它们都被释放（因为它们不能达到强引用计数为零）。
在下面代码中使用捕获列表来避免在闭包中强引用self：
class UserModelController {  let storage: UserStorage  private var user: User { didSet { userDidChange() } }   init(user: User, storage: UserStorage) {  self.storage = storage  self.user = user   storage.addObserver(forID: user.id) { [weak self] user in  self?.user = user  }  } } 如果不使用weak捕获self，上述的闭包最终会导致一个循环引用。因为self持有了storage，在storage中也持有了self。
Weak references are not always the answer 虽然上面的两个示例代码可能会让人觉得使用[weak self]总是正确的方式，但事实绝对不是这样。像其它的内存管理一样，必须仔细考虑在每种情况下如何使用self，以及希望每个逃逸的闭包在内存中保留多长时间。
如果处理的是非常短暂的闭包，比如传递给UIView.animate 的闭包（这些代码只是为了执行动画，然后被释放），捕获self不是问题，而且代码也更容易阅读：
extension ProductViewController {  func expandImageView() {  UIView.animate(withDuration: 0.3) {  self.imageView.frame = self.view.bounds  self.showImageCloseButton()  }  } } 请注意，当在一个逃逸闭包中访问实例方法和属性时，总是需要明确地引用self。这是一件好事，因为它要求我们做出明确的决定来捕获self，并考虑这样做可能产生的后果。
还有许多种情况，我们可能希望保留self甚至更长的时间。例如，如果当前对象被要求执行一个闭包的工作，就像下面这样：
extension NetworkingController {  func makeImageUploadingTask(for image: Image) -&amp;gt; Task {  Task { handler in  let request = Request(  endpoint: .imageUpload,  payload: image  )   // The current NetworkingController is required here,  // so for as long the returned task is retained,  // we&amp;#39;ll also retain its underlying controller:  self.perform(request, then: handler)  }  } } 上述代码不会导致任何循环引用，因为NetworkingController引用它所创建的任务。
还可以直接捕获一个闭包的每个依赖项，而不只是捕获self（同样使用捕获列表）。例如，在这里我们捕获了一个图片加载器的缓存属性，以便在图片被成功下载后能够使用它：
class ImageLoader {  private let cache = Cache&amp;lt;URL, Image&amp;gt;()   func loadImage(  from url: URL,  then handler: @escaping (Result&amp;lt;Image, Error&amp;gt;) -&amp;gt; Void  ) {  // Here we capture our image loader&amp;#39;s cache without  // capturing &amp;#39;self&amp;#39;, and without having to deal with  // any optionals or weak references:  request(url) { [cache] result in  do {  let image = try result.decodedAsImage()  cache.insert(image, forKey: url)  handler(.success(image))  } catch {  handler(.failure(error))  }  }  } } 当涉及到闭包捕获列表时，值类型的处理有时会比较复杂，因为它们是作为副本而不是作为引用传递给外部作用域的。尽管这正是 Swift 值类型的强大之处，但在下面这种情况下，它可能会产生一些意想不到的后果。在下面代码，一个按钮的handler赋值一个闭包时会捕获sender和message属性：
class MessageComposerViewController: UIViewController {  private let sender: MessageSender  private var message = Message()  private lazy var sendButton = ActionButton()   ...   override func viewDidLoad() {  super.viewDidLoad()   ...   sendButton.handler = { [sender, message] in  sender.send(message)  }  } } 乍一看，上面代码没什么问题。然而，Message类型是作为一个结构体来实现的，所以它是值语义的。这意味着我们在将其添加到捕获列表时只是捕获其当前值。因此，即使该值在视图控制器的生命周期中可能发生变化，一旦sendButton被点击，仍然会使用捕获到的原始值。
解决上述问题的一个方法，同时仍然避免任何额外的防护语句，就是只捕获self，以便能够访问它的message属性，然后将该值直接映射到发送方的发送方法，像下面这样：
sendButton.handler = { [weak self, sender] in  let message = self?.message  message.map(sender.send) } 但是，上面实际上只有在处理可变值时才会出现问题。如果只是处理常量，像下面的例子一样，那么可以毫无问题地将这些属性添加到任何闭包的捕获列表中（因为它们的值不会改变）：
class ProductViewController: UIViewController {  private let productManager: ProductManager  private let product: Product   ...   override func viewDidLoad() {  super.viewDidLoad()   ...   buyButton.handler = { [productManager, product] in  productManager.startCheckout(for: product)  }  } } 最后，让我们来看看当涉及到局部变量时，值是如何被捕获的。与基于值的属性捕获方式相反，局部变量在被同一作用域内的闭包捕获时，仍然保持着与原始声明的联系。这对于跟踪各种状态来说是非常有用的。
例如，假设想扩展 Swift 的 Collection 协议，使我们能够使用由当前元素和下一个元素组成的缓冲区来迭代任何集合。这可以通过将标准库的AnySequence和AnyIterator类型与本地捕获的值相结合来实现：
extension Collection {  typealias Buffer = (current: Element, next: Element?)   var buffered: AnySequence&amp;lt;Buffer&amp;gt; {  AnySequence { () -&amp;gt; AnyIterator&amp;lt;Buffer&amp;gt; in  // We define our state as local variables:  var iterator = self.makeIterator()  var next: Element?   return AnyIterator { () -&amp;gt; Buffer? in  // We can then use our state to make decisions by  // capturing them within our iterator&amp;#39;s closure:  guard let current = next ?? iterator.next() else {  return nil  }   next = iterator.next()  return (current, next)  }  }  } } 也就是说，当使用捕获列表捕获时，数值会被复制，而当直接引用时，它们不会被复制。例如，当作为属性访问时，或者当一个局部变量在它被定义的同一范围内被捕获时。
如同弱引用一样，unowned也只能应用于引用类型。它的效果与强制解包optional类型一样，因为它让我们把弱引用当作非optional的，如果相应的对象被释放了，再通过unowned访问会出现闪退。
class UserModelController {  ...   init(user: User, storage: UserStorage) {  ...   storage.addObserver(forID: user.id) { [unowned self] user in  self.user = user  }  } } 虽然使用unowned可以让我们摆脱optional的nil判断，某种程度上来说也是非常方便的。但当引用悬空的时候，会出现闪退。这就使得它相当危险。
参考资料
curried function 当一个函数返回一个带参数的函数，那么它被称为curried函数（以计算机科学家Haskell Curry命名）。下面是一个curried函数。
func makeRoundedRectangleMaker(_ sz: CGSize) -&amp;gt; (CGFloat) -&amp;gt; UIImage {  return { r in  imageOfSize(sz) {  let p = UIBezierPath(roundedRect: CGRect(origin: CGPoint.zero, size: sz), cornerRadius: r)  p.stroke()  }  } } 在上面的curried函数中，返回一个入参为CGFloat类型，返回类型为UIImage的方法。如果使用一个变量来接收该函数，调用该函数的时候需要传入一个参数：
let maker = makeRoundedRectangleMaker(CGSize(width:45, height:20)) self.iv.image = maker(8) 如果上面定义的maker没有在其它地方使用，上面的代码可以合并为一行：
self.iv.image = makeRoundedRectangleMaker(CGSize(width:45, height:20))(8) Function References and Selectors 如果想通过名字引用一个函数，可能是为了将其作为参数传递给另一个函数。在Swift中，通常可以使用函数的裸名bare name来实现这一点。函数的bare name指的是函数名字（只包括函数名字不包含其它）。下面代码中whatToAnimate和whatToDoLater都是函数的bare name：
func whatToAnimate() {  debugPrint(&amp;#34;animations&amp;#34;) }  func whatToDoLater(finished: Bool) {  debugPrint(&amp;#34;finished: \(finished)&amp;#34;) }  UIView.animate(withDuration: 0.4, animations: whatToAnimate, completion: whatToDoLater) 在上面的代码中whatToAnimate和whatToDoLater也是函数的引用。它只由函数的名字组成，也就是func关键字后，参数列表括号前的那个函数名。没有圆括号表明这是一个引用，而不是一个调用。
在没有歧义的情况下，使用bare name作为函数的引用是合法的。上面的代码中，在这个特定的上下文中只有一个叫whatToDoLater的函数，因此能在一个参数类型已知的函数调用中使用bare name作为参数。
我们既可以将函数作为参数传递，也可以将函数赋值给一个变量或者常量。下面的代码中，定义了两个相同名字的函数，一个接受参数，一个不接受参数，直接使用bark可能会产生歧义：
class Dog {  func bark() {  debugPrint(&amp;#34;woof&amp;#34;)  }   func bark(_ loudly: Bool) {  if loudly {  debugPrint(&amp;#34;WOOF&amp;#34;)  } else {  bark()  }  }   func test() {  let barkFunction = bark // compile error   } } 上面的代码将会出现编译错误，因为同时存在两个名为bark的函数，此时编译器不清楚到底要引用哪个。为了解决这个问题，Swift提供了一种表示法，它可以更精确地引用函数，标注包含两个部分：
  full name:此处翻译为全名，对于有参数的函数的全名包括函数的名字，一对圆括号，以及外部参数列表，其中**外部参数列表使用冒号(没有逗号或空格)**。如果外部参数被suppressed（即定义的时候使用下划线），则使用下划线代替。对于没有参数的函数的全名就是它的bare name。
  签名: 一个函数的签名可以用关键字as作用到其bare name或full name上。
  例如，函数func say(_ s:String, times:Int) {...}可以使用全名say(_:times:)来标注，也可使用bare name和签名:say as (String, Int) -&amp;gt; ()来标注。
在上面的代码中，如果使用let barkFunction = bark(_:) 编译器就不会报错，因为已经指定了函数bark为接受一个参数的那个。
但如果要引用无参数的bark函数，因为无参的那个函数的裸名和全名均为bark（不包括圆括号，无参数的函数加上圆括号就是函数调用了），直接使用仍然会报错，因为编译器无法区分要引用哪个函数，此时应该使用as和函数签名：
class Dog {  func bark() {  debugPrint(&amp;#34;woof&amp;#34;)  }   func bark(_ loudly: Bool) {  if loudly {  debugPrint(&amp;#34;WOOF&amp;#34;)  } else {  bark()  }  }   func test() {  let barkFunction = bark as () -&amp;gt; () // 使用函数签名  } } 下面的代码中，定义了三个bark函数，其中有两个都接受一个参数，并且外部参数名都被省略了。如果此时使用let barkFunction = bark(_:)仍然会出现编译错误，因为编译器无法确定要调用哪个bark，因为此时有两个带参数的bark，它们的fullname均为bark(_:)：
class Dog {  func bark() {  //  }   func bark(_ loudly: Bool) {  //  }   func bark(_ times: Int) {  //  }   func test() {  let barkFunction = bark(_:) // compile error  } } 此时需要使用as和函数签名才能确定到底要使用哪个bark，即let barkFunction = bark as (Int) -&amp;gt; ()转换为接受Int的那个bark，编译才不会报错。或者直接指定barkFunction为(Int) -&amp;gt; ()类型。
Function Reference Scope 在前面的代码中，在使用函数引用时，没有告知编译器函数是在哪定义的，这是因为函数定义和函数引用在同一个作用域内。也就是说，如果可以在不提供进一步信息的情况下调用该函数，就可以在不提供进一步信息的情况下形成函数引用。
函数引用可以提供关于函数在哪定义的更多信息，而且有时必须这样做。这可以通过在函数引用前加一个实例或类，然后后面紧接着点操作符来实现。有些情况下，编译器会强制要求使用self来引用一个函数，在这些情况下必须这样做：
class Dog {  func bark() {  debugPrint(&amp;#34;bark&amp;#34;)  }   func bark(_ loudly: Bool) {  if loudly {  debugPrint(&amp;#34;WOOF&amp;#34;)  } else {  debugPrint(&amp;#34;woof&amp;#34;)  }  }   func test() {  let f = {  // 使用了self  return self.bark(_:) // self required here  }  // f是一个函数，无参数，但是返回一个函数  let tmpBark = f() // 执行函数，得到一个新的函数  // 传入参数调用新的函数  tmpBark(false)  } }  let tmpDog = Dog() tmpDog.test() // woof 如果要形成对另一个类型实例方法的函数引用，可以有两个方法。如果当前有一个该类型的实例，可以**使用点操作符实现对该实例的引用**：
class Cat {  func purr() {  debugPrint(&amp;#34;purr&amp;#34;)  } }  class Dog {  let cat = Cat()   func test() {  let purrFunction = cat.purr  purrFunction()  } } 下面代码，先定义了一个Test类，然后生成一个新的实例，使用该实例来引用函数，将其赋值给一个常量，再使用该常量直接调用函数：
class Test {  static var test = &amp;#34;test&amp;#34;   static func testFunc() {  //  }   class var name: String {  return &amp;#34;name&amp;#34;  }   class func nameFunc() {  //  }   func testNew() {  debugPrint(&amp;#34;testNew&amp;#34;)  } }  let test = Test() let test1 = test.testNew test1() 另一种可能的方式是使用**类型和点操作符来获取函数的引用，即使函数是实例方法也是适用的**。但是下面的代码需要使用函数签名来消除歧义。
class Cat {  func purr() {  debugPrint(&amp;#34;purr&amp;#34;)  } }  class Dog {  func bark() {  debugPrint(&amp;#34;bark&amp;#34;)  }   func test() {  let barkFunction = Dog.bark // legal but not necessary   let purrFunction = Cat.purr  } } 上面的barkFunction和purrFunction方法并不能直接调用，必须借助一个Dog或Cat实例才可以调用该方法，如下所示：
class Cat {  func purr() {  debugPrint(&amp;#34;purr&amp;#34;)  } }  class Dog {  func bark() {  debugPrint(&amp;#34;bark&amp;#34;)  }   func test() {  let barkFunction = Dog.bark  let purrFunction = Cat.purr   barkFunction(self)()  purrFunction(Cat())()  } } 如果使用类型和点操作符来获取函数引用，并且需要借助函数签名来消除函数引用的歧义时，那么函数签名必须是描述实例方法的柯里化静态/类版本(the signature must describe the curried static/class version of the instance method)：
class Cat {  func purr() {  debugPrint(&amp;#34;purr&amp;#34;)  }   func purr(_ loudly: Bool) {  debugPrint(&amp;#34;loudly \(loudly)&amp;#34;)  } }  class Dog {  func test() {  let cat = Cat()  let purrFunc = Cat.purr as (Cat) -&amp;gt; () -&amp;gt; Void // 柯里版本，参数为类型，返回一个函数  debugPrint(purrFunc)  let tmpFunc = purrFunc(cat)  tmpFunc() // 调用purr方法  } } Selectors 在Objective-C中selector是一种方法引用。在iOS编程中，可能会调用一个Cocoa方法，这个方法需要一个selector作为它的某个参数。通常，此参数被命名为selector:或action:。
通常这样的Cocoa方法也需要提供一个target（一个对象的引用）。运行时可以将selector变成一个消息，并将该消息发送给这个target以调用该方法。
为了形成selector，需要构建一个代表方法的Objective-C字符串。这种方式是十分危险的，如果错误地构建了代表方法的字符串，那么向target发送消息时，因为target没有这样的方法，运行时将发现target不能处理这个消息，此时应用程序会突然crash，并向控制台发送unrecognized selector消息。
class ViewController: UIViewController {   @IBOutlet var button: UIButton!   func viewDidLoad() {   super.viewDidLoad()  // prepare to crash  self.button.addTarget(self, action: &amp;#34;buttonPressed&amp;#34;, for: .touchUpInside)  }   @objc func buttonPressed(_ sender: Any) {  debugPrint(&amp;#34;buttonPressed&amp;#34;)  }  } 在上面的代码中self.button是界面上的一个按钮，通过调用addTarget(action:for:)来设置按钮的响应事件，使得当按钮点击时可以调用buttonPressed方法。
但是，上面的方法字符串是错误的，因为buttonPressed不是Objective-C的方法字符串，正确的方法名称字符串应该是buttonPressed:。如果运行上面代码会导致按钮点击的时候发生崩溃。
如果不知道形成selector字符串的规则，或者即使知道，但输入时不注意犯了一个小错误，都有可能导致unrecognized selector崩溃。人在输入时是很容易犯错，因此unrecognized selector崩溃历来在iOS程序员中极为常见。
Swift编译器在这方面并不容易出错，它提供了一种方法，即通过#selector(...)语法可以生成一个Objective-C的selector，括号里面的是函数的引用：
class ViewController: UIViewController {   @IBOutlet var button: UIButton!   func viewDidLoad() {  super.viewDidLoad()  self.button.addTargett(self, action: #selector(buttonPressed), for: .touchUpInside)  }   @objc func buttonPressed(_ sender: Any) {  debugPrint(&amp;#34;buttonPressed&amp;#34;)  }  } 上面的代码中使用#selector(...)时，编译器会做两件事情：
  编译器会检查函数引用是否合法，如果不合法则会出现编译错误。同时会检查这个函数是否暴露给Objective-C。为一个Objective-C看不到的方法形成一个selector是没有意义的，因为如果Objective-C试图调用这样一个方法，应用程序会崩溃。在Swift为了确保对Objective-C是可见的，该方法需要标记为@objc。
  如果使用#selector的代码能够编译，将保证将传递给此参数的实际选择器是正确的。手动写方法字符串可能会形成错误的选择器，但编译器不会，它所产生的selector不可能与方法不匹配，也不可能出现unrecognized selector崩溃。
  尽管十分少见，但在某些情况下，可能需要手动创建一个选择器。要做到这一点可以使用一个方法字符串，或者可以用字符串作为参数来实例化Selector类型：
Selector(&amp;#34;woohoo:&amp;#34;) 使用#selector(...)语法，仍然*可能通过向错误的target发送action信息而发送崩溃*。在前面的例子中，如果把addTarget调用的第一个参数self改为self.button，将会在运行时以unrecognized selector崩溃。因为buttonPressed方法是在ViewController中声明的，而不是在UIButton类型中声明的。
Variables and Simple Types 变量是一个具名的shoebox，其包含的值必须是单一的并且是已经定义好的类型，每个变量都必须事先明确且正式地声明。如果想要将值放入shoebox中，以使用变量名引用该值，那么可以将值赋给该变量。此后，这个变量名便成为该值的引用。
一个变量不仅给它所指对象一个名字，还根据声明的位置赋予它所指对象特定的作用域（可见性）和生命周期。给变量赋值是一种确保这个值能被需要看到它的代码能看到它的一种方式。作用域和生命周期分为三个层次：全局变量，属性，局部变量。
全局变量声明在Swift文件顶部，它的生命周期和所在文件一样长。一个全局变量默认（internal访问权限）在它声明所在module任何地方都是可见的，这就是全局的意思。它对同一文件中的所有代码都是可见的，因为它处于最高级别。
此外，默认情况下全局变量对于同一模块中任何其它文件中的所有代码也都是可见的，因为同一模块中的Swift文件可以自动看到彼此，所以也可以看到彼此顶层声明的全局变量：
// File1: let globalVariable = &amp;#34;global&amp;#34;  class Dog {  func debugPrintGlobal() {  debugPrint(globalVariable)  } }  // File2:  class Cat {  func debugPrintGlobal() {  debugPrint(globalVariable)  } } 属性是在对象类型声明（枚举、结构或类）的顶层中声明的变量。有两种类型属性，一种是实例属性，另一种是静态/类属性。如果属性声明时未加static或class关键字，就是实例属性，也就是说属性默认是实例属性。
实例属性的值对于每个实例来说都可以是不同的，它的生命周期和实例的生命周期相同。一个实例是对一个对象类型实例化而来，该实例以及其属性的生命周期主要取决于赋值的变量的生命周期。
如果一个属性在声明时加上static或class，就是静态/类属性，它的生命周期和该对象类型的生命周期相同。如果对象类型声明在一个文件的顶层，那么只要该静态/类属性使用过一次，那么该属性就会一直存在。
属性只能通过对象才能看到，对象的方法能够直接看到属性，在方法内部可以使用self.x这种方式访问实例属性。默认情况下，实例属性对于其它代码也是可见的，前提是要有这个实例的引用。同样地，默认情况下，一个静态/类属性对其它可以看到这个对象类型的代码也都是可见的：
// File1:  class Dog {  static let staticProperty = &amp;#34;staticProperty&amp;#34;  let instanceProperty = &amp;#34;instanceProperty&amp;#34;   func debugPrintInstanceProperty() {  debugPrint(self.instanceProperty)  }  }  // File2:  class Cat {  func debugPrintDogStaticProperty() {  debugPrint(Dog.staticProperty)  }   func debugPrintDogInstanceProperty() {  let dog = Dog()  debugPrint(dog.instanceProperty)  }  } 局部变量是指声明在花括号内部的变量，它的生命周期与包含它的花括号一样长。当程序执行到局部变量声明的范围时，局部变量才会真正生成，当程序执行离开这个范围时，局部变量就会自动消失。
有时，局部变量也被称为自动变量，以表示它们会自动出现和消失。一个局部变量只能被同一作用域中的后续代码看到（也包括同一作用域中后续更深层次的作用域）。
class Dog {  func printLocalVariable() {  let localVariable = &amp;#34;local&amp;#34;  print(localVariable)  } } Variable Declaration 变量声明时使用关键字let或者var。使用let声明的是常量，常量的意思是当第一次被赋值之后就不再允许被修改。使用var声明的变量是真正的变量，它的值可以通过后续赋值来改变。
一个变量的声明常常伴随着初始化，即使用操作符=赋一个值给变量。但在Swift中**变量声明时没有强制立即初始化，即使使用let关键字声明也一样**。
对于let x : Int这样的声明是完全合法的。可以后面再给这个变量分配一个初始值，因为这个特殊的变量是一个常量，所以一旦有了初始值，那么这个初始值将是它以后的唯一值，不能再被改变。
声明一个变量而没有指定类型是不合法的，变量必须从一开始就具有一个类型，并且永远不能更改该类型。用var声明的变量可以通过赋值改变它的值，但新值必须同变量的类型一样。
Explicit variable type declaration 变量声明时，在名称之后添加一个冒号和类型的名称，就是显式变量类型声明：
var x : Int Implicit variable type by initialization 如果将变量初始化为声明的一部分，并且没有提供明确的类型，Swift会根据它被初始化的值来推断变量的类型：
var x = 1 // and now x is an Int 完全可以一次性显式声明变量的类型并为其分配初始值：
var x : Int = 1 在上面的代码中，显式的类型声明是多余的，因为大多数情况变量类型可以从初始值推断出来。但有些情况，即使在有初始值的情况下显式声明一个类型也不是多余的。
第一种场景是Swift推断出来的类型是错误的。一种常见的场景是使用数字字面量作为初始值，Swift编译器会将它们推断为Int或Double类型（区别为是否有小数点），但实际上有很多数字类型：
let value : Float = 2.0 // 带小数点的数字字面量2.0默认是Double类型 另一种场景是如果不明确地告诉编译器变量的类型，编译器就无法通过初始值推断出类型。一个常见的场景是options集合：
let opts = [.autoreverse, .repeat] // compile error: Reference to member &amp;#39;autoreverse&amp;#39; cannot be resolved without a contextual type let opts : UIView.AnimationOptions = [.autoreverse, .repeat] 即使编译器可以从变量的初始值正确推断出变量的类型，这种推断也是需要时间的。因此，在变量声明时提供显式类型可以减少编译时间。
如前所述，即使声明的变量是常量，也不必在声明时对其进行初始化，即下面的写法是合法的，不会出现编译错误：
let x : Int 现在x是一个空的shoebox，即没有初始值的Int变量，可以稍后为该变量分配一个初始值。由于这个特定的变量是一个常量，从赋值那刻起，该初始值将是它的唯一值，之后不能再被改变。
对于属性来说，先声明后初始化是很常见的，因为属性的初始化可以通过对象类型的初始化函数来实现。但对于局部变量来说，通常是声明的时候同时初始化。
当局部变量遇到需要conditional initialization时，也可以先声明后初始化。这是因为，有时在进行某种条件测试之前，并不知道某个变量的初始值。因为变量只能声明一次，所以它必须提前声明，之后再进行条件初始化：
let timed: Bool if val == 1 {  timed = true } else {  timed = false } 如果一个变量的地址被当作参数传递给一个函数时，这个变量必须在传递之前先声明并且在传递之前已经被初始化，也就是说即使初始化值是假的占位符也必须先给一个初始值，否则会出现编译错误：
var r: CGFloat = 0 var g: CGFloat = 0 var b: CGFloat = 0 var a: CGFloat = 0 c.getRed(&amp;amp;r, green: &amp;amp;g, blue: &amp;amp;b, alpha: &amp;amp;a) 在上面的代码中，4个CGFloat传入到getRed中后，它们的值可能会被改变。而给定的初始值只是临时占位符，用以满足编译器的要求。
特别需要注意的是：传入到函数的普通参数，也必须先初始化，否则编译器也会报错。下面代码中tt1未初始化就传入到oneParameter会出现编译错误：
func oneParameter(test: String)  debugPrint(test) } var tt1: String oneParameter(test: tt1) // 出现编译错误：Variable &amp;#39;tt1&amp;#39; used before being initialized   func oneParameter(test: String) {  debugPrint(test) } var tt2: String = &amp;#34;name&amp;#34; // 传递给函数前进行了初始化，不再出现编译错误 oneParameter(test: tt2) 如果一个变量需要传入到以inout修饰的函数参数中，必须使用var声明，并且传入前也必须先初始化（与变量地址传入那一类相似）：
func testMain(test: inout String) {  test = &amp;#34;name&amp;#34;  debugPrint(test) }  var newTest :String testMain(test: &amp;amp;newTest) // 编译错误：Variable &amp;#39;newTest&amp;#39; passed by reference before being initialized   var newTest1 :String = &amp;#34;name&amp;#34; testMain(test: &amp;amp;newTest1) 极少数情况下，会遇到这样一种情况：调用一个有返回值的Cocoa方法，然后在传递给这个方法的函数参数中又要使用这个返回值。Cocoa有一个UIApplication实例方法是下面这样声明的：
func beginBackgroundTask(expirationHandler handler: (() -&amp;gt; Void)? = nil) -&amp;gt; UIBackgroundTaskIdentifier 上面的beginBackgroundTask(expirationHandler:)会返回一个UIBackgroundTaskIdentifier对象，然后会在expirationHandler函数中使用这个对象。Swift的安全规则不允许在一条语句中声明变量，同时又在声明语句中的匿名函数中使用它：
let bti = UIApplication.shared.beginBackgroundTask {  UIApplication.shared.endBackgroundTask(bti) } // 编译错误：Closure captures &amp;#39;bti&amp;#39; before it is declared 因此，需要提前声明变量。在上面的代码中，如果只是提前声明变量，依然会有问题，编译时会报variable captured by a closure before being initialized：
var bti: UIBackgroundTaskIdentifier bti = UIApplication.shared.beginBackgroundTask {  UIApplication.shared.endBackgroundTask(bti) } // error: variable captured by a closure before being initialized 一种解决方案是提前声明变量，并且声明时给变量一个假的初始值作为占位符。如下所示，给了变量bti一个假的初始值.invalid用来占位：
var bti: UIBackgroundTaskIdentifier = .invalid bti = UIApplication.shared.beginBackgroundTask() {  UIApplication.shared.endBackgroundTask(bti) } 这里真正的问题是beginBackgroundTask相当古老了，更现代的方法是将返回值直接传递给函数作为参数。Cocoa的UIAction初始化方法init(title:handler:)就是一个例子：
let myAction = UIAction(title: &amp;#34;Hello&amp;#34;) { action in  print(action) } 在上面的代码中，action就是myAction，因此在匿名函数参数handler:中可以直接引用action，而不使用myAction（这种方法还可以防止可能的循环引用）。
在UIAction初始化器中的handler参数中使用myAction是非法的，下面代码会出现编译错误：
let myAction = UIAction(title: &amp;#34;Hello&amp;#34;) { action in  if myAction === action {  debugPrint(&amp;#34;test&amp;#34;)  }  print(action) } // Closure captures &amp;#39;myAction&amp;#39; before it is declared Computed Variable Initialization 有时需要先执行一些代码去才能获得变量的初始值，一个简洁的解决方案是定义和调用匿名函数来进行初始化，这种方式称为define-and-call initializer。下面代码中定义了一个匿名函数并立即执行来初始化常量timed：
let val = 0 let timed: Bool = {  if val == 1 {  return true  } else {  return false  } }() 当一个实例属性也需要执行一些代码去获得初始值时，也可以使用define-and-call initializer进行初始化。下面的cellBackgroundImage属性需要用到多次，但初始化时需要执行一些其它代码，因此通过定义和调用一个匿名函数来初始化这个属性：
class RootViewController: UITableViewController {  let cellBackgroundImage: UIImage = {  return imageOfSize(CGSize(width: 320, height: 44)) {  // ... drawing goes here ...  }  }() } 你可能会好奇，与其使用define-and-call initializer，为什么不直接定义一个实例方法来初始化实例属性。因为定义一个实例方法来初始化实例属性是非法的，将会出现编译错误：
class RootViewController: UITableViewController {  // Cannot use instance member &amp;#39;self&amp;#39; within property initializer; property initializers run before &amp;#39;self&amp;#39; is available  let cellBackgroundImage: UIImage = self.makeTheImage()   func makeTheImage() -&amp;gt; UIImage {  return imageOfSize(CGSize(width: 320, height: 44)) {  // ... drawing goes here ...  }  }  } 因为实例属性声明初始化时，此时实例尚未生成。因此，不能在属性声明初始时引用self。但定义和调用匿名函数是合法的，需要注意的是定义和调用匿名函数仍然不能在函数体中隐式或显式引用self，否则也会出现编译错误，如果需要在函数体中使用self，需要将属性声明为lazy。
Computed Variables 除了正常的存储变量，Swift中的变量还可以是计算的。这意味着变量不是一个值，而是一个函数。计算变量中包括setter和getter函数，setter函数在变量被赋值自动调用，getter函数在变量被引用时自动调用:
var now: String { // ①  get { // ②   return Date().description // ③  }  set { // ④  debugPrint(newValue) // ⑤  } }  变量必须使用var声明（不能使用let），并且变量类型必须显式声明，类型后面紧跟花括号。 其中的getter函数被称为get。getter函数没有正式的函数声明，get这个词后面紧跟着花括号中的函数体。 其中的getter函数必须返回一个与该变量类型相同的值。从Swift 5.1开始，当getter只有一个单一语句时，省略关键字return是合法的。 其中的setter函数被称为set。setter函数也没有正式的函数声明，set这个词后面紧跟着函数体。 其中setter函数就像接受一个参数的函数。默认情况下，该参数以newValue这个名字进入setter函数体中。  对待计算变量可以与任何其它变量相同。如果要赋值给变量，能够直接赋值给它；如果要使用变量，能够直接引用它。但是，在幕后是调用了setter和getter函数。
now = &amp;#34;Howdy&amp;#34; // Howdy print(now) // 2022-08-07 04:03:21 &#43;0000  赋值给now时，setter函数将被自动被调用，参数就是将要赋的值。在上面的代码就是Howdy，该值作为参数newValue的实参传到set函数。 获取now的值时，getter将被自动调用。  对于setter函数来说，默认的参数名可以不是newValue。如果需要指定一个不同的名称，把新名字放在set后面的括号里就可以，下面代码用新名字val代替默认的newValue：
var nowTest: String = &amp;#34;&amp;#34; var now: String {  get {  &amp;#34;test&amp;#34;  }  set(val) {  nowTest = val  } } 如果setter函数省略，那么这个计算变量就成为了一个只读变量，等同于一个let常量，一旦试图去改变这个变量的值就会出现编译错误:
var newDate: String {  return Date().description }  newDate = &amp;#34;ddd&amp;#34; // Cannot assign to property: &amp;#39;newDate&amp;#39; is a get-only property 即使只有一个getter函数，计算变量声明时也必须使用var。计算变量必须有一个getter函数。如果计算变量中没有setter函数，get这个词和它后面的花括号可以省略。如果get中只有一行，return也可以省略：
var now: String {  Date().description } Computed Properties 在实际的编程中，对于计算变量的使用场景几乎都是实例属性。当一个值在每次需要使用时可以很容易地计算出来，将其表达为一个只读的计算变量往往更简单，实际上这是对一个较长表达式的速记法：
var mp: MPMusicPlayerController {  MPMusicPlayerController.systemMusicPlayer } var nowPlayingItem: MPMediaItem? {  self.mp.nowPlayingItem } 一个计算变量的getter函数可以封装多行代码，其实质是把一个方法变成了一个属性。下面是从xml文件中提取作者信息，本可以将其声明为方法func authorOfItem() -&amp;gt; String?，但方法表达了一个过程，而计算属性则能更直观地描述它是一个事物：
var authorOfItem: String? {  guard let authorNodes = self.extensionElements(withXMLNamespace: &amp;#34;http://www.tidbits.com/dummy&amp;#34;, elementName: &amp;#34;app_author_name&amp;#34;) else {  return nil  }  guard let authorNode = authorNodes.last as? FPExtensionNode else {  return nil  }  return authorNode.stringValue } 一个计算变量可以位于一个或多个存储变量的前面，充当这些存储变量设置和获取时的守门员，这与Objective-C的的访问器类似。通常，一个计算变量由一个私有的存储变量来支持：
private var _pp: Int = 0 var pp: Int {  get {  self._pp  }  set {  self._pp = newValue  } } 上面代码是合法的，但是毫无意义。当在获取或设置存储变量的同时做其它事情的时候，存储变量的幌子变得有用了。
private var _pp: Int = 0 var pp: Int {  get {  self._pp  }  set {  self._pp = max(min(newValue, 5), 0)  } } 一个实例的计算属性getter函数或setter函数可以引用其它实例成员。这一点很重要，因为一般来说，存储属性的初始化时不能引用self。对于一个计算属性来说，隐式或显式使用self合法的，因为getter或setter函数在实例实际生成前不会被调用。
Property Wrappers 如果有几个带有存储变量幌子的计算属性实际上做了同样的事情，那么最终将会有大量的重复代码。如果能把这些共同的功能移到一个地方就更好了。实际上，可以用一个属性包装器来实现。
一个属性包装器是在声明结构体时标记@propertyWrapper，并且必须有一个wrappedValue的计算属性。下面是一个实现&amp;quot;clamped&amp;quot;模式的属性包装器。
@propertyWrapper struct Clamped {  private var _i: Int = 0  var wrappedValue: Int {  get {  self._i  }  set {  self._i = Swift.max(Swift.min(newValue, 5), 0)  }  } } 上面声明的结果是，现在可以声明一个用自定义属性标记的计算属性，该属性的名称与该结构(@Clamped) 相同，没有getter或setter函数：
@Clamped var p 上面的属性p不需要被初始化，因为它是一个计算属性，也不需要getter或setter函数。实际上，它都不需要类型声明，因为Clamped结构体的wrappedValue计算属性提供了类型。
多亏了属性包装器，我们封装了计算属性，这意味着可以声明另外一个@Clamped属性。此外，这个模式现在有了一个名字：声明@Clamped var告诉我们这个计算属性的行为将会是什么。
Setter Observers 计算变量并不经常需要作为一个存储变量的幌子。这是因为Swift有另一个功能，可以在存储变量的setter函数中注入setter observers功能。
setter observers是在设置存储变量之前和之后调用的函数。即在存储变量中添加一个willSet函数，或一个didSet函数，或两者均有：
var s = &amp;#34;whatever&amp;#34; { // ①  willSet { // ②  debugPrint(newValue) // ③  }  didSet { // ④  debugPrint(oldValue) // ⑤  // self.s = &amp;#34;something else&amp;#34;  } }   变量必须使用var声明，不能使用let声明，并且可以被赋予一个初始值。
  如果willSet函数存在的话，就是单词willSet后面紧跟着函数体。当在其它地方设置该变量时，在该变量收到其新值之前willSet函数被调用。
  默认情况下，willSet函数接受即将设置的新值，这个新值的名字是newValue。也可以通过在willSet后面的括号里写一个不同的名字来自定义接受到新值名字。旧值仍然在存储变量中，willSet函数中依然可以访问旧值。
  如果在willSet中将存储变量设置为不同的值时，不会生效，并会收到编译警告：
var newStr: String = &amp;#34;new&amp;#34; {  willSet {  debugPrint(newValue)  // Attempting to store to property &amp;#39;s&amp;#39; within its own willSet, which is about to be overwritten by the new value  newStr = &amp;#34;test&amp;#34;  } }  newStr = &amp;#34;name&amp;#34; debugPrint(newStr) // name // name   如果didSet函数存在的话，就是didSet这个词后面紧跟着函数体。当其它代码设置该变量时，在该变量实际收到其新值之后被调用。
  默认情况下，didSet函数接收旧的值，名字为oldValue，此时新值已经完成替换。可以通过在didSet后面的括号里写一个不同的名字以自定义接收到的旧值。
var now1: String = &amp;#34;now1&amp;#34; {  willSet(val) {  debugPrint(now1)  debugPrint(val)  }  didSet(val) {  debugPrint(val)  debugPrint(now1)  } }  debugPrint(now1 = &amp;#34;133&amp;#34;) //&amp;#34;now1&amp;#34; //&amp;#34;133&amp;#34; //&amp;#34;now1&amp;#34; //&amp;#34;133&amp;#34;   新的值已经在存储的变量中，didSet函数中可以访问新值。此外，在didSet函数中将存储变量设置为不同的值也是合法的，但不会再次调用Setter Observers。
var newStr: String = &amp;#34;new&amp;#34; {  willSet {  debugPrint(newValue)  newStr = &amp;#34;test&amp;#34;  }  didSet {  newStr = &amp;#34;dddd&amp;#34;  } }  newStr = &amp;#34;name&amp;#34; debugPrint(newStr) // name // dddd   需要特别注意的是，当存储变量初始化时或didSet函数中再次改变存储变量的值时，不会调用setter observers函数，否则会产生死循环。
在实际的iOS编程中，可能想要可见的界面反应对象的状态。一个setter观察器是一种简单而强大的方式，可以使界面与一个属性同步。
在下面这个例子中，有一个view类的实例属性，决定了该视图应该被旋转多少。每次这个实例属性发生变化时，我们都会改变界面来反映它，即设置self.transform使视图被旋转相应的角度：
var angle: CGFloat = 0 {  didSet { // modify interface to match   self.transform = CGAffineTransform(rotationAngle: self.angle)  } } 计算变量不能有setter observers，因为它已经有了setter函数，任何在设置过程中需要发生的额外事情都可以直接写入setter函数中。但一个被属性包装器包裹的计算变量可以有setter observers。
Lazy Initialization 如果一个存储变量声明时赋了一个初始值，并且使用了Lazy Initialization（懒初始化），那么在运行代码访问该变量的值之前，初始值实际上还不会有。在Swift中，有三种类型的变量可以被懒初始化。
  全局变量。全局变量是自动Lazy Initialization的，一个全局变量的初始化在其他代码首次引用该全局变量时才会发生，这种初始化只会执行一次，同时又是线程安全的。
  静态属性。静态属性也是自动Lazy Initialization的，它的行为和全局变量完全一样，而且原因也基本相同。所以在Swift中类属性不能再加lazy关键字。
  实例属性默认不是lazy的，但可以在声明的时候显式加上关键字lazy。此时，这个属性必须使用var来声明而不能用let。如果没有任何代码获取属性的值，属性的初始化器可能永远不会执行。
  从Swift 5.5开始，局部变量可以使用lazy var声明了。下面代码中，dog并不会被实例化。
do {  lazy var dog = Dog(name: &amp;#34;123&amp;#34;, license: 456) }   如果代码从未引用懒初始化的变量，那么这个变量的初始化器永远不会运行。显然，如果初始值的生成成本很高时，那么这个特性很有用。
如果懒惰初始化变量的第一个引用重新设置了该变量会怎么样？对于全局变量或静态属性，初始值会被计算，然后立即被新设置的值所取代。下面代码执行后，控制台打印了firstStatic和secondStatic：
struct Assist {  var value: String   init(value: String) {  self.value = value  debugPrint(self.value)  } }  class NewTest {  static var staticTest = Assist(value: &amp;#34;firstStatic&amp;#34;) } NewTest.staticTest = Assist(value: &amp;#34;secondStatic&amp;#34;) // firstStatic // secondStatic 但是对于懒加载的实例属性或局部变量的初始化器将永远不会赋初始值，如果该变量在被获取之前被重新设置。下面的代码执行后，控制台只打印了一个secondTime：
struct Assist {  var value: String   init(value: String) {  self.value = value  debugPrint(self.value)  } }  class NewTest {  lazy var test = Assist(value: &amp;#34;firstTime&amp;#34;)  func changeTest() {  self.test = Assist(value: &amp;#34;secondTime&amp;#34;)  } }  // 下面代码执行完后，只会打印secondTime，不会打印firstTime NewTest().changeTest() Singleton Lazy Initialization常用于实现单例。单例是一种设计模式，所有的代码都能够访问某个类的单一共享实例。下面代码就是一个最简单的单例实现：
class MyClass {  static let shared = MyClass()  private init() {  //  } } 在代码第一次使用MyClass.shared前，单例不会被创建。只要单例创建成功后，无论其它代码多少次使用MyClass.shared，返回的实例总是同一个实例。如果使用的是一个只读计算属性，其getter函数调用MyClass()并返回该实例，那么每次返回的是不同的实例。
通常，我们希望实例属性是Lazy Initialization的。因为实例属性初始值的生成所花费的代价可能是昂贵的，所以除非确实需要用到的时候，一般会避免提前生成。
还有另一个原因更重要，懒初始化可以做普通初始化器不能做的事情，即懒初始化可以访问实例本身，而普通的初始化器是不能这样做的，因为在普通初始化器运行的时候，实例尚未生成。
下面的代码中，如果arrow属性不声明为lazy，将会出现编译错误Cannot use instance member &#39;self&#39; within property initializer; property initializers run before &#39;self&#39; is available：
class MyView: UIView {  lazy var arrow = self.arrowImage() // legal  func arrowImage() -&amp;gt; UIImage {  // ... big image-generating code goes here ...  } } 一个常见的习惯是定义和调用匿名函数来初始化一个lazy实例属性。一旦加上lazy，那么在这个匿名函数中就可以引用实例本身self：
class MyView: UIView {  lazy var prog: UIProgressView = {  let p = UIProgressView(progressViewStyle: .default)  p.alpha = 0.7  p.trackTintColor = UIColor.clear  p.progressTintColor = UIColor.black  p.frame = CGRect(x: 0, y: 0, width: self.view.bounds.size.width, height: 20) // legal   p.progress = 1.0  return p  }() } 与自动lazy的全局变量和静态变量不同，标记为lazy的实例属性是线程不安全的。当在多线程环境中使用时，lazy的实例属性可能会导致多次初始化，甚至闪退。
因为不能将lazy加在用let声明的属性上，所以不能让一个lazy的实例属性成为只读的。没有lazy let实例属性是不幸的，因为有一些常见的情况会从这样的功能中受益。
假设想用一个helper属性添加到self中，它持有一个Helper类实例，并需要一个对self的引用。我们还想让这个Helper实例在self的整个生命周期内持续存在。可以通过让helper成为一个let属性并在其声明中初始化它来执行这一规则。
但是不能把self传递给Helper的初始化器，因为不能在属性声明中引用self。可以通过声明helper属性为lazy来解决这个问题。但是必须使用var来声明helper，也就是说这个helper可能被其它代码改变。当然，可以尽量不让这种情况发生，但问题是lazy var这样的表达方式无法执行我们真正所需的策略。
Built-In Simple Types 每一个变量和每一个字面量都必须有一个类型。Swift内置的简单类型有Bool,Numbers，String，Character，Range，Tuple等。其中Bool类型是一个结构体，只有两个值，一个是true，一个是false：
@frozen public struct Bool : Sendable {   public init()   @inlinable public init(_ value: Bool)   @inlinable public static func random&amp;lt;T&amp;gt;(using generator: inout T) -&amp;gt; Bool where T : RandomNumberGenerator   @inlinable public static func random() -&amp;gt; Bool } 与许多计算机语言不同，Swift中没有任何其它东西能被隐式地转换为Bool类型。例如，在C语言中，布尔值实际上是一个数字，0代表false，非0代表true。而在Swift中，只有false是false，true为true。
一个常见的情况：一个存储在某个var变量中的Bool，我们想反转它的值。即如果它是false的就变成true，如果它是true就变成false。
v.isUserInteractionEnabled = !v.isUserInteractionEnabled 上面的方式很麻烦，也容易忘记加取非符号!。有一个更简单的方法，即在Bool变量上调用toggle方法:
v.isUserInteractionEnabled.toggle() 主要的数字类型是Int和Double，我们一般会使用这些类型。其它数字类型的存在主要是为了与C和Objective-C API兼容。
Int对象类型也是一个结构体类型，表示Int.min和Int.max之间的一个整数。实际限制值取决于应用程序运行的平台和架构，它们并不是绝对的。
表示一个Int值最简单的方法是使用一个字面量。没有小数点的数字字面量默认为Int。内部下划线也是合法的，内部下划线对长数字的可读性很有用。前导零也是合法的，这对于在代码中填充和对齐数值很有用。
var x = 1000_000_000 var y = 00001 可以用二进制、八进制或十六进制的字面量来表示Int。要做到这一点，需要分别以0b、0o或0x开始。例如，0x10是十六进制表示，代表十进制的16。
负数以二进制补码格式存储。可以写一个看起来像底层存储的二进制字面量，但要使用它，必须通过Int(bitPattern:)初始化器。
在Swift中Double是一个结构体类型，表示一个精度约为15位小数的浮点数（使用64位存储）。含有小数点的数字默认为Double类型，并且Double类型的内部下划线和前导零也是合法的。
Double字面量不能以小数点开头（与C和Objective-C不同）。如果要表示的值介于0和1之间，则以0开头。Double有静态属性Double.infinity和Double.pi，也有一个实例属性isZero。
可以使用科学计数法写Double字面量，字母e之后的所有内容都是10的指数。如果小数位为零，则可以省略小数点。例如，3e2 是300。
可以用十六进制数字写一个Double字面量。要这样做，需要以0x开头。也可以在使用指数法（同样，可以省略小数点，字母p后面的所有内容都是2的指数。 例如，0x10p2是十进制64。
Numeric coercion 强制转换是指从一种类型转换为另一种类型。Swift并没有显式的类型强制转换，但它使用实例化能够完成同样的效果。Swift的数字类型提供了初始化器，这些初始化器将另一个数字类型实例作为参数：
let i = 10 //an Int let x = Double(i) debugPrint(x) // 10.0, a Double let y = 3.8 //a Double let j = Int(y) debugPrint(j) // 3, an Int 当数值被赋值给变量或作为参数传递给函数时，Swift只对字面数字量进行隐式强制转换。下面这段代码是合法的，虽然10默认是Int类型，但因为它是字面量，因此能够隐式地转换为Double类型：
let d : Double = 10 但下面这段代码是不合法的，编译器会报错。因为所赋值的是一个不同类型的变量，而不是字面量数字。问题的根源是i为Int实例，d是一个Double实例，二者不能自动进行隐式转换：
let i = 10 let d : Double = i // Cannot convert value of type &amp;#39;Int&amp;#39; to specified type &amp;#39;Double&amp;#39; 解决方案是在赋值或传递变量时进行显式强制类型转换（即实例化）：
let i = 10 let d : Double = Double(i) 当数字字面量被算术运算组合时，同样的规则也适用。Swift只对字面数字量进行隐式强制转换。例如，一个Int字面量与一个Double字面量运算时，Int字面量会隐式地转换为Double：
let x = 10/3.0 debugPrint(x) // 3.33333333333333 但是，如果想在算术运算中组合不同类型的数字类型变量，则必须显式强制转换以保证它们是相同的类型。如下所示，因为i和n是不同类型的变量，会出现编译错误：
let i = 10 // Int类型 let n = 3.0 // Double类型 let x = i / n // compile error:Binary operator &amp;#39;/&amp;#39; cannot be applied to operands of type &amp;#39;Int&amp;#39; and &amp;#39;Double&amp;#39; 解决方案是将变量i的类型强制转换为Double：
let i = 10 let n = 3.0 let x = Double(i) / n 这些规则都是Swift强类型的结果。对于现代计算机语言来说，它们构成了对数值不同寻常的处理，而且可能会在短时间内把你逼疯。
到目前为止，所举的例子很容易解决，但如果算术表达式较长，事情就会变得更加复杂，而且这个问题会因为其它数字类型的存在而变得更加复杂，这些数字类型是与Cocoa兼容所需要的。
Other numeric types 如果只是在某个孤立的、抽象的世界中使用Swift，可能只使用Int和Double就能完成所有必要的算术运算。但是，如果是在进行iOS编程，就会遇到Cocoa，它里面包含了许多其它的数字类型，而Swift中都有与之相匹配的类型。
除了Int，还有各种大小的有符号整数类型—Int8、Int16、Int32、Int64。加上无符号整数类型UInt、UInt8、UInt16、UInt32和UInt64。除了Double，还有低精度Float（32位存储，大约6或7个小数位精度）、更低精度的Float16、扩展精度Float80 和来自Core Graphics框架的CGFloat。
在尝试与C语言API对接时，也可能遇到C语言的数字类型。就Swift而言，这些类型只是类型别名，例如CDouble（对应C语言的double）只是Double的另一个名字，CLong（C语言的long）是Int。
在各种Cocoa框架中会出现许多其它数字类型的别名，例如，TimeInterval（Objective-C的NSTimeInterval）只是Double的类型别名。
let percentage = pt.x / s.bounds.size.width 在变量赋值、参数传递或操作符组合不同类型的数值时，必须将这些值显式强制转换为正确的类型。Cocoa有很多数值类型，但Cocoa通常会给你一个既不是Int也不是Double的数值。
但我们不一定能意识到这一点，直到编译器因为某种类型不匹配而出现报错，我们才会意识到。然后，弄清楚哪个类型错误了，并将所有内容强制转换为同一类型。
下面是一个典型示例。界面中滑块是一个UISlider，它的minimumValue和maximumValue是Floats。下面代码中s是UISlider，g是UIGestureRecognizer，尝试使用手势识别器将滑块移动到用户在滑块内点击的任何位置：
let pt = g.location(in:s) let percentage = pt.x / s.bounds.size.width let delta = percentage * (s.maximumValue - s.minimumValue) // compile error 上面代码会发生编译错误，因为pt.x的类型是CGFloat，s.bounds.size.width也是CGFloat，因此percentage的类型也是CGFloat，但是maximumValue和minimumValue是Float。所以percentage和(s.maximumValue - s.minimumValue)为不同类型。在Swift中Float和CGFloat是不同类型，必须进行显式强制类型转换：
let delta = Float(percentage) * (s.maximumValue - s.minimumValue) CGFloat是一个特殊的例子。它根据架构的位数（32位或64位）解析为Float或Double的位数大小。但这种区别已经不那么重要了，因为现在32位架构已经很少了，而且无论如何它都能有效地处理Doubles。
从Swift 5.5开始，Double和CGFloat是可以互换的。在它们被期望的地方可以互换，而不需要强制类型转换，这使iOS程序员减少了相当多的不便性：
var cfg : CGFloat = 1 var d1 : Double = 2 cfg = d1 // legal d1 = cfg &#43; d1 // legal let x2 = cfg &#43; d1 // x is inferred as Double 不是所有的数值都能够强制转换为另一个类型的数值。特别是，不同整数类型转换时可能会超出范围。例如，Int8.max是127，如果尝试将&amp;gt;=128的字面量赋值给Int8是不合法的，下面将会出现编译错误：
let tx: Int8 = 128 // Integer literal &amp;#39;128&amp;#39; overflows when stored into &amp;#39;Int8&amp;#39; 上面的例子中，因为128是一个数字字面量，所以编译器能够提前判断溢出了。但进行类型强制转换时，编译器无法事先判断是否出溢出，所以在运行时才会崩溃：
let i : Int16 = 128 let i1 = Int8(i) // Swift/Integers.swift:3564: Fatal error: Not enough bits to represent the passed value 对于上面的情况，解决方案是调用一个可失败的初始化器。下面代码在运行时虽然不会发生崩溃，但是需要测试转换是否成功：
let i : Int16 = 128 let i1 = Int8(exactly: i)  if let i = i1 {  debugPrint(i1) } 另外一种解决方案是使用clamping初始化器，这个初始化器总是会成功的，因为超出范围的值会强制落入正常范围内，下面代码执行后打印的结果为127：
let i : Int16 = 128 let i1 = Int8(clamping: i)  debugPrint(i1) //127 当浮点类型（例如Double）被强制转换为整数类型时，小数点后的内容会先被丢弃，然后再尝试强制转换。例如，Int8(127.9) 会转换成功，因为127在界限内。
debugPrint(Int8(127.9)) Arithmetic operations 从技术上讲，如果整数是无符号的，移位运算符执行逻辑移位，如果整数是有符号的，则执行算术移位。整数上溢或下溢是运行时错误（应用程序将崩溃）例如，两个Int值的和超过Int.max：
let i = Int.max - 2 let j = i &#43; 12/2 // 会发生crash 在某些情况下，我们可能想要强制此类操作成功，因此提供了特殊的上溢/下溢方法。这些方法返回一个元组，下面代码中over打印的值为true：
let i = Int.max - 2 let (j, over) = i.addingReportingOverflow(12/2) debugPrint(over) 上面的代码执行后，j的值变成了Int.min&#43;3，因为该值已从Int.max环绕到Int.min。如果不关心是否存在上溢/下溢，可以使用特殊的算术运算符来抑制错误：&amp;amp;&#43;、&amp;amp;-、&amp;amp;*。
经常希望将现有变量的值与另一个值进行算术组合，并将结果存储在同一个变量中。为此，需要将变量声明为var：
var i = 1 i = i &#43; 7 实际上有个速记法，提供了一次执行算术运算和赋值的运算符：
var i = 1 i &#43;= 7 速记（复合）赋值算术运算符有&#43;=, -=, *=, /=, %=, &amp;amp;=,|=, ^=, &amp;lt;&amp;lt;=, &amp;gt;&amp;gt;=。
Comparison 对于两个不同类型的整数，虽然不能在算术运算中组合它们，但可以比较不同整数类型的值，如下所示i是Int，i2是UInt8类型，但它们可以比较：
let i: Int = 1 let i2: UInt8 = 2 let ok = i &amp;lt; i2 // true let ok2 = i == i2 // false  debugPrint(ok2) //false 由于计算机存储数字的方式，Double数值的相等比较可能不会像我们期望的那样。举一个经典的例子，将0.1加十次与0.1乘以10的结果不同：
let f2 = 0.1 var sum = 0.0 for _ in 0..&amp;lt;10 {  sum &#43;= f2 } let product = f2 * 10 let ok3 = sum == product // false debugPrint(ok3) //false 解决这类问题并不容易。通常的方法是检查两个值是否足够接近，但又引出了该怎么判断足够接近的问题。一个有用的公式为:
let ok = sum &amp;gt;= product.nextDown &amp;amp;&amp;amp; sum &amp;lt;= product.nextUp // true String 在Swift中，字符串String也是结构体类型。表示字符串值最简单方法是使用字符串字面量，即使用双引号分隔：
let greeting = &amp;#34;hello&amp;#34; Swift中的字符串是完全现代的，它使用Unicode编码，可以在字符串字面量中包含任何字符（如表情符）。如果知道一个字符的Unicode码点，并且不嫌麻烦，可以使用\u{...}，需要注意的是在花括号的内容至多为八位十六进制数字：
let leftTripleArrow = &amp;#34;\u{21DA}&amp;#34; 该字符串中的反斜杠是转义字符。它的意思是，*“我不是一个真正的反斜杠，紧接着的下一个字符需要特殊处理。”*有很多不可打印的字符作为转义字符，最常见的是以下这些：
 \n：一个Unix换行符。 \t：制表符。 \&amp;quot;：引号（转义以表明这不是字符串文字的结尾）。 \\：反斜杠（因为单独的反斜杠是转义字符）。  转义的引号和反斜线会使字符串字面意义变得难看和难以辨认，尤其在正则表达式中。例如，模式\b\d\d\b（由两个数字组成的单词）必须写成&amp;quot;\\b\\d\\d\\b&amp;quot;。可以在引号和反斜杠之前省略转义字符，用一个或多个哈希字符（#）围住字面量，下面这些都是相同的字符串：
let pattold = &amp;#34;\\b\\d\\d\\b&amp;#34; let pattnew = #&amp;#34;\b\d\d\b&amp;#34;# // same thing let pattnew2 = ##&amp;#34;\b\d\d\b&amp;#34;## // same thing 这称为原始字符串字面量。缺点是，如果想在原始字符串字面量中使用反斜杠作为转义字符，则必须在反斜杠后面加上用于包围字符串字面量相同数量的#字符。字符串#&amp;quot;hello\nthere&amp;quot;#不包含换行符(\n)，但#&amp;quot;hello\#nthere&amp;quot;#包含。
let hello = #&amp;#34;hello\nthere&amp;#34;# debugPrint(hello)  // &amp;#34;hello\\nthere&amp;#34;  let hello = #&amp;#34;hello\#nthere&amp;#34;# debugPrint(hello)  // &amp;#34;hello\nthere&amp;#34; 可以将包含换行符的字符串字面量输入为多行，而不是包含\n字符的单行表达式，这称为多行字符串字面量。使用的规则如下：
 多行字符串字面量必须在开始和结束处用三重引号 (&amp;quot;&amp;quot;&amp;quot;) 分隔。 任何字符都不能跟在同一行的开头分隔符后面。 除了空格之外，其它任何字符都不能与结束分隔符出现在同一行。 结束分隔符之前的最后一个隐式换行符会被忽略。 结束分隔符的缩进决定了文本行的缩进，它必须至少缩进到结束分隔符（整个空行除外）。  func ff() {  let s = &amp;#34;&amp;#34;&amp;#34; Line 1 Line 2 Line 3 &amp;#34;&amp;#34;&amp;#34; // ... } 在上面字符串s包含3行字符串，第1和第3行没有以空格开始，第2行以4个空格开始，第1行和第2行后面包含换行符。如果要在第3行后添加换行，可以输入一个空行，或者添加一个转义的\n。
在多行字符串字面量中，双引号不需要转义。以反斜杠结尾的一行与下一行相连。在下面这段代码中，字符串s仅由两行文字组成，第二行由四个空格开始，后面紧跟着 &amp;quot;Line 2 and this is still line 2&amp;quot;：
func f() {  let s = &amp;#34;&amp;#34;&amp;#34; Line &amp;#34;1&amp;#34; Line 2 and this is still Line 2 &amp;#34;&amp;#34;&amp;#34;  // ...  debugPrint(s) } 可以使用#包住多行字符串字面量，使之成为一个原始的多行字符串字头，但通常不这样做。
字符串插值允许在字符串字面量中嵌入任何值，即使这个值本身不是字符串，也可以使用转义圆括号来实现：
let n = 5 let s = &amp;#34;You have \(n)widgets.&amp;#34; 如果是在一个字符串中插值，那么字符串中的引号不需要被转义：
let s = &amp;#34;You have \(&amp;#34;numerous&amp;#34;.uppercased())widgets&amp;#34; debugPrint(s)  // &amp;#34;You have NUMEROUS widgets&amp;#34; 字符串插值在多行字符串是合法的。在以#包围的原始字符串中插值也是合法的，但反斜杠后面必须有相同数量的#字符，以表明它是转义字符。
字符串插值的语法可以定制以接受额外的参数，重定义第一个参数应该如何转换。下面这种形式的表达式是合法的：
let n = 5 let s = &amp;#34;You have \(n, roman: true)widgets&amp;#34; debugPrint(s) 连接两个字符串，最简单的方式是使用&#43;操作符：
let s = &amp;#34;hello&amp;#34; let s2 = &amp;#34; world&amp;#34; let greeting = s &#43; s2 debugPrint(greeting) 这种便捷的标识可以成为可能，是因为操作符&#43;是重载的。所有的运算符都可以被重载，可以重载某个操作符，以某种适当的方式对自己的类型进行操作。
字符串和Int之间的强制转换是可能的。要创建一个代表Int的字符串，只需使用字符串插值就可以了。或者使用以Int为参数的String初始化器：
let i = 7 let s = String(i) // &amp;#34;7&amp;#34; debugPrint(s)  // 7 字符串也可以代表其它基数的Int，只需在初始化器中提供一个表示基数的radix: 参数：
let i = 31 let s = String(i, radix: 16) // &amp;#34;1f&amp;#34; debugPrint(s) 一个代表数字的字符串，可以强制转换为数值类型，一个整数类型能接受一个表达基数的radix: 参数。强制类型转换可能会失败，因为字符串可能不代表数字。所以，转换的结果不是一个数字，而是一个包裹着数字的Optional。
let s = &amp;#34;31&amp;#34; let i = Int(s) // Optional(31) let s2 = &amp;#34;1f&amp;#34; let i2 = Int(s2, radix: 16) // Optional(31) debugPrint(i, i2)  // Optional(31) Optional(31) 表示字符串长度的属性是count，而不是length。字符串由Unicode码点序列组成，但多个Unicode码点可以组合成一个字符。为了知道这样一个码点序列代表多少个字符，实际上必须遍历这个序列并将其分解成所代表的字符。
同样地，我们也可以遍历字符串中的字符，最简单的方式是使用for in结构：
let s = &amp;#34;hello&amp;#34; for c in s {  print(c) // print each Character on its own line } } 在更深的层次上，可以使用utf8和utf16属性，将一个字符串分解成UTF-8码点或UTF-16码点：
let s = &amp;#34;\u{BF}Qui\u{E9}n?&amp;#34; for i in s.utf8 {  debugPrint(i) // 194, 191, 81, 117, 105, 195, 169, 110, 63 } for i in s.utf16 {  debugPrint(i) // 191, 81, 117, 105, 233, 110, 63 } debugPrint(s) 还有一个unicodeScalars属性，代表一个以UnicodeScalar结构表示的字符串UTF-32码点的集合（String.UnicodeScalarView）。为了说明问题，下面定义了一个实用的函数，可以将两个字母的国家缩写变成国旗表情符号表示：
func flag(country: String) -&amp;gt; String {  let base: UInt32 = 127397  var s = &amp;#34;&amp;#34;  for v in country.unicodeScalars {  s.unicodeScalars.append(UnicodeScalar(base &#43; v.value)!)  }  return String(s) }  debugPrint(flag(country:&amp;#34;CN&amp;#34;)) 奇怪的是，没有更多的方法用于标准的字符串操作。将一个字符串变成大写，或者判断一个字符串是否包含一个给定的子串？大多数现代编程语言都会有一个紧凑、方便的方法来做这样的事情，但Swift没有。
原因是缺失的功能是由Foundation框架提供的，在现实生活中，总与Foundation挂钩（导入UIKit也会导入Foundation）。
一个Swift字符串被桥接到一个Foundation 的NSString。这意味着，在很大程度上，只要使用Swift字符串，Foundation NSString的属性和方法就会神奇地涌现出来：
let s = &amp;#34;hello world&amp;#34; let s2 = s.capitalized // &amp;#34;Hello World&amp;#34; debugPrint(s2) 字符串的capitalized属性来自于Foundation框架，由Cocoa提供，而不是Swift提供，它实际上是NSString的属性。
Range Range对象类型是一个结构体，代表一对端点。形成Range字面量的操作符有两个，提供一个开始值和一个结束值，在它们之间有一个Range操作符：
  ...闭range操作符：a...b意味着a到b的一切，包括b。
  ..&amp;lt;半开range操作符：a..&amp;lt;b意味着a到b的一切，但不包括b。
  在Range操作符两边同时添加空格是合法的，例如1...3或1 ... 3都是合法的。一个Range的端点的类型通常是某种数字，最常见的是整型。但是如果只有一边添加空格，则会报错：
let r = 1...3 // 正常  let range = 1... 3 // 编译错误 Consecutive statements on a line must be separated by &amp;#39;;&amp;#39; 如果结束值是一个负数，它必须用圆括号括起来或在操作符前面加上空格。let r = -1000 ... -1和let r = -1000...(-1)都是可以的。Range的常用场景是for ... in语句:
debugPrint(-1000...-1) // compile error: Ambiguous missing whitespace between unary and binary operators debugPrint(-1000...(-1)) debugPrint(-1000 ... -1) debugPrint(1 ... 1000) for ix in 1...3 {  debugPrint(ix) // 1, then 2, then 3  }  for i in -1...1 {  debugPrint(i) } 在Swift中，没有反向的Range，即Range的起始值不能大于结束值。一旦出现这种情况，编译器不会报错，但运行的时候会发生崩溃。在实际的编程上，可以使用Range的reversed()方法来实现相同的效果：
for i in 1 ... -1 {  debugPrint(i) // 运行时发生崩溃 Fatal error: Range requires lowerBound &amp;lt;= upperBound }  for ix in (1...3).reversed() {  debugPrint(ix) // 3，2，1 } 在实际编程中，可以使用Range的contains(_:)实例方法来测试一个值是否在给定的范围内。例如，可以测试某个数字是否在某个范围内：
let ix = 2 // ... an Int ... if (1...3).contains(ix) {  // ... } 如果只是想测试Range中是否包含某个数字，Range的端点数值可以为Double类型。下面的代码中，测试变量d是否在(0.1...0.9)中是可行的：
let d = 0.3 // ... a Double ... if (0.1...0.9).contains(d) {  debugPrint(&amp;#34;contains \(d)&amp;#34;) } // &amp;#34;contains 0.3&amp;#34; Range的另一个常见用途是对一个序列进行索引。下面是获取一个字符串的第二、第三和第四个字符的一种方法。如果把字符串转换为一个字符数组，可以用一个Int Range作为该数组的索引：
let s = &amp;#34;hello&amp;#34; let arr = Array(s) let result = arr[1...3] let s2 = String(result) // &amp;#34;ell&amp;#34; debugPrint(arr) // [&amp;#34;h&amp;#34;, &amp;#34;e&amp;#34;, &amp;#34;l&amp;#34;, &amp;#34;l&amp;#34;, &amp;#34;o&amp;#34;] debugPrint(s2) // &amp;#34;ell&amp;#34; 字符串本身是一个字符序列，所以可以使用Range来直接索引字符串，但必须是一个String.Index的Range，但是它很难获取。通过操作String.Index值，可以形成一个适当类型的Range，并使用它通过下标提取一个子字符串：
let s = &amp;#34;hello&amp;#34; let ix1 = s.index(s.startIndex, offsetBy:1) let ix2 = s.index(ix1, offsetBy:2) let s2 = s[ix1...ix2] // 闭区间，结果是&amp;#34;ell&amp;#34; debugPrint(s2) 可以在Range字面常量上省略一个端点，形成一个部分Range。有三种形式部分Range表达式，对应三种类型的Range结构，分别是省略前端点的的..&amp;lt;,省略前端点的...以及省略后端点的...:
let str = &amp;#34;hello&amp;#34; let range1 = str.startIndex..&amp;lt;str.endIndex // Range注意endIndex let range2 = ..&amp;lt;str.endIndex // PartialRangeUpTo let range3 = ...str.index(before: str.endIndex) // PartialRangeUpThrough let range4 = str.startIndex... // PartialRangeFrom  debugPrint(str) debugPrint(str[range1]) debugPrint(str[range2]) debugPrint(str[range3]) debugPrint(str[range4])  &amp;#34;hello&amp;#34; &amp;#34;hello&amp;#34; &amp;#34;hello&amp;#34; &amp;#34;hello&amp;#34; &amp;#34;hello&amp;#34; 如果需要将一个部分Range转换为一个Range，可以调用relative(to:)方法。但一般来说，不需要这样做，因为部分Range可以用在任何需要使用Range的地方：
let s = &amp;#34;hello&amp;#34; let ix2 = s.index(before: s.endIndex) let s2 = s[..&amp;lt;ix2] // &amp;#34;hell&amp;#34;  debugPrint(s2) // &amp;#34;hell&amp;#34; debugPrint(s[s.startIndex..&amp;lt;s.endIndex]) //&amp;#34;hello&amp;#34; debugPrint((..&amp;lt;s.endIndex).relative(to: s) == s.startIndex ..&amp;lt; s.endIndex) // true Tuple 元组是一个由多个值组成的轻量级自定义有序集合。作为一种类型，它的表达方式是用圆括号包围所含类型，用逗号分隔开各种类型。下面是一个元组变量的声明，其类型是一个Int和一个String：
var pair : (Int, String) 元组字面量也以同样的方式表达，用圆括号包含值，每个值以逗号隔开。但这些值的类型也可以由编译器推断出来，无需显式声明：
var pair1 : (Int, String) = (1, &amp;#34;Two&amp;#34;) var pair2 = (1, &amp;#34;Two&amp;#34;) 元组是Swift语言特有的，与Cocoa和Objective-C不兼容。元组是解决一个函数只能返回一个值这个问题的好方法。元组是一个特殊的值，它里面包含了多个值，所以可以使用元组作为一个函数的返回类型以返回多个值。
元组也提供了很多语言上便利性，可以一次同时赋值多个不同类型的变量，也可以一次同时声明和初始化多个不同类型的变量，如下所示：
let ix: Int let s: String (ix, s) = (1, &amp;#34;Two&amp;#34;) let (ix, s) = (1, &amp;#34;Two&amp;#34;) var (ix1, s1) = (12, &amp;#34;name&amp;#34;) 如果要将元组中的值赋给某些变量，但又要忽略元组中的某个值的时候，可以在对应位置使用下划线。下面的代码就是只取元组中的第二个值：
let pair = (1, &amp;#34;Two&amp;#34;) let (_, s) = pair // now s is &amp;#34;Two 使用元组可以不借助临时变量来交换两个变量的值，同时也是安全的。使用元组来交换两个变量时，只需要交换元组中变量的位置即可：
var s1 = &amp;#34;hello&amp;#34; var s2 = &amp;#34;world&amp;#34; (s1, s2) = (s2, s1) // now s1 is &amp;#34;world&amp;#34; and s2 is &amp;#34;hello&amp;#34; 访问元组中的值有两种方式。第一种是使用索引来访问元组中的值。例如，上面的pair元组中的第一个值可以使用pair.0来访问，第二个可以使用pair.1来访问。
var pair = (1, &amp;#34;Two&amp;#34;) pair.0 = 2 // now pair is (2, &amp;#34;Two&amp;#34;) 第二种方式是使用标签来访问元组中的值。但在元组声明的时候就需要先加上标签。元组的标签和函数的参数一样，必须作为类型声明的一部分出现：
let pair : (first:Int, second:String) = (1, &amp;#34;Two&amp;#34;) 上面的例子也可以使用let pair = (first:1, second:&amp;quot;Two&amp;quot;)这种简单的方式声明。之后便能使用标签来访问元组中的值，此时仍然可以通过索引访问：
var pair = (first: 1, second: &amp;#34;Two&amp;#34;) debugPrint(pair.first, pair.second)  let x = pair.first // 1 pair.first = 2 let y = pair.0 // 2 在序列中使用enumerated方法既可以遍历元素也可以获得对应的索引。在下面的代码中，第一个for in中使用元组获取索引和元素，第二个for in中通过offset和element来获取：
let s = &amp;#34;hello&amp;#34; for (index, c) in s.enumerated() {  debugPrint(&amp;#34;character \(index)is \(c)&amp;#34;) }  //character 0 is h //character 1 is e //character 2 is l //character 3 is l //character 4 is o  for t in s.enumerated() {  debugPrint(&amp;#34;character \(t.offset)is \(t.element)&amp;#34;) }  //character 0 is h //character 1 is e //character 2 is l //character 3 is l //character 4 is o 需要特别注意的是，可以将一个没有标签的元组赋值给一个有标签的对应元组。相反，也可以将一个有标签的元组赋值给一个没有标签的元组，下面代码都是可行的：
var pair = (1, &amp;#34;Two&amp;#34;) var pairWithNames: (first: Int, second: String) = pair let ix = pairWithNames.first // 1 pair = pairWithNames 但是，如果两个元组包含的相同的类型，但声明的标签不同，则不能相互赋值。如下所示，虽然pair1和pair2的类型相同，但标签不同，会出现编译错误：
var pair1 = (first: 1, second: &amp;#34;test&amp;#34;) debugPrint(pair1.first, pair1.0, pair1.second, pair1.1) var pair2 = (test1: 1, test2: &amp;#34;test2&amp;#34;) debugPrint(pair1.first, pair1.0, pair1.second, pair1.1) pair1 = pair2 // Cannot assign value of type &amp;#39;(test1: Int, test2: String)&amp;#39; to type &amp;#39;(first: Int, second: String)&amp;#39; 可以在函数中传递元组，也可以在一个函数中返回一个没有标签的元组，即使这个函数声明的返回值是带标签的元组，如下所示：
func tupleMaker() -&amp;gt; (first: Int, second: String) {  return (1, &amp;#34;Two&amp;#34;) // no labels here }  let tuple = tupleMaker() debugPrint(tuple.first, tuple.second, tuple.0, tuple.1) // 1 &amp;#34;Two&amp;#34; 1 &amp;#34;Two&amp;#34; Optional 可选对象类型（实质上是一个枚举）包裹着另一个对象，这个被包裹的对象的类型可以为任何类型。可以使用Optional声明或者赋值一个可选变量：
var stringMaybe = Optional(&amp;#34;howdy&amp;#34;) debugPrint(stringMaybe) stringMaybe = Optional(&amp;#34;fareWell&amp;#34;) debugPrint(stringMaybe) var stringMaybe1: String? = Optional(&amp;#34;test&amp;#34;) // optional可选值 debugPrint(stringMaybe1) stringMaybe1 = &amp;#34;name&amp;#34; debugPrint(stringMaybe1)  //Optional(&amp;#34;howdy&amp;#34;) //Optional(&amp;#34;fareWell&amp;#34;) //Optional(&amp;#34;test&amp;#34;) //Optional(&amp;#34;name&amp;#34;) 声明可选值，通常不使用Optional初始化器，而是将某种类型的值分配或传递给一个已经声明成Optional的引用。在上面代码中，一旦stringMaybe被类型化为一个包裹着String的Optional，那么直接向其赋一个String是合法的，赋值的字符串被自动包装成一个Optional。
从形式上看，Optional是一个泛型，所以包裹一个字符串的Optional是一个Optional&amp;lt;String&amp;gt;。实际上，不必这样写，Swift语言支持用语法糖来表达一个Optional类型：被包装类型的名称后面跟一个问号：
var stringMaybe : String? 如果期望是一个Optional包装的某种类型，可以传递一个包装类型的值来代替。这是因为参数传递就像赋值一样：一个未被包裹的值会被隐含地包裹起来。如果一个函数期望一个包裹着字符串的Optional参数，可以直接传递一个字符串参数，它将自动地转换成Optional：
func optionalExpecter(_ s: String?) { // ... here, s will be an Optional wrapping a String ...   debugPrint(s) } optionalExpecter(&amp;#34;howdy&amp;#34;) // console debugPrints: Optional(&amp;#34;howdy&amp;#34;) 如果期望的是一个非Optional的类型，实际上却传递了一个Optional的类型，那么编译器将会报错。下面代码将会出现编译错误：
func realStringExpecter(_ s: String) {  // } let stringMaybe: String? = &amp;#34;howdy&amp;#34; // compile error: Value of optional type &amp;#39;String?&amp;#39; must be unwrapped to a value of type &amp;#39;String&amp;#39; realStringExpecter(stringMaybe) 如果想使用一个Optional，它所包裹的东西的类型是预期的，必须解开这个Optional。也就是说，必须进入它的内部，取出它所包裹的实际东西。
Unwrapping an Optional 已经看到了不止一种将一个对象包裹在一个Optional中的方法。但是相反的过程呢？如何解开一个Optional来获取它里面包裹的对象呢？一种方法是使用unwrap操作符（或强制unwrap操作符），它是一个后缀的感叹号：
func realStringExpecter(_ s: String) {  // } let stringMaybe: String? = &amp;#34;howdy&amp;#34; realStringExpecter(stringMaybe!) 在上面这段代码中，stringMaybe！语法表达了在Optional stringMaybe内部的操作，即获取被包裹的值。由于stringMaybe是一个包裹着String的Optional，它里面的东西就是一个String。这正是realStringExpecter函数想要的实参。stringMaybe是一个包裹着字符串 &amp;quot;howdy &amp;quot;的Optional，但stringMaybe！是字符串 &amp;quot;howdy&amp;quot;。
如果Optional包裹着某个类型，不能直接向它发送这个类型的消息，必须先解开这个Optional，也就是要解开stringMaybe取它里面的String：
let stringMaybe : String? = &amp;#34;howdy&amp;#34; let upper = stringMaybe.uppercased() // compile error // Value of optional type &amp;#39;String?&amp;#39; must be unwrapped to refer to member &amp;#39;uppercased&amp;#39; of wrapped base type &amp;#39;String&amp;#39;  let stringMaybe: String? = &amp;#34;howdy&amp;#34; let upper = stringMaybe!.uppercased() // compile error Implicitly unwrapped Optional Swift提供了另一种使用Optional的方式，即在预期使用包裹的类型是的地方使用隐式解包类型。隐式解包类型也是一种Optional，但是编译器允许它直接在期望包裹类型的地方。
实际上，也可以对一个隐式解包类型进行解包，但没必要这样做，因为如果试图在期望解包类型的地方使用它，将自动解包。
请记住，一个隐式解包的Optional仍然是一个Optional。通过将某些东西声明为隐式解包的Optional，就是在请求编译器，如果碰巧在预期的包装类型中使用这个值，请原谅并自动解包这个值。
实际上，一个隐式解包的Optional类型并不是一个真正的独立类型。它只是一个以特殊方式标记的Optional，允许它在预期解包类型的地方被使用。由于这个原因，隐式解包并不通过赋值传播。
如果self是一个UIViewController，那么self.view的类型就是UIView！。因此，下面这个表达式是合法的（假设v是一个UIView）：
self.view.addSubview(v) 但是，下面是不合法的，因为隐式解包并不通过赋值传播：
let mainview = self.view let v = UIView() mainview.addSubview(v) // compile error 也可以在一开始就显式地解开隐式解包的Optional：
let mainview = self.view! mainview.addSubview(v) The keyword nil 在与nil以外的东西进行相等比较时，Optional得到了特殊的待遇：真正被比较的是被包裹的值，而不是Optional本身被比较：
let s: String? = &amp;#34;Howdy&amp;#34; if s == &amp;#34;Howdy&amp;#34; { // ... they _are_ equal!  debugPrint(true) } 上面的例子中，Swift不会将Optional本身与&amp;quot;Howdy&amp;quot;进行比较，而是自动地（安全地）将其包装值（如果有）与&amp;quot;Howdy&amp;quot;进行比较。如果包裹的值是&amp;quot;Howdy&amp;quot;，则比较成功。如果被包装的值不是&amp;quot;Howdy&amp;quot;，则比较失败。如果没有被包装的值（也就是为nil），那么比较也会安全地失败。
能够使用==操作符，则被包裹的类型必须遵循Equatable协议。如果没有遵守这个协议，编译器会阻止一个Optional类型使用==进行比较。
Object Types Swift中有三种对象（object）类型，它们分别是enum,struct,class。对象类型的作用域取决于类型声明所在的位置，可能出现的位置有三种：
  顶层声明：声明在文件顶部，默认情况下对同一个module中所有文件都是可见的。
  另一个类型声明中内嵌：在另一个类型的声明中内嵌声明一个类型是很有用的，相当于给这个内嵌类型一个命名空间。
  函数体中：在函数体中声明的对象类型的生命周期只存在于包含它的花括号内，这样的声明是合法的，但使用场景较少。
  对于任何对象类型声明时都可以在其花括号内包含以下五个方面的内容：
 初始化器：初始化器是一个函数，以一种特殊的方式声明和调用，以生成对象实例。 属性：在对象类型声明的顶层声明的变量是一个属性。 方法：在对象类型声明的顶层声明的函数是一个方法。 下标：下标是一种特殊的方法，通过在实例引用或类型名称后面加上方括号来调用。 内嵌类型：一个对象类型声明可以包含另一个对象类型声明（内嵌类型）。  Initializers 初始化器是一个用于产生对象实例的函数。严格地说，初始化器是一个静态/类方法，因为它是被对象类型调用的。它通过特殊的语法来调用的：类型的名字后面直接加上圆括号。当一个初始化器被调用时，一个新的实例被创建并作为结果返回：
class Dog {  // } let dog = Dog() 上面的代码中，Dog()调用了一个初始化器，尽管Dog类没有声明任何初始化器，但并没有编译错误。这是因为，如果没有自定义初始化器，则编译器会自动生成一个无参数的初始化器。
除了使用编译器自动生成的初始化器，也可以编写自己的初始化器。初始化器是一种特殊的函数，有特殊的声明语法，不需要使用func关键字、箭头符号以及返回值类型。
自定义初始化器的声明使用关键字init和一个参数列表，然后紧跟函数体。一个对象类型可以有多个初始化器，以其参数（个数和类型以及顺序）来区分：
class Dog {  var name = &amp;#34;&amp;#34;  var license = 0   init(name: String) {  self.name = name  }   init(license: Int) {  self.license = license  }   init(name: String, license: Int) {  self.name = name  self.license = license  } } 上面自定义了三个初始化器，即提供了三种方式创建Dog实例。但现在已经不能使用没有参数的初始化器了，因为一旦有了自定义的初始化器，编译器就不会再自动生成无参的初始化器了：
let fido = Dog(name: &amp;#34;Fido&amp;#34;) let rover = Dog(license: 1234) let spot = Dog(name: &amp;#34;Spot&amp;#34;, license: 1357) 也可以显式声明一个无参的自定义初始化器，以避免使用使用无参初始化器时出现编译报错。下面代码声明了一个无参初始化器init():
class Dog {  var name = &amp;#34;&amp;#34;  var license = 0  init() {  //  }   init(name: String) {  self.name = name  }   init(license: Int) {  self.license = license  }   init(name: String, license: Int) {  self.name = name  self.license = license  } } 当实例生成时，如果实例属性还没有初始值，则编译器会报错。因此，一个属性可以作为其声明的一部分被初始化，或被其中的每个初始化器初始化，否则会出现编译错误。
Swift编译器强制要求所有的实例属性都要正确地初始化，这是Swift的一个重要特征。相比之下，Objective-C的实例属性可以不初始化，而且经常会这样，导致可能出现奇怪的错误。
因为在初始化器中设置一个实例属性也算作初始化，所以即使实例属性是用let声明的常量也是合法的。下面代码将name和license都声明为常量属性，在初始化器中再初始化也是合法的：
class Dog {  let name: String  let license: Int   init(name: String, license: Int) {  self.name = name  self.license = license  } } Deferred initialization of properties 有时，在初始化时还不能初始化一个实例属性为有意义的值。也许这个属性的初始值要在这个实例生成后的某个时间点才能得到。这种情况与所有实例属性在其声明中初始化或通过初始化器进行初始化的要求相冲突。
可以通过分配一个默认的初始值来规避这个问题，但此时无法向你自己的代码传达这样一个事实：这个默认值不是real的值。
一个常见的解决方案是将实例属性声明为Optional类型的var。Optional类型有一个值nil，表示没有提供real的值，并且一个Optional var会自动初始化为`nil。
因此，代码中可以用nil来测试这个Optional实例属性，如果它是nil，就暂时不要使用这个属性。该属性会在某个时刻被赋予real值，这个值是被包裹在Optional中的。
// this property will be set automatically when the nib loads @IBOutlet var myButton: UIButton!  // this property will be set after time-consuming gathering of data  var albums : [MPMediaItemCollection]? Referring to self 一个初始化器可以引用一个已经初始化的实例属性，也可以引用一个未初始化的实例属性，以便初始化它。除了这种情况，在所有实例属性被初始化之前，初始化器不得显式或隐式地引用self。这条规则保证了实例在使用之前已经完全生成。
struct Cat {  var name: String  var license: Int  init(name: String, license: Int) {  self.name = name  meow() // too soon - compile error  self.license = license  }   func meow() {  print(&amp;#34;meow&amp;#34;)  } } 上面代码会出现编译错误&#39;self&#39; used before all stored properties are initialized，因为license属性还未初始化前就已经调用了meow。
Delegating initializers 在初始化器中，如果调用了另一个初始化器，那这个初始化器被称为代理初始化器。代理初始化器调用的其它初始化器必须已经将所有的存储属性初始化，否则会出现编译错误。
当一个初始化器进行委托时，另一个初始化器（它所委托的那个），必须先完全初始化实例，然后委托的初始化器可以对完全初始化的实例进行处理，可能会再次设置已经被它所委托的初始化器设置的var属性。
代理初始化器看起来是过早使用self调用函数的一个反例，但事实并不是这样，代理初始化使用self调用函数是为了初始化储存属性。
代理初始化器在调用其它初始化器之前不能使用self，即使是给存储属性赋初值也不行。下面代理初始化器中，第一行是初始化meaningOfLife，会出现编译错误：
struct Digit {   var number: Int  var meaningOfLife: Bool   init(number: Int) {  self.number = number  self.meaningOfLife = false  }   init() { // this is a delegating initializer  self.meaningOfLife = false //&amp;#39;self&amp;#39; used before &amp;#39;self.init&amp;#39; call or assignment to &amp;#39;self&amp;#39;  self.init(number: 42)  }  } 在代理初始化器中，不能再对let常量属性赋值，因为调用其它初始化器时已经将常量属性赋了初始值，如果再次对其赋值会出现编译错误。因为在代理初始化器中可以调用其它初始化器，千万不要形成递归调用，下面代码就会产生递归引用：
// do not do this! struct Digit {   var number: Int = 100   init(value: Int) {  self.init(number: value)  }   init(number: Int) {  self.init(value: number)  }  } 也就是说在一个初始化器中，一旦出现了另一个初始化器，那么这个初始化器必须在第一行，否则将会出现编译错误！
Failable initializers 一个初始化器可以返回一个可选的新实例，返回nil表示初始化失败，这种初始化器被称为可失败的初始化器。声明可失败的初始化器很简单，只要在init后面添加一个?即可:
class Dog {   let name: String  let license: Int   init?(name: String, license: Int) {  if name.isEmpty {  return nil // 返回nil  }  if license &amp;lt;= 0 {  return nil  }  self.name = name  self.license = license  } } Properties Property initialization and self 实例属性在声明的同时可以进行初始化，但初始化某个实例属性时不能获取其它实例属性或调用一个实例方法，因为此时实例尚未生成。下面代码中whole初始化时获取了其他属性，所以会出现编译错误：
class Moi {  let first = &amp;#34;Matt&amp;#34;  let last = &amp;#34;Neuburg&amp;#34;  let whole = self.first &#43; &amp;#34; &amp;#34; &#43; self.last // compile error: Cannot find &amp;#39;self&amp;#39; in scope } 解决上面编译错误有三种方法，第一种是把whole声明为计算属性而非存储属性，因为计算属性是在实例初始化完成之后才会被调用的：
class Moi {  let first = &amp;#34;Matt&amp;#34;  let last = &amp;#34;Neuburg&amp;#34;   var whole: String {  self.first &#43; &amp;#34; &amp;#34; &#43; self.last  } } 第二种方法是把whole声明为lazy的var变量。同计算变量一样，lazy变量也是要等实例初始化完成之后才会被调用：
class Moi {  let first = &amp;#34;Matt&amp;#34;  let last = &amp;#34;Neuburg&amp;#34;  lazy var whole = self.first &#43; &amp;#34; &amp;#34; &#43; self.last  } 第三种方法就是使用匿名函数的define-and-call进行初始化。因为要在匿名函数中使用self，所以也需要把实例属性声明为lazy：
class Moi {  let first = &amp;#34;Matt&amp;#34;  let last = &amp;#34;Neuburg&amp;#34;  lazy var whole: String = {  var s = self.first  s.append(&amp;#34; &amp;#34;)  s.append(self.last)  return s  }()  } 不像实例属性，静态属性可以在初始化的时候引用其他静态属性，因为静态属性初始化器本身就是lazy的。下面的代码不会出现编译错误：
struct Greeting {  static let friendly = &amp;#34;hello there&amp;#34;  static let hostile = &amp;#34;go away&amp;#34;  static let ambivalent = friendly &#43; &amp;#34; but &amp;#34; &#43; hostile }  debugPrint(Greeting.ambivalent) 上面的代码中，静态属性进行初始化的时候省略了self，这是因为它隐含地包含了self，但是上面代码中不能显式使用self（自认为是编译器的一个bug）。
对于静态属性来说，大写开头的Self表示类型本身。实际上在静态属性初始化时，如果要引用其它静态属性，前面加上自身的类型会有更好的可读性：
struct Greeting {  static let friendly = &amp;#34;hello there&amp;#34;  static let hostile = &amp;#34;go away&amp;#34;  static let ambivalent = Greeting.friendly &#43; &amp;#34; but &amp;#34; &#43; Greeting.hostile }  struct Greeting {  static let friendly = &amp;#34;hello there&amp;#34;  static let hostile = &amp;#34;go away&amp;#34;  static let ambivalent = Self.friendly &#43; &amp;#34; but &amp;#34; &#43; Self.hostile } 需要特别注意的是，在声明静态计算变量时，如果使用匿名函数的define-and-call初始化，不能在匿名函数中使用self（自认为这是一个系统bug），而是应该使用大写的S开头的Self：
struct Greeting {  static let friendly = &amp;#34;hello there&amp;#34;  static let hostile = &amp;#34;go away&amp;#34;  static var ambivalent: String = {  self.friendly &#43; &amp;#34; but &amp;#34; &#43; self.hostile // compile error: Cannot find &amp;#39;self&amp;#39; in scope  }() } struct Greeting {  static let friendly = &amp;#34;hello there&amp;#34;  static let hostile = &amp;#34;go away&amp;#34;  static var ambivalent: String = {  friendly &#43; &amp;#34; but &amp;#34; &#43; hostile // 省略self才不会报错  }() }  struct Greeting {  static let friendly = &amp;#34;hello there&amp;#34;  static let hostile = &amp;#34;go away&amp;#34;  static var ambivalent: String = {  Self.friendly &#43; &amp;#34; but &amp;#34; &#43; Self.hostile // 或者使用大写开头Selfscope  }() } Methods 在静态/类成员和实例成员之间存在着一种隔阂，尽管它们被声明在同一个对象类型中，但属于不同的世界。一个静态/类方法不能引用instance，因为在静态方法中没有实例。
因此，一个静态/类方法不能直接引用任何实例属性或调用任何实例方法。另一方面，一个实例方法可以引用类型，因此可以访问静态/类的属性，能调用静态/类方法。
The Secret Life of Instance Methods 实际上，实例方法也是静态/类方法。在下面的代码中，尽管store是一个实例方法，但可以通过类型来调用，只需把一个实例参数传进去：
class MyClass {  var s = &amp;#34;&amp;#34;   func store(_ s: String) {  self.s = s  debugPrint(&amp;#34;MyClass test&amp;#34;)  }  }  let m = MyClass() let f = MyClass.store(m) // what just happened!? f(&amp;#34;s&amp;#34;) debugPrint(m.s) 原因是，一个实例方法实际上是一个柯里化的静态/类函数。一个函数接受一个实例，另一个函数接受实例方法的参数。在上面代码中，f是第二个函数，并可以作为传递参数给实例m的store方法的一种方式被调用：
f(&amp;#34;howdy&amp;#34;) debugPrint(m.s) Subscripts 下标是一种方法，它通过将包含参数的方括号直接附加到一个对象的引用上来调用。可以把这个功能用于任何你喜欢的地方，但它特别适用于这样的情况：一个对象类型，其元素可以通过键或索引来访问。
声明下标方法有点像普通函数的声明又有点像计算属性的声明。它可以接受参数，当下标方法被调用时，参数可以出现在方括号中。一个下标就像一个计算属性，它的调用就像引用一个属性，可以获取它的值，也可以向它赋值：
struct Digit {  var number: Int   init(_ n: Int) {  self.number = n  }   subscript(ix: Int) -&amp;gt; Int { // ① ②  get { // ③  let s = String(self.number)  return Int(String(s[s.index(s.startIndex, offsetBy: ix)]))!  }  }  }   关键字sbuscript后面紧跟参数列表，说明方括号内要出现哪些参数。默认情况下，参数名不会被外化。如果要外化参数名，需要在内部参数前外化，即使它们的名字是相同的subscript(ix ix:Int)，这一点和普通函数的参数外化十分不同。
  然后箭头后面紧跟的传出（调用getter函数时）或传入（调用setter函数时）值的类型。
  最后是花括号，其内容与计算属性的内容完全一样。可以用get和花括号表示getter函数，用set和花括号表示setter函数。setter函数可以被省略，在这种情况下，get这个词和它的花括号可以一同被省略。如果getter函数只由一条语句组成，可以省略关键字return。setter函数接收的新值是newValue，但可以通过在set这个词后面的圆括号里提供一个不同的名字来实现自定义名字。
  下面代码调用了subscript中的getter的方法。在Digit实例后面跟着方括号，方括号里面有Int参数：
var d = Digit(1234) let aDigit = d[1] 下面代码中Digit类型中包含了subscript下标方法，并且下标方法中也包含了setter，可以使用d[0] = 2这样的语句来访问下标的setter：
struct Digit {   var number: Int   init(_ n: Int) {  self.number = n  }   subscript(ix: Int) -&amp;gt; Int {  get {  let s = String(self.number)  return Int(String(s[s.index(s.startIndex, offsetBy: ix)]))!  }  set {  var s = String(self.number)  let i = s.index(s.startIndex, offsetBy: ix)  s.replaceSubrange(i...i, with: String(newValue))  self.number = Int(s)!  }  } } 一种类型中可以声明多个subscript方法，以参数个数和类型进行区分。从Swift 5.1开始，subscript方法可以是静态的。从Swift 5.2开始，subscript方法可以有默认参数:
struct NewDigit {   var number: Int   init(_ n: Int) {  self.number = n  }   subscript(ix: Int) -&amp;gt; Int {  get {  let s = String(self.number)  return Int(String(s[s.index(s.startIndex, offsetBy: ix)]))!  }  set {  var s = String(self.number)  let i = s.index(s.startIndex, offsetBy: ix)  s.replaceSubrange(i...i, with: String(newValue))  self.number = Int(s)!  }  }   static subscript(index: String) -&amp;gt; Int {  debugPrint(index)  return 0  }   subscript(index: Double = 0) -&amp;gt; Int {  debugPrint(index)  return 0  } } 需要注意的是对于下标的重载来说，如果均没有使用外部参数，并且只是内部参数名不同，参数的个数、类型以及顺序都相同的话，会出现编译错误，这是因为没有外部参数时仅使用方括号调用：
subscript(ix: Int) -&amp;gt; Int {  get {  let s = String(self.number)  return Int(String(s[s.index(s.startIndex, offsetBy: ix)]))!  }  set {  var s = String(self.number)  let i = s.index(s.startIndex, offsetBy: ix)  s.replaceSubrange(i...i, with: String(newValue))  self.number = Int(s)!  } } subscript(newIndex: Int) -&amp;gt; Int {  debugPrint(newIndex)  return 0 } 如果只是外部参数不同，内部参数个数和类型都相同，则不会出现编译错误，因为编译器会认为这是不同的subscript方法：
class Dog {  var name: String  let license: Int  init?(name: String, license: Int) {  if name.isEmpty {  return nil // 返回nil  }  if license &amp;lt;= 0 {  return nil  }  self.name = name  self.license = license  }  subscript(at index: Int) -&amp;gt; String {  get {  return self.name  }  set {  self.name = newValue  }  }  subscript(for index: Int) -&amp;gt; String {  get {  return self.name  }  set {  self.name = newValue  }  } } let dog = Dog(name: &amp;#34;test&amp;#34;, license: 1345) dog?[at: 123] dog?[for: 134] Nested Object Types 一个类型声明在另一个类型里面，就会形成内嵌类型。嵌套的对象类型与其它对象类型没有什么不同，但是从外部引用内嵌类型的规则发生了变化，外部的对象类型作为一个命名空间，必须明确地被引用才能访问嵌套的对象类型。
class Dog {  struct Noise {  static var noise = &amp;#34;woof&amp;#34;  }   func bark() {  debugPrint(Dog.Noise.noise)  } } // 访问静态属性 Dog.Noise.noise = &amp;#34;arf&amp;#34; 在上面的代码中，结构体Noise定义在类Dog中，它并不是自由的，而是明确地与Dog类相关联，属于Dog中的类型。不同的命名空间允许有相同的Noise类型存在，而不会产生冲突。
在Swift的内置类型中，经常使用命名空间来解决类型冲突。例如，String结构体是包含Index结构体的几个结构体之一，但它们并没有名字冲突。
嵌套的内部类型不能直接访问其外部类型的实例成员，但是能直接访问其静态/类成员。在下面的代码中，Noise类型不能直接访问Dog类型的实例方法bark，但是能直接访问它的静态属性sound:
class Dog {  static let sound = &amp;#34;ruff&amp;#34;  struct Noise {  static var noise = &amp;#34;woof&amp;#34;  func barkTheDog() {  bark() // compile error: Instance member &amp;#39;bark&amp;#39; of type &amp;#39;Dog&amp;#39; cannot be used on instance of nested type &amp;#39;Dog.Noise&amp;#39;  }  var othernoise = sound // fine  }   func bark() {  debugPrint(Dog.Noise.noise)  } } 在上面的代码中，内嵌类型Noise能直接访问静态属性sound，而不需要使用Dog.sound，因为外层定义的静态属性sound，对于内嵌类型来说是全局的。
Enums 枚举是一种对象类型，它的实例代表不同的预定义可选择值，可以将这些预定义值看作是一个已知可能值列表，枚举是表达一组常量值的Swift方式。枚举声明包含case语句，每个case是一个可选择值的名称，一个枚举实例准确地代表一种选择：
enum Filter {  case albums  case playlists  case podcasts  case books } 上面定义的枚举Filter没有初始化器，实际上是可以自定义枚举类型的初始化器。但有一个默认的初始化器，可能在大多数时候都会使用它，即枚举的名称后面加上点号和其中一个case。
let type = Filter.albums let type: Filter = .albums 有相同case枚举实例被认为是相同的。可以将一个枚举实例与一个case进行比较：
func filterExpecter(_ type: Filter) {  if type == .albums {  print(&amp;#34;it is albums&amp;#34;)  } } filterExpecter(.albums) // &amp;#34;it is albums&amp;#34; Raw Values 在使用enum声明枚举类型时，可以添加一个类型声明，但这种类型只限于数值型和字符串。如果增加的类型是整数类型，每个case都有默认值，默认值从0开始：
enum PepBoy: Int {  case manny  case moe  case jack } 在上面代码中，.manny的默认值是0，.moe的值是1，以此类推。如果类型是字符串，在定义枚举时如果不设置某个case对应的字符串，则默认值是该case对应的名字。下面代码中，.albums的默认值是&amp;quot;albums&amp;quot;，.playlists的值是&amp;quot;playlists&amp;quot;，以此类推：
enum Filter: String {  case albums  case playlists  case podcasts  case books } 如果在声明带类型的枚举时，不管声明枚举时使用的是哪种类型，如果不想使用默认值，可以为每个case显式赋值：
enum Normal: Double {  case fahrenheit = 98.6  case centigrade = 37 } enum PepBoy: Int {  case manny = 1  case moe // 2 implicitly  case jack = 4 } enum Filter: String {  case albums = &amp;#34;Albums&amp;#34;  case playlists = &amp;#34;Playlists&amp;#34;  case podcasts = &amp;#34;Podcasts&amp;#34;  case books = &amp;#34;Audiobooks&amp;#34; } case所携带的值称为raw value。一个有类型声明的枚举隐含地遵循了RawRepresentable协议，这意味着它有一个init(rawValue:)初始化器和一个rawValue属性。
enum Normal: Double {  case fahrenheit = 98.6  case centigrade = 37 }  enum PepBoy: Int {  case manny = 1  case moe // 2 implicitly: 默认为2  case jack = 4 }  enum Filter: String {  case albums = &amp;#34;Albums&amp;#34;  case playlists = &amp;#34;Playlists&amp;#34;  case podcasts = &amp;#34;Podcasts&amp;#34;  case books = &amp;#34;Audiobooks&amp;#34; }  let type = Filter.albums print(type.rawValue) // Albums 带类型的枚举声明时，每个case的raw value必须保证是唯一的，否则会出现编译错误。因此，可以使用raw value实例化一个枚举：
let type = Filter(rawValue:&amp;#34;Albums&amp;#34;) 但使用init(rawValue:)可能失败，因为用户传入的raw value可能与case不匹配，所以它实际上是可失败的初始化器init?(rawValue:)。
Associated Values 上面说的raw value对于每个case来说都是固定的，在枚举类型声明的时候就已经确定了。有一种方法可以构造一个case，使得其常量值可以在实例创建时才被设置，此时设置的附加值被称为associated value。
声明带associated value的枚举类型时，不能为整个枚举类型声明任何原始值类型。而是在有需要的case上附加一个看起来像元组的表达式，即括号里包含一个可能的标记类型列表。与rawValue不同，associated value无类型上的限制：
enum MyError {  case number(Int)  case message(String)  case fatal } 上面声明的含义为：在MyError实例化时，一个.number case的MyError实例必须被设置一个Int值，一个.message case的MyError实例必须设置一个String值，而一个.fatal case的MyError实例不用设置任何值。
let err1 : MyError = .number(4) let num = 4 let err2 : MyError = .number(num) 如果一个case的associated value类型有标签，标签必须在初始化的时候使用。下面代码中，枚举中的case fetal有标签，需要在初始化时使用：
enum MyError2 {  case number(Int)  case message(String)  case fatal(n: Int, s: String) }  let err: MyError2 = .fatal(n: -12, s: &amp;#34;Oh the horror&amp;#34;) 默认情况==操作符不能直接用于比较带有associated value的枚举，否则会出现编译错误。下面代码中，因为直接比较两个枚举值，会出现编译错误：
enum MyError2 {  case number(Int)  case message(String)  case fatal(n: Int, s: String) }  let err: MyError2 = .fatal(n: -12, s: &amp;#34;Oh the horror&amp;#34;)  // operator &amp;#39;==&amp;#39; cannot be applied to operands of type &amp;#39;MyError2&amp;#39; and &amp;#39;(Int, String) -&amp;gt; MyError2&amp;#39; if err == MyError2.fatal { // compile error  // } 如果声明带associated value枚举时显式地遵循Equatable协议，==操作符就能正常工作了。但前提是所有associated value中的类型本身都是遵循Equatable协议，否则也会出现编译错误：
enum MyError: Equatable {  case number(Int)  case message(String)  case fatal }  let error: MyError = .fatal  if error == .fatal {  debugPrint(true) } Optional 现在可以揭露Optional是如何工作的。一个Optional只是一个有两个case的枚举：.none和.some。如果它是.none，它没有关联值，相当于nil。如果它是.some，它就会携带包装好的值作为其关联值。
Inference of Type Name with Static/Class Members 如同在枚举实例被期望的地方可以使用点和枚举case一样，当引用一个类型的静态/类成员的值是该类型的一个实例时，可以做同样的事情。
p.trackTintColor = .red // instead of UIColor.red 例如，UIColor有许多由UIColor实例生成的类属性，所以可以在预期有UIColor的地方省略UIColor前缀。从Swift 5.4开始，可以在静态/类成员后附加一个属性或方法调用，同时产生预期的类型
p.trackTintColor = .red.withAlphaComponent(0.5) 类似地，假设有一个带有静态常量的结构体Thing，其值是Thing的实例。那么在声明Thing变量或者常量时可以使用点操作符来引用该静态常量：
struct Thing: RawRepresentable {  let rawValue: Int  // 静态成员  static let one: Thing = Thing(rawValue: 1)  // 静态成员  static let two: Thing = Thing(rawValue: 2) }  let thing1: Thing = .one let thing2: Thing = .two 同样地，当一个类型有一个静态/类方法产生该类型的实例时，在期望有一个该类型实例的地方，可以省略类型名，初始化器就是这样的方法：
struct Dog {  let name: String   static func same(text: String) -&amp;gt; Dog {  return Dog(name: text)  } }  func dogExpecter(_ dog: Dog) {  debugPrint(dog.name) }  dogExpecter(.init(name: &amp;#34;Fido&amp;#34;)) dogExpecter(.same(text: &amp;#34;Foo&amp;#34;)) Enum Case Iteration 如果声明的枚举类型遵循了CaseIterable协议，那么它就会有一个allCases静态属性，这个属性包含了该枚举的所有case值：
enum Filter: String, CaseIterable {  case albums = &amp;#34;Albums&amp;#34;  case playlists = &amp;#34;Playlists&amp;#34;  case podcasts = &amp;#34;Podcasts&amp;#34;  case books = &amp;#34;Audiobooks&amp;#34; }  debugPrint(Filter.allCases) // [Command.Filter.albums, Command.Filter.playlists, Command.Filter.podcasts, Command.Filter.books] Enum Initializers 一个自定义枚举初始化器必须做默认初始化所做的事，即必须返回枚举的一个case。要做到这一点，需要将self设置为该case。在下面的代码中，声明了枚举初始化器，以便它可以用一个数字参数进行初始化：
enum Filter: String, CaseIterable {  case albums = &amp;#34;Albums&amp;#34;  case playlists = &amp;#34;Playlists&amp;#34;  case podcasts = &amp;#34;Podcasts&amp;#34;  case books = &amp;#34;Audiobooks&amp;#34;   init?(_ ix: Int) {  if !Filter.allCases.indices.contains(ix) {  return nil  }  self = Filter.allCases[ix]  } } 现在有三种方式可以创建一个Filter实例。第一种是使用Filter类型&#43;点操作符，第二种是使用rawValue，第三种方式是使用上面自定义的初始化器：
let type1 = Filter.albums let type2 = Filter(rawValue: &amp;#34;Playlists&amp;#34;)! let type3 = Filter(2) // .podcasts debugPrint(Filter.allCases) // [Command.Filter.albums, Command.Filter.playlists, Command.Filter.podcasts, Command.Filter.books] debugPrint(type1, type2, type3) // Command.Filter.albums Command.Filter.playlists Optional(Command.Filter.podcasts) 一个枚举类型可以有多个初始化器，枚举初始化器可以通过调用self.init(...)委托其它初始化器来完成初始化。唯一的要求是在调用链的某个时刻，self必须设置为某个case，否则会出现编译错误。下面代码新增了一个可失败的初始化器，在其中调用了另一个初始化器：
enum Filter: String, CaseIterable {   case albums = &amp;#34;Albums&amp;#34;   case playlists = &amp;#34;Playlists&amp;#34;   case podcasts = &amp;#34;Podcasts&amp;#34;   case books = &amp;#34;Audiobooks&amp;#34;   init?(_ ix: Int) {  if !Filter.allCases.indices.contains(ix) {  return nil  }  self = Filter.allCases[ix]  }   /// 代理初始化器  init?(_ rawValue: String) {  self.init(rawValue: rawValue)  }  } 在上面的代码中，改进了Filter枚举，以便它可以用一个字符串的原始值进行初始化，而不必在调用中使用rawValue：。因此，声明了一个带有字符串参数可失败的初始化器，该参数委托给内置的可失败的rawValue:初始化器。
Enum Properties 枚举类型既可以有实例属性也可以有静态属性，但实例属性只能是计算属性不能是存储属性，计算实例属性可以根据self值变化而变化：
enum Filter: String {  case albums = &amp;#34;Albums&amp;#34;  case playlists = &amp;#34;Playlists&amp;#34;  case podcasts = &amp;#34;Podcasts&amp;#34;  case books = &amp;#34;Audiobooks&amp;#34;   var query: MPMediaQuery {  switch self {  case .albums:  return .albums()  case .playlists:  return .playlists()  case .podcasts:  return .podcasts()  case .books:  return .audiobooks()  }  } } 如果一个枚举实例计算属性有setter方法，则其它代码可以赋值这个属性，但是更改这个计算属性的枚举实例本身必须是var而不是let声明的，否则会出现编译错误（因为let声明的常量不可以再被赋值，Cannot assign to property: &#39;silly&#39; is a &#39;let&#39; constant）：
enum Silly {  case one  var sillyProperty: String {  get {  &amp;#34;Howdy&amp;#34;  }  set {  //   }  // do nothing  } }  // 必须使用var声明 var silly = Silly.one silly.sillyProperty = &amp;#34;silly&amp;#34; 枚举类型的静态属性可以有一个property wrapper，但实例属性不能，因为枚举类型的实例属性必须都是计算属性，无法满足property wrapper底层存储属性的要求。
Enum Methods 枚举类型既可以有实例方法（包括下标）也可以有静态方法。下面代码中声明的枚举类型Shape定义了一个实例方法addShape，它根据self的值完成对应的操作：
enum Shape {  case rectangle  case ellipse  case diamond   func addShape(to p: CGMutablePath, in r: CGRect) -&amp;gt; () {  switch self {  case .rectangle:  p.addRect(r)  case .ellipse:  p.addEllipse(in: r)  case .diamond:  p.move(to: CGPoint(x: r.minX, y: r.midY))  p.addLine(to: CGPoint(x: r.midX, y: r.minY))  p.addLine(to: CGPoint(x: r.maxX, y: r.midY))  p.addLine(to: CGPoint(x: r.midX, y: r.maxY)) p.closeSubpath()  }  } } 在前面说过subscript可以是静态方法，因此可以定义一个静态的subscript来获取遵循CaseIterable协议的某个case，代码如下所示：
enum Filter: String, CaseIterable {  case albums = &amp;#34;Albums&amp;#34;  case playlists = &amp;#34;Playlists&amp;#34;  case podcasts = &amp;#34;Podcasts&amp;#34;  case books = &amp;#34;Audiobooks&amp;#34;   static subscript(ix: Int) -&amp;gt; Filter {  guard ix &amp;gt;= 0 &amp;amp;&amp;amp; ix &amp;lt; Filter.allCases.count else {  return .albums  }  return Filter.allCases[ix]  } }  debugPrint(Filter[2]) 如果枚举的某个实例方法想要修改枚举实例本身，则声明的时候要标记为mutating，因为它也是一种值类型。例如，一个枚举的实例方法可能会赋值给self的一个实例属性，即使这是一个计算属性，这种赋值也是非法的，除非该方法被标记为mutating，需要注意的是调用mutating方法的实例变量也必须声明为var。
在一个mutating枚举实例方法中，可以改变自身，方法是将另一个实例分配给self。下面的代码在advance方法中改变了自身：
enum Filter: String, CaseIterable {   case albums = &amp;#34;Albums&amp;#34;  case playlists = &amp;#34;Playlists&amp;#34;  case podcasts = &amp;#34;Podcasts&amp;#34;  case books = &amp;#34;Audiobooks&amp;#34;   static subscript(ix: Int) -&amp;gt; Filter {  guard ix &amp;gt;= 0 &amp;amp;&amp;amp; ix &amp;lt; Filter.allCases.count else {  return .albums  }  return Filter.allCases[ix]  }   mutating func advance() {  let cases = Filter.allCases  guard var ix = cases.firstIndex(of: self) else {  return  }  ix = (ix &#43; 1) % cases.count  self = cases[ix]  } }  var type = Filter.books type.advance() // type is now Filter.albums 在上面代码中，type声明时使用var，如果使用let声明会出现编译错误。下标或计算属性的setter默认是mutating的，不需要特殊标记。如果一个计算属性的getter中设置另一个属性，那么必须标记为mutating。
structs 结构体是Swift对象类型中的佼佼者，而枚举由固定的case集合组成，是一种简化的、特化的对象。在另一个极端，类往往会被证明是过度的，它包含了一些结构体所缺乏的功能，但如果是不需要这些功能的场景，结构体可能是更好的选择。
在Swift头文件中声明的200多种对象类型中，可能有半打是类，有几十个是枚举，其余的都是结构体。String是一个结构体，Int是结构体，Range是结构体，Array也是结构体。
Struct Initializers 如果结构体没有存储属性或者全部的存储属性在声明的时候已经有默认值，则会自动生成一个无参的初始化器init()。下面代码中，编译器会为Digit结构体自动生成一个无参初始化器init()：
struct Digit {  var number = 42 } 一旦在代码中增加了新的自定义初始化器，编译器将不会自动生成无参的初始化器。下面代码中，已经在Digit增加一个有参的初始化器，则编译器不会生成无参的初始化器：
struct Digit {  var number = 42  init(number: Int) {  self.number = number  } } 此时，如果想要使用Digit()生成新的实例，将会出现编译报错。需要手动再声明一个无参的初始化器，才能通过编译：
struct Digit {  var number = 42   init() {  //  }   init(number: Int) {  self.number = number  } } 有存储属性且没有显式初始化器的结构体会自动获得一个从其实例属性派生的隐式初始化器，这称为memberwise initializer(成员初始化器)：
struct Test {  var number = 42  var name: String  let age: Int  let greeting = &amp;#34;Hello&amp;#34; } 上面代码是合法，虽然看起来没有履行在声明或者初始化器中初始化所有储存属性的契约。实际上，因为没有自定义初始化器，编译器会根据实例属性自动生成一个隐式初始化器，这个初始化器被称为memberwise initializer(成员初始化器)，这个memberwise initializer初始化了所有未初始化的属性：
struct Test {  var number = 42  var name: String  let age: Int  let greeting = &amp;#34;Hello&amp;#34; }  let t1 = Test(number: 42, name: &amp;#34;matt&amp;#34;, age: 65) let t2 = Test(name: &amp;#34;matt&amp;#34;, age: 65) 上面自动生成的memberwise initializer包含了number,name,age，不包括greeting。这是因为greeting是使用let声明的，在声明的时候已经初始化了。
因为number使用var声明，并且在声明的同时已经被初始化了，从Swift 5.1后调用memberwise initializer时可以省略这种用var声明并且已经初始化了的属性：
let t2 = Test(name: &amp;#34;matt&amp;#34;, age: 65) 如果在结构体声明的时候，声明了自定义的初始化器或者属性声明为private(使用let声明并且已经初始化的属性除外)，则编译器不会自动生成memberwise initializer。下面代码中，因为声明了private实例属性，所以没有自动生成成员初始化器：
struct MoTest {  private var age = 18  var name: String } debugPrint(MoTest(name: &amp;#34;test&amp;#34;).name)  // &amp;#39;MoTest&amp;#39; initializer is inaccessible due to &amp;#39;private&amp;#39; protection level 下面虽然有private的属性，但因为是let声明的，所以还是会自动生成成员初始化器：
struct MoTest {  private let age = 18  var name: String } debugPrint(MoTest(name: &amp;#34;test&amp;#34;).name) 结构体中声明的存储属性必须全部初始化，不管是声明的时候初始化还是在所有的初始化器中初始化。如果一个结构体有多个初始化器，则可以在初始化器中通过self.init()调用其它初始化器。
Struct Properties 结构体可以有实例属性或者静态属性，二者均可以声明为存储或者计算属性。如果代码中想重新设置一个结构体实例属性的值，则该实例变量必须使用var声明，否则会出现编译错误：
var d = Test(name: &amp;#34;ddd&amp;#34;,age: 34) d.name = &amp;#34;new test&amp;#34;  struct Digit1 {  var number: Int  init(_ n: Int) {  self.number = n  } } var digit1 = Digit1(123) digit1.number = 345 debugPrint(digit1.number) Struct Methods 结构体可以有实例方法和静态方法，包括subscript(下标)，如果一个实例方法想要设置结构体中某个属性的值，那么这个方法一定要声明为mutating，并且调用这个方法的实例也必须使用var声明，否则会出现编译错误：
struct Digit {   private var number: Int   init(_ n: Int) {  self.number = n  }   mutating func changeNumberTo(_ n: Int) {  self.number = n  }  }  var d = Digit(123) d.changeNumberTo(42) 获取一个懒加载实例属性的值可能会导致该属性的初始化器运行，设置该属性的值，也就是这是一个可变的属性。因此，如果一个实例方法获取了一个懒加载的实例属性的值，那么它必须被声明为mutating的:
struct Person {  private lazy var name = &amp;#34;matt&amp;#34;  mutating func getName() -&amp;gt; String {  return self.name  } } 结构体subscript或者计算属性的setter方法默认认为是mutating，不必显式地声明为mutating。但是如果在它们的get方法中要设置其它属性的值，必须显式地声明为mutating。声明为mutating的方法中可以使用该类型的另一个实例设置self的方式来改变自身。
Constant Namespaces 经常使用degenerate struct作为常量的便捷命名空间，之所以称为degenerate，是因为结构体中全部为静态成员，并且不打算使用这种对象类型来制造任何其它实例。
UserDefaults是一种字典，每个值可以通过一个键来访问。这些键通常是字符串，一个常见的错误是使用键时拼错了键的名字，虽然在编译时不会报错，但代码将不能正常工作。
更好的方法是将这些键用带名字的常量字符串来表示。此时，如果错误地输入了一个名称，编译器会报错。带有静态成员的结构是定义常量字符串并将其名称集中到一个命名空间的好方法：
struct Default {  static let rows = &amp;#34;rows&amp;#34;  static let columns = &amp;#34;columns&amp;#34;  static let hazyStripy = &amp;#34;hazyStripy&amp;#34; } 现在就可以使用Default中的静态成员作为UserDefaults的键来引用，例如使用Default.rows可以就代表rows字符串。
Classes 虽然类和结构体相似，但和结构体还有一些关键区别：
  类是引用类型。这一意味着类的实例有两个相比于结构体或枚举实例来说是截然不同的显著特征。
  可变的：类的实例是原地是可变的。即使一个类实例变量是用let声明的，也可以通过这个引用来改变一个实例属性的值。因此，类的实例方法从来不需要被标记为可变的（也不能使用mutating标记）。
  多引用：当一个类的实例被赋值给多个变量或作为参数传递给一个函数时，可能出现多个引用指向一个相同的对象。
    继承：一个类可以有一个父类并继承父类的成员。类类型可以形成一个层次结构树，而结构体不能继承。
  在Objective-C中，类是唯一的对象类型。一些内置的Swift结构体类型可以神奇地与Objective-C的类桥接，但自定义结构类型却没有这种魔力。因此，在用Swift进行iOS编程时，声明类而不是结构的一个原因是类能够和Objective-C或Cocoa转换。
Value Types and Reference Types 在Swift中，结构体和枚举类型都是值类型，类是引用类型。值类型不能就地可变，而类的实例是能够就地可变的。下面的实例代码中，因为结构体是值类型，所以更改结构体实例的属性时，要将结构体实例用var声明，而不能使用let声明：
struct Digit {  var number: Int   init(_ n: Int) {  self.number = n  debugPrint(&amp;#34;number:\(number)&amp;#34;)  } }  var d = Digit(23) d.number = 45  // 打印结果 &amp;#34;number:23&amp;#34; 实际上，当显式改变一个值类型的实例时，是用一个不同的实例替换该实例。为了证明这一点，可以为digit实例添加一个setter观察器。下面代码中，虽然改变的只是属性number的值，但是didSet依然调用了，这说明该实例已经被替换了：
struct Digit {  var number: Int   init(_ n: Int) {  self.number = n  } }  var d: Digit = Digit(234) {  didSet {  debugPrint(&amp;#34;d was set&amp;#34;)  } }  d.number = 456 // 执行结果 &amp;#34;d was set&amp;#34; 下面代码中，实际上需要用另一个Digit实例替换digit指向的Digit实例，但因为digit是用let声明的，所以会出现编译错误。这能够解释如果值类型的实例引用是用let关键字声明的，那么就不能对该实例进行就地改变：
let digit = Digit(123) // Digit is a struct digit.number = 42 // compile error: Cannot assign to property: &amp;#39;dd&amp;#39; is a &amp;#39;let&amp;#39; constant 同时也解释了结构体或枚举的实例方法中如果需要设置某个属性值，必须将方法显式地用mutating标记。这个标记的意思：可能用另一个对象替换当前对象，所以对这个对象的引用必须是var，而不能是let声明。
但类不是值类型，它们是引用类型。如果想通过实例的引用改变某个属性的值，在声明该引用变量时无需使用var，使用let声明的变量，也可以通过该引用更改其var属性的值：
class Dog {  var name: String = &amp;#34;Fido&amp;#34; }  let rover = Dog() rover.name = &amp;#34;Rover&amp;#34; // fine 上面代码的最后一行，rover所指向的类实例被就地改变了。但这里并没有涉及到对rover的隐式赋值，所以使用let声明是合法的。实际上，当属性被设置时，Dog变量上的setter observer 没有被调用：
class Dog {  var name: String = &amp;#34;Fido&amp;#34; }  var rover: Dog = Dog() { // Dog is a class  didSet {  debugPrint(&amp;#34;did set rover&amp;#34;)  } } rover.name = &amp;#34;Rover&amp;#34; // nothing in console 上面的didSet观察器没有执行，说明没有生成新的实例。如果显式地重新给rover赋值，就会调用setter观察器。但是，类实例的didSet不会在仅改变了一个属性而被调用。
值类型和引用类型之间的差异也可以在函数调用的参数看到。当接收一个值类型的实例作为参数进入到函数体时，并在函数体内试图给这个实例属性赋值，将会出现编译错误：
func digitChanger(_ d: Digit) { // Digit is a struct  d.number = 42 // compile error } 这是因为函数参数默认是使用let隐式声明的，又因为Digit是结构体，所以在函数体改变结构体的属性时会出现编译错误：Cannot assign to property: &#39;d&#39; is a &#39;let&#39; constant。下面函数中，因为Dog是引用类型，所以dog能就地改变，不会出现编译报错：
func dogChanger(_ d: Dog) { // Dog is a class  d.name = &amp;#34;Rover&amp;#34; } Mutating Captured Self 在下面结构体中
struct Digit {  var number: Int   init(_ n: Int) {  self.number = n  }   mutating func changeNumberTo(_ n: Int) {  self.number = n  }   func otherFunction(_ f: () -&amp;gt; ()) {  //  }   mutating func callAnotherFunction() {  otherFunction {  self.changeNumberTo(345)  }  } } 上面代码是否合法取决于otherFunction是否将它的参数f声明为@escaping（逃逸闭包）。如果声明了参数f为escaping逃逸的，则编译器会出现错误Escaping closure captures mutating &#39;self&#39; parameter：
func otherFunction(_ f: @escaping ()-&amp;gt;()) {  // } 现在otherFunction是逃逸的，这意味着存在潜在的威胁：可能会在以后的某个时间点改变捕获的self。Digit是一个结构体，这将涉及到用一个不同的Digit实例来替换捕获的self，这是不被允许的（即使otherFunction是用mutating标记）。如果Digit是一个类，就不会出现这样的问题，因为捕获的self可以被mutated in place。
Class instance references are pointers 在引用类型中，在实例的引用和实例本身之间有一个隐蔽的层次。引用实际上持有一个指向实例的指针，这意味着当一个类的实例赋值给一个变量或作为一个函数参数或作为一个函数的结果时，可能会出现多个引用指向同一个对象。
而结构体和枚举不是这样的，在枚举或者结构体实例被赋值或被传递时，实际上被赋值或者被传递的是该实例的一个新的副本；而类实例被赋值或传递时，真正被赋值或传递的是指向同一个实例的引用。
var d1 = Digit(123) // Digit is a struct debugPrint(d1.number) // 123 var d2 = d1 // assignment!  d2.number = 42 debugPrint(d1.number) // 123 上面代码中，改变了d2的属性number，因为d2是结构体实例，所以不会影响到d1的number属性。但在下面代码中，改变了类实例rov的name属性，因为Dog是引用类型，这种改变也会影响到fido，因为它们指向同一个实例对象：
var fido = Dog() // Dog is a class debugPrint(fido.name) // Fido var rov = fido // assignment! rov.name = &amp;#34;Rover&amp;#34; debugPrint(fido.name) // Rover 同样地，当在函数中传递类实例时，传递的是指向同一个实例的引用。在下面代码中，因为Dog是类，当在函数doChanger中修改d的属性name后，会影响其指向的实例:
func dogChanger(_ d: Dog) { // Dog is a class  d.name = &amp;#34;Rover&amp;#34; } let fido = Dog(name: &amp;#34;name&amp;#34;, license: 123) debugPrint(fido.name) // &amp;#34;Fido&amp;#34; dogChanger(fido) debugPrint(fido.name) // &amp;#34;Rover&amp;#34; 当在函数中传递枚举和结构体实例时，实际上传递是它们的副本，所以不会影响传入的实例。此时，如果想在函数中修改传入的参数，需要使用inout标记待传入的值形参。
Advantages of value types vs. reference types 在基于对象的编程世界中，产生指向同一实例的多个引用的能力是非常重要的。因为对象会持续存在，并且可以有与之一起持续存在的属性。
如果对象A和对象B都是一直存在的，它们都有一个类类型的Dog属性，而且都指向同一个Dog实例。那么对象A或对象B都可以改变它们指向的Dog实例，而这种改变将会同时影响A和B。因此，对于类来说，可能正指向一个对象，却发现它已经被别人改变了。如果这种情况意外地发生，可能会使我们的程序进入非正常状态。
上面这种场景下类实例在幕后也更加复杂，Swift必须管理类实例的内存，正是因为对同一个对象可能有多个引用，这种管理可能涉及相当多的开销。
因此，应当尽可能地选择一个值类型（如结构体）而不是引用类型（类）。结构体实例不在引用之间共享，因此不必担心实例在其它地方被改变。结构体的存储和内存管理也要简单得多，并且值类型也更容易被推断。
Swift语言本身会帮助使用结构体类型，在许多Cocoa Foundation的引用类型前强加值类型。例如，Objective-C中的NSDate和NSData是类类型，但Swift会引导使用结构类型Date和Data来代替。
但不要搞错了，就想当然地认为类是不好的。首先，类实例的传递非常有效，因为所传递的只是一个指针。无论一个类的实例有多大、多复杂，无论它的属性包含多大量的数据，传递实例都是非常快速和高效的。
尽管一个类可能是一个引用类型，但一个特定的类可以以特殊方式实现，以表现出它的值语义。一个类的API可以拒绝对该类进行原地改变。Cocoa的NSString、NSArray、NSDictionary、NSDate、NSIndexSet、NSParagraphStyle等等都是这样的。
两个对象可以持有对同一个NSArray的引用而不用担心它在其它地方被改变，这不是因为它是一个值类型，而是因为它在设计上是不可变的。实际上，这种架构结合了值类型的易用性和引用类型的指针高效性。
此外，只有一个类的实例能成功的代表independent reality。例如，UIView是一个类，因一个单独的UIView实例就能在运行的应用程序的界面中一直代表同一个真实的、持久的视图。
另外，喜欢类而不是结构体或枚举的另一个原因是当需要递归引用时，一个值类型不能在结构上递归：即一个值类型的存储实例属性不能是同一类型的实例。下面这段代码是无法编译的：
struct Dog { 	var puppy : Dog? // compile error: Value type &amp;#39;Dog&amp;#39; cannot have a stored property that recursively contains it } 奇怪的是，可以将puppy定义为Dog数组来解除这个限制。对于值类型来说，更复杂的循环链，比如循环引用是非法的。例如，Dog结构体有一个Puppy属性，如果Puppy也是Dog类型，则是非法的，但如果Dog是类类型，这就是合法的。
struct Dog {  var puppy: [Dog]? } 关联值类型的枚举case可以是当前枚举的实例，一个枚举case的关联值可以是该枚举的一个实例，只要该case或整个枚举被标记为indirect：
enum Node {  case none(Int)  indirect case left(Int, Node)  indirect case right(Int, Node)  indirect case both(Int, Node, Node) } subclass and superclass 在Swift中，一个类可能有多个子类，但一个类至多只能有一个直接父类。就Swift本身而言，并没有要求一个类一定要有父类，或者说一个类如果有父类，也没有要求它最终应该是由特定父类派生。
一个Swift程序可以有许多没有父类的类，也可以有许多独立的层次子类树，每一个都是从不同的基类派生而来。但在Cocoa中，不是这样的。在Cocoa中实际上只有一个base class即NSObject，它表明了一个类所必需的所有功能，而所有其它类在某种层次上是这个基类的子类。
Inheritance 之所以有父类和子类关系，首先是为了共享功能。下面定义中，因为Dog和Cat都是Quadruped的子类，所以它们都能调用父类的walk方法：
class Quadruped {  func walk() {  print(&amp;#34;walk walk walk&amp;#34;)  } } class Dog: Quadruped {  // } class Cat: Quadruped {  // } let fido = Dog() fido.walk()  // 打印结果 walk walk walk 在类声明时加上final关键字可以防止其它类来继承当前类。
Additional functionality 子类化的目的不仅仅是可以继承父类的方法，也可以自定义方法。下面定义的Dog类不仅继承了walk()方法，而且自定义了bark()方法:
class Quadruped {  func walk() {  debugPrint(&amp;#34;walk walk walk&amp;#34;)  } }  class Dog: Quadruped {  func bark() {  debugPrint(&amp;#34;woof&amp;#34;)  } }  let fido = Dog() fido.walk() fido.bark() 无论方法是在类中自定义的，还是从父类中继承的，都有同样的效果。下面代码中Dog继承了Quadruped的walk方法，并自定义了bark方法，在自定义的walkAndBark方法中调用walk和bark方法时没有差别：
class Quadruped {  func walk() {  debugPrint(&amp;#34;walk walk walk&amp;#34;)  } }  class Dog: Quadruped {  func bark() {  debugPrint(&amp;#34;woof&amp;#34;)  }   func walkAndBark() {  self.walk()  self.bark()  } }  let fido = Dog() fido.walk() fido.bark() fido.walkAndBark() Overriding 在Swift中允许对从父类继承的方法进行重定义（也被称为覆写，重写）。如果重定义在父类定义的方法，必须显式在重定义的方法前添加override关键字作为标记。下面代码在子类Dog中对继承了Quadruped的walk方法进行了重写：
class Quadruped {  func walk() {  debugPrint(&amp;#34;walk walk walk&amp;#34;)  } }  class Dog: Quadruped {  func bark() {  debugPrint(&amp;#34;woof&amp;#34;)  }   func walkAndBark() {  self.walk()  self.bark()  }   override func walk() {  debugPrint(&amp;#34;dog walk&amp;#34;)  } }  class NoisyDog: Dog {  override func bark() {  debugPrint(&amp;#34;woof woof woof&amp;#34;)  } } 一个与父类同名的子类方法不一定是override，在Swift中两个函数是否相同是通过签名来区别的。只有当子类重新定义它从父类继承的同一个方法时才存在override的情况：相同的名称，包括外部参数名称，以及相同的签名。
但是，override一个方法并不需要和被覆盖的父类方法有完全相同的签名。在覆盖一个方法时，参数的类型可以用父类或父类的optional类型来代替。下面代码中，Kitten是Cat的子类，因此代码是合法的：
class Cat {  // }  class Kitten: Cat {  // }  class Dog {  func barkAt(cat: Kitten) {  //  } }  class NoisyDog: Dog {  // 下面是正常的override  override func barkAt(cat: Cat) {  //  } } 在override时用一个父类的Optional参数也是合法的。即在NoisyDog中覆盖barkAt时，参数cat的类型可以是Cat或Cat?：
class NoisyDog: Dog {  override func barkAt(cat: Cat?) {  //  } } 此外，在override时，参数可以用对应类型的Optional。下面代码中，Dog中定义的方法barkAt参数类型为Cat，而在NoisyDog中override该方法时，参数类型为Cat?也是合法的：
class Dog {  func barkAt(cat: Cat) {  //  } }  class NoisyDog: Dog {  override func barkAt(cat: Cat?) {  //  } } 而一个Optional的参数可以用其父类的Optional来覆盖。下面代码中，在override方法barkAt时Kitten?类型可以使用Cat?来代替：
class Dog {  func barkAt(cat: Kitten?) {  //  } }  class NoisyDog: Dog {  override func barkAt(cat: Cat?) {  //  } } 还有一些类似的规则，但不一一列出了。因为我们可能不需要利用它们，而且在任何情况下，编译器都会告诉我们覆盖是否非法。
除了方法之外，子类还继承了父类的属性。当然，子类也可以声明它定义的属性。覆盖一个继承的属性是可能的（有一些限制，将在后面讲到）。
The keyword super 经常发生的情况是，如果想在一个子类中覆盖一些父类的东西，但又想访问父类中被覆盖的东西，这可以通过向关键字super发送消息来实现。
在NoisyDog中的bark方法实现就是一个例子。NoisyDog在bark中真正做的事情与Dog在bark时做的事情相同，但调用次数更多。若想在NoisyDog中覆盖bark方法中实现这种效果，可以在实现时向父类发送bark消息，而不是向自己发送bark消息（这将形成死循环）。
class Dog: Quadruped {  func bark() {  print(&amp;#34;woof&amp;#34;)  } }  class NoisyDog: Dog {  override func bark() {  for _ in 1...3 {  super.bark()  }  } }  let fido = Dog() fido.bark() // woof  let rover = NoisyDog() rover.bark() // woof woof woof 下标函数也是一个方法。如果父类声明了一个下标函数，子类可以声明一个具有相同签名的下标，只要它用override关键字来标明即可。为了调用父类的下标方法，子类可以在关键字super后面使用方括号（例如：super[3]）。
class initializers 由于类的继承性，类实例的初始化比结构体和枚举实例的初始化要复杂得多。初始化器的主要任务是确保所有的属性都有一个初始值。初始化器可能还有其他任务要执行，这些任务对这个实例的初始状态和完整性至关重要。
一个类可能有一个父类，它可能有自己的属性和初始化器。因此，必须以某种方式确保当一个子类被初始化时，其父类的属性均被初始化，除了子类本身的任务外，其初始化器的任务也被按部就班地执行。
Swift通过对类的初始化器必须做的事情制定了一些清晰明确的规则，连贯而可靠地解决了这个问题，而且很巧妙地解决了这个问题。
Kinds of class initializer 类的初始化分为两类：Designated initializer和Convenience initializer。类的初始化器默认为Designated initializer。每个Designated initializer初始化器必须保证所有的存储属性都被初始化。它不能委托给类中的另一个初始化器，也就是在一个指定初始化器中使用self.init(...)是非法的。
Designated initializer 对于一个类，若存在任何一个存储属性，它没有作为其声明的一部分被初始化，则必须至少有一个明确的指定初始化器。一个没有存储属性的类，或者所有存储属性都作为声明的一部分被初始化的类，如果没有显式指定的初始化器，就有一个隐式的指定初始化器init()。
Convenience initializer 如果类的初始化器在声明的时候使用关键字convenience标记，那么它就是Convenience initializer。一个便利初始化器是一个委托初始化器，它必须包含self.init(...)，也就是它必须调用同一个类中的指定初始化器。或者如果它调用同一个类中的另一个便利初始化器，便利初始化器链必须以调用同一个类中的指定初始化器结束。
下面定义的类class没有存储属性，并且未自定义初始化器，此时此编译器自动生成了一个无参的init()，因此使用Dog()生成新的实例不会出现编译错误：
class Dog {  // } let dog = Dog() 如果类的所有存储属性在声明的时候都有初始值，并且如果未自定义任何初始化器，编译器会生成一个无参指定初始化器init()：
class Dog {  var name = &amp;#34;Fido&amp;#34; }  let dog = Dog() 在下面的例子中，虽然所有的存储属性都已经在声明的时候初始化了，但是已经有一个自定义的Designated initializer，那么就不会生成无参的初始化器init():
class Dog {  var name = &amp;#34;Fido&amp;#34;  init(name: String) {  self.name = name  } }  let dog = Dog() //compile error 在下面的例子中，所有的存储属性都有默认值，并且自定义了一个Convenience initializer，但无任何Designated initializer。此时，仍然会自动生成一个无参的init():
class Dog {  var name = &amp;#34;Fido&amp;#34;  convenience init(name: String) {  self.init() //默认的无参初始化器  self.name = name  } }  let dog1 = Dog(name: &amp;#34;Rover&amp;#34;) let dog2 = Dog() 也就是说，当一个类中无Designated initializer，但存在有参的Convenience initializer时，编译器会自动生成一个无参的init()。同时还要注意的是，不能再声明一个无参的便利初始化器convenience init()，否则将会出现编译错误:
class Dog {  var name = &amp;#34;Fido&amp;#34;  // Invalid redeclaration of synthesized &amp;#39;init()&amp;#39;  convenience init() {  //   } } 如果类的存储属性在声明的时候并未全部初始化，并且如果有自定义的Designated initializer。那么,在所有自定义的初始器中必须将所有存储属性都初始化：
class Dog {  var name: String  var license: Int   init(name: String, license: Int) {  self.name = name  self.license = license  } }  let dog = Dog(name: &amp;#34;Rover&amp;#34;, license: 42) 类的Designated initializer和Convenience initializer有较大的区别：
  一个指定的初始化器中除非为了初始化一个属性（或获取一个已经被初始化的属性的值），否则在这个类的所有属性都被初始化之前不能隐式或显式地使用self。
  一个便利初始化器是一个委托初始化器，所以在它直接或间接地调用一个指定初始化器之前，在其中不能出于任何目的使用self（也不能设置一个常量属性）。
  class Dog {  var name: String  var license: Int   init(name: String, license: Int) {  self.name = name  self.license = license  }   convenience init(license: Int) {  self.init(name: &amp;#34;Fido&amp;#34;, license: license)  }   convenience init() {  self.init(license: 1)  } }  let dog = Dog() 上面明确了Designated initializer和Convenience initializer的区别，在子类的初始化时，也有一些需要注意的地方：
  如果一个子类不需要自定义的初始化器，那么它的初始化器都继承自它的父类。此时子类是否有隐藏的无参初始化器init()，取决于它的父类是否有init()。
  如果一个子类尚无自定义的初始化器，则它可以声明Convenience initializer。子类的便利初始化器的工作方式与父类便利初始化器的工作方式完全一样。因为子类继承了父类的指定初始化器，便利初始化器必须通过使用self.init(...)来调用初始化器。
  class Dog {  var name: String  var license: Int   init(name: String, license: Int) {  self.name = name  self.license = license  }   convenience init(license: Int) {  self.init(name: &amp;#34;Fido&amp;#34;, license: license)  }   convenience init() {  self.init(license: 1)  }  }  class MyDog: Dog {  convenience init() {  self.init(license: 1)  // super.init(name: &amp;#34;test&amp;#34;, license: 1) // compile error  } }  如果一个子类声明了任何自己的Designated initializer，那么将不会继承任何来自父类的初始化器。并且在子类自定义的每个Designated initializer都必须调用一个父类的Designated initializer（通过使用super.init(...)实现）。  class Dog {  var name: String  var license: Int   init(name: String, license: Int) {  self.name = name  self.license = license  }   convenience init(license: Int) {  self.init(name: &amp;#34;Fido&amp;#34;, license: license)  }   convenience init() {  self.init(license: 1)  }  }  class MyDog: Dog {  init(name: String) {  // self.init(license: 1) // compile error  super.init(name: name, license: 1)  } }  let dog = Dog() 子类的Designated initializer中，必须按如下顺序进行初始化：
  必须确保自己的所有的属性都被初始化。
  接着必须调用super.init()。
  最后才能使用self继承自父类的实例方法或属性。
  class MyDog: Dog {  init(name: String) {  // self.name = &amp;#34;test&amp;#34; // compile error  super.init(name: &amp;#34;name&amp;#34;, license: 1)  } } 如果一个子类既有Designated initializer又有Convenience initializer。那么在便利初始化器中必须使用self.init()来直接或者间接调用Designated initializer。
子类也可以重写父类的初始化器。一个初始化器的参数与父类的方便初始化器相匹配时，子类的初始化器可以是指定的初始化器或便利初始化器，并且不被标记为override。
class Dog {  var name: String  var license: Int   init(name: String, license: Int) {  self.name = name  self.license = license  }   convenience init(license: Int) {  self.init(name: &amp;#34;Fido&amp;#34;, license: license)  }   convenience init() {  self.init(license: 1)  }  }  class MyDog: Dog {  init(license: Int) {  super.init(name: &amp;#34;name&amp;#34;, license: 1)  }  // 或者  //convenience init(license: Int) {  // self.init(license: 1)  //} } 子类的初始化器参数与父类的指定初始化器相匹配时，子类的初始化器可以是指定的初始化器或方便初始化器，并且必须标记为override。并且override的指定初始化器必须通过super.init(...)调用父类的指定初始化器。
如果一个子类override父类所有的指定初始化器，那么子类将继承父类所有的便利初始化器(这是一个例外，因为一个子类有任何指定的初始化器，则不继承初始化器)。
下面的代码是合法的，因为类NoiseDog继承了Dog的所有初始化器。但是不能使用let nd3=NoiseDog()，因为Dog里没有init()。
class Dog {  var name: String  var license: Int   init(name: String, license: Int) {  self.name = name  self.license = license  }   convenience init(license: Int) {  self.init(name: &amp;#34;Fido&amp;#34;, license: license)  }  }  class NoisyDog: Dog { }  let nd1 = NoisyDog(name: &amp;#34;Fido&amp;#34;, license: 1) let nd2 = NoisyDog(license: 2) 在下面的代码中，因为NoiseDog没有指定初始化器，只有便利初始化器，所以它继承了Dog的所有初始化器。因此，在便利初始化器中调用self.init(name: &amp;quot;Fido&amp;quot;, license: license)也是合法的：
class Dog {  var name: String  var license: Int   init(name: String, license: Int) {  self.name = name  self.license = license  }   convenience init(license: Int) {  self.init(name: &amp;#34;Fido&amp;#34;, license: license)  } }  class NoisyDog: Dog {  convenience init(name: String) {  self.init(name: name, license: 1)  } } 在下面的代码中，因为NoisyDog声明了指定初始化器，因此不再继承父类Dog的所有初始化器。如果调用父类的指定初始化器需要使用super：
class Dog {  var name: String  var license: Int   init(name: String, license: Int) {  self.name = name  self.license = license  }   convenience init(license: Int) {  self.init(name: &amp;#34;Fido&amp;#34;, license: license)  } }  class NoisyDog: Dog {  init(name: String) {  super.init(name: name, license: 1)  } } 在下面的例子中，因为NoiseDog已经覆写父类Dog的所有designated initializers，所以它继承了父类的convenience initializers，所以它能调用NoisyDog(license:2)：
class Dog {  var name: String  var license: Int   init(name: String, license: Int) {  self.name = name  self.license = license  }   convenience init(license: Int) {  self.init(name: &amp;#34;Fido&amp;#34;, license: license)  }  }  class NoisyDog: Dog {  override init(name: String, license: Int) {  super.init(name: name, license: license)  } } let nd1 = NoisyDog(name:&amp;#34;Rover&amp;#34;, license:1) let nd2 = NoisyDog(license:2) 一个类的初始化器前面可以有一个关键字required，这意味着一个子类不能缺少这个初始化器。这又意味着，如果一个子类实现了指定初始化器，从而阻断了继承，它必须覆写这个初始化器，并标记为required。在下面的例子中，如果NoisyDog中的初始化器required init(name: String)缺少关键字required将会出现编译错误。
class Dog {  var name: String  required init(name: String) {  self.name = name  } }  class NoisyDog: Dog {  var obedient = false  init(obedient: Bool) {  self.obedient = obedient  super.init(name: &amp;#34;Fido&amp;#34;)  }   required init(name: String) {  super.init(name: name)  } } 在上面的代码中，虽然在NoisyDog中已经覆写了init(name: String)，但并未标记为override，而是标记了为了required，这是因为&#39;override&#39; is implied when overriding a required initializer。并且required保证了向下传递。
class deinitializer 类的析构器是用关键字deinit声明的函数，后面是包含函数主体的花括号。但不能手动调用这个函数，当这个类的实例不存在时，它会自动被调用。如果一个类有一个父类，子类的deinit会在父类的deinit之前被调用。
只有类有deinit方法，struct和enum没有deinit方法，这是因为类是一种引用类型。我们的想法是，你可能想进行一些清理。类的deinit的另一个好用途是记录到控制台，向你自己证明你的实例是以良好的秩序消失的。在deinit过程中，属性观察者不被调用。
class properties 子类可以覆写继承父类的属性，此时必须保持和父类属性同名以及同类型，而且必须使用override标记。覆写的属性不能为存储属性，更具体地说：
  如果父类的属性是可写的（一个存储属性或者有setter的计算属性），子类的覆写可以包括为这个属性添加设置器观察者。
  或者子类覆写可以是计算属性。（1）如果父类的属性是存储的，那么子类使用计算属性来覆写时，一定要同时有getter和setter。（2）如果父类的属性是计算的，那么子类覆写的计算属性，至少需要getter（如果父类的计算属性有setter那么子类重写的方法必须有setter；如果父类的计算属性没有setter，那么子类可以添加一个）。
  覆写属性的函数可以通过super关键字对继承的属性进行读写。
Static/Class Members 一个类可以有静态成员，标记为static，就像一个结构或枚举。它也可以有类成员，标记为class。静态成员和类成员都可以被子类所继承。
Static methods vs. class methods 静态方法和类方法的主要区别在于，静态方法不能被重写，就好像静态方法是class final的同义词一样。下面代码会出现编译错误Cannot override static method：
class Dog {  static func whatDogsSay() -&amp;gt; String {  return &amp;#34;woof&amp;#34;  }   func bark() {  debugPrint(Dog.whatDogsSay())  } }  class NoisyDog: Dog {  override static func whatDogsSay() -&amp;gt; String {  return &amp;#34;noisy&amp;#34;  } } 在上面代码中，任何继承Dog的子类都会继承它的静态方法whatDogsSay，但是不能包含任何具有相同签名的静态方法或者类方法。但如果在Dog中使用class来声明whatDogsSay，则可以在子类中override该方法：
class Dog {  class func whatDogsSay() -&amp;gt; String {  return &amp;#34;woof&amp;#34;  }   func bark() {  debugPrint(Dog.whatDogsSay())  } }  class NoisyDog: Dog {  /// 使用static来重写  override static func whatDogsSay() -&amp;gt; String {  return &amp;#34;noisy&amp;#34;  } }  // 或者 class Dog {  class func whatDogsSay() -&amp;gt; String {  return &amp;#34;woof&amp;#34;  }   func bark() {  debugPrint(Dog.whatDogsSay())  } }  class NoisyDog: Dog {  /// 使用class来重写  override class func whatDogsSay() -&amp;gt; String {  return &amp;#34;noisy&amp;#34;  } } Static properties vs. class properties 静态属性和类属性的区别类似于静态方法和类方法。但有一个额外的、相当戏剧性的限定：静态属性可以被存储，但类属性必须是一个计算属性。
class Dog {  static var whatDogsSay = &amp;#34;woof&amp;#34;  func bark() {  debugPrint(Dog.whatDogsSay)  } } 上面定义的Dog有静态的存储属性，但是它不能被任何子类所override。如果要能被子类覆写，那么必须使用class来声明，并且必须声明为计算属性：
class Dog {  class var whatDogsSay: String {  return &amp;#34;woof&amp;#34;  }   func bark() {  debugPrint(Dog.whatDogsSay)  } }  class NoisyDog: Dog {  override static var whatDogsSay: String {  return &amp;#34;WOOF&amp;#34;  } } Polymorphism 当一种计算机语言有类型和子类型这样的层次结构时，它必须解决层次结构对一个对象的实际类型和指向该对象的引用类型之间关系的问题。
Swift遵循多态原则，正是多态将基于对象的语言变成了成熟的面向对象的语言。可以总结Swift的多态原则为以下两个：
替换原则：如果在某个地方期望的是某种类型的对象，但实际的对象类型可能是该类型的一个子类。下面代码中，变量dog虽然声明为Dog类型，但是赋值给它是子类NoisyDog的实例：
class Dog {  // }  class NoisyDog: Dog {  // }  let dog: Dog = NoisyDog() 内部一致原则：一个对象的实际类型是其内部性质的问题，与该对象如何被引用无关。也就是说，当一个消息被发送时，重要的不是该消息的接收者是如何通过这个或那个引用指向，重要的是消息接收者实际上是什么类型。
class Dog {  // }  class NoisyDog: Dog {  // }  let dog: Dog = NoisyDog() 替换原则说明上面最后一行代码是合法的。内部一致性原则说明，即使dog变量声明为Dog类型，但它指向的对象是NoiseDog实例。
下面代码能告诉我们内部一致原则是如何体现的。虽然在tellToBark函数中期望的参数类型为Dog，但调用时实际传递的是NoisyDog类型实例，因此调用bark方法时，实际调用的是NoisyDog的bark方法：
class Dog {  func bark() {  debugPrint(&amp;#34;woof&amp;#34;)  } }  class NoisyDog: Dog {  override func bark() {  for _ in 1...3 {  super.bark()  }  } }  func tellToBark(_ d: Dog) {  d.bark() }  var nd = NoisyDog() tellToBark(nd) // woof woof woof 关键字self表示当前这个实例。关键词self的含义是多态性的另一个重要体现。self的含义取决于实例的实际类型，即使self这个词出现在父类的代码中。
下面代码中，在Dog中的speak方法中使用self调用了bark方法，因为NoiseDog继承自Dog，所以也继承了speak方法，又因为它覆写了bark，所以speak中调用的bark变成了NosieDog中的bark方法：
class Dog {  func bark() {  debugPrint(&amp;#34;woof&amp;#34;)  }   func speak() {  // 关键字self具有多态性  self.bark()  } }  class NoisyDog: Dog {  override func bark() {  for _ in 1...3 {  super.bark()  }  } } let nd = NoisyDog() nd.speak()  // 打印结果 woof woof woof 多态对于可选类型也是适用的。假设有一个Dog类型的Optional引用，我们已经知道可以给它赋值为Dog的实例，也可以赋值为NoisyDog的实例：
var dog : Dog? dog = Dog() dog = NoisyDog() dog = Optional(NoisyDog()) 利用多态性，可以利用子类的优势以增加现有类的力量，也可以定制现有类。这对于iOS编程来说非常重要，因为多数类是定义在Cocoa中，这些类并不属于我们。例如，我们通常继承UIViewController，形成新的子类。
多态性很酷，但从总体上看，它也是比较慢的，因为它需要动态调度，这意味着编译器不能进行某些优化，而且runtime必须考虑给类实例的消息意味着什么。可以通过声明一个类或一个类成员为final或private来减少对动态调度的需求。或者使用一个结构体，因为结构体不需要动态调度。
Casting Swift是一种严格类型的语言，允许向对象引用发送的消息有严格的限制，取决于引用声明时的类型。但是，多态的内部一致性原则说明，一个对象可能有一个不同于其引用声明类型的实际类型。
下面示例代码中，在方法tellToHush中调用beQuit是非法的。因为参数d被声明为Dog类型，此时将会出现Value of type &#39;Dog&#39; has no member &#39;beQuiet&#39;编译错误：
class Dog {  func bark() {  debugPrint(&amp;#34;woof&amp;#34;)  } }  class NoisyDog: Dog {  override func bark() {  super.bark()  }   func beQuiet() {  self.bark()  } }  func tellToHush(_ d: Dog) {  d.beQuiet() // compile error  } Casting Down 上面代码会出现编译错误是因为Dog类型中并没有beQuiet方法，这个方法是其子类NoisyDog特有的。将NoisyDog实例传给tellToHush时，实际上是可以使用beQuiet方法的。
在Swift中将一个父类转换为子类，被称为Casting Down。下面代码转换时使用的是as！，这表明正在强迫编译器做它不愿意做的事情：
func tellToHush(_ d: Dog) {  let d = d as! NoisyDog // may be crash   d.beQuiet() } 这相当于告诉编译器，对象d可能是NoiseDog类型的，但是使用as!可能会发生崩溃，因为d不一定是NoiseDog类型。
Type Testing and Casting Down Safely 使用as!是强制编译器做类型转换，它也是一个警告，警告我们这种转换随时会发生崩溃，因为待转换的实例可能不是目标类型。
Casting down是告诉编译器放松其严格类型检查并让我们发号施令的一种方式。也可以先使用关键字is来判断是否为NoiseDog类型，然后使用as!; 或者使用as?进行转换，或者使用if let 。
func tellToHush(_ d: Dog) {  if d is NoisyDog {  let d = d as! NoisyDog  d.beQuiet()  } } 上面代码先使用关键字is来判断是否为NoisyDog类型，然后再进行类型转换，这样就保证了转换一定成功。
另一种可选的方式，是使用as?操作符，这种casts down有失败的可能，一旦转换失败返回的结果为nil：
func tellToHush(_ d: Dog) {  let d = d as? NoisyDog // an Optional wrapping a NoisyDog   if d != nil {  d!.beQuiet()  } } 上面代码看起来比之前并没有更简洁，可以使用?来调用optional类型的方法:
func tellToHush(_ d: Dog) {  let d = d as? NoisyDog // an Optional wrapping a NoisyDog   d?.beQuiet() } 或者将上面代码合并为一行：
func tellToHush(_ d: Dog) {  (d as? NoisyDog)?.beQuiet() } 另一种方式是使用if let或if var接受转换后的结果，然后再调用对应的方法：
func tellToHush(_ d: Dog) {  if let d = d as? NoisyDog {  d.beQuiet()  } } Type Testing and Casting Optionals 对于is, as!和as?操作符来说，它们对于Optional类型的工作方式与==比较操作符相同。都会先检查是否为nil，如果不为nil则自动解包Optional对象，然后进行比较：
func test() {  let dog: Dog? = NoisyDog()  if dog is NoisyDog {  debugPrint(&amp;#34;true&amp;#34;)  } } 在上面的例子中，is关键字首先检查dog是否为nil。如果dog为nil，则直接返回false。如果dog不为nil，则检查dog包裹的类型是否为NoiseDog。
可以对一个optional类型使用as!操作符。当as!操作符左边是一个optional类型时，Swift会先解包，然后再进行转换，下面这段代码是有效的：
let dog1: Dog? = NoisyDog() let dog2 = dog1 as! NoisyDog dog2.beQuiet() 但上面代码是不安全的，如果dog1为nil或者是Dog类型的实例，则dog1 as! NoisyDog会因为转换失败而发生崩溃。而使用as?会更安全：
let dog1: Dog? = NoisyDog() let dog2 = dog1 as? NoisyDog dog2?.beQuiet() 上面代码中，as?首先会检查dog1是为nil，如果为nil则dog2的结果为nil。如果dog1不为nil，但不是NoisyDog类型的实例，则转换失败，dog2为nil。否则，转换成功，dog2的类型为NoisyDog?。
Bridging to Objective-C 类型转换的另一种方式是当Swift和Objective-C的两种类型相等时进行值互换。例如，可以将Swift的String 类型转换为Cocoa的NSString，反之亦然。
这不是因为其中一个是另一个的子类，而是因为这些类型是相互桥接的。实际上，它们是同一种类型。当从String转换为NSString时，不是向下转换，并且所做的事情并不危险，因此使用as运算符，没有感叹号或问号。
一般来说，要从Swift类型转换到桥接的Objective-C类型，需要进行显式转换（字符串文字常量除外）。下面代码中，Swift的String类型和Objective-C的NSString等价，Int和NSNumber等价：
let s : NSString = &amp;#34;howdy&amp;#34; // string literal to NSString let s2 = &amp;#34;howdy&amp;#34; let s3 : NSString = s2 as NSString // String to NSString let i : NSNumber = 1 as NSNumber // Int to NSNumber 上面代码是相当人为的。在现实中，不会经常进行这种类型转换，因为Cocoa API会以Swift类型的形式呈现出来。下面代码是合法的，并没有显式进行类型转换：
let name = &amp;#34;MyNib&amp;#34; // Swift String  let vc = ViewController(nibName:name, bundle:nil) 类UIViewController来自于Cocoa，它的NibName属性是Objective-C的NSString类型，并非不Swift字符串。但不必通过类型转换来帮助Swift 的String 类型name桥接，因为在Swift世界中，nibName:被认为是一个String类型（实际上是一个可选字符串）：
 public init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) 下面代码中，不必通过类型转换来对Swift中的String类型进行桥接，因为set(_:forKey:)的第一个参数为Swift的Any类型（实际上是一个Optional包装的Any）：
let ud = UserDefaults.standard let s = &amp;#34;howdy&amp;#34; ud.set(s, forKey: &amp;#34;greeting&amp;#34;)  // open func set(_ value: Any?, forKey defaultName: String) 反过来说，有可能收到一个Objective-C的值，而Swift对这个值的真正底层类型一无所知。在这种情况下，可能希望显式转换为底层类型：
let ud = UserDefaults.standard let test = ud.object(forKey:&amp;#34;greeting&amp;#34;) as! String 当调用ud.object(forKey:)时，Swift并不知道真正的底层类型信息，因为结果是一个Any（实际上是一个包裹Any的Optional）。因为事先知道这个特定的调用应该产生一个字符串，所以可以把这个值强行转换为一个字符串。
但是，如果ud.object(forKey: &amp;quot;greeting&amp;quot;)不是一个字符串（或者它是nil），就会发生崩溃。如果不确定，为了安全起见，应当使用is或as?。
Type References From Instance to Type 有时我们获取到了一个实例，但并知道这个实例的类型。可能是出于调试目的将其类型打印到控制台，或者可能需要使用类型作为值。此时，可以使用全局函数type(of:)：
let dogTest: Dog = NoisyDog() debugPrint(type(of: dogTest)) // xxx.NoisyDog From self to Type 对于一个实例来说，能够引用它自己的类型尤为重要。通常，这是为了向该类型发送消息。例如，假设一个实例想要向它的类发送一个类消息。在前面的例子中，Dog实例方法通过向Dog类型发送消息来获取Dog类属性，实际上就是使用Dog这个词：
class Dog {   class var whatDogsSay: String {  return &amp;#34;woof&amp;#34;  }   func bark() {  debugPrint(Dog.whatDogsSay)  } } 表达式Dog.whatDogsSay看起来笨拙并且不灵活。为什么我们需要硬编码，它在一个类型当中，按理说应该知道自己是什么类型。可以使用关键字Self（首字母大写）来引用当前类型——self（首字母小写）的类型:
class Dog {   class var whatDogsSay: String {  return &amp;#34;woof&amp;#34;  }   func bark() {  debugPrint(Self.whatDogsSay)  } } 相似地，之前声明了一个Filter枚举类型，并且使用Filter.allCases来访问它的allCases静态属性。实际上，我们可以使用Self.allCases来代替。
在代码中使用Self而不是具体的类型名字，不仅是因为更简单，而且它更强大，因为Self和self一样，也遵循多态性。
下面代码中，当NoisyDog类型的实例调用bark时，调用的是从Dog继承到的bark方法，在这个方法中，Self是指当前实例的类型，也就是NoisyDog。因此，取到的whatDogsSay就是&amp;quot;woof woof woof&amp;quot;。
class Dog {  class var whatDogsSay: String {  return &amp;#34;woof&amp;#34;  }   func bark() {  debugPrint(Self.whatDogsSay)  } }  class NoisyDog: Dog {  override class var whatDogsSay: String {  return &amp;#34;woof woof woof&amp;#34;  } }  let dogTest: Dog = NoisyDog() debugPrint(type(of: dogTest)) // xxx.NoisyDog debugPrint(dogTest.bark()) // &amp;#34;woof woof woof&amp;#34; Self是Swift 5.1才引入的，在那之前只能使用type(of:self)。多态Self的另一个重要用途是作为返回类型。为了说明这很有价值，接下来将介绍工厂方法的概念。
假设我们的Dog类型有一个name实例属性，并且它的唯一初始化器是init(name: String)。我们想要创建一下类方法，创建并返回一个命名的Dog，无论我们把makeAndName消息发送给哪种Dog。
class Dog {  var name: String   init(name: String) {  self.name = name  }  class func makeAndName() -&amp;gt; NewDog {  let d = Self(name: &amp;#34;Fido&amp;#34;) // compile error   return d  } } 上面代码会发生编译错误，这是因为编译器怀疑init(name:)初始化器对于Dog的每个可能的子类型都能实现。为了让编译器放心，我们必须使用required关键字声明该初始化器：
class Dog {  var name: String   required init(name: String) {  self.name = name  }   class func makeAndName() -&amp;gt; NewDog {  let d = Self(name: &amp;#34;Fido&amp;#34;) // compile error  return d  } }  class NoisyDog: Dog {  // } required声明可以让编译器放心: Dog的每个子类都必须继承或重新实现init(name:)，所以在一个可能指向Dog或Dog的某个子类的类型引用上调用init(name:)信息是合法的。
let newDog1 = Dog.makeAndName() // d is a Dog named Fido let newDog2 = NoisyDog.makeAndName() // d2 is a NoisyDog named Fido 但是上面代码还有外一个问题，尽管newDog2事实上是NoisyDog类型的实例，但是makeAndName声明时返回的是Dog类型。实际上，我们声明这个方法时需要返回一个与最初发送makeAndName消息类相同类型的实例。换句话说，需要一个多态的类型声明，可以使用Self:
class NewDog {  var name: String   required init(name: String) {  self.name = name  }   class func makeAndName() -&amp;gt; Self {  let d = Self(name: &amp;#34;Fido&amp;#34;) // compile error  return d  } }  class NewNoisyDog: NewDog {  // }  let newDog1 = NewDog.makeAndName() // d is a Dog named Fido let newDog2 = NewNoisyDog.makeAndName() // d2 is a NoisyDog named Fido  debugPrint(type(of: newDog2)) Self类型作为返回类型时表示这是运行时任何类型的实例，因此当NoisyDog调用NoisyDog.makeAndName()得到的是NoisyDog实例。Self也可以用在实例方法的声明中。因此，可以编写工厂方法的实例方法版本。
class Dog {  var name: String   required init(name: String) {  self.name = name  }   class func makeAndName() -&amp;gt; Self {  let d = Self(name: &amp;#34;Fido&amp;#34;) // compile error  return d  }   func havePuppy(name: String) -&amp;gt; Self {  return Self(name: name)  } }  class NoisyDog: Dog {  // }  let newDog1 = Dog.makeAndName() // d is a Dog named Fido let newDog2 = NoisyDog.makeAndName() // d2 is a NoisyDog named Fido  debugPrint(type(of: newDog2))  let newDog11 = newDog1.havePuppy(name: &amp;#34;test1&amp;#34;) let newDog22 = newDog2.havePuppy(name: &amp;#34;test2&amp;#34;)  debugPrint(type(of: newDog11)) debugPrint(type(of: newDog22)) Type as Value 在某些情况下，可能希望将对象类型视为值，并且这是合法的。对象类型本身就是一种对象，这就是Swift所说的元类型。因此，对象类型可以赋值给变量或作为参数传递：
  声明一个对象类型是可以接受的。如在声明一个变量或参数类型时&amp;ndash;使用点标记符与类型的名称和关键字Type。
  使用一个对象类型作为一个值。比如当把一个对象类型赋值给一个变量或作为一个参数传递时，把对象交给type(of:)；或者用类型的名称和关键字self来点标记。(在后一种情况下，类型的名称可能是Self，在这种情况下，可以使用Self.self)。
  func dogTypeExpecter(_ whatType: Dog.Type) {  debugPrint(whatType) }  dogTypeExpecter(Dog.self) let dog = Dog(name: &amp;#34;test&amp;#34;) dogTypeExpecter(type(of: dog)) dogTypeExpecter(NoisyDog.self) 为了更实际地说明这一点，将把Dog类中的工厂方法重写为一个全局工厂函数，它将接受一个Dog类型作为参数，并从该类型创建一个实例。可以使用一个类型的变量引用（元类型）来实例化该类型，但不能只是在一个变量引用上加上括号，必须显式使用init方法：
func dogMakerAndNamer(_ whatType: Dog.Type) -&amp;gt; Dog {  let d = whatType(name: &amp;#34;Fido&amp;#34;)  // compile error: Initializing from a metatype value must reference &amp;#39;init&amp;#39; explicitly  return d }  func dogMakerAndNamer(_ whatType: Dog.Type) -&amp;gt; Dog {  let d = whatType.init(name: &amp;#34;Fido&amp;#34;)  return d }  let d11 = dogMakerAndNamer(Dog.self) // d11 is a Dog named Fido  let d12 = dogMakerAndNamer(NoisyDog.self) // d12 is a NoisyDog named Fido 不幸的是，即使底层的真正类型是NoisyDog，全局工厂函数dogMakerAndNamer返回的也是一个Dog对象。因为是全局函数，这里不能使用Self来解决这个问题，但可以使用泛型。
 type(of:)应用于一个对象：对象的多态（内部）类型，与引用声明的类型无关。 Self：在一个方法主中，或者在方法声明中指定返回类型时，这个类型或这个实例的类型，具有多态性。 .Type：附加在类型声明中的一个类型上，以指定该类型本身（或一个子类型）被期望。 .self：发送给一个类型以生成一个元类型，适合于传递一个类型（.Type）被期望的地方。  Comparing Types 类型引用之间可以相互比较。在==比较符的右边，可以用类型名称加.self。而在is关键字的右边，可以用类型名称加.Type。区别在于：==操作符测试的是绝对相同的类型，而is则允许子类型。
func dogTypeExpecter(_ whatType: Dog.Type) {  debugPrint(whatType)  let equality = whatType == Dog.self  let typology = whatType is Dog.Type  debugPrint(equality,typology) }  dogTypeExpecter(Dog.self) // true,true let dog = NewDog(name: &amp;#34;test&amp;#34;) dogTypeExpecter(type(of: dog)) // true,true dogTypeExpecter(NoisyDog.self) // false, true 在上面例子中，whatType放在比较操作符的左边，它可能被type(of:)替换，或者使用类型加.self替换。同时==操作符右边的Dog.self也可能被whatType和type(of:)替换。但是is关键字的右边不能出现whatType和type(of:)。
debugPrint(type(of: dog) == Dog.self, type(of: dog) == NoisyDog.self) // true,false Protocols 协议是表达不相关类型共同点的一种方式。例如，一个Bee对象和一个Bird对象可能有共同的特征，因为Bee和Bird都能飞。因此，定义一个Flier类型可能是有用的。问题是：在什么意义上，Bee和Bird都可以是Filier？
一种可能的方式是利用类继承，如果Bee和Bird都是类，Filer可以是它们的父类。但是，可能有其它原因Flier不能成为Bee和Bird的父类。例如，Bee是一种昆虫，而Bird则不是。但是它们都有飞行的能力。我们需要一个以某种方式跨越类的层次结构的类型，将较远的类联系在一起。
此外，Bee和Bird在Swift中有可能不是类，可能是结构体。为了解决这个问题，可以使用Protocols。Protocols在Swift中很重要，在Swift中的头文件中定义了超过60个协议。此外，Objective-C也有协议，Swift中的协议和Objective-C的协议大致相似，并不能与之互换。
一个协议也是一个对象类型，但是协议没有对象实例，因为协议不能被实例化。协议声明只是一个属性和方法的轻量级列表。属性没有值，方法也没有代码。
一个 &amp;ldquo;真正的&amp;quot;对象类型可以正式宣布它属于一个协议类型，这被称为遵循协议。一个遵循协议的对象类型承诺要实现协议中列出的属性和方法。而且，它必须遵守这一承诺，这就是所谓的遵循协议。
protocol Flier {  func fly() } 任何类型，例如enum,struct,class甚至另一个protocol可以遵循一个协议。只需要在声明的时候在冒号后面添加协议的名字:
struct Bird:Flier {  func fly() {  debugPrint(&amp;#34;bird fly&amp;#34;)  } } 协议给了我们另一个方式表示类型和子类型的概念，并且也适用于多态。基于替换原则，下面方法中，一个Flier可以是任何对象类型的实例，只要它遵循了Flier协议:
func tellToFly(_ f: Flier) {  f.fly() } 遵循Flier协议的对象类型可能是Bird，也可能是其他什么东西，但我们不关注。如果一个类型遵循了Flier协议，那么它就可以用在任何期望是Flier的地方。
此外，遵循了Flier协议的类型必须有一个fly方法，这样就能放心的调用该方法。相反，如果一个对象有fly方法，并不代表它自动的遵循了Flier协议。下面代码会出现编译错误：
struct Bee {   func fly() {   } }  let b = Bee() tellToFly(b) // compile error：Argument type &amp;#39;Bee&amp;#39; does not conform to expected type &amp;#39;Flier&amp;#39; Adopting a Library Protocol Swift标准库中已经充满了协议，可以先让自定义的一个对象类型遵循一个标准库中的协议，看看协议能为我们带来了什么。
其中CustomStringConvertible协议要求实现description属性，如果一种类型遵循了CustomStringConvertible协议，就会发生一件奇妙的事情：当这种类型的实例被用于字符串插值或与打印（或控制台中的po命令，或在字符串初始化器init(descripbing:)中）时，它的描述属性值会自动用来表示它。
enum Filter: String, CustomStringConvertible {  case albums = &amp;#34;Albums&amp;#34;  case playlists = &amp;#34;Playlists&amp;#34;  case podcasts = &amp;#34;Podcasts&amp;#34;  case books = &amp;#34;Audiobooks&amp;#34;   var description: String {  return self.rawValue  } } 上面代码中，已经明确了Filter遵循CustomStringConvertible协议，也实现了description属性。现在也可以把一个Filter插到一个字符串中，或者传递给print函数，或者强迫它变成一个String，这时它的description将被自动使用：
let type1 = Filter.albums debugPrint(&amp;#34;It is \(type1)&amp;#34;) // It is Albums  debugPrint(type1) // Albums  let sde = String(describing: type1) // Albums  debugPrint(sde)  // 打印的结果 &amp;#34;It is Albums&amp;#34; Albums &amp;#34;Albums&amp;#34; Protocol Type Testing and Casting 当声明的类型是一个协议类型时，在对象的声明类型和它的真实类型之间进行调解的操作符是有效的。给定一个同时被Bird和Bee采用的协议Flier，可以使用is操作符来测试一个特定的Flier是否真的是Bird：
func isBird(_ f: Flier) -&amp;gt; Bool {  return f is Bird } 类似的，as!和as?也可以用于一个声明为协议类型的对象转换为其真实类型。能够这样做是很重要的，因为遵循协议的对象通常能够接收协议不能接收的消息：
struct Bird: Flier {  func fly() {  }   func getWorm() {  } }  func tellGetWorm(f: Flier) {  (f as? Bird)?.getWorm() } Declaring a Protocol 协议声明只能发生在文件的最高层。为了声明协议，使用关键字protocol后面紧跟协议名（以大写字母开始，因为这是一种类型），然后是大括号，其中可以包含以下任何一项的声明：
 属性。协议中的属性声明由var（不是let）、属性名称、冒号、类型和包含get或get set的大括号组成。在前一种情况下，采用者对该属性的实现可以是可写的。但在后一种情况下，它必须是可写的，即采用者不得将get set属性实现为只读的计算属性或常数（let）存储属性。要声明一个静态/类属性，请在它前面加上关键字static。类采用者可以自由地将其实现为类属性。 方法。协议中的方法声明是一个没有函数体的函数声明，它没有大括号，也没有代码。任何对象函数类型都是合法的，包括init和subscript。(在协议中声明下标的语法与在对象类型中声明下标的语法相同，只是大括号中会包含get或get set。)  要声明一个静态/类方法，需要在前面加上关键字static。类的采用者可以自由地将其作为一个类方法来实现。 为了允许枚举或结构的采用者声明一个方法是mutating，在协议中声明它是mutating。如果协议中方法没有mutating，采用者不能增加mutating，但如果协议中有mutating，采用者可以省略mutating。    一个协议本身可以遵循一个或多个协议。多个协议的遵循语法是在声明协议时在其名称后面加一个冒号，紧接着的是用逗号分隔的协议列表。
Protocol Composition 如果一个协议的唯一目的是通过遵循其它的协议来以组合其它协议，而不增加任何新的要求，可以通过临时指定协议组合来避免正式地宣布协议。要做到这一点，可以用&amp;amp;连接协议，这就是所谓的协议组合：
func f(_ x: CustomStringConvertible &amp;amp; CustomDebugStringConvertible) {  // } 这是一个带有参数的函数声明，其类型被指定为某种同时遵循CustomStringConvertible协议和CustomDebugStringConvertible协议的对象类型。一个类型也可以被指定为一个类类型和一个或多个协议的组合：
protocol MyViewProtocol {  func doSomethingReallyCool() }  class ViewController: UIViewController {  var v: (UIView &amp;amp; MyViewProtocol)?   func test() {  self.v?.doSomethingReallyCool() // a MyViewProtocol requirement   self.v?.backgroundColor = .red // a UIView property   } } 为了给ViewController的属性v赋值，这个对象必须是UIView的子类并且遵循MyViewProtocol协议。通过这种方式，向编译器保证UIView消息和MyViewProtocol消息都可以被发送到ViewController的v。否则，就必须将v声明为MyViewProtocol类型，然后转换成UIView，以便向它发送UIView消息，即使我们知道v事实上总是一个UIView。
Class Protocols 协议声明可以在冒号后包括一个类的名称，这样就把能够采用这个协议的类型限制在该类或其子类中：
protocol MyViewProtocol: UIView {  func doSomethingReallyCool() } class ViewController: UIViewController {  var v: MyViewProtocol? // and therefore a UIView  func test() {  self.v?.doSomethingReallyCool() // a MyViewProtocol requirement  self.v?.backgroundColor = .red // a UIView property  } } 通过上面的声明，MyViewProtocol只能被UIView或UIView子类遵循。这意味着一个类型为MyViewProtocol的对象可以同时接受MyViewProtocol消息和UIView消息。
要指定一个协议只能被某个类（非结构体或枚举体）采用，而不指定它必须是什么类，可以使用协议类型AnyObject，每个类的类型都会采用它：
protocol MyProtocol: AnyObject {  // } 可选的方式是在协议声明的大括号前添加where限定子句：
protocol MyViewProtocol where Self: UIView {  func doSomethingReallyCool() }  protocol MyClassProtocol where Self: AnyObject {  // ...  } 声明类协议的一个有价值的副产品是，产生的类型可以利用只适用于类的特殊内存管理特性:
protocol SecondViewControllerDelegate: AnyObject {  func accept(data: Any) }  class SecondViewController: UIViewController {  weak var delegate: SecondViewControllerDelegate?  // ...  } 关键字weak标志着delegate属性具有特殊的内存管理，并且只适用于类实例。delegate属性的类型是协议，而协议可能被一个结构体或枚举类型所采用。所以，为了让编译器相信这个对象实际上是一个类实例，而不是一个结构或枚举实例，该协议被声明为一个类协议。
一个@objc协议是一个类协议，因为类协议是Objective-C唯一能理解的协议。
Optional Protocol Members 在Objective-C中，一个协议成员可以声明为可选的，意味着这个成员可以不被遵循者实现。Swift允许可选协议成员，但这一特性完全是为了与Objective-C兼容，而且事实上是由Objective-C实现的，它根本不是Swift的真正特性。因此，关于一个可选协议成员的一切都必须明确地暴露给Objective-C。协议声明必须用@objc属性标记，而可选成员的声明必须用@objc optional关键字标记：
@objc protocol Flier {  @objc optional var song: String { get }  @objc optional func sing() } 许多Cocoa协议有可选成员。例如，iOS应用程序将有一个采用UIApplicationDelegate协议的应用程序委托类，这个协议有许多方法，都是可选的。
一个可选的成员不能保证被采用者实现，所以Swift不知道向Flier发送song信息或sing信息是否安全。Swift如何解决这个问题，取决于这是一个可选属性还是一个可选方法。
Optional properties 在可选属性（如song）的情况下，Swift通过将其获取的值包裹在一个Optional中来解决这个问题。如果Flier的采用者没有实现这个属性，结果就是nil，不会造成任何伤害：
@objc protocol Flier1 {  @objc optional var song: String { get } }  class Bird1: Flier1 {  // } let ff1 : Flier1 = Bird1() let s1 = ff1.song // s1 is an Optional wrapping a String debugPrint(s1) // nil 这是一种罕见的情况，在这种情况下，可以得到一个双重包装的可选属性。如果可选属性Song的值本身是一个String?，那么从Flier中获取它的值就会产生一个String??。
@objc protocol Flier1 {  @objc optional var song: String? { get set } }  class Bird1: Flier1 {  var song: String? = &amp;#34;song&amp;#34; }  var ff1: Flier1 = Bird1() var s1 = ff1.song // s1 is an Optional wrapping a String  debugPrint(s1) //Optional(Optional(&amp;#34;song&amp;#34;)) 一个奇怪的限制:如果一个协议声明了一个可选的属性{get set}，就不能设置该属性。如果f是一个Flier，而song被声明为{get set}，就不能设置f.song：
@objc protocol Flier {  @objc optional var song: String? { get set } }  let f: Flier = Bird() f.song = &amp;#34;tweet tweet&amp;#34; // compile error 错误信息声称f是不可变的，这显然是错误的,这显然是语言中的一个错误。一个变通的办法（由Jordan Rose给我指出）是使用关键路径：
let f : Flier = Bird()  f[keyPath: \.song] = &amp;#34;tweet tweet&amp;#34; Optional methods 在可选方法（如sing）的情况下，事情就更复杂了。如果该方法没有被实现，理应不允许调用该方法。为了处理这种情况，该方法被打造成其声明类型的可选版本。因此，要向Flier发送sing消息，必须将其解包。要解开的不是方法调用的结果，而是方法本身。在方法调用中，解包操作符必须出现在圆括号之前：
@objc protocol Flier1 {  @objc optional var song: String? { get set }  @objc optional func sing() }  class Bird1: Flier1 {  var song: String? = &amp;#34;song&amp;#34; }  let ff1: Flier1 = Bird1() ff1.sing?() 其效果是，只有当这个Flier采用者实现了sing，才会向f发送sing消息。如果这个Flier采用者没有实现sing，就不会发生什么。可以强制解包这个调用&amp;ndash;f.sing!() ，但如果采用者没有实现sing，应用程序就会崩溃。如果一个可选的方法返回一个值，这个值也会被包裹在一个Optional中：
@objc protocol Flier1 {  @objc optional var song: String? { get set }  @objc optional func sing() -&amp;gt; String }  class Bird1: Flier1 {  var song: String? = &amp;#34;song&amp;#34;   func sing() -&amp;gt; String {  return &amp;#34;new sing&amp;#34;  } }  let ff1: Flier1 = Bird1() let ss1 = ff1.sing?() debugPrint(ss1) // Optional(&amp;#34;new sing&amp;#34;) Implicitly Required Initializers 假如一个协议声明一个初始化器，并且假设一个类采用了这个协议。根据协议的要求，这个类和它可能拥有的任何子类必须实现这个初始化器。因此，这个类不仅必须实现这个初始化器，而且还必须把它标记为必需的。在协议中声明的初始化器是隐含的要求，而采用这个协议的类则强制这个要求。
protocol Flier2 {  init() }  class Bird2: Flier {   init() { // compile error: Initializer requirement &amp;#39;init()&amp;#39; can only be satisfied by a &amp;#39;required&amp;#39; initializer in non-final class &amp;#39;Bird2&amp;#39;  //  }  } 这段代码产生了一个错误：Initializer requirement &#39;init()&#39; can only be satisfied by a &#39;required&#39; initializer in non-final class &#39;Bird2&#39;。为了使得编译通过，必须指定初始化器为required:
protocol Flier2 {  init() }  class Bird2: Flier2 {   required init() {  //  }  } 可选地，如果将Bird标记为final，则没有必要将初始化器init标记为required，因为final保证了Bird不会有任何子类。
protocol Flier2 {  init() }  final class Bird2: Flier2 {  init() {  //  } } 这一点也产生了一个烦人的特性。假设将内置的Cocoa类UIViewController子类化，也是极有可能做的事。假设给子类一个初始化器：
class MoViewController: UIViewController {  init() {  super.init(nibName: &amp;#34;ViewController&amp;#34;, bundle: nil) // compile error  } } 上面代码会出现编译错误：&#39;required&#39; initializer &#39;init(coder:)&#39; must be provided by subclass of &#39;UIViewController&#39;。这是因为UIViewController采用了协议NSCoding，并且这个协议要求一个初始化器init(coder:)，UIViewController必须实现。
自定义的UIViewController子类要么必须继承init(coder:)，要么必须明确地实现init(coder:)并将其标记为required。然而，我们的子类已经实现了自己的指定初始化器，从而切断了初始化器的继承。因此，它必须实现init(coder:)并将其标记为required。
但如果不希望UIViewController子类的init(coder:)被调用，这就没有意义了。我们被强迫写一个初始化器，而却不能提供任何有意义的功能! 幸运的是，Xcode的Fix-it功能以为你写初始化器，像这样：
required init?(coder: NSCoder) {  fatalError(&amp;#34;init(coder:) has not been implemented&amp;#34;) } 上面代码满足了编译器的要求，这个初始化器被中止了，所以它是合法的，尽管它没有履行初始化器的契约。如果它被调用，就会出现崩溃。这很好，因为根据假设，并不期望它被调用。
另一方面，如果确实需要这个初始化器的功能，那么需要先删除fatalError一行。一个最小的有意义的实现是调用super.init(coder:coder)，当然，如果自定义的类有需要初始化的属性，则需要先初始化它们。
不仅是UIViewController，很多内置的Cocoa类都采用NSCoding。如果你对这些类进行子类化并实现你自己的初始化器，就会遇到这个问题，这只是你必须要习惯的事情。
Expressible by Literal Swift中的很多功能不是通过内置或魔法完成的，已经在Swift头文件中暴露出来。字面量正是这种情况，我们可以使用字面量5来表达一个值为5的Int，而不是通过Int(5)来正式初始化Int，这不是因为魔法（或者至少不完全是因为魔法），是因为Int采用了ExpressibleByIntegerLiteral协议。不仅是Int字面量，所有字面量都是这样工作的，以下字面量协议是在Swift头中声明的：
ExpressibleByNilLiteral ExpressibleByBooleanLiteral ExpressibleByIntegerLiteral ExpressibleByFloatLiteral ExpressibleByStringLiteral ExpressibleByExtendedGraphemeClusterLiteral ExpressibleByUnicodeScalarLiteral ExpressibleByArrayLiteral ExpressibleByDictionaryLiteral 自定义类型也可以采用expressible-by-literal协议，这意味着字面量也可以出现在期望自定义对象类型实例的地方。下面声明了一个Nest类型，它包含一些eggs：
public protocol _ExpressibleByBuiltinIntegerLiteral {   init(_builtinIntegerLiteral value: Builtin.IntLiteral) }  public protocol ExpressibleByIntegerLiteral {   associatedtype IntegerLiteralType : _ExpressibleByBuiltinIntegerLiteral   init(integerLiteral value: Self.IntegerLiteralType) }   struct Nest: ExpressibleByIntegerLiteral {  var eggCount: Int = 0   init() {  //  }   init(integerLiteral val: Int) {  self.eggCount = val  } }  func reportEggs(_ nest: Nest) {  print(&amp;#34;this nest contains \(nest.eggCount)eggs&amp;#34;) }  reportEggs(4) // this nest contains 4 eggs Generics 泛型是一种类型占位符，实际的类型将在后续使用时被确定。特别是在某些情况下，想在多个地方使用某个相同的类型，而不需要精确地指定是什么类型。Swift泛型允许在不牺牲或规避Swift严格类型的情况下使用。
我们已经比较熟悉Optional了，知道任何类型的值都可以被封装在一个Optional中。实际上，Optional是一个枚举，它有两个case，分别是.none和.some。如果Optional的case是.some，那么它会有一个关联值，这个关联值被Optional包裹。
但是该关联值的类型是什么呢？一方面，我们认为它可以是任何类型，这也是为什么任何东西都可以用一个Optional包裹。另一方面，任何特定的Optional都只能包裹一个特定的已知类型的值。这就是泛型的精髓所在，Swift头文件中的Optional枚举声明如下所示：
@frozen public enum Optional&amp;lt;Wrapped&amp;gt; : ExpressibleByNilLiteral {   case none   case some(Wrapped)   public init(_ some: Wrapped)   @inlinable public func map&amp;lt;U&amp;gt;(_ transform: (Wrapped) throws -&amp;gt; U) rethrows -&amp;gt; U?   @inlinable public func flatMap&amp;lt;U&amp;gt;(_ transform: (Wrapped) throws -&amp;gt; U?) rethrows -&amp;gt; U?   public init(nilLiteral: ())   @inlinable public var unsafelyUnwrapped: Wrapped { get } } 上面定义的意思：&amp;ldquo;在这个枚举的声明过程中，将先使用一个未知的类型——一个类型占位符，并将其命名为Wrapped。虽然它是一个占位符，但它是一个真实、独立的类型，每当使用Wrapped时，指的是这个特定的类型。当一个Optional实例被创造出来时，它将完全清楚Wrapped所代表的类型，在使用Wrapped占位符的地方，应该用它所代表的真实类型代替。&amp;rdquo;
@frozen public enum Optional&amp;lt;Wrapped&amp;gt; : ExpressibleByNilLiteral { ①  case none  case some(Wrapped) ②  public init(_ some: Wrapped) ③   // ... } 在上面声明中，名为Wrapped类型占位符出现在了3个不同的地方：
 尖括号语法&amp;lt;Wrapped&amp;gt;声明Wrapped是一个占位符。 除了.none这种case，还有一种case是.some，它有一个Wrapped类型的关联值。 还有一个初始化器，它需要一个Wrapped类型的参数。  所有这些都构成了Optional工作的模板。Swift是严格类型的，所以任何特定的Optional实例都必须有一个真实的类型来替代Wrapped占位符，替换的过程被称为解析或特化泛型。
这个枚举的每一次使用，必须明确关联类型，这样编译器才会满意。那么，占位符类型是怎么被解析的？下面是一种方式，当一个Optional被创建时，它将被初始化为某个确定类型的实际值:
let s = Optional(&amp;#34;howdy&amp;#34;) debugPrint(s)  // 打印的结果 Optional(&amp;#34;howdy&amp;#34;) 上面代码定义变量s时调用了init(_ some: Wrapped)，所以 &amp;quot;howdy&amp;quot;在这里被作为一个Wrapped类型实例来提供，也就是将泛型占位类型解析为String。所以，编译器现在知道在这个特定的Optional&amp;lt;Wrapped&amp;gt;中，Wrapped必须是String。
在Optional初始化器中的入参类型（不管它是什么类型）是Wrapped类型，也是.some case的关联类型。在编译器眼里，这个特殊Optional声明看起来像下面这样：
enum Optional&amp;lt;String&amp;gt; {  case none  case some(String)  init(_ some: String) // ... } 上面是一个Optional的伪代码声明，它的Wrapped占位符类型已经全部被替换成了String类型。我们可以通过声明s是Optional&amp;lt;String&amp;gt;类型来概括这一点。事实上，这是合法的语法，可以使用下面的方式创建同样的Optional：
let s1: Optional&amp;lt;String&amp;gt; = &amp;#34;howdy&amp;#34; debugPrint(s1)  // 打印的结果 Optional(&amp;#34;howdy&amp;#34;) 不仅类型可以是泛型，函数也可以是泛型。泛型函数可以解决之前提出的一个问题，在下面dogMakerAndNamer方法中，当传入一个Dog的子类NoisyDog作为参数时，将会得到一个实例，但这个实例的类型依然是Dog：
func dogMakerAndNamer(_ whattype: Dog.Type) -&amp;gt; Dog {  let d = whattype.init(name: &amp;#34;Fido&amp;#34;)  return d } 实际上，调用者希望返回值的类型和传入的类型是一样的，泛型函数可以做到这一点：
func dogMakerAndNamer&amp;lt;WhatType: Dog&amp;gt;(_: WhatType.Type) -&amp;gt; WhatType {  let d = WhatType.init(name: &amp;#34;Fido&amp;#34;)  return d }  let dog = dogMakerAndNamer(NoisyDog.self) 在上面代码中，传入了NoisyDog.self作为参数。这就告诉了编译器WhatType是什么类型，是NoiseDog。实际上，编译器现在将NoisyDog替换为整个泛型的WhatType，像下面这样（伪代码）：
func dogMakerAndNamer(_: NoisyDog.Type) -&amp;gt; NoisyDog {  let d = NoisyDog.init(name: &amp;#34;Fido&amp;#34;)  return d } Generic Declarations 下面列出了在Swift中能以哪些形式声明泛型，主要包括Generic protocol with Self，Generic protocol with associated type，Generic functions和Generic object types。
Generic protocol with Self 在协议体中，使用关键词Self可以将当前协议变成一个泛型的。Self在这里是一个占位符，表示该协议采用者的类型。下面是一个Flier协议，它声明了一个参数类型为Self的方法：
protocol Flier {  func flockTogetherWith(_ f: Self) } 上面协议声明意味着，如果一个Bird对象类型采用了Flier协议，那么它的flockTogetherWith实现的参数类型必须声明为Bird：
struct Bird: Flier {  func flockTogetherWith(_ f: Bird) {  //  } } Generic protocol with associated type 在一个协议声明中可以使用associatedtype语句来声明一个关联类型，这样就能把协议变成了一个泛型协议。关联类型名称是一个类型占位符：
protocol Flier {  associatedtype T  func flockTogetherWith(_ f: T)  func mateWith(_ f: T) } 协议的采用者将在泛型协议声明中使用associatedtype的地方使用一个特定的类型，以解析占位符类型。在下面Bird声明中，flockTogetherWith中的占位符类型被解析为Bird：
struct Bee {  // }  struct Bird: Flier {  func flockTogetherWith(_ f: Bee) {  //  }  func mateWith(_ f: Bee) {  //  } } 在泛型协议Flier中，T不必正好是Flier的上面这个采用者Bird，或者任何该协议的其它采用者。T可以是String，Int或者其它类型。相反，这个协议规定，无论是哪个采用者，flockTogetherWith和mateWith中的参数类型必须一致。
Generic functions 一个函数声明时可以为其任何参数、返回类型以及在其主体内使用一个通用占位符类型。占位符的名称在函数名称后面的尖括号中声明：
func takeAndReturnSameThing&amp;lt;T&amp;gt;(_ t: T) -&amp;gt; T {  print(T.self)  return t } 泛型函数调用者将在函数声明中出现占位符的某个地方使用一个特定的类型以解析占位符类型：
let thing = takeAndReturnSameThing(&amp;#34;name&amp;#34;) debugPrint(thing)  // 打印的结果 String &amp;#34;name&amp;#34; 在上面代码中，调用takeAndReturnSameThing传入&amp;quot;howdy&amp;quot;作为参数时，会将T解析为String。因此，泛型函数takeAndReturnSameThing的调用也必须返回String。因此，变量thing的类型被编译器推断为String。
Generic object types 一个对象类型声明可以在其大括号内的任何地方使用一个泛型占位符类型。占位符名称在对象类型名称之后的尖括号中声明：
struct HolderOfTwoSameThings&amp;lt;T&amp;gt; {  var firstThing: T  var secondThing: T   init(thingOne: T, thingTwo: T) {  self.firstThing = thingOne  self.secondThing = thingTwo  } } 使用HolderOfTwoSameThings这个类型时，会在出现占位符的地方使用一个特定类型以解析占位符类型：
let holder = HolderOfTwoSameThings(thingOne: &amp;#34;howdy&amp;#34;, thingTwo: &amp;#34;bye&amp;#34;) 在上面代码中，初始化器调用时使用&amp;quot;howdy&amp;quot;作为形参 thingOne:的值，此时会将 T 解析为 String。因此， thingTwo: 的实参也必须是一个 String，并且属性 firstThing 和 secondThing 类型也必须是 Strings。
在泛型声明时尖括号里面可以声明多个泛型占位符，用逗号分隔：
func flockTwoTogether&amp;lt;T, U&amp;gt;(_ f1: T, _ f2: U) {  // } 现在flockTwoTogether的两个参数可以解析为两个不同的类型（尽管它们并不要求两个类型一定不同）。在泛型代码中，泛型占位符代表的解析类型的类型引用，可以使用类型引用进行比较：
func takeAndReturnSameThing&amp;lt;T&amp;gt;(_ t: T) -&amp;gt; T {  if T.self is String.Type {  // ...  }  return t } Type Constraints 泛型声明时可以限制有资格用于解析特定占位符的类型，这被称为类型约束。类型约束最简单的形式是在声明占位符时在它的名字后面加一个冒号和一个类型名，冒号后面的类型名可以是一个类名或一个协议名。
如果冒号后面是类名，表明这个类型必须是这个类或者这个类的子类。如果是协议名称，则表明该类型必须是该协议的采用者。而对于一个协议关联类型，类型约束可以作为关联类型声明的一部分出现：
protocol Flier {  func fly() }  protocol Flocker {  associatedtype T: Flier  func flockTogetherWith(f: T) }  struct Bee: Flier {  func fly() {  //  } }  struct Bird: Flocker {  func flockTogetherWith(f: Bee) {  //  } } 在上面的示例代码中，协议Flocker的关联类型T被限定为协议Flier的采用者。Bee是协议Filer的一个采用者，因此Bird采用协议Flocker时，可以将Bee作为方法flockTogetherWith的参数类型。
请注意，如果没有关联类型，我们就不可能通过像这样声明Flocker来达到同样的效果：
protocol Flocker {  func flockTogetherWith(f: Flier) } 但这不是一回事， 这需要Flocker采用者将flockTogetherWith的参数指定为Flier，我们将不得不像下面这样写Bird：
struct Bird: Flocker {  func flockTogetherWith(f: Flier) {  // ...  } } 对于一个泛型函数或泛型对象类型，类型约束可以出现在尖括号中。例如，前面描述了一个全局函数func dogMakerAndNamer&amp;lt;WhatType:Dog&amp;gt;。因为，Dog是一个类，所以约束条件说WhatType必须是Dog或Dog的子类。
占位符的类型约束通常用来向编译器保证某些信息可以被发送到占位符类型的实例上。假设我们想实现一个函数 myMin，返回列表中最小的成员。这里有一个有希望实现的泛型函数，但有一个问题它不能通过编译：
func myMin&amp;lt;T&amp;gt;(_ things: T...) -&amp;gt; T {   var minimum = things.first!   for item in things.dropFirst() {   if item &amp;lt; minimum { // compile error   minimum = item   }  }  return minimum } 上面的问题是item &amp;lt; minimum，因为编译器还不知道T的真正类型，即不知道item和minium类型，因此还不清楚运算符&amp;lt;是否能运用在item和minium上，所以编译器拒绝上面代码通过编译。
解决方案是向编译器承诺，T的解析类型实际上可以使用小于运算符。事实证明，这样做的方法是将T限制在Swift内置的可比较协议中：
func myMin&amp;lt;T: Comparable&amp;gt;(_ things: T...) -&amp;gt; T {   var minimum = things.first!   for item in things.dropFirst() {   if item &amp;lt; minimum { // compile error   minimum = item   }  }  return minimum } Explicit Specialization 迄今为止所有泛型例子中，占位符的类型都是通过编译器推断来完成解析的。还有另一种方法来执行解析—手动解析类型，这就是所谓的显式特化explicit specialization，目前有两种形式的explicit specialization。
Generic protocol with associated type 协议的采用者可以通过类型别名来完成手动解析关联类型，即将关联类型等同于一个明确的类型：
protocol Flier {  associatedtype T }  struct Bird: Flier {  typealias T = String } Generic object type 泛型对象类型的使用者可以用声明泛型相同尖括号语法来手动解析占位符类型，尖括号中是实际的类型名称，如下所示：
class Dog&amp;lt;T&amp;gt; {  var name: T? }  let d = Dog&amp;lt;String&amp;gt;() 但是，不能显式地特化一个泛型函数，一个解决方案是让泛型函数接受一个类型参数以解析泛型。下面是先前在dogMakerAndNamer例子中所做的：
func dogMakerAndNamer&amp;lt;WhatType: Dog&amp;gt;(_: WhatType.Type) -&amp;gt; WhatType {  let d = WhatType.init(name: &amp;#34;Fido&amp;#34;)  return d } 函数dogMakerAndNamer的参数从未在函数体内使用，这就是为什么它没有名字，只有一个下划线。然而，它确实是为了解析泛型的。
另一种方法是不使用泛型函数。替换地，先声明一个泛型对象类型，在它里面包装一个使用泛型占位符的非泛型函数。泛型占位符可以被显式地特化，以在函数中解析占位符：
protocol Flier {  init() }  struct Bird: Flier {  init() {  //  } }  struct FlierMaker&amp;lt;T: Flier&amp;gt; {  static func makeFlier() -&amp;gt; T {  return T()  } }  let f = FlierMaker&amp;lt;Bird&amp;gt;.makeFlier() // returns a Bird 当一个类是泛型类，只要解析了泛型占位符就可以对它进行子类化。可以通过一个匹配的泛型子类或者明确地解析父类的泛型占位符来做到这一点。下面是一个泛型Dog类：
class Dog&amp;lt;T&amp;gt; {  func speak(_ what: T) {  // ...  } } 可以将其子类化为一个泛型，其占位符与父类的占位符一致：
class NoisyDog&amp;lt;T&amp;gt; : Dog&amp;lt;T&amp;gt; {} 这是合法的，因为NoisyDog占位符T的被解析时的同时也解析了父类的Dog占位符T。另一个选择是明确特化父类Dog以得到非泛型子类：
class NoisyDog : Dog&amp;lt;String&amp;gt; {} 在这种情况下，子类中的方法覆盖可以使用专门的类型，而父类则使用泛型：
class NoisyDog: Dog&amp;lt;String&amp;gt; {  override func speak(_ what: String) {  // ...  } } Generic Types and Covariance 一个泛型对象类型不能用于声明的类型。下面的类类型Dog&amp;lt;T&amp;gt;，不能简单声明一个变量为Dog类型：
class Dog&amp;lt;T&amp;gt; {  func speak(_ what: T) {  //  } }  var d: Dog? // compile error 只有一个被解析了的泛型对象类型可用于声明中的类型，能有多少种解析就有多少种类型，每种不同的解析都构成一种不同的类型：
class Dog3&amp;lt;T&amp;gt; {  func speak(_ what: T) {  //  } }  var d1: Dog3&amp;lt;Int&amp;gt;? // that&amp;#39;s a type var d2: Dog3&amp;lt;String&amp;gt;? // that&amp;#39;s a different type  // ... and so on ... 但是，有一种显然的情况除外，即当根据上下文可以推断出类型时：
class Node&amp;lt;T&amp;gt; {  let value: T  let parent: Node?   init(_ value: T, parent: Node?) {  self.value = value  self.parent = parent  } } 上面代码看起来parent属性是一个尚未解析的可选Node类型。实际上，在没有显式特化的情况下，编译器会认为它是 Node&amp;lt;T&amp;gt;，并将parent解析为当前类型。
泛型的不同特化类型不仅是不同的类型，而且是不相关的类型。特别地，一个专门化为子类型的泛型对于专门化为父类型的同一泛型来说不是多态的：
struct Wrapper&amp;lt;T&amp;gt; {  // }  class Cat {  // }  class CalicoCat: Cat {  // } let w : Wrapper&amp;lt;Cat&amp;gt; = Wrapper&amp;lt;CalicoCat&amp;gt;() // compile error 上面代码会出现编译错误，上面的代码中两个泛型类型Wrapper&amp;lt;Cat&amp;gt;和Wrapper&amp;lt;CalicoCat&amp;gt;不是父类和子类的关系。相反，如果这种赋值是可能的，我们会说这些类型是共变的covariant，这意味着占位符的特化之间的多态关系被应用到了泛型类型本身。
某些 Swift 内置的泛型是共变的，Optional 就是一个明显的例子。但令人沮丧的是，共变性并不是一种通用的语言特性，无法指定自定义泛型类型应该是共变的。一种解决方法是将泛型占位符限制为一个协议，并让自定义类型采用该协议：
protocol Meower {  func meow() }  struct Wrapper&amp;lt;T: Meower&amp;gt; {  let meower: T }  class Cat: Meower {  func meow() {  print(&amp;#34;meow&amp;#34;)  } }  class CalicoCat: Cat { } 现在下面赋值就是合法的了：
let w : Wrapper&amp;lt;Cat&amp;gt; = Wrapper(meower:CalicoCat()) Associated Type Chains 当泛型占位符被限制为具有关联类型的泛型协议时，可以使用点标注来引用关联类型：占位符名称、点和关联类型名称。
下面是一个例子。想象一下，在一个游戏程序中，士兵和弓箭手是彼此的敌人。我将通过将士兵结构体和弓箭手结构体归入Fighter协议来表达这一点，Fighter协议有一个关联类型Enemy，它本身被约束为Fighter：
protocol Fighter {  associatedtype Enemy: Fighter }  struct Soldier: Fighter {  typealias Enemy = Archer }  struct Archer: Fighter {   typealias Enemy = Soldier } available属性 有个类涉及到的属性只能在iOS 13.0以上系统使用，为了将该类定义为其它类的属性，必须加上available和lazy：
@available(iOS 13.0, *) class HapticManager { } class VibrationService {  @available(iOS 13.0, *)  private(set) lazy var hapticManager = HapticManager() } xcframework xcodebuild clean archive -workspace CMBMPGMK.xcworkspace -scheme CMBMPGMK -configuration release -sdk iphoneos -destination &amp;#39;generic/platform=iOS&amp;#39; -archivePath &amp;#39;./build/iphonedevice.xcarchive&amp;#39; SKIP_INSTALL=NO BUILD_LIBRARIES_FOR_DISTRIBUTION=YES   xcodebuild clean archive -workspace CMBMPGMK.xcworkspace -scheme CMBMPGMK -configuration release -sdk iphonesimulator -destination &amp;#39;generic/platform=iOS Simulator&amp;#39; -archivePath &amp;#39;./build/iphonesimulator.xcarchive&amp;#39; SKIP_INSTALL=NO BUILD_LIBRARIES_FOR_DISTRIBUTION=YES   xcodebuild -create-xcframework -framework ./iphonesimulator.xcarchive/Products/Library/Frameworks/CMBMPGMK.framework -framework ./iphonedevice.xcarchive/Products/Library/Frameworks/CMBMPGMK.framework -output CMBMPGMK.xcframework  静态库 BUILD_LIBRARIES_FOR_DISTRIBUTION=YES 头文件放到public，以及要将头文件放出来 bitcode=no exclude simulator arm64  </content>
    </entry>
    
     <entry>
        <title>Swift协议</title>
        <url>https://iihui.github.io/post/ios-protocol/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  2015年苹果声称Swift是第一个面向协议的编程语言。从它的名字来看，很可能会认为面向协议编程都是关于协议的，但这是不正确的。面向协议的编程所涉及的不仅仅是协议，它实际上是一种新的方式，不仅是编写应用程序，而且是我们如何思考应用程序的设计。
 协议使用protocol关键字来定义，其定义语法类似于class,struct,enum等类型。下面代码定义了BaseProtocol协议，它只包含一个baseFunc方法：
protocol BaseProtocol {  func baseFunc() } 协议中的属性 定义协议时可以要求adopting协议的类型提供特定名字和特定类型的属性，但对于adopting协议的类型定义的是计算属性还是存储属性并没有要求。下面定义的FullNameProtocol协议包含了两个属性：
protocol FullNameProtocol {  var firstName: String { get set }  var lastName: String { get set } } 上面定义的两个属性firstName和lastName，都是读写属性。如果想要定义只读属性，则只需声明get，去掉set关键字即可：
protocol ReadOnlyProtocol {  var readOnly: String { get } } 协议中也可以定义静态属性，只需要在属性名的最前面添加static关键字。下面定义的StaticProtocol协议中添加了一个静态只读属性staticProperty:
protocol StaticProtocol {  static var staticProperty: String { get } } 协议中的方法 在协议定义时可以要求adopting协议的类型提供特定的方法。在协议中定义方法和在class,struct中声明方法有点相似，但不需要花括号和函数体：
protocol FullNameProtocol {  func getFullName() -&amp;gt; String } 可选属性或方法 如果要定义一个属性或者方法是可选实现的，首先需要在协议定义前添加@objc关键字，并且在可选的属性或方法前添加@objc optional:
@objc protocol Phone {  var phoneNumber: String { get set }  @objc optional var emailAdress: String { get set }  func dialNumber()  @objc optional func getEmail() -&amp;gt; String } 协议继承 定义协议时可以从一个或多个协议中继承定义的属性和方法，即协议支持多继承，在继承的同时也可以添加自定义的属性和方法。下面代码是协议继承的一个简单例子：
protocol FullName {  var firstName: String { get set }  var lastName: String { get set }   func getFullName() -&amp;gt; String }  protocol Person: FullName {  var age: Int { set get } }  struct student: Person {  var firstName = &amp;#34;firstName&amp;#34;   var lastName = &amp;#34;lastName&amp;#34;   var age = 0  func getFullName() -&amp;gt; String {  return &amp;#34;\(firstName)\(lastName)&amp;#34;  } }  protocol A {  var name: String { get } } protocol B {  var age: Int { get } }  protocol C: A, B {  var hook: String { get } } 协议组合 面向协议编程中有个重要的概念protocol composition（协议组合）。协议组合允许一个类型adopting多个协议，这是相对于类继承的最大优势，因为Swift中的类类型只允许单继承。
struct MyStruct: ProtocolOne, ProtocolTwo, ProtocolThree {  // 实现结构体的定义 } 协议组合允许我们将需求分解成许多较小的组件，而不是从一个协议或单一的父类中继承所有的属性或方法。这使得类型族在宽度上而不是在高度上增长，意味着可以避免创建臃肿的类型（这些类型可能包含一些不需要的属性和方法）。
像类型一样使用协议 尽管协议中没有任何具体实现，但在Swift中，协议仍然被认为是一种成熟的类型，并且大多可以像其他类型一样使用。这意味着，可以将协议作为函数的参数或返回类型，还可以把它们作为变量、常量和集合的类型。
protocol FullName {  var firstName: String { get set }  var lastName: String { get set }   func getFullName() -&amp;gt; String }  protocol Person: FullName {  var age: Int { set get }  var birthDate: Date { get set }  var profession: String { get }  init(firstName: String, lastName: String, birthDate: Date) }  func updatePerson(person: Person) -&amp;gt; Person {  var newPerson: Person  // 在这里更新newPerson  return newPerson } var personArray = [Person]() var personDict = [String: Person]() 协议的多态性 多态这个词来自希腊语的词根poly（意为许多）和morphe（意为形式）。在编程语言中，多态性是指多种类型的单一接口。多态性让我们通过单一的统一接口与多种类型进行交互。在面向对象的编程世界中，单一的统一接口通常来自父类，而在面向协议的编程世界中，这个单一的接口的通常跟协议相关。
struct Student: Person {  var firstName = &amp;#34;&amp;#34;  var lastName = &amp;#34;&amp;#34;  var age = 0  var birthDate: Date  var profession: String = &amp;#34;&amp;#34;   init(firstName: String, lastName: String, birthDate: Date) {  self.firstName = firstName  self.lastName = lastName  self.birthDate = birthDate  }   func getFullName() -&amp;gt; String {  return &amp;#34;\(firstName)\(lastName)&amp;#34;  } }  struct FootballPlayer: Person {  var firstName: String  var lastName: String  var age: Int = 0  var birthDate: Date  var profession: String = &amp;#34;&amp;#34;   init(firstName: String, lastName: String, birthDate: Date) {  self.firstName = firstName  self.lastName = lastName  self.birthDate = birthDate  }   func getFullName() -&amp;gt; String {  return &amp;#34;\(firstName)\(lastName)&amp;#34;  } }  func test() {  var myPerson: Person  myPerson = Student(firstName: &amp;#34;Jon&amp;#34;, lastName: &amp;#34;Hoffman&amp;#34;, birthDate: Date())  myPerson = FootballPlayer(firstName: &amp;#34;Dan&amp;#34;, lastName: &amp;#34;Marino&amp;#34;, birthDate: Date()) } 协议中的关联类型 当定义一个协议时，有时定义一个或多个关联类型是很有用的。关联类型是一个类型占位符，可以在协议中使用它来代替一个类型。实际用于关联类型的类型在协议被实现之前是不被定义的。
关联类型的意思是说：暂时不知道要使用的确切类型。当一个类型采用这个协议时，它才定义实际的类型。关联类型的定义需要使用associatedtype关键字。
假设要为一个队列定义一个协议，我们希望实现该协议的类型能够定义队列包含的实例类型。下面定义的Queue协议有一个关联类型QueueType，在协议中的两个方法都使用了这个关联类型：
protocol Queue {  associatedtype QueueType  mutating func addItem(item: QueueType)  mutating func getItem() -&amp;gt; QueueType?  func count() -&amp;gt; Int } 任何实现Queue协议的类型必须为QueueType占位符指定一个实际的类型，并且必须确保在协议中使用QueueType占位符的地方只使用这个实际的类型：
struct IntQueue: Queue {  var items = [Int]()   mutating func addItem(item: Int) {  items.append(item)  }   mutating func getItem() -&amp;gt; Int? {  if !items.isEmpty() {  return items.remove(at: 0)  } else {  return nil  }  }   func count() -&amp;gt; Int {  return items.count  } } 协议设计 下面定义的RobotMovment协议中有5个方法，每个采用RobotMovment协议的类型都必须全部实现这5个的方法：
protocol RobotMovement {  func forward(speedPercent: Double)  func reverse(speedPercent: Double)  func left(speedPercent: Double)  func right(speedPercent: Double)  func stop() } 如果机器人在二维空间行走，则上面的5个方法已经足够使用。但如果机器人要到三维空间飞行，则需要定义向上和向下的方法：
protocol RobotMovementThreeDimensions: RobotMovement {  func up(speedPercent: Double)  func down(speedPercent: Double) } Protocols 协议是一种表达与其它不相关类型之间共性的方式。例如，由于Bee和Bird都可以飞行，因此Bee对象和Bird对象可能具有共同的特征。因此，定义飞行者Flier类型可能是有用的。问题是在什么意义上，Bee和Bird都可以是飞行者？
一种可能的实现方式是使用类继承。如果Bee和Bird都是类，Flier可能是Bee和Bird的父类。然而，Flier不能成为Bee和Bird的父类可能有其它原因。例如，Bee是一种昆虫，而Bird则不是，但是它们都有飞行的能力。我们需要一个以某种方式跨越类的层次结构，将两个关系较远的类联系在一起。
此外，如果Bee和Bird不是两个类怎么办？在Swift中，这是可能的，因为重要且强大的对象可以是结构而不是类。因为结构体不能继承，所以没有父结构体和子结构体。Bee结构体和Bird结构体如何都是Fliers？
Swift通过使用协议解决了这个问题。协议在Swift中是非常重要，Swift头文件中定义了60多个协议。此外，Objective-C也有协议，Cocoa也大量使用协议。Swift的协议与Objective-C的协议大致对应，并且可以互换。
协议也是对象类型，但是不能实例化一个协议类型。协议声明只是一个轻量级的属性和方法列表，其中的属性没有值，方法没有代码。一个&amp;quot;真正的&amp;quot;对象类型可以正式声明它属于一个协议类型，这被称为adopting协议。一个adopting协议的对象类型承诺要实现协议中列出的属性和方法。
假设成为一名飞行者仅包括实现飞行方法。那么一个Flier协议可以指定必须有一个fly方法。因此，它列出了没有函数体的fly方法，如下所示:
protocol Flier {  func fly() } enum,struct,class甚至另外一个协议都可以adopting当前协议。只需在声明中的名称后的冒号后列出协议即可，如果采用者是具有父类的类，则协议位于父类规范后的逗号之后。
protocol Flier {  func fly() }  struct Bird: Flier {  func fly() {  debugPrint(&amp;#34;fly&amp;#34;)  } } 也许你此时想知道：那又怎样？如果想让一只鸟知道如何飞行，为什么不直接给鸟一种飞行方法而不采用任何协议呢？协议有什么区别？答案与类型有关，协议是一种类型。因此，在声明变量或函数参数的类型时，可以使用Flier作为类型：
func tellToFly(_ f: Flier) {  f.fly() } 因此，协议给了另一种表达类型和子类型概念的方式，多态性也适用。根据替换原则，这里的Flier可以是任何对象类型的实例，只要它adopting了flier协议。它可能是一只鸟，也可能是其它任何东西。如果类型采用了Flier协议，它就可以被传递到期望有Flier的地方。
此外，Flier必须有一个fly方法，这是adopting Flier协议意义所在。一个有fly方法的对象并不能自动成为Flier。仅仅实现协议中的方法的要求还不够，对象类型必须正式采用该协议，这段代码是不会被编译的:
struct Bee {  func fly() {  //  } }  let b = Bee() tellToFly(b) // compile error 虽然Bee能够发送fly消息。但是tellToFly不接受Bee参数，因为它需要一个Flier参数。从形式来讲，Bee不是Flier。要使Bee成为Flier，需要正式声明Bee采用Flier了协议。下面这段代码是可以通过编译的：
struct Bee: Flier {  func fly() {  debugPrint(&amp;#34;Bee fly&amp;#34;)  } }  let b = Bee() tellToFly(b) Adopting a Library Protocol 在Swift标准库中有各种协议，其中CustomStringConvertible协议要求实现一个description字符串属性。如果遵循CustomStringConvertible协议，当这种类型的实例被用于字符串插值或打印（在控制台中使用po命令，或在字符串初始化器init(descripbing:)）时，它的description属性值会被自动用来表示它。
enum Filter: String, CustomStringConvertible {   case albums = &amp;#34;Albums&amp;#34;   case playlists = &amp;#34;Playlists&amp;#34;   case podcasts = &amp;#34;Podcasts&amp;#34;   case books = &amp;#34;Audiobooks&amp;#34;   var description: String {  return self.rawValue  }  }  let filterType = Filter.albums debugPrint(&amp;#34;It is \(filterType)&amp;#34;) // It is Albums debugPrint(filterType) // Albums debugPrint(Filter.albums) debugPrint(String(describing: Filter.books)) 请注意，一个类型可以采用多个协议（协议组合）。例如，内置的Double类型采用了CustomStringConvertible、Hashable、Strideable等几个内置协议。声明采用多个协议的格式如下：
struct MyType: CustomStringConvertible, TextOutputStreamable, Strideable {  // ... } 当声明的类型是一个协议类型时，在采用的协议类型和它的真实类型之间进行转换。给定一个同时被Bird和Bee采用的协议Flier，可以使用is操作符来测试一个特定的Flier是否为Bird类型：
func isBird(_ f: Flier) -&amp;gt; Bool {  return f is Bird } 同样地，as和as?可以用来将一个被声明为协议类型的对象转换到它的实际类型。能够这样做很重要，因为采用协议的实际对象通常能够接收协议不能接收的消息。例如，一个Bird作为Filier时可以调用fly，但只能作为Bird时才能调用getWorm方法：
struct Bird: Flier {  func fly() {  debugPrint(&amp;#34;fly&amp;#34;)  }   func getWorm() {  //  } }  func tellGetWorm(f: Flier) {  (f as? Bird)?.getWorm() } Declaring a Protocol 协议声明只能在文件的顶层进行。要声明协议，需要使用关键字protocol，后跟协议名称（应该以大写字母开头，因为这是一种类型），然后是花括号，它可能包含以下任何一项的声明：
  属性：协议中的属性声明由var（不能使用let）、属性名称、冒号、类型名称和包含get或get set花括号组成。其中get或get set不能被省略。
  在只有get的情况下，采用者对该属性的实现可以是只读或者可写的。而在有get set情况下，它必须是可写的，采用者不得将get set属性实现为只读的计算属性或常量（let）存储属性。
protocol A {  let str: String //Protocols cannot require properties to be immutable; declare read-only properties by using &amp;#39;var&amp;#39; with a &amp;#39;{ get }&amp;#39; specifier }  protocol B {  let str: String { get } //&amp;#39;let&amp;#39; declarations cannot be computed properties. Replace &amp;#39;let&amp;#39; with &amp;#39;var&amp;#39; }   要声明一个静态/类属性，在它前面加上关键字static。如果采用者是类类型可以自由地将其作为一个class的计算属性来实现。如果采用者是结构体，只能使用static关键字：
struct B: A {  static var name: String = &amp;#34;&amp;#34; }  struct C: A {  static var name: String = &amp;#34;&amp;#34; }  class D: A {  // class var name: String = &amp;#34;&amp;#34; //Class stored properties not supported in classes; did you mean &amp;#39;static&amp;#39;?  private static var _name = &amp;#34;&amp;#34;  class var name: String {  get {  return _name  }  set {  self._name = newValue  }  } }  D.name = &amp;#34;test&amp;#34; debugPrint(D.name)     方法：协议中的方法声明是没有函数体的函数声明，既没有花括号，也没有代码。任何函数类型都是合法的，包括 init和subscript方法。
  在协议中声明下标的语法与在对象类型中声明下标的语法相同，只是花括号中包含get或get set。
protocol A {  subscript(ix: Int) -&amp;gt; String { get } }  struct B: A {  subscript(ix: Int) -&amp;gt; String {  return &amp;#34;&amp;#34;  } }   要声明静态/类方法，请在其前面加上关键字static。如果采用者为类类型，那么可以自由地将其实现为class方法。
protocol A {  static subscript(ix: Int) -&amp;gt; String { get } }  struct B: A {  static subscript(ix: Int) -&amp;gt; String {  return &amp;#34;B&amp;#34;  } }  class C: A {  // 实现为class方法  class subscript(ix: Int) -&amp;gt; String {  return &amp;#34;C&amp;#34;  } } protocol A {  static subscript(ix: Int) -&amp;gt; String { get set } }  struct B: A {  static subscript(ix: Int) -&amp;gt; String {  get {  return &amp;#34;B&amp;#34;  }  set {  //  }  } }  class C: A {  // 实现为class方法  class subscript(ix: Int) -&amp;gt; String {  get {  return &amp;#34;B&amp;#34;  }  set {  //  }  } }   如果要允许枚举或结构体采用者声明方法mutating，必须在协议中声明它是mutating的。如果协议缺少mutating，采用者不能添加mutating，但如果协议具有mutating，采用者可以省略mutating。
protocol A {  func change(name: String) -&amp;gt; Void }  struct B: A {  var name: String  // Type &amp;#39;B&amp;#39; does not conform to protocol &amp;#39;A&amp;#39;  mutating func change(name: String) {  self.name = name  } } protocol A {  mutating func change(name: String) -&amp;gt; Void }  struct B: A {  var name: String   mutating func change(name: String) {  self.name = name  } } protocol A {  mutating func change(name: String) -&amp;gt; Void }  struct B: A {  var name: String   func change(name: String) {  //self.name = name  } }     一个协议本身可以继承多个协议，声明协议时在名称后面加一个冒号，然后用逗号分隔它所采用的协议列表。实际上，这提供了一种方法来创建整个类型的二级层次结构，Swift的头文件就大量使用了这一点。
protocol A {  func test1() -&amp;gt; Void }  protocol B {  func test2() -&amp;gt; Void }  protocol C: A, B {  func test3() -&amp;gt; Void } Protocol Composition 如果协议的唯一目的是通过采用所有其它协议，而不添加任何新要求，则可以通过即时指定协议组合来避免正式声明协议。为此，请使用&amp;amp;连接协议名称，这称为协议组合：
func f(_ x: CustomStringConvertible &amp;amp; CustomDebugStringConvertible) {  // } 一个类型也可以被指定为一个类类型和一个或多个协议的组合。下面的代码中ViewController中声明的变量v的类型就是类UIView和协议MyViewProtocol的组合:
protocol MyViewProtocol {  func doSomethingReallyCool() }  class ViewController: UIViewController {  var v: (UIView &amp;amp; MyViewProtocol)?   func test() {  self.v?.doSomethingReallyCool() // a MyViewProtocol requirement   self.v?.backgroundColor = .red // a UIView property   } } 如果要赋值变量给ViewController的属性v，这个实例必须是UIView类型（或者它的子类型）并且adopting协议MyViewProtocol。
Class Protocols 协议声明可以在冒号后包含类名，这将能够采用此协议的类型限制为该类或其子类。所以还有一种更简单的方式实现上面的效果，就是在MyViewProtocol声明的时候，限定adopting协议的具体类型。如下所示只要在MyViewProtocol声明的时候加上冒号和类型：
protocol MyViewProtocol: UIView {  func doSomethingReallyCool() } 上面的代码的意思是MyViewProtocol协议只能被UIView或它的子类所采用。如果要限定一个协议只能被类类型所采用，可以将其限定类型设置为AnyObject：
protocol MyClassProtocol : AnyObject {  // ... } 在限定类型时一种可选的方式是在协议定义的花括号前使用where关键字：
protocol MyClassProtocol where Self: AnyObject {  // ... } Optional Protocol Members 在Objective-C中协议的成员可以声明为可选的，这意味着该成员不是必须要实现的。Swift中也可以声明可选的协议类型，但该特性是为了兼容Objective-C，实际上是由Objective-C实现的，它根本就不是 Swift 的特性。
因此，关于可选协议成员的一切都必须显式地暴露给Objective-C。协议声明必须用@objc属性标记，可选成员的声明必须用关键字@objc optional标记：
@objc protocol Flier {  @objc optional var song: String { get }  @objc optional func sing() } 在上面的代码中，在Flier协议中声明了可选的属性song，Swift通过将其获取的值包装在一个Optional中来解决这个问题。如果Flier采用者不实现该属性，则结果为nil：
class Bird: Flier {  func sing() {  //  } }  let flier: Flier = Bird() let song = flier.song // song is an Optional wrapping a String 这是一种罕见的情况，在这种情况下，可以得到一个双重包装的可选属性。如果可选属性 song 的值本身就是一个 String?，那么从 Flier 中获取它的值将产生一个 String??。
对于在协议中声明的读写可选属性，有一个奇怪的限制，就是不能去重新设置它的值。如下所示，重新设置flier的song属性时会报错：
@objc protocol Flier {  @objc optional var song: String { get set }  @objc optional func sing() }  class Bird: Flier {  var song: String = &amp;#34;bird name&amp;#34;   func sing() {  //  } }  let flier: Flier = Bird() let song = flier.song // song is an Optional wrapping a String flier.song = &amp;#34;test&amp;#34; // Cannot assign to property: &amp;#39;flier&amp;#39; is immutable 报错的信息是Cannot assign to property: &#39;flier&#39; is immutable，而这完全不合逻辑，因为flier指向的是一个类实例，这显然是语言中的一个错误，一种解决方法是使用关键路径：
@objc protocol Flier {  @objc optional var song: String { get set }  @objc optional func sing() }  class Bird: Flier {  var song: String = &amp;#34;bird name&amp;#34;   func sing() {  //  } }  var flier: Flier = Bird() let song = flier.song // song is an Optional wrapping a String //flier.song = &amp;#34;test&amp;#34; // Cannot assign to property: &amp;#39;flier&amp;#39; is immutable flier[keyPath: \.song] = &amp;#34;test&amp;#34; 在上面的代码中Flier协议中也定义了一个可选sing方法，所以调用它之前需要使用？。如果采用Flier协议的类型没有实现sing方法，那么下面的调用不会发生任何事情：
flier.sing?() 如果可选协议中的可选方法有返回值，那么调用时得到的值也是可选的：
@objc protocol Flier {  @objc optional var song: String { get set }  @objc optional func sing() -&amp;gt; String }  class Bird: Flier {  var song: String = &amp;#34;bird name&amp;#34;   func sing() -&amp;gt; String {  return &amp;#34;sing&amp;#34;  } }  let singe = flier.sing?() //Optional(&amp;#34;sing&amp;#34;) 如果在协议中声明init方法，如果采用协议的是类类型，那么该类和它的子类必须实现该初始化器，并且必须标记为required，否则会出现编译错误nitializer requirement &#39;init()&#39; can only be satisfied by a &#39;required&#39; initializer in non-final class &#39;Bird&#39;：
protocol Flier {  init() }  class Bird: Flier {  required init() {  debugPrint(&amp;#34;required init&amp;#34;)  } } 上面代码中Bird没有被标记为final，它的init必须标记为required。这意味着实现任何指定初始化器的任何 Bird 子类（因此失去初始化器继承）必须实现required初始化器并将其标记为required的。如果类Bird标记为final时，实现Flier协议中的init方法则不再需要关键字required：
protocol Flier {  init() }  final class Bird: Flier {  init() {  debugPrint(&amp;#34;required init&amp;#34;)  } } 这个事实会产生一个奇怪而烦人的特性。假设将内置的Cocoa类UIViewController子类化，下面代码是你极有可能做的事情：
class ViewController: UIViewController {  init() {  super.init(nibName: &amp;#34;ViewController&amp;#34;, bundle: nil) // compile error   } } 上面的代码会出现编译错误required initializer init(coder:)。这是因为UIViewController采用了NSCoding协议，这个协议中有一个required的init(coder:)。UIViewController子类必须继承 init(coder:)或必须显式实现它并将其标记为required。
上面的代码中已经实现了自己的指定初始化程序——因此切断了初始化程序继承。因此它必须实现 init(coder:)并将其标记为required。
class ViewController: UIViewController {  init() {  super.init(nibName: &amp;#34;ViewController&amp;#34;, bundle: nil) // compile error  }   required init?(coder: NSCoder) {  fatalError(&amp;#34;init(coder:) has not been implemented&amp;#34;)  } } 上面的代码可以通过编译，但如果真的被调用了，就会发生崩溃。不仅是UIViewController，其它的很多内置的Cocoa 类都采用NSCoding协议。如果将这些类中的任何一个进行子类化并实现自定义的初始化程序，都将遇到此问题。
Expressible by Literal Swift的美妙之处是它的许多功能都在Swift头文件中公开，字面量就是一个很好的例子。可以用5来表示一个值为5的Int，而不是通过Int(5)来正式初始化Int，这不是因为魔法。
这是因为Int采用了ExpressibleByIntegerLiteral协议。不仅是Int字面量，所有的字面量都是这样工作的。以下协议在Swift头文件中声明：
ExpressibleByNilLiteral  ExpressibleByBooleanLiteral  ExpressibleByIntegerLiteral  ExpressibleByFloatLiteral  ExpressibleByStringLiteral  ExpressibleByExtendedGraphemeClusterLiteral  ExpressibleByUnicodeScalarLiteral  ExpressibleByArrayLiteral  ExpressibleByDictionaryLiteral 可以在自定义的类型中采用字面量协议，这意味了字面量可以出现在需要对象类型实例的地方。下面的代码中声明了一个Nest结构体，它采用了ExpressibleByIntegerLiteral协议，因此在需要使用Nest实例的地方可以使用字面量：
struct Nest: ExpressibleByIntegerLiteral {  var eggCount: Int = 0   init() {  //  }   init(integerLiteral val: Int) {  self.eggCount = val  } }  func reportEggs(_ nest: Nest) {  print(&amp;#34;this nest contains \(nest.eggCount)eggs&amp;#34;) }  reportEggs(4) // this nest contains 4 eggs Generics 泛型是一种类型占位符，以后将会把实际的类型放入其中。特别是，在有些情况下，某个相同的类型将在多个地方使用，而不需要精确指定是什么类型。
之前我们定义了如下的全局函数，该函数声明的返回的类型是Dog，如果在调用的时候传入了Dog的子类，那么返回的依然是父类Dog实例：
func dogMakerAndNamer(_ whatType: Dog.Type) -&amp;gt; Dog {  let d = WhatType.init(name: &amp;#34;Fido&amp;#34;)  return d } 实际上我们希望在箭头运算符后的返回类型与参数类型相同，泛型可以达到这个目的。在下面的代码中，泛型函数指定WhatType始终是相同的类型（要求是Dog或Dog子类），而不必确切指定它是什么类型：
func dogMakerAndNamer&amp;lt;WhatType: Dog&amp;gt;(_: WhatType.Type) -&amp;gt; WhatType {  let d = WhatType.init(name: &amp;#34;Fido&amp;#34;)  return d }	因为Swift是一种强类型语言，为了调用函数dogMakerAndNamer，编译器需要知道WhatType的真实类型。但事实上，它是通过调用时传入的类型才知道真实的类型：
class Dog {  required init(name: String) {  //  } }  class NoisyDog: Dog {  required init(name: String) {  super.init(name: name)  } }  let dog = dogMakerAndNamer(NoisyDog.self) 在上面方法调用中，传递了NoisyDog.self作为参数，这就是告诉编译器WhatType的实际类型，实际上编译器现相当于在整个泛型中将NoisyDog替换为WhatType，该替换过程称为解析（或专门化）泛型。：
func dogMakerAndNamer(_: NoisyDog.Type) -&amp;gt; NoisyDog {  let d = NoisyDog.init(name: &amp;#34;Fido&amp;#34;)  return d } Optional 任何类型的值都可以被包裹在一个Optional中，这是因为Optional是一个泛型。下面是一个Optional的工作原理：
Optional是一种枚举类型，它有两个值.none和.some。如果一个Optional是.some，它就有一个关联值——被这个Optional包裹的值。但是这个关联值的类型是什么呢？
一方面，我们可以认为是任何类型，毕竟，这就是为什么任何东西都可以被Optional包裹起来。另一方面，任何特定的Optional都只能包装一个特定的已知类型的值，这听起来就像一个泛型。Swift头中的Optional枚举的声明如下所示：
@frozen public enum Optional&amp;lt;Wrapped&amp;gt; : ExpressibleByNilLiteral {   case none   case some(Wrapped)   public init(_ some: Wrapped)   @inlinable public func map&amp;lt;U&amp;gt;(_ transform: (Wrapped) throws -&amp;gt; U) rethrows -&amp;gt; U?   @inlinable public func flatMap&amp;lt;U&amp;gt;(_ transform: (Wrapped) throws -&amp;gt; U?) rethrows -&amp;gt; U?   public init(nilLiteral: ())   @inlinable public var unsafelyUnwrapped: Wrapped { get } } 上面声明中尖括号里的Wrapped是一个占位符，枚举声明的其余部分将继续使用这个占位符。除了.none这种情况，还有一种情况.some，它有一个相关的值&amp;ndash;Wrapped类型。
还有一个初始化器，它需要一个参数&amp;ndash;Wrapped类型的。因此，我们被初始化的类型(不管是什么类型)都是Wrapped类型，因此是与.some情况相关的类型。
let s = Optional(&amp;#34;howdy&amp;#34;) 对于上面的代码首先调用初始化器init(_ some: Wrapped)，所以&amp;quot;howdy&amp;quot;在这里作为一个Wrapped实例被提供的，并将这个泛型解析为String。编译器现在知道，在这个特定的Optional&amp;lt;Wrapped&amp;gt;中，Wrapped是String，这个特定的Optional的声明在编译器看起来如下所示：
enum Optional&amp;lt;String&amp;gt; {  case none  case some(String)  init(_ some: String) // ... } 上面代码中，实际上s的类型为Optional&amp;lt;String&amp;gt;，可以使用let s: Optional&amp;lt;String&amp;gt; = &amp;quot;howdy&amp;quot;来达到同样的效果。
Generic Declarations 下面列出了可以在Swift中以某种形式声明泛型的地方：
  泛型协议使用Self。在协议声明时，使用关键词Self可以将协议变成一个泛型协议。Self在这里是一个占位符，意味着采用者的类型。下面是一个Flier协议，它声明了一个接受Self参数的方法：
protocol Flier {  func flockTogetherWith(_ f: Self) } 这意味着，如果Bird对象类型采用Flier协议，那么实现flockTogetherWith时需要将其参数声明为Bird。
  泛型协议使用关联类型。协议定义时可以使用associatedtype关键字来声明关联类型，这可以将协议转换为泛型协议，关联类型名此时也是一个占位符：
protocol Flier {  associatedtype Other  func flockTogetherWith(_ f: Other)  func mateWith(_ f: Other) } 采用该协议的类型将指定占位符所代表的真正类型：
struct Bird: Flier {  func flockTogetherWith(_ f: Bird) {  //  }   func mateWith(_ f: Bird) {  //  } } 上面Bird结构体采用了Flier协议并将flockTogetherWith的参数声明为Bird类型。对于这个特定的采用者来说，因为Flier协议中定义的所有方法的参数类型都使用占位类型Other，因此Bird必须将mateWith方法的参数也声明为Bird类型。
  泛型函数。一个函数声明可以为它的任何参数、返回类型使用通用占位符类型。占位符名称在函数名称后面的尖括号中声明：
func takeAndReturnSameThing&amp;lt;T&amp;gt;(_ t: T) -&amp;gt; T {  debugPrint(T.self)  return t } 调用者可以在函数声明中出现占位符的某个地方使用一个特定的类型，以解析占位符的具体类型：let t = takeAndReturnSameThing(&amp;quot;howdy&amp;quot;)。在这里，调用中使用的参数&amp;quot;howdy&amp;quot;的类型将T解析为String。因此takeAndReturnSameThing的调用后也将返回一个String类型。
  泛型对象类型。一个对象类型声明可以在其花括号内的任何地方使用一个通用占位符类型。占位符名称在对象类型名称后面的尖括号中声明。
struct HolderOfTwoSameThings&amp;lt;T&amp;gt; {  var firstThing: T  var secondThing: T   init(thingOne: T, thingTwo: T) {  self.firstThing = thingOne  self.secondThing = thingTwo  } } 使用这个对象类型的用户将在对象类型声明中出现占位符的某个地方使用一个特定的类型，以解决占位符的问题。let holder = HolderOfTwoSameThings(thingOne:&amp;quot;howdy&amp;quot;, thingTwo:&amp;quot;getLost&amp;quot;)。在初始化器调用中使用的thingOne的参数&amp;quot;howdy&amp;quot;的类型将T解析为String。因此thingTwo也必须是一个String，并且属性firstThing和secondThing也是Strings。
  在泛型声明时尖括号内可以声明多个占位符以代表不同的类型，使用逗号分隔。下面定义的flockTwoTogether方法有两个占位符类型：
func flockTwoTogether&amp;lt;T, U&amp;gt;(_ f1: T, _ f2: U) {  // } 在泛型代码中，泛型占位符代表解析类型的类型引用，可以使用类型引用比较：
func takeAndReturnSameThing&amp;lt;T&amp;gt;(_ t: T) -&amp;gt; T {  // String.Type 是元类型，而T.self是元类型的值，参考自https://juejin.cn/post/6844903725199261710  if T.self is String.Type {  debugPrint(&amp;#34;T is String&amp;#34;)  }  return t } Contradictory Resolution Is Impossible 泛型在编译时就能排除与自身相矛盾的解析，这是泛型最重要的特性之一。由于Swift是强类型的，矛盾的解析是不可能的。泛型占位符必须在整个泛型中得到一致的解析，否则会编译报错。
func dogMakerAndNamer&amp;lt;WhatType: Dog&amp;gt;(_: WhatType.Type) -&amp;gt; WhatType {  let d = WhatType.init(name: &amp;#34;Fido&amp;#34;)  return d }  let d : NoisyDog = dogMakerAndNamer(Dog.self) // compile error 对于上面的代码let d : NoisyDog = dogMakerAndNamer(Dog.self)传入了参数Dog.self时WhatType会解析成类型Dog，但d声明为NoisyDog类型，会导致类型不一致，出现编译错误。
protocol Flier {  associatedtype Other  func flockTogetherWith(_ f: Other)  func mateWith(_ f: Other) } 相似的，如果采用上面Flier协议的类型在实现flockTogetherWith和mateWith方法中，使用不一致的类型时会出现编译错误Type &#39;Bird&#39; does not conform to protocol &#39;Flier&#39;：
struct Bird: Flier {  func flockTogetherWith(_ f: String) {  //  }   func mateWith(_ f: Int) {  //  } } Type Constraints 泛型声明可以限制可用于解析占位符的类型，这称为类型约束。最简单的类型约束形式是在占位符第一次出现时在它的名称后面放一个冒号和一个类型名称，冒号后的类型名可以是类名或协议名：
 如果是类名，则将泛型的具体类型限定为这个类或子类的名称。 如果是协议名，则协议名称表示该类型必须是该协议的采用者。  protocol Flier {  func fly() }  protocol Flocker {   associatedtype Other: Flier   func flockTogetherWith(f: Other) }  struct Bird: Flocker, Flier {   func fly() {  //  }   func flockTogetherWith(f: Bird) {  //  } } 上面定义的Flocker协议中的关联类型Other必须采用Flier协议。Bird是Flier的采用者，因此它也可以采用Flocker，同时指定其flockTogetherWith实现中的参数类型为Bird。
对于上面的代码，不使用关联类型，还有一种方法可以实现同样的效果。但是，还是有区别的，因为此时要求Flocker的采用者将flockTogetherWith的参数指定为Flier。然后在实现Flocker时就不得不将flockTogetherWith的类型声明为Flier：
protocol Flier {  func fly() }  protocol Flocker {  func flockTogetherWith(f: Flier) }  struct Bird: Flocker, Flier {  func fly() {  //  }   func flockTogetherWith(f: Flier) {  //  } } 而最上面定义的关联类型要求采用Flocker的类型在实现flockTogetherWith时参数f的类型也应该是采用Flocker协议的类型。
对于泛型函数或泛型对象，类型约束出现在尖括号中。前面声明的全局函数func dogMakerAndNamer就是一个例子。因为Dog是一个类，因此约束说明WhatType必须是Dog或Dog子类。下面是另一个例子，使用协议作为约束：
func flockTwoTogether&amp;lt;T: Flier&amp;gt;(_ f1: T, _ f2: T) {  // } 在这个例子中，Flier是一个协议，所以约束条件表明T必须是一个Flier的采用者。假如Bird和Insect都采用Flier，那么flockTwoTogether函数可以用两个Bird参数或两个Insect参数来调用，但不能一个是Bird另一个是Insect，因为T只是一个占位符(不是两个)，表示一个Flier采用者类型。但也不能用两个字符串参数调用flockTwoTogether，因为字符串不是Flier。
占位符上的类型约束经常被用来向编译器保证一些消息可以被发送到占位符类型的实例上。比方说，想实现一个函数myMin，从同一类型的列表中返回最小值:
func myMin&amp;lt;T:Comparable&amp;gt;(_ things: T...) -&amp;gt; T {  var minimum = things.first!   for item in things.dropFirst() {  if item &amp;lt; minimum {  minimum = item  }  }  return minimum } Explicit Specialization 到目前为止，在泛型示例中，占位符的类型主要是通过类型推断来解析的（隐式解析）。但还有另一种解析的方法：可以手动解析类型，这称为显式解析。在某些情况下，显式解析是强制性的，即若无法通过推理解析占位符类型。显示解析有两种形式：
  以占位符声明的泛型协议。协议的采用者可以通过将关联类型定义为某种类型的别名手动解析关联类型：
protocol Flier {  associatedtype Other }  struct Bird: Flier {  typealias Other = String }   泛型对象类型。使用泛型对象类型的用户可以使用与声明泛型时相同的尖括号语法手动解析占位符类型，类型名称在尖括号中：
class Dog&amp;lt;T&amp;gt; {  var name: T? } let d = Dog&amp;lt;String&amp;gt;()   不能手动显式解析泛型函数。一种解决方案是让泛型函数采用解析泛型的类型参数。这就是之前的dogMakerAndNamer示例中所做的:
func dogMakerAndNamer&amp;lt;WhatType: Dog&amp;gt;(_: WhatType.Type) -&amp;gt; WhatType {  let d = WhatType.init(name: &amp;#34;Fido&amp;#34;)  return d } dogMakerAndNamer的参数从未在函数体内使用，这就是它没有名称（只有下划线）的原因。但是，它确实用于解析泛型。
另一种方法是首先不使用泛型函数。相反，先声明一个泛型对象类型，包装一个使用泛型类型占位符的非泛型函数。泛型类型可以显式特化，解析函数中的占位符：
protocol Flier {  init() }  struct Bird: Flier {  init() {  //  } }  struct FlierMaker&amp;lt;T: Flier&amp;gt; {  static func makeFlier() -&amp;gt; T {  return T()  } } let f = FlierMaker&amp;lt;Bird&amp;gt;.makeFlier() // returns a Bird 当一个类是泛型时，可以对它进行子类化，前提是解析了泛型。可以通过匹配的泛型子类或显式解析父类泛型来执行此操作。下面是一个泛型的Dog：
class Dog&amp;lt;T&amp;gt; {  func speak(_ what: T) {  //  } } 可以将其子类化为泛型，其占位符与父类的占位符匹配：
class Dog&amp;lt;T&amp;gt; {  func speak(_ what: T) {  //  } }  class NoisyDog&amp;lt;T&amp;gt;: Dog&amp;lt;T&amp;gt; {  // } 这是合法的，因为NoisyDog占位符T的解析的同时将解析Dog占位符T。替代方法是子类化一个显式解析的Dog:
class NoisyDog: Dog&amp;lt;String&amp;gt; {  // } 在这种情况下，子类中的方法覆盖可以使用特化类型，而父类使用泛型：
class NoisyDog: Dog&amp;lt;String&amp;gt; {  override func speak(_ what: String) {  //  } } Generic Invariance 通常，专用于子类型的泛型类型相对于专用于父类型的相同泛型类型而言不是多态的。假设我们有一个简单的通用Wrapper结构以及一个Cat类及其CalicoCat子类：
class Cat {  // }  class CalicoCat: Cat {  // } 那么你不能赋值一个专门用于CalicoCat的Wrapper给一个专门用于Cat的Wrapper，下面将会出现编译错误：
let w : Wrapper&amp;lt;Cat&amp;gt; = Wrapper&amp;lt;CalicoCat&amp;gt;() // compile error 上面的代码看起来多态已经失效，但实际上不是这样的。因为Wrapper&amp;lt;Cat&amp;gt;和Wrapper&amp;lt;CalicoCat&amp;gt;两种类型不是父类和子类的关系。
相反，如果这种赋值是可行的话，我们会说这些类型是共变的，这意味着占位符的特殊化之间的多态关系被应用于泛型类型本身。某些Swift内置的泛型类型是共变的，Optional就是一个明显的例子。但是，令人沮丧的是，共变性并不是一个通用的语言特性，没有办法指定你的泛型类型应该是共变性的。
一个变通方法是将泛型占位符限制在一个协议上，并让你的类型采用该协议：
protocol Meower {  func meow() }  struct Wrapper&amp;lt;T: Meower&amp;gt; {  let meower: T }  class Cat: Meower {  func meow() {  debugPrint(&amp;#34;meow&amp;#34;)  } }  class CalicoCat: Cat {  // } 现在可以使用合法地使用let w : Wrapper&amp;lt;Cat&amp;gt; = Wrapper(meower:CalicoCat())这样的表达式，而不会出现编译错误。
Associated Type Chains 当一个泛型占位符限制为一个带有关联类型的泛型协议时，可以使用点符号来推断相关的类型：占位符的名称，一个点，和关联类型的名称。
protocol Fighter {  associatedtype Enemy: Fighter }  struct Soldier: Fighter {  typealias Enemy = Archer }  struct Archer: Fighter {  typealias Enemy = Soldier } 现在可以使用点操作符推断相关类型：
struct Camp&amp;lt;T: Fighter&amp;gt; {  var spy: T.Enemy? } 这就意味着，对于某个特定的Camp，如果T被解析为Soldier，那么T.Enemy就是Archer；如果T被解析为Archer，那么T.Enemy就是Soldier。
如果此时尝试赋值给spy给一个错误的类型，那么就会出现编译错误：Cannot assign value of type &#39;Soldier&#39; to type &#39;Soldier.Enemy?&#39; (aka &#39;Optional&amp;lt;Archer&amp;gt;&#39;)：
var c = Camp&amp;lt;Soldier&amp;gt;()  c.spy = Soldier() // compile error 一个泛型协议可能有个关联类型限制为一个有关联类型的协议。因此，可能出现长的关联类型链：
protocol Wieldable { }  struct Sword: Wieldable { }  struct Bow: Wieldable { }  protocol Fighter {  associatedtype Enemy: Fighter  associatedtype Weapon: Wieldable }  struct Soldier: Fighter {   typealias Weapon = Sword   typealias Enemy = Archer }  struct Archer: Fighter {   typealias Weapon = Bow   typealias Enemy = Soldier } </content>
    </entry>
    
     <entry>
        <title>KingFisher 使用</title>
        <url>https://iihui.github.io/post/ios-kingfisher/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  最近App联系人头像改成了url的形式，不再使用带大堆信息的post请求。因为头像涉及到缓存和更新机制，因此需要使用KingFisher组件。
 设置图片 如果想要设置UIImageView的图片，则可以使用KingFisher的扩展方法xxx.kf.setIamge。在这个方法中可以设置默认显示的图片，也可以设置是否缓存图片，获取图片下载的进度，还可以增加回调，函数原型如下所示：
// MARK:Setting Image   /// Sets an image to the image view with a `Source`.  ///  /// - Parameters:  /// - source: The `Source` object defines data information from network or a data provider.  /// - placeholder: A placeholder to show while retrieving the image from the given `resource`.  /// - options: An options set to define image setting behaviors. See `KingfisherOptionsInfo` for more.  /// - progressBlock: Called when the image downloading progress gets updated. If the response does not contain an  /// `expectedContentLength`, this block will not be called.  /// - completionHandler: Called when the image retrieved and set finished.  /// - Returns: A task represents the image downloading.  ///  /// - Note:  /// This is the easiest way to use Kingfisher to boost the image setting process from a source. Since all parameters  /// have a default value except the `source`, you can set an image from a certain URL to an image view like this:  ///  /// ```  /// // Set image from a network source.  /// let url = URL(string: &amp;#34;https://example.com/image.png&amp;#34;)!  /// imageView.kf.setImage(with: .network(url))  ///  /// // Or set image from a data provider.  /// let provider = LocalFileImageDataProvider(fileURL: fileURL)  /// imageView.kf.setImage(with: .provider(provider))  /// ```  ///  /// For both `.network` and `.provider` source, there are corresponding view extension methods. So the code  /// above is equivalent to:  ///  /// ```  /// imageView.kf.setImage(with: url)  /// imageView.kf.setImage(with: provider)  /// ```  ///  /// Internally, this method will use `KingfisherManager` to get the source.  /// Since this method will perform UI changes, you must call it from the main thread.  /// Both `progressBlock` and `completionHandler` will be also executed in the main thread.  ///  @discardableResult  public func setImage(  with source: Source?,  placeholder: Placeholder? = nil,  options: KingfisherOptionsInfo? = nil,  progressBlock: DownloadProgressBlock? = nil,  completionHandler: ((Result&amp;lt;RetrieveImageResult, KingfisherError&amp;gt;) -&amp;gt; Void)? = nil) -&amp;gt; DownloadTask?  {  let options = KingfisherParsedOptionsInfo(KingfisherManager.shared.defaultOptions &#43; (options ?? .empty))  return setImage(with: source, placeholder: placeholder, parsedOptions: options, progressBlock: progressBlock, completionHandler: completionHandler)  } 同时缓存图片 因为扩展方法setImage会改变UIImageView的图片，即是操作UI的，因此需要在主线程中进行。一般情况需要缓存已经下载好的图片，下次直接从缓存中取。如下定义的方法既设置了默认图片，也缓存了取到的图片：
private func setImage(imageView: UIImageView, urlStr: String, defaultImageName: String) {  let defaultImage = UIImage(named: defaultImageName)  guard let url = URL(string: urlStr) else {  DispatchQueue.main.safeAsync {  imageView.image = defaultImage  }  return  }  let resource = ImageResource(downloadURL: url, cacheKey: url.absoluteString)  DispatchQueue.main.safeAsync {  imageView.kf.setImage(with: resource, placeholder: defaultImage, options: [.diskCacheExpiration(.never)])  } } cell复用 在UITableViewCell或者UICollectionViewCell中使用kf.setIamge时，可能图片请求还没返回就已经滑了多屏，也就是说cell开始复用了，解决这个问题是在即将复用的时候取消网络请求：
override func prepareForReuse() {  super.prepareForReuse()  self.imgView.kf.cancelDownloadTask() } 鉴权信息 有时候服务端为了防盗，需要请求方提供一些鉴权信息，此时需要使用KingFisher提供的AnyModifier，在request中增加需要的信息即可：
private func setImage(imageView: UIImageView, urlStr: String, defaultImageName: String) {  let defaultImage = UIImage(named: defaultImageName)  guard let url = URL(string: urlStr) else {  DispatchQueue.main.safeAsync {  imageView.image = defaultImage  }  return  }  let modifier = AnyModifier { request in  var r = request  r.setValue(&amp;#34;abc&amp;#34;, forHTTPHeaderField: &amp;#34;Access-Token&amp;#34;)  return r  }  let resource = ImageResource(downloadURL: url, cacheKey: url.absoluteString)  DispatchQueue.main.safeAsync {  imageView.kf.setImage(with: resource, placeholder: defaultImage, options: [.requestModifier(modifier), .diskCacheExpiration(.never)])  } } 获取图片 综合获取 使用KingfisherManager.shared.retrieveImage可以获取图片。获取规则：先从缓存中获取，如果缓存中没有对应的图片，则走网络获取图片，从网络获取到图片之后将会缓存该图片：
private func getImage(urlStr: String, completion: @escaping (UIImage?) -&amp;gt; Void) {  guard let url = URL(string: urlStr) else {  completion(nil)  return  }  let resource = ImageResource(downloadURL: url, cacheKey: url.absoluteString)  KingfisherManager.shared.retrieveImage(with: resource) { result in  switch result {  case .success(let value):  completion(value.image)  case .failure(let error):  debugPrint(error.localizedDescription)  completion(nil)  }  } } 缓存中获取 也可以直接从缓存中获取图片，而不走网络；如果是默认缓存，则只要调用ImageCache.default.retrieveImage方法，并传入先前的cacheKey：
private func getImageFromCache(cacheKey: String, completion: @escaping (UIImage?) -&amp;gt; Void) {  ImageCache.default.retrieveImage(forKey: cacheKey) { result in  switch result {  case .success(let value):  completion(value.image)  case .failure(let error):  debugPrint(error.localizedDescription)  completion(nil)  }  } } 网络获取 也可以直接从网络中获取图片，而不从缓存中获取。只要调用ImageDownloader.default的downloadImage方法：
private func getImageFromNetwork(urlStr:String, completion: @escaping (UIImage?) -&amp;gt; Void) {  guard let url = URL(string: urlStr) else {  completion(nil)  return  }  ImageDownloader.default.downloadImage(with: url ) { result in  switch result {  case .success(let value):  completion(value.image)  case .failure(let error):  debugPrint(error.localizedDescription)  completion(nil)  }  } } 如果服务端为了防盗，需要请求方提供一些鉴权信息，此时需要使用KingFisher提供的AnyModifier，在request中增加需要的信息即可：
private func getImageFromNetwork(urlStr: String, completion: @escaping (UIImage?) -&amp;gt; Void) {  guard let url = URL(string: urlStr) else {  completion(nil)  return  }  let modifier = AnyModifier { request in  var r = request  r.setValue(&amp;#34;abc&amp;#34;, forHTTPHeaderField: &amp;#34;Access-Token&amp;#34;)  return r  }  ImageDownloader.default.downloadImage(with: url, options: [.requestModifier(modifier)]) { result in  switch result {  case .success(let value):  completion(value.image)  case .failure(let error):  debugPrint(error.localizedDescription)  completion(nil)  }  } } 预先取图片 如果预先知道待显示的图片，则可以预先获取图片，使用ImagePrefetcher可以批量获取，如下所示，可以在回调中查看哪些图片已经获取到，传入的参数既可以是URL数组，也可以是ImageResource数组:
private func preFetchImage(urlStrings: [String]) {  let urls = urlStrings.compactMap({ URL(string: $0) })  let prefetcher = ImagePrefetcher(urls: urls) {  skippedResources, failedResources, completedResources in  debugPrint(&amp;#34;These resources are prefetched: \(completedResources)&amp;#34;)  }  prefetcher.start() }  private func preFetchImages(urlStrings: [String]) {  let resources = urlStrings.compactMap({ URL(string: $0) }).compactMap({ ImageResource(downloadURL: $0, cacheKey: $0.absoluteString) })  let prefetcher = ImagePrefetcher(resources: resources) {  skippedResources, failedResources, completedResources in  debugPrint(&amp;#34;These resources are prefetched: \(completedResources)&amp;#34;)  }  prefetcher.start() } 缓存设置 KingFisher提供了缓存图片张数和存储大小的设置接口，在设置的时候区分了内存和磁盘缓存。内存中图片张数由countLimit确定，存储大小由totalCostLimt确定。磁盘缓存中只能设置存储大小，由sizeLimit确定。
内存缓存设置 下面的代码设置内存缓存最多300张图片，占用内存大小最多为300M。默认情况下内存中的图片五分钟后过期，在下面的设置中设置为不过期。
// 限制内存最多300张图片 ImageCache.default.memoryStorage.config.countLimit = 300 // 限制内存大小为300M ImageCache.default.memoryStorage.config.totalCostLimit = 300 * 1024 * 1024 // 内存中图片过期时间设置 ImageCache.default.memoryStorage.config.expiration = .never 磁盘缓存设置 磁盘缓存和内存缓存有一些区别，大小是由sizeLimit确定，默认情况下磁盘缓存中的图片一星期后过期，在下面的设置中设置为不过期：
// 限制磁盘缓存大小为300M ImageCache.default.diskStorage.config.sizeLimit = 300 * 1024 * 1024 // 磁盘缓存中图片过期时间设置 ImageCache.default.diskStorage.config.expiration = .never 手动保存 默认情况下，KingFisher提供的视图的扩展方法和KingfisherManager会在取图片的时候自动缓存，也可以手动缓存图片，如下所示即可以只保存在磁盘中，也可以同时缓存在内存和磁盘中：
private func storeImage(data: Data, cacheKey: String) {  ImageCache.default.storeToDisk(data, forKey: cacheKey)  if let image = UIImage(data: data) {  ImageCache.default.store(image, forKey: cacheKey)  } } 如果有图片的原始数据，也可以传递给KingFisher，这样可以帮助KingFisher确定图片应该以哪种方式保存，如下所示：
private func storeImage(data: Data, cacheKey: String) {  ImageCache.default.storeToDisk(data, forKey: cacheKey)  if let image = UIImage(data: data) {  ImageCache.default.store(image, original: data, forKey: cacheKey)  } } 手动删除 除了手动保存，也提供了手动删除缓存的方法，直接调用removeImage(forKey: cacheKey)即可根据cacheKey删除缓存：
ImageCache.default.default.removeImage(forKey: cacheKey) 也可以进行选择性的全部删除，即可以选择删除所有内存或者磁盘的缓存，或者选择只删除已经过期的内存或者磁盘中的缓存，如下所示：
private func clean() {  // 清理内存缓存  ImageCache.default.clearMemoryCache()  // 清理磁盘缓存  ImageCache.default.clearDiskCache()  // 清理内存和磁盘缓存  ImageCache.default.clearCache()  // 清理内存过期缓存  ImageCache.default.cleanExpiredMemoryCache()  // 清理磁盘过期缓存  ImageCache.default.cleanExpiredDiskCache()  // 清理内存和磁盘过期缓存  ImageCache.default.cleanExpiredCache() } 参考资料
扩展缓存和默认图片 使用KingFisher时，有时既需要设置缓存又需要默认图片，但每次都去定义ImageResource，稍微有点烦复，下面是在UIImageView中扩展出一个满足该需求的函数：
extension UIImageView {  /// 使用KingFisher设置imageView的图片  /// - Parameters:  /// - urlStr: 图片url  /// - defaultImageName: 默认图片名字，若没有可以传空字符串  func setImage(urlStr: String, defaultImageName: String) {  let defaultImage = defaultImageName.isEmpty ? nil : UIImage(named: defaultImageName)  guard let url = URL(string: urlStr) else {  if let image = defaultImage {  self.image = image  }  return  }  let source = ImageResource(downloadURL: url, cacheKey: url.absoluteString)  self.kf.setImage(with: source, placeholder: defaultImage)  } } </content>
    </entry>
    
     <entry>
        <title>使用Leaks内存检测</title>
        <url>https://iihui.github.io/post/ios-leaks/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  最近有用户反馈App出现了闪退现象，但后台并未发现有崩溃日志上传，猜测发生了内存溢出，导致App直接被系统杀掉而没有崩溃日志产生。为了验证此猜测，需要使用XCode的Leaks工具，这篇文章简单介绍使用Leaks的步骤。
 Setting 首先在XCode的菜单栏中找到Product，然后查看子菜单中的Profile是否为灰色如下图所示，若Profile为灰色，则表示该功能不能使用，需要做一些额外的设置。
设置Profile，首先需要单击选中当前target，然后在弹出框中选择Edit Scheme... 才可以修改Profile，让其变成可用，点击如下图所示箭头：
接着选中Profile，在Build Configuration一栏的右侧选中Debug，并在Executable一栏选中要调试的App，最后点击close即可完成设置，如下图所示：
Instruments 设置完成后，便可在菜单栏的Product目录下看到Profile变成可用的白色，此时选中Profile便可唤出Instrucments面板，然后再选中Leaks:
Allocations 上一步选中Leaks后，会打开Leaks面板，点击左上角的红色圆圈按钮就可以进行内存检测。在下图上半部分选中Allocations这一行，即可查看内存分配情况：
Leaks 如果在运行过程中，面板中上半部分的Leaks栏中出现红色x，则说明有内存泄漏。此时，鼠标点击Leaks这一行，便可看到内存泄漏的具体信息：
调用栈信息 默认情况下，Leaks显示的是Leaks by Backtrace。如果要定位内存泄漏代码，则需要先选择Call Tree，设置如下图所示：
然后选择底部的Call Tree，在弹窗中再选中Invert Call Tree和Hide System Libraries，即可显示出具体内存泄漏的代码：
假如还是不能显示内存泄漏的代码，则需要在Build Setting中搜索debug，然后在Debug Information Format中的debug或release行选中DWAARF with dSYM File，如下图所示：
下面三个图中第一个是没有设置DWARF with dSYM File的结果，即不能显示具体的调用信息；第二和第三个是设置了DWARF with dSYM File后的结果，能显示具体的调用信息，如果要查看某个时间段的内存泄漏，需要按住鼠标左键，然后拖动使得要查看的内存泄漏的x在范围内：
内存引用 如果想要查看内存泄漏引用图，则需要将Call Tree选项改为Cycles &amp;amp; Roots，但不是所有的都可以查看，效果如下图所示：
参考资料
</content>
    </entry>
    
     <entry>
        <title>视图</title>
        <url>https://iihui.github.io/post/ios-views/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  视图view的层次结构是其组织的主要模式。一个视图可以有多个子视图，但只能有一个直接父视图。若一个视图被从界面中被移除，则它的子视图也会被移除；若一个视图被隐藏，则它的子视图都会被隐藏；如果一个视图被移动，它的子视图也都会随之移动。也就是说，一个视图的变化会作用到它的子视图中。
 UIView是UIResponder的子类，即它不仅是用户能看到的界面，也是用户交互所用界面。也就是说视图的层次结构也是响应者链的基础，但它与响应者链不完全相同。
一个视图的创建可能来自nib，也可能来自代码。不能绝对地说哪种方式更好一些，这取决于个人需求和程序的整体架构。
window 和 root View 视图层级结构的最顶层是window。window为UIWindow或UIWindow子类的实例，其中UIWindow也是UIView的一个子类。
在App启动时会创建和显示一个window，否则只会看到一片黑色。从iOS 13开始，App可在iPad上支持多个window；如果你的App在iPad上不支持多window或在iPhone上运行，则只有一个window，即the main window。
一个可见的window构成了所有其他可见view的背景，也是所有可见视图的父视图。一个view如果是可见的，那么它一定是某个可见window的子视图。
在实际编程中，一般不会手动或者直接用子视图来填充window，因为window和它所包含的视图之间的连接是根视图控制器，即其rootViewController属性。
一旦一个ViewController被实例化，并且赋值给window的rootViewController属性，则此ViewController的主视图（即view属性），将会填充整个window，这个主视图也将是window的唯一直接子视图。其他所有可见的视图在一定深度上都是rootViewController主视图的某个子视图。
window scene architecture 从iOS 13开始App的window默认由UIWindowScene来提供，这与iOS 12及之前的版本相比，是架构上最大的变化：
  在iOS 12及以前，是基于window的架构，window是AppDelegate的一个属性。如果项目是在XCode 10或者之前创建的，则默认使用这种老架构。
  在iOS 13及以后，是基于scene的架构，window是SceneDelegate的一个属性。如果项目是在XCode 11或之后创建的，则默认使用的是这种新架构。
  使用老window架构的App，如果在iOS 13及以后的版本中运行时，它会被赋予一个UIWindowScene，但是它不知道这个事实，并且功能不受影响，仍然运行在老架构上。但是，新window架构的App不能运行在iOS 12及以前的系统。
如果需要新架构的App支持iOS 12以之前的系统，则需要将SceneDelegate的window属性复制到AppDelegate类中。然后在AppDelegate类中将所有涉及UISceneSession的方法标记为@available(iOS 13.0, *)。最后在SceneDelegate类前将整个类标记为@available(iOS 13.0, *)即可。
进行如上的改动后，如果App运行在iOS 13及以后的系统中，则使用的是新架构，并且SceneDelegate持有window。如果在iOS 12及以前的系统中，则使用的是旧架构，AppDelegate持有window。
如果想要在XCode 11以上创建的工程使用旧window架构，则需要先删除所有UISceneSession和SceneDelegate相关的代码，然后在info.plist中删除Application Scene Manifest入口，最后在AppDelegate中手动添加var window: UIWindow?即可。
App Launches 在启动时，应用程序如何初始化window，以及该window如何被填充和显示？如果应用使用main storyboard，window的初始化和显示都会自动完成。但是，「自动」并不意味着「通过魔术」。
应用的启动时的程序是直接和确定的，我们的代码可以在其中起作用。知道一个应用程序是如何启动的是非常有用的，尤其是当配置错误，应用程序的启动出现问题时，就可以找出原因了。
App启动时最终包括一次UIApplicationMain函数的调用。与OC不同，一个典型的Swift项目不会在代码中明确地进行这一调用，都是自动完成调用的。UIApplicationMain函数的调用创建了一些最重要的初始实例；如果你的应用程序使用main storyboard，则这些实例包括window和它的根视图控制器。
UIApplicationMain的处理是如何进行的，取决于你的应用程序是使用旧的window架构还是新的window架构，它们将会是两种完全不同的启动过程。
新架构 以下是UIApplicationMain如何在iOS 13及更高版本上启动支持window scene的应用程序:
  UIAppplicationMain首先实例化UIApplication，并保留这个实例，将其作为共享的实例，可以在代码中可以使用UIApplication.shared来访问。接着根据@UIApplicationMain或@main来实例化AppDelegate，并保留这个实例，使得它在应用程序中的整个生命周期中都存在，可以使用UIApplication.shared.delegate来访问。
  接着UIApplicationMain会调用AppDelegate的application(_:didFinishLaunchingWithOptions:)方法，在这个方法中可以插入我们自己的代码。
  然后UIAppplicationMain创建UISceneSession和UIWindowScene以及UIWindwScene代理类UIWindowSceneDelegate的实例。   UIAppplicationMain查看初始scene是否使用了storyboard，即查看info.plist中Application Scene Manifest字典下的Scene Configuration是否有Storyboard Name。若有，则对storybaord中指定的初始viewController进行实例化。
  如果scene使用了storyboard，UIAppplicationMain则会实例化一个UIWindow并将这个实例赋值给SceneDelegate的window属性。
  如果scene使用了storyboard，则将storyboard中那个已经实例化的初始ViewController赋值给上一步已经实例化window的rootViewController属性。此时，初始ViewController的view变成了Window的唯一子视图。
  UIApplicationMain通过调用UIWindow实例方法makeKeyAndVisible，使你的应用程序的界面出现。
  scene的(_:willConnectTo:options:)被调用，在这个方法中也可以插入自己的代码。
  如果App启动时未使用storyboard，也就是说在老的架构中Info.plist中没有Main storyboard file base name条目。而在新的架构中，这意味着在Application Scene Manifest字典的Application Scene Configuration下没有Storyboard Name条目。
此时需要在代码中完成有storyboard的情况下自动完成的所有事情。在旧的架构下，需要在app delegate的application(_:didFinishLaunchingWithOptions:)中做这些事情。
而在新的架构下，需要在SceneDelegate中的scene（_:willConnectTo:options:）方法做下面这些事情:
  创建一个UIWindow的实例，并且将其赋值给SceneDelegate的window属性。通过调用UIWindow的初始化方法init(windowScene:)使得window和window scene来建立连接。
  初始化一个视图控制器，并根据需要对其进行设置。
  将上一步实例化的视图控制器赋值给window的rootViewController属性。
  调用window的makeKeyAndVisible进行显示。
  引用window 一旦app运行，有多种方法引用window：➊从视图中引用；➋从SceneDelegate中引用；➌从application中引用。
view 如果一个视图在界面中，则该视图能通过自己的window属性引用到包含它的window。你的代码可能会在一个有main view的视图控制器中运行，此时self.view.window是引用window的最佳方式。
也可以使用UIView的window属性来询问它是否最终被嵌入到window中。如果未嵌入到window中，则它的window属性为nil。一个window属性为nil的视图是对用户不可见的。
sceneDelegate 或appDelegate SceneDelegate实例保存了window的引用，可以通过window属性来访问。即使用sceneDelegate.window来访问。但访问sceneDelegate需要先使用let sceneDelegate = UIApplication.shared.connectedScenes.first?.delegate as? SceneDelegate来获取。
如果使用的是旧window架构，则需要使用AppDelegate来访问，即 UIApplication.shared.delegate?.window。
application 共享的application实例也保存了window的引用，可以通过其window属性来访问，即let w = UIApplication.shared.windows.first!。
subview and superview 在以前，一个视图恰好拥有自己的矩形区域，即任何不属于该视图的子视图的视图都不能出现在该视图的里面。因为当该视图重新绘制其矩形区域时，它会擦除其他视图的重叠部分。视图的子视图的任何部分都不能出现在它的外面，因为该视图对它自己的矩形区域负责，而不是其他。
从macOS 10.5开始，Apple为视图绘制引入了一个全新的架构，完全解除了上面的所说的那些限制。在iOS中，一个子视图的部分或全部可以出现在它的父视图之外，一个视图可以与另一个视图重叠，可以部分或全部画在它的前面，而不成为它的子视图。
如下图所示，有3个不同背景色的视图，每个视图和其他视图都有重叠。仅从视觉效果上是无法了解视图的层次结构的：
一个视图在视图层次结构中的位置是非常重要的。首先，视图的层次结构决定了视图的绘制顺序。同一父视图的同级子视图有明确的绘制顺序：较早的同级子视图画在较晚的同级子视图之前，所以如果它们重叠，较早的子视图会出现在较晚的子视图后面。同样地，一个父视图被画在它的子视图之前，所以如果子视图与它们的父视图重叠，父视图就会出现在它们后面。
如果是在storyboard中创建的视图或者nib，则视图的层级结构可以通过菜单栏的Editor--&amp;gt;Arrange下面的子选项来改变：
  如果一个视图从它的父视图中移除，则它的所有子视图也会被移除
  一个视图的透明度会被它的子视图所继承。
  视图可以选择性地限制其子视图的绘制，使其在视图之外的任何部分都不被显示，这就是所谓的剪裁，可以通过视图的clipsToBounds属性来设置。
  在内存管理的意义上，父视图拥有它的子视图，就像一个数组拥有它的元素一样：它保留它的子视图，并且当一个子视图从这个视图的子视图集合中移除时，或者当父级视图本身不存在时，才会释放该子视图。
  如果一个视图的大小改变了，它的子视图也可能会自动调整大小。
  每个视图均有superview和subviews属性，使用这两个属性可以追踪视图的层次结构。使用视图的isDescendant(of:)方法可以判断一个视图是否是另一个视图的子视图（任意深度）。
如果想要引用特定的某个视图，可能需要为视图事先安排一个标记，可以是outlet；也可以为视图事先设置tag属性值，然后通过调用viewWithTag(_:)来获取该特定的视图。
视图的添加、删除和移动等都有相应的事件，这些事件的响应需要子类化。然后通过覆盖如下的方法便可以看到对应的调用：
willRemoveSubview(_:) didAddSubview(_:) willMove(toSuperview:) didMoveToSuperview willMove(toWindow:) didMoveToWindow 如果addSubview(_:)被调用，则视图将放在父视图的所有子视图的最后边「即最上边」，也就是最后才绘制，这意味着它将出现在最前面。
视图的子视图是有索引的，从0开始。可以在给定的索引或特定视图的下面（后面）或上面（前面）插入一个子视图；也可以通过索引交换两个同级视图；还可以将一个子视图一直移动到其同级的前面或后面。
insertSubview(_:at:) insertSubview(_:belowSubview:) insertSubview(_:aboveSubview:) exchangeSubview(at:withSubviewAt:) bringSubviewToFront(_:) sendSubviewToBack(_:) 但是，没有提供一次性删除一个视图的所有子视图的方法。一个视图的子视图数组是内部子视图列表的一个不可变的副本。因此，需要使用for循环来删除所有子视图：
myView.subviews.forEach {$0.removeFromSuperview()} color 视图可以通过其backgroundColor属性设置一个背景色，如果backgroundColor属性值为nil，则视图的背景色为透明。backgroundColor即是UIColor的实例，通常使用red,blue,green和alpha（其值为0~1）来定义：
v.backgroundColor = UIColor(red: 0, green: 0.1, blue: 0.1, alpha: 1) 自iOS 13开始出现了深色模式，为了适配需要使用动态颜色，即使用UIColor的初始化函数init(dynamicProvider:)来进行适配，下面是创建一个自定义的动态颜色：
v1.backgroundColor = UIColor { tc in  switch tc.userInterfaceStyle {  case .dark:  return UIColor(red: 0.3, green: 0.4, blue: 0.4, alpha: 1)  case .light:  return UIColor(red: 0, green: 0.1, blue: 0.1, alpha: 1)  } } 从iOS 13开始，系统提供了许多预置的动态颜色，其中大部分的名称都是以.system开头的，比如.systemYellow，其它的则是描述其作用的语义名称，比如.label。
现在可以在资产目录中设计一个自定义命名的颜色。当创建一个新的颜色集时，属性检查器中的 「外观」弹出菜单显示为「任意」、「暗色」，并且有两个颜色色块，一个用于深色模式，另一个用于其它一切；依次选择每个色块并在属性检查器中设计颜色：
上面自定义命名的颜色，就是动态的。比方说，我们在资产目录中的颜色集被称为myDarkColor，那么可以使用如下方式使用:
v.backgroundColor = UIColor(named: &amp;#34;myDarkColor&amp;#34;) 当你选择一个视图时，资产目录中的自定义命名颜色也会出现在库中和属性检查器中的颜色弹出菜单中，如下图所示：
可见性和透明度 视图的可见性和不透明度与3个属性相关，它们分别是isHidden，alpha和isOpaque，下面开始逐个介绍。
isHidden 视图可以通过将isHidden属性设置为true而变得不可见，并通过将其设置为false 而再次变成可见，因为隐藏视图并不会导致该视图从其层级结构中删除。被隐藏的视图（通常）不会收到触摸事件，所以对用户来说，就如同该视图不存在一样。
alpha 一个视图可以通过其alpha属性使其部分或完全透明。alpha属性的取值可以在0～1.0，1.0表示完全不透明，0.0表示完全透明。alpha属性既能影响视图的背景色也会影响其内容的透明度。
如果一个视图中显示了一个图像，并且有一个背景颜色，而它的alpha值小于1.0，那么背景颜色就会渗入到这个图像中。
如果一个父视图的alpha值为0.5，则它的所有子视图的alpha都将小于0.5，因为无论这些子视图的alpha属性值是多少，都是相对于父视图的0.5来进行绘制的。
一个完全透明（或非常接近完全透明）的视图就像一个isHidden为true的视图：它和它的子视图都是不可见的，而且（通常）不能被触摸到。
颜色也有一个alpha属性，这个值对于视图也有影响。一个视图的alpha值可以是1.0，但仍然可能有一个透明的背景色，因为它的背景颜色的alpha值可能小于1.0。
isOpaque isOpaque属性不同于isHidden和alpha，改变isOpaque属性值对视图的外观没有影响，只是对视图系统的绘制提示。
如果一个视图完全由不透明的物质填充并且它的alpha属性设置为1.0，那么视图就是完全不透明的，此时如果将视图的isOpaque属性设置为true，就可以更有效地进行绘制（对性能的拖累更小），否则应当将isOpaque设置为false。
当设置isHidden和alpha的值时，isOpaque属性值并不会跟着变化。isOpaque属性值的设置完全取决你自己，它的默认值为true。
Frame 每个view都有frame属性（是一个由CGRect表示的矩形，表示在父视图的坐标系统中的位置。默认情况下，父视图的坐标系将以左上角为原点，X坐标向右正向增长，Y坐标向下正向增长。
设置视图的frame值既可以重新改变视图的位置，也可以调整视图的大小，或者同时改变位置和大小。UIView的指定初始化方法是init(frame:)，可以通过这种方式指定视图的frame。若视图的frame属性值为CGRect.zero的话，则视图是不可见。
如果一个视图有一个你希望它采用的标准尺寸，特别是相对于它的内容（例如UIButton相对于它的标题）而言，除了改变frame，还可以调用其sizeToFit方法。
如果一个视图使用nib进行初始化，那么不会调用其init(frame:)，调用的为init(coder:)方法。
Bounds and Center Bounds 如下图所示，假设有一个父视图和子视图，子视图需要有10个point的镶边，首先想到的是设置子视图的frame，但该怎么设置？
CGRect有个insetBy(dx:dy:)方法可以从一个矩形中衍生出另一个矩形并嵌入。但是应该从哪个矩形中嵌入呢？不是从父视图的frame，因为frame代表一个视图在其父视图中的位置，并且是父视图的坐标系中的位置。
应当找一个用来描述在其自身坐标中与父视图矩形相关的CGRect，因为这是子视图的frame所要表达的坐标。描述视图在其自身坐标中的矩形CGRect是视图的bounds属性。
let v1 = UIView(frame:CGRect(113, 111, 132, 194)) v1.backgroundColor = UIColor(red: 1, green: 0.4, blue: 1, alpha: 1) let v2 = UIView(frame:v1.bounds.insetBy(dx: 10, dy: 10)) v2.backgroundColor = UIColor(red: 0.5, green: 1, blue: 0, alpha: 1) self.view.addSubview(v1) v1.addSubview(v2) 如果改变一个视图的bounds的size，那么它的frame也会发生变化。视图的frame的变化是围绕其center来的&amp;mdash;中心点不变。下面的代码只出现一个矩形，子视图完全覆盖父视图：
let v1 = UIView(frame:CGRect(113, 111, 132, 194)) v1.backgroundColor = UIColor(red: 1, green: 0.4, blue: 1, alpha: 1) let v2 = UIView(frame:v1.bounds.insetBy(dx: 10, dy: 10)) v2.backgroundColor = UIColor(red: 0.5, green: 1, blue: 0, alpha: 1) self.view.addSubview(v1) v1.addSubview(v2) v2.bounds.size.height &#43;= 20 v2.bounds.size.width &#43;= 20 如果改变一个视图的bounds原点，就会移动其内部坐标系的原点。当创建一个UIView时，它的边界坐标系的原点(0.0,0.0)就在它的左上方。因为一个子视图是相对于它的父视图的坐标系定位的，所以父视图的边界原点的改变也会改变子视图的显示位置，如下代码会导致父视图的大小和位置没有发生任何变化，但是子视图已经向左上角移动了：
let v1 = UIView(frame:CGRect(113, 111, 132, 194)) v1.backgroundColor = UIColor(red: 1, green: 0.4, blue: 1, alpha: 1) let v2 = UIView(frame:v1.bounds.insetBy(dx: 10, dy: 10)) v2.backgroundColor = UIColor(red: 0.5, green: 1, blue: 0, alpha: 1) self.view.addSubview(v1) v1.addSubview(v2) v1.bounds.origin.x &#43;= 10 v1.bounds.origin.y &#43;= 10 center 同样地，若改变一个视图的frame属性的size值，也会改变其bounds属性的size值。但是，改变bounds的size大小时，不会改变其center属性。
center代表子视图在父视图坐标系中的位置，确切地说，它表示子视图的bounds center在父视图中的位置：
let c = CGPoint(theView.bounds.midX, theView.bounds.midY) 改变视图的bounds不会改变的它的center，相应地改变视图的center不会改变bounds。即视图的center和bounds是相互独立的。bounds用于描述视图的大小，center用于描述视图在父视图中的位置。
实际上视图的frame属性是bounds和center的简便形式。当改变视图的frame属性时，bounds和center也会随之发生变化，当改变bounds和center时，视图的frame也会随之发生改变。尽管如此，调整一个视图在父视图中的可靠方式是使用bounds和center属性。
每个视图都有自己的坐标系统（使用bounds来表达），并且一个视图坐标系统的与它的父视图的坐标系统有一个明确的关系，即center属性。因此，可以在同一窗口中的任何两个视图的坐标之间进行转换：
open func convert(_ point: CGPoint, to view: UIView?) -&amp;gt; CGPoint open func convert(_ point: CGPoint, from view: UIView?) -&amp;gt; CGPoint open func convert(_ rect: CGRect, to view: UIView?) -&amp;gt; CGRect open func convert(_ rect: CGRect, from view: UIView?) -&amp;gt; CGRect 在convert方法中，第一个参数既可以是CGPoint也可以是CGRect，第二个参数是UIView，如果第二个参数为nil，则会认为是window。下面的例子是将v2放到v1的中心：
v2.center = v1.convert(v1.center, from:v1.superview) 另外一种更常见的方式是将子视图的中心放在父视图bounds的中心位置，如下所示：
v2.center = CGPoint(v1.bounds.midX,v1.bounds.midY) transform transform 视图的transform属性可以改变视图的绘制方式，显示大小，位置和方向，但不会改变bounds和center属性。transform属性值是一个CGAffineTransform结构体，代表代表3×3变换矩阵9个值中的6个（另外3个值是常数，所以没有必要在结构中表示它们）：
public struct CGAffineTransform {   public var a: CGFloat   public var b: CGFloat   public var c: CGFloat   public var d: CGFloat   public var tx: CGFloat   public var ty: CGFloat   public init()   public init(a: CGFloat, b: CGFloat, c: CGFloat, d: CGFloat, tx: CGFloat, ty: CGFloat) } 默认情况下，一个视图的变换矩阵是CGAffineTransform.identity，即同一变换，它没有可见的效果，所以你不知道它的存在。任何变换都是围绕视图的中心进行的，这个中心点一定是保持不变的。
let v1 = UIView(frame:CGRect(113, 111, 132, 194)) v1.backgroundColor = UIColor(red: 1, green: 0.4, blue: 1, alpha: 1) let v2 = UIView(frame:v1.bounds.insetBy(dx: 10, dy: 10)) v2.backgroundColor = UIColor(red: 0.5, green: 1, blue: 0, alpha: 1) self.view.addSubview(v1) v1.addSubview(v2) v1.transform = CGAffineTransform(rotationAngle: 45 * .pi/180) print(v1.frame) transform3D 从iOS 13开始，视图有一个新的transform3D属性。这个属性其实是底层layer的transform属性，现在通过视图暴露出来了。
Window坐标和屏幕座标 设备的屏幕没有frame，但有bounds。window没有父视图，但是它的frame是自动和设备屏幕的bounds相匹配的。window一般一开始就填满屏幕，并且通常会继续填满屏幕，因此大多数情况下，窗口坐标就是屏幕坐标。
在iOS 7及之前，屏幕坐标是不变的，transform属性是应用旋转能力的核心：因为window的frame和bounds被锁定在屏幕上，应用的界面通过对根视图应用旋转变换来补偿设备方向的变化，从而使其原点移动到用户现在看到的视图的左上方。
但iOS 8引入了一个重大变化：当应用程序旋转以补偿设备的旋转时，屏幕（以及随之而来的窗口）是旋转的。当应用程序的界面旋转时，故事中的任何视图&amp;ndash;无论是窗口、根视图还是其任何子视图&amp;ndash;都没有收到旋转变换。取而代之的是屏幕边界尺寸的换位（以及窗口边界和根视图边界尺寸的相应换位）：在纵向方向上，尺寸是高过宽，但在横向方向上，尺寸是宽过高。
Trait Collections 由于视图所处的大环境具有动态性质。如果有一个描述环境的对象，它可以通过视图控制器和视图的层次结构向下传播，同时也可以提醒该层次结构中的每个元素环境已经改变，是非常有用的。实际上，这是通过trait collection来管理的。
trait collection源于屏幕（即UIScreen），并通过window和视图控制器一路向下，直到每个单独的子视图。所有相关的类（UIScreen、UIViewController和UIPresentationController以及UIView）都实现了UITraitEnvironment协议，它提供了traitCollection属性和traitCollectionDidChange方法。
traitCollection是UITraitCollection类型，属于值类型，它带有相当数量的描述环境的属性。例如，displayScale能告诉你屏幕分辨率，userInterfaceIdiom说明设备类型&amp;ndash;iPhone或iPad，它还能报告诸如设备的强制触摸能力和显示色域等等。
当app运行时，如果traitCollection的任何属性发生变化，traitCollectionDidChange(_:)消息就会在UITraitEnvironments的层次结构中传播，旧的特性集合（如果有的话）被作为参数提供，新的特性集合可以作为self.traitCollection被检索。
如果要实现traitCollectionDidChange(_:)方法，首先应该调用super的方法，对于一个初学者来说，很容易忘记调用对应的super方法：
override func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) {  super.traitCollectionDidChange(previousTraitCollection) } 我们也可以构造自己的traitCollection，但不能直接设置任何traitCollection的属性值。可以通过init方法构造一个traitCollection，但是初始化器每次只能确定一个属性。如果想进一步增加属性值，可以通过调用init(traitsFrom:)初始化器，将一个traitCollection数组传入以组合成新的traitCollection，如下所示：
let tcdisp = UITraitCollection(displayScale: UIScreen.main.scale) let tcphone = UITraitCollection(userInterfaceIdiom: .phone) let tc1 = UITraitCollection(traitsFrom: [tcdisp, tcphone]) 初始化器init(traitsFrom:)中数组的工作方式与继承类似——进行有序的交叉。如果两个traitCollection被合并，并且它们都设置了相同的属性，那么获胜者是出现在数组后面或继承层次结构中更远的traitCollection。如果一个设置了一个属性，而另一个没有，那么设置该属性的那个就获胜。如果你创建了一个traitCollection，如果traitCollection在继承层次中，任何未指定的属性的值都将被继承。
如果需要比较traitCollection，可以调用containsTraits(in:)方法。如果参数traitCollection的每个属性的值与待比较的traitCollection中的属性值相匹配，则返回true。
对于UIViews来说，主要关注的traitCollection属性是是interface style和size class，所以接下来将会介绍这两者。
Interface Style 使用trait collection中的属性值userInterfaceStyle来报告大环境是light模式还是dark模式。如果界面上使用的颜色是动态颜色，切换userInterfaceStyle时，则界面会自动更改颜色。
然而，在某些情况下，你可能会手动管理一些颜色，你会想知道什么时候userInterfaceStyle发生了变化，这样就可以改变颜色作为回应。
假如我们要把资产目录中一个自定义的动态颜色应用到视图的borader上。这实际上是在视图的layer上完成的，要求我们使用该颜色的cgColor属性:
self.otherView.layer.borderWidth = 4 self.otherView.layer.borderColor = UIColor(named: &amp;#34;myDarkColor&amp;#34;)?.cgColor 上面代码的问题是，无论是layer上还是颜色的cgColor都不知道任何关于trait collection的信息。所以这就需要我们监听trait collection的变化，并在知道userInterfaceStyle发生变化后再次使用我们的动态颜色。多亏了trait collection的hasDifferentColorAppearance方法，可以避免做不必要的工作：
override func traitCollectionDidChange(_ prevtc: UITraitCollection?) {  super.traitCollectionDidChange(prevtc)  if prevtc?.hasDifferentColorAppearance(comparedTo: traitCollection) ?? true {  otherView.layer.borderColor = UIColor(named: &amp;#34;myDarkColor&amp;#34;)?.cgColor  } } 请注意，在上面的代码中不必知道userInterfaceStyle目前到底取什么值，只需要把动态颜色的cgColor取出来使用即可。这是因为从asset目录中UIColor(named: &amp;quot;myDarkColor&amp;quot;)访问动态颜色的行为是在先访问一个全局值UITraitCollection.current的情况下发生的。
在traitCollectionDidChange方法中和其他各种运行时正在绘制或执行布局的地方，这个值为我们自动设置，因此我们的动态颜色会在userInterfaceStyle变动时正确的取到，同时cgColor也能取到正确的值。在UITraitCollection.current没有被自动设置的情况下，我们可以自由地手动设置它，确保涉及动态颜色的后续操作将在正确的环境中进行。
同时，trait collection也是理解一个动态颜色到底是什么颜色的关键。.systemYellow是什么颜色？这取决于trait collection。所以要想知道动态颜色目前到底是怎么值，必须提供一个trait collection。这很容易，因为你可以创建一个trait collection，之后再调用 resolvedColor即可:
let yellow = UIColor.systemYellow let light = UITraitCollection(userInterfaceStyle: .light) let dark = UITraitCollection(userInterfaceStyle: .dark) let yellowLight = yellow.resolvedColor(with: light) // 1 0.8 0 1 let yellowDark = yellow.resolvedColor(with: dark) // 1 0.839216 0.0392157 1 除了userInterfaceStyle之外，trait collection还有一个userInterfaceLevel属性，它的取值为.base或.elevated。这个属性会影响到动态背景颜色，通常只有主界面前面的有限区域会受到影响。每个Alert都有一个.elevated界面级别，即使Alert后面的主界面没有。
Size Classes 关于应用程序旋转和类似旋转，最重要的事实不是旋转本身，而是应用程序的尺寸比例的变化。想象一下，root view的一个子视图，当设备处于纵向时位于屏幕的右下方。如果根视图的边界宽度和边界高度被改变，那么这个子视图就会在边界高度之外，从而离开屏幕&amp;ndash;除非你的应用程序以某种方式对这种变化做出反应，重新定位它（这样的反应被称为布局，这个主题将占据本章的大部分篇幅）。
环境的维度特征体现在一对size classes中，这对尺寸亦是trait collection属性值:horizontalSizeClass和verticalSizeClass：
上面的这两个属性都是UIUserInterfaceSizeClsass类型，取值为.regular和.compact。当应用程序的窗口占据整个屏幕时，这一对size classes有如下含义：
 在iPad上运行时，水平和垂直尺寸类都是.regular。 在iPhone上以portrait方向运行时，水平尺寸类是.compact，而垂直尺寸类是.regular。 在大的iPhone上以landscape方向运行时，水平尺寸类是.regular，而垂直尺寸类是.compact。大的手机是指iPhone 6/7/8 Plus, iPhone XR, iPhone XS Max, iPhone 11, and iPhone 11 Pro Max 在小的iPhone上以landscape方向运行时，水平和垂直尺寸类都是.regular。  从上面的情况来看，通过traitCollectionDidChange去监听size classes的变化，并不能知道界面是否已经旋转。size classes并不区分纵向的iPad和横向的iPad。它们区分的是最重要的极端情况：如果horizontal size class从.regular变成.compact，App会突然变得又高又窄，你可能想通过改变界面的某种方式来进行补偿。然而，根据我的经验，你通常不会为了监听size classes的变化而重写traitCollectionDidChange方法。相反，size classes是为了需要应对其他事件而监听。
Overriding Trait Collections 在某些情况下，隔断部分的UITraitEnvironment，并且谎报trait collection的内容是很有用的。因为，我们可能想让层次结构的一部分相信我们是在一个横向的iPhone上，而实际上我们是在一个纵向的iPhone上，或者你的应用程序的某些区域不应该对明暗模式之间的变化做出反应。
你不能仅仅通过设置视图的trait collection来直接将trait collection插入继承层次中，因为traitCollection不是一个可设置的属性。但是，在UIViewController中，你可以通过:
override func overrideTraitCollection(forChild childViewController: UIViewController) -&amp;gt; UITraitCollection? {  // } 来注入你自己的trait collection。同样的UIPresentationController也有一个类似的方法。
对于user interface style,UIViewController和UIView有一个更简单的方式，即使用override var overrideUserInterfaceStyle: UIUserInterfaceStyle。其中overrideUserInterfaceStyle是一个UIUserInterfaceStyle实例，默认值是.unspecified，含义为interface style应该是按层次结构向下传递的。但是你一旦将它设置为.light或.dark，就会阻止从层次结构中的那一点开始，将原本只继承trait collection的userInterfaceStyle属性，替代成自定义设置。
layout 当一个父视图的边界原点改变时，子视图会随着移动。但是，当父视图的尺寸改变时，子视图会发生什么变化呢？
实际上是什么也没发生变化，子视图的边界和中心没有改变，父视图的边界原点也没有移动，所以子视图保持在相对于其父视图左上方的相同位置。在现实生活中，这通常不是你想要的结果。你会希望子视图在其超视图的尺寸发生变化时能被调整大小和重新定位，这就是所谓的布局。
以下是父视图可能被动态调整大小的方式：
  你的应用程序可能会通过旋转自己来补偿用户将设备旋转90度，使其顶部移动到屏幕的新顶部，以匹配其新的方向&amp;ndash;因此，其边界的宽度和高度值会被移位。
  一个iPhone应用程序可能会在不同长宽比的屏幕上启动：例如，iPhone SE的屏幕比后来的iPhone型号的屏幕相对较短，应用程序的界面可能需要适应这种差异。
  一个通用的应用程序可能在iPad或iPhone上启动。应用程序的界面可能需要适应它所运行的屏幕的大小。
  从nib实例化的视图，如视图控制器的主视图或表视图单元，可能会被调整大小以适应它所处的界面。
  视图可能会对其周围视图的变化做出反应。例如，当一个导航栏被动态地显示或隐藏时，其余的界面可能会缩小或增长来补偿，以填补可用空间。
  用户可能会在iPad上改变你的应用程序窗口的宽度，作为iPad多任务界面的一部分。
  在上述任何一种情况下以及其他情况下，可能都需要进行布局。视图的子视图如果尺寸发生了变化，就需要移位、改变尺寸、重新分布，或者以其他方式进行补偿，以便界面看起来还不错，并保持可用。
布局通常有3种基本的方式：
  手动布局：每当父视图被调整大小时，它就会发送layoutSubviews消息。所以，要手动布局子视图，请提供你自己的子类并重写layoutSubviews。很明显，这可能会带来很多工作，但这意味着你可以做任何你喜欢的事情。
  自动调整大小：自动调整大小是自动执行布局的最古老的方式。当它的上层视图被调整大小时，子视图将按照它自己的autoresizingMask属性值所规定的规则进行响应，该属性描述了子视图和它的上层视图之间的大小调整关系。
  自动布局：自动布局依赖于视图的约束。约束是一个成熟的对象，它的数值描述了一个视图的尺寸或位置的某些方面，通常是就其他视图而言的。它比autoresizingMask更复杂，描述性更强。多个约束可以适用于单个视图，它们可以描述任何两个视图之间的关系（不仅仅是一个子视图和它的上层视图）。自动布局是在layoutSubviews的幕后实现的。实际上，约束允许你在没有代码的情况下编写复杂的layoutSubviews功能。
  你的布局策略可以使用上面3种的任何组合。需要手动布局的情况很少，但如果你需要，你可以实现它。自动调整大小是默认的。自动布局是自动调整大小的替代选择。但在现实生活中，很可能你的所有视图都会选择加入自动布局，因为它非常强大，最适合帮助你的界面适应很大的屏幕尺寸范围。视图的默认布局行为取决于它的创建方式：
  如果是从代码中创建的视图，默认情况下使用自动调整大小，而不是自动布局。如果你想让这样的视图使用自动布局，你必须故意抑制它对自动调整大小的使用。
  所有新的.storyboard和.xib文件都选择加入自动布局。他们的视图已经准备好自动布局。但如果你愿意，nib编辑器中的视图仍然可以使用自动调整大小。
  Autoresizing 自动调整大小是在概念上指定一个子视图 &amp;ldquo;弹簧和支杆&amp;quot;的问题。弹簧可以膨胀和收缩；支杆则不能。弹簧和支杆可以在内部或外部、水平或垂直地分配。有了两个内部弹簧或支杆，你就可以指定视图是否可以以及如何调整大小；有了四个外部弹簧或支杆，你就可以指定视图是否可以以及如何重新定位。
  一个子视图在其上层视图中居中，并保持居中，但随着上层视图的调整而调整自己的大小。它在外部有四个支柱，内部有两个弹簧。
  一个子视图在它的超视图中居中，并保持居中，而且不会随着父视图的调整而调整自己的大小。它在外部有四个弹簧，内部有两个支柱。
  一个OK按钮要停留在其超级视图的右下方。它内部有两个支柱，外部有两个来自其右侧和底部的支柱，外部有两个来自其顶部和左侧的弹簧。
  一个文本字段要保持在其超视图的顶部。它将随着超视图的扩大而扩大。它的外部有三根支柱，底部有一个弹簧；内部有一个垂直支柱和一个水平弹簧。
  在代码中，弹簧和支杆的组合是通过视图的autoresizingMask属性来设置的，它是一个位掩码（UIView.AutoresizingMask），这样你就可以组合选项。选项代表弹簧，没有指定的都是strut。默认是空集，显然是指所有的struts&amp;ndash;但当然不可能真的是所有的struts，因为如果父视图被调整大小，就需要改变一些东西，所以实际上空的autoresizingMask与.flexibleRightMargin和.flexibleBottomMargin一样，意味着视图被struts钉在左上方。
在debug的时候，当你把一个UIView打印到控制台时，它的autoresizingMask会用autoresize这个词和一个弹簧的列表来报告。外部弹簧是LM、RM、TM和BM；内部弹簧是W和H。autoresize = LM&#43;TM意味着有来自左侧和顶部的外部弹簧；autoresize = W&#43;BM意味着有一个内部水平弹簧和一个来自底部的弹簧。
Autolayout and Constraints 在单独的视图层面，自动布局是一种可选的技术。可以在同一界面的不同区域使用自动调整大小和自动布局；一个同级视图可以使用自动布局，而另一个同级视图不使用；一个父视图可以使用自动布局，而其部分或全部子视图不使用。
但是，自动布局是通过父视图链来实现的，如果一个视图使用了自动布局，那么它的所有父视图也会使用自动布局。如果（几乎可以肯定的是）这些视图中的一个是视图控制器的主视图，那么该视图控制器就会收到自动布局相关的事件。
view Controllers 视图控制器是UIViewController的一个实例，实际上，它将是一个UIViewController子类的实例；UIViewController被设计成可以被子类化。你可以编写你自己的UIViewController子类；也可以使用一个内置的子类，如UINavigationController或UITabBarController；或者你可以对一个内置的子类进行子类化，如UITableViewController。
视图控制器管理着一个视图以及该视图的子视图，它们的子视图等等。处于该层次结构顶端的单一超级视图是视图控制器的主视图，或者简单说是它的视图，即视图控制器的view属性指向它。视图控制器的主视图没有明确的指针指向管理它的视图控制器，但视图控制器是一个UIResponder，在响应者链中就在其视图之上，所以它是其视图的下一个响应者。
为了让视图控制器发挥作用，它的视图必须以某种方式进入可见界面。视图控制器通常负责这个工作，但通常不是其视图的视图控制器，而是某个视图已经进入界面的视图控制器。在许多情况下，这将自动发生（我会在下一节中更多地谈论这个问题），但你可以参与这个过程，对于某些视图控制器，你可能必须自己做这项工作。一个来了的视图最终也可能会离开，负责将一个视图放入界面的视图控制器通常也会负责将其删除。
视图控制器通常会在视图出现或消失时提供界面的动画。内置的视图控制器子类，以及召唤或移除视图控制器及其视图的内置方法，都有内置的动画。我们都很熟悉轻击某个东西使新的界面从屏幕一侧滑入，然后再轻击一个返回按钮使该界面再次滑出。谁负责让视图控制器的视图进入界面，谁就负责提供动画。
最强大的视图控制器是顶层的视图控制器。这可能是一个全屏呈现的视图控制器，我将在本章后面解释。但大多数时候，它将是你的应用程序的根视图控制器。这是管理根视图的视图控制器，根视图位于整个视图层次结构的顶端，是窗口的唯一直接子视图，作为应用程序其他界面的超级视图。根视图控制器之所以能达到这个崇高的位置，是因为UIApplicationMain或者你的代码把它放在那里，把它实例化并分配给了窗口的rootViewController属性。窗口的反应是采用视图控制器的主视图，给它一个正确的框架（必要时调整其大小），并使其成为自己的子视图。
</content>
    </entry>
    
     <entry>
        <title>Swift 5.3 新特性</title>
        <url>https://iihui.github.io/post/swift-5.3/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  Swift 5.3引入了很多新特性，包括多尾闭包、多模式catch、枚举比较、闭包中self省略以及Swift Package Manager等一些重要改变。
 多尾闭包 以前 在Swift 5.3前尾闭包提供了精简写法，但仅限于函数最后一个参数为函数闭包。当一个函数有多个函数闭包参数时，如果该函数类型参数不为最后一个参数时，不能使用精简写法。如下所示，既有在圆括号内的闭包，又有在圆括号外的闭包：
// 写法 1（传统写法） UIView.animate(withDuration: 0.25, animations: {  // animation code }, completion: { completed in  // completion code })  // 写法 2（单尾闭包精简写法） UIView.animate(withDuration: 0.25, animations: {  // animation code }) { completed in  // completion code } 现在 而在Swift 5.3中，同一个函数的多尾闭包有了新的精简模式。在第一闭包之后可以使用标签的方式来使用尾闭包。这种新的写法把最后的连续几个闭包参数都算作是尾闭包，这些闭包都可以放在圆括号外面。
UIView.animate(withDuration: 0.3) {  self.view.alpha = 0 } completion: { _ in  self.view.removeFromSuperview() } 但是，这些尾闭包中第一个闭包被强制省略标签。苹果的解释是：如果允许第一个尾闭包加上标签，那么开发者需要考虑是加好还是不加好，这会导致代码风格不一致，那么干脆禁了吧。也就是除了第一个尾闭包需要省略标签之外，其余的尾闭包都需有标签。
参考资料
多模式catch语句 以前 在Swift 5.3之前，捕获同一类型Error只能有一个catch，然后再使用switch语句区分同一类型Error中具体的哪种错误，如下所示：
enum TaskError: Error {  case someRecoverableError  case someFailure(msg: String)  case anotherFailure(msg: String) }  func performTask() throws -&amp;gt; String {  throw TaskError.someFailure(msg: &amp;#34;some Failure&amp;#34;) }  func recover() {  // }  do {  try performTask() } catch let error as TaskError {  switch error {  case .someFailure(let msg), .anotherFailure(let msg):  debugPrint(msg)  case .someRecoverableError:  recover()  } } 现在 Swift 5.3可以使用多个catch块捕获同一类型不同类错误，这个特性使得代码具有更好的可读性，并且能够有效减少代码行数：
do {  try performTask() } catch TaskError.someRecoverableError {  recover() } catch TaskError.someFailure(let msg), TaskError.anotherFailure(let msg) {  debugPrint(msg) }  enum TemperatureError: Error {  case tooCold, tooHot }  func getReactorTemperature() -&amp;gt; Int {  90 }  func checkReactorOperational() throws -&amp;gt; String {  let temp = getReactorTemperature()   if temp &amp;lt; 10 {  throw TemperatureError.tooCold  } else if temp &amp;gt; 90 {  throw TemperatureError.tooHot  } else {  return &amp;#34;OK&amp;#34;  } }  do {  let result = try checkReactorOperational()  print(&amp;#34;结果: \(result)&amp;#34;) } catch TemperatureError.tooHot, TemperatureError.tooCold {  // 捕获多个异常  debugPrint(&amp;#34;关闭反应堆&amp;#34;) } catch {  debugPrint(&amp;#34;未知错误&amp;#34;) } 枚举Comparable 之前 在Swift 5.3之前，如果需要比较enum，则需要enum遵循Comparable协议，并且需要实现&amp;lt;和minimum方法，但是这种代码极难维护，因为如果添加一个枚举值，则需要更新&amp;lt;和minimum方法，才能比较enum，否则会出现编译错误：
enum Volume: Comparable {  case low  case medium  case high   private static func minium(_ lhs: Self, _ rhs: Self) -&amp;gt; Self {  switch (lhs, rhs) {  case (.low, _), (_, .low):  return .low  case (.medium, _), (_, .medium):  return .medium  case (.high, _), (_, .high):  return .high  }  }   private static func &amp;lt; (_ lhs: Self, _ rhs: Self) -&amp;gt; Bool {  return (lhs != rhs) &amp;amp;&amp;amp; (lhs == self.minium(lhs, rhs))  } } 可以使用扩展的方式解决上面的比较问题，即在扩展中添加一个容易比较的计算属性值，在实现静态方法&amp;lt;时，使用自定义的comparableValue即可：
private var comparableValue: Int {  switch self {  case .low:  return 0  case .medium:  return 1  case .high:  return 2  } }  private static func &amp;lt; (_ lhs: Self, _ rhs: Self) -&amp;gt; Bool {  return lhs.comparableValue &amp;lt; rhs.comparableValue } 现在 在Swift 5.3中，只要enum没有关联值或者只有一个Comparable的关联值，则会自动实现&amp;lt;和minimum方法，定义的enum直接可以进行比较：
enum Size: Comparable {  case small(Int)  case medium  case large(Int) }  let sizes: [Size] = [.medium, .small(4), .large(5), .large(1), .small(1)] debugPrint(sizes.sorted()) //[__lldb_expr_13.Size.small(1), __lldb_expr_13.Size.small(4), __lldb_expr_13.Size.medium, __lldb_expr_13.Size.large(1), __lldb_expr_13.Size.large(5)] self的省略 之前 在Swift 5.3之前，在闭包中对当前对象的属性或方法的引用，都要明确添加self，即便闭包不会产生循环引用时，也必须要添加：
struct SomeStruct {  var x = 0   func doSomething(task: @escaping () -&amp;gt; Void) {  task()  }   func test() {  doSomething {  // 闭包中使用属性，需要显式添加self  debugPrint(self.x)  }  } }  SomeStruct().test() 现在 而在Swift 5.3中，在闭包中对当前对象的属性或方法的引用没有这样的限制，可以去除self，直接使用属性和方法，如下所示：
struct SomeStruct {  var x = 0   func doSomething(task: @escaping () -&amp;gt; Void) {  task()  }   func test() {  doSomething {  // 无需再显式添加self  debugPrint(x)  }  } } SomeStruct().test() 还有一种新的方法在捕获列表中使用self，只需在捕获列表中加入[self]。这样就可以避免在闭包中反复使用self，如下所示：
class SomeClass {  var x = 0   func doSomething(task: @escaping () -&amp;gt; Void) {  task()  }   func newTest() {  doSomething { [self] in  x &#43;= 1  x = x * 5  }  } } 但是对于在逃逸闭包中，为了防止循环引用时添加的[weak self]，在Swift 5.3中仍然不能省略，依旧需要添加[weak self]。
参考资料
main 直到Swift 5.3之前，开发一个Swift程序需要在main.swft文件中定义程序启动点。现在，能够用@main和静态func main()方法来标记一个结构或基类（在任何文件中），当程序启动时，它将被自动被调用：
@main struct TerminalApp {  static func main() {  debugPrint(&amp;#34;Hello Swift 5.3&amp;#34;)  } } 但使用@main时，如果main.swift文件已经存在，就不应该使用它。因为@main应该在基类或结构体中使用，而且只应该定义一次。
where 在Swift 5.3中可以在具有泛型和扩展的函数中使用where子句。如下所示sorted方法中要求Element遵循Comparable协议：
struct Stack&amp;lt;Element&amp;gt; {  private var array = [Element]()  mutating func push(_ item: Element) {  array.append(item)  }   mutating func pop() -&amp;gt; Element? {  array.popLast()  } }  extension Stack {  // where   func sorted() -&amp;gt; [Element] where Element: Comparable {  array.sorted()  } } didSet 在Swift 5.3中，didSet发生了一些变化：
  如果didSet中没有使用到oldValue，则不会调用get方法，这意味着节省了内存和CPU的开销。这种方式称为simple didset。
  如果存在simple didset，但没有will set，则允许修改在原地发生「allow modifications to happen in-place.」
  参考资料
Float16 因为在图像处理和机器学习领域，经常会使用Float16。所以Swift 5.3中标准库添加了Float16类型，Float16是一个半精度，即16位的浮点值类型。
debugPrint(Float16.pi) //3.14 debugPrint(Float32.pi) //3.1415925 Moya // 假设你想将300状态码也视为失败 if statusCode &amp;gt;= 300 {  let moyaError = MoyaError.statusCode(resp)  // 可以在这里进行额外的错误处理，比如记录日志等  print(&amp;#34;自定义状态码错误: \(moyaError)&amp;#34;)  // 将成功结果转换为失败结果  let newResult: Result&amp;lt;Moya.Response, MoyaError&amp;gt; = .failure(moyaError)  // 可以通过某种方式将这个新结果传递出去，比如使用回调或者事件发布-订阅机制  // 这里简单地抛出一个错误作为示例  return newResult }  /// 服务端若把code=500转成http的500状态码，则Alamofire会拦截http的500状态码，走到failure /// - Parameters: /// - data: 后台接口返回的数据，用于解析出服务端的报错信息 /// - err: Alamofire的报错信息 /// - Returns: 报错信息 private func getErrMsg(data: Data?, err: Error) -&amp;gt; String {  var errMsg = err.localizedDescription  if let jsonData = data, let msg = JSON(jsonData)[&amp;#34;message&amp;#34;].string, !msg.isEmpty {  errMsg = msg  }  return errMsg } </content>
    </entry>
    
     <entry>
        <title>Swift 5.2 新特性</title>
        <url>https://iihui.github.io/post/swift-5.2/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  Swift 5.2于2020.03.24发布，新增了许多特性。新版本专注于改善开发体验并增加了一些新功能，新功能大部分以增强函数式编程风格为导向。
 KeyPath 在Swift 5.2中允许使用key path表达式替代key path函数。下面代码中，使用了cars.filter(\.isElectric)来代替key path函数：
class Car {  var brand: String  var isElectric: Bool   init(brand: String, isElectric: Bool) {  self.brand = brand  self.isElectric = isElectric  } }  let cars: [Car] = [Car(brand: &amp;#34;Tesla&amp;#34;, isElectric: true), Car(brand: &amp;#34;Ford&amp;#34;, isElectric: false)]  let electricCars1 = cars.filter { $0.isElectric } let electricCars2 = cars.filter { $0[keyPath: \Car.isElectric] } let electricCars3 = cars.filter(\.isElectric)  debugPrint(electricCars1.first?.brand, electricCars2.first?.brand, electricCars3.first?.brand) The power of key paths in Swift Swift是静态类型语言，在设计之初就非常注重编译时的安全，所以它缺乏Objective-C、Ruby和JavaScript等动态语言运行时常见的那种动态特性。值得庆幸的是，Swift获得越来越多的动态功能，同时保留了对类型安全的关注。
其中一个功能就是key path。关键路径本质上是把实例属性作为一个单独的值来引用。因此，它可以被传递，也可以在表达式中使用，用一段代码能够获取或设置一个属性，而不需要实际知道它所处理的是哪个属性。
key paths有3种主要的变体：
 KeyPath：只读方式访问属性。 WriteableKeyPath： 读写方式访问值语义的可变属性（值类型，非引用类型）。 ReferenceWritableKeyPath：读写方式访问引用类型属性。  实际上，还有一些另外的关键路径类型，它们的存在是为了减少内部代码的重复，并帮助类型擦除。
Functional shorthands struct Article {  let id: UUID  let source: URL  let title: String  let body: String } 如果存在一个Article类型的数组，通常会使用如下方式提取某个属性生成新的数组：
let articleIDs = articles.map { $0.id } let articleSources = articles.map { $0.source } 虽然上面的方法完全可行，但我们只对提取单个属性值感兴趣，并不真正需要闭包的全部功能，所以使用关键路径可能是一个很好的选择：
extension Sequence {  func map&amp;lt;T&amp;gt;(_ keyPath: KeyPath&amp;lt;Element, T&amp;gt;) -&amp;gt; [T] {  return map { $0[keyPath: keyPath] }  } } 如果使用Swift 5.2或之后的版本，上面的扩展方法实际上是不需要的，因为key paths现在可以自动转换为函数了。
let articleIDs = articles.map(\.id) let articleSources = articles.map(\.source) 标准库能够自动对包含Sortable元素的序列进行排序，但对于其它类型序列，必须提供自己的排序闭包。基于一个可比较值的关键路径，能够容易地添加对任何序列的排序支持。在序列上添加一个扩展，将给定的关键路径转换为一个排序表达式闭包：
extension Sequence {  func sorted&amp;lt;T: Comparable&amp;gt;(by keyPath: KeyPath&amp;lt;Element, T&amp;gt;) -&amp;gt; [Element] {  return sorted { a, b in  return a[keyPath: keyPath] &amp;lt; b[keyPath: keyPath]  }  } } 使用上述方法，现在能够快速、轻松地对任何序列进行排序，只需给出想要排序的关键路径。如果正在构建的应用程序涉及任何形式的可排序列表，现在可以根据可比较的属性（甚至是嵌套的）自由地对列表进行排序：
playlist.songs.sorted(by: \.name) playlist.songs.sorted(by: \.dateAdded) playlist.songs.sorted(by: \.ratings.worldWide) 上面这样做似乎只是简单地添加了一个语法糖，但这样既可以使一些复杂的代码更容易阅读，也可以帮助减少重复的代码。
No instance required 虽然适量的语法糖是很好的，但关键路径的真正力量来自于这样一个事实，即它们引用一个属性而不需要将其与任何特定的实例联系起来。现在假设正在开发一个显示歌曲列表的应用程序，为了在用户界面中为这个列表配置一个UITableViewCell，并使用一个配置器类型：
struct SongCellConfigurator {   func configure(_ cell: UITableViewCell, for song: Song) {  cell.textLabel?.text = song.name  cell.detailTextLabel?.text = song.artistName  cell.imageView?.image = song.albumArtwork  } } 上面代码没有任何问题，但想以类似的方式渲染其它模型的可能性很大（许多表视图单元格倾向于渲染标题、副标题和图像，而不管它们代表什么模型）。所以让我们看看是否可以利用关键路径的力量来创建一个用于任何模型的共享配置器实现。
下面创建一个叫做CellConfigurator的通用类型，由于想为不同的模型渲染不同的数据，将给它一组基于路径的关键属性：
struct CellConfigurator&amp;lt;Model&amp;gt; {  let titleKeyPath: KeyPath&amp;lt;Model, String&amp;gt;  let subtitleKeyPath: KeyPath&amp;lt;Model, String&amp;gt;  let imageKeyPath: KeyPath&amp;lt;Model, UIImage?&amp;gt;   func configure(_ cell: UITableViewCell, for model: Model) {  cell.textLabel?.text = model[keyPath: titleKeyPath]  cell.detailTextLabel?.text = model[keyPath: subtitleKeyPath]  cell.imageView?.image = model[keyPath: imageKeyPath]  } } 上述方法的好处是，现在可以很容易地为每个模型使用相同的轻量级关键路径语法来特化通用的CellConfigurator类型，像下面这样：
let songCellConfigurator = CellConfigurator&amp;lt;Song&amp;gt;(  titleKeyPath: \.name,  subtitleKeyPath: \.artistName,  imageKeyPath: \.albumArtwork )  let playlistCellConfigurator = CellConfigurator&amp;lt;Playlist&amp;gt;(  titleKeyPath: \.title,  subtitleKeyPath: \.authorName,  imageKeyPath: \.artwork ) 就像标准库的功能操作，如map和sorted，我们本可以使用闭包来实现CellConfigurator。但是，通过关键路径，能够实现一个非常好的语法糖。
Converting to functions 到目前为止，只是用键路径来读取属性，但现在可以看看如何用它们来动态地写入数值。在许多不同的代码库中，有一个非常常见的模式，就像下面这个例子一样。
正在加载一个列表，在ListViewController中显示，当加载操作完成后，只需将加载的项目赋值给视图控制器的一个属性：
class ListViewController {  private var items = [Item]() { didSet { render() } }   func loadItems() {  loader.load { [weak self] items in  self?.items = items  }  } } 既然在上面所做的只是把传递给闭包的值分配给视图控制器上的一个属性，如果能够把这个属性的设置器作为一个函数来传递，那不是更好吗？如果这样，就可以直接将该函数传递进去。
为了实现这一点，首先定义一个函数，把任何可写的关键路径转换成一个设置该关键路径属性的闭包。这次将使用ReferenceWritableKeyPath类型，因为想把这个功能只限制在引用类型上（否则就只能对一个值的拷贝进行修改）。
给定一个对象和该对象的关键路径，然后将自动捕获该对象作为一个弱引用，并在我们的函数被调用时分配与关键路径相匹配的属性：
func setter&amp;lt;Object: AnyObject, Value&amp;gt;(  for object: Object,  keyPath: ReferenceWritableKeyPath&amp;lt;Object, Value&amp;gt; ) -&amp;gt; (Value) -&amp;gt; Void {  return { [weak object] value in  object?[keyPath: keyPath] = value  } } 使用上述方法，现在可以简化之前的代码，得到一个看起来相当简洁的语法：
class ListViewController {  private var items = [Item]() { didSet { render() } }   func loadItems() {  loader.load(then: setter(for: self, keyPath: \.items))  } } 参考资料
实例调用函数 这个新功能允许拥有名为callAsFunction方法的实例直接调用该方法，即实例可以像函数一样被调用。如下所示的代码中base2Pow(x: 3)调用的就是callAsFunction(x: Double)这个函数：
struct MyPow {  let base: Double   func callAsFunction(x: Double) -&amp;gt; Double {  return pow(base, x)  } }  let base2Pow = MyPow(base: 2) // 直接使用实例调用方法 debugPrint(base2Pow(x: 3)) 在Swift中，任何拥有callAsFunction方法的对象都可以像一个函数一样被调用，这样的对象被称为可调用的。实际上callAsFunction方法的调用有3种，如下所示：
struct WannabeFunction {  func callAsFunction() {  debugPrint(&amp;#34;Hi there&amp;#34;)  } }  let wan = WannabeFunction() wan() wan.callAsFunction() // 使用类型来调用实例方法，需要传入一个实例 WannabeFunction.callAsFunction(wan)() 实际上callAsFunction()方法遵从所有Swift函数规则，它也可以被声明在类的扩展中。下面代码便是在WannabeFunction结构体的扩展中定义一个callAsFunction：
struct WannabeFunction {  // }  extension WannabeFunction {  func callAsFunction() {  debugPrint(&amp;#34;Hi there&amp;#34;)  } }  let wan = WannabeFunction() wan() wan.callAsFunction() WannabeFunction.callAsFunction(wan)() 在对象类型中定义的callAsFunction()方法既可以重载，也可以作为函数参数进行传递。下面的代码中重载了6个callAsFunction方法：
struct WannabeFunction {  func callAsFunction() {  debugPrint(#function)  }   // Argument label overloading  func callAsFunction(x: Int) {  debugPrint(#function, x)  }   func callAsFunction(y: Int) {  debugPrint(#function, y)  }   // Argument type overloading  func callAsFunction(x: String) {  debugPrint(#function, x)  }   // Generic type constraint overloading  func callAsFunction&amp;lt;T&amp;gt;(value: T) where T: Numeric {  debugPrint(#function, value)  }   func callAsFunction&amp;lt;T&amp;gt;(value: T) where T: StringProtocol {  debugPrint(#function, value)  } }  let wan = WannabeFunction() wan() // callAsFunction() wan(x: 1) // callAsFunction(x:) 1 wan(y: 2) // callAsFunction(y:) 2 wan(value: 3) // callAsFunction(value:) 3 wan(value: &amp;#34;str&amp;#34;) // callAsFunction(value:) str wan([1, 2, 3]) // ❌ Error: Type of expression is ambiguous without more context // 使用函数full name let fo = wan.callAsFunction(y:) fo(10)  //&amp;#34;callAsFunction()&amp;#34; //&amp;#34;callAsFunction(x:)&amp;#34; 1 //&amp;#34;callAsFunction(y:)&amp;#34; 2 //&amp;#34;callAsFunction(value:)&amp;#34; 3 //&amp;#34;callAsFunction(value:)&amp;#34; &amp;#34;str&amp;#34; //&amp;#34;callAsFunction(y:)&amp;#34; 10 如果没有可调用语法，引用和传递泛型函数是不可能的。如果试图引用一个泛型函数，就会出现编译错误，下面的代码会出现Cannot explicitly specialize a generic function编译错误：
func bar&amp;lt;T&amp;gt;(_ x: T) {  debugPrint(x) }  let f = bar&amp;lt;Int&amp;gt;() // Cannot explicitly specialize a generic function： 不能显式地特化泛型函数 但使用callAsFunction()方法就可以实现，在下面代码中f被赋值为{ print($0) }，然后Bar的实例f1可以通过语法糖来调用f：
struct Bar&amp;lt;T&amp;gt; {  var f: (T) -&amp;gt; Void   func callAsFunction(_ x: T) {  f(x)  } }  let f1 = Bar&amp;lt;Int&amp;gt; {  debugPrint($0) } f1(1)  let bar = Bar&amp;lt;Int&amp;gt;() {  debugPrint($0) }  bar(2) 如果对于每个输入，两个函数产生相同的输出，则被认为是相等的。鉴于某些类别是无限的，实现这一目标的唯一可能的方法是将函数包装成一个名义类型(nominal type)。
下面的例子展示了如何通过将一个函数包装成一个名义类型来为它添加可识别、可散列和可等价的一致性。callAsFuntion()方法允许我们使用类似函数的语法来调用包装器：
struct Function&amp;lt;Input, Output&amp;gt;: Identifiable {  let id: UUID  let f: (Input) -&amp;gt; Output   init(id: UUID = UUID(), f: @escaping (Input) -&amp;gt; Output) {  self.id = id  self.f = f  }   func callAsFunction(_ input: Input) -&amp;gt; Output {  f(input)  } }  extension Function: Equatable {  static func == (lhs: Function&amp;lt;Input, Output&amp;gt;, rhs: Function&amp;lt;Input, Output&amp;gt;) -&amp;gt; Bool {  lhs.id == rhs.id  } }  extension Function: Hashable {  func hash(into hasher: inout Hasher) {  hasher.combine(id)  } } Partial application和 bound closures可以使用可调用语法来建模。Partial application是一种函数式编程技术，意味着将一些参数绑定到一个函数上，而不对其进行完全评估：
func add(_ x: Int) -&amp;gt; (_ y: Int) -&amp;gt; Int {  { y in x &#43; y } }  let addTwo = add(2) print(addTwo(3)) // 5 上面的Partial application可以使用使用callAsFunction来进行替换。如下所示，定义一个sum结构体来代替上面的方法：
struct Sum {  var x: Int  func callAsFunction(_ y: Int) -&amp;gt; Int { x &#43; y } }  // 2. let addTwo = Sum(x: 2) print(addTwo(3)) // 5 对于经常忘记写[weak self]这种问题，有人提出了auto-weak delegate模式。这个模式也可以使用callAsFunction提高可读性：
class Delegate&amp;lt;Input, Output&amp;gt; {  init() {}   private var block: ((Input) -&amp;gt; Output?)?  func delegate&amp;lt;T: AnyObject&amp;gt;(on target: T, block: ((T, Input) -&amp;gt; Output)?) {  self.block = { [weak target] input in  guard let target = target else { return nil }  return block?(target, input)  }  }   func call(_ input: Input) -&amp;gt; Output? {  return block?(input)  }   func callAsFunction(_ input: Input) -&amp;gt; Output? {  return call(input)  } }  class DataLoader {  let onLoad = Delegate&amp;lt;(), Void&amp;gt;()  func loadData() {  onLoad(())  } }  class ViewController: UIViewController {  let loader = DataLoader()   override func viewDidLoad() {  super.viewDidLoad()  loader.loadData()  loader.onLoad.delegate(on: self) { (self, _) in  self.setupLoadedUI()  }  }   func setupLoadedUI() {} } 参考资料
下标默认值 在Swift 5.2中定义下标的时候，可以带默认值参数。在下面的例子中，在下标越界的情况下，返回一个默认值：
struct Building {  var floors: [String]   subscript(index: Int, default default: String = &amp;#34;Unknown&amp;#34;) -&amp;gt; String {  if index &amp;gt;= 0, index &amp;lt; floors.count {  return floors[index]  } else {  return `default`  }  } }  let building = Building(floors: [&amp;#34;Ground Floor&amp;#34;, &amp;#34;1st&amp;#34;, &amp;#34;2nd&amp;#34;, &amp;#34;3rd&amp;#34;]) Lazy filtering 在Swift 5.2前使用lazy filtering时，运算顺序从右到左。在Swift 5.2后运算顺序变成了从左到右。下面的代码在Swift 5.2前的输出为1，2，3，4，5，到Swift 5.2后则为2，4，如下所示：
let numbers1 = [1, 2, 3, 4, 5].lazy.filter { $0 % 2 == 0 }.filter { print($0); return true }  _ = numbers1.count // 2  // 4 </content>
    </entry>
    
     <entry>
        <title>Xcode编译报错问题</title>
        <url>https://iihui.github.io/post/ios-compiler/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> xxx-Swift.h未找到 如果报xxx-Swift.h未找到，则需要检查设置中的Swift Compiler - General下的Objective-C Generated Interface Header Name是否有对应的文件：
iOS 14.5.1编译报错 使用XCode 12.4在iOS 14.5.1的真机上编译时，打断点调试时，不能正常打印出成员变量的值，出现如下的报错信息：
查阅网上的资料，应该在设置Build Setting时将Debug的Optimization Level设置为None，如下所示：
但是上述方法对于在XCode 12.4中调试iOS 14.5.1真机却不生效。但新建一个demo工程，却可以正常调试，设置如下：
XCode 12.5 报错 使用XCode 12.5编译项目报Showing Recent Messages Application extensions and any libraries they link to must be built with the APPLICATION_EXTENSION_API_ONLY build setting set to YES.。需要将报错的Target的编译设置中的Require Only App-Extensions-Safe API置为YES即可：
</content>
    </entry>
    
     <entry>
        <title>Swift 基础</title>
        <url>https://iihui.github.io/post/swift-base/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> 语句 一个Swift文件包含多行文本。换行对于Swift来说是有意义的，代表一条语句的结束，因此Swift中一般一行只写一条语句。如果需要在一行中写多条语句，则需要分号隔开，但不推荐这样做。
print(&amp;#34;hello&amp;#34;) print(&amp;#34;world&amp;#34;) print(&amp;#34;hello&amp;#34;); print(&amp;#34;world&amp;#34;) 常量和变量 Swift的常量或者变量使用前必须先声明，使用let来声明常量，使用var来声明变量。常量赋初值后就不能再改变，如果尝试改变其值，则会报错。变量的值可以任意变化，随时修改。
显式声明 有两种方式声明变量，即显式和隐式，显式和隐式说的是声明常量或变量的时候是否明确指明类型。在变量声明时明确指定变量的类型则为显式变量声明，声明格式为var name: type = value：
var firstNumber: Int = 5 let firstNum: Int = 6 隐式声明 在变量声明时不指明变量的类型，而是由编译器推断出相应的类型，则为隐式声明。大部分情况下Swift足够智能，可以通过初始化值来推断出相应的类型：
var firstNumber = 5 let firstNum = 100 可选类型 当一个变量或者常量可能不存在值时，应该使用可选类型来声明。一个可选类型表示一个变量可能有值也可能没有值。可选类型可能不包含值，所以在访问前需要判断是否为nil。
var optionStr: String? optionStr = &amp;#34;Any Test&amp;#34;  if let str = optionStr {  debugPrint(str) }  if var str = optionStr {  str &#43;= &amp;#34;closure&amp;#34;  debugPrint(str) } 数组 声明 数组要求其中元素类型一致。数组声明的时候可以不指定类型，由编译器推断出类型。也可以在声明的时候指明类型，示例代码如下所示：
let arrayOne = [12, 34, 667] var arrayTwo = [Int]() var arrayThree: [Int] = [] let testMo = Array(repeating: &amp;#34;12&amp;#34;, count: 12) var testMo1 = Array([&amp;#34;1&amp;#34;,&amp;#34;23&amp;#34;,&amp;#34;45&amp;#34;,&amp;#34;90&amp;#34;,&amp;#34;test&amp;#34;,&amp;#34;mp&amp;#34;,&amp;#34;Y&amp;#34;]) 特殊数组 在Swift中，关键字Any可以代表任何类型的实例，包括函数类型。因此，在数组的定义时，使用Any可以保存不同类型数据元素：
var myArray: [Any] = [1,&amp;#34;Two&amp;#34;] 访问元素 数组元素的访问，包括以下标的形式访问数组中的任意一个元素。还可以以first来访问第一个元素，使用last属性来访问最后一个元素：
let arrayOne = [12, 34, 667] debugPrint(arrayOne[0], arrayOne[1], arrayOne[2])  var multiArray = [[1, 2], [3, 4], [5, 6]] let arr = multiArray[0] let value = multiArray[0][1] debugPrint(arr, value, arr.first, arr.last, multiArray.first, multiArray.last) 使用shuffle()或者shuffled()可以对数组进行重新洗牌，新生成一个随机序列。但调用shuffle()会改变原数组的顺序：
debugPrint(array, array.shuffled(), array.shuffled(), array) //[12, 34, 5, 89, 0, 1] [5, 1, 0, 89, 12, 34] [12, 34, 5, 89, 0, 1] [12, 34, 5, 89, 0, 1] array.shuffle() debugPrint(array) //[34, 0, 5, 12, 89, 1] 数组切片 数组切片是指以range的方式取数组中元素。下面的代码使用range的方式，以numbers[1 ... 3] = [100, 200, 400]方式整体改变数组中某些元素：
var numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] numbers[1 ... 3] = [100, 200, 400] debugPrint(numbers) diff var scores1 = [100, 81, 95, 98, 99, 65, 87]  var scores2 = [100, 98, 95, 91, 83, 88, 72]  let diff = scores2.difference(from: scores1) let newArr = scores1.applying(diff) ?? []  debugPrint(newArr) //[100, 98, 95, 91, 83, 88, 72] 字典 字典有时被称为哈希表，保存键和值之间的配对集合。key可以是任何符合Hashable协议的元素，而value可以是任何类型。与数组不同，字典的内容不是按顺序存储的。
声明 字典的声明与数组的声明一样，包括初始化隐式声明和指明类型两种。初始化隐式声明即通过编译器确定key和value类型：
let countries = [&amp;#34;US&amp;#34;: &amp;#34;UnitedStates&amp;#34;, &amp;#34;IN&amp;#34;: &amp;#34;India&amp;#34;, &amp;#34;UK&amp;#34;: &amp;#34;UnitedKingdom&amp;#34;] var dic1 = [String: String]() var dic2 = [Int: String]() var dic3 = [String: AnyObject]() var dic4: [String: String] = [:] var dic5: [Int: String] = [:] var dict1 = Dictionary&amp;lt;String, Any&amp;gt;() 更新或添加 字典中已有值的更新或添加可以通过赋值或者调用updateValue函数来改变key对应的value，如果key在字典中不存在，则更新不生效：
var countries = [&amp;#34;US&amp;#34;: &amp;#34;UnitedStates&amp;#34;, &amp;#34;IN&amp;#34;: &amp;#34;India&amp;#34;, &amp;#34;UK&amp;#34;: &amp;#34;UnitedKingdom&amp;#34;] countries.updateValue(&amp;#34;test&amp;#34;, forKey: &amp;#34;US&amp;#34;) debugPrint(countries) countries[&amp;#34;US&amp;#34;] = &amp;#34;MoTest&amp;#34; debugPrint(countries) 移除值 字典中已有值的移除可以通过重新赋值为nil或者调用removeValue函数来移除。如果key在字典中不存在，则移除不生效：
var countries = [&amp;#34;US&amp;#34;: &amp;#34;UnitedStates&amp;#34;, &amp;#34;IN&amp;#34;: &amp;#34;India&amp;#34;, &amp;#34;UK&amp;#34;: &amp;#34;UnitedKingdom&amp;#34;] countries[&amp;#34;US&amp;#34;] = nil countries.removeValue(forKey: &amp;#34;UK&amp;#34;) debugPrint(countries) 集合 在Swift中的集合是非有序集合，并且集合中每个元素都是唯一的，不可重复的。如果使用for循环来遍历集合，得到的顺序是随机的。
声明 字典的声明与数组的声明一样，包括初始化隐式声明和指明类型两种。初始化隐式声明即通过编译器确定集合类型：
var mySet1 = Set&amp;lt;String&amp;gt;() var mySet2 = Set([&amp;#34;one&amp;#34;, &amp;#34;two&amp;#34;, &amp;#34;three&amp;#34;]) 插入 mySet1.insert(&amp;#34;test&amp;#34;) mySet2.insert(&amp;#34;name&amp;#34;) 移除 mySet1.remove(&amp;#34;test&amp;#34;) mySet2.remove(&amp;#34;name&amp;#34;) 过滤 在集合或者枚举类型中，通过需要使用过滤功能，这包括在集合中使用where子句，for case， if case和filter函数等。
where for number in 1...30 where number % 3 == 0 {  debugPrint(number) } for case var worldSeriesWinners = [(&amp;#34;Red Sox&amp;#34;, 2004),  (&amp;#34;White Sox&amp;#34;, 2005),  (&amp;#34;Cardinals&amp;#34;, 2006),  (&amp;#34;Red Sox&amp;#34;, 2007),  (&amp;#34;Phillies&amp;#34;, 2008),  (&amp;#34;Yankees&amp;#34;, 2009),  (&amp;#34;Giants&amp;#34;, 2010),  (&amp;#34;Cardinals&amp;#34;, 2011),  (&amp;#34;Giants&amp;#34;, 2012),  (&amp;#34;Red Sox&amp;#34;, 2013),  (&amp;#34;Giants&amp;#34;, 2014), (&amp;#34;Royals&amp;#34;, 2015)]  for case (&amp;#34;Red Sox&amp;#34;, let year) in worldSeriesWinners {  debugPrint(year) } let myNumbers: [Int?] = [1, 2, nil, 4, 5, nil, 6] for case .some(let num) in myNumbers {  debugPrint(num) } let myNumbers2: [Int?] = [1, 2, nil, 4, 5, nil, 6] for case let num? in myNumbers2 where num &amp;lt; 3 {  debugPrint(num) } if case enum Identifier {  case Name(String)  case Number(Int)  case NoIdentifier }  var playerIdentifier = Identifier.Number(2) if case .Number(let num) = playerIdentifier {  debugPrint(&amp;#34;Player&amp;#39;s number is \(num)&amp;#34;) }  if case .Number(let num) = playerIdentifier, num == 2 {  debugPrint(&amp;#34;Player is either XanderBogarts or Derek Jeter&amp;#34;) } 协议 声明 协议中既可以声明方法，也可以声明属性。如下所示声明了CalorieCountProtocol协议，协议中既包含了方法也有属性：
protocol CalorieCountProtocol {  var calories: Int { get }   func description() -&amp;gt; String } 下面类Burger实现了CalorieCountProtocol协议。虽然协议里面声明的是变量，但实现协议的时候使用了常量，这是因为协议定义的时候只需要实现get方法即可，并未要求set方法：
class Burger: CalorieCountProtocol {  let calories = 800   func description() -&amp;gt; String {  return &amp;#34;This burger has \(calories)calories&amp;#34;  } } 协议的实现既可以在定义的时候，也可以在扩展中实现，下面代码在Sauce枚举扩展中实现CalorieCountProtocol协议，如下所示：
enum Sauce {  case chili   case tomato }  extension Sauce: CalorieCountProtocol {  var calories: Int {  switch self {  case .chili:   return 20   case .tomato:   return 15  }  }   func description() -&amp;gt; String {  return &amp;#34;This sauce has \(calories)calories&amp;#34;  } } 协议数组 在数组中要求其中的所有元素都是相同的，有了协议之后。只要符合相同协议的类型实例都可以放进这个协议数组中，如下所示：
let burger = Burger()  let sauce = Sauce.tomato  let foodArray: [CalorieCountProtocol] = [burger, sauce]  debugPrint(foodArray.reduce(0) { $0 &#43; $1.calories }) 协议继承 面向协议的编程过程中，需要使用协议继承、协议组合，协议扩展。协议继承是指一个协议可以继承一个或者多个协议。如下所示，Person协议继承了Name,Age,Hair，而协议Dog继承了Name, Age, Fur：
protocol Name {  var firstName: String { get set }  var lastName: String { get set } }  protocol Age {  var age: Double { get set } }  protocol Fur {  var furColor: UIColor { get set } }  protocol Hair {  var hairColor: UIColor { get set } }  protocol Person: Name, Age, Hair {  var height: Double { get set } }  protocol Dog: Name, Age, Fur {  var breed: String { get set } } 协议组合 协议组合是指允许类型实现多个协议，这是面向协议的设计相对于面向对象的设计所具有的众多优势之一，因为对象只能有一个父类。
protocol Name {  var firstName: String { get set }  var lastName: String { get set } }  protocol Age {  var age: Double { get set } }  protocol Fur {  var furColor: UIColor { get set } }  protocol Hair {  var hairColor: UIColor { get set } }  protocol Persion: Name, Age, Hair {  var height: Double { get set } }  protocol Dog: Name, Age, Fur {  var breed: String { get set } }  protocol Occupation {  var occupationName: String { get set }  var yearlySalary: Double { get set }  var experienceYears: Double { get set } }  struct Programmer: Persion, Occupation {  var firstName: String  var lastName: String  var age: Double  var hairColor: UIColor  var height: Double  var occupationName: String  var yearlySalary: Double  var experienceYears: Double } 协议中的where 在对协议进行过滤时，可以使用where：
for (index, animal) in animals.enumerated() where animal is SeaAnimal {  print(&amp;#34;Only Sea Animal: \(index)&amp;#34;) } 泛型 泛型函数 定义泛型函数时，可以同时添加多种泛型占位符，习惯上使用T或者E作为泛型占位符，如下所示：
func testGeneric&amp;lt;T, E&amp;gt;(a: T, b: E) {  // Statements } 使用泛型函数来交换变量的值：
func swapGeneric&amp;lt;T&amp;gt;(a: inout T, b: inout T) {  let tmp = a  a = b  b = tmp }  var a = 56 var b = 66  swapGeneric(a: &amp;amp;a, b: &amp;amp;b) 定义泛型函数时，可以指定其遵循某种协议或者属于某种类型。有多个泛型占位符，可以部分指定遵循某种协议或者属于某种类型，也可以全部指定：
func testGenericComparable&amp;lt;T: Comparable&amp;gt;(a: T, b: T) -&amp;gt; Bool {  a == b }  func testFunction&amp;lt;T: MyClass, E: MyProtocol&amp;gt;(a: T, b: E) {  // Statements } 泛型类型 不仅可以使用class定义泛型类，也可以在使用struct、enum时定义泛型类型：
class List&amp;lt;T&amp;gt; {  var items = [T]() }  var stringList = List&amp;lt;String&amp;gt;() var doubleList = List&amp;lt;Double&amp;gt;()  struct GenericStruct&amp;lt;T&amp;gt; {  // }  enum GenericEnum&amp;lt;T&amp;gt; {  // } 有条件扩展泛型 可以有条件地对泛型进行扩展，下面对List添加扩展，并要求其遵循Numeric协议：
extension List where T: Numeric {  func sum() -&amp;gt; T {  items.reduce(0, &#43;)  } } 有条件添加函数 从Swift 5.3中开始可以在泛型类型或者泛型类型扩展中，有条件添加方法：
extension List {  func sum() -&amp;gt; T where T: Numeric {  items.reduce(0, &#43;)  }   func sorted() -&amp;gt; [T] where T: Comparable {  items.sorted()  } } Conditional conformance Conditional conformance允许泛型占位符遵循某种协议才遵循某种协议，如下所示：
extension List: Equatable where T: Equatable {  static func == (l1: List, l2: List) -&amp;gt; Bool {  if l1.items.count != l2.items.count {  return false  }  for (e1, e2) in zip(l1.items, l2.items) {  if e1 != e2 { return false }  }  return true  } } 泛型下标 在Swift 4前，如果要使用泛型下标，必须要在类或者结构体层面定义。从Swift 4开始，可以创建泛型下标，下标的返回类型或其参数都可以是泛型：
subscript&amp;lt;T: Hashable&amp;gt;(item: T) -&amp;gt; Int {  return item.hashValue } subscript&amp;lt;T&amp;gt;(key: String) -&amp;gt; T? {  return dictionary[key] as? T } Associated types 关联类型声明一个占位名称，可以在协议中代替类型使用，在协议被实现时，实际的类型才可以确定。在创建泛型函数和泛型类型也使用相似的语法：
protocol QueueProtocol {  associatedtype QueueType  mutating func add(item: QueueType)  mutating func getItem() -&amp;gt; QueueType?  func count() -&amp;gt; Int } class IntQueue: QueueProtocol {  var items = [Int]()  func add(item: Int) {  items.append(item)  }   func getItem() -&amp;gt; Int? {  return items.count &amp;gt; 0 ? items.remove(at: 0) : nil  }   func count() -&amp;gt; Int {  return items.count  } } 关联类型也可以和泛型关联：即在协议中使用关联类型，然后在定义泛型时实现刚刚定义的协议。在下面的定义中，泛型GenericQueue实现了QueueProtocol协议：
class GenericQueue&amp;lt;T&amp;gt;: QueueProtocol {  var items = [T]()   func add(item: T) {  items.append(item)  }   func getItem() -&amp;gt; T? {  return items.count &amp;gt; 0 ? items.remove(at: 0) : nil  }   func count() -&amp;gt; Int {  return items.count  } }  var intQ2 = GenericQueue&amp;lt;Int&amp;gt;() intQ2.add(item: 2) intQ2.add(item: 4) print(intQ2.getItem()!) intQ2.add(item: 6) 协议中使用关联类型时，也可以使用类型约束。当协议被实现时，为关联类型定义的类型必须继承于该类或符合类型约束所定义的协议，下面定义了一个带有类型约束的关联类型：
associatedtype QueueType: Hashable 错误处理 错误定义 enum PlayerNumberError: Error {  case NumberTooHigh(description: String)  case NumberTooLow(description: String)  case NumberAlreadyAssigned  case NumberDoesNotExist } 抛出错误 需要抛出错误时，需在方法定义中添加throws关键字。意思是告诉任何调用该方法的调用者，这个方法可能抛出错误，而且这个错误必须处理：
typealias BaseballPlayer = (firstName: String, lastName: String, number: Int)  mutating func addPlayer(player: BaseballPlayer) throws {  guard player.number &amp;lt; maxNumber else {  throw PlayerNumberError.NumberTooHigh(description: &amp;#34;Max number is \(maxNumber)&amp;#34;)  }   guard player.number &amp;gt; minNumber else {  throw PlayerNumberError.NumberTooLow(description: &amp;#34;Min number is \(minNumber)&amp;#34;)  }   guard players[player.number] == nil else {  throw PlayerNumberError.NumberAlreadyAssigned  }   players[player.number] = player } 如果确定错误不会抛出，可以使用try!，try!会切断错误的传播。但不建议这样使用，因为一旦有错误，则会有运行时错误。
Swift提供了try?操作。它试图执行一个可能会抛出错误的操作，并将其转换为一个可选值；因此，如果抛出错误，操作的结果将是nil，如果没有抛出错误，则是操作的结果.
if let player = try? myTeam.getPlayerByNumber(number: 34) {  print(&amp;#34;Player is \(player.firstName)\(player.lastName)&amp;#34;) } 捕获错误 do {  let player = try myTeam.getPlayerByNumber(number: 34)  print(&amp;#34;Player is \(player.firstName)\(player.lastName)&amp;#34;) } catch PlayerNumberError.NumberDoesNotExist {  print(&amp;#34;No player has that number&amp;#34;) }  do {  try myTeam.addPlayer(player: (&amp;#34;David&amp;#34;, &amp;#34;Ortiz&amp;#34;, 34)) } catch PlayerNumberError.NumberTooHigh(let description) {  print(&amp;#34;Error: \(description)&amp;#34;) } catch PlayerNumberError.NumberTooLow(let description) {  print(&amp;#34;Error: \(description)&amp;#34;) } catch PlayerNumberError.NumberAlreadyAssigned {  print(&amp;#34;Error: Number already assigned&amp;#34;) } catch {  print(&amp;#34;Error: Unknown Error&amp;#34;) } 自定义下标 默认情况下，下标在Swift中是访问集合列表或序列中的快捷方式。也可以在自定义类型中定义下标，包括类、结构体、枚举和协议类型：
class MyNames {  private var names = [&amp;#34;Jon&amp;#34;, &amp;#34;Kailey&amp;#34;, &amp;#34;Kara&amp;#34;]   subscript(index: Int) -&amp;gt; String {  get { return names[index] }  set { names[index] = newValue }  } } 只读下标 自定义的下标时，可以只定义只读的下标，有两种方式。一种是只显式声明get方法，不声明set方法；另一种是不显式声明，直接返回：
subscript(index: Int) -&amp;gt; String {  return names[index] }  subscript(index: Int) -&amp;gt; String {  return names[index] }  subscript(add index: Int) -&amp;gt; Int {  get {  return num &#43; index  } } 计算下标 在定义下标时，可以如同定义计算属性：
struct MathTable {  var num: Int  subscript(index: Int) -&amp;gt; Int {  return num * index  } }  enum Hello {  subscript(name: String) -&amp;gt; String {  return &amp;#34;Hello \(name)&amp;#34;  } } 静态下标 enum Hello {  static subscript(name: String) -&amp;gt; String {  return &amp;#34;Hello \(name)&amp;#34;  } } 额外下标参数 可以在一个类型中定义多个下标，调用的时候可以根据传过去的索引名字区分：
struct MathTable {  var num: Int  subscript(multiply index: Int) -&amp;gt; Int {  return num * index  }   subscript(add index: Int) -&amp;gt; Int {  return num &#43; index  } } var table = MathTable(num: 5) print(table[multiply: 4]) // Displays 20 because 5*4=20 print(table[add: 4]) // Displays 9 because 5&#43;4=9 多维下标 一般的下标定义只有一个参数，但定义下标时可以有多个参数：
struct TicTacToe {  var board = [[&amp;#34;&amp;#34;, &amp;#34;&amp;#34;, &amp;#34;&amp;#34;], [&amp;#34;&amp;#34;, &amp;#34;&amp;#34;, &amp;#34;&amp;#34;], [&amp;#34;&amp;#34;, &amp;#34;&amp;#34;, &amp;#34;&amp;#34;]]   subscript(x: Int, y: Int) -&amp;gt; String {  get { return board[x][y] }  set { board[x][y] = newValue }  } } var board = TicTacToe()  board[1, 1] = &amp;#34;x&amp;#34;  board[0, 0] = &amp;#34;o&amp;#34; enum SayHello {  subscript(messageText message: String, messageName name: String, number: Int) -&amp;gt; [String] {  var retArray: [String] = []  for _ in 0 ..&amp;lt; number {  retArray.append(&amp;#34;\(message)\(name)&amp;#34;)  }  return retArray  } } 动态成员查询 动态成员查询可以调用一个将在运行时动态解析的属性：
@dynamicMemberLookup struct BaseballTeam {  let city: String  let nickName: String  let wins: Double  let losses: Double  let year: Int  subscript(dynamicMember key: String) -&amp;gt; String {  switch key {  case &amp;#34;fullname&amp;#34;:  return &amp;#34;\(city)\(nickName)&amp;#34;  case &amp;#34;percent&amp;#34;:  let per = wins / (wins &#43; losses)  return String(per)  default:  return &amp;#34;Unknown request&amp;#34;  }  } }  var redsox = BaseballTeam(city: &amp;#34;Boston&amp;#34;, nickName: &amp;#34;Red Sox&amp;#34;, wins: 108, losses: 54, year: 2018)  print(&amp;#34;The \(redsox.fullname)won \(redsox.percent)of their games in \(redsox.year)&amp;#34;) 闭包 闭包是独立的代码块，没有函数名的函数，可以在应用程序中传递和使用。我们可以把Int类型看作是包含integer的类型，String类型是包含字符串的类型。因此，闭包可以被认为包含代码块的类型。这意味着可以把闭包分配一个变量，将其作为参数传递给函数，也可以从函数中返回。
闭包可以捕捉和存储对任何变量或常量的引用，而这些变量或常量是在其定义的上下文中出现的。这被称为对变量或常量的closing over，在大多数情况下，Swift会为我们处理内存管理。唯一的例外是在创建强引用循环时。
简单闭包 闭包，就像一个函数，包含一些指令序列，可以接受参数和返回值，但是没有函数名。闭包可以赋值给常量和变量，因此如果需要在程序中传递闭包十分方便：
let clos1 = { () -&amp;gt; Void in  print(&amp;#34;Hello World&amp;#34;) }  let clos2 = { (name: String) -&amp;gt; Void in  print(&amp;#34;Hello \(name)&amp;#34;) }  let clos3 = { (name: String) -&amp;gt; String in  return &amp;#34;Hello \(name)&amp;#34; } 闭包的简明语法 func testFunction(num: Int, handler: () -&amp;gt; Void) {  for _ in 0 ..&amp;lt; num {  handler()  } }  testFunction(num: 5, handler: { print(&amp;#34;Hello from Shorthand closure&amp;#34;) }) func testFunction(num: Int, handler: () -&amp;gt; Void) {  for _ in 0 ..&amp;lt; num {  handler()  } }  testFunction(num: 5) {  print(&amp;#34;Hello from Shorthand closure&amp;#34;) } 数组中使用闭包 guests.map { name in  debugPrint(&amp;#34;hello \(name)&amp;#34;) }  guests.map { &amp;#34;hello \($0)&amp;#34; } let greetGuest = { (name: String) -&amp;gt; Void in  print(&amp;#34;Hello guest named \(name)&amp;#34;) }  let sayGoodbye = { (name: String) -&amp;gt; Void in  print(&amp;#34;Goodbye \(name)&amp;#34;) }  guests.map(greetGuest) guests.map(sayGoodbye) 不初始化数组 Swift 5.2为数组添加了一个不包含提前初始化的构造函数，如下所示：
let capacity = 20 let diceRolls = [Int](unsafeUninitializedCapacity: capacity) { buffer, initializedCount in  for x in 0 ..&amp;lt; capacity {  buffer[x] = Int.random(in: 1 ... 6)  }  initializedCount = capacity } 使用这种初始化器，有以下几点需要注意：
  如果initializedCount不设置，则默认为0，此时所有的设置的值都会消失。
  初始化的元素个数initializedCount不能大于数组的容量capacity；如果初始化的元素个数小于数组的容量，则剩余的元素都是随机值。
  并发和并行 自定义值类型 值和类类型 在Swift中不支持值的递归类型，而允许类的递归类型。如下所示的值类型会报Value type &#39;LinkedListValueType&#39; cannot have a stored property that recursively contains it错误：
struct LinkedListValueType {  var value: String  var next: LinkedListValueType? } 应该声明类类型的递归类型：
class LinkedListReferenceType {  var value: String  var next: LinkedListReferenceType?  init(value: String) {  self.value = value  } } 写复制 一般情况，当传递一个值类型，例如结构体，会创建一个新的副本。这意味着，如果一个大的结构体包含很多属性时，每次都要复制。为了解决这个问题，苹果在标准库中实现了写时复制。但是，自定义类型并未自动实现写复制。
private class BackendQueue&amp;lt;T&amp;gt; {  private var items = [T]()   public init() {  //  }   private init(_ items: [T]) {  self.items = items  }   public func addItem(item: T) {  items.append(item)  }   public func getItem() -&amp;gt; T? {  if items.count &amp;gt; 0 {  return items.remove(at: 0)  } else {  return nil  }  }   public func count() -&amp;gt; Int {  return items.count  }   public func copy() -&amp;gt; BackendQueue&amp;lt;T&amp;gt; {  return BackendQueue&amp;lt;T&amp;gt;(items)  } } struct Queue {  private var internalQueue = BackendQueue&amp;lt;Int&amp;gt;()   public mutating func addItem(item: Int) {  internalQueue.addItem(item: item)  }   public mutating func getItem() -&amp;gt; Int? {  return internalQueue.getItem()  }   public func count() -&amp;gt; Int {  return internalQueue.count()  } } 类 类中定义的常量和变量称为属性，定义的函数称为方法。子类会继承父类的所有的属性和方法，在子类定义的时候可以增加新的属性和方法。
class Animal {  var name: String   var sound: String   var numberOfLegs: Int   var breathesOxygen: Bool   init(name: String, sound: String, numberOfLegs: Int, breathesOxygen: Bool) {  self.name = name   self.sound = sound   self.numberOfLegs = numberOfLegs   self.breathesOxygen = breathesOxygen  }   func makeSound() {  print(sound)  } }  class Mammal: Animal {  let hasFurOrHair: Bool = true } 结构体 struct Reptile {  var name: String   var sound: String   var numberOfLegs: Int   var breathesOxygen: Bool   let hasFurOrHair: Bool = false   func makeSound() {  print(sound)  }   func description() -&amp;gt; String {  return &amp;#34;Structure: Reptile name: \(name)sound: \(sound)numberOfLegs: \(numberOfLegs)breathesOxygen: \(breathesOxygen)hasFurOrHair: \(hasFurOrHair)&amp;#34;  } } 加锁 下面可以添加
private var lock: os_unfair_lock = os_unfair_lock()  // 加锁来保证顺序获取id os_unfair_lock_lock(&amp;amp;self.lock) defer {  os_unfair_lock_unlock(&amp;amp;self.lock) } </content>
    </entry>
    
     <entry>
        <title>UISearchController</title>
        <url>https://iihui.github.io/post/ios-uisearchcontroller/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> 苹果 解决
// 先override viewDidLayoutSubviews方法 override func viewDidLayoutSubviews() {  super.viewDidLayoutSubviews()  super.setNavigationBarHidden(true, animated: false) } // 然后再push的时候关闭动画 from.navigationController?.pushViewController(vc, animated: true) </content>
    </entry>
    
     <entry>
        <title>Moya</title>
        <url>https://iihui.github.io/post/ios-moya/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  Moya是一个高度抽象的网络库，它的目标是让使用者不必关心网络请求的底层实现细节，只需要关注业务。Moya采用桥接和组合来进行封装，默认桥接了Alamofire。Moya具有很强的扩展性，可以轻松地将RxSwift、PromiseKit和ObjectMapper结合起来。
 模块介绍 Moya使用面向协议编程POP来设计网络抽象层，因此它整体的逻辑结构并没有明显的继承关系。Moya的核心代码，可以分成以下几个模块：
  Request模块包含TargetType、Endpoint、Cancellable类型。
  Provider模块是网络请求的枢纽，它将TargetType转换为Endpoint，再转换为URLRequest，最后让Alamofire做实际的网络请求。
  Response模块将Alamofire的返回的数据回调给上层，支持filter、mapJSON等方法。
  Alamofire模块通过桥接的方式将Alamofire的细节隐藏在上层，Moya和Alamofire的区别如下：
  Plguins为插件模块，默认提供了4种插件。
  Provider Provider是网络请求的枢纽，接受TargetType类型，并通过闭包调用回上层。下面是Provider的init方法定义：
/// Initializes a provider. public init(endpointClosure: @escaping EndpointClosure = MoyaProvider.defaultEndpointMapping,  requestClosure: @escaping RequestClosure = MoyaProvider.defaultRequestMapping,  stubClosure: @escaping StubClosure = MoyaProvider.neverStub,  callbackQueue: DispatchQueue? = nil,  manager: Manager = MoyaProvider&amp;lt;Target&amp;gt;.defaultAlamofireManager(),  plugins: [PluginType] = [],  trackInflights: Bool = false) {  self.endpointClosure = endpointClosure  self.requestClosure = requestClosure  self.stubClosure = stubClosure  self.manager = manager  self.plugins = plugins  self.trackInflights = trackInflights  self.callbackQueue = callbackQueue } 在init方法中，endpointClosure将TargetType转换为EndPoint，其中EndPoint是Moya网络请求的一个中间状态。requestClosure把EndPoint转换为URLRequest。Request的生成过程如下：
其中stubClosure闭包模拟服务器端假数据用于piling tests。而rackInflights表示是否需要跟踪重复的网络请求。
Request 使用Moya进行网络请求时，首先需要进行配置，以生成一个Request。按照官方文档，需要先创建一个枚举类型，并使其遵守TargetType协议，然后实现协议所规定的属性。
为什么要创建枚举来遵守协议，而不是创建类来遵守协议呢？实际上使用类或者结构体也是可行的。使用枚举的原因是Swift的枚举功能比较强大，结合switch语句，使得API管理起来非常方便。
如上图所示，endpointClosure将TargetType转换为EndPoint。endpointClosure为EndpointClosure类型，其定义如下：
public typealias EndpointClosure = (Target) -&amp;gt; Endpoint&amp;lt;Target&amp;gt; 当Provider初始化时，endpointClosure有一个默认值MoyaProvider.defaultEndpointMapping，其定义如下：
/// These functions are default mappings to `MoyaProvider`&amp;#39;s properties: endpoints, requests, manager, etc. public extension MoyaProvider {  final class func defaultEndpointMapping(for target: Target) -&amp;gt; Endpoint {  return Endpoint(  url: URL(target: target).absoluteString,  sampleResponseClosure: { .networkResponse(200, target.sampleData) },  method: target.method,  task: target.task,  httpHeaderFields: target.headers  )  }  ... } 接着requestClosure将Endpoint转换为URLRequest。requestClosure也有默认值MoyaProvider.defaultRequestMapping，这也是最后一次修改Request的机会：
final class func defaultRequestMapping(for endpoint: Endpoint, closure: RequestResultClosure) {  do {  let urlRequest = try endpoint.urlRequest()  closure(.success(urlRequest))  } catch MoyaError.requestMapping(let url) {  closure(.failure(MoyaError.requestMapping(url)))  } catch MoyaError.parameterEncoding(let error) {  closure(.failure(MoyaError.parameterEncoding(error)))  } catch {  closure(.failure(MoyaError.underlying(error, nil)))  } } 为什么在TargetType-&amp;gt;Endpoint-&amp;gt;URLRequest映射中使用闭包？这是为了平衡灵活性和易用性。对于大多数API请求，使用Moya提供的默认闭包映射就足够了，这样在大多数时候就不用担心这两个闭包的内容了，但有时会有一些额外的要求，比如在所有的API请求中增加一个额外的HTTP Header：
let endpointClosure = { (target: MyTarget) -&amp;gt; Endpoint&amp;lt;MyTarget&amp;gt; in  let defaultEndpoint = MoyaProvider.defaultEndpointMapping(for: target)  return defaultEndpoint.adding(newHTTPHeaderFields: [&amp;#34;APP_NAME&amp;#34;: &amp;#34;MY_AWESOME_APP&amp;#34;]) } open class Endpoint {  public typealias SampleResponseClosure = () -&amp;gt; EndpointSampleResponse   /// A string representation of the URL for the request.  public let url: String   /// A closure responsible for returning an `EndpointSampleResponse`.  public let sampleResponseClosure: SampleResponseClosure   /// The HTTP method for the request.  public let method: Moya.Method   /// The `Task` for the request.  public let task: Task   /// The HTTP header fields for the request.  public let httpHeaderFields: [String: String]?   public init(url: String,  sampleResponseClosure: @escaping SampleResponseClosure,  method: Moya.Method,  task: Task,  httpHeaderFields: [String: String]?) {   self.url = url  self.sampleResponseClosure = sampleResponseClosure  self.method = method  self.task = task  self.httpHeaderFields = httpHeaderFields  }   /// Convenience method for creating a new `Endpoint` with the same properties as the receiver, but with added HTTP header fields.  open func adding(newHTTPHeaderFields: [String: String]) -&amp;gt; Endpoint {  return Endpoint(url: url, sampleResponseClosure: sampleResponseClosure, method: method, task: task, httpHeaderFields: add(httpHeaderFields: newHTTPHeaderFields))  }   /// Convenience method for creating a new `Endpoint` with the same properties as the receiver, but with replaced `task` parameter.  open func replacing(task: Task) -&amp;gt; Endpoint {  return Endpoint(url: url, sampleResponseClosure: sampleResponseClosure, method: method, task: task, httpHeaderFields: httpHeaderFields)  }   fileprivate func add(httpHeaderFields headers: [String: String]?) -&amp;gt; [String: String]? {  guard let unwrappedHeaders = headers, unwrappedHeaders.isEmpty == false else {  return self.httpHeaderFields  }   var newHTTPHeaderFields = self.httpHeaderFields ?? [:]  unwrappedHeaders.forEach { key, value in  newHTTPHeaderFields[key] = value  }  return newHTTPHeaderFields  } } 为什么要引入RequestResultClosure来对外暴露底层URLRequest呢？猜测有以下几个原因：
  有些信息，比如cookies，在URLRequest创建之前是不知道的
  有很多URLRequest的属性，其中大部分是不常见的，比如allowCellularAccess，不必在Moya层封装。
  从Endpoint到URLRequest的映射是通过闭包回调来完成的，这意味着可以异步回调。
  为什么要引入Endpoint而不是直接映射到URLRequest呢？就是说，两步的闭包映射变成了一步的映射。这是为了确保：TargetType保持不变（属性都是只读），同时提供了一个对外友好的API。通过Endpoint可以很容易添加新的参数、HttpHeader等。
Stub Stub是一个与测试相关的概念，允许返回一些假数据。在Provider的初始化函数中，有一个stubClosure参数，默认值为MoyaProvider.neverStub：
 /// Initializes a provider. public init(endpointClosure: @escaping EndpointClosure = MoyaProvider.defaultEndpointMapping,  requestClosure: @escaping RequestClosure = MoyaProvider.defaultRequestMapping,  stubClosure: @escaping StubClosure = MoyaProvider.neverStub,  callbackQueue: DispatchQueue? = nil,  manager: Manager = MoyaProvider&amp;lt;Target&amp;gt;.defaultAlamofireManager(),  plugins: [PluginType] = [],  trackInflights: Bool = false) {  self.endpointClosure = endpointClosure  self.requestClosure = requestClosure  self.stubClosure = stubClosure  self.manager = manager  self.plugins = plugins  self.trackInflights = trackInflights  self.callbackQueue = callbackQueue } 而Moya的stub原理很简单：如果Provider初始化时确定了需要使用Stub，它就会返回Endpoint中的假数据。否则，Moya就会进行实际的网络请求。Moya通过StubClosure闭包来确定stub的模式：
/// Closure that decides if/how a request should be stubbed. public typealias StubClosure = (Target) -&amp;gt; Moya.StubBehavior 如上定义StubClosure返回Moya.StubBehavior，它有三种模式，其中never表示不使用Stub，其它两种表示需要返回假数据。Moya.StubBehavior的定义如下：
public enum StubBehavior {  /// Do not stub.  case never  /// Return a response immediately.  case immediate  /// Return a response after a delay.  case delayed(seconds: TimeInterval) } 如果使用Stub并且模式选择StubBehavior.immediate或StubBehavior.delayed(seconds: TimeInterval)，则返回EndPoint中定义的假数据，并关闭请求：
switch endpoint.sampleResponseClosure() { case .networkResponse(let statusCode, let data):  let response = Moya.Response(statusCode: statusCode, data: data, request: request, response: nil)  let result = validate(response)  plugins.forEach { $0.didReceive(result, target: target) }  completion(result) case .response(let customResponse, let data):  let response = Moya.Response(statusCode: customResponse.statusCode, data: data, request: request, response: customResponse)  let result = validate(response)  plugins.forEach { $0.didReceive(result, target: target) }  completion(result) case .networkError(let error):  let error = MoyaError.underlying(error, nil)  plugins.forEach { $0.didReceive(.failure(error), target: target) }  completion(.failure(error)) } 而默认的Endpoint，即defaultEndpointMapping中sampleResponseClosure的值如下所示：
final class func defaultEndpointMapping(for target: Target) -&amp;gt; Endpoint {  return Endpoint(  url: URL(target: target).absoluteString,  sampleResponseClosure: { .networkResponse(200, target.sampleData) },  method: target.method,  task: target.task,  httpHeaderFields: target.headers  ) } Moya中使用简单粗暴的stub，但效果很好。如果不使用Moya，也想返回假数据，这时需要URLProtocol，采用URLProtocol时，网络请求可以被拦截，从而将网络请求重定向到假数据。
因为NSURLConnection发起的请求也可以直接拦截。拦截NSURLSession的时候稍微复杂一点。因为URLSession的拦截规则通过URLSessionConfiguration属性确定。通常的做法是hook住URLSession的初始化方法init(configuration: URLSessionConfiguration, delegate: URLSessionDelegate?， delegateQueue: OperationQueue?)，再用URLSessionConfiguration注册所需的拦截协议。
Plugin Moya提供了一种插件机制，可以在网络请求的关键节点插入代码。从网络开始到结束全程可以插入额外代码时机如下所示：
但要注意的是插件不是类型化的，所以不要在插件中尝试进行JSON解析，并将其传递给上层。Moya共提供了4种插件：
  AccessTokenPlugin
  CredentialsPlugin
  NetworkActivityPlugin
  NetworkLoggerPlugin
  通过将插件的接口暴露给每个节点，Moya的插件功能不需要与核心代码耦合，但也给了外面足够的灵活性来插入任何你想要的代码。
Response Moya并没有具体处理Response，只是将Alamofire层返回的数据封装成Moya.Response。然后调用convertResponseToResult进一步封装成Result&amp;lt;Moya.Response, MoyaError&amp;gt;，并返回给上层：
/// A public function responsible for converting the result of a `URLRequest` to a Result&amp;lt;Moya.Response, MoyaError&amp;gt;. public func convertResponseToResult(_ response: HTTPURLResponse?, request: URLRequest?, data: Data?, error: Swift.Error?) -&amp;gt;  Result&amp;lt;Moya.Response, MoyaError&amp;gt; {  switch (response, data, error) {  case let (.some(response), data, .none):  let response = Moya.Response(statusCode: response.statusCode, data: data ?? Data(), request: request, response: response)  return .success(response)  case let (.some(response), _, .some(error)):  let response = Moya.Response(statusCode: response.statusCode, data: data ?? Data(), request: request, response: response)  let error = MoyaError.underlying(error, response)  return .failure(error)  case let (_, _, .some(error)):  let error = MoyaError.underlying(error, nil)  return .failure(error)  default:  let error = MoyaError.underlying(NSError(domain: NSURLErrorDomain, code: NSURLErrorUnknown, userInfo: nil), nil)  return .failure(error)  } } 如果进一步想将Moya.Response转换为JSON对象，可以使用Moya.Response扩展中定义的mapJSON的方法：
/// Maps data received from the signal into a JSON object. /// /// - parameter failsOnEmptyData: A Boolean value determining /// whether the mapping should fail if the data is empty. func mapJSON(failsOnEmptyData: Bool = true) throws -&amp;gt; Any {  do {  return try JSONSerialization.jsonObject(with: data, options: .allowFragments)  } catch {  if data.count &amp;lt; 1 &amp;amp;&amp;amp; !failsOnEmptyData {  return NSNull()  }  throw MoyaError.jsonMapping(self)  } } 至此Moya所做的事情就很清楚了：它提供了一个面向协议的接口，用于编写网络请求；它提供了一个灵活的闭合接口，用于定制请求；它提供了插件，用于客户端介入每个节点的网络请求；它将原始请求数据返回给上层。
Cancel API请求应该是可取消的，即在一个API请求发出去后，客户端应该能够取消刚发出的请求。Moya发出请求后将Cancellable协议类型返回：
/// Designated request-making method. Returns a `Cancellable` token to cancel the request later.  @discardableResult  open func request(_ target: Target,  callbackQueue: DispatchQueue? = .none,  progress: ProgressBlock? = .none,  completion: @escaping Completion) -&amp;gt; Cancellable {   let callbackQueue = callbackQueue ?? self.callbackQueue  return requestNormal(target, callbackQueue: callbackQueue, progress: progress, completion: completion)  }  func requestNormal(_ target: Target, callbackQueue: DispatchQueue?, progress: Moya.ProgressBlock?, completion: @escaping Moya.Completion) -&amp;gt; Cancellable {  ... } 从Cancellable的定义可以看出符合the Minimum Knowledge Principle原则，客户端不知道请求的是什么，唯一能做的就是取消请求：
public protocol Cancellable {   /// A Boolean value stating whether a request is cancelled.  var isCancelled: Bool { get }   /// Cancels the represented request.  func cancel() } 在内部实现中，使用CancellableWrapper类包装实际的Cancel动作，它返回的是实际实现协议的类型。
internal class CancellableWrapper: Cancellable {  internal var innerCancellable: Cancellable = SimpleCancellable()   var isCancelled: Bool { return innerCancellable.isCancelled }   internal func cancel() {  innerCancellable.cancel()  } } internal class SimpleCancellable: Cancellable {  var isCancelled = false  func cancel() {  isCancelled = true  } } 为什么需要CancellableWrapper来进行一层包装？因为对于没有实际发送的请求，取消动作是简单的SimpleCancellable。而对于实际的请求，cancel取消的是实际的网络请求：
cancellableToken.innerCancellable = self.performRequest(target, request: preparedRequest, callbackQueue: callbackQueue, progress: progress, completion: networkCompletion, endpoint: endpoint, stubBehavior: stubBehavior) 在取消网络请求的时候需要使用信号量，以防止两个线程同时取消网络请求，造成混乱：
/// Internal token that can be used to cancel requests public final class CancellableToken: Cancellable, CustomDebugStringConvertible {  let cancelAction: () -&amp;gt; Void  let request: Request?   public fileprivate(set) var isCancelled = false   fileprivate var lock: DispatchSemaphore = DispatchSemaphore(value: 1)   public func cancel() {  _ = lock.wait(timeout: DispatchTime.distantFuture)  defer { lock.signal() }  guard !isCancelled else { return }  isCancelled = true  cancelAction()  }   public init(action: @escaping () -&amp;gt; Void) {  self.cancelAction = action  self.request = nil  }   init(request: Request) {  self.request = request  self.cancelAction = {  request.cancel()  }  }   /// A textual representation of this instance, suitable for debugging.  public var debugDescription: String {  guard let request = self.request else {  return &amp;#34;Empty Request&amp;#34;  }  return request.debugDescription  }  } Alamofire Moya使用桥接的方式封装Alamofire的API细节，这些封装细节可以在Moya&#43;Alamofire.swift文件中查看，简单来说有两种桥接方法。一种是类型桥接，一种是协议桥接：
/// Represents an HTTP method. public typealias Method = Alamofire.HTTPMethod  /// Choice of parameter encoding. public typealias ParameterEncoding = Alamofire.ParameterEncoding public typealias JSONEncoding = Alamofire.JSONEncoding public typealias URLEncoding = Alamofire.URLEncoding public typealias PropertyListEncoding = Alamofire.PropertyListEncoding  /// Multipart form. public typealias RequestMultipartFormData = Alamofire.MultipartFormData Alamofire的外部接口是Request Type。另一方面，Moya需要在Plugin中暴露Reuqest，将其与Request协议桥接起来：
public protocol RequestType {  var request: URLRequest? { get }  func authenticate(user: String, password: String, persistence: URLCredential.Persistence) -&amp;gt; Self  func authenticate(usingCredential credential: URLCredential) -&amp;gt; Self }  internal typealias Request = Alamofire.Request extension Request: RequestType { } 对外暴露的接口就变成了如下的形式：
public extension PluginType {  func prepare(_ request: URLRequest, target: TargetType) -&amp;gt; URLRequest { return request }  func willSend(_ request: RequestType, target: TargetType) { }  func didReceive(_ result: Result&amp;lt;Moya.Response, MoyaError&amp;gt;, target: TargetType) { }  func process(_ result: Result&amp;lt;Moya.Response, MoyaError&amp;gt;, target: TargetType) -&amp;gt; Result&amp;lt;Moya.Response, MoyaError&amp;gt; { return result } } 桥接隐藏了一些细节，因此将来某一天Moya不再需要在底层依赖Alamofire时，对上层没有任何影响，这也是解耦的一种方式。
简单使用 用Moya分为几步，首先需要自定义一个枚举类型。然后遵循开闭原则，让定义的枚举分类遵循TargetType协议，然后按需实现协议中定义的各种get方法。最后创建MoyaProvider对象发起网络请求。
声明分类 Moya基于enum封装API，通过枚举不同端点的不同用法，以生成请求：
enum LCYApi {  case login(name: String, password: String) } TargetType 遵循开闭原则，使上一步定义的枚举分类遵循TargetType协议。TargetType协议定义了各个请求的url，参数和header等信息，按需实现即可，下面是TargetType的定义：
public protocol TargetType {   /// The target&amp;#39;s base `URL`.  var baseURL: URL { get }   /// The path to be appended to `baseURL` to form the full `URL`.  var path: String { get }   /// The HTTP method used in the request.  var method: Moya.Method { get }   /// Provides stub data for use in testing.  var sampleData: Data { get }   /// The type of HTTP task to be performed.  var task: Task { get }   /// A Boolean value determining whether the embedded target performs Alamofire validation. Defaults to `false`.  var validate: Bool { get }   /// The headers to be used in the request.  var headers: [String: String]? { get } } 对于上面定义的LCYpi，让其先遵循TargetType协议，实现相关的get方法，如下所示：
extension LCYApi: TargetType {  var baseURL: URL {  return NSURL.init(string: &amp;#34;http://test.com&amp;#34;)! as URL  }   var path: String {  switch self {  case .login:  return &amp;#34;/login&amp;#34;  }  }   var method: Method {  return .post  }   //这个是做单元测试模拟的数据，必须要实现，只在单元测试文件中有作用  var sampleData: Data {  return &amp;#34;&amp;#34;.data(using: String.Encoding.utf8)!  }   var task: Task {  var parmeters: [String : Any] = [:]   switch self {  case .login(let name, let password):  parmeters[&amp;#34;name&amp;#34;] = name  parameters[&amp;#34;password&amp;#34;] = password  }   return .requestParameters(parameters: parmeters, encoding: URLEncoding.default)  }   //在请求头内添加公共请求参数，也可以通过自定义closure返回endpoint，在provider中添加  var headers: [String : String]? {  return [&amp;#34;Content-type&amp;#34;: &amp;#34;application/json&amp;#34;]  } } 定义Provider对象 在Moya中，是使用Provider对象发起网络请求的，因此在网络请求之前需要将Provider对象先创建好。Moya中Provider对象在销毁的时候会取消网络请求，为了得到正确的结果，必须保证在网络请求时Provider对象不会被释放。为了避免这种情况，可以将Provider实例设置为类成员变量，或者shared实例。
let ApiProvider = MoyaProvider&amp;lt;LCYApi&amp;gt;() 发起网络请求 ApiProvider.request(LCYApi.login(name: &amp;#34;name&amp;#34;, password: &amp;#34;password&amp;#34;)) { result in  switch result {  case let .success(response):  let data = response.data  let statusCode = response.statusCode  break  case let .failure(error):  break  } } 自定义插件 日志插件 在第一部分介绍了使用Moya时可以自定义插件，下面的代码定义了日志插件，在请求发出之前把Request的信息打印出来，在请求完成前把相应的信息也打印出来：
public struct LoggerPlugin: PluginType {   public init() {  //  }   public func prepare(_ request: URLRequest, target: TargetType) -&amp;gt; URLRequest {  return request  }   public func willSend(_ request: RequestType, target: TargetType) {  guard let request = request.request else {  return  }  print(&amp;#34;🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀&amp;#34;)  print(&amp;#34;🚀 \(request.httpMethod ?? &amp;#34;&amp;lt;unknown method&amp;gt;&amp;#34;)\(request.url?.absoluteString ?? &amp;#34;nil&amp;#34;)&amp;#34;)  print(&amp;#34;🚀&amp;#34;)  for (header, value) in request.allHTTPHeaderFields ?? [:] {  print(&amp;#34;🚀 \(header): \(value)&amp;#34;)  }  if let body = request.httpBody, let content = String(data: body, encoding: .utf8) {  print(&amp;#34;🚀\n🚀\(content)&amp;#34;)  }  print(&amp;#34;🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀&amp;#34;)  }   public func process(_ result: Result&amp;lt;Moya.Response, MoyaError&amp;gt;, target: TargetType) -&amp;gt; Result&amp;lt;Moya.Response, MoyaError&amp;gt; {  defer {  print(&amp;#34;👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋&amp;#34;)  }  print(&amp;#34;👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋&amp;#34;)  switch result {  case .success(let resp):  if let response = resp.response {  print(&amp;#34;👋 \(response.statusCode)\(response.url?.absoluteString ?? &amp;#34;nil&amp;#34;)&amp;#34;)  print(&amp;#34;👋&amp;#34;)  for (header, value) in response.allHeaderFields {  print(&amp;#34;👋 \(header): \(value)&amp;#34;)  }  if let content = String(data: resp.data, encoding: .utf8) {  print(&amp;#34;👋\n👋\(content)&amp;#34;)  }  } else {  print(&amp;#34;👋 &amp;lt;Unknown Response&amp;gt;&amp;#34;)  }  case .failure(let error):  if let response = error.response?.response {  print(&amp;#34;👋 \(response.statusCode)\(response.url?.absoluteString ?? &amp;#34;nil&amp;#34;)&amp;#34;)  } else {  print(&amp;#34;👋 \(target.path)&amp;#34;)  }  print(&amp;#34;👋\n👋 &amp;lt;ERROR: \(error.localizedDescription)&amp;gt;&amp;#34;)  }  return result  } } GB2312插件 服务端有些接口返回的时候是GB2312编码的，但是工程中一般使用UTF8编码，所以在接口返回的时候需要将GB2312转换为UTF8编码：
public struct GB2312ToUTF8ConvertPlugin: PluginType {   /// Called to modify a result before completion.  public func process(_ result: Result&amp;lt;Moya.Response, MoyaError&amp;gt;, target: TargetType) -&amp;gt; Result&amp;lt;Moya.Response, MoyaError&amp;gt; {  if case let .success(resp) = result, (target as? GB2312Convertor)?.responseDataIsGB2312Data == true {  // 通讯录后台返回的是GB2312编码，要先转换成UTF8编码  if let data = resp.data.fromGB2312ToUTF8Data {  let newResp = Moya.Response(statusCode: resp.statusCode, data: data, request: resp.request, response: resp.response)  return .success(newResp)  }  return .success(resp)  }  return result  }  } 在上面的代码中使用到了responseDataIsGB2312Data == true的判断，因为不是所有的接口返回都要转换为UTF8编码的，所以定义了一个GB2312Convertor协议，协议里面有个变量用于标记是否需要转换编码：
protocol GB2312Convertor {  var responseDataIsGB2312Data: Bool { get } } 然后在实现了TargetType的枚举类型中，按需要实现GB2312Convertor即可，下面的代码中ContactsRequestAPI中的其他请求都需要将GB2312转换为UTF8编码:
extension ContactsRequestAPI: GB2312Convertor {  var responseDataIsGB2312Data: Bool {  switch self {  case .requestEnterpriseAuthInfo:  return false  default:  return true  }  } } NetworkLoggerPlugin 下面是Moya内置的插件NetworkLoggerPlugin的具体实现：
/// Logs network activity (outgoing requests and incoming responses). public final class NetworkLoggerPlugin: PluginType {  fileprivate let loggerId = &amp;#34;Moya_Logger&amp;#34;  fileprivate let dateFormatString = &amp;#34;dd/MM/yyyy HH:mm:ss&amp;#34;  fileprivate let dateFormatter = DateFormatter()  fileprivate let separator = &amp;#34;, &amp;#34;  fileprivate let terminator = &amp;#34;\n&amp;#34;  fileprivate let cURLTerminator = &amp;#34;\\\n&amp;#34;  fileprivate let output: (_ separator: String, _ terminator: String, _ items: Any...) -&amp;gt; Void  fileprivate let requestDataFormatter: ((Data) -&amp;gt; (String))?  fileprivate let responseDataFormatter: ((Data) -&amp;gt; (Data))?   /// A Boolean value determing whether response body data should be logged.  public let isVerbose: Bool  public let cURL: Bool   /// Initializes a NetworkLoggerPlugin.  public init(verbose: Bool = false, cURL: Bool = false, output: ((_ separator: String, _ terminator: String, _ items: Any...) -&amp;gt; Void)? = nil, requestDataFormatter: ((Data) -&amp;gt; (String))? = nil, responseDataFormatter: ((Data) -&amp;gt; (Data))? = nil) {  self.cURL = cURL  self.isVerbose = verbose  self.output = output ?? NetworkLoggerPlugin.reversedPrint  self.requestDataFormatter = requestDataFormatter  self.responseDataFormatter = responseDataFormatter  }   public func willSend(_ request: RequestType, target: TargetType) {  if let request = request as? CustomDebugStringConvertible, cURL {  output(separator, terminator, request.debugDescription)  return  }  outputItems(logNetworkRequest(request.request as URLRequest?))  }   public func didReceive(_ result: Result&amp;lt;Moya.Response, MoyaError&amp;gt;, target: TargetType) {  if case .success(let response) = result {  outputItems(logNetworkResponse(response.response, data: response.data, target: target))  } else {  outputItems(logNetworkResponse(nil, data: nil, target: target))  }  }   fileprivate func outputItems(_ items: [String]) {  if isVerbose {  items.forEach { output(separator, terminator, $0) }  } else {  output(separator, terminator, items)  }  } }  private extension NetworkLoggerPlugin {   var date: String {  dateFormatter.dateFormat = dateFormatString  dateFormatter.locale = Locale(identifier: &amp;#34;en_US_POSIX&amp;#34;)  return dateFormatter.string(from: Date())  }   func format(_ loggerId: String, date: String, identifier: String, message: String) -&amp;gt; String {  return &amp;#34;\(loggerId): [\(date)] \(identifier): \(message)&amp;#34;  }   func logNetworkRequest(_ request: URLRequest?) -&amp;gt; [String] {   var output = [String]()   output &#43;= [format(loggerId, date: date, identifier: &amp;#34;Request&amp;#34;, message: request?.description ?? &amp;#34;(invalid request)&amp;#34;)]   if let headers = request?.allHTTPHeaderFields {  output &#43;= [format(loggerId, date: date, identifier: &amp;#34;Request Headers&amp;#34;, message: headers.description)]  }   if let bodyStream = request?.httpBodyStream {  output &#43;= [format(loggerId, date: date, identifier: &amp;#34;Request Body Stream&amp;#34;, message: bodyStream.description)]  }   if let httpMethod = request?.httpMethod {  output &#43;= [format(loggerId, date: date, identifier: &amp;#34;HTTP Request Method&amp;#34;, message: httpMethod)]  }   if let body = request?.httpBody, let stringOutput = requestDataFormatter?(body) ?? String(data: body, encoding: .utf8), isVerbose {  output &#43;= [format(loggerId, date: date, identifier: &amp;#34;Request Body&amp;#34;, message: stringOutput)]  }   return output  }   func logNetworkResponse(_ response: HTTPURLResponse?, data: Data?, target: TargetType) -&amp;gt; [String] {  guard let response = response else {  return [format(loggerId, date: date, identifier: &amp;#34;Response&amp;#34;, message: &amp;#34;Received empty network response for \(target).&amp;#34;)]  }   var output = [String]()   output &#43;= [format(loggerId, date: date, identifier: &amp;#34;Response&amp;#34;, message: response.description)]   if let data = data, let stringData = String(data: responseDataFormatter?(data) ?? data, encoding: String.Encoding.utf8), isVerbose {  output &#43;= [stringData]  }   return output  } }  fileprivate extension NetworkLoggerPlugin {  static func reversedPrint(_ separator: String, terminator: String, items: Any...) {  for item in items {  print(item, separator: separator, terminator: terminator)  }  } }  参考资料 参考资料 参考资料
</content>
    </entry>
    
     <entry>
        <title>MDM</title>
        <url>https://iihui.github.io/post/tool-mdm/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  MDM是Moblie Device Management移动设备管理的简称，目的就是让企业能够方便的管理iPhone和Pad等移动设备。当企业大量的使用移动设备办公或涉及到一些安全限制时设备管理的作用就能明显的体现出来，通过MDM，IT人员能够在企业环境下安全地注册设备，无线配置和更新设置，监督公司政策的遵守情况，还能远程擦除或锁定被管理的设备。
 工作流程 从上图可以看出要实现MDM服务须涉及到，苹果推送服务器APNs、自己或者第三方提供的MDM服务器、受管理的设备。实际中三者之间通过HTTPS相互通信，所以推送和普通APP推送一样必须要有推送证书。没有操作的情况下，除了设备本身和APNs之间保持连接，其他都不在连接状态。各自在系统中的作用如下：
  MDM服务器：对于设备，通过它发送指令对设备进行管理，获取相关信息及操作，回应响应设备操作。对于APNs，向APNs发送一个命令，目的来唤醒设备去主动连接MDM服务器，报告其当前状态是否处于空闲（若设备空闲，MDM服务器会继续下一步操作比如开始发送指令）。
  APNs：可看作其他两者之间的信使，主要就是转发MDM服务器指令给设备，意思告诉设备开始去连接服务器啦。
  设备：首先通过Safari访问服务器安装一个配置描述文件（下文叙述）并登记注册使其成为受管理的设备，当收到APNs指令后，根据已安装的配置文件的url连接MDM服务器并报告其状态，然后接受下一步命令。比如命令DeviceInformation（查询设备信息如ModelName、BatteryLevel、WiFiMAC等），设备收到XML格式的指令后再向服务器传送其相关查询的信息，如果不需要继续发送指令，服务器关闭连接。
  另外设备和MDM服务器之间数据传输都是以XML格式形式，以PUT请求的方式进行的，所以发送指令时，服务器要把指令封装成一个XML的文件同时要实现PUT请求相关操作处理。APNs所发送的仅仅是一个与设备本身相关的标示符，没有其他命令，目的就是唤醒设备去连接MDM服务器。
需要的操作 要实现一个完整的MDM服务，需要制作APNs推送证书、设备安装的配置文件、实现https通信、实现MDM相关协议、学习MDM协议相关命令及使用、一个MDM服务器（这里不作主要叙述，因为这些相关的都是有我们后台做的）。
证书制作 这个证书就是MDM Server和APNs推送消息所需要的证书，当然和APP推送证书完全不同，虽然功能差不多。
发送指令 所以完成一次指令推送经历以下过程：
1、server 与APNs建立连接，发送数据。 2、当设备收到APNs推送消息时，主动连接server报告本身的状态空闲 3、server收到设备发来的状态信息，发出操作命令 4、设备收到命令执行，并返回数据 5、server响应，此次查询完成，连接关闭。
参考资料 苹果官方
</content>
    </entry>
    
     <entry>
        <title>iOS PWA</title>
        <url>https://iihui.github.io/post/ios-pwa/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> PWA  PWA（Progressive web apps）译为渐进式Web应用，指的是运用现代的Web API以及传统的渐进式增强策略来创建跨平台Web应用程序。PWA没有统一的定义，可以理解为使用Web技术来创建App，不用打包，不用签名，可以离线工作，如果你愿意，还可以添加到桌面上，看起来就和其他原生应用一样。
 Service Works 对于iOS来说Service Workers &#43; Web App Manifest = PWA
PWA 参考资料 参考资料 参考资料 传闻即将支持 支持
</content>
    </entry>
    
     <entry>
        <title>SwiftUI</title>
        <url>https://iihui.github.io/post/swiftui/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> Chapter 1 单个词的变量名可能很好，但有时希望使用多个单词来使变量或常量名有更好的可读性。当组合多个单词形成变量或常量名时，通常使用camelCase命名法：
var ageOfPet: Int = 8 var weightInKilograms: Double = 13.48 var directionToTurn: String = &amp;#34;Right&amp;#34; 除了将相关项目进行物理分组，如函数和变量分别放在一起，也可以通过添加//MARK: 注释使得搜索代码块变得更容易。放置一个//MARK: 注释，后面紧跟描述性文字，那么通过Xcode的下拉菜单可以很容易从一段代码跳转到另一段：
在SwiftUI中设计用户界面时，通常会创建一个视图（如Text），然后应用对应的修改器。如果需要反复使用相同的修改器，可以为多个视图重复这些修改器代码。但是，重复使用同样的修改器代码会使代码看起来冗长：
Text(&amp;#34;This is the first line&amp;#34;)  .font(.title)  .foregroundColor(.yellow)  .background(Color.blue)  .cornerRadius(6)  .padding()  Text(&amp;#34;Second line here&amp;#34;)  .font(.title)  .foregroundColor(.yellow)  .background(Color.blue)  .cornerRadius(6)  .padding() 重复的代码除了会占用空间，还会带来另一个问题。如果想改变一个或多个修改器，如改变字体大小或背景颜色。使用重复的修改器，需要修改每一个副本，这增加了忘记修改一个或多个副本的概率。
更好的解决方案是定义一个独立ViewModifier的struct，将将常用的修改器组存储在其中。然后将这个ViewModifier结构体应用于多个view。此时，如果需要更改这些修改器，可以在一个地方改变它们，而不是在多个地方。
struct MyStyle: ViewModifier {  func body(content: Content) -&amp;gt; some View {  content  .font(.title)  .foregroundColor(.yellow)  .background(Color.blue)  .cornerRadius(6)  .padding()  } } 上面定义的这个ViewModifier结构包含了所有的修改器，然后可以通过使用.modifier跟着结构名称来应用于任何视图，像下面这样:
VStack {  Text(&amp;#34;This is the first line&amp;#34;)  .modifier(MyStyle())  Text(&amp;#34;Second line here&amp;#34;)  .modifier(MyStyle()) } Charpter3 Closures 把函数改写成闭包的一种方法是去掉func关键字和函数名，然后把其余的代码用大括号括起来，像下面这样：
let y = { (x: Int) -&amp;gt; Int in  return x * 2 } 还可以将上面的方法简写为如下形式：
let z = {x in return x * 2}  let w = {x in x * 2}  let v = {$0 * 2} 当声明一个函数时，需要显式定义每个参数的类型：
func addNumbers(x: Int, y: Int) -&amp;gt; Int {  return x &#43; y } 使用闭包时，需要把所有的参数放在括号里。在许多情况下，不需要定义每个参数的数据类型，因为Swift可以根据返回值的数据类型来推断类型。例如，如果返回值数据类型是整数，Swift就会推断出传递的参数也必是整型，例如：
{(x, y) -&amp;gt; Int in return x &#43; y} 但是，如果有任何不明确的地方，就必须明确地定义参数的数据类型：
{(x: Int, y: Int) in return x &#43; y} {(x: Int, y: Int) in x &#43; y} {$0 as Int &#43; $1 as Int} Understanding Value Capturing 当在一个函数中声明变量和常量时，它们只能在该函数中被访问。然而，当在一个函数之外声明一个变量或常量时，该函数可以访问该值：
也许闭包最通用的用法是把它们当作数据块，可以像使用任何固定值一样使用它们。这意味着可以将一个闭包作为一个函数（或另一个闭包）的参数来传递，将闭包存储在像数组这样的数据结构中，或者将闭包分配给一个变量。
let addNumbers1 = { (x, y) -&amp;gt; Int in  return x &#43; y } let addNumbers2 = { (x: Int, y: Int) in  return x &#43; y } let addNumbers3 = { (x: Int, y: Int) in  x &#43; y } let addNumbers4 = {  $0 as Int &#43; $1 as Int } Chapter 1 在新建的SwiftUI工程中，主文件是ContentView.swift，它里面包含了当前应用程序自定义的用户界面相关Swift代码：
import SwiftUI  struct ContentView: View {  var body: some View {  VStack {  Image(systemName: &amp;#34;globe&amp;#34;)  .imageScale(.large)  .foregroundColor(.accentColor)  Text(&amp;#34;Hello, world!&amp;#34;)  }.padding()  } }  struct ContentView_Previews: PreviewProvider {  static var previews: some View {  ContentView()  } } 上面示例代码中，import SwiftUI可让应用程序使用SwiftUI框架来编写用户界面。在文件ContentView.swift中自动生成了两个View：
ContentView：在屏幕上显示视图的视图结构体。SwiftUI一次只能在屏幕上显示一个视图。创建好了SwiftUI iOS应用程序时，默认视图是一个垂直堆栈 (VStack)，它里面包含一个Image视图和一个Text视图。Image视图显示一个地球仪图标，Text视图在屏幕上显示 Hello, world!。
ContentView_Previews：是一个PreviewProvider结构体，实际上它用于在Canvas（画布）面板中显示当前程序定义的用户界面，画布面板位于代码编辑面板的右侧：
当编辑面板和Canvas（画布）面板并排出现时，编辑面板中的任何修改都会显示在预览的画布面板中，反之亦然。如下图所示，点击右上角的编辑器选项可以关闭画布面板。
画布面板有两个作用。首先，它可以让我们看到自定义的用户界面在模拟器上是什么样的。除了可以在不同模拟器（如不同的iPhone或 iPad型号）之间切换外，画布（Canvas） 面板还可以让我们选择不同的设置，如浅色或深色模式和动态类型。更改iOS设置可以让我们看到用户界面在不同显示选项下的效果。
Switching Between iOS Devices 画布面板能够模拟单个iOS设备，如iPhone 14 Pro或iPad Mini。这样就能看到用户界面如何适配不同iOS设备屏幕尺寸。要使Canvas面板模拟不同的iOS设备，有以下两种操作方式：
  单击Xcode窗口顶部当前显示的iOS设备名称，当前能够模拟的不同iOS设备列表就会弹出，然后选择想要的模拟器即可，如下图所示：
  Xcode还提供了第二种方式以切换画布面板中的模拟器。即在Inspector面板中切换模拟器。首先将光标切到ContentView_Previews中的ContentView，接着在右侧的Inspector面板上点击Device，最后选择相应模拟器即可：
  选择好了不同的模拟器设备后，则可以通过单击画布面板右下角出现的不同缩放图标来更改画布面板的放大倍率，各个图标的含义如下图所示：
  Zoom Out：缩小iOS模拟器尺寸。
  Zoom to 100%：以实际尺寸显示iOS模拟器（可能会截断模拟器的某些部分，尤其是iPad或大尺寸的iPhone型号的模拟器时）。
  Zoom to Fit：使iOS模拟器完全可见。
  Zoom In：放大iOS模拟器尺寸。
  Changing the iOS Device Emulation Appearance 在画布面板中选择要模拟的iOS设备后，如下图所示，若再点击底部的Device Setting按钮，将会显示三种选项更改用户界面外观：
 Color Scheme：浅色或深色模式。 Orientation：纵向或横向模式。 Dynamic Type：改变文字大小。  如果想对比Device Setting中不同外观选项的效果，可以点击画布面板底部的Variants按钮，然后选中弹出的不同选项，就可以看到各种选项的效果对比：
如下图所示，在底部点击实时(Live)图标，就能再次在画布面板中查看iOS模拟器：
Selecting User Interface Objects 在自定义用户界面上放置对象后，只能通过将光标移动至该对象对应的Swift代码来选择它们。如果希望使用鼠标点击用户界面上的对象，则需要点击画布面板底部的可选(Selectable)按钮：
一旦点击可选图标，单击用户界面上的对象后，该对象周围会出现蓝色边框。通过这些蓝色边框，可以看到对象的大小。如果对象添加了背景颜色，还可以方便地查看对象背景的大小。
不同于可选图标，点击实时图标后可让我们与自定义的用户界面进行交互，以测试应用程序。而可选图标可以方便地编辑用户界面。
Manipulating the Xcode Panes Xcode的4个面板：导航，编辑，画布和检查器均有不同用途。最左边的导航器面板显示工程相关信息，单击导航器面板中的特定项目，该项目就会显示在编辑器面板中。
在编辑面板中，可以编辑Swift代码。画布面板用于查看和测试由Swift代码编写的页面。最右侧的检查器面板显示在编辑面板中选定对象的相关信息，以对选定对象的不同属性进行修改。
将鼠标移到面板边框上，然后向左或向右拖动，就可以调整面板的大小。如果需要，可以在导航器或检查器面板处触发隐藏/显示。对于导航或检查器面板，可以使用如下方式进行显示/隐藏:
 选择View---&amp;gt;Navigators/Inspectors---&amp;gt;Hide/Show Navigator/Inspector。 单击显示（或隐藏）导航器（或检查器）面板图标。  Chapter 2 每个应用程序都需要一个自定义用户界面。SwiftUI的基本思想是使用视图(views，这里的视图概念和UIKit中不同)创建界面。视图是指在用户界面上显示的单个项目，例如文本、图像或按钮等。
SwiftUI的一个限制是一次只能在屏幕上显示一个视图。为了摆脱这种限制，SwiftUI提供了一种名为堆栈(Stack)的东西。堆栈Stack被视为单个视图，但允许在其中组合或堆叠多达十个视图。
通过创建堆栈，可以在屏幕上显示多个视图。堆栈甚至还可以内嵌其它堆栈，从而可以在一个屏幕上尽可能多地显示视图。当前共有3种类型的堆栈：
 VStack：将视图排列在另一个视图的上方和下方的垂直堆栈。 HStack：并排排列视图的水平堆栈。 ZStack：将视图直接叠加在一起的堆栈。  一个堆栈仅算作单个视图。通过使用水平（HStack）或垂直（VStack）堆栈，可以在堆栈内添加多达十个视图。为了提高灵活性，可以将一个堆栈嵌入到另一个堆栈内部，按需显示多个视图。
一个堆栈最多只能包含十个视图。如果尝试在堆栈中添加11个或更多视图，Xcode将显示错误信息并拒绝运行我们的应用程序，即会出现编译错误。
在SwiftUI中创建用户界面时，有三个选择：
 在编辑面板写Swift代码创建。 将视图拖到编辑器面板中的Swift代码中。 将视图拖到画布面板中。  在编辑面板编写Swift代码构建界面是最快、最灵活的方式，但需要先花费时间熟悉不同的选项。为了让编写Swift代码来定义用户界面视图变得更容易，Xcode在识别到试图键入的内容时会弹出一个选项菜单。选择一个选项并按下Return键，就可以快速创建视图：
如果对构建界面的各种选项不熟悉，可以使用Library Window，它列出了各种视图。一旦打开了Library Window，可以按如下方式添加视图：
  先点击编辑面板右上角的&#43;按钮，然后将视图从Library Window直接拖到编辑面板中。
  单击可选图标，再点击右上角的&#43;按钮，然后将Library Window中的视图拖到画布面板中的模拟器上的用户界面。
  无论如何更改用户界面，Xcode都会保持编辑器面板和画布面板之间的所有更改同步。这意味着当在编辑面板修改Swift代码时，画布面板会立即显示这种变更；当将用户界面视图拖到画布面板后，Xcode会自动将对应的代码添加到编辑面板中。
画布面板显示自定义的用户界面，如果想测试应用程序，则有两种选择：
 单击导航栏窗口的运行按钮或选择Product ➤ Run打开模拟器。 在画布面板的底部点击Live按钮。  要了解SwiftUI如何创建简单的可响应用户界面，可以按以下步骤操作：
  创建一个新的iOS应用程序，确保使用SwiftUI，并输入一个描述性的名称（如 SwiftExample）。
  单击导航面板中的ContentView文件，则编辑面板会显示ContentView文件的内容。
  选择Editor ➤ Canvas（如果画布选项前已出现选中标记，跳过此步骤即可）。这一步将打开画布，以便预览自定义用户界面。
  删除文本命令中的文本&amp;quot;Hello, world!&amp;quot;，然后键入以下内容，使ContentView结构体如下所示：
struct ContentView: View {  @State private var message = true  var body: some View {  VStack {  Toggle(isOn: $message) {  Text(&amp;#34;Toggle message on/off&amp;#34;)  }  if message {  Text (&amp;#34;Here&amp;#39;s a secret message!&amp;#34;)  }  }  } } 上面Swift代码会在屏幕上显示一个开关。除非在模拟器中运行应用程序或单击实时(Live)图标进行测试，否则无法看到上面开关的状态。多数情况下，实时(Live)图标能更快地在画布面板中查看和测试用户界面。
  单击实时(Live)图标打开实时预览，然后点击开关，即可以看到文本的消失和出现。
  单击运行按钮打开模拟器，重复前面的步骤，也可以完成测试。在模拟器或画布面板中测试应用程序的方法相同，主要区别在于画布面板使用起来更快。
上面VStack里的第一个视图是Toggle，它使用文本视图在Toggle左侧显示Toggle message on/off。当Toggle打开时，message的值将变为true。当Toggle关闭时，message变量值变成了false。
在Toggle下面，有一个if语句。如果message值为true，则会在开关下面显示一个文本视图，内容为Here’s a secret message! 如果message状态变量为false，则不显示该文本视图。
Modifying the User Interface with the Inspector Pane 在SwiftUI中创建用户界面通常包括两个步骤。首先，需要安排各种视图在屏幕上的显示方式。接下来，需要更改视图的大小、颜色或位置等信息来完成定制用户界面。
若要自定义用户界面视图，需要添加modifiers（修改器）。Xcode提供了两种方法添加modifiers：
  直接在编辑面板中输入modifiers。
  单击要修改的视图（在编辑器面板中单击或者单击可选图标后再单击画布面板中的对应视图）。然后从检查器面板中选择相应的修改器。
  直接在编辑器面板中键入修改器的前提是知道要使用的修改器名称。随着经验的积累，直接在代码中键入修改器的速度会越来越快。不过，刚开始使用时，可能不知道有哪些修改器可用。这时，使用检查器面板会更快捷。
打开检查器面板，需要先选择要修改的视图。既可以在编辑面板将光标移到该视图对应的Swift代码，也可以在画布面板的底部单击可选图标，然后在画布面板中点击待修改的视图。选择好视图后，检查器面板就会显示选中视图的相关修改器。
检查器面板显示最常用的修改器，例如文本的字体、对齐方式或颜色。单击检查器面板底部的添加修改器(Add Modifier)按钮，可以查看其它修改器列表：
从修改器列表中看到想要使用的修改器时，单击该修改器，Xcode将会在Inspector面板中显示该修改器。如果想删除已添加到检查器面板中的修改器，将鼠标悬浮在对应的修改器的右上角，就会出现Delete按钮，单击便可删除：
需要注意的是，添加修改器的不同顺序可能会产生不同的效果。文本视图有两个修饰器，background和padding。下面代码先添加背景修改器，然后再添加padding修改器：
Text(&amp;#34;Here&amp;#39;s a secret message!&amp;#34;).background(Color.yellow).padding() 上面代码中，先为文本视图添加黄色背景，然后在文本视图四周添加padding。假设将这两个修改器调换一下顺序，代码如下所示：
Text(&amp;#34;Here&amp;#39;s a secret message!&amp;#34;).padding().background(Color.yellow) 先在文本视图四周添加padding，然后添加background颜色。由于背景现在包含了新增的空间，因此背景颜色也填充了文本视图四周的空间：
无论使用哪种方法添加修改器，Xcode的编辑器面板和检查器面板都会保持同步。如果在编辑器面板中键入修改器，所有更改将自动出现在检查器面板。同样，如果在检查器面板中选择了某个修改器，Xcode也会自动将该修改器添加到编辑器面板的代码中。
Chapter 3 在自定义用户界面上放置单个视图时，无论屏幕是小巧的 iPhone还是大得多的iPad，SwiftUI都会将其置于屏幕中央。当需要在页面上添加更多视图时，这些视图垂直还是水平显示，取决于是以垂直还是水平方式排列这些视图。
但是，添加到页面上的视图越多，相邻视图就会显得越拥挤。为了解决这个问题，SwiftUI提供了几种在自定义用户界面上放置视图的方法：
 使用padding修改器。 在Stack堆栈中定义spacing。 在视图之间使用spacer。 定义一个offset或positon location。  可以使用一种或多种不同方法在页面上排列视图，使它们准确地显示在你想要的位置上。重要的是，这些定位方法适用于SwiftUI中的所有视图。
Using the Padding Modifier padding修改器可在视图四周添加空间。默认情况下，padding修改器会在视图的顶部、底部、左侧和右侧添加空间。要使用padding修改器，只需在视图后添加以下内容:
.padding() padding有两个作用。首先，它可以在视图四周增加空间，从而改变背景，若先在背景上添加颜色，则能使视图更大更容易被看清。其次，padding修改器能将相邻视图推得更远，使相邻视图不拥挤。
最简单的padding修改器会在视图的四周添加16个point空间。如果添加一个数字，就可以定义所需的精确间距，例如 .padding(45) 或 .padding (3):
Text(&amp;#34;No padding&amp;#34;).background(Color.yellow) Text(&amp;#34;Default padding of 16 points&amp;#34;).padding().background(Color.yellow) Text(&amp;#34;Default padding of 45 points&amp;#34;).padding(45).background(Color.yellow) Text(&amp;#34;Default padding of 3 points&amp;#34;).padding(3).background(Color.yellow) 请注意，padding修改器默认会在视图的所有边上添加间距，但也可以只在一个或多个特定方向上添加间距。可以定义的方向包括：
 .top .bottom .vertical(top and bottom) .leading(left) .trailing(right) .horizontal (trailing and leading)  VStack {  Text(&amp;#34;Top padding only&amp;#34;).padding(.top).background(Color.yellow)  Text(&amp;#34;Bottom padding only&amp;#34;).padding(.bottom).background(Color.green)  Text(&amp;#34;Vertical padding&amp;#34;).padding(.vertical).background(Color.yellow)  Text(&amp;#34;Leading padding only&amp;#34;).padding(.leading).background(Color.green)  Text(&amp;#34;Trailing padding only&amp;#34;).padding(.trailing).background(Color.yellow)  Text(&amp;#34;Horizontal padding only&amp;#34;).padding(.horizontal).background(Color.green) } 如果添加padding修改器时没有指定值，那么默认会增加16个点的空间。如果要同时定义添加的方向和特定间距，可以按如下方式：
.padding(.top, 30) 如果要为两个或两个以上方向添加间距，可以像下面一样在方括号中定义这些方向，并在后面加上可选的间距值。下面第一行使用的是默认距离16，第二行指定了距离为30:
.padding([.top, .leading]) .padding([.top, .leading] , 30) .padding(.leading, 9).padding(.vertical, 40) 除了使用固定数值来定义要填充的间距，还可以使用一个类型为CGFloat的数值变量。下面代码定义了一个distanceSize变量作为padding size：
var distanceSize = 15.0 .padding(CGFloat(distanceSize)) 需要注意的是，.padding修改器需要将数值转换为CGFloat类型。在.padding修改器中使用数值变量作为间距值，可以通过改变该变量的值来改变.padding修改器的间距。
Defining Spacing Within a Stack 使用padding修改器可以方便地将不同视图分开。若没有padding，堆栈中的多个视图就会挤在一起。如下图所示，通过为堆栈中的每个视图添加padding，可以将它们分开，使得每个视图就更容易看清。
虽然padding可以让每个视图更容易看清，但我们可能希望对堆栈内视图之间的间距有更多控制。为此，可以在定义堆栈时同时指定一个spacing值：
VStack (spacing: 40) { } Aligning Views Within a Stack 创建堆栈（VStack或HStack）时，无论是否指定spacing，都可以定义对齐方式。如果在堆栈中同时定义对齐方式和间距，则必须先定义对齐方式，后定义间距：
VStack (alignment: .leading) VStack (alignment: .leading, spacing: 24) 使用VStacks时，有三种选项对齐其中的视图：
 .leading (左对齐) .center (如果没有设置对齐方式，则该值为默认设置) .trailing (右对齐)  VStack(alignment: .leading) {  Text(&amp;#34;Top&amp;#34;).background(Color.yellow)  Text(&amp;#34;Middle Text View&amp;#34;).background(Color.yellow)  Text(&amp;#34;Bottom&amp;#34;).background(Color.yellow) } VStack(alignment: .center) {  Text(&amp;#34;Top&amp;#34;).background(Color.yellow)  Text(&amp;#34;Middle Text View&amp;#34;).background(Color.yellow)  Text(&amp;#34;Bottom&amp;#34;).background(Color.yellow) } VStack(alignment: .trailing) {  Text(&amp;#34;Top&amp;#34;).background(Color.yellow)  Text(&amp;#34;Middle Text View&amp;#34;).background(Color.yellow)  Text(&amp;#34;Bottom&amp;#34;).background(Color.yellow) } 使用HStack时，有5种选项对齐其中的视图：
  .top
  .bottom
  .center（如果没有设置其它对齐选项，则该值为默认设置）
  .firstTextBaseline
  .lastTextBaseline
  HStack(alignment: .bottom) {  Text(&amp;#34;Top&amp;#34;).font(.system(size: 40)).background(Color.yellow)  Text(&amp;#34;Middle Text View&amp;#34;).background(Color.yellow)  Text(&amp;#34;Bottom&amp;#34;).font(.largeTitle).background(Color.yellow) } 上面选项中的.top,.bottom,.center对于所有视图都是适用的。但是，若是文本视图，SwiftUI还提供了两种基线对齐的方法。可以根据第一个视图（.firstTextBaseline）或最后一个视图（.lastTextBaseline）对齐文本。
HStack(alignment: .firstTextBaseline) {  Text(&amp;#34;Top&amp;#34;).font(.system(size: 40)).background(Color.yellow)  Text(&amp;#34;Middle Text View&amp;#34;).background(Color.yellow)  Text(&amp;#34;Bottom&amp;#34;).font(.largeTitle).background(Color.yellow) }.padding()  HStack(alignment: .lastTextBaseline) {  Text(&amp;#34;Top&amp;#34;).font(.system(size: 40)).background(Color.yellow)  Text(&amp;#34;Middle Text View&amp;#34;).background(Color.yellow)  Text(&amp;#34;Bottom&amp;#34;).font(.largeTitle).background(Color.yellow) } Using Spacers 在堆栈中的视图之间使用padding和spacing可以方便地排列视图。另一种放置视图的方法是使用spacers(间隔期)。间隔器就像弹簧一样，将两个视图尽可能地推开。
Spacer() 由于Spacer能自动适应不同的屏幕尺寸，也就是说无论屏幕尺寸如何，间隔器都将视图对齐屏幕边缘。下面代码将两个视图顶到屏幕边缘：
HStack() {  Text(&amp;#34;Left&amp;#34;).font(.system(size: 40)).background(Color.red)  Spacer()  Text(&amp;#34;Right&amp;#34;).font(.system(size: 40)).background(Color.red) } VStack {  Text(&amp;#34;Top&amp;#34;).font(.system(size: 40)).background(Color.yellow)  Spacer()  Text(&amp;#34;Middle&amp;#34;).font(.system(size: 40)).background(Color.yellow)  Spacer()  Text(&amp;#34;Bottom&amp;#34;).font(.system(size: 40)).background(Color.yellow) } 多个间隔器能将视图推得更远。如果改变上面代码，在顶部和中间视图之间添加两个间隔器，这两个间隔器会将中间视图推得更远，效果如下图所示：
VStack {  Text(&amp;#34;Top&amp;#34;).font(.system(size: 40)).background(Color.yellow)  Spacer()  Spacer()  Text(&amp;#34;Middle&amp;#34;).font(.system(size: 40)).background(Color.yellow)  Spacer()  Text(&amp;#34;Bottom&amp;#34;).font(.system(size: 40)).background(Color.yellow) } 通过使用多个间隔器，我们能够根据屏幕大小调整视图。当应用程序在较大的屏幕上运行时，间隔器会将视图推到屏幕的边界。当应用程序在较小的屏幕上运行时，间隔器将视图推到较短的距离。
也就是说，间隔器会根据屏幕尺寸自动调整大小。不过，可能有时需要为间隔器定义一个最小长度，以防止其将视图推到较远的距离。要定义最小长度，可以使用如下代码：
Spacer(minLength: 25.73) 请注意，最小长度既可以定义为CGFloat类型，也可以使用整数值，例如：
Spacer(minLength: 25) Spacer(minLength: 25.56) 如果不指定最小长度，间隔器就会根据程序运行时的屏幕尺寸而变化。如果想为间隔器指定一个固定值，可以使用.frame修改器。如果在VStack中使用Spacer，可以在frame修改器中指定高度：
VStack {  Text(&amp;#34;Left&amp;#34;).font(.system(size: 40)).background(Color.yellow)  Spacer().frame(height: 125)  Text(&amp;#34;Right&amp;#34;).font(.system(size: 40)).background(Color.yellow) } HStack {  Text(&amp;#34;Left&amp;#34;).font(.system(size: 40)).background(Color.yellow)  Spacer().frame(width: 55)  Text(&amp;#34;Right&amp;#34;).font(.system(size: 40)).background(Color.yellow) } Using the Offset and Position Modifiers 堆栈中的Spacers、padding和alignment可以改变视图在页面上的位置。如果想以另一种方式页面上放置视图，还可以使用offset(偏移)修改器。偏移修改器可以指定一个特定x和y值，以将视图从正常的位置上移开。
下面的ZStack将两个相同的文本视图放在一起。由于两个文本视图出现在完全相同的位置，因此无法同时看到它们，即这两个文本视图是重叠的：
ZStack {  Text(&amp;#34;Top&amp;#34;).font(.system(size: 40)).background(Color.yellow)  Text(&amp;#34;Top&amp;#34;).font(.system(size: 40)).background(Color.yellow) } 如果我们为其中一个文本视图添加偏移修改器，则可以将看到两个视图了。下面的偏移修改器将把第二个文本视图从它正常出现的位置移动固定的距离：
ZStack {  Text(&amp;#34;Top&amp;#34;).font(.system(size: 40)).background(Color.yellow)  Text(&amp;#34;Top&amp;#34;).font(.system(size: 40)).background(Color.yellow).offset(x: 75, y: 125) }  ZStack {  Text(&amp;#34;Top&amp;#34;).font(.system(size: 40)).background(Color.yellow)  Text(&amp;#34;Top&amp;#34;).font(.system(size: 40)).background(Color.yellow).offset(x: -75, y: -125) } ZStack {  Text(&amp;#34;Top&amp;#34;).font(.system(size: 40)).background(Color.yellow)  Text(&amp;#34;Top&amp;#34;).font(.system(size: 40)).background(Color.yellow).offset(x: 75, y: 125)  Text(&amp;#34;Top&amp;#34;).font(.system(size: 40)).background(Color.yellow).offset(x: -75, y: -125) } 偏移修改器是根据正常放置的位置来移动视图。如果希望根据原点（屏幕左上角）放置一个视图，可以使用position修改器：
ZStack {  Text (&amp;#34;Top&amp;#34;)  .font(.system(size: 40))  .background(Color.yellow)  .position(x: 225, y: 127) } 如果在offset或position修改器中使用较大的x或y值时要特别小心，因为较大的值可能会在大屏幕上完美地放置视图，但在小屏幕上却会使同一视图偏离到屏幕外。
在任何视图中都可以使用offset和postion修改器。因为Stack也是视图，所以也可以在其上应用offset和position修改器，这样会移动里面的每个视图的位置：
VStack {  Text(&amp;#34;First&amp;#34;).font(.system(size: 40)).background(Color.yellow)  Text(&amp;#34;Second View&amp;#34;).font(.system(size: 40)).background(Color.yellow) }.offset(x: 25, y: 125) 不同的是offset偏移修改器会将整个VStack从其正常位置移开，而position修改器则根据原点（屏幕左上角）来放置VStack。下面代码使用了完全相同的x和y值，但在VStack上使用了position修改器：
VStack {  Text(&amp;#34;First&amp;#34;).font(.system(size: 40)).background(Color.yellow)  Text(&amp;#34;Second View&amp;#34;).font(.system(size: 40)).background(Color.yellow) }.position(x: 25, y: 125) 需要注意的是，因为position修改器是从原点开始移动VStack，但因为x值不够大，VStack里的内容会被屏幕截断。
Chapter 4 每个用户界面都需要在屏幕上显示信息，这些信息可以以各种形式出现。在用户界面上显示的一种常见信息是文本。如果要在用户界面上显示文本，就需要定义一个字符串来显示在文本视图中。
Text(&amp;#34;Hello World&amp;#34;) 为了提高灵活性，可以将字符串存储在变量或常量中，然后在文本视图中使用该字符串变量或常量:
let myString = &amp;#34;Displays a string variable&amp;#34; Text(myString) 字符串变量可以存储不同的字符串，使文本视图显示不同的文本。为了获得更大的灵活性，文本视图还可以使用字符串插值法显示非字符串数据:
let myString = 46 Text(&amp;#34;This is my age = \(myString)&amp;#34;) 字符串插值允许在非字符串数据出现在字符串中。最重要的是，字符串插值不需要将数据转换成字符串，因此这是在文本视图中显示数据的一种快速而简单的方法。
文本视图可以显示任意长度的字符串。不过，在屏幕上显示字符串的长度会因应用程序运行时的屏幕尺寸（如较大的iPad屏幕或较小的iPhone屏幕）而异。要自定义字符串的显示方式，SwiftUI允许定义以下内容：
 行限制：定义文本视图可显示的最大行数，如2或4行。 截断：如果无法显示整个字符串，定义如何截断字符串。  HStack {  let myString = 23  Text(&amp;#34;This is my age \(myString). Since I am retired, I am now eligible for a pension and Social Security so I can spend the rest of my life relaxing and enjoying life without having to work for an income anymore.&amp;#34;) } Spacer().frame(height: 10) HStack {  let myString = 23  Text(&amp;#34;This is my age \(myString). Since I am retired, I am now eligible for a pension and Social Security so I can spend the rest of my life relaxing and enjoying life without having to work for an income anymore.&amp;#34;).lineLimit(2) } 除了在代码中添加.lineLimit修改器，还可以在检查面板修改行限制。如下图所示，在Font下面，可以修改Line Limit的值：
如果定义了行数限制，并且将要显示的文本若超出了这个行数限制，那么文本将被截断。SwiftUI提供三种选项来截断超过行数限制的文本：
 .head：截断最后一行的开头。 .middle：截断最后一行的中间。 .tail：截断最后一行的末尾。  SwiftUI默认截断字符串最后一行的末尾，可以在代码中使用truncationMode修改器来改变截断模式。如下代码所示，在行限制修改器后面添加truncationMode修改器：
VStack {  Text(&amp;#34;This is my age \(myString). Since I am retired, I am now eligible for a pension and Social Security so I can spend the rest of my life relaxing and enjoying life without having to work for an income anymore.&amp;#34;).lineLimit(2).truncationMode(.head)  Spacer().frame(height: 12)  Text(&amp;#34;This is my age \(myString). Since I am retired, I am now eligible for a pension and Social Security so I can spend the rest of my life relaxing and enjoying life without having to work for an income anymore.&amp;#34;).lineLimit(2).truncationMode(.middle)  Spacer().frame(height: 12)  Text(&amp;#34;This is my age \(myString). Since I am retired, I am now eligible for a pension and Social Security so I can spend the rest of my life relaxing and enjoying life without having to work for an income anymore.&amp;#34;).lineLimit(2).truncationMode(.tail) } Changing the Appearance of Text 文本视图通常显示纯文本。为了美化文本外观，SwiftUI允许在Swift代码中键入修改器或通过检查器面板定义字体大小、粗细和颜色。字体大小选项包括特定的文本样式，可自动适应iPhone或iPad上定义的任何辅助功能设置。
 Large Title Title Title 2 Titile 3 Caption Caption 2 Healine Subheadline Callout Footnote Body  如果要为文本视图设置特定字体，可以使用自定义字体修改器：
Text(&amp;#34;New Font&amp;#34;).font(.custom(&amp;#34;Courier&amp;#34;, size: 36)) 在上面代码中，定义了字体族，然后是字体大小。请注意，Xcode可能不支持所有字体。如果只想定义字体大小，可以省略字体名称:
.font(.custom(&amp;#34;&amp;#34;, size: 36)) 定义自定义字体时，文本视图不会根据用户的iOS设置自动调整文本大小。因此，除非绝对需要，否则最好避免使用自定义字体。
除了字体大小，还可以设置字体权重，权重定义了文本显示时的粗细程度，权重选项包括以下几种：
 Heavy Semibold Bold Regular Thin Black Medium Light Ultra Light  修改文本外观的第三种方法是设置文本颜色。可以在Swift代码中键入颜色修改器，或从检查器面板中选择标准颜色，如红色、绿色或橙色：
Text(&amp;#34;New Font&amp;#34;).font(.custom(&amp;#34;Courier&amp;#34;, size: 36)).foregroundColor(.red) 可以选择标准颜色，如绿色、蓝色或黄色。如果不想使用标准颜色，也可以选择自定义颜色。选择自定义颜色选项后，会出现一个颜色对话框，让用户选择非标准颜色。此时可以选择不同的颜色值和不透明度值，从0（完全不可见）到1（完全可见）。
就像文字处理器一样，SwiftUI还可以使用斜体、粗体、下划线或删除线修改文本。要为文本添加这些效果，可以键入以下修改器命令：
.bold() .italic() .underline() .strikethrough() 也可以单击检查器面板中的添加修改器，然后搜索并选中弹出的修改器，而不是键入上面列出的修改器：
修改文本的另一种方法是定义文本的对齐方式。既可以在代码中添加multilineTextAlignment修改器，也可以在检查器面板中修改，文本视图共有三种对齐选项：
 Leading：文本在左边缘对齐。 Center：每行文字都居中显示在左右边缘之间。 Trailing：文本在右边缘对齐。  private let myString = 23 var body: some View {  VStack {  Text(&amp;#34;New Font&amp;#34;).font(.custom(&amp;#34;Courier&amp;#34;, size: 36)).foregroundColor(.red).bold()  Spacer().frame(height: 42)  Text(&amp;#34;This is my age \(myString). Since I am retired, I am now eligible for a pension and Social Security so I can spend the rest of my life relaxing and enjoying life without having to work for an income anymore.&amp;#34;).multilineTextAlignment(.leading)  Spacer().frame(height: 12)  Text(&amp;#34;This is my age \(myString). Since I am retired, I am now eligible for a pension and Social Security so I can spend the rest of my life relaxing and enjoying life without having to work for an income anymore.&amp;#34;).multilineTextAlignment(.center)  Spacer().frame(height: 12)  Text(&amp;#34;This is my age \(myString). Since I am retired, I am now eligible for a pension and Social Security so I can spend the rest of my life relaxing and enjoying life without having to work for an income anymore.&amp;#34;).multilineTextAlignment(.trailing)  } } Using the Label View 和Text视图相似的是Label视图，Text视图仅显示单行字符串文本，而Label视图可以同时显示文本和图片，如下图所示：
Label视图可使用Apple免费的SF Symbols应用程序中的任何图片。该应用程序可显示所有可用的系统图像。如果想要在Label视图中显示SF Symbol图片，可使用如下代码：
Label(&amp;#34;Text&amp;#34;, systemImage: &amp;#34;SF Symbol image name here&amp;#34;) 上面文本可以是任何字符串字面量或字符串变量。SF Symbol名称必须完全括在双引号内，如&amp;quot;creditcard&amp;quot;或 &amp;quot;banknote.fill&amp;quot;。
若要确保输入的SF Symbol图片名与SF Symbol应用程序中显示的名称完全一致，可以右键单击SF Symbol应用程序中的任何图标，在弹出菜单中选择复制名称。
如果想要使用自定义的图片，则需要先将它们拖放到工程的Assets文件夹中。如果想显示存储在Xcode工程中Assets文件夹中的图片，可以使用如下代码：
Label(&amp;#34;Text&amp;#34;, image: &amp;#34;image name here&amp;#34;) 文本可以是任何字符串或字符串变量，而图像名称必须与Assets文件夹中的图片文件名完全一致，但不包括文件扩展名。
在将图片添加到Xcode项目的Assets文件夹之前，可能需要调整图片的大小。否则，如果图片过大，Label视图将以原始大小显示图片，这可能远远超出我们的预期。
定义Label视图最简单方法是使用一个systemImage（来自SF Symbols库）或一个存储在Assets文件夹中的普通图片：
Label(&amp;#34;Text&amp;#34;, systemImage: &amp;#34;SF Symbol image name here&amp;#34;) Label(&amp;#34;Text&amp;#34;, image: &amp;#34;image name here from Assets folder here&amp;#34;) 如果想自定义Label视图中的文本或图片，可以使用下面代码创建Label视图：
VStack {  Label {  Text(&amp;#34;Alternate Label definition&amp;#34;)  } icon: {  Image(systemName: &amp;#34;SF Symbol image name here&amp;#34;)  }  Spacer().frame(height: 34)  Label {  Text(&amp;#34;Alternate Label definition&amp;#34;)  } icon: {  Image(&amp;#34;image name here&amp;#34;)  } } 使用Text和Image视图定义Label视图的时候，也可以为其中的每个视图自定义一些特性，例如为文本视图选择字体，为图像视图选择不透明度：
Label {  Text(&amp;#34;Modifiers&amp;#34;)  .font(.title) } icon: {  Image(systemName: &amp;#34;flag&amp;#34;)  .opacity(0.25) } 创建Label视图时，labelStyle修改器有三个选项：
  titleAndIcon（默认）
  titleOnly
  iconOnly
  VStack {  Label(&amp;#34;Text and icon&amp;#34;, systemImage: &amp;#34;hare.fill&amp;#34;)  Label(&amp;#34;Text Only&amp;#34;, systemImage: &amp;#34;hare.fill&amp;#34;).labelStyle(.titleOnly)  Label(&amp;#34;Icon Only&amp;#34;, systemImage: &amp;#34;hare.fill&amp;#34;).labelStyle(.iconOnly) } Adding a Border Around a Text or Label View 如果要突出显示文本和Label视图，可以在它们周围添加边框，边框可以由颜色和宽度组成：
Label {  Text(&amp;#34;Modifiers&amp;#34;)  .font(.title) } icon: {  Image(systemName: &amp;#34;flag&amp;#34;)  .opacity(0.25) }.border(Color.red, width: 3) 在Text或Label视图中使用.border修改器时，边框会紧紧包裹住文本：
如果不想在使用border紧紧包裹文本，可以先在视图周围添加padding:
Label {  Text(&amp;#34;Modifiers&amp;#34;)  .font(.title) } icon: {  Image(systemName: &amp;#34;flag&amp;#34;)  .opacity(0.25) }.padding(6).border(Color.red, width: 1) Chapter 5 多数用户界面都由文本组成，但仅显示文字可能会显得平淡无奇。在屏幕上显示的第二类常见信息是图片，图片可以起到装饰作用，也可以帮助用户浏览页面。
最常见的图像类型是图标。SF Symbols应用程序列出了所有可使用的图标。除了这些图标，还可以将图片拖放到Xcode项目下的Assets文件夹中。此外，还可以在用户页面上添加常见的几何形状，例如矩形、圆形、圆角矩形和椭圆等。
通过在屏幕上显示色彩鲜艳或信息丰富的图形，能为页面外观增色不少。在创建用户界面时，可以考虑添加图形图像，使页面在视觉上更吸引用户。
Displaying Shapes 最简单的图像就是常见的几何图形。几何图形可以单独使用，也可以将其放在其它类型视图（如文本视图）的背景中作装饰用，五种常见的几何图形如下：
 Capsule Circle Ellipse Rectangle Rounded rectangle(cornerRadius: x)  RoundedRectangle(cornerRadius: 16).frame(width: 100, height: 100).foregroundColor(.green) Capsule().frame(width: 300,height: 80).foregroundColor(.gray) Circle().frame(width: 100,height: 100).foregroundColor(.red) Rectangle().frame(width: 100,height: 100).foregroundColor(.accentColor) Ellipse().frame(width: 300,height: 100).foregroundColor(.purple) 要创建几何图形，只需说明形状名称，如Circle()。但圆角矩形是个例外，它需要一个角半径来定义边角的弯曲程度。半径值越小，边角越尖锐，半径值为0时，边角的弧度为90度，此时与普通矩形无异。角半径越大，圆角矩形就越像胶囊。有两种方式定义圆角矩形：
 By corner radius. By defining width and height of the curve.  用角半径定义圆角矩形需要一个数值。数值越小（如10），圆角就越小；数值越大（如100），矩形每个角曲线就越平滑：
RoundedRectangle(cornerRadius: 10) RoundedRectangle(cornerRadius: 100) 定义圆角矩形的第二种方法是定义圆角曲线的宽度和高度。宽度定义曲线沿X轴（水平方向）的长度，高度定义曲线沿 Y 轴（垂直方向）的大小。如下图所示，选择不同的宽度和高度值，可以为矩形创建形状不对称的圆角。
RoundedRectangle(cornerSize: CGSize(width: 100, height: 25)) Coloring a Shape 每个几何图形的默认颜色都是黑色，有时可能需要为图形选择不同颜色填充。如果要为几何形状添加颜色，可以像下面这样使用fill修改器：
Capsule().fill(Color.yellow) 如果不喜欢使用任何标准颜色（绿、红、黄、蓝等），也可以像下面这样使用红、绿、蓝值或色相、饱和度和亮度值定义自己的颜色：
Capsule().fill(Color(red: 1.0, green: 0.0, blue: 0.0, opacity: 1.0)) Ellipse().fill(Color(hue: 1.7, saturation: 2.9, brightness: 0.58)) 另外两种方式改变几何图形是：
 Opacity（不透明度） Shadows（阴影）  不透明度定义了几何图形透明程度，不透明度值越低，几何图形越接近透明，而不透明度值越高，图形越清晰。要为几何形状定义不透明度，只需在颜色后添加.opacity修改器：
Capsule().fill(Color(red: 1.0, green: 0.0, blue: 0.0, opacity: 1.0).opacity(1.0)) Capsule().fill(Color(red: 1.0, green: 0.0, blue: 0.0, opacity: 1.0).opacity(0.1)) 另一种改变几何图形外观的方法是使用阴影，阴影可以出现在几何图形的外边缘或内边缘。要使阴影显示在形状之外，可使用.shadow修改器并定义drop半径。drop半径值越大，阴影越大；drop半径值越小，阴影越小，但也更明显：
Rectangle().fill(Color.yellow.shadow(.drop(radius: 45))) 要使阴影显示在几何图形内部，可使用.shadow修改器并定义内半径。内半径越大，阴影越大，内半径越小，阴影越小。内部修改器如下所示:
Rectangle().fill(Color.yellow.shadow(.inner(radius: 45))) Coloring a Shape with Gradients 另一种添加颜色的方法是使用渐变，以不同的方式显示两种或多种颜色。SwiftUI提供三种类型的颜色渐变，如下所示：
 Linear gradients Radial gradients Angular gradients  线性渐变需要定义两种或多种颜色以及起点和终点。颜色存储在方括号中，颜色渐变的起点和终点可以使用如下位置之一：
  bottom
  bottomLeading
  bottomTrailing
  center
  leading
  top
  topLeading
  topTrailing
  trailing
  如果要创建颜色线性渐变，只需像下面这样定义两种或以上颜色以及线性渐变的起点和终点：
Capsule().fill(LinearGradient(gradient: Gradient(colors: [.blue, .green, .pink]), startPoint: .topLeading, endPoint: .bottomTrailing)) 径向渐变在中心参数（如 .center 或 .top）定义的特定位置绘制圆形颜色。如果选择.top这样的值，渐变中心将从形状的顶部中心开始:
Ellipse().fill(RadialGradient(gradient: Gradient(colors: [.blue,.yellow]), center: .top, startRadius: 10, endRadius: 65)) Ellipse().fill(RadialGradient(gradient: Gradient(colors: [.blue,.yellow]), center: .center, startRadius: 10, endRadius: 75)) Ellipse().fill(RadialGradient(gradient: Gradient(colors: [.blue,.yellow]), center: .center, startRadius: 10, endRadius: 25)) 线性渐变和径向渐变只需使用两种颜色即可，而角度渐变则需要使用更多的颜色。如果只为角度渐变定义了两种颜色，SwiftUI将并排显示这两种颜色，然后它们会逐渐合并：
Rectangle().fill(AngularGradient(colors: [.green,.blue], center: .center)) 在AngularGradient中定义的颜色越多，各种颜色就越能融合在一起。除了定义多种颜色外，还需要定义渐变的中心，如 .center或.bottomTrailing。要创建角度渐变，可定义多种颜色或多次定义相同颜色，并定义中心：
Rectangle().fill(AngularGradient(colors: [.green,.blue,.black,.green,.blue,.black,.green], center: .center)) Displaying Images 如文本视图可以在用户界面上显示文本一样，图像视图可在界面上显示图标和图形文件。如果要显示存储在SF Symbols应用程序中的图标，可以使用如下Swift代码：
Image(systemName: &amp;#34;hare.fill&amp;#34;) 显示SF Symbol图标时，必须使用systemName参数。因为系统图标通常很小，有时我们可能希望将图标放大，最简单方法是定义较大的字体，如.largeTitle 或.custom：
Image(systemName: &amp;#34;hare.fill&amp;#34;) Image(systemName: &amp;#34;hare.fill&amp;#34;).font(.largeTitle) Image(systemName: &amp;#34;hare.fill&amp;#34;).font(.custom(&amp;#34;&amp;#34;, size: 66)) 如果要显示一张图片，必须先将其拖放到Assets文件夹中。然后，要显示存储在Assets文件夹中的图片，可以使用Image视图，并像下面这样指定图像名称：
Image(&amp;#34;flag&amp;#34;) 图片可以是任何尺寸，但不管图片过大或过小，图像视图都将以原始尺寸显示。有时需要调整图片大小以适应用户界面，可以在图片视图中使用以下三个修改器:
 .resizable() .aspectRatio(contentMode: z) .frame(width: x, height: y)  .resizable()修改器可让图像视图改变显示图像的大小。如果图像视图缺少.resizable()修改器，那么无论图像视图的大小如何，图像都会保持其原始大小。
通过.frame(width: x, height: y)修改器，可以定义图像视图的大小。与.resizable()修改器一起使用时，.frame修改器可定义图像的固定宽度和高度。
因为拉伸Image视图的宽度和高度会扭曲内部显示的图像，因此.aspectRatio修改器可定义图像的反应方式。.fill选项可将图像扩展到.frame修改器定义的最大宽度或高度。而.fit 选项可将图像缩小到.frame修改器定义的最小宽度或高度。
Image(&amp;#34;flag&amp;#34;)  .resizable()  .aspectRatio(contentMode: .fill)  .frame(width: 150, height: 50) Image(&amp;#34;flag&amp;#34;)  .resizable()  .aspectRatio(contentMode: .fit)  .frame(width: 150, height: 50) 如果想要定义宽高比，可以使用如下方式：
Image(&amp;#34;flag&amp;#34;)  .resizable()  .frame(width: 150, height: 150)  .aspectRatio(0.5, contentMode: .fill) 除了使用.aspectRatio修改器和定义.fill或.fit的contentMode之外，Swift还提供了另外两种选择：
 .scaleToFill() .scaleToFit()  Image(&amp;#34;flag&amp;#34;)  .resizable()  .frame(width: 150, height: 150)  .scaledToFill()  Image(&amp;#34;flag&amp;#34;)  .resizable()  .frame(width: 150, height: 150)  .scaledToFit() Clipping Images 图像视图可以显示绘制的图片，也可以显示用数码相机拍摄的照片。通常，图形视图会在.frame修改器定义的矩形范围内显示任何图片。不过，为了创建更独特的视觉效果，可以使用.clipShape修改器将图片与几何图形叠加，从而达到剪辑图片的目的：
.clipShape(Circle()) 使用Ellipse()或Capsule()等其它几何图形时，需要确保frame的宽度足够大。如果frame的宽度和高度相同，那么Ellipse()和Capsule()形状看起来就像一个Circle()。下图显示了.clipShape(Circle()) 修改器如何改变原本显示为矩形的图像的外观。
Image(systemName: &amp;#34;hare.fill&amp;#34;).resizable().scaledToFill().frame(width: 150, height: 150).clipShape(Circle()) Adding Shadows to Images 另一种突出图像视图外观的方法是使用.shadow修改器，它可以在视图周围添加阴影。通过定义阴影的半径来调整阴影在视图周围出现的程度：
.shadow(color: .red, radius: 46, x: 0, y: 0) 修改器.shadow需要如下参数：
 Color：定义阴影的颜色。 Radius：定义阴影的半径。 X：定义阴影的水平偏移量。值为0时，阴影会在水平方向上围绕视图居中。 Y：定义阴影的垂直偏移量。值为0时，阴影会在垂直方向上围绕视图居中。  如果x和y值都不为0，则阴影会偏离图像视图。如果x值和y值都为0，则阴影会均匀地出现在图像视图四个边缘，如下图所示：
Adding a Border Around Images 更进一步的，如果想突出图像视图，可以使用.overlay修改器在其周围添加一个边框，如下所示：
.overlay(Rectangle().stroke(Color.blue, lineWidth: 10)) .overlay修改器需要以下参数：
 Shape：定义边框的形状以匹配图像视图的形状。 Color：定义边框的颜色。 lineWidth: 定义图像视图周围边框线的粗细。  Defining the Opacity of an Image 另一种修改图像外观的方法是不透明度。不透明度为0表示图像不可见。不透明度为1表示显示时没有任何变化。不透明度越接近0，图像就越模糊。不透明度越接近1，图像越清晰。要使用不透明度修改器，只需像这样定义一个从0到1的不透明度值：
.opacity(0.75) 如下图所示，通过改变不同视图的不透明度，可以在ZStack中将它们堆叠在一起，产生有趣的视觉效果：
Chapter 6 每个页面都向用户显示信息，不管这些信息是文本还是图像。用户界面的另一个功能是接受用户的指令，最简单方式就是使用按钮。按钮代表一条命令，这条命令可以是简单的确认，如确定或取消。要创建按钮，需要定义：
 The title that displays text on the button. Swift code that runs when the user taps the button.  SwiftUI给了两种方式创建按钮，最简单的方法是先定义要显示在按钮上标题文本，然后像下面这样定义用户点击按钮时要运行的Swift代码：
Button(&amp;#34;Click here&amp;#34;) {  debugPrint(&amp;#34;clicked Btn&amp;#34;) } 第二种创建按钮的方式是先定义点击时要运行的代码，再定义标题视图，这种方式能更灵活地修改按钮上文字外观：
Button {  debugPrint(&amp;#34;clicked Btn&amp;#34;) } label: {  Text(&amp;#34;This is a button&amp;#34;)  .font(.largeTitle)  .foregroundColor(.green)  .padding()  .border(Color.red, width: 6) } 除了使用Text视图定义按钮的标题，也可以使用Label视图展示文本和图标：
Button {  debugPrint(&amp;#34;clicked Btn&amp;#34;) } label: {  Label(&amp;#34;Image button&amp;#34;, systemImage: &amp;#34;hare.fill&amp;#34;)  .font(.largeTitle)  .foregroundColor(.purple)  .padding()  .border(Color.blue, width: 6) } 也可以使用Image视图让按钮只显示一个图片：
Button {  debugPrint(&amp;#34;clicked Btn&amp;#34;) } label: {  Image(&amp;#34;browncat&amp;#34;)  .resizable()  .frame(width: 150, height: 150)  .clipShape(Circle())  .overlay(Circle().stroke(Color.yellow, lineWidth: 4)) } Running Code in a Button 在点击按钮时可以运行任何代码，比较常见的代码是改变某个变量的状态。在SwiftUI中，可以像下面这样将特殊变量声明为状态变量：
@State var colorMe = false 普通变量更新数据时，程序中使用该变量的任何其它部分都不知道数据已经更新。要确保程序的每一部分都能接收到存储在变量中的数据更新，可能既繁琐又容易出错。因此，SwiftUI提供了状态变量来解决这个问题。
当改变一个状态变量的值时，任何使用该状态变量的东西都会自动获得存储在该状态变量中的最新数据，无需编写额外的代码。当一个变量持有一个值时，它处于一种状态，而当同一个变量持有一个不同的值时，它又处于另一种状态。SwiftUI状态变量可以自动确保程序的每一部分都知道变量值或状态的变化。
上面通过使用@State关键字创建了一个状态变量，变量声明 (var) 定义了变量名colorMe、数据类型（布尔类型）和初始值（false）。
Storing Code to Run in a User Interface View 当创建一个按钮或类似类型的视图与用户交互时，需要编写Swift代码使用户界面视图做出响应。最简单的是直接在定义交互视图的同一文件中编写代码：
Button(&amp;#34;Plain text button&amp;#34;) {  colorMe.toggle() } 当只有几行代码时，这样做没有问题。但是，如果需要存储几十行代码来定义视图如何响应用户，这就会使整个 .swift文件变得难以理解，因为这样的文件将由Swift代码组成，用于设计用户界面和响应用户操作。
与其在定义用户界面的代码中塞入多行代码，不如将这些代码存储在一个单独的函数中。这样，用户界面代码只需调用一行代码，如下所示：
Button(&amp;#34;Click Me&amp;#34;) { 	callMyFunction() }  func callMyFunction() {  colorMe.toggle()  debugPrint(colorMe) } Using a Segmented Control 一个按钮代表一个命令，如果要让用户在多个命令之间进行选择，就需要使用多个按钮。遗憾的是，在用户界面上放置多个按钮会非常麻烦。为了解决这个问题，SwiftUI提供了Segmented Control。
虽然Segmented Control理论上可以显示大量选项，但显示的选项越多，看起来就越杂乱。一般来说，如果一个Segmented Control包含过多选项，可以考虑使用另一种方式为用户提供多个选择，例如通过滚轮或菜单选择。
Segmented Control的主要理念是在一个小的空间内显示两个或多个选项，而不是使用多个按钮。要创建Segmented Control需要具备以下条件：
 A State variable to represent which segment (option) the user chose A Picker view that lists two or more options A tag property linked to each option The SegmentedPickerStyle modifier  Picker(&amp;#34;&amp;#34;, selection: $selectedItem) {  Text(&amp;#34;Fish&amp;#34;)  Text(&amp;#34;Tortoise&amp;#34;)  Text(&amp;#34;Hare&amp;#34;)  Text(&amp;#34;Bird&amp;#34;) }.pickerStyle(.segmented) 在Picker视图中放置多个Text视图可以定义显示的选项，但分段控件无法知道用户选择了哪个选项。如果使用多个文本视图定义Picker视图中的选项，则需要在每个文本视图后添加一个.tag 属性。
该.tag属性提供了代表分段控件上每个item的实际数据。.tag属性可以是任何数据类型（如字符串或 Int），但每个.tag属性都应包含相同的数据类型。
@State private var selectedColor = Color.gray  Picker(&amp;#34;Favorite Color&amp;#34;, selection: $selectedColor) {  Text(&amp;#34;red&amp;#34;).tag(Color.red)  Text(&amp;#34;green&amp;#34;).tag(Color.green)  Text(&amp;#34;blue&amp;#34;).tag(Color.blue)  Text(&amp;#34;black&amp;#34;).tag(Color.black) }.pickerStyle(.segmented) Rectangle().fill(selectedColor) 如果上面代码省略.pickerStyle(.segmented)，那么Picker视图会在菜单中显示3个选项，显示效果如下图所示：
使用多个文本视图来填充一个分段控件是可行的，但重复意味着可以简化。对于Picker视图，可以使用数组和ForEach循环代替多个文本视图，如下所示：
@State var selectedItem = &amp;#34;&amp;#34; let animalArray = [&amp;#34;Fish&amp;#34;, &amp;#34;Tortoise&amp;#34;, &amp;#34;Hare&amp;#34;, &amp;#34;Bird&amp;#34;]  Picker(&amp;#34;&amp;#34;, selection: $selectedItem) {  ForEach(animalArray, id: \.self) {  Text($0)  } }.pickerStyle(.segmented) Text(selectedItem) Running Code from a Segmented Control 在分段控件上点击选项，就能更改对应的状态变量。如果要根据用户在分段控件上选择的选项来运行代码，则需要添加一个.onChange修改器:
@State var selectedMsg = &amp;#34;&amp;#34;  Picker(&amp;#34;&amp;#34;, selection: $selectedMsg) {  ForEach(animalArray, id: \.self) {  Text($0)  } }.pickerStyle(.segmented)  .onChange(of: selectedMsg) { newValue in  switch newValue {  case &amp;#34;Fish&amp;#34;:  selectedMsg = &amp;#34;Clicked Fish&amp;#34;  case &amp;#34;Tortoise&amp;#34;:  selectedMsg = &amp;#34;Clicked Tortoise&amp;#34;  case &amp;#34;Hare&amp;#34;:  selectedMsg = &amp;#34;Clicked Hare&amp;#34;  case &amp;#34;Bird&amp;#34;:  selectedMsg = &amp;#34;Clicked Bird&amp;#34;  default:  break  }  } Text(selectedMsg) Chapter 7 在用户界面上通常需要用户输入文本信息。有时这些文本可能是一个单词或短语，但也可能是几个段落。为了让用户输入文本，SwiftUI提供了三种视图：
 Text Field Secure Field Text Editor  一个Text Field允许用户输入单行文本，如姓名或地址。Text Field可选择显示浅灰色的占位符文本，用于解释这个Text Editor希望输入的信息类型。
而Secure Field工作原理与Text Field完全相同，只是它屏蔽了用户输入的所有内容。这在要求用户输入敏感信息（如信用卡号）时非常有用。
Text Editor会显示一个大的输入框，用户可以在其中输入和编辑多行文本，如多个段落。由于Text Field、Secure Field和Text Editor都需要存储数据，因此，它们都需要使用可保存字符串数据类型的状态变量：
@State private var message = &amp;#34;&amp;#34; Using Text Fields 实际上Text Field的主要用途是接受用户输入的简短文本，可以是一个单词或一个短句。为了提醒用户输入预期的内容，Text Field可以显示浅灰色的占位符文本：
// 状态变量存储用户输入的字符串 @State var msg = &amp;#34;&amp;#34; VStack {  TextField(&amp;#34;placeholder text&amp;#34;, text: $msg)  Text(msg) } 当用户在TextField中输入内容时，输入的文本就会存储在传入的状态变量中。上面示例代码中，这个状态变量是msg，美元符号$表示该状态变量与该Text Field绑定。这意味着更改TextField的内容会自动更改该状态变量的值。
Defining Expandable Text Fields 虽然TextField用于接受简短的文本，如地址或电话号码，但用户实际上可以输入任意多的文本内容。当用户键入过多文本时，TextField会水平（默认的设置）或垂直展开。要定义一个可扩展的TextField，需要添加一个轴参数.horizontal或.vertical：
// 状态变量存储用户输入的字符串 @State var msg = &amp;#34;&amp;#34;  VStack {  TextField(&amp;#34;placeholder text&amp;#34;, text: $msg, axis: .horizontal).padding(.horizontal, 60)  Text(msg) } 当TextField水平展开时，用户可以继续输入，文本只会显示在一行上，直到滚动到看不见为止。当TextField垂直展开时，TextField的宽度保持不变，但高度会展开以显示多行文本:
当TextField垂直展开时，其高度会随着用户继续输入文本而不断扩展。如果要定义垂直展开的TextField可以具体显示多少行文本，可以使用.lineLimit修改器：
TextField(&amp;#34;Vertical&amp;#34;, text: $message, axis: .vertical).lineLimit(3) 上面代码限制TextField至多显示3行文本。在定义行数限制时，垂直展开的TextField仍可显示大量文本，但当用户继续键入时，文本将自动向上滚动并离开视线。使用.lineLimit修改器除了能限制固定行数，还可以定义限制的范围range:
.lineLimit(2...5)  // 状态变量存储用户输入的字符串 @State var msg = &amp;#34;&amp;#34; VStack {  TextField(&amp;#34;placeholder text&amp;#34;, text: $msg, axis: .vertical)  .lineLimit(1 ... 2).padding(.horizontal, 100)  .foregroundColor(.brown)  Text(msg) } 一个range的意思是TextField能扩展显示到最小的文本行数，直到达到最大的限制的行数就会自动滚动，超出的一部分会离开视线范围。例如，如果使用.lineLimit(2...5) 定义2到5行文本，TextField将扩展为2行文本。然后，如果用户继续添加更多文本，TextField就会扩展到显示三行文本，然后是四行，最后停在第五行。显示五行内容后，TextField将停止扩展，并滚动显示更多文字。
Changing the Text Field Style 让TextField更容易被用户理解的方式是使用灰色的占位符，占位提示让用户知道要输入什么以及在哪里输入。另一种方式是使用textFieldStyle修改器添加圆角边框：
TextField(&amp;#34;placeholder text&amp;#34;, text: $msg, axis: .horizontal)  .textFieldStyle(.roundedBorder)  .padding() // Structure creating a custom textFieldStyle struct WhiteBorder: TextFieldStyle {  func _body(configuration: TextField&amp;lt;Self._Label&amp;gt;) -&amp;gt; some View {  configuration.padding(8)  .overlay(RoundedRectangle(cornerRadius: 8).stroke(Color.red, lineWidth: 0.6))  } }  VStack {  TextField(&amp;#34;placeholder text&amp;#34;, text: $msg, axis: .vertical).lineLimit(1).padding(.horizontal, 100).textFieldStyle(WhiteBorder())  Text(msg) } Creating Secure Text Fields 在TextField输入文本时，文本就会显示在屏幕上。虽然这在大多数情况下都很方便，但在输入密码或信用卡号等敏感信息时就不合适了。为了屏蔽用户输入的文本，SwiftUI提供了一个名为SecureField的特殊的TextField。
VStack {  SecureField(&amp;#34;Password&amp;#34;, text: $msg)  .textFieldStyle(.roundedBorder)  .padding(.horizontal, 60)  Text(msg) } 在用户界面上，SecureField与TextField看起来完全一样。唯一不同的是，当在SecureField中键入文字时，它会屏蔽输入的所有内容。此外，所有能应用到TextField的修改器，都能应用到SecureField视图，例如.textFieldStyle。
Using Autocorrect and Text Content 默认情况下，TextField开启了自动纠错功能，这意味着输入时，TextField会尝试猜测将要输入的东西。在某些情况下，这可能会有所帮助。但当试图输入一个名字时，不希望自动更正将名字改成普通的单词。此时只要添加disableAutocorrection修改器：
.disableAutocorrection(true) 另一种方案是使用.textContentType修改器定义输入文本的类型，例如name，email address, telephone number等：
TextField(&amp;#34;Enter your email address&amp;#34;, text: $emailAddress) .textContentType(.emailAddress) 通过定义特定的.textContentType，将减少自动更正其提出的不相关建议的数量。不同的.textContentType修改器选项包括:
 .URL – For entering URL data .namePrefix – For entering prefixes or titles such as Dr. or Mr. .name – For entering names .nameSuffix – For entering suffixes to names such as Jr. .givenName – For entering a first name .middleName – For entering a middle name .familyName – For entering a family or last name .nickname – For entering an alternative name  Defining Different Keyboards 在iOS真机设备上，应用程序会显示虚拟键盘，用户可以点击键盘输入数字或字符。由于TextField可能需要某些类型的信息，例如姓名、数字或电子邮件地址，所以可以为用户界面上的每个TextField定义特定类型的虚拟键盘。TextField可显示的不同虚拟键盘包括：
 .default – The virtual keyboard that normally appears unless you specify otherwise .asciiCapable – Displays standard ASCII characters .numbersAndPunctuation – Displays numbers and punctuation marks .URL – Displays a keyboard optimized for URL entries .numberPad – Displays a numeric keypad for PIN entry .phonePad – Displays a keypad for entering telephone numbers .namePhonePad – Displays a keypad for entering a person’s name and telephone number .emailAddress – Displays a keyboard for typing email addresses .decimalPad – Displays a keyboard with numbers and a decimal point .twitter – Displays a keyboard for Twitter text entry .webSearch – Displays a keyboard for web search terms and URL entry .asciiCapableNumberPad – Displays a numeric pad that outputs only ASCII digits .alphabet – Displays a keyboard for alphabetic entry  TextField(&amp;#34;Enter name&amp;#34;, text: $message).keyboardType(.phonePad) 如果要查看虚拟键盘，必须在模拟器或iOS真机设备上测试。在模拟器中，可以通过选择I/O ➤ Keyboard ➤ Toggle Software Keyboard或按Command&#43;K来切换隐藏或显示虚拟键盘。需要注意的是，无法在画布面板中查看虚拟键盘。
Dismissing the Virtual Keyboard 当用户在TextField中输入内容时，虚拟键盘就会出现，当前页面也会自动向上滚动。但是，一旦输入完毕，就需要让虚拟键盘消失。
一种方式是使用.submitLabel修改器，它能定义一个特殊的键出现在键盘上。点击这个定义的键，能让虚拟键盘消失，.submitLabel修改器的样式如下所示：
.submitLabel(.done) 如果没有指定.submitLabel修改器，SwiftUI默认在虚拟键盘的右下角显示一个返回按钮。无论右下角的按键上出现什么标签，点击它都会使虚拟键盘消失。.submitLabel修改器可在虚拟键盘上放置的按钮类型包括：
 .continue – Adds a Continue button .done – Adds a Done button .go – Adds a Go button .join – Adds a Join button .next – Adds a Next button .return – Adds a Return button .route – Adds a Route button .search – Adds a Search button .send – Adds a Send button  Using a Text Editor TextField可让用户键入单词或短句，而TextEditor可让用户键入多行文本，就像文字处理器一样。当在用户界面上放置TextEditor时，它会扩展到填满所有可用空间。因此，最好使用.frame修饰符为TextEditor定义特定大小。
由于TextEditor可容纳多行文本，虚拟键盘右下角的按钮只是将光标移到下一行，并始终显示Return标签。因此，如果要在使用TextEditor时隐藏虚拟键盘，需要执行以下操作：
 Create a Focus State variable that represents a Boolean value. Add the .focused modifier to the Text Editor and use the Focus State variable. Create an additional control, such as a button, that sets the Focus State variable to false.  上面这种使用带有.focused修改符的和Focus状态变量和separate control的方法也适用于文本字段。
@FocusState var dismissKeyboard: Bool  TextEditor(text: $message)  .focused($dismissKeyboard)  .frame(width: 250, height: 150).padding()  Button(&amp;#34;Hide Keyboard&amp;#34;) {  dismissKeyboard = false } Chapter 8 Pickers可以显示多个选项，让用户选择其中一个，Picker能够确保用户只输入有效的数据。普通的Picker可让用户从一系列文本选项中进行选择。对于选择颜色或日期，SwiftUI还提供了特殊的颜色选择器和日期选择器。日期选择器还可以让我们定义有效的日期范围。选择器的目的就是确保用户在任何时候都只能向程序输入有效的数据。
Using a Picker 选择器显示由多个文本视图定义的选项列表。虽然选择器使用文本字符串显示可用选项，但用户选择的任何选项实际上都可以代表任何值，如字符串、十进制数、整数或枚举定义的值。而分段控件是选择器视图的一种特殊类。
为了创建选择器，可使用多个文本视图来显示选项，并为每个选项附加一个.tag修改器。实际上，.tag修改器定义了用户选择的实际值。
@State var choice = &amp;#34;one&amp;#34; Picker(&amp;#34;&amp;#34;, selection: $choice) {  Text(&amp;#34;1&amp;#34;).tag(&amp;#34;one&amp;#34;)  Text(&amp;#34;2&amp;#34;).tag(&amp;#34;two&amp;#34;)  Text(&amp;#34;3&amp;#34;).tag(&amp;#34;three&amp;#34;)  Text(&amp;#34;4&amp;#34;).tag(&amp;#34;four&amp;#34;)  Text(&amp;#34;5&amp;#34;).tag(&amp;#34;five&amp;#34;) } Text(&amp;#34;Choice = \(choice)&amp;#34;) 上面代码中，可选的项都是数字，当用户选择一个数字，实际存储的是字符串。文本视图中的.tag修改器可以包含任何数据类型，但同一个选择器里面的.tag修改器的数据类型必须一致，并且类型必须和定义的状态变量的类型一致。
@State var choice = 1 Picker(&amp;#34;&amp;#34;, selection: $choice) {  Text(&amp;#34;1&amp;#34;).tag(1)  Text(&amp;#34;2&amp;#34;).tag(2)  Text(&amp;#34;3&amp;#34;).tag(3)  Text(&amp;#34;4&amp;#34;).tag(4)  Text(&amp;#34;5&amp;#34;).tag(5) } Text(&amp;#34;Choice = \(choice)&amp;#34;) 默认情况下，选择器视图以菜单形式出现，但.pickerStyle修改器给定了三种不同方式显示选择器视图，三种选项的效果如下图所示：
 .pickerStyle(.menu) .pickerStyle(.wheel) .pickerStyle(.segmented)  Picker(&amp;#34;&amp;#34;, selection: $choice) {  Text(&amp;#34;1&amp;#34;).tag(1)  Text(&amp;#34;2&amp;#34;).tag(2)  Text(&amp;#34;3&amp;#34;).tag(3)  Text(&amp;#34;4&amp;#34;).tag(4)  Text(&amp;#34;5&amp;#34;).tag(5) }.pickerStyle(.menu) Picker(&amp;#34;&amp;#34;, selection: $choice) {  Text(&amp;#34;1&amp;#34;).tag(1)  Text(&amp;#34;2&amp;#34;).tag(2)  Text(&amp;#34;3&amp;#34;).tag(3)  Text(&amp;#34;4&amp;#34;).tag(4)  Text(&amp;#34;5&amp;#34;).tag(5) }.pickerStyle(.wheel) Picker(&amp;#34;&amp;#34;, selection: $choice) {  Text(&amp;#34;1&amp;#34;).tag(1)  Text(&amp;#34;2&amp;#34;).tag(2)  Text(&amp;#34;3&amp;#34;).tag(3)  Text(&amp;#34;4&amp;#34;).tag(4)  Text(&amp;#34;5&amp;#34;).tag(5) }.pickerStyle(.segmented) Displaying Options in a Picker 在选择器中显示选项的最直接方法是使用多个文本视图。如果选项数量较少，这种方法也行得通，但如果选项数量较多，尤其是使用.wheel样式显示选项时，使用ForEach循环从数组中检索选项通常会更方便。首先，创建一个数组，保存要在选择器视图中显示的所有选项，例如：
let myArray = [&amp;#34;Fish&amp;#34;, &amp;#34;Tortoise&amp;#34;, &amp;#34;Hare&amp;#34;, &amp;#34;Bird&amp;#34;] 然后，创建一个状态变量：
@State var selectedItem = &amp;#34;&amp;#34; 最后，创建使用ForEach循环的Picker视图：
Picker(&amp;#34;&amp;#34;, selection: $selectedItem) {  ForEach(myArray, id: \.self) {  Text($0)  } }.pickerStyle(.wheel) Populating a Picker with an Enumeration 数组是填充选择器视图的一种方法。另一种方法是取枚举中的所有case作为选项值。枚举可以定义自己的数据类型，并提供有限的选项列表。若要创建枚举，需要先定义枚举名称，然后定义其数据类型：
enum ColorItems: String, CaseIterable, Identifiable {  case rose  case grass  case sky  var id: Self {  self  } }  @State private var selectedColor1 = ColorItems.rose @State var myColor = Color.red  VStack {  Rectangle().fill(myColor)  Picker(&amp;#34;Favorite Color&amp;#34;, selection: $selectedColor1) {  ForEach(ColorItems.allCases, id: \.self) { catFood in  Text(catFood.rawValue.capitalized)  }  }.pickerStyle(.wheel)  .onChange(of: selectedColor1) { newValue in  switch newValue {  case ColorItems.rose:  myColor = Color.red  case ColorItems.grass:  myColor = Color.green  case ColorItems.sky:  myColor = Color.blue  }  } } Using the Color Picker 普通选择器可选择文本视图代表的不同选项。但是，如果想让用户选择一种特定的颜色，该怎么办呢？可以在选择器中列出几种颜色，但如果用户想选择一种自定义颜色呢？这时就可以使用颜色选取器。
颜色选择器可以让用户选择标准颜色，或者自定义颜色。用户可通过颜色选择器从网格、光谱或红、绿、蓝滑块中选择标准颜色（红、蓝、绿、黄等）或自定义颜色。
@State var myColor = Color.red  VStack {  ColorPicker(&amp;#34;Pick a color&amp;#34;, selection: $myColor).padding(30) } 颜色选择器不仅可以选择颜色，还可以选择不透明度。默认情况，不透明度是开启的，如果想要关闭不透明度，可以将supportsOpacity参数置为false:
VStack {  ColorPicker(&amp;#34;Pick a color&amp;#34;, selection: $myColor, supportsOpacity: false).padding(30) } Using the Date Picker 用户需要输入的一种常见数据类型是日期和时间。但是，某个用户可能把日期写成June 14, 2023，而另一个人可能把同一日期写成6/14/23。在输入时间时，可能会输入6:45 p.m，也可能会输入18:45。
为了方便用户输入日期和时间，SwiftUI提供了日期选择器。如下图所示，用户无需键入日期或时间，只需单击想要的日期或时间即可：
DatePicker(selection: $myDate, label: {  Text(&amp;#34;Date&amp;#34;) }) Choosing a Date Picker Style 默认情况下，日期选择器会将日期和时间显示为用户可以选择的字段。如果不喜欢日期选择器默认的紧凑模式，可以使用.datePickerStyle()修改器自定义日期选择器的外观：
 .compact: 日期和时间的默认显示方式。当用户选择日期时，就会出现类似.graphical样式的日历。当用户选择时间时，会以.wheel样式显示不同时间。 .graphical: 在日历中显示日期，但将时间作为一个field。当用户选择时间时，会以.wheel样式显示不同时间。 .wheel:以.wheel样式显示不同的日期和时间。  DatePicker(selection: $myDate, label: {  Text(&amp;#34;Date&amp;#34;) }).datePickerStyle(.wheel)  DatePicker(selection: $myDate, label: {  Text(&amp;#34;Date&amp;#34;) }).datePickerStyle(.graphical) Displaying a Date and/or Time 尽管日期选择器可以让用户同时选择日期和时间，但有时可能让用户只选择日期或者时间。为了限制日期选择器只显示日期或时间，可以设置displayedComponents参数：
DatePicker(selection: $myDate, displayedComponents: [.date]) {  Text(&amp;#34;Date&amp;#34;) } DatePicker(selection: $myDate, displayedComponents: [.hourAndMinute]) {  Text(&amp;#34;Time&amp;#34;) } Restricting a Date Range 当用户选择一个日期时，可能需要将其限制在有效日期内。例如，如果要询问某人的出生日期，那么让日期选择器允许用户选择1737年2月3日这样一个久远地离谱的日期是没有意义的。要限制日期选择器的日期范围，必须先定义开始和结束日期范围：
let dateRange1: ClosedRange&amp;lt;Date&amp;gt; = {  let calendar = Calendar.current  let startComponents = DateComponents(year: 2024, month: 1, day: 1)  let endComponents = DateComponents(year: 2024, month: 12, day: 31, hour: 23, minute: 59, second: 59)  return calendar.date(from: startComponents)! ... calendar.date(from: endComponents)! }()  let dateRange2: PartialRangeFrom&amp;lt;Date&amp;gt; = {  let calendar = Calendar.current  let startComponents = DateComponents(year: 2023, month: 1, day: 1)  return calendar.date(from: startComponents)!... }()  let dateRange3: PartialRangeThrough&amp;lt;Date&amp;gt; = {  let calendar = Calendar.current  let stopComponents = DateComponents(year: 2024, month: 1, day: 1)  return ...calendar.date(from: stopComponents)! }()  DatePicker(selection: $myDate, in: dateRange1, displayedComponents: [.date]) {  Text(&amp;#34;Date&amp;#34;) }.datePickerStyle(.graphical).padding() Formatting Dates 默认情况下，SwiftUI显示的日期会包含很多可能不想显示的详细信息。要显示特定格式的日期，可以使用 DateFormatter，如下所示：
let formatter = DateFormatter() 然后，可以定义一种样式来显示日期和时间:
   Style Date Time     .short 2/15/22 7:15 PM   .medium Feb 15, 2022 7:15:29 PM   .long February 15, 2022 7:15:29 PM CST   .full Tuesday, February 15, 2022 7:15:29 PM Central Standard Time    需要注意的是：地区不同可能会改变日期的实际显示方式，如15 June 2021或June 15 2021。为了使用日期样式，必须定义DateFormatter的dateStyle属性：
let formatter = DateFormatter() formatter.dateStyle = .medium formatter.timeStyle = .short 一旦定义了DateFormatter，并且设置了它的dateStyle和timeStyle属性。最后一步是使用这个formatter格式化日期：
formatter.string(from: myDate) 下面代码是使用formatter的示例：
@State var myDate = Date.now let formatter = DateFormatter()  VStack {  Text(&amp;#34;Chosen date = \(formatter.string(from: myDate))&amp;#34;).padding()  DatePicker(selection: $myDate) {  Text(&amp;#34;Date&amp;#34;)  }.onAppear() {  formatter.dateStyle = .full  formatter.timeStyle = .full  } } Creating a MultiDate Picker 普通的日期选择器只能让用户选择一个日期。如果想让用户一次选择多个日期，可以使用多日期选择器(MultiDatePicker)。MultiDatePicker允许用户选择多个日期，因此这些日期会存储在一组 DateComponents中，这意味着需要像下面这样创建一个状态变量：
@State var dates = Set&amp;lt;DateComponents&amp;gt;() 如果要创建MultiDatePicker，只需使用State变量来定义它，以存储所选的多个日期，如下所示：
MultiDatePicker(&amp;#34;Select Dates&amp;#34;, selection: $dates) VStack {  MultiDatePicker(&amp;#34;Select Dates&amp;#34;, selection: $dates)  Button(&amp;#34;Click Me&amp;#34;) {  for x in dates {  message &#43;= formatter.string(from: x.date!) &#43; &amp;#34;\n&amp;#34;  }  }  TextEditor(text: $message) }.onAppear {  formatter.dateStyle = .medium  formatter.locale = Locale(identifier: &amp;#34;en_US&amp;#34;) }.padding() Chapter 9 Toggle按钮可为用户提供两种选择，如开或关、是或否、真或假。由于Toggle按钮只提供两种选择，因此它代表一个布尔值（真或假）。
一个Stepper将用户输入限制在有效数据范围内。步进器会显示一个减号/加号图标，用户可以点击该图标，以固定的数量向上或向下递增/递减数值。通过使用步进器，用户无需输入具体数字即可定义数值。
滑块还可将用户输入限制在有效数据范围内。滑块可让用户拖动输入特定值，而无需输入任何内容。步进器和滑块都可以定义最小值和最大值，从而限制用户只能选择有效的数值。对许多人来说，点击或拖动选择一个数值比键入数字本身更容易。步进器和滑块都表示Double数值（十进制数）。
Using a Toggle 如果要创建一个Toggle按钮，需要先定义出现在Toggle按钮旁边的文本，并将类型为Bool的状态变量链接或绑定到Toggle按钮上:
@State var settingValue = false  Toggle(isOn: $settingValue) {  Text(&amp;#34;Toggle text&amp;#34;) } Using a Stepper Stepper步进器存储一个值，用户可以按固定增量（如1或2.5）递增。定义步进器时能够设置表示的最小值和最大值，例如1到10之间的范围。
此外，还可以定义步进器是否能够wrap。Wrapping是指步进器达到最大值后如果继续递增，它就会回到最小值。同样，如果不断递减步进器，使其低于最小值，它就会跳到最大值。这样，用户就可以轻松选择不同的值，而不必从一个极端值穷举到另一个极端值。
@State var newValue = 0  Stepper(value: $newValue) {  Text(&amp;#34;Stepper value = \(newValue)&amp;#34;) }.padding()  // https://www.simpleswiftguide.com/swiftui-stepper-tutorial-how-to-create-and-use-stepper-in-swiftui/ Stepper(&amp;#34;Stepper value: \(newValue)&amp;#34;, value: $newValue)  Stepper(onIncrement: {  print(&amp;#34;Stepper onIncrement&amp;#34;)  self.newValue &#43;= 1 }, onDecrement: {  print(&amp;#34;Stepper onDecrement&amp;#34;)  self.newValue -= 1 }) {  Text(&amp;#34;Stepper value: \(self.newValue)&amp;#34;) }  Stepper(value: $newValue) {  HStack {  Text(&amp;#34;Value: \(self.newValue)&amp;#34;)  Image(systemName: &amp;#34;dollarsign.circle&amp;#34;)  } } Defining a Range in a Stepper 如果想在步进器定义一个有效的范围，需要将范围传入：
Stepper(value: $newValue, in: 1...10) {  Text(&amp;#34;Stepper value = \(newValue)&amp;#34;) }.padding() Defining an Increment/Decrement Value in a Stepper 步进器的默认步长是1，但也可以自定义步长值:
Stepper(value: $newValue, in: 1...10, step: 2) {  Text(&amp;#34;Stepper value = \(newValue)&amp;#34;) }.padding()  Stepper(value: $newDouble, in: 1...10.0, step: 0.25) {  Text(&amp;#34;Stepper value =\(newDouble)&amp;#34;) }.padding() Using Sliders 和步进器相似，滑块让用户在不输入特定数字的情况下选择数值。步进器强制用户按固定值递增/递减数值，而滑块只需改变滑块的位置，就能让用户在一系列数值中快速做出选择。因此，滑块比步进器更适合让用户在广泛的数值范围内进行选择。
虽然滑块可以表示任何Double类型（小数）数据，但默认情况下，它的范围只是从0到1，其中最左边表示0，最右边表示1。
@State var sliderValue = 0.0  Text(&amp;#34;Slider value = \(sliderValue)&amp;#34;) Slider(value: $sliderValue)  Slider(value: $sliderValue, in: 0 ... 20) Text(&amp;#34;Current slider value: \(sliderValue, specifier: &amp;#34;%.2f&amp;#34;)&amp;#34;)  Slider(value: $sliderValue, in: 0 ... 20, step: 1)  .padding()  .accentColor(Color.red)  .border(Color.green, width: 1.0) Slider(value: $sliderValue, in: 0 ... 20, step: 1)  .padding()  .accentColor(Color.purple)  .overlay(  RoundedRectangle(cornerRadius: 15.0)  .stroke(lineWidth: 1.0)  .foregroundColor(Color.green)  ) Changing the Color of a Slider 默认情况下，一个Slider以蓝色显示已经滑动过的范围，如果想要改变颜色，需要使用.accentColor修改器：
Slider(value: $sliderValue).accentColor(.red) Defining a Range for a Slider 滑块默认的范围是从0到1，如果想定义一个不同的范围，可以传入range参数到形参in。下面代码定义了滑块的最小值为1，最大值为50:
Slider(value: $sliderValue, in: 1...10).accentColor(.red) Defining a Step Increment for a Slider 如果Slider的范围值大于1，拖动滑块会使其递增/递减1。 若要为滑块定义一个不同的递增/递减值，需要定设置 step:参数的值:
Slider(value: $sliderValue, in: 1 ... 50, step: 4) Displaying Minimum and Maximum Labels on a Slider 为了使Slider更容易被理解，可以在两端显示表示最小值和最大值的label。这样，就可以清楚地知道滑块的最小值和最大值：
Text(&amp;#34;Slider value = \(sliderValue)&amp;#34;) Slider(value: $sliderValue, in: 1 ... 50, step: 4) {  Text(&amp;#34;Slider&amp;#34;) } minimumValueLabel: {  Text(&amp;#34;1&amp;#34;) } maximumValueLabel: {  Text(&amp;#34;50&amp;#34;) }.accentColor(.red).padding() Chapter 10 曾几何时，应用程序只需要通过按钮让用户选择命令。随着iPhone和iPad应用程序开始变得越来越复杂，让用户选择命令的其他方式的需求也随之增加。链接和菜单是显示命令供用户选择的两种常见方式。
链接与按钮相似，只是它能打开浏览器显示网站内容。如下图所示，菜单可显示一个选项列表，其中还可内嵌子菜单选项：
Using Links 链接提供了一种便捷的方式让用户在应用程序中访问网站，链接定义时需要一个网站地址，链接中的文本视图定义链接上显示的文本。可以在文本视图中添加任何修改器，例如定义字体或背景颜色：
Link(destination: URL(string: &amp;#34;https://www.baidu.com&amp;#34;)!) {  Text(&amp;#34;baidu&amp;#34;) } 要测试链接是否成功加载网站地址，需要在模拟器或实际的iOS真机设备上测试。画布面板无法像模拟器或iOS设备那样打开Safari浏览器。
Using ShareLinks 普通链接的作用类似于超链接，可将用户带至特定网页。如下图所示，&amp;ldquo;共享链接&amp;quot;可让用户点击链接，显示共享表单，为用户提供复制数据或与其他应用程序共享数据的选项。
ShareLink(item: &amp;#34;This text will be shared&amp;#34;) ShareLink(item: URL(string: &amp;#34;https://www.apple.com&amp;#34;)!) Customizing a ShareLink 与其显示默认的共享图标和文字share...，也可以自定义分享链接的文本和图标。如果要在ShareLink上显示自定义文本，必须像下面这样创建了一个 ShareLink：
ShareLink(&amp;#34;Custom text here&amp;#34;, item: URL(string: &amp;#34;https://www.apple.com&amp;#34;)!) 如果不想显示默认的分享图标，需要使用文本视图定义要显示在 ShareLink中的文本，如下所示：
ShareLink(item: &amp;#34;This text will be shared&amp;#34;) {  Text(&amp;#34;Custom ShareLink text&amp;#34;) } 上面的分享链接不会显示图标，并且只是简单的显示Custom ShareLink text。如果想要显示图标，并且不显示文本，可以只使用Image视图:
ShareLink(item: &amp;#34;ShareLink example&amp;#34;) {  Image(systemName: &amp;#34;tortoise&amp;#34;) } 上面代码的ShareLink显示一个龟图标。在定义ShareLink时可以使用Label自定义文字，使用Image自定义图标：
ShareLink(item: &amp;#34;ShareLink example&amp;#34;) {  Label {  Text(&amp;#34;Custom ShareLink text&amp;#34;)  } icon: {  Image(systemName: &amp;#34;hare&amp;#34;)  } } Using Menus 有时，可能希望为用户提供多种选择。在屏幕上放置多个按钮可能会显得笨拙，即使使用分段控制也可能过于局限。如果需要在狭小的空间内显示多个选项，这时就可以使用菜单。
菜单在用户界面上显示为一个按钮。当用户点击它时，菜单会显示一个选项列表。现在，用户可以点击某个选项或打开其它子菜单，查看更多选项。菜单可以在有限的空间内轻松隐藏多个选项。
Menu(&amp;#34;Options&amp;#34;) {  Button(&amp;#34;Open &amp;#34;, action: openFile)  Button(&amp;#34;Find&amp;#34;, action: findFile)  Button(&amp;#34;Delete...&amp;#34;, action: deleteFile) } Text(message).padding()  func openFile() {  message = &amp;#34;Open chosen&amp;#34; } func findFile() {  message = &amp;#34;Find chosen&amp;#34; } func deleteFile() {  message = &amp;#34;Delete chosen&amp;#34; } 需要注意的是，菜单中的每个按钮都会调用由action参数定义的一个函数。与其调用一个已定义的函数，不如将一个或多个命令放在大括号中：
Menu(&amp;#34;Options&amp;#34;) {  Button(&amp;#34;Open&amp;#34;) {  message = &amp;#34;Open File&amp;#34;  }  Button(&amp;#34;Find&amp;#34;) {  message = &amp;#34;Find File&amp;#34;  }  Button(&amp;#34;Delete...&amp;#34;) {  message = &amp;#34;Delete File&amp;#34;  } } Text(message).padding() Formatting Titles on the Menu and Buttons 菜单可以自定义标题，使得它看起来就像一个标准的按钮。不过，如果想格式化标题，还有另一种定义菜单的方法，即可以定义一个label参数，在该参数中可以使用文本或标签视图：
Menu {  Button(&amp;#34;Open&amp;#34;) {  message = &amp;#34;Open File&amp;#34;  }  Button(&amp;#34;Find&amp;#34;) {  message = &amp;#34;Find File&amp;#34;  }  Button(&amp;#34;Delete...&amp;#34;) {  message = &amp;#34;Delete File&amp;#34;  } } label: {  Text(&amp;#34;Options&amp;#34;).font(.largeTitle).foregroundColor(.purple).italic() } Text(message).padding()   Menu {  Button(&amp;#34;Open&amp;#34;) {  message = &amp;#34;Open File&amp;#34;  }  Button(&amp;#34;Find&amp;#34;) {  message = &amp;#34;Find File&amp;#34;  }  Button(&amp;#34;Delete...&amp;#34;) {  message = &amp;#34;Delete File&amp;#34;  } } label: {  Label(&amp;#34;Options&amp;#34;, systemImage: &amp;#34;pencil.circle&amp;#34;) } Text(message).padding() 也可以使用标签视图而不是文本视图来定义按钮标题：
Menu {  Button {  message = &amp;#34;Open File&amp;#34;  } label: {  Label(&amp;#34;Open&amp;#34;, systemImage: &amp;#34;book&amp;#34;)  }  Button {  message = &amp;#34;Find File&amp;#34;  } label: {  Label(&amp;#34;Find&amp;#34;, systemImage: &amp;#34;magnifyingglass&amp;#34;)  }  Button {  message = &amp;#34;Delete File&amp;#34;  } label: {  Label(&amp;#34;Delete&amp;#34;, systemImage: &amp;#34;trash&amp;#34;)  } } label: {  Label(&amp;#34;Options&amp;#34;, systemImage: &amp;#34;pencil.circle&amp;#34;) } Text(message).padding() Adding a Submenu 一个菜单可以显示一系列用按钮定义的可选择项。但是，菜单中也可以内嵌子菜单：
Menu {  Button {  message = &amp;#34;Open File&amp;#34;  } label: {  Label(&amp;#34;Open&amp;#34;, systemImage: &amp;#34;book&amp;#34;)  }  Button {  message = &amp;#34;Find File&amp;#34;  } label: {  Label(&amp;#34;Find&amp;#34;, systemImage: &amp;#34;magnifyingglass&amp;#34;)  }  Button {  message = &amp;#34;Delete File&amp;#34;  } label: {  Label(&amp;#34;Delete&amp;#34;, systemImage: &amp;#34;trash&amp;#34;)  }  Menu(&amp;#34;Submenu&amp;#34;) {  Button(&amp;#34;Copy Format&amp;#34;) {  message = &amp;#34;Copy Format&amp;#34;  }  Button(&amp;#34;Paste Format&amp;#34;) {  message = &amp;#34;Paste Format&amp;#34;  }  } } label: {  Label(&amp;#34;Options&amp;#34;, systemImage: &amp;#34;pencil.circle&amp;#34;) } Text(message).padding() 可以在子菜单中内嵌子菜单。一般来说，只使用一级子菜单，否则过多的内嵌选项列表会让用户感到困惑。
Chapter 11 用户通过buttons、toggles、menu控制应用程序非常方便，但所有这些控制都会占用屏幕空间。为了消除在用户界面上添加额外对象，应用程序还可以检测和响应触摸手势，以便直接操作屏幕上显示的视图。iOS应用程序可以检测和响应的不同类型的触摸手势：
 Tap – A fingertip touches the screen and lifts up. Spatial tap – One or more fingertips touching the screen and reporting the tap location. Pinch – Two fingertips come together or move apart. Rotation – Two fingertips rotate left or right in a circular motion. Pan – A fingertip slides in a dragging motion across the screen. Swipe – A fingertip slides up, down, left, or right across the screen and lifts up. Long press – A fingertip touches and presses down on the screen.  可以对任何视图（如图像视图、文本视图或矩形或椭圆形等形状）应用触摸手势。
Detecting Tap Gestures 点击手势只需检测用户点击屏幕的时间。默认情况下，轻点手势只识别一个指尖的单次轻点，但也可以定义两个或多个指尖的多次轻点。
Rectangle().frame(width: 175, height: 125)  .foregroundColor(changeMe ? .red : .yellow)  .onTapGesture {  changeMe.toggle()  } Detecting Spatial Tap Gestures 空间点击手势与普通的点击手势类似，但它能检测一个或多个点击的位置。要检测轻点位置，需要一个可以存储CGPoint数据类型的状态变量，然后定义一个空间点击手势检测位置：
@State var tapLocation: CGPoint = .zero var spatialTapGesture: some Gesture {  SpatialTapGesture().onEnded { event in  tapLocation = event.location  } } 上面代码中event.location检测点击手势的位置，并将位置信息存储在状态变量tapLocation中。一旦检测到点击位置，就可以根据用户点击的区域做出响应。默认情况下，空间点击手势只检测单次点击，但可以通过设置计数参数来定义需要多少次点击：
@State var tapLocation: CGPoint = .zero let dimension: CGFloat = 360 var spatialTapGesture: some Gesture {  SpatialTapGesture(count: 2).onEnded { event in  tapLocation = event.location  } }  VStack {  Rectangle().foregroundStyle(tapLocation.y &amp;gt; dimension / 2.0 ? Color.orange : Color.purple)  .overlay(Text(&amp;#34;Tap Me&amp;#34;).font(.largeTitle).foregroundColor(tapLocation.x &amp;gt; dimension / 2.0 ? Color.black : Color.white))  .frame(width: dimension, height: dimension).gesture(spatialTapGesture)  Text(&amp;#34;Tap x location = \(tapLocation.x)&amp;#34;)  Text(&amp;#34;Tap y location = \(tapLocation.y)&amp;#34;)  Text(message).padding() } Detecting Long Press Gestures 当用户用一个或多个指尖在屏幕上按压固定时间，并且指尖不会移动太远时，就会出现长按手势。要定义长按手势，可以修改以下属性：
 minimumDuration:定义一个或多个指尖必须按住屏幕多长时间才能识别长按操作。 maximumDistance:定义在长按手势失败前指尖可移动的距离。  Text(message).padding() Rectangle().frame(width: 175, height: 125)  .foregroundColor(changeMe ? .red : .yellow)  .onLongPressGesture(minimumDuration: 2, maximumDistance: 2, pressing: { stillPressed in  message = &amp;#34;Long press in progress: \(stillPressed)&amp;#34;  }) {  changeMe.toggle()  }   VStack {  Rectangle().frame(width: 175, height: 125)  .foregroundColor(changeMe ? .red : .yellow)  .onLongPressGesture(minimumDuration: 2, maximumDistance: 2) { stillPressed in  message = &amp;#34;Long press in progress: \(stillPressed)&amp;#34;  } perform: {  changeMe.toggle()  }  Text(message) } Detecting Magnification Gestures 放大手势（也称为捏合手势）是指用户将两个指尖放在屏幕上，然后将指尖分开或靠近屏幕。这种手势通常发生在用户想要放大图像或缩小图像以查看更多内容（如放大地图）时。
因为放大手势会改变视图的大小，因此需要定义两个状态变量，分别表示当前大小和最终大小的CGFloat数据类型：
@State private var tempValue: CGFloat = 0 @State private var finalValue: CGFloat = 1 要调整视图的大小，放大手势需要与要调整视图大小的.scaleEffect修改器配合使用:
Image(systemName: &amp;#34;star.fill&amp;#34;)  .font(.system(size: 200))  .foregroundColor(.green)  .scaleEffect(finalValue &#43; tempValue) 然后，需要将.gesture修改器附加到要使用放大手势调整大小的视图上，像下面这样：
Image(systemName: &amp;#34;star.fill&amp;#34;)  .font(.system(size: 200))  .foregroundColor(.green)  .scaleEffect(finalValue &#43; tempValue)  .gesture(  MagnificationGesture()  .onChanged { amount in  // Code to run  }.onEnded { amount in  // Code to run  }  ) .onChanged修改器用于测量用户将两个指尖分开或靠近的距离。.onEnded修改器用于测量当用户将两个指尖抬离屏幕以结束放大手势时，两个指尖之间的距离。
Image(systemName: &amp;#34;star.fill&amp;#34;)  .font(.system(size: 200))  .foregroundColor(.green)  .scaleEffect(finalValue &#43; tempValue)  .gesture(  MagnificationGesture()  .onChanged { amount in  tempValue = amount - 1  }.onEnded { amount in  finalValue &#43;= tempValue  tempValue = 0  }  ) Detecting Rotation Gestures 旋转手势与放大手势类似，因为它们都使用两个指尖。主要区别在于，旋转手势会检测两个指尖是顺时针还是逆时针的圆周运动。由于旋转手势会改变视图的角度，因此需要定义一个状态变量，以Double类型来测量旋转角度，像下面这样：
@State private var degree = 0.0 为了旋转一个视图，旋转手势必须和.rotationEffect修改器一起：
Image(systemName: &amp;#34;star.fill&amp;#34;)  .font(.system(size: 200))  .foregroundColor(.green)  .rotationEffect(Angle.degrees(degree))  .gesture(  RotationGesture().onChanged({ angle in  degree = angle.degrees  })  ) Detecting Drag Gestures 当用户在屏幕上按下并滑动指尖时，就会出现拖动手势。拖动手势通常会将屏幕上的项目移动到新的位置。由于拖动手势会改变视图的位置，因此需要定义一个状态变量，将此位置作为CGPoint来测量，就像这样：
@State private var circlePosition = CGPoint(x: 50, y: 50) 要移动视图，拖动手势需要与要移动的视图上的.position修改器配合使用：
@State private var circleLabel = &amp;#34;50, 50&amp;#34; @State private var circlePosition = CGPoint(x: 50, y: 50)  Text(circleLabel).padding() Circle().fill(Color.blue)  .frame(width: 100, height: 100)  .opacity(0.8)  .position(circlePosition)  .gesture(DragGesture().onChanged({ value in  circlePosition = value.location  circleLabel = &amp;#34;\(Int(value.location.x)), \(Int(value.location.y))&amp;#34;  })) Defining Priority and Simultaneous Gestures 可以为任何视图添加触摸手势。由于Stack也是视图，因此也可以为VStacks、HStacks和ZStacks添加触摸手势。如果在堆栈内的视图中添加一个手势，然后为堆栈本身添加第二个相同的手势，哪个手势会被识别？
当一个手势添加到整个Stack时，堆栈中的每个视图都能识别该手势。但是，如果堆栈中的某个视图有自己的手势修改器，则该手势修改器将被优先识别。
VStack {  Text(message).padding()  Circle().frame(width: 125, height: 125)  .foregroundColor(.blue).onTapGesture {  message = &amp;#34;Circle tapped&amp;#34;  }  Spacer() }.background(Color.yellow).onTapGesture {  message = &amp;#34;VStack tapped&amp;#34; } Defining a High-Priority Gesture Stack内视图的手势总是比整个堆栈的手势更优先被识别。如果想让堆栈的手势修改器代替堆栈内视图的手势修改器运行，则需要使用.highPriorityGesture修改器。
VStack {  Text(message).padding()  Circle().frame(width: 125, height: 125)  .foregroundColor(.blue).onTapGesture {  message = &amp;#34;Circle tapped&amp;#34;  }  Spacer() }.background(Color.yellow).highPriorityGesture(  TapGesture().onEnded { _ in  message = &amp;#34;VStack tapped&amp;#34;  }) Defining Simultaneous Gestures 通常情况下，添加到单个视图的手势修改器将代替添加到堆栈的任何手势修改器运行。如果使用 .highPriorityGesture手势修改器，就可以让堆栈的手势代替单个视图的任何手势修改器运行。但是，如果希望同时运行视图上的手势和堆栈上的手势，该怎么办呢？
实际上，可以使用.simultaneousGesture修改器确保堆栈的手势修改器与附加到单个视图的手势修改器同时运行。要定义同时运行的手势，请将通常会被忽略的手势包含在.simultaneousGesture修改器中：
VStack {  Text(message).padding()  Circle().frame(width: 125, height: 125)  .foregroundColor(.blue).onTapGesture {  message &#43;= &amp;#34; Circle tapped&amp;#34;  }  Spacer() }.background(Color.yellow).simultaneousGesture(  TapGesture().onEnded { _ in  message = &amp;#34;VStack tapped&amp;#34;  }) Chapter 12 几乎每个应用程序都需要显示和接受来自用户的数据。显示数据的最简单方法是文本视图，但有时需要显示数据并让用户做出反应。在这种情况下，可以使用Alert或Action Sheet。向用户显示选项的另一种方式是contextual menus。
Displaying an Alert/Action Sheet 每个用户界面都需要向用户回显数据。在某些情况下，这些数据可以只显示在Label中，但有时需要确保用户看到某些信息。在这种情况下，应该使用alert controller。
Alert/Action Sheet显示在应用程序的用户界面上，可通过更改以下属性进行自定义：
 Title: 出现在顶部的文本，通常为粗体，字体较大。 Message: 标题下方的文字，字体较小。 One or more buttons: 可解除Alert/Action Sheet的按钮。  @State var showAlert = false  Button(&amp;#34;Show Alert&amp;#34;) {  showAlert.toggle() }.alert(isPresented: $showAlert) {  Alert(title: Text(&amp;#34;Warning!&amp;#34;), message: Text(&amp;#34;Zombies on the loose&amp;#34;), dismissButton: .default(Text(&amp;#34;OK&amp;#34;))) } 一个Alert最多可显示两个按钮，分别为primaryButton和secondaryButton。
Button(&amp;#34;Show Alert&amp;#34;) {  showAlert.toggle() }.alert(isPresented: $showAlert) {  Alert(title: Text(&amp;#34;Warning!&amp;#34;), message: Text(&amp;#34;Zombies on the loose&amp;#34;), primaryButton: .default(Text(&amp;#34;Default&amp;#34;)), secondaryButton: .cancel(Text(&amp;#34;Cancel&amp;#34;))) } 而一个Action Sheet最多可以显示三个按钮。对于要显示的每个按钮，可以从下面三种样式中选择一种：
 .default：以蓝色显示文本。 .destructive：以红色显示文本。 .cancel：以粗体显示文本。  Button(&amp;#34;Show Alert&amp;#34;) {  showAlert.toggle() }.actionSheet(isPresented: $showAlert) {  ActionSheet(title: Text(&amp;#34;Warning!&amp;#34;), message: Text(&amp;#34;Zombies on the loose&amp;#34;), buttons: [.default(Text(&amp;#34;Default&amp;#34;)), .cancel(Text(&amp;#34;Cancel&amp;#34;)), .destructive(Text(&amp;#34;Destructive&amp;#34;))]) } Making Alert/ActionSheet Buttons Responsive 只需将按钮添加到Alert或Action Sheet中，当用户选择其中任何一个按钮时，就会自动退出Alert或Action Sheet。最常见的情况是，点击某个按钮后执行一些操作。为此，首先创建一个函数，其中包含用户选择特定按钮时要运行的代码。然后，在用户选择按钮时调用该函数。
Button(&amp;#34;Show Alert&amp;#34;) {  showAlert.toggle() }.alert(isPresented: $showAlert) {  Alert(title: Text(&amp;#34;Warning!&amp;#34;), message: Text(&amp;#34;Zombies on the loose&amp;#34;),  primaryButton: .default(Text(&amp;#34;Default&amp;#34;), action: {  message = &amp;#34;Default chosen&amp;#34;  }), secondaryButton: .cancel(Text(&amp;#34;Cancel&amp;#34;), action: cancelFunction)) } Text(message).padding()  func cancelFunction() {  message = &amp;#34;Cancel chosen&amp;#34; } Button(&amp;#34;Show Alert&amp;#34;) {  showAlert.toggle() }.actionSheet(isPresented: $showAlert) {  ActionSheet(title: Text(&amp;#34;Warning!&amp;#34;), message: Text(&amp;#34;Zombies on the loose&amp;#34;),  buttons: [.default(Text(&amp;#34;Default&amp;#34;), action: {  message = &amp;#34;Default chosen&amp;#34;  }), .cancel(Text(&amp;#34;Cancel&amp;#34;), action: cancelFunction),  .destructive(Text(&amp;#34;Destructive&amp;#34;), action: {  message = &amp;#34;Destructive chosen&amp;#34;  })]) } Text(message).padding()  func cancelFunction() {  message = &amp;#34;Cancel chosen&amp;#34; } Displaying TextFields in an Alert Alert可以显示一个或多个TextField，使用TextField可以让用户输入数据。然后，Alert可以获取用户在TextFields中输入的数据，并将其传递给程序的另一部分。
@State private var username = &amp;#34;&amp;#34; @State private var password = &amp;#34;&amp;#34;  Button(&amp;#34;Show Alert&amp;#34;) {  showAlert.toggle() }.alert(&amp;#34;Login&amp;#34;, isPresented: $showAlert) {  TextField(&amp;#34;Username&amp;#34;, text: $username)  SecureField(&amp;#34;Password&amp;#34;, text: $password)  Button(&amp;#34;Login&amp;#34;) {  message = &amp;#34;login&amp;#34;  }  Button(&amp;#34;Cancel&amp;#34;, role: .cancel) {  message = &amp;#34;cancel&amp;#34;  } } message: {  Text(&amp;#34;Please enter your username and password.&amp;#34;) } Using Contextual Menus Contextual Menu能够在用户界面上隐藏多个选项。只有在检测到某个视图（如文本视图）上的长按手势后它才会出现。当上下文菜单列出选项时，用户可以选择其中一个。
Rectangle().foregroundColor(myColor) Text(&amp;#34;Pick a color&amp;#34;).padding().contextMenu(menuItems: {  Button(&amp;#34;Red&amp;#34;) {  myColor = Color.red  }  Button(&amp;#34;Purple&amp;#34;) {  myColor = .purple  }  Button(&amp;#34;Green&amp;#34;) {  myColor = .green  }  Button(&amp;#34;Orange&amp;#34;) {  myColor = .orange  } })   Rectangle().foregroundColor(myColor) Text(&amp;#34;Pick a color&amp;#34;).padding().contextMenu {  Button(&amp;#34;Red&amp;#34;) {  myColor = Color.red  }  Button(&amp;#34;Purple&amp;#34;) {  myColor = .purple  }  Button(&amp;#34;Green&amp;#34;) {  myColor = .green  }  Button(&amp;#34;Orange&amp;#34;) {  myColor = .orange  } } Chapter 13 向用户显示大量相关数据的一种常用方法是列表（也称为表视图）。列表只是简单地显示垂直堆叠的多行类似类型的数据。最简单的列表类型定义了一个或多个文本视图，它们分别显示在不同的行中。
List {  Text(&amp;#34;Cat&amp;#34;)  Text(&amp;#34;Dog&amp;#34;)  Text(&amp;#34;Bird&amp;#34;)  Text(&amp;#34;Reptile&amp;#34;)  Text(&amp;#34;Fish&amp;#34;) } 如果列表包含的元素一屏显示不了，用户可以上下滑动查看所有数据。需要注意的是，这种滚动功能不需要任何额外的编码。
创建列表时，可以使用多个文本视图，但如果要显示大量可能随时间增长或缩小的项目，手动键入多个文本视图是比较麻烦的。相反，可能需要使用循环来检索数据，并将其显示在List中的文本视图中。
VStack {  List {  ForEach(1 ... 25, id: \.self) { index in  Text(&amp;#34;Animal #\(index)&amp;#34;)  }  } } Displaying Array Data in a List 列表中数据通常存储在一个数组中。数组中的元素个数可以是固定的，但更常见的情况是元素个数会随时间发生变化。这意味着列表的内容可能会随着数组元素的增加和减少而变化。
var myArray = [&amp;#34;Cat&amp;#34;, &amp;#34;Dog&amp;#34;, &amp;#34;Turtle&amp;#34;, &amp;#34;Ferret&amp;#34;, &amp;#34;Parrot&amp;#34;,&amp;#34;Goldfish&amp;#34;, &amp;#34;Lizard&amp;#34;, &amp;#34;Canary&amp;#34;, &amp;#34;Tarantula&amp;#34;, &amp;#34;Hamster&amp;#34;]  VStack {  List {  ForEach(0...myArray.count - 1, id: \.self) { index in  Text(myArray[index])  }  } } Displaying Arrays of Structures in a List 前面的示例代码使用ForEach循环按索引值检索数组中的元素。另一种存储数据的方法是先定义一个结构体，然后创建一个结构体数组。这样做的目的是定义要存储的数据，同时定义一个唯一的ID，用来标识每个结构体：
struct Animals: Identifiable {  let pet: String  let id = UUID() }  var myAnimals = [Animals(pet: &amp;#34;Cat&amp;#34;),  Animals(pet: &amp;#34;Dog&amp;#34;),  Animals(pet: &amp;#34;Turtle&amp;#34;),  Animals(pet: &amp;#34;Ferret&amp;#34;),  Animals(pet: &amp;#34;Parrot&amp;#34;),  Animals(pet: &amp;#34;Goldfish&amp;#34;),  Animals(pet: &amp;#34;Lizard&amp;#34;),  Animals(pet: &amp;#34;Canary&amp;#34;),  Animals(pet: &amp;#34;Tarantula&amp;#34;),  Animals(pet: &amp;#34;Hamster&amp;#34;)]  VStack {  List(myAnimals) {  Text($0.pet)  } } Creating Groups in a List 如果列表中显示了许多元素，要在所有数据中滚动查找所需的项目可能会很困难。为了解决这个问题，列表允许我们创建section:
要定义sections，需要创建两个结构体。一个结构体定义section标题，第二个结构体定义要显示的数据。要定义section标题，需要定义：
 一个字符串常量：用于保存每个部分的名称。 一个数组常量：用于保存包含要显示的实际数据的结构体数组。 一个ID：为每个section定义一个唯一的ID。  struct SectionHeading: Identifiable {  let name: String  let animalList: [Animals]  let id = UUID() }  struct Animals: Identifiable {  let pet: String  let id = UUID() } 为了显示列表中的元素，需要内嵌ForEach循环。外部ForEach循环定义了section名称，内部的ForEach循环定义每个section中出现的元素：
var myAnimals1 = [SectionHeading(name: &amp;#34;Mammals&amp;#34;, animalList: [Animals(pet: &amp;#34;Cat&amp;#34;), Animals(pet: &amp;#34;Dog&amp;#34;), Animals(pet: &amp;#34;Ferret&amp;#34;), Animals(pet: &amp;#34;Hamster&amp;#34;)]),  SectionHeading(name: &amp;#34;Reptiles&amp;#34;, animalList: [Animals(pet: &amp;#34;Turtle&amp;#34;), Animals(pet: &amp;#34;Lizard&amp;#34;)]),  SectionHeading(name: &amp;#34;Birds&amp;#34;, animalList: [Animals(pet: &amp;#34;Parrot&amp;#34;), Animals(pet: &amp;#34;Canary&amp;#34;)]),  SectionHeading(name: &amp;#34;Other&amp;#34;, animalList: [Animals(pet: &amp;#34;Tarantula&amp;#34;), Animals(pet: &amp;#34;Goldfish&amp;#34;)])]  VStack {  List {  ForEach(myAnimals1) { heading in  Section(header: Text(&amp;#34;\(heading.name)Section&amp;#34;)) {  ForEach(heading.animalList) { creature in  Text(creature.pet)  }  }  }  } } Adding Line Separators to a List 列表通常会在各个元素之间显示线条。SwiftUI允许选择隐藏或显示这些线条，或为这些线条着色。要隐藏或显示列表中的线条，可以使用.listRowSeparator修改器，并像下面这样使用.visible或.hidden：
.listRowSeparator(.hidden) 要为列表中的分隔线着色，请使用.listRowSeparatorTint修改器，并像下面这样使用.red 或.blue等颜色：
.listRowSeparatorTint(.red) 可以在List中使用这两个修改器来修改 ForEach循环，该循环定义了在List中显示的内容。要了解如何在List中显示分隔线并为其着色：
List {  ForEach(0 ... myArray.count - 1, id: \.self) { index in  Text(myArray[index])  }.listRowSeparator(.visible).listRowSeparatorTint(.red) } Displaying Alternating Colors to a List 查看长列表比较麻烦。虽然用线条（无论有无颜色）分隔列表中的项目可以使列表更容易被看清，但另一种方法是在列表行中使用交替的颜色。
使用颜色可能会显得过于鲜艳，以至于列表中每一行的文字都难以阅读。要调整颜色强度，可以添加一个.opacity修改器来降低颜色强度。不透明度值为0时，颜色会完全消失；不透明度值为1时，颜色会完全显现。因此，不透明度值小于1会降低颜色的外观。
Color.green.opacity(0.4) 如果一个数组填充了一个List，那么可以根据数组索引是奇数还是偶数来交替使用数组索引。要确定数组索引（或任何数字）是否为偶数，可使用模运算符 (%) 将该数字除以 2。要定义 List 中每一行的背景颜色，我们需要使用 .background修改器来识别偶数和奇数数组索引值：
List {  ForEach(0...myArray.count - 1, id: \.self) { index in  HStack {  Text(myArray[index])  Spacer()  }.background(index % 2 == 0 ? Color.green.opacity(0.4) : Color.yellow.opacity(0.4))  } } Adding Swipe Gestures to a List 系统应用邮件、信息和照片等许多常用应用程序都会在列表中显示项目。在这些列表中，用户可以从左向右或从右向左轻扫，以显示更多选项供选择。
删除和移动项目是列表的两种常见任务。从列表中删除项目涉及删除项目，通常是在用户从右向左滑动之后。在列表中移动项目包括用按住并滑动项目，将其放到列表中的新位置。
Deleting Items from a List 在iOS中，删除列表中的项目最常用的快捷方式是从右到左轻扫，显示删除按钮。作为一种替代方法，用户可以继续从右向左轻扫来删除项目，而无需轻点删除按钮。
因为这种轻扫删除手势经常使用，SwiftUI使得这种方式易于实现。第一步是在List的ForEach循环中添加.onDelete修改器，如下所示：
@State var myArray = [&amp;#34;Cat&amp;#34;, &amp;#34;Dog&amp;#34;, &amp;#34;Turtle&amp;#34;, &amp;#34;Ferret&amp;#34;, &amp;#34;Parrot&amp;#34;, &amp;#34;Goldfish&amp;#34;, &amp;#34;Lizard&amp;#34;, &amp;#34;Canary&amp;#34;, &amp;#34;Tarantula&amp;#34;, &amp;#34;Hamster&amp;#34;]  func delete(at offsets: IndexSet) {  myArray.remove(atOffsets: offsets) }  List {  ForEach(0 ... myArray.count - 1, id: \.self) { index in  HStack {  Text(myArray[index])  Spacer()  }.background(index % 2 == 0 ? Color.green.opacity(0.4) : Color.yellow.opacity(0.4))  }.onDelete(perform: delete) } Moving Items in a List 使用列表的另一种常见方式是在列表中重新排列或移动项目。在iOS中，这通常需要两个步骤。首先，必须编辑列表，在列表中每个项目的右侧显示三条水平横线。其次，使用三横线滑动列表项目，将该项目放到新的位置。
func move(from source: IndexSet, to destination: Int) {  myArray.move(fromOffsets: source, toOffset: destination) }  NavigationView {  List {  ForEach(0 ... myArray.count - 1, id: \.self) { index in  Text(myArray[index])  }.onMove(perform: move)  }.toolbar {  // 显示编辑按钮  EditButton()  } } Creating Custom Swipe Actions for a List SwiftUI还允许在列表项上自定义从左至右和从右至左的手势。第一步是为列表（如文本视图）中的视图添加.swipeActions修改器。然后定义.leading（从左到右）还是.trailing（从右到左）轻扫手势:
Text(&amp;#34;\(message)&amp;#34;) List {  ForEach(0 ... myArray.count - 1, id: \.self) { index in  Text(myArray[index])  .swipeActions(edge: .trailing) {  Button {  message = &amp;#34;Item = \(myArray[index])-- Index = \(index)&amp;#34;  } label: {  Image(systemName: &amp;#34;calendar.circle&amp;#34;)  }.tint(.yellow)  }  .swipeActions(edge: .trailing) {  Button {  message = &amp;#34;Green button selected&amp;#34;  }  label: {  Image(systemName: &amp;#34;book&amp;#34;)  }.tint(.green)  }  .swipeActions(edge: .leading) {  Button {  message = &amp;#34;Left to right swipe&amp;#34;  }  label: {  Image(systemName: &amp;#34;graduationcap&amp;#34;)  }.tint(.purple)  }  } } Searching a List 因为列表通常显示大量数据，滚动浏览可能会很麻烦。为了方便地在长列表中搜索特定数据，可以添加搜索栏。用户可以输入一个或多个字符来过滤长列表，这样就能看到想要查看的数据。若要在列表中添加搜索栏，需要在导航视图中嵌入列表，并在列表中添加.searchable修改器：
// 定义全局函数 func newList() -&amp;gt; [String] {  return [&amp;#34;Automobile&amp;#34;, &amp;#34;Bicycle&amp;#34;, &amp;#34;Skateboard&amp;#34;, &amp;#34;Boat&amp;#34;, &amp;#34;Scooter&amp;#34;, &amp;#34;Airplane&amp;#34;, &amp;#34;Skates&amp;#34;] }  @State var search = &amp;#34;&amp;#34; @State var transportation = newList() NavigationView {  List(transportation, id: \.self) { x in  Text(x)  }.searchable(text: $search)  .onChange(of: search) { newValue in  if !newValue.isEmpty, newValue.count &amp;gt;= 1 {  transportation = transportation.filter { $0.lowercased().hasPrefix(newValue.lowercased()) }  } else {  transportation = newList()  }  } } Chapter 14 在填写纸质表格时，表格有时会将相关项目集中在一起。例如，表格的某个区域可能会询问用户姓名、地址和电话号码，而另一个区域则会询问性别、种族和婚姻状况。纸质表单便于在一个区域输入相关数据。
SwiftUI表单的工作方式与此类似，它将相关视图组合在一起，提供可以选择的选项和设置。表单由可选的页眉、页脚以及由文本、滑块或开关等视图组成。
表单可以像堆栈一样将相关视图组合在一起。不同的是，表单还能在用户界面上将视图直观地组合在一起。表单中的所有视图都显示在一起，而不在表单中的视图则被灰色区域隔开。
@State var messageOne = &amp;#34;&amp;#34; @State var messageTwo = &amp;#34;&amp;#34;  Form {  Text(&amp;#34;This is the first Form&amp;#34;)  TextField(&amp;#34;Type here&amp;#34;, text: $messageOne) } Form {  Text(&amp;#34;This is the second Form&amp;#34;)  TextField(&amp;#34;Type here&amp;#34;, text: $messageTwo) } Text(&amp;#34;Form #1 = \(messageOne)&amp;#34;) Text(&amp;#34;Form #2 = \(messageTwo)&amp;#34;) Dividing a Form into Sections 表单可以容纳多个视图，其中的视图越多，这些视图就会显得越拥挤。若要对相关视图进行分组，可以将表单划分为多个部分，每个部分可包含一个或多个视图。此外，各个部分可以包含可选的页眉和/或页脚。下面是几种创建表单分组的方式：
Section {  // Add views here  }  Section(&amp;#34;Header text here&amp;#34;) {  // Add views here  }  Section(content: {  // Add views here }, header: {  // Define header text here })  Section(content: {  // Add views here }, footer: {  // Define footer text here })   Section {  // Add views here } header: {  // Define header text her } footer: {  // Define footer text her } 下面代码将表单里面的视图分为4个部分，第一个分组没有头，第2个分组只有header，第3个分组只有footer，第4个分组既有header也有footer：
Form {  Section {  Text(&amp;#34;This Section has no header&amp;#34;)  }  Section(&amp;#34;Just a Header&amp;#34;) {  Text(&amp;#34;This Section uses a simple header&amp;#34;)  }  Section {  Text(&amp;#34;This Section uses a simple footer&amp;#34;)  } footer: {  Text(&amp;#34;Just a Footer&amp;#34;)  }  Section {  Text(&amp;#34;This Section uses both a header and footer&amp;#34;)  } header: {  Text(&amp;#34;The header&amp;#34;)  } footer: {  Text(&amp;#34;The footer&amp;#34;)  } } Disabling Views in a Form 通常，在纸质表格可能会提出一系列问题。根据用户回答的结果，另一组问题可能与用户无关。例如，如果在纸质表格问用户已婚还是单身，用户可能会回答已婚。在这种情况下，纸质表格的另一部分可能会询问配偶的姓名和联系信息。
但是，如果回答单身，就没有必要回答关于配偶相关问题。在SwiftUI表单中，可以使用.disabled修改器，根据布尔值有选择地禁用表单中的某个视图：
.disabled(flag) 下面代码是在表单中禁用一个视图：
Form {  Section {  Toggle(isOn: $flag) {  Text(&amp;#34;Are you married?&amp;#34;)  }  Button(flag ? &amp;#34;Disabled&amp;#34; : &amp;#34;Click Me&amp;#34;) {  debugPrint(flag)  }.disabled(flag)  } header: {  Text(&amp;#34;Header&amp;#34;)  } footer: {  Text(&amp;#34;Footer&amp;#34;)  } }  Form {  Section {  Toggle(isOn: $flag) {  Text(&amp;#34;Are you married?&amp;#34;)  }  Button(flag ? &amp;#34;Disabled&amp;#34; : &amp;#34;Click Me&amp;#34;) {  debugPrint(flag)  }.disabled(flag)  Toggle(isOn: $flag) {  Text(&amp;#34;Test ?&amp;#34;)  }.disabled(flag)  } header: {  Text(&amp;#34;Header&amp;#34;)  } footer: {  Text(&amp;#34;Footer&amp;#34;)  } } Using Group Boxes GroupBox为将相关视图组织在一起提供了一种更简单的方法。虽然与表单相似，但GroupBox可以显示标签，并在灰色矩形内直观地显示多个视图，而表单则在白色矩形内显示多个视图。
@State var flag = false @State var message = &amp;#34;&amp;#34;  VStack {  GroupBox(label: Text(&amp;#34;Group Box&amp;#34;)) {  Toggle(isOn: $flag) {  Text(&amp;#34;Click me&amp;#34;)  }  TextField(&amp;#34;Type here&amp;#34;, text: $message)  } } Chapter 15 许多应用程序都包含大量信息，如姓名和地址。但是，有时可能并不想一次查看存储的所有信息，以免占用屏幕。当想让用户选择性地隐藏或显示信息时，就可以使用Disclosure Group或Outline Group。
Disclosure Group有两种显示状态。首先，它可以显示代表链接的一行文本。其次，当用户点击该链接时，会展开显示一个或多个视图。
Disclosure Group可以选择性地隐藏或显示一组相关视图，而Outline Group则可以选择性地隐藏或显示列表中的文本组。
Using a Disclosure Group Disclosure Group用于隐藏一个或多个视图（文本、滑块、切换等），直到用户点击Disclosure Group名称将其展开。展开后，Disclosure Group将显示用户界面上的一个或多个视图。
与堆栈一样，Disclosure Group最多可容纳10个视图，并且其中一个或多个视图可以是堆栈。此外，还可以在Disclosure Group中内嵌Disclosure Group。
为了创建一个Disclosure Group，首先需要创建一个代表链接的描述文本。该文本的最右侧会出现一个&amp;gt;，表示该链接包含隐藏的视图。其次，需要创建一个视图列表（最多10个），当用户选择Disclosure Group链接时，该列表就会出现。
@State var sliderValue = 0.0 @State var message = &amp;#34;&amp;#34; @State var flag = true  VStack {  DisclosureGroup(&amp;#34;Expand Me&amp;#34;) {  Text(&amp;#34;You typed = \(message)&amp;#34;)  TextField(&amp;#34;Type here&amp;#34;, text: $message).padding()  Text(flag ? &amp;#34;Toggle = true&amp;#34; : &amp;#34;Toggle = false&amp;#34;)  Toggle(isOn: $flag) {  Text(&amp;#34;Toggle&amp;#34;)  }.padding()  Text(&amp;#34;The slider value = \(sliderValue)&amp;#34;)  Slider(value: $sliderValue, in: 0 ... 15).padding()  }.padding() } Using a Scroll View 在VStack中排列多个视图时，这些视图会固定在用户界面上。如果显示的视图多于用户界面所能显示的视图，这些视图的一部分就会被隐藏起来。为了解决这个问题，SwiftUI提供了一种名为Scroll View的特殊容器。
Scroll View如同Stack可以放置多个视图，但和Stack不同的是滚动视图允许用户垂直或水平滚动，以查看Scroll View的全部内容。Scroll View可以在任何能够使用Stack的地方工作，包括在Disclosure Group中。
ScrollView {  // Multiple views here  } 这样就可以通过右侧的滚动指示器垂直滚动。如下图所示，滚动指示器可以看到离列表项目的开始或结束有多近或多远。
创建Scroll View的另一种方法是定义滚动方向（Axis.Set.horizontal或Axis.Set.vertical）以及是否显示滚动指示器（showsIndicators参数）：
ScrollView(Axis.Set.vertical, showsIndicators: true, content: {  ForEach(0..&amp;lt;50) { Text(&amp;#34;Item #\($0)&amp;#34;) } })  ScrollView(.vertical, showsIndicators: true) {  ForEach(0 ..&amp;lt; 50) {  Text(&amp;#34;Item #\($0)&amp;#34;)  } } Jumping to a Specific Location ScrollView可以显示大数量的数据。但是，显示的数据越多，就越难找到某个特定的项目。SwiftUI提供了在 ScrollView中跳转到特定位置的功能，而不是强迫用户无休止地滚动。
如果一个ScrollView当前显示100个项目，可以跳转到其中的任意一个特定的位置，例如ScrollView中的第54个项目或第12个项目。这样，用户就可以轻松地在ScrollView中的大量项目列表中快速跳转到特定位置。
当跳转到ScrollView中的特定位置时，可以选择显示或锚定该项目在哪个位置，当前有.top、.center或.bottom三种选项。.top锚点在屏幕顶部显示所选项目，.center锚点在屏幕中央显示所选项目，而.bottom锚点在屏幕底部显示所选项目。
@State var sliderValue = 0.0 @State var anchorPosition = UnitPoint.center  ScrollViewReader { scrollView in  HStack {  Text(&amp;#34;\(Int(sliderValue))&amp;#34;)  Slider(value: $sliderValue, in: 0 ... 99)  }  Button(&amp;#34;Scroll to slider value&amp;#34;) {  withAnimation {  scrollView.scrollTo(Int(sliderValue), anchor: anchorPosition)  }  }  Picker(&amp;#34;Location&amp;#34;, selection: $anchorPosition, content: {  Text(&amp;#34;Top&amp;#34;).tag(UnitPoint.top)  Text(&amp;#34;Center&amp;#34;).tag(UnitPoint.center)  Text(&amp;#34;Bottom&amp;#34;).tag(UnitPoint.bottom)  }).pickerStyle(.segmented)  ScrollView {  ForEach(0 ..&amp;lt; 100) { index in  Text(&amp;#34;Item # \(index)&amp;#34;).id(index)  }  } } Defining a Horizontal Scroll View ScrollView默认是垂直方向滚动的。实际上，也可以将滚动方向改为水平的，这对于滚动屏幕上无法显示的信息（如大量文本）非常方便。
ScrollViewReader { _ in  ScrollView(.horizontal, showsIndicators: true) {  Text(&amp;#34;This is a long amount of text that won&amp;#39;t fit within the narrow width of an iPhone. That way you can see how to scroll horizontally.&amp;#34;)  } } Using an Outline Group Outline Group的作用类似于超级Disclosure Group。主要区别在于，Disclosure Group最多只能显示10个视图，而Outline Group则可以在一个单独类中显示无数的项目。此外，Outline Group会自动缩进类别，以便于查看项目之间的层次关系。
Outline Group显示定义关系的对象数组。若要使用Outline Group，需要执行以下操作：
 Create a class that holds the data you want to display. Create an array that holds multiple objects defined by the class. Create an Outline Group that displays the data stored in the objects.  class Species: Identifiable {  let id = UUID()  var name: String  var classification: [Species]?   init(name: String, classification: [Species]? = nil) {  self.name = name  self.classification = classification  } }  var animals: [Species] = [  Species(name: &amp;#34;Mammal&amp;#34;, classification: [  Species(name: &amp;#34;Dog&amp;#34;, classification: [  Species(name: &amp;#34;Poodle&amp;#34;),  Species(name: &amp;#34;Collie&amp;#34;),  Species(name: &amp;#34;St. Bernard&amp;#34;),  ]),  Species(name: &amp;#34;Cat&amp;#34;),  Species(name: &amp;#34;Elephant&amp;#34;),  Species(name: &amp;#34;Whale&amp;#34;),  ]),  Species(name: &amp;#34;Bird&amp;#34;, classification: [  Species(name: &amp;#34;Canary&amp;#34;),  Species(name: &amp;#34;Parakeet&amp;#34;),  Species(name: &amp;#34;Eagle&amp;#34;),  ]), ]   VStack {  List {  OutlineGroup(animals, id: \.id, children: \.classification) { creature in  Text(creature.name)  }  } } Chapter 16 应用程序需要向用户显示信息。无论信息是文本还是数字，大量数据可能难以理解。这就是为什么许多应用程序会将信息转换成图表的原因。图表只需将数字数据转换成彩色图像，即可一目了然。
创建图表的关键在于识别所拥有的数据，并确定关于这些数据想讲述什么故事。例如，销售额列表可以用来显示销售额的增长（或萎缩）情况、哪个时间段最赚钱（哪个时间段最不赚钱）、不同销售人员的对比情况，或者哪些产品可能比其它产品卖得更好。
根据数据制作图表的方法没有对错之分，因为图表是用来交流的。所以，唯一可能犯的错误就是创建的图表无法讲述想讲述的数据故事。SwiftUI支持创建以下类型的图表。
 Bar Point Line Area Rectangle  图表使用数值来定义坐标轴上的标记。标记可以直观地测量数据，而坐标轴就像一把尺子，可以帮助用户确定每个标记所代表的数量。下图中，在条形图中，单个条就是一个标记，而在折线图中，单条折线就是一个标记。
为了创建图表，首先需要导入Charts：
import Charts Creating a Bar Chart 为了创建条形图，需要使用BarMark定义x和y的值:
@State var sliderValue = 25.0  VStack {  Chart {  BarMark(x: .value(&amp;#34;Name&amp;#34;, &amp;#34;Oscar&amp;#34;), y: .value(&amp;#34;Sales&amp;#34;, 50))  BarMark(x: .value(&amp;#34;Name&amp;#34;, &amp;#34;Mayer&amp;#34;), y: .value(&amp;#34;Sales&amp;#34;, Int(sliderValue)))  }  HStack {  Text(&amp;#34;\(Int(sliderValue))&amp;#34;)  Slider(value: $sliderValue, in: 1 ... 100)  }.padding() } Defining Charts with Loops and Arrays 对于小型图表，定义一个或多个标记（如BarMarks）很容易。但是，如果需要绘制含有大量数据的图表，定义每个标记可能会很麻烦。因为，事先可能不知道图表所需标记的确切数量，而数据的大小又会发生变化。
因此，最好不要单独定义标记，而是依靠数据结构和循环来定义图表中每个标记的数量和高度。首先，需要定义一个结构体来保存图表数据。
struct SalesPeople: Identifiable {  var name: String  var sales: Int  var id: String {  name  } }  var mySalesArray: [SalesPeople] = [  .init(name: &amp;#34;Oscar&amp;#34;, sales: 50),  .init(name: &amp;#34;Mayer&amp;#34;, sales: 43),  .init(name: &amp;#34;George&amp;#34;, sales: 62),  .init(name: &amp;#34;Hormel&amp;#34;, sales: 26) ] 一旦有了结构体数组，因为在数组中定义了一个类别（名称）和一个值（销售额），就可以在图表中使用它。这意味着要定义包含图表数据的数组，以及临时存储每个数组项的任意变量：
Chart(mySalesArray) { x in  BarMark(x: .value(&amp;#34;Name&amp;#34;, x.name), y: .value(&amp;#34;Sales&amp;#34;, x.sales)) } Defining Colors for a Bar Chart 条形图的每个标记（条形）都默认显示为蓝色。不过，可以使用.foregroundStyle修改器设置不同的颜色，如下所示，将条形图的标记设置为橙色：
Chart(mySalesArray) { x in  BarMark(x: .value(&amp;#34;Name&amp;#34;, x.name), y: .value(&amp;#34;Sales&amp;#34;, x.sales))  .foregroundStyle(.orange) } 上面代码中.foregroundStyle修改器定义了一种颜色，所有条形都显示同一种颜色。若要显示不同颜色的标记（条形），需要定义第三个类别。这样，每个类别就会显示自己的颜色。
struct SalesPeople: Identifiable {  var name: String  var department: String  var sales: Int  var id = UUID() }  var mySalesArray: [SalesPeople] = [  .init(name: &amp;#34;Oscar&amp;#34;, department: &amp;#34;North&amp;#34;, sales: 50),  .init(name: &amp;#34;Mayer&amp;#34;, department: &amp;#34;South&amp;#34;, sales: 43),  .init(name: &amp;#34;George&amp;#34;, department: &amp;#34;East&amp;#34;, sales: 62),  .init(name: &amp;#34;Hormel&amp;#34;, department: &amp;#34;West&amp;#34;, sales: 26),  .init(name: &amp;#34;Mike&amp;#34;, department: &amp;#34;North&amp;#34;, sales: 67),  .init(name: &amp;#34;Spam&amp;#34;, department: &amp;#34;South&amp;#34;, sales: 38),  .init(name: &amp;#34;Jan&amp;#34;, department: &amp;#34;East&amp;#34;, sales: 47),  .init(name: &amp;#34;Lundy&amp;#34;, department: &amp;#34;West&amp;#34;, sales: 53) ]  Chart(mySalesArray) { x in  BarMark(x: .value(&amp;#34;Name&amp;#34;, x.name), y: .value(&amp;#34;Sales&amp;#34;, x.sales))  .foregroundStyle(by: .value(&amp;#34;Department&amp;#34;, x.department)) }.padding(30) Displaying an Average Value with the RuleMark 当有大量条形标记时，很难比较不同的数值。哪些高于平均值？哪些低于平均值？为了便于查看这些，charts提供了RuleMark，它可以在图形上显示一条线。RuleMark使用方式如下所示：
Chart(mySalesArray) { x in  BarMark(x: .value(&amp;#34;Name&amp;#34;, x.name), y: .value(&amp;#34;Sales&amp;#34;, x.sales))  .foregroundStyle(by: .value(&amp;#34;Department&amp;#34;, x.department))  RuleMark(y: .value(&amp;#34;Average Sales&amp;#34;, (mySalesArray.map { Int($0.sales)  }).reduce(0, &#43;) / Set(mySalesArray.map { $0.sales  }).count)).foregroundStyle(.purple)  RuleMark(y: .value(&amp;#34;Sales must not go below this line&amp;#34;, 20)).foregroundStyle(.red) } Creating a Stacked Bar Chart 条形图可以跟踪趋势，堆叠条形图可以看到整体的各个部分，比如每个季度哪些产品的销售额最高，或者每个月哪个销售人员的销售额最高。创建堆叠条形图需要三组数据：
 The numeric data you want to define the marks (bars) (y value). The duplicate data that defines each stacked bar (x value). The category to separate each bar.  var mySalesArray: [SalesPeople] = [  .init(name: &amp;#34;Oscar&amp;#34;, department: &amp;#34;North&amp;#34;, sales: 50),  .init(name: &amp;#34;Oscar&amp;#34;, department: &amp;#34;South&amp;#34;, sales: 43),  .init(name: &amp;#34;Oscar&amp;#34;, department: &amp;#34;East&amp;#34;, sales: 62),  .init(name: &amp;#34;Oscar&amp;#34;, department: &amp;#34;West&amp;#34;, sales: 26),  .init(name: &amp;#34;Mayer&amp;#34;, department: &amp;#34;North&amp;#34;, sales: 67),  .init(name: &amp;#34;Mayer&amp;#34;, department: &amp;#34;South&amp;#34;, sales: 38),  .init(name: &amp;#34;Mayer&amp;#34;, department: &amp;#34;East&amp;#34;, sales: 47),  .init(name: &amp;#34;Mayer&amp;#34;, department: &amp;#34;West&amp;#34;, sales: 53) ]  Chart(mySalesArray) { x in  BarMark(x: .value(&amp;#34;Name&amp;#34;, x.name), y: .value(&amp;#34;Sales&amp;#34;, x.sales))  .foregroundStyle(by: .value(&amp;#34;Department&amp;#34;, x.department)) }.padding() Spacer() Creating a Line Chart 折线图的工作原理与条形图类似，都是通过高度来测量数值。主要区别在于，折线图更容易发现上升或下降趋势。在绘制多组数据时，折线图往往效果最佳。
var mySalesArray: [SalesPeople] = [  .init(name: &amp;#34;Oscar&amp;#34;, department: &amp;#34;North&amp;#34;, sales: 50),  .init(name: &amp;#34;Mayer&amp;#34;, department: &amp;#34;South&amp;#34;, sales: 43),  .init(name: &amp;#34;George&amp;#34;, department: &amp;#34;East&amp;#34;, sales: 62),  .init(name: &amp;#34;Hormel&amp;#34;, department: &amp;#34;West&amp;#34;, sales: 26),  .init(name: &amp;#34;Jan&amp;#34;, department: &amp;#34;North&amp;#34;, sales: 47),  .init(name: &amp;#34;Lundy&amp;#34;, department: &amp;#34;South&amp;#34;, sales: 53), ]  Chart(mySalesArray) { x in  LineMark(x: .value(&amp;#34;Name&amp;#34;, x.name), y: .value(&amp;#34;Sales&amp;#34;, x.sales)) }.padding() Spacer() Creating Area Charts 面积图本质上也是折线图，只是将折线图填充，并且填充后更易于查看:
var mySalesArray: [SalesPeople] = [  .init(name: &amp;#34;Oscar&amp;#34;, department: &amp;#34;North&amp;#34;, sales: 50),  .init(name: &amp;#34;Mayer&amp;#34;, department: &amp;#34;South&amp;#34;, sales: 43),  .init(name: &amp;#34;George&amp;#34;, department: &amp;#34;East&amp;#34;, sales: 62),  .init(name: &amp;#34;Hormel&amp;#34;, department: &amp;#34;West&amp;#34;, sales: 26),  .init(name: &amp;#34;Jan&amp;#34;, department: &amp;#34;North&amp;#34;, sales: 47),  .init(name: &amp;#34;Lundy&amp;#34;, department: &amp;#34;South&amp;#34;, sales: 53), ]  Chart(mySalesArray) { x in  AreaMark(x: .value(&amp;#34;Name&amp;#34;, x.name), y: .value(&amp;#34;Sales&amp;#34;, x.sales)) }.padding() Spacer() Creating a Point Chart 点图，线图和面积图相似。主要区别在于点图只是将数据显示为图表上的点。与线形图或面积图相比，点图更难表现趋势，但点图在识别数据组出现的位置时特别有用。一旦知道数据应该出现在什么位置，点图就能轻松识别超出正常范围的数据。
var mySalesArray: [SalesPeople] = [  .init(name: &amp;#34;Oscar&amp;#34;, department: &amp;#34;North&amp;#34;, sales: 50),  .init(name: &amp;#34;Mayer&amp;#34;, department: &amp;#34;South&amp;#34;, sales: 43),  .init(name: &amp;#34;George&amp;#34;, department: &amp;#34;East&amp;#34;, sales: 62),  .init(name: &amp;#34;Hormel&amp;#34;, department: &amp;#34;West&amp;#34;, sales: 26),  .init(name: &amp;#34;Jan&amp;#34;, department: &amp;#34;North&amp;#34;, sales: 47),  .init(name: &amp;#34;Lundy&amp;#34;, department: &amp;#34;South&amp;#34;, sales: 53), ]  VStack {  Chart(mySalesArray) { x in  PointMark(x: .value(&amp;#34;Name&amp;#34;, x.name), y: .value(&amp;#34;Sales&amp;#34;, x.sales))  .foregroundStyle(by: .value(&amp;#34;Region&amp;#34;, x.department))  }.padding()  Spacer() } Creating a Rectangle Chart 矩形图本质上只显示条形图的顶部，顶部下面没有任何颜色。这样就可以很容易看到它们所代表的数值，而不会受到额外图形的干扰。
var mySalesArray: [SalesPeople] = [  .init(name: &amp;#34;Oscar&amp;#34;, department: &amp;#34;North&amp;#34;, sales: 50),  .init(name: &amp;#34;Mayer&amp;#34;, department: &amp;#34;South&amp;#34;, sales: 43),  .init(name: &amp;#34;George&amp;#34;, department: &amp;#34;East&amp;#34;, sales: 62),  .init(name: &amp;#34;Hormel&amp;#34;, department: &amp;#34;West&amp;#34;, sales: 26),  .init(name: &amp;#34;Jan&amp;#34;, department: &amp;#34;North&amp;#34;, sales: 47),  .init(name: &amp;#34;Lundy&amp;#34;, department: &amp;#34;South&amp;#34;, sales: 53), ]  VStack {  Chart(mySalesArray) { x in  RectangleMark(x: .value(&amp;#34;Name&amp;#34;, x.name), y: .value(&amp;#34;Sales&amp;#34;, x.sales))  .foregroundStyle(by: .value(&amp;#34;Region&amp;#34;, x.department))  }.padding()  Spacer() } Chapter 17 只有最简单的应用程序才只有一个页面，如计算器应用程序。但是，大多数应用程序通常需要两个或更多页面来显示信息。在SwiftUI中，可以通过创建单独的结构体来定义应用程序用户界面。也就是说，需要提供从一个页面跳转到另一个页面的方法。
从一个页面跳转到另一个页面最简单方法之一是通过导航堆栈，即按顺序显示多页面。许多 iOS 应用程常用导航堆栈来让用户查看不同的选项。
Using a Navigation Stack 导航堆栈最多可容纳10个视图，就像其它类型的堆栈（VStack、HStack、ZStack）一样。导航堆栈可以包含多个视图，代码如下：
NavigationStack {  // Put multiple views here  } 在NavigationStack中，需要一个或多个NavigationLink，每个NavigationLink都需定义要点击的视图和另一个要显示的视图。创建导NavigationLink的一种方法是只定义要点击的文本和要显示的视图：
NavigationLink (&amp;#34;Link text&amp;#34;) { 	// View to appear  } 用户点击导航链接时显示的视图可以是单一视图（如文本视图），也可以是包含多个视图的Stack视图。创建导航链接的第二种方法可以设计链接的外观:
NavigationLink { 	// View to appear  } label: { 	// View that defines the navigation link  } 下面示例代码展示了创建导航链接的不同方法，以及用户点击特定导航链接时将要出现的视图：
NavigationStack {  NavigationLink {  Text(&amp;#34;The 1st view&amp;#34;)  } label: {  Text(&amp;#34;First link&amp;#34;).font(.largeTitle)  }.padding()  NavigationLink {  Text(&amp;#34;The 2nd view&amp;#34;)  } label: {  Label {  Text(&amp;#34;Second link&amp;#34;)  } icon: {  Image(systemName: &amp;#34;sun.and.horizon.circle&amp;#34;)  }  }.padding()  NavigationLink {  Image(systemName: &amp;#34;ellipsis.message&amp;#34;).font(.system(size: 125))  } label: {  VStack {  Text(&amp;#34;Third view&amp;#34;)  Image(systemName: &amp;#34;figure.archery&amp;#34;)  }.font(.largeTitle)  }.padding()  NavigationLink(&amp;#34;The 4th view&amp;#34;) {  VStack {  Image(systemName: &amp;#34;airplane.departure&amp;#34;).font(.system(size: 120))  Text(&amp;#34;Departure time is 12:15&amp;#34;).font(.largeTitle)  }  }.padding() } Adding a Title to a Navigation Stack 导航栈只是在屏幕上显示一个或多个导航链接。有时可能希望在导航链接上添加一个标题，以确保用户了解该导航链接的目的。设置导航栈标题可以使用.large或.inline。
@State var titleType = NavigationBarItem.TitleDisplayMode.large  NavigationStack {  NavigationLink {  Text(&amp;#34;The 1st view&amp;#34;)  } label: {  Text(&amp;#34;First link&amp;#34;).font(.largeTitle)  }.padding()  NavigationLink {  Text(&amp;#34;The 2nd view&amp;#34;)  } label: {  Label {  Text(&amp;#34;Second link&amp;#34;)  } icon: {  Image(systemName: &amp;#34;sun.and.horizon.circle&amp;#34;)  }  }.padding()  NavigationLink {  Image(systemName: &amp;#34;ellipsis.message&amp;#34;).font(.system(size: 125))  } label: {  VStack {  Text(&amp;#34;Third view&amp;#34;)  Image(systemName: &amp;#34;figure.archery&amp;#34;)  }.font(.largeTitle)  }.padding()  NavigationLink(&amp;#34;The 4th view&amp;#34;) {  VStack {  Image(systemName: &amp;#34;airplane.departure&amp;#34;).font(.system(size: 120))  Text(&amp;#34;Departure time is 12:15&amp;#34;).font(.largeTitle)  }  }.padding()  .navigationTitle(&amp;#34;Navigation Stack&amp;#34;)  .navigationBarTitleDisplayMode(titleType) } 将.navigationtitle 和.navigationBarTitleDisplayMode修改器添加到导航堆栈时，像下面这样将这两个修改器放在导航堆栈的最后一个大括号内：
NavigationStack {  .navigationTitle(&amp;#34;Navigation Stack Title&amp;#34;)  .navigationBarTitleDisplayMode(.inline) } .navigationTitle修改器定义了显示在屏幕顶部导航堆栈上方的文本。而.navigationBarTitleDisplayMode修改器定义了标题在屏幕上的显示方式。有两个选项.large和.inline。如果没有设置.navigationBarTitleDisplayMode，默认为.large。
@State var titleType = NavigationBarItem.TitleDisplayMode.large  NavigationStack {  NavigationLink {  Text(&amp;#34;The 1st view&amp;#34;)  } label: {  Text(&amp;#34;First link&amp;#34;).font(.largeTitle)  }.padding()  .navigationTitle(&amp;#34;Navigation Stack&amp;#34;)  .navigationBarTitleDisplayMode(titleType)  HStack(spacing: 50) {  Button(&amp;#34;.large&amp;#34;) {  titleType = NavigationBarItem.TitleDisplayMode.large  }  Button(&amp;#34;.inline&amp;#34;) {  titleType = NavigationBarItem.TitleDisplayMode.inline  }  } } Adding Buttons to a Navigation Stack 除了在导航堆栈上方显示标题，还可以在屏幕顶部显示一个或多个按钮。这些按钮会显示在工具栏上，可以在导航堆栈内使用.toolbar修改器添加工具栏：
@State var titleType = NavigationBarItem.TitleDisplayMode.inline  NavigationStack {  NavigationLink {  Text(&amp;#34;The 1st view&amp;#34;)  } label: {  Text(&amp;#34;First link&amp;#34;).font(.largeTitle)  }.padding()  .navigationTitle(&amp;#34;Navigation Title&amp;#34;)  .navigationBarTitleDisplayMode(titleType)  .toolbar {  ToolbarItem(placement: .navigationBarLeading) {  Button {  message = &amp;#34;iCloud icon tapped&amp;#34;  }  label: {  Image(systemName: &amp;#34;icloud&amp;#34;)  }  }  ToolbarItem(placement: .navigationBarTrailing) {  Button {  message = &amp;#34;Done button tapped&amp;#34;  } label: {  Text(&amp;#34;Done&amp;#34;)  }  }  }  HStack(spacing: 50) {  Button(&amp;#34;.large&amp;#34;) {  titleType = NavigationBarItem.TitleDisplayMode.large  }  Button(&amp;#34;.inline&amp;#34;) {  titleType = NavigationBarItem.TitleDisplayMode.inline  }  } }.accentColor(.purple) Displaying Views from a Navigation Stack 在某些情况下，在导航堆栈中只显示文本或图像等单一视图可能没有问题。但很多时候，我们可能希望显示一个完全不同的用户界面。由于可以使用结构体定义用户界面，因此可以使用多个结构体创建多个页面，并显示在导航堆栈中。
struct FileView: View {  var body: some View {  HStack {  Spacer()  VStack {  Spacer()  Text(&amp;#34;This is a separate structure&amp;#34;)  Text(&amp;#34;that&amp;#39;s stored in the same file&amp;#34;)  Spacer()  }  Spacer()  }.background(Color.yellow)  } }  struct SeparateFileView: View {  var body: some View {  HStack {  Spacer()  VStack {  Spacer()  Text(&amp;#34;This is another structure&amp;#34;)  Text(&amp;#34;but stored in a separate file&amp;#34;) Spacer()  }  Spacer()  }.background(Color.orange)  } }  NavigationStack {  VStack {  NavigationLink(destination: FileView()) {  Text(&amp;#34;Link to structure in same file&amp;#34;)  }  NavigationLink(destination: SeparateFileView()) {  Text(&amp;#34;Separate file link&amp;#34;)  }.navigationTitle(&amp;#34;Navigation Title&amp;#34;)  } } Passing Data Between Structures in a Navigation Stack 上面创建了两个结构体，第一个结构体存储在ContentView文件中，第二个结构体存储在另一个文件中。这两个结构体都定义了用户界面。
在很多情况下，可能希望一个结构体中的数据出现在另一个结构中。这意味着我们必须将数据从一个结构体传递到另一个结构体。
这与函数间的数据传递类似。当一个结构体需要接收数据时，只需通过创建一个变量来声明一个属性，给该变量一个描述性的名称，并定义该变量可以容纳的数据类型，如String或Double：
struct FileView: View {  var choice: String   var body: some View {  HStack {  Spacer()  VStack {  Spacer()  Text(&amp;#34;You chose = \(choice)&amp;#34;)  Spacer()  }  Spacer()  }.background(Color.yellow)  } }  struct SeparateFileView: View {  var passedData: String   var body: some View {  HStack {  Spacer()  VStack {  Spacer()  Text(&amp;#34;You chose = \(passedData)&amp;#34;)  Spacer()  }  Spacer()  }.background(Color.orange)  } }  NavigationStack {  VStack {  Text(&amp;#34;Choose Heads or Tails&amp;#34;)  NavigationLink(destination: FileView(choice: &amp;#34;Head&amp;#34;)) {  Text(&amp;#34;Heads&amp;#34;)  }  NavigationLink(destination: SeparateFileView(passedData: &amp;#34;Tails&amp;#34;)) {  Text(&amp;#34;Tails&amp;#34;)  }.navigationTitle(&amp;#34;Flip a Coin&amp;#34;)  } } Changing Data Between Structures in a Navigation Stack 上个项目创建了两个结构体，其中一个结构体存储在ContentView文件中，第二个结构体存储在另一个文件中。这两个结构体都定义了要接收的数据和要显示数据的用户界面。如果将数据传递给一个结构体，然后允许该结构体修改数据呢？这就需要做出几处改动：
 Create a State variable. Use the NavigationLink to open another structure and pass that structure a binding to the State variable (using the $symbol) such as FileView(choice: $message). Define a @Binding variable in the structure that will receive data. Change that Binding variable in the structure that received data.  @State var message = &amp;#34;&amp;#34;  NavigationStack {  VStack {  TextField(&amp;#34;Type here&amp;#34;, text: $message)  NavigationLink(destination: FileView(choice: $message)) {  Text(&amp;#34;Heads&amp;#34;)  }  NavigationLink(destination: SeparateFileView(passedData: $message)) {  Text(&amp;#34;Tails&amp;#34;)  }.navigationTitle(&amp;#34;Flip a Coin&amp;#34;)  } }  struct FileView: View {  @Binding var choice: String   var body: some View {  HStack {  Spacer()  VStack {  Spacer()  TextField(&amp;#34;Type here:&amp;#34;, text: $choice)  Spacer()  }  Spacer()  }.background(Color.yellow)  } }  struct SeparateFileView: View {  @Binding var passedData: String   var body: some View {  HStack {  Spacer()  VStack {  Spacer()  TextField(&amp;#34;Type here:&amp;#34;, text: $passedData)  Spacer()  }  Spacer()  }.background(Color.orange)  } } Sharing Data Between Structures in a Navigation Stack 使用@State和@Binding声明变量可以让多个视图共享和修改数据。但是，假设创建了一个导航栈，它按顺序将四个结构体依次链接在一起。如果要更改第一个结构体上的数据并将其传递给第四个结构体，则还必须通过第二个和第三个结构传递该数据。
这样做虽然可行，但很笨拙，若直接将数据传递给需要数据的结构体要好得多。为此，SwiftUI提供了另一种在结构间共享数据的方法。首先，创建一个ObservableObject类，其中包含一个或多个要共享的变量，每个变量都必须标记为@Published：
class ShareString: ObservableObject {  @Published var message = &amp;#34;&amp;#34; } 包含NavigationStack的结构体需要定义一个@StateObject变量，像下面这样定义ObservableObject类中的一个对象：
@StateObject var showMe = ShareString() 由于要在导航堆栈中的所有视图之间共享这个ObservableObject，因此需要在导航堆栈中添加 .environmentObject修改器，并像下面这样共享StateObject：
NavigationStack {  // }.environmentObject(showMe) 导航链接无需向每个视图传递数据，而只需要显示视图:
NavigationLink(destination: FileView()) {  Text(&amp;#34;Send a message&amp;#34;) } 在每个需要访问ObservableObject的结构体中，都需要声明一个@EnvironmentObject变量，该变量使用 ObservableObject类：
@EnvironmentObject var choice: ShareString 最后，在每个定义了@EnvironmentObject的结构体中，可以使用@EnvironmentObject的属性名称加上@Published属性名来访问要共享的数据：
$choice.message 整个过程的示例代码如下：
@StateObject var showMe = ShareString()  NavigationStack {  VStack {  TextField(&amp;#34;Type here&amp;#34;, text: $showMe.message)  NavigationLink(destination: FileView()) {  Text(&amp;#34;Send a message&amp;#34;)  }  NavigationLink(destination: SeparateFileView()) {  Text(&amp;#34;Separate file&amp;#34;)  }.navigationTitle(&amp;#34;Sharing Data&amp;#34;)  } }.environmentObject(showMe)   class ShareString: ObservableObject {  @Published var message = &amp;#34;&amp;#34; }  struct FileView: View {  @EnvironmentObject var choice: ShareString   var body: some View {  HStack {  Spacer()  VStack {  Spacer()  TextField(&amp;#34;Type here:&amp;#34;, text: $choice.message)  Spacer()  }  Spacer()  }.background(Color.yellow)  } }  struct SeparateFileView: View {  @EnvironmentObject var passedData: ShareString   var body: some View {  HStack {  Spacer()  VStack {  Spacer()  TextField(&amp;#34;Type here:&amp;#34;, text: $passedData.message)  Spacer()  }  Spacer()  }.background(Color.orange)  } } Using Lists in a Navigation Stack 与单独显示导航链接相比，一种常用的方法是创建一个列表，列表中的每个项目都像一个链接。通过选择列表中的某个项目，导航堆栈可以打开一个新视图。导航堆栈中的列表组合常用于iOS的设置应用。在以前的项目中创建导航链接时，定义了要显示在链接上的文本以及目标视图：
NavigationLink { 	Text(&amp;#34;Destination view&amp;#34;) } label: { 	Text(&amp;#34;Text to appear on link&amp;#34;) } 在处理列表时将目标视图与导航链接分开会更方便。因为这样，导航链接只需定义其外观。然后，为了定义目标视图，可以使用navigationDestination修改器来定义用户选择导航链接时的显示内容：
struct Books: Identifiable, Hashable {  var id = UUID()  var title: String  var summary: String }  let books: [Books] = [  Books(title: &amp;#34;Fahrenheit 451&amp;#34;, summary: &amp;#34;Dystopian novel about book burning&amp;#34;),  Books(title: &amp;#34;The Martian Chronicles&amp;#34;, summary: &amp;#34;Tales about the colonization of Mars&amp;#34;),  Books(title: &amp;#34;Something Wicked This Way Comes&amp;#34;, summary: &amp;#34;A sinister circus comes to town&amp;#34;),  Books(title: &amp;#34;The Illustrated Man&amp;#34;, summary: &amp;#34;Short stories revolving around a tattooed man&amp;#34;) ]  NavigationStack {  List(books) { book in  NavigationLink(&amp;#34;\(book.title)&amp;#34;, value: book)  }.navigationTitle(Text(&amp;#34;Book List&amp;#34;))  .navigationDestination(for: Books.self) { x in  BookView(bookInfo: x)  } }  struct BookView: View {  var bookInfo: Books  var body: some View {   VStack(spacing: 24) {  Text(&amp;#34;\(bookInfo.title)&amp;#34;).font(.largeTitle)  Text(&amp;#34;\(bookInfo.summary)&amp;#34;).font(.body)  }  } } Chapter 18 大多数应用程序都由多个页面组成。上一章介绍了如何使用导航堆栈，让用户按顺序从一个页面跳转到另一个页面。这对于显示更多细节非常方便，例如iOS中的系统「设置」应用程序可以让用户点击不同的设置页面，然后查看选择不同的设置。
但是，导航堆栈的一个问题是，如果把太多页面连接在一起，跳转就会变得很麻烦。因为导航堆栈必须从第一个页面跳转到第二个页面，再导航到第三个页面，才能到达第四个页面。然后，必须颠倒整个过程，才能从第四个屏幕回到第一个屏幕。
为了提供从一个屏幕跳转到另一个屏幕的另一种方法，可以使用Tab视图，该视图在屏幕底部显示图标和/或文本。选择一个标签（图标和/或文本），就会跳转到一个新的屏幕。
例如，时钟应用会在屏幕底部显示图标/文本，让我们跳转到不同的页面。无论查看哪个页面，tab栏都会出现在屏幕底部，因此标签视图可以让我们随时轻松跳转到想查看的页面。
Using a Tab View 标签视图中可以包含多个视图：
TabView {  // Put multiple views here  } 存储在标签视图中的视图可以是简单的视图（如文本或图像视图），也可以是更复杂的定义视图的结构体。创建tab视图的第一部分是列出要在tab视图中使用的所有视图：
TabView {  Text(&amp;#34;One&amp;#34;)  Text(&amp;#34;Two&amp;#34;)  Text(&amp;#34;Three&amp;#34;)  Text(&amp;#34;Four&amp;#34;) } 定义了要在tab视图中显示的视图后，下一步就是定义代表每个视图的图标和/或文本。为此，需要为每个使用图像和文本视图的视图添加.tabItem修改器：
TabView {  Text(&amp;#34;One&amp;#34;).tabItem {  Image(systemName: &amp;#34;heart.fill&amp;#34;)  Text(&amp;#34;Tab&amp;#34;)  } } 为每个视图添加.tabItem修改器，并使用图像和文本视图定义其显示内容，就可以创建一个显示在屏幕底部的tab栏，效果如下图所示:
TabView {  Text(&amp;#34;One&amp;#34;).tabItem {  Image(systemName: &amp;#34;heart.fill&amp;#34;)  Text(&amp;#34;One&amp;#34;)  }  Text(&amp;#34;Two&amp;#34;).tabItem {  Image(systemName: &amp;#34;hare.fill&amp;#34;)  Text(&amp;#34;Two&amp;#34;)  }  Text(&amp;#34;Three&amp;#34;).tabItem {  Image(systemName: &amp;#34;tortoise.fill&amp;#34;)  Text(&amp;#34;Three&amp;#34;)  }  Text(&amp;#34;Four&amp;#34;).tabItem {  Image(systemName: &amp;#34;folder.fill&amp;#34;)  Text(&amp;#34;Four&amp;#34;)  } } tab栏可以显示图像或文本，也可以是图像和文本。为清晰起见，最好将tab同时定义为图像和文本。如果超出了5个tab，第5个tab将会显示在More：
TabView {  Text(&amp;#34;One&amp;#34;).tabItem {  Image(systemName: &amp;#34;heart.fill&amp;#34;)  Text(&amp;#34;One&amp;#34;)  }  Text(&amp;#34;Two&amp;#34;).tabItem {  Image(systemName: &amp;#34;hare.fill&amp;#34;)  Text(&amp;#34;Two&amp;#34;)  }  Text(&amp;#34;Three&amp;#34;).tabItem {  Image(systemName: &amp;#34;tortoise.fill&amp;#34;)  Text(&amp;#34;Three&amp;#34;)  }  Text(&amp;#34;Four&amp;#34;).tabItem {  Image(systemName: &amp;#34;folder.fill&amp;#34;)  Text(&amp;#34;Four&amp;#34;)  }  Text(&amp;#34;Five&amp;#34;).tabItem {  Image(systemName: &amp;#34;internaldrive.fill&amp;#34;)  Text(&amp;#34;Five&amp;#34;)  }  Text(&amp;#34;Six&amp;#34;).tabItem {  Image(systemName: &amp;#34;cloud.drizzle.fill&amp;#34;)  Text(&amp;#34;Six&amp;#34;)  } } Selecting Buttons Programmatically in a Tab Bar 要选择不同的视图，用户只需在tab栏中选择一个即可。默认情况下，最左边的第一个选项卡会突出显示。不过，有时可能想通过代码选择一个tab。在这种情况下，需要使用.tag修改器来标识每个.tabItem项目。
.tag修改器，可以用固定值来标识每个tab。当每个tabItem有一个唯一的.tag值，就可以使用代码引用.tag值来选择特定tab。
@State var selectedView = 2  HStack {  Button(&amp;#34;1&amp;#34;) {  selectedView = 1  }  Button(&amp;#34;2&amp;#34;) {  selectedView = 2  }  Button(&amp;#34;3&amp;#34;) {  selectedView = 3  }  Button(&amp;#34;4&amp;#34;) {  selectedView = 4  }  Button(&amp;#34;5&amp;#34;) {  selectedView = 5  }  Button(&amp;#34;6&amp;#34;) {  selectedView = 6  } }  TabView(selection: $selectedView) {  Text(&amp;#34;One&amp;#34;).tabItem {  Image(systemName: &amp;#34;heart.fill&amp;#34;)  Text(&amp;#34;One&amp;#34;)  }.tag(1)  Text(&amp;#34;Two&amp;#34;).tabItem {  Image(systemName: &amp;#34;hare.fill&amp;#34;)  Text(&amp;#34;Two&amp;#34;)  }.tag(2)  Text(&amp;#34;Three&amp;#34;).tabItem {  Image(systemName: &amp;#34;tortoise.fill&amp;#34;)  Text(&amp;#34;Three&amp;#34;)  }.tag(3)  Text(&amp;#34;Four&amp;#34;).tabItem {  Image(systemName: &amp;#34;folder.fill&amp;#34;)  Text(&amp;#34;Four&amp;#34;)  }.tag(4)  Text(&amp;#34;Five&amp;#34;).tabItem {  Image(systemName: &amp;#34;internaldrive.fill&amp;#34;)  Text(&amp;#34;Five&amp;#34;)  }.tag(5)  Text(&amp;#34;Six&amp;#34;).tabItem {  Image(systemName: &amp;#34;cloud.drizzle.fill&amp;#34;)  Text(&amp;#34;Six&amp;#34;)  }.tag(6) }.accentColor(.purple) Displaying a Page View 一般情况下tab视图在屏幕底部显示tab，这样用户就可以选择tab并跳转到不同的视图。作为一种替代方法，可以将tab视图转化为页面视图。
页面视图在屏幕底部中间显示代表不同页面的tab图标。然后，用户可以左右滚动，按顺序查看每个页面。要将tab视图转换为页面视图，只需在tab视图中添加.tabViewStyle修改器，并像下面这样指定.page：
TabView(selection: $selectedView) {  Text(&amp;#34;One&amp;#34;).tabItem {  Image(systemName: &amp;#34;heart.fill&amp;#34;)  Text(&amp;#34;One&amp;#34;)  }.tag(1)  Text(&amp;#34;Two&amp;#34;).tabItem {  Image(systemName: &amp;#34;hare.fill&amp;#34;)  Text(&amp;#34;Two&amp;#34;)  }.tag(2)  Text(&amp;#34;Three&amp;#34;).tabItem {  Image(systemName: &amp;#34;tortoise.fill&amp;#34;)  Text(&amp;#34;Three&amp;#34;)  }.tag(3)  Text(&amp;#34;Four&amp;#34;).tabItem {  Image(systemName: &amp;#34;folder.fill&amp;#34;)  Text(&amp;#34;Four&amp;#34;)  }.tag(4)  Text(&amp;#34;Five&amp;#34;).tabItem {  Image(systemName: &amp;#34;internaldrive.fill&amp;#34;)  Text(&amp;#34;Five&amp;#34;)  }.tag(5)  Text(&amp;#34;Six&amp;#34;).tabItem {  Image(systemName: &amp;#34;cloud.drizzle.fill&amp;#34;)  Text(&amp;#34;Six&amp;#34;)  }.tag(6) }.tabViewStyle(.page) 现在，用户不再需要从屏幕底部选择一个tab打开视图，而是可以左右滚动来按顺序打开每个视图。如果要提供可视图数量，可以添加.indexViewStyle修改器，并指定.always为背景显示模式：
TabView(selection: $selectedView) {  Text(&amp;#34;One&amp;#34;).tabItem {  Image(systemName: &amp;#34;heart.fill&amp;#34;)  Text(&amp;#34;One&amp;#34;)  }.tag(1)  Text(&amp;#34;Two&amp;#34;).tabItem {  Image(systemName: &amp;#34;hare.fill&amp;#34;)  Text(&amp;#34;Two&amp;#34;)  }.tag(2)  Text(&amp;#34;Three&amp;#34;).tabItem {  Image(systemName: &amp;#34;tortoise.fill&amp;#34;)  Text(&amp;#34;Three&amp;#34;)  }.tag(3)  Text(&amp;#34;Four&amp;#34;).tabItem {  Image(systemName: &amp;#34;folder.fill&amp;#34;)  Text(&amp;#34;Four&amp;#34;)  }.tag(4)  Text(&amp;#34;Five&amp;#34;).tabItem {  Image(systemName: &amp;#34;internaldrive.fill&amp;#34;)  Text(&amp;#34;Five&amp;#34;)  }.tag(5)  Text(&amp;#34;Six&amp;#34;).tabItem {  Image(systemName: &amp;#34;cloud.drizzle.fill&amp;#34;)  Text(&amp;#34;Six&amp;#34;)  }.tag(6) }.tabViewStyle(.page).indexViewStyle(PageIndexViewStyle(backgroundDisplayMode: .always)) Displaying Structures in a Tab View 虽然tab视图可以显示单一视图（如文本或图像视图），但很多时候可能希望显示一个全新的用户界面。因为可以使用结构体定义用户界面屏幕，因此可以使用多个结构体创建多个页面，并显示在tab视图中。
创建新结构的最简单方法是在ContentView文件中创建。不过，这种方法会使代码变得杂乱无章，因此第二种方法是将结构体存储在单独的文件中。
TabView {  FileView().tabItem {  Image(systemName: &amp;#34;heart.fill&amp;#34;)  Text(&amp;#34;First&amp;#34;)  }  SeparateFileView().tabItem {  Image(systemName: &amp;#34;hare.fill&amp;#34;)  Text(&amp;#34;Second&amp;#34;)  } }  struct FileView: View {   var body: some View {  HStack {  Spacer()  VStack {  Spacer()  Text(&amp;#34;This is a separate structure&amp;#34;)  Text(&amp;#34;that&amp;#39;s stored in the same file&amp;#34;)  Spacer()  }  Spacer()  }.background(Color.yellow)  } }  struct SeparateFileView: View {   var body: some View {  HStack {  Spacer()  VStack {  Spacer()  Text(&amp;#34;This is a separate structure&amp;#34;)  Text(&amp;#34;that&amp;#39;s stored in the same file&amp;#34;)  Spacer()  }  Spacer()  }.background(Color.orange)  } } Passing Data Between Structures in a Tab View 在很多情况下，我们可能希望一个结构体中的数据出现在另一个结构体中。这意味着必须将数据从一个结构体传递到另一个结构体。
这种情况与函数间的数据传递类似。当一个结构体需要接收数据时，只需通过创建一个变量来声明一个属性，类型可以是String或Double等：
@State var message = &amp;#34;&amp;#34;  TabView {  TextField(&amp;#34;Type here&amp;#34;, text: $message).tabItem {  Image(systemName: &amp;#34;house.fill&amp;#34;)  Text(&amp;#34;Home&amp;#34;)  }  FileView(choice: message).tabItem {  Image(systemName: &amp;#34;heart.fill&amp;#34;)  Text(&amp;#34;First&amp;#34;)  }  SeparateFileView(passedData: message).tabItem {  Image(systemName: &amp;#34;hare.fill&amp;#34;)  Text(&amp;#34;Second&amp;#34;)  } }   struct FileView: View {  var choice: String   var body: some View {  HStack {  Spacer()  VStack {  Spacer()  Text(&amp;#34;You typed = \(choice)&amp;#34;)  Spacer()  }  Spacer()  }.background(Color.green)  } }  struct SeparateFileView: View {  var passedData: String  var body: some View {  HStack {  Spacer()  VStack {  Spacer()  Text(&amp;#34;String from text field = \(passedData)&amp;#34;)  Spacer()  }  Spacer()  }.background(Color.orange)  } } Changing Data Between Structures in a Tab View 上面创建了两个结构体，其中一个结构体存储在ContentView文件中，第二个结构体存储在另一个文件中。两个结构体都定义了接收数据并显示数据的用户界面。如果我们需要将数据传递给一个结构体，然后允许该结构体修改这些数据，这就需要做出几处改动：
 Create a State variable. Open another structure and pass that structure a binding to the State variable (using the $symbol) such as FileView(choice: $message) Define a @Binding variable in the structure that will receive data. Change that Binding variable in the structure that received data.  @State var message = &amp;#34;&amp;#34;  TabView {  TextField(&amp;#34;Type here&amp;#34;, text: $message).tabItem {  Image(systemName: &amp;#34;house.fill&amp;#34;)  Text(&amp;#34;Home&amp;#34;)  }  FileView(choice: $message).tabItem {  Image(systemName: &amp;#34;heart.fill&amp;#34;)  Text(&amp;#34;First&amp;#34;)  }  SeparateFileView(passedData: $message).tabItem {  Image(systemName: &amp;#34;hare.fill&amp;#34;)  Text(&amp;#34;Second&amp;#34;)  } }  struct FileView: View {  @Binding var choice: String   var body: some View {  HStack {  Spacer()  VStack {  Spacer()  TextField(&amp;#34;Type here:&amp;#34;, text: $choice)  Spacer()  }  Spacer()  }.background(Color.green)  } }  struct SeparateFileView: View {  @Binding var passedData: String  var body: some View {  HStack {  Spacer()  VStack {  Spacer()  TextField(&amp;#34;Type here:&amp;#34;, text: $passedData)  Spacer()  }  Spacer()  }.background(Color.orange)  } } Sharing Data Between Structures in a Tab View 使用@State和@Binding变量可以让多个视图共享和修改数据。SwiftUI还提供了另一种在结构体之间共享数据的方法。首先，创建一个ObservableObject类，其中包含一个或多个要共享的变量，每个要共享的变量都必须标记为@Published：
class ShareString: ObservableObject {  @Published var message = &amp;#34;&amp;#34; } 包含tab视图的结构体（如ContentView）需要定义一个@StateObject变量，该变量类型必须是ObservableObject类型，即上一步定义的类型：
@StateObject var showMe = ShareString() 由于我们要在TabView中的所有视图之间共享此ObservableObject，因此需要在TabView中添加 .environmentObject修改器和要共享的StateObject变量：
TabView {  // }.environmentObject(showMe) 然后在每个需要访问ObservableObject的结构体中，需要使用@EnvironmentObject声明一个ObservableObject类型的变量：
@EnvironmentObject var choice: ShareString 最后，在每个使用@EnvironmentObject声明了变量的结构体中，可以使用@EnvironmentObject声明的变量名加上使用@Published声明的属性访问要共享的实际数据：
$choice.message 按上面步骤组合后，得到如下代码：
class ShareString: ObservableObject {  @Published var message = &amp;#34;&amp;#34; }  @StateObject var showMe = ShareString()  TabView {  TextField(&amp;#34;Type here&amp;#34;, text: $showMe.message).tabItem {  Image(systemName: &amp;#34;house.fill&amp;#34;)  Text(&amp;#34;Home&amp;#34;)  }  FileView().tabItem {  Image(systemName: &amp;#34;heart.fill&amp;#34;)  Text(&amp;#34;First&amp;#34;)  }  SeparateFileView().tabItem {  Image(systemName: &amp;#34;hare.fill&amp;#34;)  Text(&amp;#34;Second&amp;#34;)  } }.environmentObject(showMe)  struct FileView: View {  @EnvironmentObject var choice: ShareString   var body: some View {  HStack {  Spacer()  VStack {  Spacer()  TextField(&amp;#34;Type here:&amp;#34;, text: $choice.message)  Spacer()  }  Spacer()  }.background(Color.green)  } }  struct SeparateFileView: View {  @EnvironmentObject var passedData: ShareString  var body: some View {  HStack {  Spacer()  VStack {  Spacer()  TextField(&amp;#34;Type here:&amp;#34;, text: $passedData.message)  Spacer()  }  Spacer()  }.background(Color.orange)  } } Chapter 19 文本视图适合显示字符串，图像视图适合显示图形。但是，如果要在屏幕上显示多块数据怎么办？这时可以使用网格(Grid)，网格可以按行（水平）或列（垂直）显示数据。
创建网格，需要三项：
 要显示的数据。 定义如何在网格中排列数据的GridItem数组。 将数据放入GridItem数组中LazyVGrid或LazyHGrid。  Lazy指的是网格加载数据的方式。如果一个网格需要显示1000个项目，它可以在内存中加载所有1000个项目，即使其中大部分项目无法显示在屏幕上。但这会浪费内存，所以Lazy网格只加载需要显示的项目。当用户滚动查看更多数据时，Lazy网格会立即加载这些项目。
直到最后一秒才加载数据，Lazy网格的内存使用量大大降低，应用程序运行效率更高，但运行速度却略有降低。一般来说，Lazy网格会嵌入在滚动视图中，让用户滚动查看网格中存储的更多数据。
let gridItems = [GridItem()] ScrollView(Axis.Set.horizontal, showsIndicators: true, content: {  LazyHGrid(rows: gridItems) {  Image(systemName: &amp;#34;1.circle&amp;#34;)  Image(systemName: &amp;#34;2.circle&amp;#34;)  Image(systemName: &amp;#34;3.circle&amp;#34;)  Image(systemName: &amp;#34;4.circle&amp;#34;)  Image(systemName: &amp;#34;5.circle&amp;#34;)  Image(systemName: &amp;#34;6.circle&amp;#34;)  Image(systemName: &amp;#34;7.circle&amp;#34;)  Image(systemName: &amp;#34;8.circle&amp;#34;)  Image(systemName: &amp;#34;9.circle&amp;#34;)  Image(systemName: &amp;#34;10.circle&amp;#34;)  }.font(.largeTitle) }) ScrollView(Axis.Set.vertical, showsIndicators: true, content: {  LazyVGrid(columns: gridItems) {  Image(systemName: &amp;#34;1.square&amp;#34;)  Image(systemName: &amp;#34;2.square&amp;#34;)  Image(systemName: &amp;#34;3.square&amp;#34;)  Image(systemName: &amp;#34;4.square&amp;#34;)  Image(systemName: &amp;#34;5.square&amp;#34;)  Image(systemName: &amp;#34;6.square&amp;#34;)  Image(systemName: &amp;#34;7.square&amp;#34;)  Image(systemName: &amp;#34;8.square&amp;#34;)  Image(systemName: &amp;#34;9.square&amp;#34;)  Image(systemName: &amp;#34;10.square&amp;#34;)  }.font(.largeTitle) }) Defining Multiple Rows/Columns 上面代码创建了一个单行的LazyHGrid和单列的LazyVGrid，单行和单列是由GridItem数组定义的。如果想创建多行和多列，可以定义超过一个元素的GridItem数组：
let gridItems = [GridItem(), GridItem()] 上面代码将创建两行的LazyHGrid或者两列的LazyVGrid。每向数组中添加一个GridItem，就会增加网格的行数或列数。
let gridItems = [GridItem(), GridItem(), GridItem()]  VStack {  ScrollView(Axis.Set.horizontal, showsIndicators: true, content: {  LazyHGrid(rows: gridItems) {  Image(systemName: &amp;#34;1.circle&amp;#34;)  Image(systemName: &amp;#34;2.circle&amp;#34;)  Image(systemName: &amp;#34;3.circle&amp;#34;)  Image(systemName: &amp;#34;4.circle&amp;#34;)  Image(systemName: &amp;#34;5.circle&amp;#34;)  Image(systemName: &amp;#34;6.circle&amp;#34;)  Image(systemName: &amp;#34;7.circle&amp;#34;)  Image(systemName: &amp;#34;8.circle&amp;#34;)  Image(systemName: &amp;#34;9.circle&amp;#34;)  Image(systemName: &amp;#34;10.circle&amp;#34;)  }.font(.largeTitle)  })  ScrollView(.vertical, showsIndicators: true) {  LazyVGrid(columns: gridItems) {  Image(systemName: &amp;#34;1.square&amp;#34;)  Image(systemName: &amp;#34;2.square&amp;#34;)  Image(systemName: &amp;#34;3.square&amp;#34;)  Image(systemName: &amp;#34;4.square&amp;#34;)  Image(systemName: &amp;#34;5.square&amp;#34;)  Image(systemName: &amp;#34;6.square&amp;#34;)  Image(systemName: &amp;#34;7.square&amp;#34;)  Image(systemName: &amp;#34;8.square&amp;#34;)  Image(systemName: &amp;#34;9.square&amp;#34;)  Image(systemName: &amp;#34;10.square&amp;#34;)  }.font(.largeTitle)  } } 请注意，当使用LazyHGrid填充时，SwiftUI会将每个项目放在不同的行中。这就是为什么圆圈1出现在顶行，圆圈2出现在第二行，圆圈3出现在第三行，而圆圈4又再次出现在顶行的原因。
当使用LazyVGrid填充时也是如此，只不过SwiftUI将每个项目放在单独的一列中。方形1出现在第一列，方块2出现在第二列，方块3出现在第三列，方块4再次出现在第一列。
只有当网格不能显示所有项目时，才会出现滚动指示器。当显示三行或三列时，所有项目都可以显示，因此不需要显示滚动指示器。
Adjusting Spacing Between Rows/Columns 通过创建GridItem数组，可以定义网格中的行数/列数。为了实现更多自定义功能，还可以定义行与列之间的间距。定义网格中行/列间距的三种方法包括：
 .fixed .flexible .adaptive  .fixed选项可定义一个数值（CGFloat数据类型）来指定间距。下面定义了不同的固定间距选项，可以看到它们是如何影响网格中行和列的外观。
let gridItems = [GridItem(.fixed(25)), GridItem(.fixed(25)), GridItem(.fixed(25))] VStack {  ScrollView(Axis.Set.horizontal, showsIndicators: true, content: {  LazyHGrid(rows: gridItems) {  Image(systemName: &amp;#34;1.circle&amp;#34;)  Image(systemName: &amp;#34;2.circle&amp;#34;)  Image(systemName: &amp;#34;3.circle&amp;#34;)  Image(systemName: &amp;#34;4.circle&amp;#34;)  Image(systemName: &amp;#34;5.circle&amp;#34;)  Image(systemName: &amp;#34;6.circle&amp;#34;)  Image(systemName: &amp;#34;7.circle&amp;#34;)  Image(systemName: &amp;#34;8.circle&amp;#34;)  Image(systemName: &amp;#34;9.circle&amp;#34;)  Image(systemName: &amp;#34;10.circle&amp;#34;)  }.font(.largeTitle)  })  ScrollView(.vertical, showsIndicators: true) {  LazyVGrid(columns: gridItems) {  Image(systemName: &amp;#34;1.square&amp;#34;)  Image(systemName: &amp;#34;2.square&amp;#34;)  Image(systemName: &amp;#34;3.square&amp;#34;)  Image(systemName: &amp;#34;4.square&amp;#34;)  Image(systemName: &amp;#34;5.square&amp;#34;)  Image(systemName: &amp;#34;6.square&amp;#34;)  Image(systemName: &amp;#34;7.square&amp;#34;)  Image(systemName: &amp;#34;8.square&amp;#34;)  Image(systemName: &amp;#34;9.square&amp;#34;)  Image(systemName: &amp;#34;10.square&amp;#34;)  }.font(.largeTitle)  } }  let gridItems = [GridItem(.fixed(120)),GridItem(.fixed(120)),GridItem(.fixed(120))] VStack {  ScrollView(Axis.Set.horizontal, showsIndicators: true, content: {  LazyHGrid(rows: gridItems) {  Image(systemName: &amp;#34;1.circle&amp;#34;)  Image(systemName: &amp;#34;2.circle&amp;#34;)  Image(systemName: &amp;#34;3.circle&amp;#34;)  Image(systemName: &amp;#34;4.circle&amp;#34;)  Image(systemName: &amp;#34;5.circle&amp;#34;)  Image(systemName: &amp;#34;6.circle&amp;#34;)  Image(systemName: &amp;#34;7.circle&amp;#34;)  Image(systemName: &amp;#34;8.circle&amp;#34;)  Image(systemName: &amp;#34;9.circle&amp;#34;)  Image(systemName: &amp;#34;10.circle&amp;#34;)  }.font(.largeTitle)  })  ScrollView(.vertical, showsIndicators: true) {  LazyVGrid(columns: gridItems) {  Image(systemName: &amp;#34;1.square&amp;#34;)  Image(systemName: &amp;#34;2.square&amp;#34;)  Image(systemName: &amp;#34;3.square&amp;#34;)  Image(systemName: &amp;#34;4.square&amp;#34;)  Image(systemName: &amp;#34;5.square&amp;#34;)  Image(systemName: &amp;#34;6.square&amp;#34;)  Image(systemName: &amp;#34;7.square&amp;#34;)  Image(systemName: &amp;#34;8.square&amp;#34;)  Image(systemName: &amp;#34;9.square&amp;#34;)  Image(systemName: &amp;#34;10.square&amp;#34;)  }.font(.largeTitle)  } } 为网格中的行列间距定义一个.fixed值，可以在任何iOS设备上获得可预测的结果。不过，在较小或较大的iOS设备屏幕上，.fixed值不一定总是好看。如果想创建能根据不同屏幕尺寸变化的网格，可以使用.flexible或.adaptive。
.flexible选项会尽量扩大行/列之间的间距。而.adaptive选项会尽可能缩小行/列之间的间距。.flexible（灵活）和.adaptive（自适应）选项都允许定义一个最小值和一个最大值。
let gridItems = [  GridItem(.flexible(minimum: 20, maximum: 450)),  GridItem(.flexible(minimum: 20, maximum: 450)),  GridItem(.flexible(minimum: 20, maximum: 450)) ] VStack {  ScrollView(Axis.Set.horizontal, showsIndicators: true, content: {  LazyHGrid(rows: gridItems) {  Image(systemName: &amp;#34;1.circle&amp;#34;)  Image(systemName: &amp;#34;2.circle&amp;#34;)  Image(systemName: &amp;#34;3.circle&amp;#34;)  Image(systemName: &amp;#34;4.circle&amp;#34;)  Image(systemName: &amp;#34;5.circle&amp;#34;)  Image(systemName: &amp;#34;6.circle&amp;#34;)  Image(systemName: &amp;#34;7.circle&amp;#34;)  Image(systemName: &amp;#34;8.circle&amp;#34;)  Image(systemName: &amp;#34;9.circle&amp;#34;)  Image(systemName: &amp;#34;10.circle&amp;#34;)  }.font(.largeTitle)  })  ScrollView(.vertical, showsIndicators: true) {  LazyVGrid(columns: gridItems) {  Image(systemName: &amp;#34;1.square&amp;#34;)  Image(systemName: &amp;#34;2.square&amp;#34;)  Image(systemName: &amp;#34;3.square&amp;#34;)  Image(systemName: &amp;#34;4.square&amp;#34;)  Image(systemName: &amp;#34;5.square&amp;#34;)  Image(systemName: &amp;#34;6.square&amp;#34;)  Image(systemName: &amp;#34;7.square&amp;#34;)  Image(systemName: &amp;#34;8.square&amp;#34;)  Image(systemName: &amp;#34;9.square&amp;#34;)  Image(systemName: &amp;#34;10.square&amp;#34;)  }.font(.largeTitle)  } }   let gridItems = [  GridItem(.adaptive(minimum: 20, maximum: 450)),  GridItem(.adaptive(minimum: 20, maximum: 450)),  GridItem(.adaptive(minimum: 20, maximum: 450)) ] VStack {  ScrollView(Axis.Set.horizontal, showsIndicators: true, content: {  LazyHGrid(rows: gridItems) {  Image(systemName: &amp;#34;1.circle&amp;#34;)  Image(systemName: &amp;#34;2.circle&amp;#34;)  Image(systemName: &amp;#34;3.circle&amp;#34;)  Image(systemName: &amp;#34;4.circle&amp;#34;)  Image(systemName: &amp;#34;5.circle&amp;#34;)  Image(systemName: &amp;#34;6.circle&amp;#34;)  Image(systemName: &amp;#34;7.circle&amp;#34;)  Image(systemName: &amp;#34;8.circle&amp;#34;)  Image(systemName: &amp;#34;9.circle&amp;#34;)  Image(systemName: &amp;#34;10.circle&amp;#34;)  }.font(.largeTitle)  })  ScrollView(.vertical, showsIndicators: true) {  LazyVGrid(columns: gridItems) {  Image(systemName: &amp;#34;1.square&amp;#34;)  Image(systemName: &amp;#34;2.square&amp;#34;)  Image(systemName: &amp;#34;3.square&amp;#34;)  Image(systemName: &amp;#34;4.square&amp;#34;)  Image(systemName: &amp;#34;5.square&amp;#34;)  Image(systemName: &amp;#34;6.square&amp;#34;)  Image(systemName: &amp;#34;7.square&amp;#34;)  Image(systemName: &amp;#34;8.square&amp;#34;)  Image(systemName: &amp;#34;9.square&amp;#34;)  Image(systemName: &amp;#34;10.square&amp;#34;)  }.font(.largeTitle)  } } Creating Tables Using GridRows 通常，网格中的数据可以类似于表格的行和列进行组织。为了在SwiftUI中模仿表格，有一种特殊的GridRow可让在网格中定义数据行。
Grid() {  GridRow {  Text(&amp;#34;Movies&amp;#34;)  Text(&amp;#34;Distributer&amp;#34;)  }.bold().font(.largeTitle)  GridRow {  Text(&amp;#34;The Martian&amp;#34;)  Text(&amp;#34;20th Century&amp;#34;)  }  GridRow {  Text(&amp;#34;E.T.&amp;#34;)  Text(&amp;#34;Universal&amp;#34;)  }  GridRow {  Text(&amp;#34;Raiders of the Lost Ark&amp;#34;)  Text(&amp;#34;Paramount&amp;#34;)  }  GridRow {  Text(&amp;#34;Toy Story&amp;#34;)  Text(&amp;#34;Buena Vista Pictures&amp;#34;)  }  GridRow {  Text(&amp;#34;Dunkirk&amp;#34;)  Text(&amp;#34;Warner Brothers&amp;#34;)  } } 有两种格式化网格外观的方法，分别是分隔线和对齐方式。分隔线在每个网格行之间显示一条水平线，而对齐方式可定义数据在每个网格行中的显示方式，如.center（默认）、.leading（左对齐）或.trailing（右对齐）。
Grid(alignment: .leading) {  GridRow {  Text(&amp;#34;Movies&amp;#34;)  Text(&amp;#34;Distributer&amp;#34;)  }.bold().font(.largeTitle)  GridRow {  Text(&amp;#34;The Martian&amp;#34;)  Text(&amp;#34;20th Century&amp;#34;)  }  Divider()  GridRow {  Text(&amp;#34;E.T.&amp;#34;)  Text(&amp;#34;Universal&amp;#34;)  }  Divider()  GridRow {  Text(&amp;#34;Raiders of the Lost Ark&amp;#34;)  Text(&amp;#34;Paramount&amp;#34;)  }  Divider()  GridRow {  Text(&amp;#34;Toy Story&amp;#34;)  Text(&amp;#34;Buena Vista Pictures&amp;#34;)  }  Divider()  GridRow {  Text(&amp;#34;Dunkirk&amp;#34;)  Text(&amp;#34;Warner Brothers&amp;#34;)  } } Grid(alignment: .center) {  GridRow {  Text(&amp;#34;Movies&amp;#34;)  Text(&amp;#34;Distributer&amp;#34;)  }.bold().font(.largeTitle)  GridRow {  Text(&amp;#34;The Martian&amp;#34;)  Text(&amp;#34;20th Century&amp;#34;)  }  Divider()  GridRow {  Text(&amp;#34;E.T.&amp;#34;)  Text(&amp;#34;Universal&amp;#34;)  }  Divider()  GridRow {  Text(&amp;#34;Raiders of the Lost Ark&amp;#34;)  Text(&amp;#34;Paramount&amp;#34;)  }  Divider()  GridRow {  Text(&amp;#34;Toy Story&amp;#34;)  Text(&amp;#34;Buena Vista Pictures&amp;#34;)  }  Divider()  GridRow {  Text(&amp;#34;Dunkirk&amp;#34;)  Text(&amp;#34;Warner Brothers&amp;#34;)  } } Chapter 20 动画可以移动用户界面上的项目，以提供反馈或增加美感。与传统的手工动画不同，SwiftUI中的动画只需定义一个起始和结束状态。然后，SwiftUI就会在起始和结束状态之间为项目制作动画。最常见的三种动画类型:
 移动：更改用户界面上项目的x和y位置。 缩放：通过缩小或放大改变项目大小。 旋转：以顺时针或逆时针方向改变项目的角度。  创建动画需要定义动画的内容、动画的方式（移动、缩放、旋转）以及动画的时间。动画通常会在用户进行操作（如点击按钮）或发生特定事件（如数值达到某个点）时出现。
Moving Animation 要移动视图，必须定义一个x、y起始位置和一个 x、y终止位置。指定位置的两个修改器分别是.position和.offset。修改器.position可将视图移动到远离iOS设备屏幕左上角（原点（0,0))的特定x和y位置。.offset修改器可将视图置于特定的x和y位置，使其远离正常情况下出现在用户界面上的位置。
.position修改器定义屏幕上的固定位置；而.offset修改器定义相对于正常情况的偏移。在这两种情况下，正x值会使视图向右移动，正y值会使视图向下移动。
使用.position和.offset这两个修改器，极端的x或y值有可能使视图偏离屏幕。在下面代码中，.animation修改器提供了文本视图两个不同x和y位置之间的过渡。每次点击切换按钮时，动画都会再次运行。
@State var move = false  VStack {  Text(&amp;#34;A Text view&amp;#34;)  .offset(x: move ? 100 : 0, y: move ? 100 : 0)  .animation(.default, value: move)  Toggle(isOn: $move) {  Text(&amp;#34;Toggle me&amp;#34;)  } } 使用.animation修改器需要定义所需的动画类型（如.default）和触发动画的状态变量。在上面代码中，每次move变量发生变化时，都需要动画，因此.animation修改器会在其参数中传入move：
@State var move = true .animation(.default, value: move) Scaling Animation 另一种创建动画的方法是为视图定义不同的尺寸，即缩放视图。要定义视图尺寸的起始和终止状态，可使用 .scaleEffect修改器并定义要进行的相对尺寸变化。例如，.scaleEffect(1)表示视图的当前大小。.scaleEffect值大于1则表示更大的尺寸，而.scaleEffect值小于1则表示更小的尺寸。
@State private var changeMe = false  VStack {  Image(systemName: &amp;#34;tortoise.fill&amp;#34;)  .font(.system(size: 100))  .foregroundColor(.red)  .scaleEffect(changeMe ? 1.75 : 1)  .animation(.default, value: changeMe)  .onTapGesture {  changeMe.toggle()  } } Rotating Animation 旋转动画是指.rotationEffect修改器改变视图的角度。如果.rotationEffect值为0，则不旋转；如果旋转角度小于0，则视图会逆时针旋转；若角度大于0，则视图会顺时针旋转。
@State var myDegrees: Double = 0.0 @State var flag = false  Text(&amp;#34;Hello, world!&amp;#34;)  .padding()  .rotationEffect(Angle(degrees: flag ? myDegrees : 0))  .animation(.default, value: flag) Button(&amp;#34;Animate now&amp;#34;) {  flag.toggle() } Slider(value: $myDegrees, in: -180 ... 180, step: 1).padding() Animation Options 到目前为止，使用.animation修改器时每次都是使用.default设置。虽然这种方法可行，但还可以选择其它几种动画选项：
 .easeIn：开始时动画速度较慢，然后速度加快。 .easeOut：在接近结尾时减慢动画速度。 .easeInOut：动画开始时速度较慢，然后加快，临近结束时速度减慢（与.default相同）。 .linear：动画从开始到结束以恒定速度运行。  Button(&amp;#34;Start animation&amp;#34;) {  start.toggle() } HStack {  Text(&amp;#34;easeIn&amp;#34;).offset(x: 0, y: start ? 450 : 0).animation(.easeIn, value: start)  Text(&amp;#34;easeOut&amp;#34;).offset(x: 0, y: start ? 450 : 0).animation(.easeOut, value: start)  Text(&amp;#34;easeInOut&amp;#34;).offset(x: 0, y: start ? 450 : 0).animation(.easeInOut, value: start)  Text(&amp;#34;linear&amp;#34;).offset(x: 0, y: start ? 450 : 0).animation(.linear, value: start) }.position(x: 150, y: 10) Using Delays and Duration in Animation 按时间修改动画的两种方式为延迟和持续时间。延迟可以指定在动画开始前要等待多少秒。持续时间可指定动画应持续多长时间。持续时间值越大，动画运行速度越慢，时间值越短，动画运行速度越快。
要定义延迟，在.animation修改器选项中添加.delay修改器，例如.animation(.linear.delay(2.5), value: yourVariableNameHere):
@State private var start = false  VStack {  Button(&amp;#34;Start animation&amp;#34;) {  start.toggle()  }  HStack {  Text(&amp;#34;easeIn&amp;#34;).offset(x: 0, y: start ? 450 : 0).animation(.easeIn.delay(0.5), value: start)  Text(&amp;#34;easeOut&amp;#34;).offset(x: 0, y: start ? 450 : 0).animation(.easeOut.delay(1.0), value: start)  Text(&amp;#34;easeInOut&amp;#34;).offset(x: 0, y: start ? 450 : 0).animation(.easeInOut.delay(1.5), value: start)  Text(&amp;#34;linear&amp;#34;).offset(x: 0, y: start ? 450 : 0).animation(.linear.delay(2.5), value: start)  }.position(x: 150, y: 10) } 要定义持续时间，需要将持续时间添加到.animation修改器的选项中，例如.animation(.easeIn(duration: 0.7), value: start)。
@State private var start = false  VStack {  Button(&amp;#34;Start animation&amp;#34;) {  start.toggle()  }  HStack {  Text(&amp;#34;easeIn&amp;#34;).offset(x: 0, y: start ? 450 : 0).animation(.easeIn(duration: 0.7), value: start)  Text(&amp;#34;easeOut&amp;#34;).offset(x: 0, y: start ? 450 : 0).animation(.easeOut(duration: 1.7), value: start)  Text(&amp;#34;easeInOut&amp;#34;).offset(x: 0, y: start ? 450 : 0).animation(.easeInOut(duration: 2.6), value: start)  Text(&amp;#34;linear&amp;#34;).offset(x: 0, y: start ? 450 : 0).animation(.linear(duration: 3.1), value: start)  }.position(x: 150, y: 10) } 实际上延迟和持续时间可以同时使用:
@State private var start = false  VStack {  Button(&amp;#34;Start animation&amp;#34;) {  start.toggle()  }  HStack {  Text(&amp;#34;easeIn&amp;#34;).offset(x: 0, y: start ? 450 : 0).animation(.easeIn(duration: 0.7).delay(0.5), value: start)  Text(&amp;#34;easeOut&amp;#34;).offset(x: 0, y: start ? 450 : 0).animation(.easeOut(duration: 1.7).delay(1.0), value: start)  Text(&amp;#34;easeInOut&amp;#34;).offset(x: 0, y: start ? 450 : 0).animation(.easeInOut(duration: 2.6).delay(1.5), value: start)  Text(&amp;#34;linear&amp;#34;).offset(x: 0, y: start ? 450 : 0).animation(.linear(duration: 3.1).delay(2.5), value: start)  }.position(x: 150, y: 10) } Using an Interpolating Spring in Animation 为了提供更多自定义动画效果，还可以为动画添加.interpolatingSpring修改器。通过.interpolatingSpring可以定义以下一种或多种方式：
 Mass：数值较小时动画速度较慢，反弹较多；数值较大时动画速度较快，反弹较小。 Stiffness：数值较小时，动画速度慢；数值较大时，动画速度快。 Damping：数值较小时会产生更多的反弹；数值较大时会抑制反弹。 InitialVelocity：数值较小时动画开始时速度较慢；数值较大时动画开始时速度较快。  下面代码中，每个.animation修改器的damping参数相同，但stiffness参数不同：
@State private var start = false  VStack {  Button(&amp;#34;Start animation&amp;#34;) {  start.toggle()  }  HStack {  Text(&amp;#34;spring&amp;#34;).offset(x: 0, y: start ? 450 : 0).animation(.interpolatingSpring(stiffness: 1, damping: 1), value: start)  Text(&amp;#34;spring&amp;#34;).offset(x: 0, y: start ? 450 : 0).animation(.interpolatingSpring(stiffness: 1.8, damping: 1), value: start)  Text(&amp;#34;spring&amp;#34;).offset(x: 0, y: start ? 450 : 0).animation(.interpolatingSpring(stiffness: 0.5, damping: 1), value: start)  Text(&amp;#34;spring&amp;#34;).offset(x: 0, y: start ? 450 : 0).animation(.interpolatingSpring(stiffness: 2, damping: 1), value: start)  }.position(x: 150, y: 10) } 除了stiffness和damping外，还可以定义mass和initialVelocity。通过尝试所有四个参数的不同值，可以进一步自定义动画:
VStack {  Button(&amp;#34;Start animation&amp;#34;) {  start.toggle()  }  HStack {  Text(&amp;#34;spring&amp;#34;).offset(x: 0, y: start ? 450 : 0)  .animation(.interpolatingSpring(mass: 1, stiffness: 1, damping: 1, initialVelocity: 1), value: start)  Text(&amp;#34;spring&amp;#34;).offset(x: 0, y: start ? 450 : 0)  .animation(.interpolatingSpring(mass: 1.9, stiffness: 1, damping: 1, initialVelocity: 1), value: start)  Text(&amp;#34;spring&amp;#34;).offset(x: 0, y: start ? 450 : 0)  .animation(.interpolatingSpring(mass: 2.5, stiffness: 1, damping: 1, initialVelocity: 1), value: start)  Text(&amp;#34;spring&amp;#34;).offset(x: 0, y: start ? 450 : 0)  .animation(.interpolatingSpring(mass: 3.5, stiffness: 1, damping: 1, initialVelocity: 1), value: start)  }.position(x: 150, y: 10) } Using withAnimation 通过使用.animation修改器，可以定义要为哪些视图添加动画。使用.animation修改器的一个问题是，如果有五个视图需要相同的动画效果，就必须为五个视图都添加相同的.animation修改器。
VStack {  Button(&amp;#34;Start animation&amp;#34;) {  start.toggle()  }  HStack {  Text(&amp;#34;One&amp;#34;).offset(x: 0, y: start ? 450 : 0).animation(.default, value: start)  Text(&amp;#34;Two&amp;#34;).offset(x: 0, y: start ? 450 : 0).animation(.default, value: start)  Text(&amp;#34;Three&amp;#34;).offset(x: 0, y: start ? 450 : 0).animation(.default, value: start)  Text(&amp;#34;Four&amp;#34;).offset(x: 0, y: start ? 450 : 0).animation(.default, value: start)  Text(&amp;#34;Five&amp;#34;).offset(x: 0, y: start ? 450 : 0).animation(.default, value: start)  }.position(x: 150, y: 10) } 为了解决这个问题，SwiftUI提供了第二种为视图添加动画的方法。通过withAnimation，可以指定一个可为视图添加动画的状态变量。不必在不同的视图上编写多个.animation修改器，而只需定义要影响的状态变量，当该状态变量发生变化时，它就会自动为使用该状态变量的任何视图生成动画：
VStack {  Button(&amp;#34;Start animation&amp;#34;) {  withAnimation {  start.toggle()  }  }  HStack {  Text(&amp;#34;One&amp;#34;).offset(x: 0, y: start ? 450 : 0)  Text(&amp;#34;Two&amp;#34;).offset(x: 0, y: start ? 450 : 0)  Text(&amp;#34;Three&amp;#34;).offset(x: 0, y: start ? 450 : 0)  Text(&amp;#34;Four&amp;#34;).offset(x: 0, y: start ? 450 : 0)  Text(&amp;#34;Five&amp;#34;).offset(x: 0, y: start ? 450 : 0)  }.position(x: 150, y: 10) } Chapter 21 iOS设备的用户界面必须适应不同的屏幕尺寸。不仅iPhone和iPad屏幕尺寸不同，而且市场上不同型号的iPhone和iPad也有不同的屏幕尺寸。为了解决这个问题，SwiftUI将用户界面项目置于中心位置，但如果需要将用户界面的视图精确地放置在特定位置，该怎么办呢？
指定X和Y坐标是行不通的，因为在大屏幕上看起来不错的东西，在小得多的屏幕上看起来就不合适了，反之亦然。如果需要在屏幕上的特定位置放置用户界面项目，比较安全的方法是使用GeometryReader。
GeometryReader就像一个容器，能自动适应不同的屏幕尺寸。添加GeometryReader后，就可以使用 GeometryReader的相对坐标来放置用户界面中的视图，而不是使用不同尺寸屏幕的精确坐标。这样，当应用程序在不同尺寸的屏幕上运行时，GeometryReader也会调整其相对坐标。
Understanding the GeometryReader GeometryReader可以像堆栈一样容纳多个视图。主要区别在于，GeometryReader会尽可能多地扩展空间。此外，GeometryReader还可以获取其宽度和高度。
GeometryReader { geometry in 	// Views defined here  } GeometryReader可以使用一个任意命名的变量，上面代码中的这个变量名为geometry。要获取GeometryReader的宽度和高度，可以下面这样获取size.width和size.height属性：
geometry.size.width geometry.size.height 下面代码是使用GeometryReader的简单示例：
GeometryReader { geometry in  VStack {  Text(&amp;#34;Width = \(geometry.size.width)&amp;#34;)  Text(&amp;#34;Height = \(geometry.size.height)&amp;#34;)  } }.background(Color.yellow) Understanding the Differences Between Global and Local Coordinates 了解了GeometryReader是如何缩小或扩展以适应不同iOS屏幕尺寸后，下一步就是了解GeometryReader的坐标是如何工作的。GeometryReader中的坐标称为本地坐标。
全局坐标指的是整个iOS屏幕。虽然不同iOS设备屏幕的全局坐标总是不同，但GeometryReader中的局部坐标却始终保持一致。
var body: some View {  GeometryReader { geometry in  VStack {  Text(&amp;#34;Local X origin = \(geometry.frame(in: .local).origin.x)&amp;#34;)  Text(&amp;#34;Local Y origin = \(geometry.frame(in: .local).origin.y)&amp;#34;)  Divider()  Text(&amp;#34;Global X origin = \(geometry.frame(in: .global).origin.x)&amp;#34;)  Text(&amp;#34;Global Y origin = \(geometry.frame(in: .global).origin.y)&amp;#34;)  }  }.background(Color.yellow) } 请注意，局部原点是(0,0)，因为它从iOS屏幕的左上角开始。然而，全局原点却显示在(0,59)处。这是因为GeometryReader实际上出现在iPhone 14 Pro机型的凹口下方。
如果在.background(Color.yellow)修改器后添加.ignoreAllSafeAreas()修改器，这样就忽略了凹槽周围的区域，因此全局y原点现在显示在屏幕的左上角，局部y原点一样。
var body: some View {  GeometryReader { geometry in  VStack {  Text(&amp;#34;Local X origin = \(geometry.frame(in: .local).origin.x)&amp;#34;)  Text(&amp;#34;Local Y origin = \(geometry.frame(in: .local).origin.y)&amp;#34;)  Divider()  Text(&amp;#34;Global X origin = \(geometry.frame(in: .global).origin.x)&amp;#34;)  Text(&amp;#34;Global Y origin = \(geometry.frame(in: .global).origin.y)&amp;#34;)  }  }.background(Color.yellow).ignoresSafeArea() } 下面的代码使用VStack将GeometryReader向下推，然后使用HStack将 GeometryReader向右推。请注意，GeometryReader的本地原点仍然是(0,0)，但全局原点与从iOS屏幕左上角测量的原点不同:
var body: some View {  VStack {  Text(&amp;#34;This Text view pushes the GeometryReader down&amp;#34;)  HStack {  Text(&amp;#34;Pushes to the right&amp;#34;)  GeometryReader { geometry in  VStack {  Text(&amp;#34;Local X origin = \(geometry.frame(in: .local).origin.x)&amp;#34;)  Text(&amp;#34;Local Y origin = \(geometry.frame(in: .local).origin.y)&amp;#34;)  Divider()  Text(&amp;#34;Global X origin = \(geometry.frame(in: .global).origin.x)&amp;#34;)  Text(&amp;#34;Global Y origin = \(geometry.frame(in: .global).origin.y)&amp;#34;)  }  }.background(Color.yellow).ignoresSafeArea()  }  } } Identifying Minimum, Mid, and Maximum Values of a GeometryReader 全局坐标取决于当前的iOS屏幕尺寸。较小iOS屏幕上的最大X坐标和Y坐标与较大iOS屏幕上的最大X坐标和Y坐标不同。因此，使用全局坐标在屏幕上定位视图可能会将视图完全移出屏幕或截断部分视图。
另一方面，在GeometryReader使用局部坐标可以自动适应不同的屏幕尺寸。由于GeometryReader的宽度或高度会根据iOS屏幕尺寸的不同而变化，因此重要的是不要使用固定值，而应使用最小值和最大值。GeometryReader可访问以下已定义的属性：
var body: some View {  GeometryReader { geometry in  VStack {  Text(&amp;#34;minX = \(geometry.frame(in: .local).minX)&amp;#34;)  Text(&amp;#34;midX = \(geometry.frame(in: .local).midX)&amp;#34;)  Text(&amp;#34;maxX = \(geometry.frame(in: .local).maxX)&amp;#34;)  Divider()  Text(&amp;#34;minY = \(geometry.frame(in: .local).minY)&amp;#34;)  Text(&amp;#34;midY = \(geometry.frame(in: .local).midY)&amp;#34;)  Text(&amp;#34;maxY = \(geometry.frame(in: .local).maxY)&amp;#34;)  }  }.background(Color.yellow) } </content>
    </entry>
    
     <entry>
        <title></title>
        <url>https://iihui.github.io/post/ios-async/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> 第1本 asyn &amp;amp; await 方法定义中的async关键字让编译器知道代码是在一个异步上下文中运行。换句话说，它表示代码可以随意暂停和恢复。另外，无论该方法需要多长时间完成，它最终都会像同步方法一样返回一个值。
func availableSymbols() async throws -&amp;gt; [String] { 	guard let url = URL(string: &amp;#34;http://localhost:8080/littlejohn/symbols&amp;#34;) else {  throw &amp;#34;The URL could not be created.&amp;#34; 	} } 然后在上面的代码的底部添加如下代码：
let (data, response) = try await URLSession.shared.data(from: url) 上面调用异步方法URLSession.data(from:delegate:)后，会暂停availableSymbols()，并在从服务器获取数据后恢复它。
使用await会给运行时提供一个暂停点：暂停当前方法，并考虑是否有其它任务要先运行，然后继续运行你的代码。这样做是非常方便的，因为可以进行异步调用，而不必担心线程或闭包传递。
第2本 struct Entry: Identifiable {  let id = UUID()  let imageName: String }  func errorEntry() -&amp;gt; Entry {  Entry(imageName: &amp;#34;circle.slash&amp;#34;) }  extension Entry: Equatable {  static func == (lhs: Entry, rhs: Entry) -&amp;gt; Bool {  lhs.imageName == rhs.imageName  } }  extension Entry {  static var exampleEntry: Entry {  Entry(imageName: &amp;#34;1.circle&amp;#34;)  }   static var exampleEntries: [Entry] {  [Entry(imageName: &amp;#34;1.circle&amp;#34;),  Entry(imageName: &amp;#34;2.circle&amp;#34;),  Entry(imageName: &amp;#34;3.circle&amp;#34;),  Entry(imageName: &amp;#34;4.circle&amp;#34;),  errorEntry()]  } } </content>
    </entry>
    
     <entry>
        <title>Programming for Beginners</title>
        <url>https://iihui.github.io/post/ios-beginner/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> Xcode界面   工具栏：用于构建和运行应用程序，以及查看运行任务的进度。
  导航区：提供对项目各个部分的快速访问，默认情况下会显示项目导航器。
  编辑器区：允许编辑源代码、用户界面和其他资源。
  检查器区：允许查看和编辑在导航器区域或编辑器区域中选择的项目的信息。
  调试区：包含调试栏、变量视图和控制台。通过键入Shift &#43; Command &#43; Y来切换调试区域。
  工具栏 下图是工具栏的截图，使用编号来标记各个部分：
 导航按钮：打开和关闭导航器区域。 停止按钮：仅在应用程序运行时它会出现在“运行”按钮旁边，表示停止当前正在运行的应用程序。 运行按钮：用于构建和运行应用程序。 方案菜单：显示构建项目的特定方案和运行应用程序的目的地。方案和目的地是不同的，方案指定用于构建和运行项目的设置。目的地为应用程序指定安装位置，可以安装在物理设备和模拟器中。 活动视图：显示正在运行的任务的进度。  下图工具栏右边的截图，使用编号来标记各个部分：
 库按钮：显示用户界面元素、代码片段和其它资源。 检查器按钮：打开和关闭检查器区域。  模拟器 安装Xcode的时候就已经安装好了iOS模拟器。可以模拟iPad和iPhone的所有屏幕尺寸和分辨率，因此可以轻松地在多个设备上测试应用程序。
如果查看Scheme菜单，可能想知道No Devices和Build的用途。单击工具栏中的Scheme菜单以查看菜单顶部的No Devices和Build部分：
No Devices部分表示目前没有任何iOS设备连接到您的计算机。如果插入iOS设备，它将出现在此部分中，将能够运行在其上开发的应用程序进行测试。
建议在实际设备上运行您的应用程序，因为模拟器无法准确反映实际iOS设备的性能特征，并且不具备实际设备具有的某些硬件功能和软件API。
Build部分只有一个菜单项Any iOS Device (arm64)。当需要将应用提交到App Store之前对其进行归档时使用此选项。
无线连接设备 将iOS设备拔出并重新插入到Mac会变得相当麻烦，可以配置Xcode通过WiFi连接到iOS设备，进行App调试。
 首先确保iOS设备已经插入到Mac电脑，并且Mac和iOS设备在同一局域网内。 在Xcode菜单栏选择Window--&amp;gt;Device and Simulators。 对于选中的设备，勾选Connect via network。  按照上面的设置，如果依然出现Xcode will continue when iPhone is connected。则可以在左侧点击选中设备，鼠标右键，然后选中Connect via IP Address...，再输入真机的IP地址，即可连接：
简单的数据类型 在Swift中，浮点数字默认属于Double类型。Double类型占用64位，Float类型占用32位。
if isRestaurantOpen {  print(&amp;#34;Restaurant is open.&amp;#34;) } 集合 var movieGenres: Set = [&amp;#34;Horror&amp;#34;, &amp;#34;Action&amp;#34;, &amp;#34;Romantic Comedy&amp;#34;] movieGenres.insert(&amp;#34;Love&amp;#34;) debugPrint(movieGenres.count, movieGenres.isEmpty)  let movieGenres2: Set = [&amp;#34;Science Fiction&amp;#34;, &amp;#34;War&amp;#34;, &amp;#34;Fantasy&amp;#34;]  movieGenres.union(movieGenres2) debugPrint(movieGenres)  movieGenres.intersection(movieGenres2) debugPrint(movieGenres)  movieGenres.subtracting(movieGenres2) debugPrint(movieGenres)  movieGenres.symmetricDifference(movieGenres2) debugPrint(movieGenres) 闭包 闭包像一个函数，包含了一系列指令，可以接受参数，也可以有返回值。但是，闭包没有名字。闭包中的指令序列被花括号({ })包围，in关键字将参数和返回类型与闭包主体分开。
闭包可以赋值给常量或变量，因此在函数中传递它们很方便。下面的闭包用于计算数值的平方，并且将自定义的闭包传递给map函数：
let myClosure = { (item: Int) in  return item * item }  var numbersArray = [2, 4, 6, 7] let mappedNumbers = numbersArray.map(myClosure) debugPrint(mappedNumbers) 上面的闭包可以进一步简化：
var numbersArray = [2, 4, 6, 7] let mappedNumbers = numbersArray.map { (item: Int) -&amp;gt; Int in  return item * item }  debugPrint(mappedNumbers) 当闭包中参数的类型已经知道的时候，可以省略类型，进行进一步简化：
var numbersArray = [2, 4, 6, 7] let mappedNumbers = numbersArray.map({ item in  item * item })  debugPrint(mappedNumbers) 当闭包是函数中的唯一参数，可以省略括号：
var numbersArray = [2, 4, 6, 7] let mappedNumbers = numbersArray.map { item in  item * item }  debugPrint(mappedNumbers) 代码组织 程序被重写和修改的频率远远超过它们被创建的频率。这意味着大多数时候开发人员将修改由其他人编写或由自己在过去某个时间编写的现有代码。由于您可能正在编写您或其他人最终将在未来修改的代码，因此您需要确保您组织代码以使其易于理解。
</content>
    </entry>
    
     <entry>
        <title>AES 实现</title>
        <url>https://iihui.github.io/post/ios-aes/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  高级加密标准(AES,Advanced Encryption Standard)，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用是最常见的对称加密算法，它是一种对称加密算法（对称加密是指加密和解密使用相同的密钥）。AES支持128，192，256位3种长度的密钥，其中AES256安全性最高，AES128性能最好。
 加密流程 算法实现 import CommonCrypto import Foundation  /// AES-128加密参考自https://stackoverflow.com/questions/37680361/aes-encryption-in-swift class AES {  private let key: Data  private let iv: Data   init?(key: String, iv: String) {  guard key.count == kCCKeySizeAES128 || key.count == kCCKeySizeAES256, let keyData = key.data(using: .utf8) else {  DPrint(&amp;#34;密钥长度不对&amp;#34;)  return nil  }   guard iv.count == kCCBlockSizeAES128, let ivData = iv.data(using: .utf8) else {  DPrint(&amp;#34;初始化向量出错&amp;#34;)  return nil  }   self.key = keyData  self.iv = ivData  }   func encrypt(string: String) -&amp;gt; Data? {  return self.crypt(data: string.data(using: .utf8), option: CCOperation(kCCEncrypt))  }   func decrypt(data: Data?) -&amp;gt; String? {  guard let decryptedData = crypt(data: data, option: CCOperation(kCCDecrypt)) else {  return nil  }  return String(bytes: decryptedData, encoding: .utf8)  }   func crypt(data: Data?, option: CCOperation) -&amp;gt; Data? {  guard let data = data else {  return nil  }   let cryptLength = [UInt8](repeating: 0, count: data.count &#43; kCCBlockSizeAES128).count  var cryptData = Data(count: cryptLength)   let keyLength = [UInt8](repeating: 0, count: kCCBlockSizeAES128).count  let options = CCOptions(kCCOptionPKCS7Padding) // kCCOptionPKCS7Padding   var bytesLength = Int(0)    let status = cryptData.withUnsafeMutableBytes { cryptBytes in  data.withUnsafeBytes { dataBytes in  iv.withUnsafeBytes { ivBytes in  key.withUnsafeBytes { keyBytes in  CCCrypt(option, CCAlgorithm(kCCAlgorithmAES), options, keyBytes, keyLength, ivBytes, dataBytes, data.count, cryptBytes, cryptLength, &amp;amp;bytesLength)  }  }  }  }   guard UInt32(status) == UInt32(kCCSuccess) else {  DPrint(&amp;#34;加密出错，错误状态为：\(status)&amp;#34;)  return nil  }   cryptData.removeSubrange(bytesLength ..&amp;lt; cryptData.count)  return cryptData  } } func DPrint&amp;lt;T&amp;gt;(_ message: T, file: String = #file, method: String = #function, line: Int = #line) {  #if DEBUG  print(&amp;#34;\((file as NSString).lastPathComponent)[\(line)], \(method): \(message)&amp;#34;)  #endif }  参考资料 参考资料
</content>
    </entry>
    
     <entry>
        <title>Cookie简介</title>
        <url>https://iihui.github.io/post/cookie/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> 简介 标准的http协议是无状态的，即服务端对于客户端的每次请求都认为它是一个新的请求，上一次的会话和下一次的会话之间没有任何联系。当用户访问服务端并进行登录后，之后的客户端请求服务端依然无法对其身份进行识别。如果将客户端与服务器之间的多次交互当做一个整体来看，服务端若想识别客户端的身份，就需要将多次交互所涉及的数据「或称为状态」保存下来。
cookie的作用就是对请求和响应的状态进行管理，服务端通过在响应体中设置cookie (状态)，客户端会将cookie(状态) 存储起来。之后客户端的每个请求都将cookie(状态)带上，这样服务端就能够对客户端的身份进行识别。
早期实现 在早期cookie还未出现之前有个最简单的办法，就是在请求的页面中插入一个token，然后在下次请求时将这个token送至服务器。这需要在页面的form表单中插入一个包含token 的隐藏域，或者将token放在URL的query字符串中来传递。这两种方法都需要手动操作，因此极易出错。而使用cookie则不同，一般情况下客户端会自动存储服务器发来的cookie，并在之后的每次请求中自动带上cookie，无需客户端进行手动处理。
基本原理 当浏览器向服务器发送请求的时候，服务器将少量数据以set-cookie消息头的方式发送给客户端。浏览器一般自动将cookie数据进行存储，当客户端再次访问服务器时，会将这些数据以cookie消息头的方式发送给服务器，服务端就可以根据cookie消息头来判别用户的身份或进行一些特别的处理并返回响应，大致流程如下图所示：
属性介绍 cookie主要是用于管理服务端和客户端直接的状态，其本质上就是一堆存储在客户端的数据，每条cookie都有对应下面几个属性。
domain 属性domain指定了该cookie所属的域名。默认情况下，domain会被设置为创建该cookie 时所在的域名。某个域下的cookie如果希望能够被它的子域具有可见性（即可以读取），应该保证这个cookie在被设置时以.开头。
path 属性path指定了cookie所属的路径。domain和path两者一起来限制了cookie 允许被哪些URL访问。当请求某个资源「URL」时只有当该URL域名能够同时与domain和path属性匹配时，浏览器才会将此cookie自动添加到该请求的cookie头部中。
属性domain的匹配是根据请求URL中的域名从后向前进行匹配。而属性path的匹配则是判断URL中的路径是否包含path：
生存期 从cookie的工作原理可以知道cookie存储在客户端，而cookie在客户端的生存期主要由属性max-age或expires决定。属性expires是http/1.0协议中的，在新的http/1.1协议之后expires已经由 max-age代替。
max-age max-age属性以秒为单位，表示将在xxx秒后失效。根据其取值的不同，浏览器会做不同的处理，具体含义如下所示：
  默认情况下cookie只是暂时存在的，只在浏览器会话期间存在，当用户关闭浏览器窗口后这些值也会随之销毁。因为生成的cookie只是临时存储于浏览器内存中，并未做持久化处理。
  若max-age为正数，表示cookie会在max-age秒之后被销毁，此时cookie会做持久化处理，存储在本地文件中。
  若max-age为负数，行为与默认情况相同。表示cookie只在浏览器会话期间存在，当用户关闭浏览器窗口后这些值也会随之销毁，生成的cookie临时存储于浏览器内存中，并未做持久化。
  若max-age为0，表示cookie将被立即销毁，符合将在xxx秒后失效的表述。
  expires expires表示一个具体的到期时间，到了这个指定的时间后，浏览器就不再保留这个 cookie。它的值是UTC格式，可以使用Date.prototype.toUTCString()进行格式转换。
max-age属性则是指定从现在开始cookie存在的秒数，比如一年的有效期为60 * 60 * 24 * 365。过了这个时间以后，浏览器就不再保留这个cookie。
如果同时指定了expires和max-age，那么max-age的值将优先生效。如果没有指定expires或 max-age属性，那么这个cookie就是会话Cookie，即它只在本次对话存在，一旦用户关闭浏览器窗口，浏览器将不再保留。
secure 包含secure选项的cookie只有在当请求是HTTPS或其他安全协议时，才能被发送至服务器。但要注意，secure选项只是限定了在安全情况下才可以传输给服务端，但还是可以查看cookie的。
同时需要注意的是，如果想在客户端即网页中通过js去设置 secure类型的cookie，必须保证网页是https协议的。在http协议的网页中无法设置secure类型的cookie。
httpOnly 属性httpOnly的意思是告诉浏览器该cookie不能通过JavaScript的 document.cookie属性访问。
参考资料
session 除了cookie还经常使用session来记录客户端状态。session是服务端使用的一种用来记录客户端状态的机制，使用上比cookie简单一些，相应的也增加了服务器的存储压力。
客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是session。客户端浏览器再次访问时只需要从该session中查找该客户的状态就可以了。
session就是通过检查服务器上的“客户明细表”来确认客户身份。session好比程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。
参考资料
参考资料
Ajax Ajax的全称是Asynchronous JavaScript and XML，译为异步的JavaScript和XML。Ajax是Web2.0的技术核心，由多种技术集合而成。使用Ajax技术时不必刷新整个页面，只需对页面的局部进行更新，可以节省网络带宽，提高页面的加载速度，从而缩短用户等待时间，改善用户体验。
传统的web应用，当提交一个表单请求给服务器，服务器接收到请求之后，返回一个全新的页面给浏览器。这种做法浪费了很多带宽，因为发送请求前和获得的新页面中有很多html代码是相同的。由于每次用户的交互都需要向服务器发送请求，应用的访问时间取决于服务器的返回时间。
而使用Ajax就不同了，因为Ajax只取回一些必须的数据，它使用SOAP、XML或者支持JSON的Web Service接口，在客户端利用JavaScript处理来自服务器的响应，这样客户端和服务器之间的数据交互就减少了，从而用户请求就得到了加速。
Ajax是多种技术的组合，包括JavaScript异步数据获取技术，就是XMLHttpRequest以及XML以及Dom，还有表现技术XHTML和CSS。Ajax的核心是XMLHttpRequest，它是支持异步请求的技术，可以发送请求给服务器，并且不阻塞用户。其实XMLHttpRequest是JavaScript的一种语法子集，是它的一套API，支持发送GET和POST请求。该API是Ajax开发的核心，也是现在web技术的核心之一。通过这些技术，我们进行无序重新加载网页就可以发送和取回数据以完成交互。
Ajax全称是Asynchronous Javascript and XML。异步在这里简单地解释就是：向服务器发送请求的时候，不必等待结果，而是可以同时做其他的事情，等有了结果我们可以再来处理这个事。如果不是这样的话，我们点完按钮，页面就会卡死在那里，其他的数据请求不会往下走，这样比等待刷新似乎更加讨厌。虽然提供异步通讯功能的组件默认情况下都是异步的，但它们也提供了同步选项，如果你好奇把那个选项改为false的话，页面就会卡死。
XML只是一种数据格式，在这件事里并不重要，在更新一行字的时候理论上说不需要这个格式，但如果我们更新很多内容，那么格式化的数据可以使我们有条理地去实现更新。现在大部分是用JSON来代替XML的，因为前者更加简洁，据说目前的解析速度也更快。多快好省，能省则省啊。
总结：只要是JS调用异步通讯组件并使用格式化的数据来更新Web页面上的内容或操作过程，那么就应该算是使用Ajax。
参考资料
NSHttpCookies 302问题 参考资料
</content>
    </entry>
    
     <entry>
        <title>Java 基础</title>
        <url>https://iihui.github.io/post/java-base/</url>
        <categories>
          <category>java</category>
        </categories>
        <tags>
          <tag>java</tag>
        </tags>
        <content type="html"> 数据类型 在Java中数据分为两大类，一类是基本数据类型primitive types，另一类是引用类型reference types。基本类型所占的内存大小是固定的，在内存中存放的是数据值本身。引用类型在内存中存放的是指向该数据的地址，不是数值本身，它往往由多个基本数据组成。
基本数据类型 Java中共定义了4类8种基本类型，其中4种整数类型：byte,short,int,long，每种整型都是带符号的。2种浮点型：float，double。1种逻辑型:boolean。1种字符型:char。
整数有三种进制表示形式。八进制：以数字0开头，后跟多个0～7之间的数字。十六进制：以0x或0X开头，后跟多个0～9或者a～f之间的小写字母或A-F之间的大写字母，大小写字母可以混输。十进制：用多个0～9之间的数字表示，如果有两位及两位以上数字，首位不能为0（首位为0表示八进制）。在Java中，整型的范围与运行代码的机器无关，这与C&#43;&#43;的整型有明显区别。
int digit = 0x1dAc123; System.out.println(digit);  // 八进制 int n = 011; System.out.println(n);  // 执行结果 31113507 9 整数字面量默认为int类型，当需要将一个整数字面量强制转换为长整型时，需要在整数字面量后面添加小写字母l或大写字母L（建议使用大写字母L，因为小写字母容易被误看成阿拉伯数字1）。
一个浮点数值字面量默认为double类型，若在一个浮点字面量后面添加f或F，可以将其强制转换为float型。需要注意的是，浮点类型不适用于无法接受舍入误差的金融计算。
long length = 345L; double test = 45D; System.out.println(length); System.out.println(test);  // 执行结果 345 45.0 各种基本数据类型占用的字节数如下所示：
   数据类型 关键字 占用字节数 默认数值     布尔型 boolean 无规范 false   字节型 byte 1 0   短整型 short 2 0   整型 int 4 0   长整型 long 8 0   单精度浮点型 float 4 0.0F   双精度浮点型 double 8 0.0D   字符型 chart 2 ‘\u000&#39;    int intSize = Integer.SIZE; System.out.println(&amp;#34;int size: &amp;#34; &#43; (intSize / 8) &#43; &amp;#34;Byte&amp;#34;); int shortSize = Short.SIZE; System.out.println(&amp;#34;short size: &amp;#34; &#43; (shortSize / 8) &#43; &amp;#34;Byte&amp;#34;); int longSize = Long.SIZE; System.out.println(&amp;#34;long size: &amp;#34; &#43; (longSize / 8) &#43; &amp;#34;Byte&amp;#34;); int byteSize = Byte.SIZE; System.out.println(&amp;#34;byte size: &amp;#34; &#43; (byteSize / 8) &#43; &amp;#34;Byte&amp;#34;); int floatSize = Float.SIZE; System.out.println(&amp;#34;float size: &amp;#34; &#43; (floatSize / 8) &#43; &amp;#34;Byte&amp;#34;); int doubleSize = Double.SIZE; System.out.println(&amp;#34;double size: &amp;#34; &#43; (doubleSize / 8) &#43; &amp;#34;Byte&amp;#34;); int charSize = Character.SIZE; System.out.println(&amp;#34;char size: &amp;#34; &#43; (charSize / 8) &#43; &amp;#34;Byte&amp;#34;);  // 执行结果 int size: 4Byte short size: 2Byte long size: 8Byte byte size: 1Byte float size: 4Byte double size: 8Byte char size: 2Byte 有三个表示溢出或出错情况的特殊浮点数值：
 正无穷大 负无穷大 NAN（非数值）  Double.POSITIVE_INFINITY // 打印出来为Infinity Double.NEGATIVE_INFINITY // 打印出来为-Infinity Double.NaN // 打印出来为NaN  System.out.println(Double.POSITIVE_INFINITY); System.out.println(Double.NEGATIVE_INFINITY); System.out.println(Double.NaN);  // 执行结果 Infinity -Infinity NaN 不能使用x == Double.NaN来检测某个值是否等于NaN，因为所有NaN的值都认为是不相同的。所以，需要使用Double.isNaN(x)来判断某个值是否为NaN。
如果基本的整型和浮点型不能满足需求，可以使用java.math中的BigInteger和BigDecimal。BigInteger类实现任意精度的整数运算，BigDecimal实现任意精度的浮点数运算：
BigInteger big1 = BigInteger.valueOf(101); BigInteger big2 = new BigInteger(&amp;#34;11000078881111115678899000001234567890987&amp;#34;); System.out.println(&amp;#34;big result:&amp;#34; &#43; big1.add(big2)); 对于BigDecimal，应当使用带字符串入参的构造器。因为，如果使用带Double入参的构造器很容易造成舍入误差。例如，下面代码执行后，不会得到真正的0.1：
BigDecimal bigDecimal = new BigDecimal(0.1); System.out.println(&amp;#34;bigDecimal:&amp;#34; &#43; bigDecimal);  BigDecimal bigDecimal1 = new BigDecimal(&amp;#34;0.1&amp;#34;); System.out.println(&amp;#34;bigDecimal1:&amp;#34; &#43; bigDecimal1);   // 执行结果 bigDecimal:0.1000000000000000055511151231257827021181583404541015625 bigDecimal1:0.1 变量声明 Java是一种强类型语言，这意味着必须为每一个变量声明一个类型。声明一个变量时，需要先指定变量的类型，然后是变量名。声明一个局部变量后，必须用赋值语句对这个局部变量进行显式初始化，否则使用未初始化的局部变量会出现编译错误。下面定义的str局部变量未初始化就使用，会出现编译错误：
String str; System.out.println(str == null);  // 编译报错 java: variable str might not have been initialized 从Java 10开始，对于局部变量，如果能从变量的初始值推断出它的类型，可选地不再需要声明变量类型。此时，只需使用关键字var声明。但需要特别注意的是，var关键字**只能用于方法中的局部变量**。
var vacationDays = 12; System.out.println(vacationDays);  // 执行结果 12 关键字final表示这个变量只能被赋值一次，一旦变量被赋值后就不能够再被更改了，一般用来定义常量。习惯上，常量名使用全大写。在Java中可能经常需要创建一个常量，以便在一个类的多个方法中使用。通常将这些常量称为class constant，可以使用关键字static final设置一个类常量。
public static final double CM_PER_INCH = 2.54; 数据类型转换 因为数值有不同的类型，所以数值数据也有类型转换问题。数值型数据的类型转换分为自动类型转换和强制类型转换。
  凡是把占用位数少的数据转换为占用位数较多的数据，会触发自动类型转换。此时，类型转换由编译系统自动转换完成。
  把较长的数据转换较短的数据类型时，就要使用强制类型转换，否则会产生编译错误。
  自动类型转换 已经定义好的数值型变量，若是想以另一种数值类型来表示，在以下条件同时成立时，将自动触发数据类型的转换：
  转换前的数据类型与转换后的类型兼容。
  转换后的数据类型的表示范围比转换前的类型大。转换从短到长的优先关系为byte→short→char→int→long→float→double。
  如果在一个表达式中有整数类型为short或byte的数据参加运算，为了避免溢出，编译器会将其中的short或byte类型自动转换为int类型。
byte b = 12; short b1 = 34; int a = b &#43; 13; int a1 = b1 &#43; 45;  System.out.println(a); System.out.println(a1);  // 执行结果 25 79 强制类型转换 如果要将较长的数据转换为较短的数据类型时，就要进行强制类型转换（英文术语为cast）。强制类型转换格式为：(预转换的数据类型) 变量名。
double x = 9.9996; int nx = (int)x; System.out.println(nx);  // 执行结果 9 下面示例代码中，a/b是整数相除，结果还是整数，但赋值给g的时候，因为g为浮点型变量，所以a/b的结果会自动转换为浮点型。而在(float)a/b中，因为先将a强制转换为浮点型了，所以接着b会自动转换为浮点类型后再进行计算，最后(float)a/b的结果也为浮点型：
public class Convert {  public static void main(String[] args) {  int a = 155;  int b = 9;  float g,h;  g = a/b;  System.out.println(g); //17.0  h = (float) a/b;  System.out.println(h); //17.222221  } }  // 执行结果 17.0 17.222221 如果想舍入一个浮点数来得到最接近的整数，可以使用math.round方法：
double x = 9.997; // Math.round的结果为long，所以需要强制转换为int int nx = (int)Math.round(x); System.out.println(nx); //10  double x12 = -9.997; // Math.round的结果为long，所以需要强制转换为int int nx12 = (int) Math.round(x12); System.out.println(nx12); // -10 // 执行结果 10 -10 如果某个运算符得到一个值，但其类型与左侧操作数的声明的类型不同，也会发生强制类型转换。下面示例中，因为x是一个int类型变量，以下语句将会发生强制类型转换：
int x = 10; // 计算 x &#43; 3.5 时，x被转换为了double，然后赋值给x的时候被强制转换为int x &#43;= 3.5 =&amp;gt; (int)(x &#43; 3.5) 需要注意的是，赋值是一个表达式expression，即它有一个值 ，具体来说就是所赋的那个值。可以使用这个值完成一些操作，例如赋给另一个变量，下面示例代码中x &#43;= 4是一个赋值表达式，它的值赋给y:
int x = 1; int y = x &#43;= 4; 字符串数值转换 字符串可以转换为byte，short，int，long，float，double等类型。可以使用XXX.parseYYY()方法将字符串转换为其它类型，其中XXX代表Byte,Short,Integer,Long,Float,Double,Boolean等类型，XXX和YYY多数情况下相同。需要注意的是，若给定字符串转换失败会抛出异常：
int c = Integer.parseInt(&amp;#34;123&amp;#34;); short d = Short.parseShort(&amp;#34;34&amp;#34;); long e = Long.parseLong(&amp;#34;345&amp;#34;); System.out.println(c); System.out.println(d); System.out.println(e); boolean f = Boolean.parseBoolean(&amp;#34;true&amp;#34;); System.out.println(f);  // 执行结果 123 34 345 true 如果输入的字符串不能转换为相应的类型就会抛异常，例如int c = Integer.parseInt(&amp;quot;123i&amp;quot;);运行时会抛出NumberFormatException异常。
// 下面语句执行时会抛出异常 short d = Short.parseShort(&amp;#34;34.12&amp;#34;); // 代码执行发生异常 Exception in thread &amp;#34;main&amp;#34; java.lang.NumberFormatException: For input string: &amp;#34;34.12&amp;#34; 字符串可用&#43;拼接，若&#43;两边的某个操作数不是字符串，在连接之前会自动将其转换为字符串。因此，可用&#43;来实现数值到字符串的自动转换：
int myInt = 234; String myStr = &amp;#34;&amp;#34; &#43; myInt; System.out.println(myStr); String testStr = &amp;#34;test&amp;#34; &#43; 12.34; System.out.println(testStr); // test12.34  // 执行结果 234 test12.34 流程控制 语句 在Java中语句既可以是以分号;结尾的简单语句，也可以是用一对花括号{}括起来的复合语句。复合语句也被称为语句块，是由花括号括起来的若干简单语句组成。
复合语句中可以嵌套复合语句，但不允许在两个嵌套的复合语句内声明同名变量。下面代码编译时会出现Variable &#39;dd&#39; is already defined in the scope错误:
{  int dd = 34;  System.out.println(dd);  {  int dd = 45;  System.out.println(dd);  } }  // 同名变量编译错误 java: variable dd is already defined in method main(java.lang.String[]) 文档注释 最常用的注释方式是使用//，注释内容从//开始到当前行结尾。当需要更长的注释时，既可以在每行的注释前面标记//，也可以使用/*和*/界定符将其中内容注释。但/*和*/注释不能嵌套，即不能简单地把代码用/*和*/括起来作为注释，因为这段代码本身可能也包含一个*/界定符。
第三种注释可以用来自动地生成文档。注释以/**开头，以*/结尾，这种注释主要用于描述类、数据和方法。它可以使用JDK提供的javadoc命令产生的扩展名为.HTML的文件，从而为程序提供文档说明。
条件语句 if语句 在Java中，if()和else if()括号中的条件表达式的结果必须为布尔值，即true或者false，这种严格类型要求与C或者C&#43;&#43;的要求截然不同：
int a = 155; if (a &amp;gt; 122) {  System.out.println( &amp;#34;a &amp;gt; 122&amp;#34;); } else if (a &amp;gt; 100) {  System.out.println( &amp;#34;100 &amp;lt; a &amp;lt;= 122&amp;#34;); } else {  System.out.println( &amp;#34;a &amp;lt;= 100&amp;#34;); }  // 执行结果 a &amp;gt; 122 switch语句 在经典多分支switch选择语句执行时，首先会计算圆括号中表达式的值。并且要求表达式的类型与各个case后面常量表达式值的类型一致：
char op = &amp;#39;&#43;&amp;#39;; switch (op) {  case &amp;#39;&#43;&amp;#39;:  System.out.println(&amp;#39;&#43;&amp;#39;);  break;  case &amp;#39;-&amp;#39;:  System.out.println(&amp;#39;-&amp;#39;);  break;  default:  break; } 在经典switch语句中的每一个case，一般都应该有break语句，以指明这个分支执行完后就跳出switch语句。在某些特定场合下可能不需要break语句，如果若干case需要共享一个分支时，就可以将不同的判断语句流入相同的分支（被称为直通（fallthrough）行为）。
有返回值的switch语句称为switch表达式，分为带箭头和不带箭头两种情况（均自Java 14引入）。带箭头的switch表达式，没有fallthrough行为，不带箭头的有fallthrougt行为。若是箭头表达式，则各个分支中的箭头-&amp;gt;放在返回值前面。在switch表达式中可以为各个case提供多个标签，用逗号分隔：
int num = switch(sessionName) {  case &amp;#39;Spring&amp;#39;,&amp;#39;Summer&amp;#39;,&amp;#39;Winter&amp;#39; -&amp;gt; 6;  case &amp;#39;Fall&amp;#39; -&amp;gt; 4;  default -&amp;gt; -1; } 需要注意的是，在switch表达式中使用枚举常量时，不需要为各个标签提供枚举类型名，可从switch值中推导出来。若枚举常量的值均在case分支中，可以不使用default分支。但使用整数或String操作数的switch表达式必须有一个default分支。如果操作数是null，则会抛出一个空指针异常NullPointerException。
在switch表达式中case标签可以是：
 类型为char, byte,short,int的常量表达式 枚举常量 字符串字面量 多个字符串，使用逗号分隔  String input = &amp;#34;yes&amp;#34;; // 带箭头的switch没有fallthrough switch (input.toLowerCase()) {  case &amp;#34;yes&amp;#34;, &amp;#34;y&amp;#34; -&amp;gt; System.out.println(&amp;#34;yes&amp;#34;);  case &amp;#34;no&amp;#34;, &amp;#34;n&amp;#34; -&amp;gt; System.out.println(&amp;#34;no&amp;#34;);  default -&amp;gt; System.out.println(&amp;#34;other&amp;#34;); }  // 执行结果 yes 与所有表达式类似，switch表达式（包括有箭头和无箭头）也有一个值，也就是说每个分支都必须生成一个值。在箭头表达式中，最常见的做法是各个值跟在箭头-&amp;gt;后面，如case &amp;quot;Summer&amp;quot;, &amp;quot;Winte&amp;quot; -&amp;gt; 6。而在非箭头的表达式中，需要借助yeild关键字返回值：
// 带箭头的表达式 int num = switch(sessionName) {  case &amp;#39;Spring&amp;#39;,&amp;#39;Summer&amp;#39;,&amp;#39;Winter&amp;#39; -&amp;gt; 6;  case &amp;#39;Fall&amp;#39; -&amp;gt; 4;  default -&amp;gt; -1; }  // 不带箭头的表达式 var sessionName = &amp;#34;Spring&amp;#34;; int numLetters = switch (sessionName) {  case &amp;#34;Spring&amp;#34;:  // 直通行为  System.out.println(&amp;#34;Spring time!&amp;#34;);  case &amp;#34;Summer&amp;#34;, &amp;#34;Winter&amp;#34;:  yield 6;  case &amp;#34;Fall&amp;#34;:  yield 4;  default:  yield 1; }; 在有直通行为（fallthrough）的switch中，每个case以一个冒号结束。如果case以箭头-&amp;gt;结束，则表示没有直通(fallthrough)行为。需要注意的是，不能在一个switch中同时使用冒号和箭头。
在switch表达式中出现的yield关键字，会终止switch。但与break不同，yield还会生成一个值，也就是表达式的值。如果想在switch表达式的一个分支中使用语句而不想出现fallthrough行为，就必须使用大括号和yield。
var op = &amp;#34;123&amp;#34;; int num = switch (op) {  case &amp;#34;Spring&amp;#34; -&amp;gt; {  System.out.println(&amp;#34;Spring time&amp;#34;);  yield 6;  }  default -&amp;gt; -1; } // 上面有箭头，表示无直通行为 在非箭头switch表达式（有fallthrough行为）中也可以使用yield来终止fallthrough行为:
var sessionName = &amp;#34;Spring&amp;#34;; // 无箭头，有直通行为 int numLetters = switch (sessionName) {  case &amp;#34;Spring&amp;#34;:  System.out.println(&amp;#34;Spring time!&amp;#34;);  case &amp;#34;Summer&amp;#34;, &amp;#34;Winter&amp;#34;:  yield 6;  case &amp;#34;Fall&amp;#34;:  yield 4;  default:  yield 1; };  System.out.println(numLetters); // 执行结果 1 循环结构 Java中循环语句共有三种，分别为while语句，do-while语句和for语句。while语句先计算表达式的值，若表达式的值为真，则执行循环体中代码。而do-while则是先执行一次循环体代码，再判断条件表达式的值是否为true。
public static int fibonacci(int n) {  if(n == 0 || n == 1 ) {  return n;  }  int i = 0;  int j = 1;  int k = 2;  int result = 0;  while( k &amp;lt;= n) {  result = i &#43; j;  i = j;  j = result;  k&#43;&#43;;  }  return result; } 对于for循环，首先计算【表达式1】的值，以完成必要的初始化工作。再判断【条件表达式】的值，若值为false，则退出循环；若条件表达式的值为true，则执行循环体中的代码，执行完循环体后再返回【表达式2】进行计算，这样一轮循环就结束了。下一轮的循环从计算并判断【条件表达式】开始，若条件表达式的值仍为true，则继续循环，否则终止循环：
for(express 1; condition expression; express 2) {  // 循环体 } public static int sum(int n) {  int sum = 0;  for (int i = 1; i &amp;lt;= n; i&#43;&#43;) {  sum &#43;= i;  }  return sum; } for循环语句的三个表达式都可以为空。若条件表达式也为空，则表示当前循环是一个无限循环，需要在循环体中使用其它跳转语句来终止循环。
// 下面是死循环，需要其它语句来跳出循环体 for (; ; ) {  System.out.println(&amp;#34;test&amp;#34;);  ... } 数组 栈与堆内存 Java把内存分为栈内存和堆内存。在方法中定义的一些基本类型变量和对象的引用变量都在方法的栈内存中分配。堆内存用来存放由new运算符创建的对象和数组，在堆中分配的内存，由Java虚拟机垃圾回收器来管理。
在堆中创建一个对象或数组后，同时在栈中定义一个特殊变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中这个变量就成为数组或对象的引用变量。
引用变量实际上保存的是数组或对象在堆内存中的地址（也称为对象的句柄），以后就可以在程序中使用栈的引用变量来访问堆中的数组或对象。
一维数组 数组是一种数据结构，用来存储同一类型值的集合。通过整数索引可以访问数组中的每一个值。
一维数组的使用要经过三个步骤：①声明数组；②创建空间；③创建数组元素并赋值。前两个步骤的语法如下所示。在声明时可以不给出数组的长度：
数据类型[] 数组名; 数组名 = new 数据类型[个数]; int intArray[]; // 建议使用下面这种方式 int[] intArray;  byte[] byteArray; short[] shortsArray; boolean[] booleanArray; long[] longArray; float[] floatArray; double[] doubleArray; char[] charArray;  System.out.println(floatArray == null);  // 局部变量声明数组后，如果不初始化将会出现编译错误 java: variable floatArray might not have been initialized 数组用new分配内存空间的同时，每个元素都会自动赋一个默认值，整数为0，浮点为0.0，字符为&#39;\0&#39;，布尔型为false，引用类型为null。在声明数组时，也可以将两个步骤合并为一步：
数据类型 [] 数组名 = new 数据类型[个数] 一维数组定义时可以同时分配空间和赋值，称为数组的初始化。使用这种方式时，不需要给出数组元素个数，编译器会根据初始值数量自动确定数组长度：
数据类型 [] 数组名 = {初始值1,初始值2,...,初始值n} // 后面这一段为匿名数组 int[] intArr = new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; // 上面方式的简写 int[] intArr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; 无论使用哪种方式定义数组，都不能在声明的类型里指定长度（即在数组名前面的方括号内指定长度，不是new后面的方括号），否则会出现编译错误。
允许声明长度为0的数组，编写一个结果为数组的方法时，如果碰巧结果为空，此时一个长度为0的数组就很有用。可以按如下方式构造一个长度为0的数组，即空数组：
new elementType[0] new elementType[]{}  int[] arr2 = new int[0]; int[] arr3 = new int[]{}; // 不声明元素个数 System.out.println(Arrays.toString(arr2)); System.out.println(Arrays.toString(arr3));  // 执行结果 [] [] 创建一个数值型数组时，所有元素都会被初始化为0，boolean数组的元素会初始化为false。对象数组的元素都初始化为一个特殊值null，表示这些元素还未存放任何对象。下面代码创建一个包含10个字符串的数组，因为String是类类型，所以数组中所有元素都为null。
String[] names = new String[10]; System.out.println(Arrays.toString(names));  // 执行结果 [null, null, null, null, null, null, null, null, null, null] 有一种循环可以用来依次处理数组（或者任何其他元素集合）中的每个元素，而不必考虑指定的索引值。这种增强的for each循环格式如下所示，其中的collection表达式必须是一个数组或者是一个实现了Iterable接口的类对象。
for(type variable : collection) statement 对于一维数组，可以使用for each语句遍历数组：
public static void array() {  int[] a = new int[3];  a[1] = 45;  // 遍历数组中的每个元素  for (int item : a) {  System.out.println(item);  } }  // 执行结果 0 45 0 上面的for each循环等同于如下方式，但更加简洁：
for (int i = 0; i &amp;lt; a.length; i&#43;&#43;) {  System.out.println(a[i]); } 有一个更加简单的方式打印数组中的所有值，即利用Arrays的静态方法toString。调用该方法后会返回一个包含数组元素的字符串，这些元素在中括号内，元素之间使用逗号分隔。
int[] arrTest = {12, 34, 6, 90, 789, 90, 234, 5678, 0, 3, 1, 56, 23, 7891, 13}; System.out.println(Arrays.toString(arrTest));  // 执行结果 [12, 34, 6, 90, 789, 90, 234, 5678, 0, 3, 1, 56, 23, 7891, 13] 允许将一个数组变量拷贝到另一个数组变量，此时两个变量将引用（指向）同一个数组。
int[] newNames = smallNames; newNames[12] = 344; 如果希望将一个数组的所有值拷贝到一个新的数组中，就要使用Arrays类的静态copyOf方法：
int[] numbers = Array.copyOf(smallNames, 2 * smallNames.length) 需要注意的是，数组实际上也是类的实例，该类的直接父类是Object。每个数组都有一个相关的类，与其它所有具有相同类型的数组共享这个类：
int[] intArray = new int[3]; byte[] byteArray = new byte[3]; short[] shortsArray = new short[3]; // array of Strings String[] strArray = new String[3]; int[][] multiDimenArr = new int[8][9]; int[][][] newArr = new int[8][9][2];  System.out.println(intArray.getClass()); // 父类是Object System.out.println(intArray.getClass().getSuperclass()); System.out.println(byteArray.getClass()); System.out.println(shortsArray.getClass()); System.out.println(strArray.getClass()); System.out.println(newArr.getClass());  // 执行结果 class [I //运行时int数组的签名 class java.lang.Object class [B //运行时byte数组的签名 class [S //运行时short数组的签名 class [Ljava.lang.String; //运行时字符串类型数组的签名 class [[I //运行时int二维数组的签名 class [[[I // 运行时int三维数组的签名 数组类型有以下几个特点：
 公共的final字段length，表示数组元素个数。 除了Object的clone方法，继承了Object类的所有成员。 公共方法clone()，它覆盖了Object类中的clone方法，并且没有抛出检查过的异常。  int cloneArray[] = intArray.clone(); // will print false as deep copy is created // for one-dimensional array System.out.println(intArray == cloneArray); for (int i = 0; i &amp;lt; cloneArray.length; i&#43;&#43;) {  System.out.print(cloneArray[i] &#43; &amp;#34; &amp;#34;); }  // 执行结果 false 0 0 0 二维数组 在Java中没有真正的多维数组，多维数组只是数组的数组。二维数组声明方式与一维数组相似，内存的分配也使用new运算符，其声明与分配内存的格式如下：
数据类型 [][] 数组名; 数组名 = new 数据类型[行数][列数];  数据类型 [][] 数组名 = new 数据类型[行数][列数];  数据类型 [][] 数组名 = {{第1行的初值},{第2行的初值}, ..., {第m行的初值}} 使用clone方法可以复制数组，包括一维和多维数组：
int intArray[][] = {{1, 2, 3}, {4, 5}}; int cloneArray[][] = intArray.clone(); // will print false System.out.println(intArray == cloneArray); // will print true as shallow copy is created // i.e. sub-arrays are shared // 指向同一个地址 System.out.println(intArray[0] == cloneArray[0]); System.out.println(intArray[1] == cloneArray[1]);  // 执行结果 false true true 循环语句foreach不会自动循环处理二维数组的所有元素，若想要快速打印二维数组的元素可以调用deepToString方法，但需要注意的是它不能用于一维数组 ：
int[][] magicNums = {{1, 2, 3}, {3, 4, 5, 6}, {7, 8}}; System.out.println(Arrays.toString(magicNums)); System.out.println(Arrays.deepToString(magicNums));  // 执行结果 [[I@77ec78b9, [I@1a3869f4, [I@a38d7a3] [[1, 2, 3], [3, 4, 5, 6], [7, 8]] 数组拷贝 在Java中允许将一个数组变量拷贝到另一个数组变量，这时两个变量将指向同一个数组。如果希望将一个数组的所有值拷贝到一个新的数组中去，就要使用Arrays类的copyOf方法：
int[] arrTest = {12, 34, 6, 90, 789, 90, 234, 5678, 0, 3, 1, 56, 23, 7891, 13}; System.out.println(Arrays.toString(arrTest)); int[] luckyNum = arrTest; luckyNum[7] = 567; int[] copiedLuckyNum = Arrays.copyOf(luckyNum, luckyNum.length); 方法的第2个参数表示新数组长度，如果新数组长度小于原始数组的长度，则只拷贝旧数组前面的值。如果新数组长度大于原始数组的长度，那么额外的元素根据数组中元素类型填充默认值。
数组排序 如果想对数值型数组进行排序，可以使用Arrays中的静态sort方法，这个sort方法使用了优化的快速排序：
int[] arrTest = {12, 34, 6, 90, 789, 90, 234, 5678, 0, 3, 1, 56, 23, 7891, 13}; System.out.println(Arrays.toString(arrTest)); Arrays.sort(arrTest); System.out.println(Arrays.toString(arrTest));  // 执行结果 [12, 34, 6, 90, 789, 90, 234, 5678, 0, 3, 1, 56, 23, 7891, 13] [0, 1, 3, 6, 12, 13, 23, 34, 56, 90, 90, 234, 789, 5678, 7891] 字符串 Java没有内置的字符串类型，而是标准库中提供了一个预定义的String类型。每个用双引号括起来的字符串都是String类的一个实例。也就是说，无论字符串常量还是字符串变量，都是使用类来实现的。程序中用到的字符串可以分为两类，一类是创建后不会修改字符串内容，另一类是创建后允许修改字符串内容。
下面代码中，第一条语句只是声明了字符串引用变量str，此时str的值为null。第二条语句则在堆内存中分配了内存，并将变量名指向了字符串的首地址：
String str; str = new String(&amp;#34;字符串&amp;#34;); public class Convert {  public String strNull; } Convert convert = new Convert();  // 类里面的属性与局部变量不一样，未初始化不会出现编译错误 System.out.println(convert.strNull == null); //true 也可以按如下使用字符串字面量创建字符串变量，这个变量对应的字符串对象被创建在字符串常量池中：
String 变量名 = &amp;#34;字符串&amp;#34; 字符串也可以用new操作符来声明，即动态分配。如果字符串是动态分配的，它们会在堆中被分配一个新的内存位置，这个字符串对象不会被添加到字符串常量池中：
String 变量名 = new String(&amp;#34;字符串&amp;#34;); 如果想将上述方式生成的字符串放到常量池中，可以调用intern方法：
String str = new String(&amp;#34;Geeks&amp;#34;); String str1 = &amp;#34;Geeks&amp;#34;; System.out.println(str == str1); //false System.out.println(str.equals(str1)); // true String str2 = str.intern(); System.out.println(str == str2); // false System.out.println(str.equals(str1)); // true System.out.println(str1 == str2); // true System.out.println(str1.equals(str2)); // true String testStr = &amp;#34;test&amp;#34;; System.out.println(&amp;#34;test&amp;#34; == testStr); // true System.out.println(&amp;#34;test&amp;#34; == testStr.intern()); // true  // 执行结果 false true false true true true true true 利用String类创建的字符串变量，一旦被初始化或赋值，它的值和分配的内容原则上不可再被改变。这是因为String是使用char数组来存储字符串的，不可变是因为这个char数组是private的，String没有对外提供方法来修改这个数组，因而无法改变这个char数组的值，所以说String是不可变的：
@Stable private final byte[] value; 如果改变字符串变量的值，将会产生一个新的字符串：
public static void testString() {  String str1 = &amp;#34;test&amp;#34;;  str1 = &amp;#34;Good&amp;#34;;  System.out.println(str1); } 上面的例子看起来是一个简单的字符串赋值，实际上重新申请了一个新的内存空间。首先产生一个字符串对象test，在内存中分配了一段空间，str1指向这个对象。由于str1被重新赋值，原来的空间中已经不可能再追加新的内容，系统不得不将这个对象放弃，再重新生产新的对象Good，即str1指向的内存地址已经不是同一个，对象也不是同一个。
空字符串是长度为0的字符串，也是一个对象，它有自己的长度和内容（长度为0，内容为空）。String变量还可以存放一个特殊值，名称为null，表示没有任何对象和该变量关联。空字符&amp;quot;&amp;quot;的长度为0，可以调用length()或isEmpty()检查一个字符串是否为空：
if(str.length() == 0) {  System.out.println(&amp;#34;str length is 0&amp;#34;); } 有时要检查一个字符串既不是null，也不是空串：
// null判断要放在前面，否则str为null时调用实例方法length时会出现编译错误 if(str != null &amp;amp;&amp;amp; str.length() != 0) {  System.out.println(&amp;#34;str length is 0&amp;#34;); } equals和== 在Java中，equals方法用于比较两个对象是否相等。它是Object类的一个方法，通常用于引用数据类型的比较。默认情况下，equals方法比较的是两个对象的地址值，即两个引用是否指向同一个对象。但是，许多类如String、Date、File以及包装类等都重写了Object类中的equals方法，使得它们比较的不再是地址值，而是对象的实际内容。
equals方法与==运算符的区别 运算符*==*可以用于基本数据类型和引用数据类型的比较。当用于基本数据类型时，比较的是两个变量保存的数据是否相等。而当用于引用数据类型时，它比较的是两个对象的地址值是否相同。下面示例中，因为String是类，即引用类型，所以比较的是对象的地址：
String str1 = new String(&amp;#34;123&amp;#34;); String str2 = new String(&amp;#34;123&amp;#34;);  System.out.println(str1 == str2); // 输出false，因为str1和str2指向不同的对象实例 作为对比，equals方法默认情况下也是比较对象的地址值，但是很多类通过重写equals方法改变了这一默认行为。例如，String类重写了equals方法，使得它比较的是两个字符串的内容是否相等：
String str1 = new String(&amp;#34;runoob&amp;#34;); String str2 = new String(&amp;#34;runoob&amp;#34;);  boolean retVal; retVal = str1.equals(str2);  System.out.println(&amp;#34;返回值 = &amp;#34; &#43; retVal); // 输出true，因为str1和str2的内容相同 自定义类中的equals方法 在自定义类中使用equals方法时，通常是为了比较两个对象的实体内容是否相同。这就需要我们重写Object类中的equals方法。例如，在一个订单类Order中，我们可能会像下面这样重写equals：
@Override public boolean equals(Object obj) {  // 先判断是否指向同一对象 	if (this == obj) { 	return true;  }  // 再判断是否是相同类型  if (obj instanceof Order) { 	Order order = (Order)obj; 	// 请注意：对于基本数据类型使用==，对于引用数据类型使用equals 	return this.orderId == order.orderId &amp;amp;&amp;amp; this.orderName.equals(order.orderName); 	} 	return false; } 在这个例子中，equals方法首先检查两个对象的地址值是否相同，如果相同则直接返回true。如果不同，它会检查obj是否是Order类的实例，若是则比较属性orderId和orderName是否相等，否则返回false。
需要注意的是：
 *==*既可以比较基本类型也可以比较引用类型。对于基本类型，比较的是值，而对于引用类型，比较的是内存地址。 equals方法属于java.lang.Object类，如果没有被重写，默认行为与*==相同。但是，像String类这样的类已经重写了equals方法，它的equals*方法比较的是对象的内容。 通常情况下，重写equals方法会比较类中的相应属性是否都相等。  字符串池 Java程序在执行时会维护一个字符串池(string pool)，对于一些可共享的字符串对象，会先在字符串池中查找是否有相同的字符串内容，如果有就直接返回，而不是重新创建一个新的String对象，以减少内存占用。当在程序中直接使用双引号括起来的字符串时，该字符串就会在字符串池中。
String str = &amp;#34;Geeks&amp;#34;; 字符串判等 对于字符串说，运算符==用于比较两个变量本身的值，即两个对象在内存中的首地址。而equal()方法则是比较两个字符串包含的内容是否相同：
public static void equalString() {  String s1, s2, s3 = &amp;#34;abc&amp;#34;, s4 = &amp;#34;abc&amp;#34;;  s1 = new String(&amp;#34;abc&amp;#34;);  s2 = new String(&amp;#34;abc&amp;#34;);  System.out.println(s1 == s2); //false  System.out.println(s1.equals(s2)); //true  System.out.println(s1 == s3); //false  System.out.println(s1.equals(s3)); //true  System.out.println(s3 == s4); //true，因为都在字符串池里  System.out.println(s3.equals(s4)); //true }  // 打印结果 false true false true true true 而对于非字符串类型的类类型变量来说，默认情况下==运算符和equal()方法都是用来比较其所指向对象在堆内存中的首地址，即是否指向同一个对象:
Test a = new Test(); Test b = new Test(); System.out.println(a == b); //false System.out.println(a.equals(b)); //false StringBuffer StringBuffer是String的一个对等类，提供了字符串的大部分功能。String表示固定长度、不可改变的字符序列，而StringBuffer表示可增长和可写入的字符序列。
需要注意的是，StringBuffer是线程安全的，它所有公共方法都是使用synchronized修饰的，这意味着它是同步的，可以在多线程环境中安全使用。因此，当应用程序需要线程安全时，应当使用StringBuffer。
StringBuffer buffer = new StringBuffer(&amp;#34;test&amp;#34;); buffer.append(&amp;#34;test11&amp;#34;); System.out.println(buffer); // 若超出字符串长度，则会抛异常StringIndexOutOfBoundsException buffer.deleteCharAt(2); System.out.println(buffer);  // 执行结果 testtest11 tettest11 StringBuilder StringBuilder自Java 5引入，与StringBuffer的主要区别在于它的方法不是线程安全的。由于没有同步，StringBuilder在单线程环境下的性能比StringBuffer更优，因此在不需要考虑线程安全的情况下，推荐使用StringBuilder。
StringBuilder str3 = new StringBuilder(); str3.append(&amp;#34;GFG&amp;#34;); str3.deleteCharAt(1); str3.append(&amp;#34;GHIJ&amp;#34;);  // 执行结果 GGGHIJ StringTokenizer StringTokenizer根据自定义分界符进行拆分，并将结果进行封装提供对应方法进行遍历取值，其用途类似于split方法，只是对结果进行了封装。
StringTokenizer str4 = new StringTokenizer(&amp;#34;abc cdb&amp;#34;, &amp;#34; &amp;#34;, false); System.out.println(str4.countTokens()); while (str4.hasMoreTokens()) {  System.out.println(str4.nextToken()); }  // 执行结果 abc cdb StringJoiner StringJoiner是java.util包中的一个类，用于构造一个由分隔符分隔的字符串，并且可选择以特定前缀开始，以特定后缀结束。尽管这样的字符序列可以使用StringBuilder类实现，但StringJoiner提供了一种更简单的方法，无需编写太多代码就可以做到：
StringJoiner joiner = new StringJoiner(&amp;#34;,&amp;#34;); joiner.add(&amp;#34;This&amp;#34;); joiner.add(&amp;#34;is&amp;#34;); joiner.add(&amp;#34;a&amp;#34;); joiner.add(&amp;#34;test&amp;#34;); System.out.println(joiner);  StringJoiner joiner1 = new StringJoiner(&amp;#34;,&amp;#34;,&amp;#34;prefix&amp;#34;,&amp;#34;suffix&amp;#34;); joiner1.add(&amp;#34;This&amp;#34;); joiner1.add(&amp;#34;is&amp;#34;); joiner1.add(&amp;#34;a&amp;#34;); joiner1.add(&amp;#34;test&amp;#34;); System.out.println(joiner1;  // 打印结果 This,is,a,test prefixThis,is,a,testsuffix 类与对象 类是对某一类事物的描述，是抽象的，概念上的定义，可以理解为一个模具。而对象则是实际存在的属于该类的某个具体个体，因而也被称为实例instance。
在Java中，任何对象变量的值都是一个引用，指向存储在另一个地方的对象，new操作符返回的也是一个引用。可以显式地将对象变量设置为null，表示这个对象变量目前没有引用任何对象。
Date startTime = new Date(); System.out.println(startTime);  // 对象类型变量可以被置为null startTime = null; System.out.println(startTime); 修饰符 类修饰符 一个类的方法可以访问这个类的所有对象的私有数据。一个类可以有多个修饰符，且无先后顺序之分，但abstract和final是对立的，所以不能同时将它们应用在同一个类的定义中，各个修饰符含义如下：
   修饰符 含义     public 将一个类声明为公共类，它可以被任何对象访问   abstract 将一个类声明为抽象类，不能创建该类的实例   final 将不能被其它类继承   缺省 只有在同一个包中才能使用    成员变量修饰符 成员变量的修饰符有访问控制修饰符，static修饰符，final修饰符，过渡修饰符和易失修饰符。一个成员变量可以被两个以上的修饰符同时修饰，但有些修饰符不能同时存在，各个修饰符的含义如下：
   修饰符 含义     public 公共访问控制符，指定该变量为公共的，它可以被任何对象的方法访问。   private 私有访问控制符，指定该变量只允许自己类中方法访问，其它任何类（包括子类）中的方法均不能访问。   protected 保护访问控制符，指定只可以被它自己的类以及子类在同一包中的其它类访问，在子类中可以覆盖此变量。   缺省 表示在同一个包中的其它类可以访问此成员变量，而其它包中的类不能访问该成员变量。   final 指定该变量的值不能改变。   static 指定该变量被所有对象共享，即所有的实例都可使用该变量。   transient 指定该变量是一个系统保留，暂无特别作用的临时变量。   volatile 指定该变量可以同时被几个线程控制和修改。    可以将实例字段定义为final，这样的字段必须在构造对象时初始化。也就是说，必须确保每个构造器执行之后，这个字段已经设置，并且以后不会再修改这个字段。
如果类中所有方法都不会改变其对象，这样的类被称为不可变类。对于对象类型，final关键字只表示存储在变量中的对象引用不会再指向另一个不同的对象，但其所指向的对象本身是可以被修改的。
如果将一个字段设置为static，那么这个字段并不出现在每个类的对象实例中，每个静态字段只有一个副本。可以认为静态字段属于类，而不是单个对象。静态变量使用的少，但静态常量使用比较多，例如Math.PI,System.out等。
可以使用对象实例来调用静态方法，这是合法的，但不建议这样做，建议使用类名来调用静态方法。main方法也是一个静态方法，它不对任何对象进行操作。事实上，启动程序时还没有任何对象，将执行静态main方法，并构造所需的对象。每个类都可以有一个main方法。
成员方法修饰符 Java的方法总是按值调用，即方法中形参得到的是所有实参的一个副本。具体来说，方法不能修改传递给它的任何参数变量的内容。需要强调的是，对象引用也是按值传递的。下面示例中，因为String是不可变对象类型，所以swap方法没有任何作用。实际上，交换的是两个副本的值：
String a = &amp;#34;aaa&amp;#34;; String b = &amp;#34;bbb&amp;#34;; employee1.swap(a, b); System.out.println(&amp;#34;aOut:&amp;#34; &#43; a &#43; &amp;#34; bOut:&amp;#34; &#43; b);  public void swap(String a, String b) {  String tmp = a;  a = b;  b = tmp;  System.out.println(&amp;#34;aIn:&amp;#34; &#43; a &#43; &amp;#34; bIn:&amp;#34; &#43; b); }  // 执行结果 aIn:bbb bIn:aaa aOut:aaa bOut:bbb  class Test1 {  String name;   public Test1() {  System.out.println(&amp;#34;Test1 constructor&amp;#34;);  }   public Test1(String name) {  this.name = name;  } }  public static void swap(Test1 a, Test1 b) {  var tmp = a.name;  a.name = b.name;  b.name = tmp; }  Test1 test1 = new Test1(&amp;#34;H1&amp;#34;); Test1 test2 = new Test1(&amp;#34;H2&amp;#34;); // swap中传递的是值 swap(test1, test2); System.out.println(test1.name &#43; &amp;#34; &amp;#34; &#43; test2.name); // 执行结果 H2 H1 在方法中定义修饰符是可选项。方法的修饰符较多，包括访问控制符、静态修饰符、抽象修饰符、最终修饰符、同步修饰符和本地修饰符，具体含义如下所示：
   修饰符 含义     public 公共访问控制符，指定该方法为公共的，它可以被任何对象的方法访问。   private 私有访问控制符，指定该方法只允许自己类中方法访问，其他任何类（包括子类）中的方法均不能访问。   protected 保护访问控制符，指定该方法只可以被它自己的类以及子类在同一包中的其它类访问。   缺省 表示在同一个包中的其它类可以访问此成员方法，而其它包中的类不能访问该成员方法。   final 指定该方法不能被重载。   static 指定不需要实例化一个对象就可以激活的方法。   synchronized 在多线程程序中，该修饰符用于在运行前，对它所属的方法加锁，以防止其它线程访问，运行结束后解锁。   native 指定此方法的方法体是其他语言在程序外部编写的。    成员变量和局部变量  成员变量是对象的一部分，它随着对象的创建而存在。而局部变量随着方法调用而产生，随着方法调用的结束而自动消失。 成员变量是对象的一部分，而对象是存在于堆内存中，所以成员变量也是在堆内存中，而局部变量是存在于栈内存中的。 成员变量如果没有被赋初值，则自动以类型的默认值初始化。局部变量不会自动赋值，必须显式地赋值后才能使用。被final修饰但没有被static修饰的成员变量必须显式地赋值。  {  String str;  // 局部变量不会自动初始化，若使用前没初始化，将会编译报错  System.out.println(str == null); }  // 编译报错 java: variable str might not have been initialized 下面是成员变量初始化的例子：
class Test {  // 成员变量若未被赋初值，会自动初始化  private String str;  // 静态成员变量若未初始化，也会自动初始化  public static String newStr;   public Test() {  // str默认的初始化值为null，即会自动被初始化为null  // 使用前已经被初始化了，使用不会出现编译错误  System.out.println(str == null);  } } 当且仅当自定义类没有构造器，编译器会自动生成一个无参构造器，这个默认的无参构造器会将所有的实例字段设置为相应的默认值。只要自定义了类的构造器，就不会自动生成无参构造器。
对象的使用 创建新的对象之后，就可以对其成员进行访问。在对象实例名和成员之间用.相连，通过这种方式来引用成员，如下所示：
对象名.对象成员 class Employee {  private String name;  private Double salary;  private LocalDate hireDay;   public void raiseSalary(double percent) {  this.salary &#43;= (this.salary * percent / 100);  } }  Employee object = new Employee(); object.raiseSalary(23); 参数传值 Java语言在给被调用方法的参数赋值时，只采取传值的方式。所以，基本类型数据传递的是数据值本身。而引用类型数据传递的也是这个变量的本身，即对象的引用变量，而非对象本身。
通过方法调用，可以改变对象的内容，但对象的引用变量是不能改变的。简言之，就是当参数是基本数据类型时，是传值方式调用；而当参数是引用变量时，则是传地址方式调用。
隐式与显式参数 对象的方法用于操作对象以及存取它们的实例字段。下面raiseSalary方法有两个参数，第一个参数为隐式参数，是出现在方法名前的Employee类型的对象实例。第二个参数是位于方法名后面括号中的数值，这是一个显式参数：
class Employee {  private String name;  private Double salary;  private LocalDate hireDay;   public void raiseSalary(double percent) {  salary &#43;= (salary * percent / 100);  } } 也就是说显式参数列在方法声明中，隐式参数并没有出现在方法声明中。在每个方法中，关键字this指示隐式参数，如果喜欢的话，可以将raiseSalary改写成如下方式：
class Employee {  private String name;  private Double salary;  private LocalDate hireDay;   public void raiseSalary(double percent) {  this.salary &#43;= (this.salary * percent / 100);  } } 方法重载 重载是指相同的方法名称，如果参数个数不同，或者参数类型不同，则方法就具有不同的功能。方法重载中参数的类型是关键，仅仅是形参名不同是不行的。也就是说，参数的列表必须不同，即或者参数个数不同，或者参数类型不同，或者参数的顺序不同。
构造方法 构造方法是一种特殊方法，用于在对象被创建时初始化对象成员的方法，构造方法的名称必须与它类名完全相同。虽然构造方法没有显式返回值，但在定义构造方法时，构造方法名前不能用void来修饰，因为一个类的构造方法的返回值类型就是该类本身。
构造方法定义后，创建对象时会被自动调用，因此构造方法不需要在程序中直接调用，而是在对象产生时自动执行。若在构造方法前添加void，就变成了普通方法，不会再自动调用了。构造方法的特殊性在于：
  构造方法的方法名与类名相同。
  构造方法没有返回值，但不能写成void。
  构造方法的主要作用是完成类对象的初始化工作。
  构造方法一般不能显式调用，而是由new操作符来调用。
  默认构造方法 如果在定义类时，没有定义任何构造器，编译器会自动生成一个默认构造函数，它没有参数，函数体中也没任何代码。如果定义类的class关键字前有public修饰，则编译器生成的默认构造方法也是public的。
构造函数调用 构造函数可以重载，一个构造函数可以调用另一个构造函数，但必须使用this关键字，而且this关键字必须是构造方法内的第一行。这种方式使用this关键字非常有用，只需要写一次公共构造代码。
class Test {  private String str;   public Test() {  System.out.println(&amp;#34;test&amp;#34;);  System.out.println(str == null);  }   public Test(String str) {  // this调用构造器必须放在第一行  this();  this.str = str;  } } 对象初始化器 类中实例字段的初始化既可以在构造器中，也可以在声明中直接赋值，还可以在初始化块中。在一个类的声明中，可以包含任意多个初始化代码块，只要构造这个类的实例，这些代码块就会执行。
class Employee {  private String name;  private Double salary;  private LocalDate hireDay;   public void raiseSalary(double percent) {  this.salary &#43;= (this.salary * percent / 100);  }   {  name = &amp;#34;name&amp;#34;;  salary = 2.3;  hireDay = LocalDate.now();  }  }  // 构造对象实例时会调用对象初始化器 Employee object = new Employee(); 需要注意的是，在实例化类的对象实例时，会首先运行初始化块，然后才会运行构造器中的代码。通常建议将初始化块放在字段定义之后，以免出现循环定义。若同一个类中存在多个实例初始化块，则按在声明中出现的顺序执行。
class Employee1 {  private String name;  private Double salary;  private LocalDate hireDay;   public void raiseSalary(double percent) {  this.salary &#43;= (this.salary * percent / 100);  }   {  name = &amp;#34;name&amp;#34;;  salary = 2.3;  hireDay = LocalDate.now();  System.out.println(&amp;#34;2&amp;#34;);  }   {  name = &amp;#34;test&amp;#34;;  salary = 4.5;  hireDay = LocalDate.now();  System.out.println(-1);  }   public Employee1() {  this.name = &amp;#34;unknow&amp;#34;;  this.salary = 9.9;  this.hireDay = LocalDate.now();  System.out.println(&amp;#34;1&amp;#34;);  }   public Employee1(String name) {  this();  this.name = name;  this.salary = 109.9;  this.hireDay = LocalDate.now();  System.out.println(&amp;#34;3&amp;#34;);  } }  Employee1 employee1 = new Employee1(&amp;#34;this&amp;#34;);  // 执行结果 2 -1 1 3 静态初始化器 静态初始化器是由关键字static修饰的一对花括号{}括起来的语句块。它的作用与类的构造方法有些相似，都是用来初始化工作的，但与构造方法有些不同：
  构造方法是对新创建的对象实例进行初始化，而静态初始化器是对类自身进行初始化。
  静态初始化器一般不能由程序调用，是所属类被加载进内存时由系统调用执行，也就是该类或类的实例使用时才会自动调用。
  静态初始化器只执行一次，没有方法名，没有返回值和参数。
  class Test {  private String str;   public Test() {  System.out.println(&amp;#34;test&amp;#34;);  }   public Test(String str) {  this();  this.str = str;  }   static {  System.out.println(&amp;#34;this is a test num&amp;#34;);  }   static {  System.out.println(&amp;#34;second&amp;#34;);  } }  // 打印的结果 this is a test num second 在上面这个例子中，第一次使用Test类时，静态初始化器才会执行，并不是在程序启动时就会执行。如果有多个静态初始化器，则它们在类的初始化时会按照在类声明中出现的顺序依次执行。
如果在构造器中没有显式为类中字段设置初值，那么就会被自动地赋初始值。数值为0，布尔值为false，对象引用为null。这与局部变量的初始化有重大区别。
继承 Java中继承是通过extends关键字来实现的，不支持多继承，一个类只能有一个直接父类。所有类都直接或间接继承自java.lang.Object，即若定义类时没有使用extends关键字则表示该类继承自java.lang.Object。
有一个简单的规则可以用来判断是否应该将数据设计为继承关系，即is-a规则，它指出子类的每个对象也是父类的对象。is-a规则的另一种表述是替换原则，即程序中出现父类对象的任何地方都可以使用子类对象替换。
在Java中，对象变量是多态的。例如，一个Employee类型的变量既可以引用一个Employee类型的对象，也可以引用Employee任何一个子类的对象实例。
构造方法执行 class Person {  private String name;  private int age;  String gender;   public Person() {  System.out.println(&amp;#34;person init&amp;#34;);  } }  class Student extends Person {  private String department;   public Student() {  System.out.println(&amp;#34;Student init&amp;#34;);  } }  Student stu = new Student(); System.out.println(stu.gender == null); // true  // 执行结果 Person init Student init true 上面例子中，若执行Student student = new Student();，会先自动调用父类的构造方法，帮助继承父类的成员初始化做准备，随后才会执行子类的构造方法。
在执行子类的构造方法前，若没有显式使用super来调用父类的构造函数，则默认会调用父类中无参数构造方法。如果父类只定义了有参构造方法，而子类的构造方法中又未使用super来调用父类的构造函数，则会出现编译错误：
class NewTest {  private int x;   NewTest(int x) {  this.x = x;  } }  class NewTest1 extends NewTest {  NewTest1() {  // 父类中没有无参构造方法，子类又未显式调用有参构造方法，则会出现编译错误  System.out.println(&amp;#34;NewTest1&amp;#34;);  } }  // NewTest只定义了有参构造函数，而NewTest1没有调用父类的构造函数，所以会出现编译错误 java: constructor NewTest in class NewTest cannot be applied to given types;  required: int  found: no arguments  reason: actual and formal argument lists differ in length this和super 关键字this有两种含义，一是隐式参数的引用；二是调用该类的其它构造器。相似的，super关键字也有两种含义，一是调用父类的方法，二是调用父类的构造器。如果使用this或super调用构造器，都只能作为另一个构造器的第一条语句出现。需要注意的是，不能在构造器中同时使用super和this调用另一个构造器。
需要注意的是，super和this有些区别，super并不是一个对象的引用，因为不能将值super赋给另一个对象变量。事实上，super只是一个指示编译器调用父类方法的特殊关键字。
方法覆盖 方法覆盖是指在子类中定义方法名称、参数个数、参数类型均与父类完全相同的方法，用于重写父类里同名方法的功能。需要特别注意的是，子类不能覆盖父类中声明为final或static的方法。
在子类中覆盖父类方法时，可以扩大父类方法的访问权限，绝不可以缩小父类方法的访问权限。下面例子中，show方法在子类的访问权限可以改为public，但不能改为private:
class Person {  private String name;  private int age;   public Person() {  System.out.println(&amp;#34;Person init&amp;#34;);  }   protected void show() {  System.out.println(&amp;#34;Person show&amp;#34;);  } }  class Student extends Person {  private String department;   public Student() {  System.out.println(&amp;#34;Student init&amp;#34;);  }   protected void show() {  System.out.println(&amp;#34;Student show&amp;#34;);  } } 所有被private修饰符限定的方法以及所有包含在final类中的方法，都默认是final的。这些方法既不可能被子类继承，也不可能被子类覆盖。
一个成员变量若被static final两个修饰符所限定时，它实际的含义就是常量。定义一个成员变量，若只用final修饰，而不用static修饰时，则必须且只能赋值一次。
一个对象变量可以指向多种实际类型，被称为多态。在运行时能够自动地选择适当的方法，被称为动态绑定。在Java中，对象变量是多态的，也就是说一个Employee类型的变量既可以引用一个Employee类型的对象，也可以引用Employee类的任何一个子类对象。
在Java中，子类引用数组可以转换为父类引用数组，而不需要使用强制类型转换。
阻止继承 有时，可能希望阻止定义某个类的子类， 不允许继承的类被称为final类。如果想阻止某个类定义子类，可以定义为final类。类中的某个特定方法也可以被声明为final，子类就不能覆盖这个方法。final类中的所有方法自动地成为final方法。
字段也可以声明为final，对于final字段来说，构造对象实例后就不允许改变它们的值了。如果将一个类声明为final，只有其中的方法自动地成为final，而不包括字段。
对象类型的强制类型转换需要满足：
 只能在继承层次结构内进行强制类型转换。 在将父类强制转换为子类之前，应该使用instanceof进行检查。  Object类 在Java中，只有基本类型不是对象，例如数值，布尔以及字符的值不是对象。每个类都扩展了Object，即可以使用Object类型的变量引用任何任何类类型的对象。所有数组类型，不管是基本类型的数组还是对象数组都是扩展了Object类的类型。
在Java中所有类都直接或者间接继承自java.lang.Object，它定义了public final Class getClass()方法。这个方法返回运行时对象所属的类，返回的class对象是被所属类的静态同步方法锁定的对象:
Test a = new Test(); Class obj = a.getClass(); System.out.println(obj); //class test System.out.println(obj.getName()); //Test  // 执行结果 class Test Test 在上面示例中，首先通过始祖类Object的实例方法getClass()获取类的实例，然后通过Class类的实例方法getName()获取到了类Test的名称。
可以使用Object类型的变量引用任何类型的对象，但它只能作为一个泛型容器。如果想要对其中的内容进行具体的操作，还需先进行强制类型转换：
Object object = new Employee(); ((Employee) object).raiseSalary(23); 在Java中，只有基本类型(primitive type)不是对象。例如，数值，字符和布尔类型的值都不是对象。所有的数组类型，不管是类类型的数组还是基本类型数组都扩展了Object类。
Object object = new Employee(); Employee[] staff = new Employee[10]; object = staff; object = new int[10]; 可以通过对象运算符instanceof来测试一个对象是否是指定类或其子类的实例，若是则返回true，否则返回false：
Student stu = new Student(); System.out.println(stu instanceof Object);  // 打印的结果 true 下面定义的类中，Parent是Object的子类，Child是Parent的子类：
// Java program to demonstrate working of instanceof Keyword  // Class 1 // Parent class class Parent { 	// }  // Class 2 // Child class class Child extends Parent { }  // Class 3 // Main class class GFG {   // Main driver method  public static void main(String[] args) {   // Creating object of child class  Child obj = new Child();   // A simple case  if (obj instanceof Child)  System.out.println(&amp;#34;obj is instance of Child&amp;#34;);  else  System.out.println(&amp;#34;obj is NOT instance of Child&amp;#34;);   // instanceof returning true for Parent class also  if (obj instanceof Parent)  System.out.println(&amp;#34;obj is instance of Parent&amp;#34;);  else  System.out.println(&amp;#34;obj is NOT instance of Parent&amp;#34;);   // instanceof returns true for all ancestors   // Note : Object is ancestor of all classes in Java  if (obj instanceof Object)  System.out.println(&amp;#34;obj is instance of Object&amp;#34;);  else  System.out.println(&amp;#34;obj is NOT instance of Object&amp;#34;);  } }  // 执行结果 obj is instance of Child obj is instance of Parent obj is instance of Object 需要注意的是，如果在使用instanceof时，对象的值为null，则返回false。下面代码中，obj虽然定义为Test1类型的变量，但其初始值为null，所以使用instanceof运算符后的结果为false：
class Test1 {  // }  class Main {  public static void main(String[] args) {  Test1 obj = null;   // obj虽然声明为Test1类型，但初始化值为null  if (obj instanceof Test1)  System.out.println(&amp;#34;obj is instance of Test&amp;#34;);  else  System.out.println(&amp;#34;obj is NOT instance of Test&amp;#34;);  } }  // 执行结果 tobj is NOT instance of Test 子类引用的数组可以转换为父类引用的数组，而不需要使用强制类型转换：
Student[] students = new Student[10]; Person[] persons = students; Object类中的equals方法用于检测一个对象是否等于另外一个对象。Object类中实现的equals方法是比较两个对象引用地址是否相等，这是一个合理的默认行为，如果两个对象引用相等，这两个对象肯定就相等。
hashCode 散列码hashCode是由对象导出的一个整型值。若x和y是两个不同的对象，则x.hasCode与y.hashCode基本上不同。下面代码中，字符串s与t有相同的散列值，这是因为字符串的散列值是由内容导出的。而sb和tb的散列值不同，是因为StringBuilder类中没有自定义hashCode方法，而Object类的默认hashCode方法是从对象的存储地址得出散列值：
var s = &amp;#34;OK&amp;#34;; var sb = new StringBuilder(s); System.out.println(s.hashCode() &#43; &amp;#34; &amp;#34; &#43; sb.hashCode()); var t = new String(&amp;#34;OK&amp;#34;); var tb = new StringBuilder(t); System.out.println(t.hashCode() &#43; &amp;#34; &amp;#34; &#43; tb.hashCode());  // 打印结果 2524 990368553 2524 1452126962 如果在类中重新定义了equals方法，还必须为用户可能插入散列表的对象重新定义hashCode方法。
方法hashCode应该返回一个整数（可以是负数），并且要合理地组合类实例字段的散列值，以便让不同对象产生的散列值分布更加均匀。最好使用null安全的方法Objects.hashCode，即如果参数为null，这个方法应当返回0。否则返回对参数调用hashCode的结果，另外使用静态方法Double.hashCode来避免创建Double对象：
public int hashCode() {  return 7 * Objects.hashCode(name) &#43; 11 * Double.hashCode(salary) &#43; 13 * Objects.hashCode(hireDay); } 还有一个更好的做法，需要组合多个参数的散列值时，可以调用Objects.hash并提供这些参数。这个方法会对各个参数调用Objects.hashCode，并组合这些参数的散列值：
public int hashCode() {  return Objects.hash(name, salary, hireDay); } 需要特别注意的是，equals和hashCode的定义必须相容，如果x.equals(y)返回true，那么x.hashCode()就必须与y.hasCode()的值相同。
toString方法 在Object中还有一个重要的方法，就是toString方法，它会返回表示对象值的一个字符串。大多数的toString方法都遵循这种格式：类的名字，随后是一对方括号括起来的字段值：
public String toString() {  return &amp;#34;Employee[name&amp;#34; &#43; name &#43; &amp;#34;,salary=&amp;#34; &#43; salary &#43; &amp;#34;,hireDay=&amp;#34; &#43; hireDay &#43; &amp;#34;]&amp;#34;; }  System.out.println(e.toString());  // 执行结果 Employee[nameRomeo,salary=55000.0,hireDay=2003-03-31] 只要对象与一个字符串通过操作符&#43;连接起来，编译器就会自动地调用toString方法来获得这个对象的字符串描述：
Student stu = new Student(); System.out.println(stu &#43; &amp;#34;123&amp;#34;);  // 执行结果 Student@12cdcf4123 main方法 每一个类可以有一个main方法，这是常用于对类进行单元测试的一个技巧。例如在Employee类中添加一个main方法：
class Employee {  private String name;  private Double salary;  private LocalDate hireDay;   public Employee(String n, double s, int year, int month, int day) {  name = n;  salary = s;  hireDay = LocalDate.of(year, month, day);  }   public void raiseSalary(double percent) {  this.salary &#43;= (this.salary * percent / 100);  }   {  name = &amp;#34;name&amp;#34;;  salary = 2.3;  hireDay = LocalDate.now();  }   static {  System.out.println(&amp;#34;static block&amp;#34;);  }   public static void test() {  System.out.println(&amp;#34;HaHa&amp;#34;);  }   public static void main(String[] args) {  var e = new Employee(&amp;#34;Romeo&amp;#34;, 50000, 2003, 3, 31);  e.raiseSalary(10);  System.out.println(e.salary);  } } 泛型数组列表 在Java中，允许在运行时确定数组的大小。下面代码一旦确定了数组的大小，就不能容易地改变它了。这种方式并没有完全解决运行时动态修改数组的问题。
int size = 10; var staff = new Employee[size]; 解决这个问题最简单的方式是使用ArrayList，它是一个有类型参数(type parameter)的泛型类(generic class)。需要注意的是类型参数必须是引用类型，不能是基本类型：
var staff = new ArrayList&amp;lt;Employee&amp;gt;(); ArrayList&amp;lt;Employee&amp;gt; employees = new ArrayList&amp;lt;&amp;gt;(); 如果想要定义一个整型数组列表，因为尖括号中的类型不允许是基本类型。也就是不能使用new ArrayList&amp;lt;int&amp;gt;()这样的方式定义新的数组。
此时可以使用基本类型的包装器，这些包装器为：Integer，Long，Float，Double，Short，Byte，Character和Boolean。前6个类派生于公共的超类Number：
var list = new ArrayList&amp;lt;Integer&amp;gt;(); 由于每个值分别包装在一个对象中，所以new ArrayList&amp;lt;Integer&amp;gt;的效率远低于int []数组，因此要谨慎使用。有一个很有用的特性，可以容易地向ArrayList&amp;lt;Integer&amp;gt;添加int类型的元素：
var arrList = new ArrayList&amp;lt;Integer&amp;gt;(); arrList.add(1); arrList.add(2); arrList.add(1233); System.out.println(arrList);  // 执行结果 [1, 2, 1233] 上面代码会自动地将list.add(1)转换为list.add(Integer(1))，这种转换被称为自动包装(autoBoxing)。反过来，当将一个Integer对象赋值给一个int值时，会自动拆箱(unboxed)。
int n = list.get(i);  Integer a0 = 12; int a01 = a0; System.out.println(a0 == a01); // true 自动包装和自动拆箱甚至适用于算术表达式。例如，可以将自增运算符运用于一个包装器引用，编译器将自动地插入指令对对象进行拆箱，然后将结果值增加1，最后再将其装箱。
Integer n = 3; n&#43;&#43;; 枚举类 enum Size {  Small,  Medium,  Large,  ExtraLarge, } 实际上，上面声明定义的枚举类型是一个类，它恰好只有4个实例，不可能构造新的对象（枚举的构造器总是私有的）。因此，在比较枚举类型的值时，不需要使用equals，可以直接使用==（因为==比较的是内存地址）。
如果需要的话，可以为枚举类型增加构造器、方法和属性。但需要特别注意，构造器仅在构造枚举常量时调用。因为枚举的构造器总是私有的，所以可以省略private。如果一个enum的构造器为protectd或public，则会出现编译错误。
enum Size {  SMALL(&amp;#34;S&amp;#34;),MEDIUM(&amp;#34;M&amp;#34;),LARGE(&amp;#34;L&amp;#34;), EXTRA_LAGRE(&amp;#34;XL&amp;#34;);   // 自定义属性  private String abbreviation;   // 若在构造器前面添加public或protected会报错  // java: 此处不允许使用修饰符public/protected  Size(String abbreviation) {  this.abbreviation = abbreviation;  }   public String getAbbreviation() {  return this.abbreviation;  } } 所有枚举类型都是抽象类Enum的子类，继承了这个类的许多方法，其中最有用的是实例方法toString，它的逆方法是静态方法valueOf。如果传入的字符串和枚举中的成员不匹配，会抛出IllegalArgumentException异常：
System.out.println(Size.Medium.toString()); // Medium  Size size1 = Enum.valueOf(Size.class,&amp;#34;Small&amp;#34;); System.out.println(size1); // SMALL  Size1 size2 = Enum.valueOf(Size1.class, &amp;#34;S&amp;#34;); System.out.println(size2); // 出现编译错误No enum constant Size1.S 每个枚举类型都有一个静态values方法，它返回一个包含全部枚举值的数组：
for(Size item: Size.values()) {  System.out.println(item); }  // 执行结果 SMALL MEDIUM LARGE EXTRA_LAGRE 方法ordinal返回enum声明中枚举常量的位置，位置从0开始计数，例如打印Size.Medium.ordinal的值为1:
System.out.println(Size.Medium.ordinal());  // 执行结果 1 抽象类 抽象类与模板的作用相似，可以根据它的格式来创建新的类。但不能直接用抽象类创建对象，只能通过抽象类派生出新的子类，再由子类来创建对象。也就是说，抽象类不能用new运算符来创建实例对象。抽象类的定义格式如下：
abstract class 类名 {  声明成员变量;  返回值的数据类型 方法名(参数表) {  ...  }  abstract 返回值的数据类型 方法名(参数表); } 抽象类中的方法分为两种，一种是一般的方法，另一种是抽象方法。抽象方法是以abstract关键字开头的方法，只需声明返回值类型，方法名和所需的参数，无方法体。即抽象方法只需声明，无具体实现，相当于子类中实现的占位。
当一个方法为抽象方法时，意味着这个方法必须被子类所覆写，否则子类仍然是abstract的。抽象方法声明时不能使用修饰符static，即修饰符static和abstract不能同时修饰某个方法。
需要注意的是，抽象类中不一定包含抽象方法，但包含抽象方法的类一定要声明为抽象类。extend一个抽象类时，可以有两种选择，一种是全部实现抽象方法，另一种是实现部分抽象方法（此时该类仍是抽象类）。
抽象类可以有构造方法，且构造方法可以被子类的构造方法调用，但其构造方法不能被声明为抽象的。
abstract class Person1 {  private String name;   Person1(String name) {  this.name = name;  }   // 抽象方法：子类实现，占位符  abstract String getDescription();   // 一般方法  String getName() {  return name;  }  } 抽象类不能被实例化，如果声明了一个类为抽象类，就不能创建这个类的实例。但可以定义一个抽象类的对象变量，该变量只能引用非抽象子类的对象，因为不能创建抽象类的实例。
反射 class类 能够分析类能力的程序称为可反射的。在程序运行期间，Java运行时系统始终为所有对象维护一个运行时类型标识，这个信息会跟踪每个对象所属的类，虚拟机利用运行时类型信息选择要执行的正确的方法。
可以使用一个特殊的类来访问这些信息，保存这些信息的类名为Class。Object类中的getClass()方法会返回一个Class类型的实例。Class最常用的方法是getName，它返回类的名字，如果类在一个包中，包名也会作为返回的类名的一部分。
Size size = Size.MEDIUM; System.out.println(size.getClass().getName());  System.out.println(e.getClass().getName() &#43; &amp;#34; &amp;#34; &#43; e.getName()); var generator = new Random(); Class cls = generator.getClass(); // 如果类在一个包里，包的名字也作为类名的一部分 System.out.println(cls.getName());  // 执行结果 Employee Romeo java.util.Random 还可以使用静态方法forName获得类名对应的Class对象。如果className是一个类名或接口名，这个方法可以正常执行，否则forName方法将抛出一个异常，因此无论什么时候使用该方法都应该提供一个异常处理器。
String className = &amp;#34;java.util.Random&amp;#34;; try {  Class cls1 = Class.forName(className);  System.out.println(cls1.getName()); } catch (ClassNotFoundException ex) {  System.out.println(ex.getLocalizedMessage()); }  // 执行结果 java.util.Random 获得Class类对象的第三种方法是一个很快捷的方式，如果T是任意的Java类型（或Void关键字），T.class将代表匹配的类对象：
Class cl1 = Random.class; Class cl2 = int.class; Class cl3 = Double[].class; System.out.printf(&amp;#34;%s\n%s\n%s\n&amp;#34;, cl1.getName(), cl2.getName(), cl3.getName());  // 执行结果 java.util.Random int [Ljava.lang.Double; 需要注意的是，一个Class对象实际上表示一个类型，可能是类，也可能不是类。如上所示，虽然int不是类，但int.Class是一个Class类型的对象。Class类实际上是一个泛型，如Employee.class的类型是Class&amp;lt;Employee&amp;gt;。
虚拟机为每个类型管理一个唯一的Class对象。因此，可以利用==运算符实现两个类对象的比较：
if (e.getClass() == Employee.class) 如果e是一个Employee实例，比较表达式返回true。与条件e instanceof Employee 不同，如果e是某个子类的实例，e.getClass() == Employee.class 将返回false。
如果有一个Class类型的对象，可以用它构造类的对象。调用getConstructor方法将得到一个Constructor类型的对象，然后使用newInstance方法构造一个实例。但需要注意的是，如果该类没有无参构造器，则使用getConstructor会抛出一个异常：
String className = &amp;#34;java.util.Random&amp;#34;; try {  Class cls0 = Class.forName(className);  Object object1 = cls0.getConstructor().newInstance();  System.out.println(cls0.getName()); } catch (ClassNotFoundException | NoSuchMethodException ex) {  System.out.println(ex.getLocalizedMessage()); } catch (InvocationTargetException ex) {  throw new RuntimeException(ex); } catch (InstantiationException ex) {  throw new RuntimeException(ex); } catch (IllegalAccessException ex) {  throw new RuntimeException(ex); } 接口 接口用来描述类应该做什么，而不指定它们具体该怎么做，一个类可以实现一个或多个接口。接口与抽象类非常相似，本身也具有数据成员与抽象方法，但与抽象类有很大不同：
 接口中不能包含实例，但可以包含常量，即接口的数据成员必须初始化。 在Java 8之前，接口中的方法必须全部声明为abstract，即不能拥有普通的方法。但现在接口中还可以有其它方法（这些方法不能引用实例字段，因为接口不能创建实例）。  class 类名称 implements 接口名表 {  ... } 上面是接口实现的语法，接口的实现类似于继承，但使用implements关键字。若一个类要实现一个接口，应该要注意如下问题：
 如果实现某接口的类不是抽象类，则在类定义部分必须实现该接口的所有抽象方法，即非抽象类中不能存在抽象方法。 一个类在实现某接口的抽象方法时，必须使用完全相同的方法头。否则，就是在定义一个新方法，而不是实现接口中已有的抽象方法。 接口可以作为一种引用类型来使用，任何实现了该接口的类实例都可以存储在该接口类型的变量中，通过接口变量可以访问类中所实现接口中的方法。  需要特别注意的是，接口中的所有方法都自动为public的，在声明接口时不必显式提供public关键字。但在实现接口时，必须把方法都声明为public的，否则编译器认为这个方法的访问属性是包可访问的，将会出现编译错误。
类似的，接口中的字段默认为public static final，可以显式地将接口中的方法标记为public，将字段标记为public static final，但不建议这样做。
在Java 9 中，接口的方法可以是private的，关键字private既可以修饰静态方法也可以修饰实例方法。由于私有方法只能在接口本身的方法中使用，所以接口中private方法用途有限，只是作为接口中其它方法的辅助。
接口不是类，即不能使用new操作符来实例化一个接口。接口变量必须引用一个实现了该接口的类对象。可以使用instanceof操作符检查一个对象是否实现了某个特定的接口。
可以为任何接口方法提供默认实现，即使用关键字default来修饰方法，默认方法在保持接口的源代码兼容方面很有用（新增接口不会出现编译错误）。在默认方法中也可以调用其它方法：
public interface AA {  String name = &amp;#34;123&amp;#34;;   int size();  default boolean isEmpty() {  return size() == 0;  } } 如果在一个接口中将某个方法定义成了默认方法，在接口的父类中定义了同样签名的方法，或者在另一个接口中定义了相同签名的方法，就会产生冲突。解决接口中默认方法冲突的原则：
 父接口优先，即忽略待实现接口中的默认方法。 如果一个类同时实现了两个接口，并且这两个接口有同名的默认方法，则由编码者覆盖默认方法来解决冲突，解决二义性问题。  类优先原则：如果一个类继承了一个父类，并实现了一个接口。这个父类和接口具有相同的方法，则接口的所有默认方法都会被忽略。这个规则被称为类优先规则，它可以确保与Java 7的兼容性，如果一个接口增加默认方法，这对于有默认方法之前能正常工作的代码不会有任何影响。
接口的继承 接口也可以被继承。定义一个接口时可通过extends关键字声明该新接口是某个已存在父接口的子接口，它将继承父接口的所有变量与方法。与类继承不同的是，一个接口可以有一个以上的父接口，它们之间用逗号分隔，形成父接口列表，新接口将继承所有父接口中的变量与抽象方法。
虽然Java只支持类的单重继承机制，即一个类只能有一个直接父类。但是，它可以同时实现若干个接口，实际上就可以获得多个父类，即实现了多重继承。
lambda表达式 lambda是一个可传递的代码块，可以在以后执行一次或多次。在Java中不能直接传递一个代码块，因为它是一种面向对象的语言，所以必须构造一个对象，这个对象有一个方法包含所需的代码。
在Java中有很多封装代码块的接口，例如ActionListener或Comparator，lambda表达式与这些接口是兼容的。对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式，这种接口被称为函数式接口。
内部类 内部类是定义在类中的类，主要作用是将逻辑上相关的类放到一起。而匿名类是一种特殊的内部类，它没有类名，在定义类的同时，就生成了该类的一个实例，由于不会在其它地方用到该类，所以不用取名字，因而又被称为匿名内部类。
内部类定义 定义内部类时只需要将类的定义置于一个用于封装它的类的内部即可，但内部类不能与外部类同名，如果内部类还有内部类，则不能与任何一层内部类同名，这与代码块中不能定义同名局部变量规则一致。
在封装内部类的类中使用内部类，与普通类的使用方式相同。但在外部使用内部类时，需要在内部类前冠以其所属外部类的名字才能使用：
class Group {  private int age;   public class MoStu {  String name;   public MoStu(String name) {  this.name = name;  }   public void show() {  System.out.println(&amp;#34;MoStu show&amp;#34;);  }  }   public void show() {  System.out.println(&amp;#34;Group show&amp;#34;);  MoStu stu = new MoStu(&amp;#34;test&amp;#34;);  stu.show();  } }  Group group = new Group(); group.show(); // 创建内部类需要使用外部类作为前缀 Group.MoStu stu = group.new MoStu(&amp;#34;outside&amp;#34;); stu.show(); Java将内部类作为一个成员，就如同成员变量或成员方法。内部类可以被声明为private或protected。在内部类中可以直接引用它的外部类的成员，包括静态成员、实例成员和私有成员：
class Group {  private int age;   public class MoStu {  String name;   public MoStu(String name) {  this.name = name;  // 直接使用外部类的实例成员  age = 34;  }   public void show() {  System.out.println(&amp;#34;MoStu show&amp;#34;);  }  }   public int getAge() {  return age;  }   public void show() {  System.out.println(&amp;#34;Group show&amp;#34;);  } }  Group group = new Group(); group.show(); // new前面是外部类的名 Group.MoStu moStu = group.new MoStu(&amp;#34;outside&amp;#34;); moStu.show(); System.out.println(group.getAge());  // 执行结果 Group show MoStu show 34 不能直接创建内部类的对象实例，必须使用外部类对象实例来创建内部类对象实例。对于上面示例，可以使用如下方式在外部创建内部类的实例：
Group.MoStu stu = group.new MoStu(&amp;#34;outside&amp;#34;); stu.show(); 匿名内部类 匿名内部类前不能有修饰符，也不能定义构造方法，因为它没有名字。也正是这个原因，在创建对象时不能带参数，因为默认构造函数不带参数：
class Group {  private int age;   // 内部类  public class MoStu {  String name;   public MoStu(String name) {  this.name = name;  }   public void show() {  System.out.println(&amp;#34;MoStu show&amp;#34;);  }  }   // 抽象类  abstract class Person {  public abstract void eat();  }   public void show() {  System.out.println(&amp;#34;Group show&amp;#34;);  MoStu stu = new MoStu(&amp;#34;test&amp;#34;);  stu.show();   // 匿名内部类  Person p = new Person() {  public void eat() {  System.out.println(&amp;#34;eat something&amp;#34;);  }  };  p.eat();   Thread t = new Thread() {  public void run() {  for (int i = 1; i &amp;lt;= 5; i&#43;&#43;) {  System.out.print(i &#43; &amp;#34; &amp;#34;);  }  }  };  t.start();  } }  // 执行结果 eat something 1 2 3 4 5 包 Java使用包来确保类名的唯一性。为了保证包名的唯一性，要用一个因特网域名以逆序的方式作为包名，对于不同工程使用不同的子包。例如域名mac.com，逆序就是com.mac，然后追加一个工程名，如com.mac.study，如果再把Employee类放在包里，那么这个类的全名就是com.mac.study.Employee。一个类可以使用所属包中的所有类，以及其它包中的公共类。
静态导入 有一种import语句允许导入静态方法和静态字段，而不只是类。如果在源文件顶部，添加如下指令，就可以使用System类的静态方法和静态字段：
import static java.lang.System.*;  out.println(&amp;#34;Hello World!&amp;#34;); 创建包 如果没在源文件中放置package语句，这个源文件中的类就属于无名包(unnamed package)。若要创建自己的包，就必须以package语句作为源文件的第一条语句，指明该文件中定义类所在的包，格式为：
package 包名1[.包名2][.包名3][...] 经过package声明后，同一文件内的所有类或接口都被纳入相同的包中。编译器将包对应于文件系统的文件夹进行管理，例如：
package test.myPackage 上面例子指定包中的文件存储在文件夹test\myPackage中。实际上创建包就是在当前文件夹中创建一个子文件夹，语句中的.代表文件分隔符，即上面的语句创建了两个文件夹。第一个文件夹是test，第二个是myPackage，当前包中所有的类就存放在这个文件夹中。同一包中类名不能重复，不同包中的类名可以相同。
包名标识符全部都是小写，由字母、数字和下划线组成，但不能以数字开头。
异常 异常本质上是程序运行期间发生的事件，这个事件将中断程序的正常执行，当在Java方法内部发生异常时，这个方法就会创建一个异常对象，并把它传递给运行时环境。
Java中所说的异常都是Exception类及其子类，异常处理通过try,catch,finally,throw,throws五个关键字来实现的。
异常捕获 public void handleException() {  int[] arr = {1, 2, 3, 4};  for (int i = 0; i &amp;lt; 5; i&#43;&#43;) {  try {  System.out.println(arr[i] / i);  } catch (ArrayIndexOutOfBoundsException e) {  System.out.println(e.getLocalizedMessage());  } catch (ArithmeticException e) {  System.out.println(e.getLocalizedMessage());  } catch (Exception e) {  System.out.println(e.getLocalizedMessage());  } finally {  System.out.println(&amp;#34;finally&amp;#34;);  }  } }  try {  int a12 = Integer.parseInt(&amp;#34;12.34&amp;#34;);  System.out.println(a12);　} catch (NumberFormatException e) {  System.out.println(e); }   异常捕获过程中做了两个判断，第一个是try程序块中是否有异常产生；第二个是产生的异常是否和catch后面括号内预捕获的异常类型匹配。
  catch块中语句应该根据异常类型的不同而执行不同的操作，比较通用的做法是输出异常相关的信息，包括异常的名称，产生异常的方法名等。
  由于异常对象于catch块的匹配是按照catch块的先后排列顺序进行的，所以在处理异常时，应该认真设计各catch块的排列顺序。
  当在try块中语句抛出一个异常时，其后的代码都不会被执行，所以此时可以通过finally语句块来提供统一的出口。
  finally块是可以省略的，若省略，则在catch块结束后，程序跳转到try-catch块之后的语句继续运行。
  当catch块中包含System.exit(0)语句时，则不执行finally语句块，程序直接终止。而当catch块中包含return语句时，则执行完执行finally语句块，再会终止程序。
  抛出异常 所有系统定义的运行时异常都可以由系统自动抛出。而指定方法抛出异常要使用throw或者throws来明确指定方法内抛出异常。一个方法声明抛出异常有两种方式，第一种是在方法内抛出异常对象，异常类对象是一个从Throwable派生的异常类对象：
throw 异常类对象 第二种方式，在方法声明中添加throws子句，表示方法将抛出异常。带有throws子句的方法声明格式如下：
[修饰符] 返回值类型 方法名([参数列表]) throws 异常类列表 通过上面两种方式抛出的异常，在方法中可以不使用try-catch-finally来处理异常，而交由调用此方法的上层方法处理。
如果一个方法抛出异常后，该方法内又没有处理异常的语句，则系统会将异常向上传递，由调用它的方法来处理这些异常，若上层调用方法中仍没有处理异常的语句，则可以再往上传递，直到传递到main方法，由JVM处理。
多线程 多线程是指在同一个进程中同时存在几个执行体，按几条不同的执行路径同时工作的情况。所以多线程编程的含义就是将一个程序分为几个可以同时并发执行的子任务。
Java中实现多线程的方法有两种，一种继承自java.lang包中的Thread类。另一种是用户在自定义类中实现Runnable接口。要在一个Thread子类中激活线程，必须要准备好下列两种事情：
  此类必须是继承自Thread类。
  线程所要执行的代码必须写在run方法内。但一般不直接调用run方法，而是通过线程的start方法来启动线程。
  Thread class ThreadTest extends Thread {  private String who;   public ThreadTest(String str) {  this.who = str;  }   public void run() {  for (int i = 0; i &amp;lt; 5; i&#43;&#43;) {  try {  sleep((int) (1000 * Math.random()));  } catch (InterruptedException e) {  System.out.println(e.toString());  }  System.out.println(who &#43; &amp;#34;正在运行!&amp;#34;);  }  } }  ThreadTest thread1 = new ThreadTest(&amp;#34;thread1&amp;#34;); ThreadTest thread2 = new ThreadTest(&amp;#34;thread2&amp;#34;); thread1.start(); thread2.start(); System.out.println(&amp;#34;main 方法执行结束&amp;#34;);  // 某次执行结果，因为使用了随机数，每次执行结果不同 main 方法执行结束 thread2正在运行! thread2正在运行! thread1正在运行! thread1正在运行! thread2正在运行! thread1正在运行! thread2正在运行! thread2正在运行! thread1正在运行! thread1正在运行! Runnable 上面使用继承Thread的方式来创建线程，具有局限性。因为，如果类本身已经继承了某个父类，因为类不允许多继承，所以此时需要类实现Runnable接口。Runnable接口定义在java.lang包中，其中只提供了一个抽象方法run()的声明，从本质上说，任何实现线程的类必须实现该接口：
class ThreadTestMo implements Runnable {  private String who;   public ThreadTestMo(String str) {  who = str;  }   @Override  public void run() {  for (int i = 0; i &amp;lt; 5; i&#43;&#43;) {  try {  Thread.sleep((int) (1000 * Math.random()));  } catch (InterruptedException e) {  System.out.println(e.toString());  }  System.out.println(who &#43; &amp;#34;正在运行!&amp;#34;);  }  } }  ThreadTestMo mo1 = new ThreadTestMo(&amp;#34;thread1&amp;#34;); ThreadTestMo mo2 = new ThreadTestMo(&amp;#34;thread2&amp;#34;); Thread thread1 = new Thread(mo1); Thread thread2 = new Thread(mo2); thread1.start(); thread2.start(); System.out.println(&amp;#34;main 方法执行结束&amp;#34;);  // 某次执行结果，因为使用了随机数，每次执行结果不同 main 方法执行结束 thread1正在运行! thread2正在运行! thread1正在运行! thread2正在运行! thread1正在运行! thread1正在运行! thread2正在运行! thread1正在运行! thread2正在运行! thread2正在运行! 如果需要线程有序执行，就需要使用join方法。当某一线程调用join方法后，则其它线程会等到该线程结束后才开始执行：
public static void threadJoin() {  ThreadTestMo test0 = new ThreadTestMo(&amp;#34;test0&amp;#34;);  ThreadTestMo test1 = new ThreadTestMo(&amp;#34;test1&amp;#34;);  Thread thread1 = new Thread(test0);  Thread thread2 = new Thread(test1);  thread1.start();  try {  thread1.join();  } catch (InterruptedException e) {  System.out.println(e.toString());  }  thread2.start();  try {  thread2.join();  } catch (InterruptedException e) {  System.out.println(e.toString());  }  System.out.println(&amp;#34;测试方法运行完毕&amp;#34;); }  // 执行后的结果 test0正在运行! test0正在运行! test0正在运行! test0正在运行! test0正在运行! test1正在运行! test1正在运行! test1正在运行! test1正在运行! test1正在运行! 测试方法运行完毕 数据共享 若直接使用Thread类，在类中this即指当前线程。若是实现Runnable接口的类，要在此类中获取当前线程，必须使用Thread.currentThread()方法。
使用Runnable接口可以轻松实现多个线程共享相同的数据，只要用同一个实现了Runnable接口类的实例作为参数创建多个线程：
class ThreadSale implements Runnable {  private int tickets = 10;   @Override  public void run() {  while (true) {  if (tickets &amp;gt; 0) {  System.out.println(Thread.currentThread().getName() &#43; &amp;#34;售机票第&amp;#34; &#43; tickets-- &#43; &amp;#34;号&amp;#34;);  } else {  System.exit(0);  }  }  } }  public static void threadShare() {  ThreadSale sale = new ThreadSale();  Thread t1 = new Thread(sale, &amp;#34;第一号窗口&amp;#34;);  Thread t2 = new Thread(sale, &amp;#34;第二号窗口&amp;#34;);  Thread t3 = new Thread(sale, &amp;#34;第三号窗口&amp;#34;);  t1.start();  t2.start();  t3.start(); }  // 某次执行结果 第二号窗口售机票第9号 第三号窗口售机票第8号 第一号窗口售机票第10号 第三号窗口售机票第6号 第二号窗口售机票第7号 第三号窗口售机票第4号 第一号窗口售机票第5号 第二号窗口售机票第3号 第三号窗口售机票第2号 第一号窗口售机票第1号 多线程同步 为了保证互斥，Java使用synchronized关键字来标识同步的资源，这里的资源可以是对象，也可以是一个方法，还可以是一段代码。
synchronized (对象) {  临界代码段 }  public synchronized 返回类型 方法名() {  方法体 } synchronized的功能：首先判断对象或方法的互斥锁是否存在，若在就获得互斥锁，然后就可以执行紧随其后的临界代码段或方法体；如果对象或方法的互斥锁不在，就进入等待状态，直到获得互斥锁。当被synchronized限定的代码段执行完，就会自动释放互斥锁。
线程通信 java.lang.Object类的wait(),notify()等方法为线程间的通信提供了有效手段，但wait(),notify()只能在同步代码块里调用。
   方法 功能说明     public void wait() 如果一个正在执行的同步代码(synchronized)的线程A执行了wait()调用「在对象x上」，该线程暂停执行而进入对象x的等待队列，并释放已获得的对象x的互斥锁。线程A要一直等到其他线程在对象x上调用notify或notifyAll，才能够再重新获得对象x的互斥锁后继续执行。   public void notify() 唤醒正在等待该对象互斥锁的第一个线程   public void notifyAll() 唤醒正在等待该对象互斥锁的所有线程，优先级高的先被唤醒    </content>
    </entry>
    
     <entry>
        <title>鼠须管配置</title>
        <url>https://iihui.github.io/post/tool-squirrel/</url>
        <categories>
          <category>tool</category>
        </categories>
        <tags>
          <tag>tool</tag>
        </tags>
        <content type="html">  鼠须管是macOS上一款高度可定制的输入法软件，它当前没有自带图形设置界面，需通过修改yaml配置文件来实现设置变更。这篇文章记录折腾鼠须管0.15.1版本时遇到的一些问题和解决方案，并且只在0.15.1上验证过有效性。
 横排显示 鼠须管默认是竖排显示候选词的，为了修改为横排显示，首先在~/Library/Rime目录下创建配置文件squirrel.custom.yaml，并在其中添加如下代码，并且重新部署才可生效：
patch:  style/horizontal: true #注意style前是tab 自定义配色 鼠须管默认的候选词配色方案个人觉得不好看，可以在~/Library/Rime/squirrel.custom.yaml文件中添加一些自定义主题配色。下面是从网络上看到的一些主题配色：
 preset_color_schemes:  mojave_dark:  name: &amp;#34;沙漠夜／Mojave Dark&amp;#34;  author: &amp;#34;xiehuc &amp;lt;xiehuc@gmail.com&amp;gt;&amp;#34;  horizontal: true  inline_preedit: true  candidate_format: &amp;#34;%c %@&amp;#34;  corner_radius: 5  hilited_corner_radius: 0  border_height: 6  border_width: 12  border_color_width: 0  font_face: PingFangSC  font_point: 16  label_font_point: 13  text_color: 0xdedddd  back_color: 0x3c3c3c  label_color: 0x888785  border_color: 0x3c3c3c  candidate_text_color: 0xdedddd  hilited_text_color: 0xdedddd  hilited_back_color: 0x3c3c3c  hilited_candidate_text_color: 0xefefef  # hilited_candidate_back_color: 0xcb5d00  hilited_candidate_label_color: 0xefefef  comment_text_color: 0xdedddd  clean_white:  author: &amp;#34;Chongyu Zhu &amp;lt;lembacon@gmail.com&amp;gt;, based on 搜狗「简约白」&amp;#34;  back_color: 0xeeeeee  border_height: 6  border_width: 6  candidate_format: &amp;#34;%c %@&amp;#34;  candidate_text_color: 0x000000  comment_text_color: 0x808080  corner_radius: 6  font_point: 16  hilited_candidate_back_color: 0xeeeeee  hilited_candidate_label_color: 0xa0c98915  hilited_candidate_text_color: 0xc98915  hilited_text_color: 0x000000  horizontal: true  label_color: 0x888888  label_font_point: 12  name: &amp;#34;简约白／Clean White&amp;#34;  text_color: 0x808080 接着在~/Library/Rime/squirrel.custom.yaml文件中修改style/color_scheme的值为想要设置的主题，就可以完成候选词颜色主题切换：
style:  color_scheme: mojave_dark 候选词数量 首先在~/Library/Rime目录下创建全局配置文件default.custom.yaml，并在其中添加menu/page_size和对应候选词的个数，即可修改每页候选词的数量：
patch:  menu/page_size: 9 #每页候选词的数量 输入方案 鼠须管提供了一些常见的输入方案，可以在全局配置文件~/Library/Rime/default.custom.yaml文件中设置可以激活的预选输入方案：
schema_list: #“输入选单”中激活的输入方案定义。  - schema: luna_pinyin_simp  - schema: luna_pinyin 翻页快捷键 鼠须管默认使用上下箭头来翻页候选词，这与默认输入法使用[和]翻页候选词不同。为了修改翻页快捷键，需要在~/Library/Rime/default.custom.yaml文件中添加如下快捷键：
 key_binder/bindings:  - { when: has_menu, accept: bracketleft, send: Page_Up } #使用[向上翻页  - { when: has_menu, accept: bracketright, send: Page_Down } #使用]向下翻页 参考资料
生僻字 默认情况下，对于生僻字鼠须管显示为一个带问号的方框，看着很难受。可以从这里或者这里下载花园明朝字体，安装完即可解决生僻字显示乱码问题。
默认英文模式 在鼠须管中，软件可以设置默认英文模式，只需知道软件的Bundle identifier。默认英文模式的设置需要修改~/Library/Rime/squirrel.custom.yaml文件，将其下的app_options添加对应的ascii_mode: true。而Bundle identifier需要在Applications中找到对应的软件，右键选择Show Package Contents，进入content，打开Info.plist文件，在其中找到Bundle identifier即可：
 # 以下软件默认英文模式  app_options:  com.apple.dt.Xcode:  ascii_mode: true  com.runningwithcrayons.Alfred:  ascii_mode: true  com.apple.Terminal:  ascii_mode: true  com.googlecode.iterm2:  ascii_mode: true  com.apple.finder:  ascii_mode: true  com.sublimetext.3:  ascii_mode: true Emoji 首先切换输入法到朙月拼英文简化字，接着从这里下载opencc文件夹，将其放入到~/Library/Rime/目录下。然后在~/Library/Rime/目录下创建luna_pinyin_simp.custom.yaml文件，复制如下代码到其中，重新部署即可生效。
# encoding: utf-8  patch:  switches/@next:  name: emoji_suggestion  reset: 1  states: [ &amp;#34;🈚️️\uFE0E&amp;#34;, &amp;#34;🈶️️\uFE0F&amp;#34; ]  &amp;#39;engine/filters/@before 0&amp;#39;:  simplifier@emoji_suggestion  emoji_suggestion:  opencc_config: emoji.json  option_name: emoji_suggestion  tips: all 参考资料 参考资料 参考资料
大写键中英文切换 系统默认输入法，可以设置大写键进行中英文切换，鼠须管也可以设置大写键进行中英文切换。需要在~/Library/Rime/default.custom.yaml文件中加入如下代码：
patch:  ascii_composer/good_old_caps_lock: false  ascii_composer/switch_key:  Caps_Lock: commit_code  Shift_L: noop  Shift_R: noop  Control_L: noop  Control_R: noop 切换无效 在IntelliJ系列的软件中发现设置good_old_caps_lock: false后用CapsLock切换中英文输入法不生效，反而英文变成了大写。在终端中使用如下命令，然后重新部署一下：
cd /Library/Input Methods/Squirrel.app/Contents sudo /usr/libexec/PlistBuddy -c &amp;#39;Add :TICapsLockLanguageSwitchCapable bool true&amp;#39; Info.plist 参考资料
快捷符号 快捷符号可以在中文状态下，通过直接输入/dn来调出特殊符号。需要在~/Library/Rime/目录下的luna_pinyin_simp.custom.yaml文件中，添加如下配置：
 punctuator:  import_preset: symbols  symbols:  &amp;#34;/fs&amp;#34;: [½,‰,¼,⅓,⅔,¾,⅒,½,⅓,⅔,¼,¾,⅕,⅖,⅗,⅘,⅙,⅚,⅐,⅛,⅜,⅝,⅞,⅑,⅒,⅟,↉,℀,℁,℅,℆,⅍]  &amp;#34;/dq&amp;#34;: [🌍,🌎,🌏,🌐,🌑,🌒,🌓,🌔,🌕,🌖,🌗,🌘,🌙,🌚,🌛,🌜,🌝,🌞,⭐,🌟,🌠,⛅,⚡,❄,🔥,💧,🌊]  &amp;#34;/jt&amp;#34;: [⬆,↗,➡,↘,⬇,↙,⬅,↖,↕,↔,↩,↪,⤴,⤵,🔃,🔄,🔙,🔚,🔛,🔜,🔝]  &amp;#34;/sg&amp;#34;: [🍇,🍈,🍉,🍊,🍋,🍌,🍍,🍎,🍏,🍐,🍑,🍒,🍓,🍅,🍆,🌽,🍄,🌰,🍞,🍖,🍗,🍔,🍟,🍕,🍳,🍲,🍱,🍘,🍙,🍚,🍛,🍜,🍝,🍠,🍢,🍣,🍤,🍥,🍡,🍦,🍧,🍨,🍩,🍪,🎂,🍰,🍫,🍬,🍭,🍮,🍯,🍼,🍵,🍶,🍷,🍸,🍹,🍺,🍻,🍴]  &amp;#34;/dw&amp;#34;: [🙈,🙉,🙊,🐵,🐒,🐶,🐕,🐩,🐺,🐱,😺,😸,😹,😻,😼,😽,🙀,😿,😾,🐈,🐯,🐅,🐆,🐴,🐎,🐮,🐂,🐃,🐄,🐷,🐖,🐗,🐽,🐏,🐑,🐐,🐪,🐫,🐘,🐭,🐁,🐀,🐹,🐰,🐇,🐻,🐨,🐼,🐾,🐔,🐓,🐣,🐤,🐥,🐦,🐧,🐸,🐊,🐢,🐍,🐲,🐉,🐳,🐋,🐬,🐟,🐠,🐡,🐙,🐚,🐌,🐛,🐜,🐝,🐞,🦋]  &amp;#34;/bq&amp;#34;: [😀,😁,😂,😃,😄,😅,😆,😉,😊,😋,😎,😍,😘,😗,😙,😚,😇,😐,😑,😶,😏,😣,😥,😮,😯,😪,😫,😴,😌,😛,😜,😝,😒,😓,😔,😕,😲,😷,😖,😞,😟,😤,😢,😭,😦,😧,😨,😬,😰,😱,😳,😵,😡,😠]  &amp;#34;/ss&amp;#34;: [💪,👈,👉,👆,👇,✋,👌,👍,👎,✊,👊,👋,👏,👐]  &amp;#34;/dn&amp;#34;: [⌘, ⌥, ⇧, ⌃, ⎋, ⇪, , ⌫, ⌦, ↩︎, ⏎, ↑, ↓, ←, →, ↖, ↘, ⇟, ⇞]  &amp;#34;/fh&amp;#34;: [©,®,℗,ⓘ,℠,™,℡,␡,♂,♀,☉,☊,☋,☌,☍,☑︎,☒,☜,☝,☞,☟,✎,✄,♻,⚐,⚑,⚠]  &amp;#34;/xh&amp;#34;: [＊,×,✱,★,☆,✩,✧,❋,❊,❉,❈,❅,✿,✲]  &amp;#34;/pk&amp;#34;: [♠,♥,♦,♣,♤,♡,♧,♢,🂡,🂱,🃁,🃑,🂢,🂲,🃂,🃒,🂣,🂳,🃃,🃓,🂤,🂴,🃄,🃔,🂥,🂵,🃅,🃕,🂦,🂶,🃆,🃖,🂧,🂷,🃇,🃗,🂨,🂸,🃈,🃘,🂩,🂹,🃉,🃙,🂪,🂺,🃊,🃚,🂫,🂻,🃋,🃛,🂬,🂼,🃌,🃜,🂭,🂽,🃍,🃝,🂮,🂾,🃎,🃞,🂠,🂿,🃏,🃟]  &amp;#34;/mj&amp;#34;: [🀀,🀁,🀂,🀃,🀄,🀅,🀆,🀇,🀈,🀉,🀊,🀋,🀌,🀍,🀎,🀏,🀐,🀑,🀒,🀓,🀔,🀕,🀖,🀗,🀘,🀙,🀚,🀛,🀜,🀝,🀞,🀟,🀠,🀡,🀢,🀣,🀤,🀥,🀦,🀧,🀨,🀩,🀪,🀫]  &amp;#34;/lm&amp;#34;: [ⅰ,ⅱ,ⅲ,ⅳ,ⅴ,ⅵ,ⅶ,ⅷ,ⅸ,ⅹ,ⅺ,ⅻ,ⅼ,ⅽ,ⅾ,ⅿ,Ⅰ,Ⅱ,Ⅲ,Ⅳ,Ⅴ,Ⅵ,Ⅶ,Ⅷ,Ⅸ,Ⅹ,Ⅺ,Ⅻ,Ⅼ,Ⅽ,Ⅾ,Ⅿ]  &amp;#34;/cf&amp;#34;: [&#43;,−,×,÷,±,∓,∔,⁺,⁻,⁼,⁽,⁾,ⁿ,₊,₋,₌,₍,₎,ª,º,℔,℥,ℨ,ℬ,ℊ,µ,ℌ,ℑ,℞,ℳ,℃,℉,℀,℁,℅,℆,ℾ,ℿ,⅀,ℽ,¬,∩,∪,∝,∞,ℵ,ℶ,ℷ,ℸ,ℏ,ℇ,∀,∁,∂,℮,∃,∄,∅,∆,∇,⊂,⊃,⊄,⊅,⊆,⊇,⊈,⊉,⊊,⊋,∈,∉]  &amp;#34;/jh&amp;#34;: [∊,∋,∌,∍,∧,∨,&amp;lt;,≤,≥,≦,≧,≨,≩,≪,≫,≭,≮,≯,≰,≱,≲,≳,≴,≶,≷,≸,≹,≺,≻,≼,≽,≾,≿,⊀,⊁,∎,∏,∐,∑,∕,∖,∗,∘,∙]  &amp;#34;/gh&amp;#34;: [√,∛,∜,∟,∠,∡,∢,∣,∤,∥,∦,∫,∬,∭,∮,∯,∰,∱,∲,∳,⌠,⎮,⌡,∴,∵,∶,∷,∸,∹,∺,∻,∼,∽,∾,∿,≀,≁,≂,≃,≄,≅,≆,≇,≈,≉,≊,≋,≌,≍,≎,≏,≐,≑,≒,≓,≔,≕,≖,≗,≘,≙,≚,≛,≜,≝,≞,≟,≠,≡,≢,≣,≬,⊌,⊍,⊎,⊏,⊐,⊑,⊒,⊓,⊔]  &amp;#34;/bh&amp;#34;: [㇀,㇁,㇂,㇃,㇄,㇅,㇆,㇇,㇈,㇉,㇊,㇋,㇌,㇍,㇎,㇏,㇐,㇑,㇒,㇓,㇔,㇕,㇖,㇗,㇘,㇙,㇚,㇛,㇜,㇝,㇞,㇟,㇠,㇡,㇢,㇣]  &amp;#34;/bm&amp;#34;: [⓪,①,②,③,④,⑤,⑥,⑦,⑧,⑨,⑩,⑪,⑫,⑬,⑭,⑮,⑯,⑰,⑱,⑲,⑳,⓿,❶,❷,❸,❹,❺,❻,❼,❽,❾,❿,⓫,⓬,⓭,⓮,⓯,⓰,⓱,⓲,⓳,⓴] 或者将这些特殊符号放在symbols.yaml文件中，然后在luna_pinyin_simp.custom.yaml文件中加入如下代码以载入symbols.yaml文件中特殊字符：
 #特殊符号  punctuator:  import_preset: symbols  recognizer:  import_preset: default  patterns:  punct: &amp;#34;^/([a-z]&#43;|[0-9]0?)$&amp;#34; 参考资料 参考资料
增加词库 首先从这里下载词库，然后将下载到的luna_pinyin.poetry.dict.yaml,luna_pinyin.hanyu.dict.yaml,luna_pinyin.extended.dict.yaml,luna_pinyin.cn_en.dict.yaml四个文件拷贝到~/Library/Rime/目录下，最后将luna_pinyin.custom.yaml文件中patch下的内容复制粘贴到luna_pinyin_simp.custom.yaml文件中：
 # 载入朙月拼音扩充词库  &amp;#34;translator/dictionary&amp;#34;: luna_pinyin.extended  # 改写拼写运算，使得含西文的词汇（位于 luna_pinyin.cn_en.dict.yaml 中）不影响简拼功能（注意，此功能只適用于朙月拼音系列方案，不适用于各类双拼方案）  # 本条补丁只在「小狼毫 0.9.30」、「鼠须管 0.9.25 」、「Rime-1.2」及更高的版本中起作用。  &amp;#34;speller/algebra/@before 0&amp;#34;: xform/^([b-df-np-z])$/$1_/ 由上面的代码可知，只在luna_pinyin_simp.custom.yaml文件中添加了&amp;quot;translator/dictionary&amp;quot;: luna_pinyin.extended就把所有的词库都添加进去了，而在之前拷贝了四个词典文件到~/Library/Rime/目录下，为什么只载入luna_pinyin.extended就能把其他词库都加进来？
原来在luna_pinyin_simp.custom.yaml文件中定义的字典是luna_pinyin.extended，而在luna_pinyin.extended.dict.yaml中通过import_tables将luna_pinyin,luna_pinyin.hanyu,luna_pinyin.poetry,luna_pinyin.cn_en都导入进来了：
import_tables:  - luna_pinyin  - luna_pinyin.hanyu  - luna_pinyin.poetry  - luna_pinyin.cn_en 所以，如果要添加新的词典，只要将待加入的词典放入到~/Library/Rime/目录下，然后在luna_pinyin.extended.dict.yaml的import_tables词库中添加新的词库即可：
import_tables:  - luna_pinyin  - luna_pinyin.hanyu  - luna_pinyin.poetry  - luna_pinyin.cn_en  - luna_pinyin.name  - luna_pinyin.biaoqing  - luna_pinyin.classical  - luna_pinyin.website  - luna_pinyin.chat  - luna_pinyin.net  - luna_pinyin.movie  - luna_pinyin.computer  - luna_pinyin.history  - luna_pinyin.idiom  - luna_pinyin.sougou 中英切换直接上屏 在中文输入状态的时候输入英文，按shift键后字符上屏，然后还得回车一下，可以将shift设置为直接上屏，不需要再按回车：
 ascii_composer/switch_key:  Caps_Lock: commit_code  Control_L: noop  Control_R: noop  # 按下左 shift 英文字符直接上屏，不需要再次回车，输入法保持英文状态  Shift_L: commit_code  Shift_R: noop 参考资料
升级至0.15.2 若从0.15.1升级到0.15.2版本后出现异常，可以先将luna_pinyin_simp.custom.yaml中下面代码先注释：
# 载入朙月拼音扩充词库  &amp;#34;translator/dictionary&amp;#34;: luna_pinyin.extended  # 改写拼写运算，使得含西文的词汇（位于 luna_pinyin.cn_en.dict.yaml 中）不影响简拼功能（注意，此功能只適用于朙月拼音系列方案，不适用于各类双拼方案）  # 本条补丁只在「小狼毫 0.9.30」、「鼠须管 0.9.25 」、「Rime-1.2」及更高的版本中起作用。  &amp;#34;speller/algebra/@before 0&amp;#34;: xform/^([b-df-np-z])$/$1_/ 接着将luna_pinyin.extended.dict.yaml文件中import_tables下的所有词典也都先注释，即以-开头的词典：
import_tables:  - luna_pinyin  - luna_pinyin.hanyu  - luna_pinyin.poetry  - luna_pinyin.cn_en  - luna_pinyin.name  - luna_pinyin.biaoqing  - luna_pinyin.classical  - luna_pinyin.website  - luna_pinyin.chat  - luna_pinyin.net  - luna_pinyin.movie  - luna_pinyin.computer  - luna_pinyin.history  - luna_pinyin.idiom  - luna_pinyin.sougou 然后部署，输入法正常之后将luna_pinyin_simp.custom.yaml中先前注释的代码都恢复，再次重新部署，如果依然正常，则将luna_pinyin.extended.dict.yaml文件中import_tables下面的扩展词典一个个慢慢放开。
输入法消失 将macOS升级到monterry后发现鼠须管输入法不见了，此时需要重新安装鼠须管，安装之后会弹出keyboard设置页面，再点击Input Sourece，然后选择左下角的&#43;，选中Chinese,Simplified，选中Squirrel即可：
无法切回到简体 可能按错了快捷键鼠须管输入法一直切不回简体，可以按照如下方式切回到简体。首先，打开default.yaml，确保以下配置存在：
# 强制全局默认简体 switches:  - name: simplification  reset: 1 # 1=简体，0=繁体  states: [ 繁, 简 ] 然后重新部署，接着再在终端中执行如下命令（可以先切到其它输入法，然后再切回来）：
# 关闭输入法进程 killall Squirrel # 重新启动 /Library/Input Methods/Squirrel.app/Contents/MacOS/Squirrel --reload </content>
    </entry>
    
     <entry>
        <title>UIView 使用</title>
        <url>https://iihui.github.io/post/ios-uiview/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> layoutIfNeeded与setNeedsLayout setNeedsLayout setNeedsLayout当需要调整UIView子视图布局时，需要在主线程调用此方法。此方法记录调整布局请求并立即返回「即异步执行」，等待下一个更新周期更新视图。也就是说，这个方法不会强制立即更新，而是等待下一个更新周期，才进行刷新页面。因此，可以将多个视图布局更新合并到一个update cycle，有助于提高性能。
layoutIfNeeded layoutIfNeeded方法一被调用，主线程会立即强制重新布局，它会从当前视图开始，一直到完成所有子视图的布局。如果没有待处理的布局更新，则该方法将直接退出，而不会修改布局，或调用任何与布局有关的方法。
如果要立即刷新，要先调用setNeedsLayout，把标记设为需要布局，然后马上调用layoutIfNeeded，实现布局。在视图第一次显示之前，标记肯定是需要刷新的，所以直接调用layoutIfNeeded就会进行立即更新。
参考资料
</content>
    </entry>
    
     <entry>
        <title>PromiseKit使用</title>
        <url>https://iihui.github.io/post/ios-promisekit/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  PromiseKit是简化异步编程的一种非必要方式，使用它可以提高代码的可读性和维护性，让代码更加优雅，它主要用于解决回调地狱问题。
 回调地狱 为了保证异步代码按顺序执行，通常将异步代码嵌套在回调函数中。如果异步方法过多，就会产生过多回调，一层一层嵌套，会产生所谓的回调地狱callback hell问题，难以维护。下面的fetchJSON有3次回调，代码看起来比较费劲，可读性较差：
fetchJSON(fromURL: &amp;#34;someURL&amp;#34;) { response, results, error in  switch response {  case .success:  fetchUserData(for: results) { response, results, error in  switch response {  case .success:  loginUser(user: results) { response, _, error in  switch response {  case .success:  // finally all of the callbacks are finished  print(&amp;#34;Handle logic here&amp;#34;)  case .fail:  print(error)  }  }  case .fail:  print(error)  }  }  case .fail:  print(error)  } } promise设计模式 promise借用生活中的「承诺」一词来描述异步编程中的回调模型。「承诺」是一种对未来的期许，它有以下两个特点：
  描述未来的一种状态或动作。
  承诺具有不确定性，可以被兑现fullfill，也可能被拒绝rejected。
  网络操作一般都是异步的，如果写一个方法从网络获取图片，可以使用承诺模式来实现。定义一个返回承诺对象的方法，它不直接返回Image，只有当请求到图片时，这个承诺才会兑现，然后将Image传递到承诺对象中，否则承诺被拒绝（网络错误或者图片不存在）。
无论兑现还是拒绝，这个承诺对象都会标记为已解决（resolve)，已解决的承诺会被销毁。如果既不兑现，也不拒绝，则这个承诺会一直有效，即未解决。
promise对象执行完then和catch方法后，这两个方法会返回先前的promise对象，同时根据异步操作结果改变promise对象的状态。
PromiseKit调用链 在PromiseKit中，通过promise对象将异步任务串接起来的，一个典型的promise链如下所示：
firstly {  promise1() }.then {  promise2() }.then {  promise3() }.ensure {  // 无论承诺是否兑现，都会执行ensure }.done {  // 所有承诺都被成功执行 }.catch {  // 所有被rejected的承诺都会集中在这里处理 }   其中firstly是可选的，但它只能放在第一行，需要返回一个Promise对象。
  then是放在中间的，它也要求返回一个promise，可以有无限多个then相互连接。任何一个then都可以抛出一个error。
  ensure类似于finally，不管事件是否错误，它都一定会得到执行。不同于finally，ensure可以放在任何位置。
  done是事件结束的标志，它是必须要有的，只有前面所有事件都执行成功时，才会执行done。
  而catch用于捕获异常，done之前的任何事件出现错误，都会直接进入catch块。
  举个栗子 fetchJSON(fromURL: &amp;#34;someURL&amp;#34;) { response, results, error in  switch response {  case .success:  fetchUserData(for: results) { response, results, error in  switch response {  case .success:  loginUser(user: results) { response, _, error in  switch response {  case .success:  // finally all of the callbacks are finished  print(&amp;#34;Handle logic here&amp;#34;)  case .fail:  print(error)  }  }  case .fail:  print(error)  }  }  case .fail:  print(error)  } } 上面fetchJSON方法有3个回调，按照PromiseKit链结构可以将上面的方法改造成3个方法，每个方法都返回一个promise对象，然后依次串接起来：
func promiseFetchJSON() -&amp;gt; Promise&amp;lt;String: Any]&amp;gt; {  return Promise&amp;lt;String: Any]&amp;gt; { seal in  fetchJSON(fromURL: &amp;#34;someURL&amp;#34;, completion: { response, results, error in  switch response {  case .success:  seal.fulfill(results)  case .fail:  seal.reject(error)  }  })  } } promise对象初始化时提供了seal对象，这个对象定义了回调完成的方法。接着依次新增promiseFetchUserData和promiseLoginUser：
func promiseFetchUserData(user: String: Any]) -&amp;gt; Promise&amp;lt;User&amp;gt; {  return Promise&amp;lt;User&amp;gt; { seal in  fetchUserData(for: user, completion: { response, results, error in  switch response {  case .success:  seal.fulfill(results)  case .fail:  seal.reject(error)  }  })  } }  func promiseLoginUser(user: User) -&amp;gt; Promise&amp;lt;Bool&amp;gt; {  return Promise&amp;lt;Bool&amp;gt; { seal in  loginUser(user: user, completion: { response, _, error in  switch response {  case .success:  seal.fulfill(true)  case .fail:  seal.reject(error)  }  })  } } 最后，套用基本调用链格式，将各个返回promise对象的异步事件串起来，形成一个完整的调用链：
firstly {  promiseFetchJSON() }.then { json in  promiseFetchUserData(user: json) }.then { user in  promiseLoginUser(user: user) }.ensure {  // something that should happen whatever the outcome }.done { _ in  // all promises are success resolved  // handle final logic here }.catch { _ in  // handle error here } firstly firstly是可选的，它只能放在第一个，是为了代码能更加优雅和整齐，它的block里也需要返回一个一个Promise对象。
then then是接在中间的，可以无限多个then相互连接。顾名思义，就像我们讲故事可以不断地有然后、然后、然后&amp;hellip;then也是要求返回一个Promise对象的，也就是说，任何一个then都可以抛出一个error，中断事件。
ensure 无论调用链在哪里结束，成功或者失败。ensure终将被执行，也可以使用finally来完成相同功能，区别是finally没有返回值并且ensure可以放在任何位置。
firstly {  // ... }.then {  // ... }.done {  // ... }.ensure {  // ... }.catch {  // ... } firstly {  // ... }.done {  // ... }.catch {  // ... }.finally {  //... } finally 执行完then，或者处理完error后，还有一些操作（比如关闭活动指示器），那么就可以放到finally里面去执行。也就是说不管前面是fulfill还是reject，最终都会进入到 finally方法里来。
done done是事件结束的标志，它是必须要有的，只有上面的事件都执行成功时，才会最终执行done。在promise链中，done不返回promise，它用于前面所有的promise都success，表示调用链无错误的运行，而then会返回promise对象：
firstly {  login() }.then { creds in  fetch(avatar: creds.user) }.done { image in  self.imageView = image } catch处理 每个promise都是一个表示单个异步任务的对象。如果任务失败，它的promise将成为rejected。产生rejected promises将跳过所有的then，执行后续所有catch。
firstly {  login() }.then { creds in  //... }.done { image in  //... }.catch {  // 整个 chain 上的错误都到了这里 } recover recover能从异常中拯救任务，可以判定某些错误就忽略，当做正常结果返回，剩下的错误继续抛出异常。
CLLocationManager.requestLocation().recover { error -&amp;gt; Promise&amp;lt;CLLocation&amp;gt; in  guard error == MyError.airplaneMode else {  throw error  }  return .value(CLLocation.savannah) }.done { location in  //… } 参考资料
throw 如果then中需要抛出异常，一种方法是在Promise中调用reject，另一种比较简便的方法就是直接throw：
firstly {  foo() }.then { baz in  bar(baz) }.then { result in  guard !result.isBad else { throw MyError.myIssue }  //…  return doOtherThing() } 如果调用的方法可能会抛出异常，try也会让异常直达catch：
foo().then { baz in  bar(baz) }.then { result in  try doOtherThing() }.catch { error in  // if doOtherThing() throws, we end up here } get 如果想要在异步链路中取值用于其他操作，可以使用get或者tap方法，它们不会影响到原有的链路逻辑。get方法只有前面是fulfill时才会调用。
参考资料
tap 而tap方法是不管前面是完成fulfill还是失败reject，它都会被调用，同时它得到的是Result&amp;lt;T&amp;gt;。它是一个无侵入操作，不会影响事件的任何属性，只是在适当的时机做一些不影响主线的事情，适用于打点：
firstly {  foo() }.tap {  print($0) }.done {  //… }.catch {  //… } 参考资料
when 多个异步操作需要同步的时候，经常会使用group.enter()和group.leave()。在PromoiseKit中使用when来进行多个异步的同步，它提供了并行执行异步方法的能力，并且只在所有异步操作都执行完之后才会执行回调。和其他的 promise链一样，when方法中任一异步操作发生错误，都会进入到下一个catch方法中。
// 并行操作 var result1: ...! var result2: ...! let group = DispatchGroup() group.enter() group.enter() operation1 {  result1 = $0  group.leave() } operation2 {  result2 = $0  group.leave() } group.notify(queue: .main) {  finish(result1, result2) } 使用when之后，简化了多个异步操作的同步，使得代码变得清晰易懂，如下所示：
firstly {  when(fulfilled: operation1(), operation2()) }.done { result1, result2 in  // ... } race race的用法与when一样，只不过when是等所有的异步操作都执行完毕后才执行then的回调。而race只要一个异步操作执行完毕就立即执行then回调，其他没有执行完毕的异步操作仍然会继续执行，而不是停止。
Guarantee Guarantee是Promise的变种、或者补充，其用法和Promise一样，大多情况下二者可以互相替换使用。与Promise状态可以是成功或者失败不同，Guarantee要确保永不失败，因此语法也更简单些，有它就不需要catch来捕获异常了。
after after是一个延迟执行的方法，它就返回了一个Guarantee对象，因为延迟执行是一定不会失败的，所以我们只需要后续接done就行了：
firstly {  after(seconds: 0.1) }.done {  // there is no way to add a `catch` because after cannot fail. } map map是指一次数据的变换，而不是一次事件。例如，我们要把从接口返回的json数据转换成对象，就可以用map，map返回的也是一个对象，但不是Promise。
then方法要求输入一个promise值并返回一个promise，而map是根据先前 promise的结果，然后返回一个新的对象或值类型。
compactMap compactMap与map类似，不过它是返回Optional。例如，我们返回nil，则整个链会产生PMKError.compactMap错误。？？
线程切换 所有then的blocks如果不特别指定，默认都是在主线程执行。PromiseKit切换线程非常的方便和直观，只需要在方法中传入on的线程即可，哪个方法需要指定线程就在那个方法的on传入对应的线程，如下所示：
firstly {  user() }.then(on: DispatchQueue.global()) { user in  URLSession.shared.dataTask(.promise, with: user.imageUrl) }.compactMap(on: DispatchQueue.global()) {  UIImage(data: $0) } 源码 入门 使用 使用 使用
(base) {15:37}[ruby-3.2.2]~/Downloads ➭ xcrun simctl runtime add &amp;#34;~/Downloads/iOS_17_beta_8_Simulator_Runtime.dmg&amp;#34; D: D4797DCF-3EAB-429B-90FD-C670D5E90103 iOS (17.0 - 21A5326a) (Unusable - Other Failure: Error Domain=SimDiskImageErrorDomain Code=5 &amp;#34;Duplicate of 3BBE67A5-32E8-4E10-8E27-DA0EB91CDDEE&amp;#34; UserInfo={NSLocalizedDescription=Duplicate of 3BBE67A5-32E8-4E10-8E27-DA0EB91CDDEE, unusableErrorDetail=}) https://cloud.tencent.com/developer/ask/sof/106238
-force_load
https://juejin.cn/post/6844904018376917000
ImageLoaderMachO::doModInitFunctions https://developer.apple.com/forums/thread/684150
</content>
    </entry>
    
     <entry>
        <title>Ruby 基础</title>
        <url>https://iihui.github.io/post/ruby-base/</url>
        <categories>
          <category>ruby</category>
        </categories>
        <tags>
          <tag>ruby</tag>
        </tags>
        <content type="html">  最近做组件的源码和二进制切换时遇到一些问题，在查资料时发现了cocoapods-imy-bin这个插件，打算以这个插件为基础进行改造，写一个适合自己业务场景的插件。但之前未接触ruby和cocoapods插件开发，这篇文章是一点学习笔记，方便后续查阅。
 调试环境 在Mac上使用RubyMine进行调试ruby程序前需要先安装debase和ruby-debug-ide。按照提示安装时一直失败，提示如下报错信息：
Failed to Install Gems. Following gems were not installed: 	/Applications/RubyMine.app/Contents/plugins/ruby/rb/gems/debase-2.3.2.gem: Error installing debase-2.3.2.gem: 	ERROR: Failed to build gem native extension. current directory: /Users/hui/.gem/ruby/2.6.0/gems/debase-2.3.2/exto /System/Library/Frameworks/Ruby.framework/Versions/2.6/usr/bin/ruby -I /System/Library/Frameworks/Ruby.framework/Versions/2.6/usr/lib/ruby/2.6.0 -r ./siteconf20210116-5397-1jtpnju.rb extconf.rb /System/Library/Frameworks/Ruby.framework/Versions/2.6/usr/lib/ruby/2.6.0/universal-darwin20/rbconfig.rb:229: warning: Insecure world writable dir /usr/local/opt in PATH, mode 040777 checking for vm_core.h... no checking for vm_core.h... no ************************************************************************** No source for ruby-2.6.3-p62 (revision 67580) provided with debase-ruby_core_source gem. Falling back to ruby-2.6.0-p0. ************************************************************************** chec... (show balloon) 查阅资料，发现解决上面报错问题有两种方案，但本质上都是安装隔离的高版本ruby，然后再在RubyMine中安装对应版本的debase以及ruby-debug-ide。
Homebrew 第一种方式是使用Homebrew安装高版本ruby，即用命令brew install ruby。如果安装过程中有如下所示的报错信息：
Error: Could not find an SDK that supports macOS 11.0. You may have have an outdated or incompatible CLT. Homebrew found the following SDKs in the CLT install:  10.14  10.15  Please update CLT or uninstall it if no updates are available. 需要先用brew update命令更新Homebrew本身。然后用brew install ruby或者brew upgrade ruby命令更新ruby。接着，在RubyMine设置中的Ruby SDK and Gems中添加新安装的ruby ：
选择New local，把新版本ruby「目录为/usr/local/Cellar/ruby/3.0.0_1/bin/ruby」加到Ruby SDK and Gems中。然后在调试前更改配置，选择新安装的ruby，如下图所示：
参考资料
RVM 另一种方案是利用rvm安装高版本的ruby，即先用curl -sSL https://get.rvm.io | bash -s stable命令安装rvm，如果看到如下信息，表明安装已经成功：
 Adding rvm PATH line to /Users/hui/.profile /Users/hui/.mkshrc /Users/hui/.bashrc /Users/hui/.zshrc.  Adding rvm loading line to /Users/hui/.profile /Users/hui/.bash_profile /Users/hui/.zlogin. Installation of RVM in /Users/hui/.rvm/ is almost complete:   * To start using RVM you need to run `source /Users/hui/.rvm/scripts/rvm`  in all your open shell windows, in rare cases you need to reopen all shell windows. Thanks for installing RVM 🙏 Please consider donating to our open collective to help us maintain RVM.  👉 Donate: https://opencollective.com/rvm/donate 如果在安装过程中出现curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused这样的错误信息，则说明DNS解析被污染，导致DNS解析过程无法通过域名取得正确的IP地址。
这就需要先到ipaddress上查询raw.githubusercontent.com对应的IP地址。然后借助SwitchHosts修改host文件中raw.githubusercontent.com对应的IP地址，使得请求raw.githubusercontent.com时，直接去请求相应的IP地址，而不再走DNS解析过程。具体操作看这里。
接着根据提示，使用source ~/.rvm/scripts/rvm命令「具体路径根据提示」启用rvm。然后使用rvm install &amp;quot;ruby-2.7.2&amp;quot;命令安装高版本ruby。
安装成功后，使用rvm use 2.7.2命令启用新安装的ruby。因为，用gem安装的工具都处于gem的管理之下，而gem是ruby标准库的一部分，所以切换了ruby版本之后，对应的gem也就随之切换了。那么之前使用gem安装的包，例如cocoapods,xcpretty等都会随之切换，所以之前安装的工具都需要重新安装。
接着在RubyMine中添加ruby 2.7.2，路径为~/.rvm/rubies/ruby-2.7.2/bin/ruby，如下图所示：
接着，点击调试按钮，按照提示安装debase和ruby-debug-ide，如下所示，等待安装完毕，就可以打断点调试ruby程序了：
参考资料
插件调试 准备源码 为了调试cocopods和cocoapods-imy-bin插件，首先需要下载相应的源码。先创建一个目录bundle「名字可以随意」，然后在该目录下使用下面命令获取CocoaPods仓库中tag为1.10.1版本的源码：
git clone -b 1.10.1 https://github.com/CocoaPods/CocoaPods.git 接着在相同目录下，使用下面的命令获取cocoapods-imy-bin插件tag为0.3.1.3的源码：
git clone -b 0.3.1.3 https://github.com/MeetYouDevs/cocoapods-imy-bin.git 接着在同级目下创建Gemfile文件，内容如下所示。在Gemfile文件中，source是下载的源，gem xxx默认是从源仓库下载，当指定path表示指向本地源码：
source &amp;#39;https://rubygems.org&amp;#39;  gem &amp;#39;cocoapods&amp;#39; , :path =&amp;gt; &amp;#34;./CocoaPods&amp;#34; gem &amp;#39;cocoapods-imy-bin&amp;#39; , :path =&amp;gt; &amp;#34;./cocoapods-imy-bin&amp;#34;  group :debug do  gem &amp;#39;ruby-debug-ide&amp;#39;  gem &amp;#39;debase&amp;#39; end 安装依赖 在调试某个gem库的时候，为了不影响已经安装的依赖，在安装依赖的时候，最好是安装到当前文件夹下的执行目录中。对于ruby的依赖包管理工具bundle，如果配置了config文件，就可以在配置文件中声明安装目录。因此，在同级下创建.bundle目录，再在.bundle目录下创建文件config，内容如下：
BUNDLE_PATH: &amp;#34;vendor/bundle&amp;#34; 最后回到Gemfile所在目录，执行bundle install，将会把Gemfile文件中所声明的依赖安装到vendor/bundle目录下。
参考资料
开始调试 使用RubyMine打开Gemfile所在的父目录bundle。然后点击添加配置，在Gem name中输入cocoapods-imy-bin，在Executable name中输入pod，在Arguments中输入bin init。接着，再在bundle目录下创建demo目录，然后在demo创建Podfile，接着在Working directory中选择demo目录，如下所示：
如果在调试的时候，遇到如下类似的报错信息，则说明需要重新安装对应的依赖，使用gem install xxx安装即可。
Uncaught exception: can&amp;#39;t find gem cocoapods (&amp;gt;= 0.a) with executable pod 参考资料 参考资料 参考资料
创建新插件 参考资料 参考资料
双私有源方案 双私有源的方案是将二进制的包上传到服务器中，同时产生一份二进制的podspec，将其发布到二进制私有源中。
在执行pod install后，Cocoapods在解析依赖的过程中，根据podfile.lock指定的版本，构建Specification对象「定义在cocoapod-core中用来描述podspec对象」。
在分析依赖的过程中，会生成一个叫resolver_specs_by_target的hash，包含podfile中配置的所有target以及对应target下所有的pod库信息。整个过程比较复杂，流程结束之后整个依赖关系就确定了。内部会根据前面生成的Milinilo图遍历，将所有的target依赖的pod库构建为ResolverSpecification对象。
通过hook resolver_specs_by_target，遍历所有的podspec，找到做了二进制标记的pod库，对其进行重组，来进行二进制的切换。
# &amp;gt;= 1.4.0 才有 resolver_specs_by_target 以及 ResolverSpecification  # &amp;gt;= 1.5.0 ResolverSpecification 才有 source，供 install 或者其他操作时，输入 source 变更  #  if Pod.match_version?(&amp;#39;~&amp;gt; 1.4&amp;#39;)  old_resolver_specs_by_target = instance_method(:resolver_specs_by_target)  define_method(:resolver_specs_by_target) do  specs_by_target = old_resolver_specs_by_target.bind(self).call   sources_manager = Config.instance.sources_manager  use_source_pods = podfile.use_source_pods   missing_binary_specs = []  specs_by_target.each do |target, rspecs|  # use_binaries 并且 use_source_pods 不包含 本地可过滤  use_binary_rspecs = if podfile.use_binaries? || podfile.use_binaries_selector  rspecs.select do |rspec|  ([rspec.name, rspec.root.name] &amp;amp; use_source_pods).empty? &amp;amp;&amp;amp;  (podfile.use_binaries_selector.nil? || podfile.use_binaries_selector.call(rspec.spec))  end  else  []  end   # Parallel.map(rspecs, in_threads: 8) do |rspec|  specs_by_target[target] = rspecs.map do |rspec|  # 含有 subspecs 的组件暂不处理  # next rspec if rspec.spec.subspec? || rspec.spec.subspecs.any?   # developments 组件采用默认输入的 spec (development pods 的 source 为 nil)  # 可以使 :podspec =&amp;gt; &amp;#34;htts://IMYFoundation.podspec&amp;#34;可以走下去，by slj  # unless rspec.spec.respond_to?(:spec_source) &amp;amp;&amp;amp; rspec.spec.spec_source  # next rspec  # end   # 采用二进制依赖并且不为开发组件  use_binary = use_binary_rspecs.include?(rspec)  source = use_binary ? sources_manager.binary_source : sources_manager.code_source   spec_version = rspec.spec.version  UI.message &amp;#39;cocoapods-imy-bin 插件&amp;#39;  UI.message &amp;#34;- 开始处理 #{rspec.spec.name}#{spec_version}组件.&amp;#34;   begin  # 从新 source 中获取 spec,在bin archive中会异常，因为找不到  specification = source.specification(rspec.root.name, spec_version)  UI.message &amp;#34;#{rspec.root.name}#{spec_version}\r\nspecification =#{specification}&amp;#34;  # 组件是 subspec  if rspec.spec.subspec?  specification = specification.subspec_by_name(rspec.name, false, true)  end  # 这里可能出现分析依赖的 source 和切换后的 source 对应 specification 的 subspec 对应不上  # 造成 subspec_by_name 返回 nil，这个是正常现象  next unless specification   used_by_only = if Pod.match_version?(&amp;#39;~&amp;gt; 1.7&amp;#39;)  rspec.used_by_non_library_targets_only  else  rspec.used_by_tests_only  end  # used_by_only = rspec.respond_to?(:used_by_tests_only) ? rspec.used_by_tests_only : rspec.used_by_non_library_targets_only  # 组装新的 rspec ，替换原 rspec  if use_binary  rspec = if Pod.match_version?(&amp;#39;~&amp;gt; 1.4.0&amp;#39;)  ResolverSpecification.new(specification, used_by_only)  else  ResolverSpecification.new(specification, used_by_only, source)  end  UI.message &amp;#34;组装新的 rspec ，替换原 rspec #{rspec.root.name}#{spec_version}\r\nspecification =#{specification}\r\n#{rspec}&amp;#34;   end   rescue Pod::StandardError =&amp;gt; e  # 没有从新的 source 找到对应版本组件，直接返回原 rspec   # missing_binary_specs &amp;lt;&amp;lt; rspec.spec if use_binary  missing_binary_specs &amp;lt;&amp;lt; rspec.spec  rspec  end   rspec  end.compact  end   if missing_binary_specs.any?  missing_binary_specs.uniq.each do |spec|  UI.message &amp;#34;【#{spec.name}| #{spec.version}】组件无对应二进制版本 , 将采用源码依赖.&amp;#34;  end  Pod::Command::Bin::Archive.missing_binary_specs(missing_binary_specs)   #缓存没有二进制组件到spec文件，local_psec_dir 目录  sources_sepc = []  des_dir = CBin::Config::Builder.instance.local_psec_dir  FileUtils.rm_f(des_dir) if File.exist?des_dir  Dir.mkdir des_dir unless File.exist?des_dir  missing_binary_specs.uniq.each do |spec|  next if spec.name.include?(&amp;#39;/&amp;#39;)   spec_git_res = false  CBin::Config::Builder.instance.ignore_git_list.each do |ignore_git|  spec_git_res = spec.source[:git] &amp;amp;&amp;amp; spec.source[:git].include?(ignore_git)  break if spec_git_res  end  next if spec_git_res   #获取没有制作二进制版本的spec集合  sources_sepc &amp;lt;&amp;lt; spec  unless spec.defined_in_file.nil?  FileUtils.cp(&amp;#34;#{spec.defined_in_file}&amp;#34;, &amp;#34;#{des_dir}&amp;#34;)  end  end  end   specs_by_target  end  end  end 上面是一种类似于OC的Method Swizzling。上面的instance_method临时存储resolver_specs_by_target方法，define_method类似于关键字def，def是定义一个方法，define_method是产生一个新的方法，类似于class_addMethod可以根据参数动态生成方法。
获取到specs_by_target后，取出需要切换的Specification对象的rspec和二进制源source，通过source的specification方法构建二进制Specification对象。
匹配规则 在执行pod install后，关于podspec的匹配规则可以简单的描述为：
 首先取出podfile配置的pod库 取出该pod在源内的所有版本 找到podfile.lock对应库的版本 根据podfile.lock中对应的版本，取出对应的podspec  在pod install命令执行过程中，会有一个解析依赖的阶段。当控制台打印Analyzing dependencies的时候就是在解析内部依赖关系的过程。在解析依赖的过程中有个很重要的方法resolver_specs_by_target,所有的pod库的最终信息都会在这个方法中返回，可以通过hook这个方法，拿到所有pod库的podspec信息，然后将其替换为想要的，即可晚餐切换。
cocoapods/installer.rb  def install!  # 准备环境  prepare  # 解析依赖  resolve_dependencies  # 下载依赖  download_dependencies  # 验证target  validate_targets  # 生成工程文件  if installation_options.skip_pods_project_generation?  show_skip_pods_project_generation_message  else  integrate  end  # 写入依赖  write_lockfiles  # 结束回调  perform_post_install_actions end 基础知识 简介 所有的Ruby文件扩展名都是.rb。在ruby代码中，空白字符一般都会被忽略，而字符串中的空白字符不会被忽略。
Ruby默认使用ASCII来读源码，如果在代码中直接使用中文会报错，需要在文件开头加入# -*- coding: UTF-8 -*-。
在Ruby中单行注释以#开头，直到该行结束。多行注释以=begin开头，以=end结束：
=begin 这是一个多行注释。 可扩展至任意数量的行。 但 =begin 和 =end 只能出现在第一行和最后一行。 =end  # 单行注释 变量 在Ruby中，变量不需要提前声明，为变量赋初值时会自动创建。例如，a = 300 会创建一个名为a的变量，并将300存储在该变量中。
Ruby变量可以容纳任何类型的数据，甚至可以对一个已经定义的变量，更改其数据类型，如下所示：
b = &amp;#34;test&amp;#34; puts b b = 233 puts b 命名 Ruby中变量名的风格偏好：使用小写字母，以下划线连接，不使用缩写，不以数字开头，以内容的含义命名。
作用域 参考资料
字符串 Ruby中字符串分为单引号和双引号字符串，区别在于双引号字符串能够支持更多的转义字符。即在双引号括起来的字符串中，转义字符会被解析。而在单引号括起来的字符串中，转义字符多数不会被解析，基本按照原样输出。
单引号 如果需要在单引号字符串中使用单引号，必须使用转义字符，例如&#39;Won\&#39;t you read O\&#39;Reilly\&#39;s book?&#39;
Ruby中还支持一种采用%q来引导的字符串（单引号引用规则），后面紧跟 !,{,[,|,&amp;lt;的开始定界符，最后以!,},],|,&amp;gt;结尾的定界符，如下所示：
puts %q! test ! puts %q{ test } puts %q[ test ] puts %q| test | puts %q&amp;lt; test &amp;gt; 双引号 在双引号括起来的字符串中，转义字符会被解析。而在单引号括起来的字符串中，转义字符多数不会被解析，基本按照原样输出。
Ruby中还支持一种采用%Q来引导的字符串（双引号引用规则），后面紧跟 !,{,[,|的开始定界符，最后以!,},],|结尾的定界符，如下所示：
name = &amp;#34;hello&amp;#34; puts %Q! test #{name} ! puts %Q{ test #{name}} puts %Q[ test #{name}] puts %Q| test #{name} | puts %Q&amp;lt; test #{name}&amp;gt; heredoc 参考资料
运算符  &amp;lt;= 判断左操作数的值是否小于或者等于右操作数的值，如果是则条件为真。 &amp;gt;= 判断左操作数的值是否大于或者等于右操作数的值，如果是则条件为真。 &amp;lt;=&amp;gt; 联合比较符，如果左边操作数等于右边操做数，则返回0，如果左边操作数大于右边操作数，则返回1，否则返回-1。 and 与 &amp;amp;&amp;amp; 均为和，区别是and优先级比&amp;amp;&amp;amp;低。 or 与 ||均为或，区别是前者的优先级低于后者。 not 与 !均为非，区别是前者的优先级低于后者。 &amp;amp;&amp;amp;的运算法则是左边为false或者nil时，直接返回false或nil，右边将不会被运算；否则返回右边的对象。 ||的运算法则是左边为false或者nil时，返回右边的对象；否则返回左边的对象，右边将不会被运算。  def current_user  @current_user ||= session[:user_id] &amp;amp;&amp;amp; User.find(session[:user_id]) end def current_user  if @current_user  return @current_user  else  if session[:user_id]  @current_user = User.find(session[:user_id])  else  @current_user = nil  end  return @current_user  end end 参考资料 参考资料
跳出作用域 参考资料
模块  模块定义了一个命名空间，相当于一个沙盒，把方法、类和常量组合在一起，在里面的方法，常量，类都不会与其他地方的常量冲突。
 模块中常量的命名和类常量命名相似，以大写字母开头。可以使用模块名称和两个冒号来引用一个常量。
require require类似于C&#43;&#43;中的include或者Java中的import语句。如果程序中想使用已经定义的模块，可以使用require filename来引用。
数组 在Ruby中，索引为-1表示数组的最后一个元素，-2表示倒数第二个元素，依次类推。数组不需要指定大小，当向数组添加元素时，Ruby数组会自动增长。对于数组可以使用count或size或length得到数组长度。
names = Array.new(20)  puts names.count, names.length  names = Array.new(4,&amp;#34;test&amp;#34;)  puts &amp;#34;#{names}&amp;#34;  nums = Array.new(10) { |e| e = e * 2 } puts &amp;#34;#{nums}&amp;#34;  nums = Array(0..9) puts &amp;#34;#{nums}&amp;#34;  nums = Array[11,23,45] puts &amp;#34;#{nums}&amp;#34;  nums = Array.[](88,99,1120,89,457,783) puts &amp;#34;#{nums}&amp;#34;  nums = Array.new nums.append(56) puts &amp;#34;#{nums}&amp;#34; 哈希 Ruby中的哈希类似于其他语言中的字典。可以使用new来创建带默认值的哈希，当访问有默认值的哈希中的键时，如果键或值不存在时，将返回默认值。没有默认值的哈希，访问的键或值不存在时，将返回nil。
months = Hash.new(&amp;#34;month&amp;#34;) puts months[&amp;#34;test&amp;#34;]  months = Hash.new &amp;#34;Test&amp;#34; puts months[&amp;#34;name&amp;#34;] 在Ruby中可以任何对象作为键或者值，甚至可以使用数组：
hash = Hash[&amp;#34;a&amp;#34; =&amp;gt; 12, &amp;#34;b&amp;#34; =&amp;gt; &amp;#34;test&amp;#34;] puts &amp;#34;#{hash[&amp;#39;a&amp;#39;]}#{hash[&amp;#39;b&amp;#39;]}&amp;#34; #12 test  hash[[1,&amp;#34;josn&amp;#34;]] = &amp;#34;json&amp;#34; puts hash #{&amp;#34;a&amp;#34;=&amp;gt;12, &amp;#34;b&amp;#34;=&amp;gt;&amp;#34;test&amp;#34;, [1, &amp;#34;josn&amp;#34;]=&amp;gt;&amp;#34;json&amp;#34;} 类 attr_accessor参考 参考资料
 参考资料 参考资料
</content>
    </entry>
    
     <entry>
        <title>属性包装</title>
        <url>https://iihui.github.io/post/ios-propertywrapper/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  属性包装器propertyWrapper的作用对象是属性，它的思想是只可以通过wrappedValue的get和set方法来访问属性，这样就可以通过get和set方法来对属性进行包装，提供特定功能的属性。属性包装器是一种通用结构，它封装了wrappedValue属性的读写访问，并可以为其添加其他行为，也就是如果需要限制属性值，向get和set方法添加限制逻辑即可。
 基本使用 属性包装器propertyWrapper是Swift 5.1引入，使用时必须满足两个条件。首先必须使用@propertyWrapper声明。其次，必须具有非静态的wrapppedValue属性。
@propertyWrapper struct SomeWrapper {  var wrappedValue: Int  var someValue: Double  init() {  self.wrappedValue = 100  self.someValue = 12.3  }  init(wrappedValue: Int) {  self.wrappedValue = wrappedValue  self.someValue = 45.6  }  init(wrappedValue value: Int, custom: Double) {  self.wrappedValue = value  self.someValue = custom  } }  struct SomeStruct {  // 使用 init() 进行初始化  @SomeWrapper var a: Int   // 使用 init(wrappedValue:) 进行初始化  @SomeWrapper var b = 10   // 两个都是使用 init(wrappedValue:custom:) 进行初始化  @SomeWrapper(custom: 98.7) var c = 30  @SomeWrapper(wrappedValue: 30, custom: 98.7) var d }  @propertyWrapper struct Wrapper&amp;lt;T&amp;gt; {  var wrappedValue: T }  struct TestWrapper {  @Wrapper var x: Int  @Wrapper var y = 12  @Wrapper(wrappedValue: 34) var z }  func test() {  let test1 = TestWrapper(x: 100)  print(test1.x, test1.y, test1.z)   let test2 = TestWrapper(x: 34, y: 45, z: Wrapper(wrappedValue: 89))  print(test2.x,test2.y,test2.z) } 在属性包装器中，也可以提供额外的功能，但如果要使用这些额外的功能，则需要访问包装器本身，而不是其封装的属性值wrappedValue。如果想要访问包装器本身，而不是包装的属性值，则需要在属性名称之前添加下划线。下面代码中属性包装器Wrapper提供了的函数foo不能直接访问，需要利用包装器本身来访问，即在包装属性前加下划线：
@propertyWrapper struct Wrapper&amp;lt;T&amp;gt; {  var wrappedValue: T   func foo(){  print(&amp;#34;foo&amp;#34;)  } }  struct TestWrapper {  @Wrapper var x: Int  @Wrapper var y = 12  @Wrapper(wrappedValue: 34) var z   func foo(){  _x.foo() //_x是属性包装器本身，不能通过x.foo()来访问foo  } }  func test() {  let test1 = TestWrapper(x: 100)  print(test1.x, test1.y, test1.z)   let test2 = TestWrapper(x: 34, y: 45, z: Wrapper(wrappedValue: 89))  print(test2.x,test2.y,test2.z)   test1.foo()  test2.foo() } 上面的_x是属性包装器本身，它是private级别的。因此，从外部使用它会产生编译错误。属性包装器还可以通过定义投影值来暴露其他功能。投影值的名称与包装值相同，只是它以$开头。投影值使用projectedValue定义，可以返回任何类型的值作为投影值：
@propertyWrapper struct Wrapper&amp;lt;T&amp;gt; {  var wrappedValue: T  var projectedValue: Wrapper&amp;lt;T&amp;gt; { return self }   func foo(){  print(&amp;#34;foo&amp;#34;)  } }  struct TestWrapper {  @Wrapper var x: Int  @Wrapper var y = 12  @Wrapper(wrappedValue: 34) var z   func foo(){  _x.foo()  $x.foo()  //不能使用x.foo()，因为x代表wrappedValue  print(x,_x,$x) //12 Wrapper&amp;lt;Int&amp;gt;(wrappedValue: 12) Wrapper&amp;lt;Int&amp;gt;(wrappedValue: 12)  } }  func test() {  let test1 = TestWrapper(x: 100)  print(test1.x, test1.y, test1.z)   let test2 = TestWrapper(x: 34, y: 45, z: Wrapper(wrappedValue: 89))  print(test2.x,test2.y,test2.z)   test1.foo()  test2.foo()   test1.$x.foo()  test2.$x.foo() } 在上面的例子中投影值返回的是包装器本身，也就是投影成自己。投影值可以返回任何类型的值，在下面的例子中，投影值是布尔类型：
@propertyWrapper struct SmallNumber {  private var number: Int  var projectedValue: Bool   init() {  self.number = 0  self.projectedValue = false  }   var wrappedValue: Int {  get {  return number  }  set {  if newValue &amp;gt; 12 {  number = 12  projectedValue = true  } else {  number = newValue  projectedValue = false  }  }  } }  struct SomeStruct {  @SmallNumber var someNum: Int }  func testSmall() {  var small = SomeStruct()  small.someNum = 3  print(small.$someNum) // false  small.someNum = 70  print(small.$someNum) // true } 参考资料 参考资料
减少重复代码 使用属性包装器可以减少重复代码。我们通常使用UserDefaults来保存引导页是否已经展示过，如果没有@propertyWrapper时，可能会使用如下代码实现：
extension UserDefaults {  public enum Keys {  static let hasDisplayedGuideView = &amp;#34;has_Displayed_guide_view&amp;#34;  }   var hasDisplayedGuideView: Bool {  get {  return bool(forKey: Keys.hasDisplayedGuideView)  }  set {  set(newValue, forKey: Keys.hasDisplayedGuideView)  }  } }  func showGuide() {  let hasDisplayed = UserDefaults.standard.hasDisplayedGuideView   if hasDisplayed {  // 显示引导页  UserDefaults.standard.hasDisplayedGuideView = false  } } 如果后续需要再添加另一个引导项，则需要重复上面的代码。如果使用@propertyWrapper，可以减少上面的重复代码，如下所示：
@propertyWrapper struct UserDefault&amp;lt;T&amp;gt; {  let key: String  let defaultValue: T   init(key: String, defaultValue: T) {  self.key = key  self.defaultValue = defaultValue  }   var wrappedValue: T {  get {  return UserDefaults.standard.object(forKey: key) as? T ?? defaultValue  }  set {  UserDefaults.standard.set(newValue, forKey: key)  }  } }  enum UserDefaultConfig {  @UserDefault(key: &amp;#34;speech_guide&amp;#34;, defaultValue: false) static var speechGuide: Bool  @UserDefault(key: &amp;#34;note_guide&amp;#34;, defaultValue: false) static var noteGuide: Bool }  func testGuide() {  UserDefaultConfig.speechGuide = false  UserDefaultConfig.noteGuide = true } 因为UserDefaults本身只能存储基本类型，所以上面的包装的属性UserDefault，也只适用于基本类型都。对于非基本类型，就要借助于Codable才能保存：
/// for codable @available(swift 5.1) @propertyWrapper struct UserDefaultJsonWrapper&amp;lt;T: Codable&amp;gt; {  var key: String  var defaultValue: T  var wrappedValue: T {  get {  guard let jsonString = UserDefaults.standard.string(forKey: key) else {  return defaultValue  }  guard let jsonData = jsonString.data(using: .utf8) else {  return defaultValue  }  guard let value = try? JSONDecoder().decode(T.self, from: jsonData) else {  return defaultValue  }  return value  }  set {  let encoder = JSONEncoder()  guard let jsonData = try? encoder.encode(newValue) else {  return  }  let jsonString = String(bytes: jsonData, encoding: .utf8)  UserDefaults.standard.set(jsonString, forKey: key)  }  }   init(key: String, defaultValue: T) {  self.key = key  self.defaultValue = defaultValue  } } /// 全局配置的属性包装，wrappedValue为可选值 @propertyWrapper public struct CodableGlobalConfigProperty&amp;lt;T: Codable&amp;gt; {   private var key: UserDefaultsKey   public init(key: UserDefaultsKey) {  self.key = key  }   public var wrappedValue: T? {  get {  if let data = UserDefaultsManager.standard.value(forKey: key) as? Data, let model = try? JSONDecoder().decode(T.self, from: data) {  return model  } else {  return nil  }  }  set {  if let value = newValue {  // 此处不可与上面合并,因为要确保newValue为nil时删除key对应的值  if let jsonData = try? JSONEncoder().encode(value) {  UserDefaultsManager.standard.set(value: jsonData, forKey: key)  }  } else {  UserDefaultsManager.standard.remove(forKey: key)  }  }  } } 参考资料
原子属性包装器 静态缓存类相关变量（类变量或者结构体中含有类变量），数组，字典均是多线程不安全的，为了解决线程安全问题，可以使用属性包装器定义原子属性：
@propertyWrapper public struct Atomic&amp;lt;Value&amp;gt; {   private var value: Value  private var lock: os_unfair_lock //自旋锁   public init(wrappedValue value: Value) {  self.value = value  lock = os_unfair_lock.init()  }   public var wrappedValue: Value {  mutating get {  return read()  }  set {  write(newValue: newValue)  }  }   mutating func read() -&amp;gt; Value {  os_unfair_lock_lock(&amp;amp;self.lock)  defer {  os_unfair_lock_unlock(&amp;amp;self.lock)  }  return value  }   mutating func write(newValue: Value) {  os_unfair_lock_lock(&amp;amp;self.lock)  defer {  os_unfair_lock_unlock(&amp;amp;self.lock)  }  value = newValue  } } 参考资料
public class UserConfigService {  private var pid: String  private let split: String = &amp;#34;...&amp;#34;   public init(pid: String) {  self.pid = pid  // 取巧的方式将id传递给属性包装器  _loginRestriction.setId(id: self.pid)  } } /// 用户个性化配置的属性包装，需带默认值 @propertyWrapper public struct UserConfigProperty&amp;lt;Value&amp;gt; {  /// 自定UserDefaultsKey，详见其定义  private var key: UserDefaultsKey  /// 默认值  private var defaultValue: Value  /// 用户主键  private var id: String   public init(key: UserDefaultsKey, id: String, defaultValue: Value) {  self.key = key  self.defaultValue = defaultValue  self.id = id  }   public init(key: UserDefaultsKey, defaultValue: Value) {  self.key = key  self.defaultValue = defaultValue  // 因为属性包装器会在init方法之前执行，导致id无法初始化，因此先给id一个初始空值  self.id = &amp;#34;&amp;#34;  }   /// 因为属性包装器会在init方法之前执行，所以初始给了一个空值，此函数是为了修改真正的id  /// - Parameter id: id  public mutating func setId(id:String) {  self.id = id  }   public var wrappedValue: Value {  get {  return (UserDefaultsManager.standard.value(forKey: key, forId: id) as? Value) ?? defaultValue  }  set {  UserDefaultsManager.standard.set(value: newValue, forKey: key, forId: self.id)  }  } } 测试代码 在工程中ConfigDataService文件中相关的缓存变量都是数组，例如static var desktopConfigItems: [MoConfigItemModel] = []是线程不安全的，不使用原子属性包装器下面测试代码会闪退：
static func testDemo(){  let group = DispatchGroup()  let models:[MoConfigItemModel] = [MoConfigItemModel(),MoConfigItemModel()]  for _ in 0..&amp;lt;2000 {  let delaySet = TimeInterval(arc4random() % 10);  group.enter()  DispatchQueue.global().asyncAfter(deadline: .now() &#43; delaySet) {  self.desktopConfigItems = models  group.leave()  }   let delaySetNil = TimeInterval(arc4random() % 10);  group.enter()  DispatchQueue.global().asyncAfter(deadline: .now() &#43; delaySetNil) {  self.desktopConfigItems.append(MoConfigItemModel())  group.leave()  }   let delayGet = TimeInterval(arc4random() % 10)  group.enter()  DispatchQueue.global().asyncAfter(deadline: .now() &#43; delayGet) {  let _ = self.allConfigItems  group.leave()  }  }   let success = group.wait(timeout: .now() &#43; 12)  if success == .success {  print(&amp;#34;test&amp;#34;)  }  } </content>
    </entry>
    
     <entry>
        <title>调试</title>
        <url>https://iihui.github.io/post/ios-debug/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> LLDB LLDB是一个庞大的工具,内置了许多有用的命令。
命令语法结构 &amp;lt;command&amp;gt; [&amp;lt;subcommand&amp;gt; [&amp;lt;subcommand&amp;gt;...]] &amp;lt;action&amp;gt; [-options [option-value]] [argument [argument...]] 其中：
 command和subcommand为LLDB调试命令的名称，命令和子命令按照层级结构来排列：一个命令对象为跟随其的子命令对象创建一个上下文，子命令又为其子命令创建一个上下文，依此类推。 action  上面的这些元素之间通过空格来分割，如果某一元素自身含有空格，则可以使用双引用。而如果元素中又包含双引号，则可以使用反斜杠；或者元素使用单引号。如下所示：
(lldb) command [subcommand] -option &amp;#34;some \&amp;#34;quoted\&amp;#34; string&amp;#34; (lldb) command [subcommand] -option &amp;#39;some &amp;#34;quoted&amp;#34; string&amp;#39; 获取变量值和状态 使用expression和e可以获取和改变变量的值
获取整个APP的状态和指定语言的命令  bugreport:生成当前应用状态的完整报告 frame:获取当前线程的当前栈帧的概述  参考资料
不能安装 无法安装 因为App是企业发布，偶尔有人反映安装不了，最近有人反映在iPhone8 Plus上遇到「无法安装XXX，请稍候再试」的情况，如下图所示： 这篇文章给出如下的建议：
安装到最后变灰了 安装到一半变灰了，可以先清除Safari浏览器，然后再重启，再通过ideviceinstaller -i命令安装：
参考资料
手机发烫 手机发烫，调试时看到总是看到字体日志和safe_M_setObjectforKeyedSubscript-------object is nil相关信息，如下图红色框所示：
CoreText note: Client requested name &amp;#34;.SFUI-Regular&amp;#34;, it will get TimesNewRomanPSMT rather than the intended font. All system UI font access should be through proper APIs such as CTFontCreateUIFontForLanguage() or &#43;[UIFont systemFontOfSize:]. 根据提示，设置CTFontLogSystemFontNameRequest符号端点，可以查看相关信息。
开启网络服务 Start a Web Server python2 -m SimpleHTTPServer 50524 python3 -m http.server --cgi 50524 参考资料
mospecs is not clean The repo `cmbchina-mospecs` at `../../../../.cocoapods/repos/cmbchina-mospecs` is not clean 需要先删除mospecs然后添加mospecs。
微信分享 iOS-Universal Link 接入与微信分享的配置 微信分享的配置
Safari调试  在Mac上调试iOS WebView既需要在Mac上的Safari浏览器上开启开发者选项，也需要在iOS设备上开启Web检查功能。
 开启Mac的开发者菜单 首先需要开启Mac上Safari浏览器的显示开发者菜单选项。即先进入到Safari浏览器中的设置，然后点击最右边的高级，再勾选在菜单栏中显示开发菜单，如下图所示：
开启iOS上Safari上的Web检查 然后开启iOS设备中Safari里的网页检查器，设置路径为：设置--&amp;gt;Safari-&amp;gt;高级-&amp;gt;网页检查器：
开始调试 将手机连接到Mac上，打开WebView页面，然后在Mac上的Safari浏览器中的开发者菜单中找到对应的iOS设备：
 参考资料
</content>
    </entry>
    
     <entry>
        <title>KSCrash</title>
        <url>https://iihui.github.io/post/ios-kscrash/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  KSCrash是崩溃日志收集框架，总共分为三个部分，Crash Recording，Crash Reporting以及Installation。其中Installation用来启动KSCrash，并且指定Crash收集方式。Crash收集方式包括：邮件KSCrashInstallationEmail，向自定义服务器发送KSCrashInstallationStandard，隐式收集KSCrashInstallationHockey和KSCrashInstallationQuincy，在控制台「Debug」输出崩溃日志KSCrashInstallationConsole。
 邮件发送崩溃日志 之前项目中使用PLCrashReporter收集崩溃日志，但是相比于KSCrash，它对于导致崩溃的原因以及第三方framework的符号化相对较弱。下面是KSCrash使用邮件方式来收集崩溃日志：
import KSCrash class CrashReporterService {  static var shared = CrashReporterService()  private let emailAddress = &amp;#34;xiaohui.sysu@qq.com&amp;#34;  func startCrashReport() {  let installation = KSCrashInstallationEmail.sharedInstance()  installation?.recipients = [emailAddress]  installation?.subject = &amp;#34;Crash Report&amp;#34;  installation?.message = &amp;#34;This is a crash report&amp;#34;  installation?.filenameFmt = &amp;#34;crash-report-%d.crash.gz&amp;#34;  installation?.reportStyle = KSCrashEmailReportStyleApple  // KSCrash.sharedInstance()?.deleteBehaviorAfterSendAll = KSCDeleteOnSucess  installation?.addConditionalAlert(withTitle: &amp;#34;Crash Detected&amp;#34;,  message: &amp;#34;The app crashed last time it was launched. Send a crash report?&amp;#34;,  yesAnswer: &amp;#34;Sure!&amp;#34;,  noAnswer: &amp;#34;No thanks&amp;#34;)  installation?.install()  installation?.sendAllReports { (reports, completed, error) -&amp;gt; Void in  if completed, let count = reports?.count {  print(&amp;#34;Sent \(count)reports&amp;#34;)  } else if let msg = error?.localizedDescription {  print(&amp;#34;Failed to send reports: \(msg)&amp;#34;)  }  }  } } 参考资料 参考资料 参考资料
行号为0 如果源文件的行号为0，则表示回溯堆栈未能映射到原始代码中的特定代码行。这是因为编译器通过内联函数等方式对代码进行了优化，而崩溃时执行的代码与原始代码中的确切行并不对应，在这种情况下，只能利用函数名这个线索。
修复崩溃 NSPlaceholderArray *** -[__NSPlaceholderArray initWithCapacity:]: capacity (18446744073709549746) is ridiculous 出现上面闪退，说明在初始化的时候，使用的预设值太大。可能是数组初始化时预设的容量过大，也可能是数组初始化时容量为负数。而在这个项目中，是因为设置tableView的frame时用到了CGFloat.greatestFiniteMagnitude。
参考资料 参考资料 参考资料
NSCameraUsageDescription 如果在使用相机前没有给定权限，就会报The app’s Info.plist must contain an NSCameraUsageDescription key with a string value explaining to the user how the app uses this data.。此时，应该在工程的info.plist文件中添加Privacy Camera Usage Description，并给它一个值，如下图所示：
![-c](https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E6%95%99%E5%AE%A4/the-apps-info-plist-must-contain-an-nscamerausagedescription-key-9d7e032cf1f4) import PLCrashReporter  // Enable PLCrashReporter PLCrashReporter.shared().enable()  // Check if the app crashed in the foreground or background func checkCrashStatus() {  let crashData = PLCrashReporter.shared().loadPendingCrashReportData()   if let crashData = crashData {  let crashReport = try? PLCrashReport(data: crashData)   if let crashReport = crashReport {  if crashReport.hasProcessInfo {  let processInfo = crashReport.processInfo   if processInfo.processType == .foreground {  // Crash occurred in the foreground  print(&amp;#34;Crash occurred in the foreground&amp;#34;)  } else if processInfo.processType == .background {  // Crash occurred in the background  print(&amp;#34;Crash occurred in the background&amp;#34;)  }  }  }   // Purge the crash report  PLCrashReporter.shared().purgePendingCrashReport()  } }  // Call the function to check crash status checkCrashStatus() import PLCrashReporter  // Enable PLCrashReporter PLCrashReporter.shared().enable()  // Check if the app crashed in the foreground or background func checkCrashStatus() {  let crashData = PLCrashReporter.shared().loadPendingCrashReportData()   if let crashData = crashData {  let crashReport = try? PLCrashReport(data: crashData)   if let crashReport = crashReport {  if crashReport.signalInfo?.name == SIGABRT {  // Crash occurred in the foreground  print(&amp;#34;Crash occurred in the foreground&amp;#34;)  } else {  // Crash occurred in the background  print(&amp;#34;Crash occurred in the background&amp;#34;)  }  }   // Purge the crash report  PLCrashReporter.shared().purgePendingCrashReport()  } }  // Call the function to check crash status checkCrashStatus() </content>
    </entry>
    
     <entry>
        <title>Shell 常用命令</title>
        <url>https://iihui.github.io/post/shell-base/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  本文记录工作中用的shell命令，以便下次使用的时候查阅。
 软链接 创建 ln ~/.cocoapods/repos-art/CocoaPods-cmb ~/.cocoapods/repos 删除 unlink cocoaPods-github </content>
    </entry>
    
     <entry>
        <title>Python 基础</title>
        <url>https://iihui.github.io/post/python-base/</url>
        <categories>
          <category>python</category>
        </categories>
        <tags>
          <tag>python</tag>
        </tags>
        <content type="html"> 字符串 在python中，用引号括起来的都是字符串，其中的引号可以是单引号，也可以是双引号。这种灵活性让我们能够在字符串中包含引号或单引号：
print(&amp;#39;This is a string&amp;#39;) print(&amp;#34;This is also a string&amp;#34;) print(&amp;#39;I told my friend, &amp;#34;python is my favorite language&amp;#34;&amp;#39;) print(&amp;#34;The language &amp;#39;Python&amp;#39; is named after Monty Python, not the snake&amp;#34;)  This is a string This is also a string I told my friend, &amp;#34;python is my favorite language&amp;#34; The language &amp;#39;Python&amp;#39; is named after Monty Python, not the snake 对于字符串，title()函数以首字母大写的方式显示每个单词；upper()函数可以将字符串全部转为大写；lower()函数可以将字符串全部转为小写。
name = &amp;#39;ada lovelace&amp;#39; print(name.title()) print(name.upper()) print(name.lower())  Ada Lovelace ADA LOVELACE ada lovelace 空白符泛指任何非打印字符，如空格、制表符和换行符。lstrip()函数删除字符串前面的空白符；rstrip()函数删除字符串最后的空白符；而strip()函数删除字符串开头和结尾的空白符。
name = &amp;#39; python &amp;#39; print(name.lstrip()) print(name.rstrip()) print(name.strip())  python  python python 如果要在字符串中插入变量的值，可以在字符串的前引号加上字母f，然后将要插入的变量放在花括号中，这种字符串称为f字符串，其中f是format的缩写：
first_name = &amp;#39;ada&amp;#39; last_name = &amp;#39;lovelace&amp;#39; full_name = f&amp;#39;{first_name}{last_name}&amp;#39; print(f&amp;#34;Hello, {full_name.title()}&amp;#34;)  Hello, Ada Lovelace 数值 Python将所有带小数点的数视为浮点数。实际上，受限于计算机内部表示数的方式，很难精确表示浮点数。所以，浮点数运算后结果包含小数位数可能是不确定的：
print(0.2 &#43; 0.1) print(3 * 0.1)  0.30000000000000004 0.30000000000000004 将任意两个数相除时，结果总是浮点数，即使这两个数都是整数并且能整除。在其它任何运算中，如果一个操作数是整数，另一个操作是浮点数，结果也是浮点数：
print(4 / 2) print(1 &#43; 2.0) print(2 * 3.0)  2.0 3.0 6.0 书写很大的数字时，可使用下划线将这个数字（包括整数和小数部分）分组，使其更清晰易读。打印这种使用下划线的数时，Python不会打印其中的下划线。将数字分组时，每组位数没有硬性规定，一般是3位：
universe_age = 14_000_000_000 print(universe_age) universe_age = 14_0000_000_00 print(universe_age)  14000000000 14000000000  universe_age = 14_000_000_000.0000_00000 print(universe_age) universe_age = 14_000_000_000.0000_000_000 print(universe_age)  14000000000.0 14000000000.0 print 在Python2中print不是一个函数，而在Python3中是一个函数，因此**in括号必不可少**。在Python2中可以把变量用括号括起来，所以也可以像Python3一样使用print()，但与Python3的函数调用完全不一样。
在Python3中能使用help(print)来查看文档，但Python2中不行。此外，Python3中使用print能更方便的重定向，而Python2中要使用类似C&#43;&#43;风格的重定向：
with open(&amp;#39;print.txt&amp;#39;, &amp;#39;w&amp;#39;) as f:  print(&amp;#39;hello, python!&amp;#39;, file = f) with open(&amp;#39;print.txt&amp;#39;, &amp;#39;w&amp;#39;) as f:  print &amp;gt;&amp;gt; f, &amp;#39;hello, python!&amp;#39; 参考资料。
列表 列表由一系列按特定顺序排列的元素组成。在Python中，用方括号[]来表示列表，并用逗号来分隔其中的元素。第一个列表元素索引为0，最后一个元素索引为-1:
bicycles = [&amp;#39;trek&amp;#39;, &amp;#39;cannondale&amp;#39;, &amp;#39;redline&amp;#39;, &amp;#39;specialized&amp;#39;] print(bicycles[0],bicycles[-1])  trek specialized 负数索引 将列表索引指定为-1，可返回最后一个列表元素，这种方式也适用于其它负数索引。例如，索引-2返回倒数第二个列表元素， 索引-3返回倒数第三个列表元素，以此类推：
banned_users = [&amp;#39;andrew&amp;#39;, &amp;#39;carolina&amp;#39;, &amp;#39;david&amp;#39;] print(banned_users[-1], banned_users[-2])  david carolina 增删改 在列表末尾添加元素可以使用append函数，如果要在指定位置插入元素可以使用insert函数。例如，motorcycles.insert(0, &#39;ducati&#39;)是在索引0处添加元素ducati：
motorcycles = [] motorcycles.append(&amp;#39;test&amp;#39;) motorcycles.insert(0, &amp;#39;ducati&amp;#39;)  print(motorcycles) [&amp;#39;ducati&amp;#39;, &amp;#39;test&amp;#39;] 如果事先知道待删除元素在列表中的索引，可以使用del语句删除列表中某个位置的元素。例如，del motorcycles[0]可以删除列表中的第一个元素。
print(motorcycles) del motorcycles[0] print(motorcycles)  [&amp;#39;ducati&amp;#39;, &amp;#39;test&amp;#39;] [&amp;#39;test&amp;#39;] 如果想要删除列表中的元素并获取这个值可以使用pop函数。pop将列表视为一个栈，删除列表末尾的元素相当于弹出栈顶元素。不带参数的pop()函数可删除列表末尾的元素，并能返回末尾元素的值。如果要删除列表中任何位置的元素，可以在圆括号中指定要删除元素的索引：
motorcycles = [] motorcycles.append(&amp;#39;test&amp;#39;) motorcycles.insert(0, &amp;#39;ducati&amp;#39;) motorcycles.insert(0, &amp;#39;all&amp;#39;) print(motorcycles)  [&amp;#39;all&amp;#39;, &amp;#39;ducati&amp;#39;, &amp;#39;test&amp;#39;]   # 删除栈顶元素，也就是数组最后一个 last = motorcycles.pop() print(motorcycles) motorcycles.pop(1) print(motorcycles)  [&amp;#39;all&amp;#39;, &amp;#39;ducati&amp;#39;] [&amp;#39;all&amp;#39;] 如果不知道要删除元素在列表中的索引，可以使用列表的remove函数，但是它只会删除第一个指定的值，如果要删除全部相同的元素，需要借助循环：
arr = [&amp;#39;1&amp;#39;, &amp;#39;2&amp;#39;, &amp;#39;3&amp;#39;, &amp;#39;4&amp;#39;, &amp;#39;5&amp;#39;, &amp;#39;3&amp;#39;, &amp;#39;9&amp;#39;, &amp;#39;3&amp;#39;] print(arr) arr.remove(&amp;#39;3&amp;#39;) print(arr)  [&amp;#39;1&amp;#39;, &amp;#39;2&amp;#39;, &amp;#39;3&amp;#39;, &amp;#39;4&amp;#39;, &amp;#39;5&amp;#39;, &amp;#39;3&amp;#39;, &amp;#39;9&amp;#39;, &amp;#39;3&amp;#39;] [&amp;#39;1&amp;#39;, &amp;#39;2&amp;#39;, &amp;#39;4&amp;#39;, &amp;#39;5&amp;#39;, &amp;#39;3&amp;#39;, &amp;#39;9&amp;#39;, &amp;#39;3&amp;#39;]  arr = [&amp;#39;1&amp;#39;, &amp;#39;2&amp;#39;, &amp;#39;9&amp;#39;, &amp;#39;4&amp;#39;, &amp;#39;5&amp;#39;, &amp;#39;3&amp;#39;, &amp;#39;9&amp;#39;, &amp;#39;9&amp;#39;] while &amp;#39;9&amp;#39; in arr:  arr.remove(&amp;#39;9&amp;#39;) print(arr)  [&amp;#39;1&amp;#39;, &amp;#39;2&amp;#39;, &amp;#39;4&amp;#39;, &amp;#39;5&amp;#39;, &amp;#39;3&amp;#39;] 排序 列表的sort函数会**永久性地**修改列表元素的排列顺序。如果要保留列表原来的排列顺序，同时又需要以特定的顺序呈现它们，可以使用sorted函数：
cars = [&amp;#39;bmw&amp;#39;, &amp;#39;audi&amp;#39;, &amp;#39;toyota&amp;#39;, &amp;#39;subaru&amp;#39;] print(cars) cars.sort() print(cars)  [&amp;#39;bmw&amp;#39;, &amp;#39;audi&amp;#39;, &amp;#39;toyota&amp;#39;, &amp;#39;subaru&amp;#39;] [&amp;#39;audi&amp;#39;, &amp;#39;bmw&amp;#39;, &amp;#39;subaru&amp;#39;, &amp;#39;toyota&amp;#39;]   arr = [&amp;#39;11&amp;#39;, &amp;#39;21&amp;#39;, &amp;#39;3&amp;#39;, &amp;#39;4&amp;#39;, &amp;#39;5&amp;#39;, &amp;#39;3&amp;#39;, &amp;#39;9&amp;#39;, &amp;#39;3&amp;#39;] print(sorted(arr)) print(arr)  [&amp;#39;11&amp;#39;, &amp;#39;21&amp;#39;, &amp;#39;3&amp;#39;, &amp;#39;3&amp;#39;, &amp;#39;3&amp;#39;, &amp;#39;4&amp;#39;, &amp;#39;5&amp;#39;, &amp;#39;9&amp;#39;] [&amp;#39;11&amp;#39;, &amp;#39;21&amp;#39;, &amp;#39;3&amp;#39;, &amp;#39;4&amp;#39;, &amp;#39;5&amp;#39;, &amp;#39;3&amp;#39;, &amp;#39;9&amp;#39;, &amp;#39;3&amp;#39;]  lists = [&amp;#34;test&amp;#34;, &amp;#34;wan&amp;#34;, &amp;#34;deng&amp;#34;] print(sorted(lists, reverse=True)) print(lists)  [&amp;#39;wan&amp;#39;, &amp;#39;test&amp;#39;, &amp;#39;deng&amp;#39;] [&amp;#39;test&amp;#39;, &amp;#39;wan&amp;#39;, &amp;#39;deng&amp;#39;] 列表函数reverse不是按字母逆序顺序排列列表元素，只是反转列表元素的排列顺序，并且它是永久地修改列表元素的顺序：
cars = [&amp;#39;bmw&amp;#39;, &amp;#39;audi&amp;#39;, &amp;#39;toyota&amp;#39;, &amp;#39;subaru&amp;#39;] print(cars) cars.reverse() print(cars)  [&amp;#39;bmw&amp;#39;, &amp;#39;audi&amp;#39;, &amp;#39;toyota&amp;#39;, &amp;#39;subaru&amp;#39;] [&amp;#39;subaru&amp;#39;, &amp;#39;toyota&amp;#39;, &amp;#39;audi&amp;#39;, &amp;#39;bmw&amp;#39;] 长度 访问列表中元素，若索引超过了列表长度，则会出现编译错误。访问列表最后一个元素时，可以使用索引-1。但当列表为空时，这种访问最后一个元素的方式会导致错误。函数len可以获取列表的长度，因此可以先使用函数len来确定列表长度。
lists = [&amp;#34;test&amp;#34;, &amp;#34;wan&amp;#34;, &amp;#34;deng&amp;#34;] print(lists[3])  IndexError: list index out of range  motorcycles = [] print(motorcycles[-1])  IndexError: list index out of range  motorcycles = []  if len(motorcycles) &amp;gt; 0:  print(motorcycles[-1]) 遍历 可以使用for循环遍历列表。在for循环后面，没有缩进的代码都只执行一次，不会被重复执行。Python根据缩进来判断代码行与前一个代码行的关系，对于位于for语句后面且属于循环组成部分的代码行，一定要缩进：
arr = [&amp;#39;11&amp;#39;, &amp;#39;21&amp;#39;, &amp;#39;3&amp;#39;, &amp;#39;4&amp;#39;, &amp;#39;5&amp;#39;, &amp;#39;3&amp;#39;, &amp;#39;9&amp;#39;, &amp;#39;3&amp;#39;] for item in arr:  print(item)  11 21 3 4 5 3 9 3  magicians = [&amp;#39;alice&amp;#39;, &amp;#39;david&amp;#39;, &amp;#39;carolina&amp;#39;] for magician in magicians:  print(f&amp;#34;{magician.title()},that was a great trick!&amp;#34;)  print(f&amp;#34;I can&amp;#39;t wait to see you next trick, {magician.title()}\n&amp;#34;)  print(&amp;#39;Thank you,every one.&amp;#39;)  Alice,that was a great trick! I can&amp;#39;t wait to see you next trick, Alice  David,that was a great trick! I can&amp;#39;t wait to see you next trick, David  Carolina,that was a great trick! I can&amp;#39;t wait to see you next trick, Carolina  Thank you,every one.   for item in arr: print(item) #for循环中没有缩进会出现编译错误  IndentationError: expected an indented block 如果不小心缩进了无需缩进的代码，Python编译器会指出这一点，出现IndentationError: unexpected indent错误。下面的代码中，print函数调用是无须缩进的，因为它并非循环的组成部分：
message = &amp;#39;Hello Python world!&amp;#39;  print(message)  IndentationError: unexpected indent range 使用range函数可以生成**半闭半开区间的数字**。例如，range(1,5)等同于数学上的[1,5)，使用range时，也可以同时指定步长：
for value in range(1,5):  print(value)  1 2 3 4  print(range(1, 7)) #打印的结果为range(1, 7)  range(1, 7)  even_numbers = list(range(2,11,2)) print(even_numbers)  [2, 4, 6, 8, 10] 可使list函数将range()结果转换为数字列表：
numbers = list(range(1, 6)) print(numbers)  [1, 2, 3, 4, 5] 可以将for循环和创建新元素的代码合并成一行：
squares = [value ** 2 for value in range(1, 11)] print(squares)  [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 切片 如果要创建切片，就需要指定第一个元素和最后一个元素的索引区间。在切片中，索引区间也是半闭半开的。如果切片区间没有指定第一个索引，则默认从列表开头开始。同样地，如果切片区间没有指定最后一个元素的索引，则切片终止于列表末尾:
players = [&amp;#39;charles&amp;#39;, &amp;#39;martina&amp;#39;, &amp;#39;michael&amp;#39;, &amp;#39;florence&amp;#39;, &amp;#39;eli&amp;#39;] print(players[0:3]) print(players[1:4]) print(players[:3]) print(players[2:])  [&amp;#39;charles&amp;#39;, &amp;#39;martina&amp;#39;, &amp;#39;michael&amp;#39;] [&amp;#39;martina&amp;#39;, &amp;#39;michael&amp;#39;, &amp;#39;florence&amp;#39;] [&amp;#39;charles&amp;#39;, &amp;#39;martina&amp;#39;, &amp;#39;michael&amp;#39;] [&amp;#39;michael&amp;#39;, &amp;#39;florence&amp;#39;, &amp;#39;eli&amp;#39;] 负数索引 可以输出列表末尾的任何切片。如下所示，想要输出名单上的最后三名队员，可以使用负数索引切片：
print(players[-3:])  [&amp;#39;michael&amp;#39;, &amp;#39;florence&amp;#39;, &amp;#39;eli&amp;#39;] 对于索引区间，如果负数索引值超过了列表区间，依然不会报错：
players = [&amp;#39;charles&amp;#39;, &amp;#39;martina&amp;#39;, &amp;#39;michael&amp;#39;, &amp;#39;florence&amp;#39;, &amp;#39;eli&amp;#39;] print(players[-6:]) print(players[:6])  [&amp;#39;charles&amp;#39;, &amp;#39;martina&amp;#39;, &amp;#39;michael&amp;#39;, &amp;#39;florence&amp;#39;, &amp;#39;eli&amp;#39;] [&amp;#39;charles&amp;#39;, &amp;#39;martina&amp;#39;, &amp;#39;michael&amp;#39;, &amp;#39;florence&amp;#39;, &amp;#39;eli&amp;#39;] 若要遍历列表的部分元素，可以借助切片和循环：
for player in players[-3:]:  print(player)  florence eli name 复制列表 要复制列表，可创建一个包含整个列表的切片，方法是同时省略起始索引和终止索引。这让Python创建一个始于第一个元素，终于最后一个元素的切片，即整个列表的副本：
foods = [&amp;#39;pizza&amp;#39;, &amp;#39;falafel&amp;#39;, &amp;#39;carrot cake&amp;#39;] tmp_foods = foods[:] print(tmp_foods)  [&amp;#39;pizza&amp;#39;, &amp;#39;falafel&amp;#39;, &amp;#39;carrot cake&amp;#39;]  players = [&amp;#39;charles&amp;#39;, &amp;#39;martina&amp;#39;, &amp;#39;michael&amp;#39;, &amp;#39;florence&amp;#39;, &amp;#39;eli&amp;#39;] # test_players复制player数组 test_players = players[:] test_players.append(&amp;#34;test&amp;#34;)  print(players) print(test_players)  [&amp;#39;charles&amp;#39;, &amp;#39;martina&amp;#39;, &amp;#39;michael&amp;#39;, &amp;#39;florence&amp;#39;, &amp;#39;eli&amp;#39;] [&amp;#39;charles&amp;#39;, &amp;#39;martina&amp;#39;, &amp;#39;michael&amp;#39;, &amp;#39;florence&amp;#39;, &amp;#39;eli&amp;#39;, &amp;#39;test&amp;#39;] 需要注意的是，如果直接使用列表赋值，不能得到两个列表，而是两个变量指向同一个列表：
players = [&amp;#39;charles&amp;#39;, &amp;#39;martina&amp;#39;, &amp;#39;michael&amp;#39;, &amp;#39;florence&amp;#39;, &amp;#39;eli&amp;#39;] mo_players = players mo_players.append(&amp;#34;name&amp;#34;) print(players) print(mo_players)  [&amp;#39;charles&amp;#39;, &amp;#39;martina&amp;#39;, &amp;#39;michael&amp;#39;, &amp;#39;florence&amp;#39;, &amp;#39;eli&amp;#39;, &amp;#39;name&amp;#39;] [&amp;#39;charles&amp;#39;, &amp;#39;martina&amp;#39;, &amp;#39;michael&amp;#39;, &amp;#39;florence&amp;#39;, &amp;#39;eli&amp;#39;, &amp;#39;name&amp;#39;] 元组 列表适合用于存储在程序运行期间可能变化的数据集，因为列表是可以修改的。有时需要创建一系列不可修改的元素，元组可以满足这种需求。Python将不能修改的值称为不可变的，而不可变的列表称为元组。
dimensions = (200, 50) print(dimensions[0], dimensions[1])  200 50 如果试图修改元组中的元素，则会出现编译错误：
dimensions = (200, 50) dimensions[0] = 300  TypeError: &amp;#39;tuple&amp;#39; object does not support item assignment 元组变量 虽然不能修改元组中元素的值，但可以给储存元组的变量重新赋值：
dimensions = (200, 50) dimensions = (300, 400, 100) # 可以整体改变元组 if语句 在Python中，if语句包括单独的if，if-else、还有if-elif-else语句。但需要注意的是，并不要求if-elif结构后面必须有else代码块：
cars = [&amp;#39;audi&amp;#39;, &amp;#39;bmw&amp;#39;, &amp;#39;subaru&amp;#39;, &amp;#39;toyota&amp;#39;] for car in cars:  if car == &amp;#39;bmw&amp;#39;:  print(car.upper())  else:  print(car.title())  if age &amp;gt; 18:  print(&amp;#34;You are old enough to vote!&amp;#34;)  print(&amp;#34;Have you registered to vote yet?&amp;#34;) else:  print(&amp;#34;Sorry, you are too young to vote.&amp;#34;)  print(&amp;#34;Please register to vote as soon as you turn 18!&amp;#34;)  if age &amp;lt; 4:  print(&amp;#34;Your admission cost is $0&amp;#34;) elif age &amp;lt; 18:  print(&amp;#34;Your admission cost is $25&amp;#34;) else:  print(&amp;#34;Your admission cost is $40&amp;#34;) 如果要检查多个条件可以使用and或or：
age_0 = 22 age_1 = 18 status = age_0 &amp;gt;= 21 and age_1 &amp;gt;= 21 print(status)  False  status = (age_0 &amp;gt;= 21) and (age_1 &amp;gt;= 21) print(status)  False  status = (age_0 &amp;gt;= 21) or (age_1 &amp;gt;= 21) print(status)  True 要判断特定的值是否包含在列表中，可使用关键字in：
requested_toppings = [&amp;#39;mushrooms&amp;#39;, &amp;#39;onions&amp;#39;, &amp;#39;pineapple&amp;#39;] print(&amp;#39;mushrooms&amp;#39; in requested_toppings)  True 使用关键字not in可以判断某个特定的值未包含在列表中：
banned_users = [&amp;#39;andrew&amp;#39;, &amp;#39;carolina&amp;#39;, &amp;#39;david&amp;#39;] user = &amp;#39;marie&amp;#39; if user not in banned_users:  print(f&amp;#39;{user}not in {banned_users}&amp;#39;)  marie not in [&amp;#39;andrew&amp;#39;, &amp;#39;carolina&amp;#39;, &amp;#39;david&amp;#39;] 在if语句中将列表作为条件表达式时，列表至少包含一个元素时返回True，并在列表为空时返回False：
requested_toppings = [] if requested_toppings:  for requested_topping in requested_toppings:  print(requested_topping)  print(&amp;#34;Finish&amp;#34;) else:  print(&amp;#34;Are you sure you want a plain pizza?&amp;#34;)   Are you sure you want a plain pizza? 字典 在Python中字典用花括号{}中的键值对表示。字典是一种动态结构，可随时在其中添加键值对，如果要添加键值对，可依次指定字典名，用方括号括起来的键值：
test_dict = {&amp;#34;key1&amp;#34;: 12, &amp;#34;key2&amp;#34;: &amp;#34;test&amp;#34;} print(test_dict[&amp;#34;key1&amp;#34;]) print(test_dict[&amp;#34;key2&amp;#34;]) test_dict[&amp;#34;key3&amp;#34;] = 23 print(test_dict)  12 test {&amp;#39;key1&amp;#39;: 12, &amp;#39;key2&amp;#39;: &amp;#39;test&amp;#39;, &amp;#39;key3&amp;#39;: 23} 在Python 3.7中，字典中元素的排列顺序与定义时添加顺序相同。如果将字典打印出来或遍历其元素，会发现元素的排列顺序与添加时的顺序相同：
alien_0 = {} alien_0[&amp;#34;color&amp;#34;] = &amp;#39;green&amp;#39; alien_0[&amp;#39;points&amp;#39;] = 5 print(alien_0)  {&amp;#39;color&amp;#39;: &amp;#39;green&amp;#39;, &amp;#39;points&amp;#39;: 5} 删除键值对 对于字典中不需要的信息，可使用del语句将相应的键值对彻底删除。使用del语句时，必须指定字典名和要删除的键，如果要删除的键不存在，则会出现编译错误：
test_dict = {&amp;#34;key1&amp;#34;: 12, &amp;#34;key2&amp;#34;: &amp;#34;test&amp;#34;} print(test_dict[&amp;#34;key1&amp;#34;]) print(test_dict[&amp;#34;key2&amp;#34;]) test_dict[&amp;#34;key3&amp;#34;] = 23 print(test_dict) del test_dict[&amp;#34;key1&amp;#34;] print(test_dict)  12 test {&amp;#39;key1&amp;#39;: 12, &amp;#39;key2&amp;#39;: &amp;#39;test&amp;#39;, &amp;#39;key3&amp;#39;: 23} 12 test {&amp;#39;key2&amp;#39;: &amp;#39;test&amp;#39;, &amp;#39;key3&amp;#39;: 23}  del test_dict[&amp;#34;key&amp;#34;]  KeyError: &amp;#39;key&amp;#39; 遍历字典 对于字典，既可以只遍历键，也可以只遍历值，或者同时遍历键值对：
for key in test_dict.keys():  print(key)  for value in test_dict.values():  print(value)  for key, value in test_dict.items():  print(key, value)  for key in sorted(test_dict.keys()):  print(key) 如果放在方括号内的键不存在，则会出现编译错误：
print(test_dict[&amp;#34;key0&amp;#34;])  KeyError: &amp;#39;key0&amp;#39; 函数get()的第一个参数用于指定键，是必不可少的，第二个参数为指定的键不存在要返回的值，是可选的。如果没有指定第二个参数且指定的键不存在，Python将返回值None，None并非错误，而是一个表示值不存在的特殊值：
print(test_dict.get(&amp;#39;key&amp;#39;, &amp;#39;No key&amp;#39;)) print(test_dict.get(&amp;#39;key&amp;#39;))  No key None 集合 为了剔除重复项，可使用集合，集合中的每个元素都必须是独一无二的：
test_dict = {&amp;#34;key1&amp;#34;: 12, &amp;#34;key2&amp;#34;: &amp;#34;test&amp;#34;} test_dict[&amp;#34;key3&amp;#34;] = 12 print(test_dict)  # 列表转换为集合 for key in set(test_dict.values()):  print(key)  12 test 可以使用花括号直接创建集合，并在其中用逗号分隔。不同于列表和字典，集合不会以特定的顺序存储元素：
languages = {&amp;#39;python&amp;#39;, &amp;#39;ruby&amp;#39;, &amp;#39;python&amp;#39;, &amp;#39;c&amp;#39;} print(languages)  {&amp;#39;python&amp;#39;, &amp;#39;ruby&amp;#39;, &amp;#39;c&amp;#39;} # 集合每次执行打印后的顺序不同 函数input让程序暂停运行，等待用户输入一些文本。获取用户输入后，Python将其赋值给一个变量，并将用户输入解读为字符串：
message = input(&amp;#34;Tell me something, and I will repeat it back to you:&amp;#34;) print(message)   name = input(&amp;#39;Please enter your name：&amp;#39;) print(f&amp;#39;\nHello {name}&amp;#39;)   age = input(&amp;#39;Please enter your age：&amp;#39;) print(f&amp;#39;\nHello {age}&amp;#39;) # 输入qwe print(int(age)) ValueError: invalid literal for int() with base 10: &amp;#39;qwe&amp;#39; 函数 在Python中，函数使用def关键字定义。调用函数时，既可以使用位置实参（实参按照顺序传递），也可以使用关键字实参。一个函数全部使用关键字实参调用时，关键字的位置可以不按顺序来指定：
def print_message(msg):  print(msg)   print_message(&amp;#34;test&amp;#34;) print_message(msg=&amp;#34;hello&amp;#34;)  test hello 关键字实参是指传递参数时，直接将形参和实参值一一对应起来。所以，向函数传递实参时不会混淆，也无须考虑函数调用中的实参顺序，这样能够清楚地指出函数调用中各个值的用途：
def describe_pet(animal_type, pet_name):  print(f&amp;#34;My {animal_type}&amp;#39;s name is {pet_name.title()}.&amp;#34;)  describe_pet(pet_name=&amp;#39;harry&amp;#39;, animal_type=&amp;#39;hamster&amp;#39;) 默认值 编写函数时，可以给每个形参指定默认值。在调用函数时如果没有给形参指定实参，则将使用该参数的默认值。但是，使用默认值时必须先在形参列表中列出没有默认值的形参，再列出有默认值的形参：
def print_test(name=&amp;#39;ty&amp;#39;):  print(name)  print_test()  ty 返回值 在函数中，可以使用return语句将值返回到调用函数的代码行，既可以返回一个值也可以返回一组值。函数可以返回任何类型的值，包括列表和字典等较复杂的数据结构：
def return_test(name):  return name   print(return_test(&amp;#34;Hello&amp;#34;))  hello   def build_person(first_name, last_name, age=None):  person = {&amp;#39;first&amp;#39;: first_name, &amp;#39;last&amp;#39;: last_name}  if age:  person[&amp;#39;age&amp;#39;] = age  return person   musician = build_person(&amp;#39;jimi&amp;#39;, &amp;#39;hendrix&amp;#39;, age=34) print(musician)  {&amp;#39;first&amp;#39;: &amp;#39;jimi&amp;#39;, &amp;#39;last&amp;#39;: &amp;#39;hendrix&amp;#39;, &amp;#39;age&amp;#39;: 34} 列表参数 将列表传递给函数后，函数就可以对这个列表进行修改。在函数中对这个列表所做的任何修改都是永久性的（与C&#43;&#43;的指针参数相似）如果需要禁止函数修改列表，则可向函数传递列表的副本，即切片[:]。
unprinted_design1 = [&amp;#39;phone case&amp;#39;, &amp;#39;robot pendant&amp;#39;, &amp;#39;dodecahedron&amp;#39;] completed_models1 = [] print(unprinted_design1) print(completed_models1)   def change(unprinted_design, completed_models):  while unprinted_design:  current_design = unprinted_design.pop()  print(f&amp;#34;Printing model:{current_design}&amp;#34;)  completed_models.append(current_design)   change(unprinted_design1, completed_models1) print(unprinted_design1) print(completed_models1)  [&amp;#39;phone case&amp;#39;, &amp;#39;robot pendant&amp;#39;, &amp;#39;dodecahedron&amp;#39;] [] Printing model:dodecahedron Printing model:robot pendant Printing model:phone case [] [&amp;#39;dodecahedron&amp;#39;, &amp;#39;robot pendant&amp;#39;, &amp;#39;phone case&amp;#39;]   unprinted_design1 = [&amp;#39;phone case&amp;#39;, &amp;#39;robot pendant&amp;#39;, &amp;#39;dodecahedron&amp;#39;] completed_models1 = [] print(unprinted_design1) print(completed_models1)   def change(unprinted_design, completed_models):  while unprinted_design:  current_design = unprinted_design.pop()  print(f&amp;#34;Printing model:{current_design}&amp;#34;)  completed_models.append(current_design)   change(unprinted_design1[:], completed_models1[:]) print(unprinted_design1) print(completed_models1)   [&amp;#39;phone case&amp;#39;, &amp;#39;robot pendant&amp;#39;, &amp;#39;dodecahedron&amp;#39;] [] Printing model:dodecahedron Printing model:robot pendant Printing model:phone case [&amp;#39;phone case&amp;#39;, &amp;#39;robot pendant&amp;#39;, &amp;#39;dodecahedron&amp;#39;] [] 任意数量的实参 有时候，事先不知道函数需要接受多少个实参，好在Python允许函数从调用语句中收集任意数量的实参。在下面定义的函数中，形参名中的*让Python创建一个名为toppings的空元组，并将收到的所有值都封装到这个元组中：
def make_pizza(*toppings):  print(toppings)  make_pizza(&amp;#39;test&amp;#39;, 12) # (&amp;#39;test&amp;#39;, 12)  def make_pizza(*toppings):  print(toppings, toppings[0])  toppings[0] = 123 # TypeError: &amp;#39;tuple&amp;#39; object does not support item assignment  如果要让函数接受不同类型的实参，必须在函数定义时将接受任意数量实参放在最后。Python会先匹配位置实参和关键字实参，再将余下的实参都收集到最后一个形参中:
def make_pizza(size, *toppings):  &amp;#34;&amp;#34;&amp;#34;概述要制作的比萨&amp;#34;&amp;#34;&amp;#34;  print(&amp;#34;\nMaking a &amp;#34; &#43; str(size) &#43; &amp;#34;-inch pizza with the following toppings:&amp;#34;)  for topping in toppings:  print(&amp;#34;- &amp;#34; &#43; topping)  make_pizza(16, &amp;#39;pepperoni&amp;#39;) make_pizza(12, &amp;#39;mushrooms&amp;#39;, &amp;#39;green peppers&amp;#39;, &amp;#39;extra cheese&amp;#39;)   def make_pizza(*toppings):  print(toppings)  toppings[0] = 13 # TypeError: &amp;#39;tuple&amp;#39; object does not support item assignment 有时候，需要接受任意数量不同类型实参，但预先不知道传递给函数的会是什么样的信息。在这种情况下，可将函数编写成能够接受任意数量的键值对：
def build_profile(first, last, **user_info):  &amp;#34;&amp;#34;&amp;#34;创建一个字典，其中包含我们知道的有关用户的一切&amp;#34;&amp;#34;&amp;#34;  profile = {}  profile[&amp;#39;first_name&amp;#39;] = first  profile[&amp;#39;last_name&amp;#39;] = last   for key, value in user_info.items():  profile[key] = value  return profile   user_profile = build_profile(&amp;#39;albert&amp;#39;, &amp;#39;einstein&amp;#39;, location=&amp;#39;princeton&amp;#39;, field=&amp;#39;physics&amp;#39;) print(user_profile)  {&amp;#39;first_name&amp;#39;: &amp;#39;albert&amp;#39;, &amp;#39;last_name&amp;#39;: &amp;#39;einstein&amp;#39;, &amp;#39;location&amp;#39;: &amp;#39;princeton&amp;#39;, &amp;#39;field&amp;#39;: &amp;#39;physics&amp;#39;} 导入函数 要让函数是可导入的，需要先创建模块，模块名就是扩展名为.py的文件。例如，现在有一个名为test.py的文件，如果要使用其中的函数，则在需要在文件中import test ，然后通过test.test()来调用test函数。下面在pizza.py文件中定义一个make_pizza函数：
def make_pizza(size, *toppings):  &amp;#34;&amp;#34;&amp;#34;概述要制作的披萨&amp;#34;&amp;#34;&amp;#34;  for topping in toppings:  print(f&amp;#34;-{topping}&amp;#34;) 然后在另外一个文件中引用该函数，需要先导入pizza模块：
import pizza  pizza.make_pizza(16, &amp;#39;pepperoni&amp;#39;) pizza.make_pizza(12, &amp;#39;mushrooms&amp;#39;, &amp;#39;green peppers&amp;#39;, &amp;#39;extra cheese&amp;#39;) 如果只需要导入特定的函数，则使用from module_name import func_name_0, function_1, function_2这种方式，这种方式导入函数后则不需要加module前缀来调用对应的函数：
from pizza import make_pizza  make_pizza(16, &amp;#39;pepperoni&amp;#39;) make_pizza(12, &amp;#39;mushrooms&amp;#39;, &amp;#39;green peppers&amp;#39;, &amp;#39;extra cheese&amp;#39;)   -pepperoni -mushrooms -green peppers -extra cheese 如果要导入的函数的名称和当前文件中的某个函数冲突，或者要使用的函数名称太长。则可以在导入的时候为函数指定别名from module_name import func_name as other_name:
from pizza import make_pizza as mp  mp(16, &amp;#39;pepperoni&amp;#39;) mp(12, &amp;#39;mushrooms&amp;#39;, &amp;#39;green peppers&amp;#39;, &amp;#39;extra cheese&amp;#39;) 如果要导入某个模块中的所有函数，可以使用from module_name import *:
from pizza import *  make_pizza(16, &amp;#39;pepperoni&amp;#39;) make_pizza(12, &amp;#39;mushrooms&amp;#39;, &amp;#39;green peppers&amp;#39;, &amp;#39;extra cheese&amp;#39;) 类 类名应使用驼峰命名法，类中的函数都称为方法。__init__是一个特殊方法，开头和末尾各有两个下划线，这是一种约定，旨在避免与普通方法名冲突。该方法在创建类的实例时会自动调用：
class Dog:  &amp;#34;&amp;#34;&amp;#34;一次模拟小狗的简单尝试&amp;#34;&amp;#34;&amp;#34;   def __init__(self, name, age):  &amp;#34;&amp;#34;&amp;#34;初始化属性name和age&amp;#34;&amp;#34;&amp;#34;  self.name = name  self.age = age   def sit(self):  &amp;#34;&amp;#34;&amp;#34;模拟小狗坐下&amp;#34;&amp;#34;&amp;#34;  print(f&amp;#34;{self.name}is now sitting&amp;#34;)   def roll_over(self):  &amp;#34;&amp;#34;&amp;#34;模拟小狗收到命名时打滚&amp;#34;&amp;#34;&amp;#34;  print(f&amp;#34;{self.name}rolled over&amp;#34;) 编写类时，可使用继承，当一个类继承另一个类时，将自动获得另一个类的所有属性和方法，原有的类称为父类，而新创建的类称为子类：
class Car:  def __init__(self, make, model, year):  self.make = make  self.model = model  self.year = year  self.odometer_reading = 0   def get_descriptive_name(self):  long_name = f&amp;#34;{self.year}{self.make}{self.model}&amp;#34;  return long_name.title()   def read_odometer(self):  print(f&amp;#34;This car has {self.odometer_reading}miles on it.&amp;#34;)   def update_odometer(self, mileage):  if mileage &amp;gt;= self.odometer_reading:  self.odometer_reading = mileage  else:  print(&amp;#34;You can&amp;#39;t roll back an odometer!&amp;#34;)   def increment_odometer(self, miles):  self.odometer_reading &#43;= miles   class ElectriCar(Car):   def __init__(self, make, model, year):  super().__init__(make, model, year)   my_tesla = ElectriCar(&amp;#39;tesla&amp;#39;, &amp;#39;models s&amp;#39;, 2019) print(my_tesla.get_descriptive_name())   2019 Tesla Models S 一个类继承另一个类后，也可以添加新属性和新方法：
class ElectriCar(Car):   def __init__(self, make, model, year):  super().__init__(make, model, year)  # 新属性  self.battery_size = 75   # 新方法  def describe_battery(self):  print(f&amp;#34;This car has {self.battery_size}-kWh battery&amp;#34;) 对于父类的方法，只要它不符合子类的行为，都可以重写：
class ElectriCar(Car):   def __init__(self, make, model, year):  super().__init__(make, model, year)  # 新属性  self.battery_size = 75   # 新方法  def describe_battery(self):  print(f&amp;#34;This car has {self.battery_size}-kWh battery&amp;#34;)   # 重写父类的方法  def get_descriptive_name(self):  long_name = f&amp;#34;{self.year}{self.make}{self.model}{self.battery_size}&amp;#34;  return long_name.title()   my_tesla = ElectriCar(&amp;#39;tesla&amp;#39;, &amp;#39;models s&amp;#39;, 2019) print(my_tesla.get_descriptive_name()) 可根据需要在程序中文件中导入任意数量的类：
# 导入文件中的所有类 from module_name import * # 导入文件中的多个类 from module_name import classA,classB,... 标准库 Python标准库是一组模块，如果想要使用标准库中的任何函数和类，只需在程序开头包含一条简单的import语句：
from random import randint, choice  print(randint(1, 6)) print(choice(players))  3 name 文件 关键字with可以在不需要访问文件后将其关闭。在下面的程序中调用了open，但没有调用close。也可以调用open和close来打开或关闭文件，但这样做时，如果程序存在bug导致close未执行，文件将不会关闭。未妥善关闭文件可能导致数据丢失或受损：
with open(&amp;#39;pizza.py&amp;#39;) as file_object:  contents = file_object.read() print(contents) 相比于原始文件，该输出唯一不同的地方是末尾多了一个空行。因为read到达文件末尾时返回一个空字符串，而将这个空字符串显示出来就是一个空行。要删除多出来的空行，可在函数调用print中使用rstrip:
with open(&amp;#39;pizza.py&amp;#39;) as file_object:  contents = file_object.read() print(contents.rstrip()) 读取文件时，可能需要检查其中的每一行：
with open(&amp;#39;pizza.py&amp;#39;) as file_object:  for line in file_object:  print(line.rstrip())  with open(&amp;#39;pizza.py&amp;#39;) as file_object:  lines = file_object.readlines() for line in lines:  print(line.rstrip()) 函数readlines()从文件中读取每一行，并将其存储在一个列表中。在with代码块外，依然可使用这个变量。
打开文件时，可指定读取模式。要将文本写入文件，在调用open()时需要提供另一个实参w，告诉Python要写入打开的文件。如果写入的文件不存在，函数open()将自动创建它，如果指定的文件已存在，将在返回文件对象前清空该文件的内容：
with open(&amp;#39;test.txt&amp;#39;, &amp;#39;w&amp;#39;) as file_object:  file_object.write(&amp;#39;I love programming&amp;#39;) 文件模式有读取模式r，写入模式w，附加模式a，写入模式r&#43;。函数write不会在写入的文本末尾添加换行符。如果要让字符串都单独占一行，需要在方法调用write中包含换行符：
with open(&amp;#39;test.txt&amp;#39;, &amp;#39;w&amp;#39;) as file_object:  file_object.write(&amp;#39;I love programming\n&amp;#39;)  file_object.write(&amp;#39;I love creating new games.\n&amp;#39;) 异常 print(5 / 0)  ZeroDivisionError: division by zero 当认为可能会发生错误时，可编写一个try-except代码块来处理可能引发的异常：
try:  print(5 / 0) except ZeroDivisionError:  print(&amp;#39;divide by zero&amp;#39;) 无异常的代码可以放到except后的else：
try:  print(5 / 0) except ZeroDivisionError:  print(&amp;#39;divide by zero&amp;#39;) else:  print(&amp;#39;test&amp;#39;) 使用文件时，一种常见的问题是找不到文件。查找的文件可能在其它地方，文件名也可能不正确，或者这个文件根本不存在。对于这些情形，都可使用try-except代码块以直观的方式处理：
try:  with open(filename, encoding=&amp;#39;utf-8&amp;#39;) as f:  contents = f.read() except FileNotFoundError:  print(f&amp;#34;Sorry, the file{filename}does not exist&amp;#34;)  Sorry, the filealice.txt does not exist 并非每次捕获到异常都需要告诉用户，有时候希望程序发生异常时保持静默，就像什么都没发生一样继续运行：
def count_words(filename):  &amp;#34;&amp;#34;&amp;#34;计算一个文件大致包含多少个单词&amp;#34;&amp;#34;&amp;#34;  try:  with open(filename, encoding=&amp;#39;utf-8&amp;#39;) as f:  contents = f.read()  except FileNotFoundError:  pass  else:  words = contents.split()  numbers_words = len(words)  print(f&amp;#34;The file {filename}, has about {numbers_words}words.&amp;#34;)  # ddd.txt不存在时，该函数调用不会打印任何内容 count_words(&amp;#39;ddd.txt&amp;#39;) 存储 numbers = [2, 3, 5, 7, 11, 13] filename = &amp;#39;numbers.json&amp;#39; with open(filename, &amp;#39;w&amp;#39;) as f:  json.dump(numbers, f)  with open(filename) as f:  numbers = json.load(f)  print(numbers)   [2, 3, 5, 7, 11, 13] </content>
    </entry>
    
     <entry>
        <title>Swift Tips</title>
        <url>https://iihui.github.io/post/swift-tips/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> 柯里化 柯里化(curry)：把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下参数而且返回结果的新函数。
func addTo(_ adder: Int) -&amp;gt; (Int) -&amp;gt; Int {  return { num in  return num &#43; adder  } }  let addTwo = addTo(2) // addTwo: Int -&amp;gt; Int let result = addTwo(6) // result = 8 柯⾥化是⼀种量产相似⽅法的好办法，可以通过柯⾥化⼀个⽅法模板来避免写出很多重复代码，也方便今后的维护：
func greaterThan(_ comparer: Int) -&amp;gt; (Int) -&amp;gt; Bool {  return { $0 &amp;gt; comparer } }  let greaterThan10 = greaterThan(10);  greaterThan10(13) // =&amp;gt; true greaterThan10(9) // =&amp;gt; false  target-action 在swift中selector只能使用字符串生成，这面临一个很严重的问题，就是难以重构，并且无法编译期间进行检查。但target-action⼜是 Cocoa中如此重要的⼀种设计模式，⽆论如何我们都想安全地使⽤的话，应该怎么办呢？⼀种可能的解决⽅式就是利⽤⽅法的柯⾥化。
protocol TargetAction {  func performAction() }  struct TargetActionWrapper&amp;lt;T: AnyObject&amp;gt;: TargetAction {  weak var target: T?  let action: (T) -&amp;gt; () -&amp;gt; ()   func performAction() -&amp;gt; () {  if let t = target {  action(t)()  }  } }  enum ControlEvent {  case TouchUpInside  case ValueChanged  // ... }  class Control {  var actions = [ControlEvent: TargetAction]()   func setTarget&amp;lt;T: AnyObject&amp;gt;(target: T, action: @escaping (T) -&amp;gt; () -&amp;gt; (), controlEvent: ControlEvent) {   actions[controlEvent] = TargetActionWrapper(target: target, action: action)  }   func removeTargetForControlEvent(controlEvent: ControlEvent) {  actions[controlEvent] = nil   }   func performActionForControlEvent(controlEvent: ControlEvent) {  actions[controlEvent]?.performAction()  }  } protocol Swift中的protocol不仅可以被class类型实现，也可以被struct和enum是实现。mutating关键字修饰方法是为了能在该方法中修改struct或是enum的变量，如果如果没在协议⽅法⾥写mutating的话，别⼈如果⽤struct或者enum来实现这个协议的话，就不能在⽅法⾥改变⾃⼰的变量了。因此，在定义协议时需要多考虑是否适用mutating来修饰方法。
public protocol Vehicle {  mutating func changeColor() } 在使用class来实现带有mutating的方法的协议时，具体实现的前面是不需要加mutating修饰的，因为class可以随意修改自己的成员变量。所以说在协议里mutating修饰方法，对于class的实现是完全透明，可以当作不存在的。
Sequence Swift中的for ... in可以用在所有实现了Sequence协议的类型上，而为了实现Sequence协议，首先需要实现IteratorProtocol协议。下面是一个反向迭代器的例子：
class ReverseIterator&amp;lt;T&amp;gt;: IteratorProtocol {   typealias Element = T  var array: [Element]  var currentIndex = 0   init(array: [Element]) {  self.array = array  self.currentIndex = array.count - 1  }   func next() -&amp;gt; Element? {  if currentIndex &amp;lt; 0 {  return nil  } else {  let element = array[currentIndex]  currentIndex -= 1  return element  }  } } 接着使用ReverseIterator迭代器来创建一个实现Sequence协议的反向ReverseSequence，代码如下：
struct ReverseSequence&amp;lt;T&amp;gt;: Sequence {  var array: [T]   init(array: [T]) {  self.array = array  }   typealias Iterator = ReverseIterator&amp;lt;T&amp;gt;   func makeIterator() -&amp;gt; ReverseIterator&amp;lt;T&amp;gt; {  return ReverseIterator(array: self.array)  }  }  func test() {  let arr = [0, 1, 2, 3, 4]  // 对 Sequence 可以使⽤ for...in 来循环访问  for i in ReverseSequence(array: arr) {  print(&amp;#34;Index \(i)is \(arr[i])&amp;#34;)  } } 多元组 在Swift中使用多元组可以轻松的交换两个值，而不需要额外的交换空间：
func swap&amp;lt;T&amp;gt;(a: inout T, b: inout T) {  (a,b) = (b,a) } autoclosure @autoclosure把一句表达式自动地封装成一个闭包closure。但是，@autoclosure并不支持带有输入参数的写法，也就是说只有形如()-&amp;gt;T的参数才能使用此特性进行简化。
func testAutoClosure(predicate:@autoclosure ()-&amp;gt;Bool) {  if predicate() {  print(&amp;#34;true&amp;#34;)  }else{  print(&amp;#34;false&amp;#34;)  } } testAutoClosure(predicate: 2&amp;gt;1) // true 在testAutoClosure(predicate: 2&amp;gt;1)中，Swift会把2&amp;gt;1这个表达式自动转换为() -&amp;gt; Bool。操作符??、&amp;amp;&amp;amp;、||也中用到了autoclosure：
public func ?? &amp;lt;T&amp;gt;(optional: T?, defaultValue: @autoclosure () throws -&amp;gt; T) rethrows -&amp;gt; T  public func ?? &amp;lt;T&amp;gt;(optional: T?, defaultValue: @autoclosure () throws -&amp;gt; T?) rethrows -&amp;gt; T?  public static func &amp;amp;&amp;amp; (lhs: Bool, rhs: @autoclosure () throws -&amp;gt; Bool) rethrows -&amp;gt; Bool  public static func || (lhs: Bool, rhs: @autoclosure () throws -&amp;gt; Bool) rethrows -&amp;gt; Bool @escaping 接受@escaping的闭包，因为要确保闭包内的成员依然有效，如果闭包内引出了self及其成员的话，Swift将强制明确的写出self。
如果在协议或者父类中定义了一个接受@escaping为参数的方法，那么在实现协议和类型或者是这个父类的子类，对应的方法也必须声明为@escaping，否则两个方法会被认为拥有不同的函数签名。
Optional Chaining Optional Chaining随时都可能返回nil的，所以使用Optional Chaining所得到的东西其实都是Optional。
typealias typealias是用来为已经存在的类型重新定义名字的，通过重命名，可以使代码变得更清晰。使用typealias关键字就像使用普通的赋值语句一样，可以将某个已经存在的类型赋值为新名字。
typealias Location = CGPoint typealias Distance = Double  func distance(from location: Location, to anotherLocation: Location) -&amp;gt; Distance {  let dx = Distance(location.x - anotherLocation.x)  let dy = Distance(location.y - anotherLocation.y)  return sqrt(dx * dx &#43; dy * dy) }  let origin: Location = Location(x: 0, y: 0) let point: Location = Location(x: 1, y: 1)  let d: Distance = distance(from: origin, to: point) 在涉及到泛型时，情况就稍微不太⼀样。⾸先，typealias是单⼀的，也就是说你必须指定将某个特定的类型通过typealias赋值为新名字，⽽不能将整个泛型类型进⾏重命名。下⾯这样的命名都是⽆法通过编译的。
class Person&amp;lt;T&amp;gt; {} typealias Worker = Person typealias Worker = Person&amp;lt;T&amp;gt; 在别名中也引入泛型，是可以的：
// This is OK typealias Worker&amp;lt;T&amp;gt; = Person&amp;lt;T&amp;gt; 当泛型类型确定性得到保证后，显然别名也是可以使用的：
class Person&amp;lt;T&amp;gt; {} typealias WorkId = String typealias Worker = Person&amp;lt;WorkId&amp;gt; 另⼀个使⽤场景是某个类型同时实现多个协议的组合时。我们可以使⽤ 后给它们⼀个新的更符合上下⽂的名字，来增强代码可读性：
protocol Cat { ... } protocol Dog { ... } typealias Pat = Cat &amp;amp; Dog 初始化方法顺序 Swift的初始化方法需要保证类型的所有属性都被初始化，因此在子类中，需要保证当前子类实例的成员初始化完成后才能调用父类的初始化方法。
class Cat {  var name: String  init() {  name = &amp;#34;cat&amp;#34;  } }  class Tiger: Cat {  let power: Int  override init() {  power = 10. //先初始化子类的成员变量  super.init() //再初始化父类的成员  name = &amp;#34;tiger&amp;#34; //最后修改父类的成员变量  } } 一般来说，子类的初始化顺序分为以下三步：
 设置子类自己需要初始化的参数power=10 调用父类相应的初始化方法super.init 对父类中需要改变的成员进行设定name=tiger  其中第三步是根据具体情况决定的，如果子类中不需要对父类的成员做出改变的话，就不存在第三步。在这种情况下，Swift会自动对父类的init方法进行调用，也就是说第二步的super.init也是可以不写：
class Cat {  var name: String  init() {  name = &amp;#34;cat&amp;#34;  } }  class Tiger: Cat {  let power: Int  override init() {  power = 10  }  } default参数 在Swift中默认参数限制较少，可以不放在最后，如下所示，两种写法都是可以的：
func sayHello1(str1: String = &amp;#34;Hello&amp;#34;, str2: String, str3: String) {  print(str1 &#43; str2 &#43; str3) }  func sayHello2(str1: String, str2: String, str3: String = &amp;#34;World&amp;#34;) {  print(str1 &#43; str2 &#43; str3) }  可变参数 在Swift中写一个可变参数只需要在声明参数时在类型后面加上...就可以了。其他语言因为编译器和语言自身语法限制，在使用可变参数时，往往可变参数只能作为方法中最后一个参数来使用。而不能先声明一个可变参数。
fun sum(input:Int ...) -&amp;gt; Int {  return input.reduce(0,&#43;) } 正则表达式 Swift还没有在语言层面上支持正则表达式，在Cocoa中使用NSRegularExpression来做正则表达，所以在Swift中可以对其进行封装：
struct RegexHelper {  let regex: NSRegularExpression   init(_ pattern: String) throws {  try regex = NSRegularExpression(pattern: pattern, options: .caseInsensitive)  }   func match(_ input: String) -&amp;gt; Bool {  let matches = regex.matches(in: input, options: [], range: NSMakeRange(0, input.utf16.count))   return matches.count &amp;gt; 0  }  } let mailPattern = &amp;#34;^([a-z0-9_\\.-]&#43;)@([\\da-z\\.-]&#43;)\\.([a-z\\.]{2,6})$&amp;#34; let matcher: RegexHelper do {  matcher = try RegexHelper(mailPattern)  let maybeMailAddress = &amp;#34;onev@onevcat.com&amp;#34;  if matcher.match(maybeMailAddress) {  print(&amp;#34;有效的邮箱地址&amp;#34;)  } }catch {  print(error.localizedDescription) } 接着封装=～运算符，就可以像其他语言一样使用正则表达式了：
precedencegroup MatchPrecedence {  associativity: none higherThan: DefaultPrecedence }  infix operator =~: MatchPrecedence  func =~(lhs: String, rhs: String) -&amp;gt; Bool {  do {  return try RegexHelper(rhs).match(lhs)  } catch {  print(error.localizedDescription)  return false  } }  if &amp;#34;xxx@test.com&amp;#34; =~ &amp;#34;^([a-z0-9_\\.-]&#43;)@([\\da-z\\.-]&#43;)\\.([a-z\\.]{2,6})$&amp;#34; {  print(&amp;#34;有效的邮箱地址&amp;#34;) } 模式匹配 Swift中没有内置正则表达式，但是有一个和正则表达式类似的特性——模式匹配。从概念上来说，正则匹配只是模式匹配的一个子集。
协议和类方法中的Self 在定义一些协议时，首字母大写的Self出现在类型的位置上。在下面IntervalType协议中，定义了一个方法，接受实现该协议的自身类型，并返回一个同样的类型：
protocol IntervalType {  /// Return `rhs` clamped to `self`. The bounds of the result, even   /// if it is empty, are always within the bounds of `self`  func clamp(intervalToClamp: Self) -&amp;gt; Self } 这么定义是因为协议本身没有自己的上下文类型的信息，在声明协议的时候，我们并不知道最后究竟会是什么样的类型来实现这个协议。
Reflection 和 Mirror  反射是一种在运行时检测、访问或者修改类型的行为特性。一般的静态语言类型的结构和方法的调用等都需要在编译时决定。
 Selector @selector是OC时代的一个关键词，可以将一个方法转换并赋值给一个SEL类型，它的表现类似一个动态的函数指针。
-(void) callMe { //...  }  -(void) callMeWithParam:(id)obj { //...  }  SEL someMethod = @selector(callMe); SEL anotherMethod = @selector(callMeWithParam:);  // 或者也可以使⽤ NSSelectorFromString  // SEL someMethod = NSSelectorFromString(@&amp;#34;callMe&amp;#34;);  // SEL anotherMethod = NSSelectorFromString(@&amp;#34;callMeWithParam:&amp;#34;); 在Swift中没有@selector了，取而代之是从#selector来暴露给OC的代码中获取一个selector。
@objc func callMe() { //... }  @objc func callMeWithParam(obj: AnyObject!) { //... }  let someMethod = #selector(callMe) let anotherMethod = #selector(callMeWithParam(obj:)) selector其实是OC运行的概念，在Swift 4中，默认情况下所有的Swift方法在OC中是不可见的，所以需要在这类方法加上@objc关键字，将这个方法暴露给OC，才能进行使用。
编译标记 可以使用Mark:这样的标记，Xcode将在代码中寻找这样的标记，然后以粗体标签的形式将名称显示在导航栏中。还可以在冒号的后⾯加⼀个横杠Mark:-分隔开各个部分，会显得更加清晰：
as 需要注意的是as是在编译期间执行的，as?和as!是在运行时执行的。执行下面的代码会崩溃，是因为as?和as!是在运行时执行，运行时4已经先赋值为Int类型，然后强制转换为Double时必然失败，所以会产生崩溃。
print(4 as Double) // print 4.0 print(4 as! Double) // crash  </content>
    </entry>
    
     <entry>
        <title>Kotlin基础</title>
        <url>https://iihui.github.io/post/kotlin-base/</url>
        <categories>
          <category>kotlin</category>
        </categories>
        <tags>
          <tag>kotlin</tag>
        </tags>
        <content type="html"> 变量和函数 常量 Kotlin中使用val来声明常量「val是value的缩写」，val声明的常量不可以再重新赋值，否则会报错。val对应Java中的final。
val str = &amp;#34;Hello world&amp;#34; 变量 Kotlin中使用var来声明变量「var是variable的缩写」，var声明的变量可以重新赋值。var声明的变量对应Java中的final变量。
var test = &amp;#34;ch&amp;#34; println(test) test = &amp;#34;ccc&amp;#34; println(test) 函数 在Kotlin中fun用于定义函数，例如fun methodName(param1:Int, param2:Int):Int定义一个名为methodName，接受两个Int类型的参数，返回Int的函数。
fun largeNumber1(param1:Int,param2:Int):Int {  return max(param1,param2) }  fun largeNumber2(param1:Int,param2:Int):Int = max(param1,param2)  fun largeNumber3(param1:Int,param2:Int) = max(param1,param2) 条件语句 if语句 Kotlin中的if相比于Java中有一个额外功能，它是可以有返回值的，返回值是if语句每一个条件中最后一行代码的返回值。
fun largeNumber4(num1: Int, num2: Int): Int {  val value = if (num1 &amp;gt; num2) {  num1  } else {  num2  }  return value } fun largeNumber5(num1: Int, num2: Int): Int {  return if (num1 &amp;gt; num2) {  num1  } else {  num2  } } fun largeNumber6(num1: Int, num2: Int): Int = if (num1 &amp;gt; num2) {  num1 } else {  num2 } // 自动推断类型 fun largerNumber7(num1: Int, num2: Int) = if (num1 &amp;gt; num2) {  num1 } else {  num2 } when Kotlin不包含三元运算符，更加倾向于使用条件表达式，随着if-else的复杂性增加，可以使用when表达式。Kotlin中的when表达式中每个分支由一个条件，一个箭头和一个结果表示，如果箭头左侧的条件求值为true，则会返回右侧表达式的值。
传入参数 标准的when语句使用是传入参数。when语句和if语句一样，也是可以有返回值，因此依然可以使用单行代码函数语法糖。
fun checkNumber(num: Number) {  when (num) {  is Int -&amp;gt; println(&amp;#34;number is Int&amp;#34;)  is Double -&amp;gt; println(&amp;#34;number is Double&amp;#34;)  else -&amp;gt; println(&amp;#34;number not support&amp;#34;)  } } when {  count == 43 -&amp;gt; println(&amp;#34;43&amp;#34;)  tt == &amp;#34;name&amp;#34; -&amp;gt; println(&amp;#34;name&amp;#34;)  str1 == &amp;#34;test&amp;#34; -&amp;gt; println(str1) } val count = 43 var str1 = when (count) {  42 -&amp;gt; &amp;#34;42&amp;#34;  56 -&amp;gt; &amp;#34;56&amp;#34;  else -&amp;gt; &amp;#34;else&amp;#34; } fun getValue(colorEnum: ColorEnum) =  when(colorEnum){  ColorEnum.RED -&amp;gt; 1;  ColorEnum.BLUE -&amp;gt; 2;  ColorEnum.GREEN -&amp;gt; 3;  } 不传参数 可以不在when语句中传入参数。这种用法是将判断的表达式完整地写在when结构体中，对于其他的一些情况很有用，如下所示：
fun getScore1(name: String) = when {  name == &amp;#34;A&amp;#34; -&amp;gt; 1  name == &amp;#34;B&amp;#34; -&amp;gt; 2  name == &amp;#34;C&amp;#34; -&amp;gt; 3  else -&amp;gt; -1 }  fun getScore2(name: String) = when {  name.startsWith(&amp;#34;test&amp;#34;) -&amp;gt; 89  name == &amp;#34;M&amp;#34; -&amp;gt; 90  else -&amp;gt; 4589 } 循环语句 Kotlin在for在循环方面做了很大幅度的修改，直接舍弃了Java中的for-i，而在Java中的另一种for-each循环则被Kotlin进行大幅度的加强，变成了for-in循环。
区间 Kotlin中的区间有左闭右闭，左闭右开。左右双闭区间使用..来定义，而左闭右开使用until来定义。这两个关键字定义的区间都必须左端小于右端区间，也就是这两种关键字创建的都是升序区间。
升序区间 fun forTest1() {  for (i in 0..100) {  println(i)  } }  fun forTest2() {  for (i in 0 until 100) {  println(i)  } } 由..和until定义的升序区间，默认步长都是1，如果想要更改步长就需要使用step关键字，如下所示：
fun forTest3() {  for (i in 0..100 step 6) {  println(i)  } }  fun forTest4() {  for (i in 0 until 100 step 6) {  println(i)  } } 降序区间 如果要使用降序区间，需要使用downTo关键字，由downTo定义的区间是也是左闭右闭的，也可以使用step关键字设置步长。
fun forTest5() {  for (i in 10 downTo 1) {  println(i)  } }  fun forTest6() {  for (i in 10 downTo 1 step 4) {  println(i)  } } 类与对象 在Kotlin中任何一个非抽象类默认都是不可以被继承的，相当于Java中给类声明了final关键字。如果要想一个非抽象类可以被继承，就要在其前添加open关键字。
构造函数 主构造函数 构造函数分为了两种，一种是主构造函数，另一种是次构造函数。每个类默认都会有一个不带参数的主构造函数。主构造函数的特点是没有函数体，直接定义在类名的后面即可：
open class Person {  var name = &amp;#34;&amp;#34;  var age = 0  fun eat() {  println(name &#43; &amp;#34; is eating. He is &amp;#34; &#43; age &#43; &amp;#34;years old.&amp;#34;)  } }  class Student : Person() {  var sno = &amp;#34;&amp;#34;  var grade = 0   init {  println(sno)  println(grade)  } } 主构造函数没有函数体，如果想要在主构造函数中编写一些逻辑，则可以写在init结构体中。主构造函数声明为val或者var的参数将自动成为该类的字段。
open class Person(val name: String, val age: Int) {  // }  class Student(val sno: String, val grade: Int, name: String, age: Int) : Person(name, age) {  // } 次构造函数 任何一个类只能(至多)有一个主构造函数，但是可以有多个次构造函数。次构造函数也可以用于实例化一个类。次构造函数是通过constructor关键字来定义，次构造函数是有函数体的，可以通过this关键字来调用主构造函数。
class Student(val sno: String, val grade: Int, name: String, age: Int) : Person(name, age) {  constructor(name: String, age: Int) : this(&amp;#34;&amp;#34;, 0, name, age) {  //  }   constructor() : this(&amp;#34;&amp;#34;, 0) {  //  } } 当一个类没有显式地定义主构造函数且定义了次构造函数时，它就是没有主构造函数的。因为没有主构造函数，次构造函数只能直接调用父类的构造函数：
class Student : Person {  constructor(name: String, age: Int) : super(name, age) } 接口 在Java中，任何一个类最多只能继承一个父类，但可以实现任意多接口，Kotlin也是。Java中继承使用的关键字为extends，实现接口使用的关键字为implements，而Kotlin中统一使用冒号，中间用逗号进行分隔。Kotlin中使用override关键字来重写父类或者实现接口中的函数。
interface Study {  fun readBooks()  fun doHomework() }  class Student(val sno: String, val grade: Int, name: String, age: Int) : Person(name, age), Study {  constructor(name: String, age: Int) : this(&amp;#34;&amp;#34;, 0, name, age) {  //  }   constructor() : this(&amp;#34;&amp;#34;, 0) {  //  }   override fun readBooks() {  println(&amp;#34;$nameis reading&amp;#34;)  }   override fun doHomework() {  println(&amp;#34;$nameis doing homework.&amp;#34;)  } } 参考
exception is java.lang.IllegalArgumentException: Could not resolve placeholder &amp;#39;NEW_MYSQL_URL&amp;#39; in value &amp;#34;${NEW_MYSQL_URL}&amp;#34; </content>
    </entry>
    
     <entry>
        <title>使用Charles</title>
        <url>https://iihui.github.io/post/tool-charles/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  charles是一款用于iOS抓包的工具，可以将它设置成网络访问的代理服务器，使得所有网络访问请求都通过它来完成，从而实现网络封包的截取和分析，以作为网络访问的监视器。当App连接charles代理访问互联网时，charles可以监控这个App发送和接收的所有数据，这些信息包括request,response和headers（包含cookies与caching）。
 安装证书 首先打开Charles，然后点击菜单栏的Help，选择SSL Proxing，接着选中Install Charles Root Certificate on a Mobile Device or Remote Browser，步骤如下图所示：
然后会弹出下图所示提示：
根据上一步提示，应该先为手机上连接的WIFI设置代理(代理中的服务器IP地址和端口号具体值要根据Charles上一步给的提示进行设置)，详细步骤如下图所示：
根据提示，接着打开Safari浏览器，在地址栏输入chls.pro/ssl，点击前往，然后会弹出下载描述文件的界面，点击允许。等待描述文件下载好之后再打开系统设置，在头像下面会出现已下载描述文件（高版本系统在软件更新里面）：
点击已下载描述文件选项，会弹出下面安装页面，点击右上角安装按钮，接着会有警告，再次点击弹出的安装按钮即可，详细步骤如下图所示：
如果在手机上设置了WIFI的代理或者在浏览器中输入chls.pro/ssl后，若Mac OS上弹出如下图所示的提示框，则需要点击Allow按钮：
https抓包 安装好Charles生成的描述文件之后，就可以抓包，默认http的请求都可以直接查看，但https的请求不能直接查看，需要额外设置。有两种方式设置，第一种是直接在SSL Proxying Settings中设置，另外一种是在请求地址目录上选中然后右键设置Enable SSL Proxying。
第一种 打开Charles，在菜单栏中点击Proxy，再选中SSL Proxying Settings，如下图所示：
然后出现如下界面，点击Add按钮，把需要抓包的https请求地址加上即可：
第二种 第二种方式是在已请求的带锁的https地址上点击鼠标右键，然后选中Enable SSL Proxying。下次有同样的请求时，就可以看到请求的具体内容了，如下图所示：
下图一带锁的标志表示不能查看的https请求，需要设置Enable SSL Proxying之后才能查看，下图二设置之后的，蓝色表示可以查看具体的请求信息：
额外设置 如果抓包之后不能看到具体资源的名称，则需要到手机上的「设置&amp;mdash;&amp;gt;通用&amp;mdash;&amp;gt;关于本机&amp;mdash;&amp;gt;证书信任设置」中查看Charles Proxy CA ...是否信任，如果尚未信任，开启即可：
参考资料
503 若升级Charles版本后，抓包的时候出现所有请求都出现503，则需要在手机上检查一下是否未安装描述文件或描述文件已过期，这两种情况都需要安装新的描述文件。
在安装过程中若使用Safari浏览器打开http://chls.pro/ssl，提示已丢失网络连接或白屏打不开（具体什么原因暂不清楚），则需要手动将证书发送到手机端。即在MacOS上选择Help → SSL Proxying → Save Charles Root Certificate，将证书保存到本地，然后使用隔空投送到iPhone上，最后在设置中安装（高版本的iOS系统，需要到设置&amp;ndash;&amp;gt;软件更新里安装）。
Harmony Next抓包 首先将在MacOS上保存的证书文件，使用如下hdc命令将正式文件传到手机：
hdc file send /path/to/xxx.pem /storage/media/100/local/files/Docs/Download/ 接着进入原生Harmony Next手机，通过如下方式的一种安装证书：
  设置→ 隐私和安全 → 高级 → 证书与凭据 → 从存储设备安装 → CA证书→ 选择下载目录的证书文件→ 安装。
  或通过命令快速跳转安装界面，然后选择从存储设备安装 → CA证书→ 选择下载目录的证书文件→ 安装。
hdc shell aa start -a MainAbility -b com.ohos.certmanager   最后在原生鸿蒙手机上为连上的WIFI设置代理即可抓包。
</content>
    </entry>
    
     <entry>
        <title>刘海屏适配</title>
        <url>https://iihui.github.io/post/ios-layout/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  自从苹果推出刘海屏之后，App开发就要做相应的适配，适配过程通常会用到topLayoutGuide和bottomLayoutGuide或者safeAreaLayoutGuide。topLayoutGuide和bottomLayoutGuide是UIViewController的两个与view同级的只读属性。这两个属性是iOS 7.0引入的，而在iOS 11.0开始废弃。而safeAreaLayoutGuide是iOS 11.0之后才引入的，属于UIViewController中view的一个属性。
 topLayoutGuide  topLayoutGuide区分界面是否有导航栏。若没有导航栏，topLayoutGuide的顶部与状态栏顶部对齐，底部与状态栏的底部对齐。若有导航栏，topLayoutGuide的顶部与状态栏顶部对齐，底部与导航栏的底部对齐。
 private func topLayoutGuideTest(){  let view = UIView()  view.backgroundColor = .red  self.view.addSubview(view)  view.snp.makeConstraints(){ maker in  maker.leading.equalToSuperview()  maker.trailing.equalToSuperview()  maker.top.equalTo(self.topLayoutGuide.snp.top)  maker.bottom.equalTo(self.topLayoutGuide.snp.bottom)  } } 上面的代码对于根据是否有导航栏，表现是不同的。如下图一表示没有导航栏，图二表示有导航栏。
无导航栏 有导航栏 bottomLayoutGuide  bottomLayoutGuide要区分有没有是否刘海屏。对于刘海屏bottomLayoutGuide底部与手机屏幕底部对其，bottomLayoutGuide的顶部与底部圆角的顶部对齐；对于非刘海屏，bottomLayoutGuide的顶部和底部与都与屏幕底部对齐。
 private func bottomLayoutGuideTest(){  let view = UIView()  view.backgroundColor = .red  self.view.addSubview(view)  view.snp.makeConstraints(){ maker in  maker.leading.equalToSuperview()  maker.trailing.equalToSuperview()  maker.top.equalTo(self.bottomLayoutGuide.snp.top)  maker.bottom.equalTo(self.bottomLayoutGuide.snp.bottom)  } } private func bottomLayoutGuideTest(){  let view = UIView()  view.backgroundColor = .red  self.view.addSubview(view)  view.snp.makeConstraints(){ maker in  maker.leading.equalToSuperview()  maker.trailing.equalToSuperview()  maker.bottom.equalTo(self.bottomLayoutGuide.snp.top)  maker.height.equalTo(20)  } } self.view.addSubview(self.performanceView) self.performanceView.snp.makeConstraints { maker in  if #available(iOS 11.0, *) {  maker.trailing.equalTo(self.view.safeAreaLayoutGuide.snp.trailing).inset(20)  maker.bottom.equalTo(self.view.safeAreaLayoutGuide.snp.bottom).inset(15)  } else {  maker.trailing.equalToSuperview().inset(20)  maker.bottom.equalTo(self.bottomLayoutGuide.snp.top).inset(-15)  }  maker.width.equalTo(200)  maker.height.equalTo(40) }  safeAreaLayoutGuide  iOS 11.0之后引入了safe area，它用于定义视图的安全可视区域，可以保证在safe area区域内的子view不会被遮挡。UIKit定义的navigation controller、tabbar controller会展示一个顶部的导航栏或者底部的tabbar，也会遮挡一部分 child view controller的视图。safe area描述当前view不被父Controller的控件挡住的区域。
 private func safeAreaTest(){  let view = UIView(frame: .zero)  view.backgroundColor = .red  self.view.addSubview(view)  view.snp.makeConstraints(){ maker in  maker.leading.equalTo(self.view.safeAreaLayoutGuide.snp.leading)  maker.trailing.equalTo(self.view.safeAreaLayoutGuide.snp.trailing)  maker.top.equalTo(self.view.safeAreaLayoutGuide.snp.top)  maker.bottom.equalTo(self.view.safeAreaLayoutGuide.snp.bottom)  } } 底部适配 这两天在做一个选择器时需要在底部加两个按钮，这涉及到刘海屏的适配问题，可以在storyBoard中通过约束来实现适配，如下图所示：
也可以通过safeAreaLayoutGuide或者bottomLayoutGuide达到适配的目的，代码如下所示：
safeAreaLayoutGuide private func setupUI(){  let view = UIView()  view.backgroundColor = .red  self.view.addSubview(view)  view.snp.makeConstraints(){ maker in  maker.bottom.equalToSuperview()  maker.top.equalTo(self.view.safeAreaLayoutGuide.snp.bottom).inset(60)  maker.leading.equalToSuperview()  maker.trailing.equalToSuperview()  } } bottomLayoutGuide private func setupUI(){  let view = UIView()  view.backgroundColor = .red  self.view.addSubview(view)  view.snp.makeConstraints(){ maker in  maker.top.equalTo(self.bottomLayoutGuide.snp.top .inset(-60)  maker.bottom.equalToSuperview()  maker.leading.equalToSuperview()  maker.trailing.equalToSuperview()  } } 顶部适配 同样顶部的适配可以使用safeAreaLayoutGuide或者bottomLayoutGuide达到目的，代码如下所示：
safeAreaLayoutGuide private func setupUI2() {  let topView = UIView()  topView.backgroundColor = .blue   self.view.addSubview(topView)  topView.snp.makeConstraints { maker in  maker.leading.equalToSuperview()  maker.trailing.equalToSuperview()  maker.top.equalToSuperview()  maker.bottom.equalTo(self.view.safeAreaLayoutGuide.snp.top).inset(60)  } } topLayoutGuide private func setupUI3() {  let topView = UIView()  topView.backgroundColor = .blue   self.view.addSubview(topView)  topView.snp.makeConstraints { maker in  maker.leading.equalToSuperview()  maker.trailing.equalToSuperview()  maker.top.equalToSuperview()  maker.bottom.equalTo(self.topLayoutGuide.snp.bottom).inset(-60)  } } 参考资料
</content>
    </entry>
    
     <entry>
        <title>UITabBarController</title>
        <url>https://iihui.github.io/post/ios-uitabbar/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> 添加Tab 既可以直接添加UITabBarController到storyboard中，也可以在现有的ViewController中添加UITabBarController。
直接添加 如下图所示，在Xcode 12右上角点击&#43;号，然后输入Tab，在出现的提示中选中Tab Bar Controller，拖到storyboard，然后松开即可添加：
已有中添加 在已有的ViewController之前添加Tab Bar Controller，有两种方式。第一种是在storyboard编辑界面的右下角的Embed In中添加；另一种是在菜单栏的Editor下添加。
Storyboard编辑界面右下角 如下图所示，在storyboard中先选择已有的ViewController，如下图标号1所示，先选中左边第一个按钮，然后在标号2处点击，选中Tab Bar Controller:
添加Navigation 菜单栏Editor下 除了在storyboard右下角添加，也可以在菜单栏中添加。如下图所示，首先选中已有的ViewController，然后在菜单栏上选择Editor --&amp;gt; Embed In --&amp;gt; Tab Bar Controller:
双击检测 private let intervalThreshold: Double = 0.8 private var dkLastClickedDate: Date? = nil private var ePaperLastClickedDate: Date? = nil func tabBarController(_ tabBarController: UITabBarController, shouldSelect viewController: UIViewController) -&amp;gt; Bool {  if tabBarController.selectedIndex == 1,let nav = tabBarController.selectedViewController as? UINavigationController,let vc:NewsViewController = nav.visibleViewController  let date = Date()  switch vc.segmentedView.selectedIndex {  case 0:  if let lastDate = self.ePaperLastClickedDate, (date.timeIntervalSince1970 - lastDate.timeIntervalSince1970) &amp;lt; intervalThreshold {  NotificationCenter.default.post(name: .ePaperScrollToTopNotification, object: nil)  }  self.ePaperLastClickedDate = date  case 1:  if let lastDate = self.dkLastClickedDate, (date.timeIntervalSince1970 - lastDate.timeIntervalSince1970) &amp;lt; intervalThreshold {  NotificationCenter.default.post(name: .dkScrollToTopNotification, object: nil)  }  self.dkLastClickedDate = date  default:  break  }  }  return true } </content>
    </entry>
    
     <entry>
        <title>Go枚举</title>
        <url>https://iihui.github.io/post/go-iota/</url>
        <categories>
          <category>go</category>
        </categories>
        <tags>
          <tag>go</tag>
        </tags>
        <content type="html">  Go中没明确意义上的enum定义，但是可以借助iota来生成一组自增常量值来实现枚举，iota是一个比较奇怪的存在，它只能用在const的声明中，是一个从0开始的行数索引器。
 iota 按行递增 首先，iota是一个行数索引器,它是按行递增的。
const ( 	x1 = iota //x1=0 	x2 //x2=1 	x3 //x3=2 	x4 //x4=3 )  fmt.Println(x1, x2, x3, x4) //0 1 2 3 const ( 	_, _ = iota, iota * 10 //0 0*10 	a, b //1 1*10 	c, d //2 2*10 ) const ( 	_ = iota //iota 代表0 	KB = 1 &amp;lt;&amp;lt; (10 * iota) //iota 代表1 	MB //iota 代表2 	GB ) println(KB,MB,GB) //1024 1048576 1073741824  iota恢复 如果中断iota自增，则必须显式恢复，且后续自增按行序递增，而不是C&#43;&#43;语言中的enum那样按上一个取值递增。
const ( 	a = iota 	b // 1 	c = 100 // 中断iota的计数 	d // 100 	e = iota // 4，显式恢复，因为是行增，所以得到是4 	f // 5 ) fmt.Println(a, b, c, d, e, f) //0 1 100 100 4 5  多个iota 可在多常量中定义中使用多个iota，他们是各自单独计数，只须确保组中每行常量的列数量相同即可。
const ( 	_, _ = iota, iota 	a, b 	c, d ) fmt.Println(a, b, c, d) // 1 1 2 2 const中的iota自增默认数据类型是int，但也可显式指定类型。
const ( 	x = iota 	y float32 = iota //指定类型 	z = iota ) fmt.Println(x, y, z) //0 1 2  </content>
    </entry>
    
     <entry>
        <title>Go常量</title>
        <url>https://iihui.github.io/post/go-let/</url>
        <categories>
          <category>go</category>
        </categories>
        <tags>
          <tag>go</tag>
        </tags>
        <content type="html">  常量值必须是编译期间可确定的字符、字符串、数字或者布尔值。常量的类型可以指定，或者由编译器通过初始化值推断，不支持C或者C&#43;&#43;数字类型后缀。可在函数代码块中定义常量，不使用的常量不会引发编译错误。
 const x, y int = 12, 0x12 const s = &amp;#34;hello world&amp;#34; const c = &amp;#39;我&amp;#39; const ( 	i, f = 1, 0.123 	b = false ) 显式转换 在定义常量时，如果显式指定类型，必须确保常量左右值类型一致，需要时可做显式转换。右值不能超出常量类型的取值范围，否则会引发溢出错误。
const ( 	x, y int = 99, -999 	b byte = byte(x) //x是int类型必须显式转换为byte 	n = uint8(y) //转换溢出，会报错 ) 常量值也可以是某些编译器能够计算出结果的表达式，如unsafe.SizeOf,len,cap等。
const ( 	ptrSize = unsafe.Sizeof(uintptr(0)) 	strSize = len(&amp;#34;hello world&amp;#34;) ) 在常量组中如果不指定类型和初始值，则与上一行非空常量右值（表达式文本）相同。
const ( 	x uint16 = 120 	y 	s = &amp;#34;abc&amp;#34; 	z ) println(x, y, s, z) // 120 120 abc abc 没有地址 数字常量不会分配存储空间，无须像变量那样通过内存寻址来取值，因此无法获取地址，如下所示：
var x = 0x100 const y = 0x200 println(&amp;amp;x, x) println(&amp;amp;y, y) //cannot take the address of y  </content>
    </entry>
    
     <entry>
        <title>Go变量</title>
        <url>https://iihui.github.io/post/go-var/</url>
        <categories>
          <category>go</category>
        </categories>
        <tags>
          <tag>go</tag>
        </tags>
        <content type="html"> Go中每一个文件都以package声明开头，表明文件属于哪一个包。package声明后面是import声明，然后是不区分顺序的包级别的类型，变量、常量和函数的声明。对于包级别的声明不仅对于包含其声明的源文件可见，而且对于同一包里面的所有的源文件可见。
变量命名   以字母（这里指的是广义字母，只要能够被unicode编码即可）或下划线开始，由多个字母，数字下划线组合而成。尽管Go支持使用汉字等unicode字符命名，但从编程习惯上来说，这并不是最好的选择。
  在Go中变量的标识符是区分大小写。
  变量名首字母大小写决定了其作用域，首字母大写的为导出成员，可被外部不同的包使用，而小写仅能在包内使用。
  对变量标识符习惯上使用驼峰命名法。
  习惯上Go对专有名词通常会全部大写（这样一来这个专有名词就是可导出的了）。
  有一个名为_的特殊成员（称为空占位符），通常作为忽略占位符使用，可以用作表达式左值，但无法读取内容，即空标识符只写不读。
  空标识符可用来临时规避编译器对未使用变量和导入包的错误检查，但是它是预置成员，不能重新定义。 导入包时使用空标识符的目的是为了使用包中初始化函数以进行初始化，而一般的变量定义中使用空标识符是为了舍弃错误的处理（一般不建议这么做，因为出现错误时应当进行相应的处理）。
y,_ := strconv.Atoi(&amp;#34;12&amp;#34;) println(y)    变量声明 变量的声明方式有3种：①使用var关键字声明变量； ②使用简短模式； ③使用new函数来声明变量。
使用var定义变量 Go是一种静态类型语言，所以变量总需要有确定的类型，类型决定了变量的内存长度和存储格式。
var声明一个具体类型的变量，然后给它附加一个名字，设置它的初始值，每一个声明有一个通用的形式：
var name type = expression 这里的类型和表达式可以省略一个，但是不能全部省略。如果类型省略，那么变量的类型由表达式决定；如果表达式省略，则变量的初始值对应其类型零值。
var x int var y = false println(x,y) 运行时内存分配操作会确保变量自动初始化为二进制零值(zero value)。类型零值：对于数字是0，对于布尔型是false，对于字符串是“”，对于接口和引用类型（slice，指针，map，通道，函数）是nil。而对于数组，结构体这样的复合类型，零值是其所有元素或成员的零值。
  使用var定义变量，类型放在变量名后面var x int。这样的好处是定义多个指针变量时，不必每次都声明是指针变量。
  使用var进行变量定义的时候，可以使用初始值。使用初始值时，可以省略类型，Go会自动进行类型推导，例如var x = 12 此时x的类型被推导为int。
  同样可以一次可以定义多个变量，使用逗号隔开:  var x,y int。
  可以使用成组的方式定义个多个或多种变量，即使用一个var关键词定义多种类型的变量：
var (  y int  s = 100, &amp;#34;abc&amp;#34; //这一行两个变量，并且类型不相同 ) fmt.Println(x, y, a, s) //0 0 100 abc   赋值操作必须确保左右值类型相同，（有3种情况例外，详见基本类型中的类型转换规则）如果等式两边的类型不同则会出现编译错误。
  编译器将未使用「重新赋值不算做使用」的局部变量当作错误处理。全局定义的变量如果未使用，编译器不会报错；局部定义的变量一定要使用，并且重新赋值不算是使用。也就是说局部变量必须被读一次，编译器才不会报错。
  编译器确保变量总是被初始化类型0值，在函数内部还可以使用简略形式来定义变量。
var s = &amp;#34;hello world&amp;#34; // 使用类型推导，编译器将s的类型推导为string y := make([]int, 0, 5) //函数内部省略 var 关键字，更简单的模式 fmt.Println(y) //y是切片类型 for i := 0; i &amp;lt; 10; i&#43;&#43; {  y = append(y, i) //追加后重新赋值  } fmt.Println(y) //[0 1 2 3 4 5 6 7 8 9]   在Go中，var声明通常是为那些与初始化表达式类型不一致的局部变量保留的，或者用于后面才对变量赋值以及变量初始值不重要的情况。
   简短模式定义变量 还可以使用例如 x := 100这样的简短模式声明变量,但是简短模式具有以下限制：
  必须使用显式初始化。
  简短模式不能提供数据类型，Go会按照进行类型推导。
  只能在函数内部使用简短模式。
  简短模式并不总是变量定义，也可能是部分退化的赋值操作，退化赋值的前提是：至少有一个新变量被定义，且必须是同一作用域。
func test() { 	x := 200 	x1 := x &#43; 100  	if x1 &amp;gt; 0 { 	println(&amp;#34;x&amp;#34;) 	} else { 	println(&amp;#34;-x&amp;#34;) 	} 	x1, y := 200, &amp;#34;abc&amp;#34; // x1 是重新赋值，y是变量定义 	fmt.Println(x1, y) } x := 100 println(&amp;amp;x,x) { 	x, y := 200, 300 //定义了一个新变量 	println(&amp;amp;x, &amp;amp;y, x, y) } 多变量赋值操作时，总是首先计算出所有的右值，然后再依次完成赋值操作，即并行赋值。
x, y := 1, 2 x, y = y&#43;3, x&#43;2 //先计算出右值y&#43;3,x&#43;2,然后再依次完成赋值操作 fmt.Println(x, y)  使用new函数定义变量 new函数是Go中内置的函数，表达式new(T)创建一个未命名的T类型变量，初始化为T类型的零值，并返回其指针。
使用new创建的变量和取其地址的普通变量没有什么不同，只是不需要引入一个虚拟名字，因此new（T）只是在语法上的便利。下面两个newInt函数有同样的行为：
func newInt() *int { 	return new(int) }  func newInt() *int { 	var dummy int 	return &amp;amp;dummy }  </content>
    </entry>
    
     <entry>
        <title>snapkit 使用</title>
        <url>https://iihui.github.io/post/ios-snapkit/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> inset和offset  在描述view与superview关系时，应该使用inset，而描述view与同一层级的其它view时，应该使用offset。
 使用offset来设置距离子控件相对于父控件边距时，对于右边和下方的约束都需要加-号。这和在storyboard中设置约束不一致，显得有些不合理。
/* extension String { func boundingRect(with constrainedSize: CGSize, font: UIFont, lineSpacing: CGFloat? = nil) -&amp;gt; CGSize { let attritube = NSMutableAttributedString(string: self) let range = NSRange(location: 0, length: attritube.length) attritube.addAttributes([NSAttributedString.Key.font: font], range: range) if lineSpacing != nil { let paragraphStyle = NSMutableParagraphStyle() paragraphStyle.lineSpacing = lineSpacing! attritube.addAttribute(NSAttributedString.Key.paragraphStyle, value: paragraphStyle, range: range) } let rect = attritube.boundingRect(with: constrainedSize, options: [.usesLineFragmentOrigin, .usesFontLeading], context: nil) var size = rect.size if let currentLineSpacing = lineSpacing { // The height of the text minus the height of the font is less than or equal to the line spacing 1 line let spacing = size.height - font.lineHeight if spacing &amp;lt;= currentLineSpacing &amp;amp;&amp;amp; spacing &amp;gt; 0 { size = CGSize(width: size.width, height: font.lineHeight) } } return size } func boundingRect(with constrainedSize: CGSize, font: UIFont, lineSpacing: CGFloat? = nil, lines: Int) -&amp;gt; CGSize { if lines &amp;lt; 0 { return .zero } let size = boundingRect(with: constrainedSize, font: font, lineSpacing: lineSpacing) if lines == 0 { return size } let currentLineSpacing = (lineSpacing == nil) ? (font.lineHeight - font.pointSize) : lineSpacing! let maximumHeight = font.lineHeight * CGFloat(lines) &#43; currentLineSpacing * CGFloat(lines - 1) if size.height &amp;gt;= maximumHeight { return CGSize(width: size.width, height: maximumHeight) } return size } } */ func format(phoneNumber: String, shouldRemoveLastDigit: Bool = false) -&amp;gt; String {   guard !phoneNumber.isEmpty else {  return &amp;#34;&amp;#34;  }   guard let regex = try? NSRegularExpression(pattern: &amp;#34;[\\s-\\(\\)]&amp;#34;, options: .caseInsensitive) else {  return &amp;#34;&amp;#34;  }   let r = NSString(string: phoneNumber).range(of: phoneNumber)  var number = regex.stringByReplacingMatches(in: phoneNumber, options: .init(rawValue: 0), range: r, withTemplate: &amp;#34;&amp;#34;)   if number.count &amp;gt; 11 {  let tenthDigitIndex = number.index(number.startIndex, offsetBy: 11)  number = String(number[number.startIndex..&amp;lt;tenthDigitIndex])  }   if shouldRemoveLastDigit {  let end = number.index(number.startIndex, offsetBy: number.count - 1)  number = String(number[number.startIndex..&amp;lt;end])  }   if number.count &amp;lt; 7 {  let end = number.index(number.startIndex, offsetBy: number.count)  let range = number.startIndex..&amp;lt;end  number = number.replacingOccurrences(of: &amp;#34;(\\d{3})(\\d&#43;)&amp;#34;, with: &amp;#34;$1 $2&amp;#34;, options: .regularExpression, range: range)  } else {  let end = number.index(number.startIndex, offsetBy: number.count)  let range = number.startIndex..&amp;lt;end  number = number.replacingOccurrences(of: &amp;#34;(\\d{3})(\\d{4})(\\d*)&amp;#34;, with: &amp;#34;$1 $2 $3&amp;#34;, options: .regularExpression, range: range)  }   return number  } label.lineBreakMode = NSLineBreakByCharWrapping; //以字符为显示单位显示，后面部分省略不显示。 label.lineBreakMode = NSLineBreakByClipping; //剪切与文本宽度相同的内容长度，后半部分被删除。 label.lineBreakMode = NSLineBreakByTruncatingHead; //前面部分文字以……方式省略，显示尾部文字内容。 label.lineBreakMode = NSLineBreakByTruncatingMiddle; //中间的内容以……方式省略，显示头尾的文字内容。 label.lineBreakMode = NSLineBreakByTruncatingTail; //结尾部分的内容以……方式省略，显示头的文字内容。 label.lineBreakMode = NSLineBreakByWordWrapping; //以单词为显示单位显示，后面部分省略不显示。 参考资料
参考资料
</content>
    </entry>
    
     <entry>
        <title>富文本</title>
        <url>https://iihui.github.io/post/ios-richtext/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> 在文字后面添加红点 /// 使用富文本的方式在UILabel文本后面添加红点 /// - Parameter add: isNeedAdd 为true表示要加红点，否则不需要 /// - Returns: 处理后的富文本 func addRedDot(isNeedAdd: Bool) -&amp;gt; NSMutableAttributedString {  var text: String = (self.text ?? &amp;#34;&amp;#34;)  if isNeedAdd {  text &#43;= &amp;#34; &amp;#34;  let contentText = NSMutableAttributedString(string: text)  let attach = NSTextAttachment()  let dotImg = UIImage(named: &amp;#34;reddot&amp;#34;)  let width: CGFloat = 10  attach.bounds = CGRect(x: 0, y: 0.5, width: width, height: width)  attach.image = dotImg  let attrText = NSMutableAttributedString(attachment: attach)  attrText.insert(contentText, at: 0)  return attrText  } else {  let attrText = NSMutableAttributedString(string: text)  return attrText  } }  文字前面添加标签 /// 标题前面添加红底白字的标签，参考自https://www.jianshu.com/p/ab7ada727606 /// - Parameters: /// - category: 标签类别 /// - title: 真正的标题 func addCategoryBackground(category: String, title: String) -&amp;gt; NSMutableAttributedString {  // 设计要求title前面需要有空格  let contentText = NSMutableAttributedString(string: &amp;#34; &amp;#34; &#43; title)  let paragraphStyle = NSMutableParagraphStyle()  paragraphStyle.lineSpacing = self.lineSpace  paragraphStyle.lineBreakMode = .byWordWrapping  if #available(iOS 9.0, *) {  paragraphStyle.allowsDefaultTighteningForTruncation = true  }  // 设计要求category前后都需要有空格  let text = &amp;#34; &amp;#34; &#43; category &#43; &amp;#34; &amp;#34;  let width = calculateWidth(text: text, height: self.categoryHeight, font: UIFont.systemFont(ofSize: self.categoryFontSize, weight: .regular), maxWidth: CGFloat.greatestFiniteMagnitude)  let tmpLbl = UILabel(frame: CGRect(x: 0.0, y: 0.0, width: self.multiple * width, height: self.multiple * self.categoryHeight))  tmpLbl.text = text  tmpLbl.font = UIFont.systemFont(ofSize: self.multiple * self.categoryFontSize, weight: .regular)  tmpLbl.backgroundColor = UIColor.hexColor(&amp;#34;ed534d&amp;#34;)  tmpLbl.textColor = .white  tmpLbl.clipsToBounds = true  tmpLbl.cornerRadius = self.categoryCornerRadius  tmpLbl.textAlignment = .center  if let image = labelConvertToImage(view: tmpLbl) {  let attach = NSTextAttachment()  attach.bounds = CGRect(x: 0, y: self.categoryHeightSkewing, width: width, height: self.categoryHeight)  attach.image = image  let attrText = NSAttributedString(attachment: attach)  contentText.insert(attrText, at: 0)  let attributes = [NSAttributedString.Key.paragraphStyle: paragraphStyle]  contentText.addAttributes(attributes, range: NSRange(location: 0, length: contentText.length))  }  return contentText } /// 将UIView转换为UIImage，以便AttributedString使用图文混排 /// - Parameter view: 待转换的view /// - Returns: 转换后的图片 private func labelConvertToImage(view: UIView) -&amp;gt; UIImage? {  var image: UIImage? = nil  UIGraphicsBeginImageContext(view.bounds.size)  if let context = UIGraphicsGetCurrentContext() {  view.layer.render(in: context)  image = UIGraphicsGetImageFromCurrentImageContext()  UIGraphicsEndImageContext()  }  return image }  自动计算宽度 自动计算宽度分为两种，第一种以一个UILabel作为试探，使用sizeToFit()来计算；另一种是使用字符串的boundingRect来计算，如下代码所示：
/// 动态计算给定字符串在固定高度下的宽度，若小于最大宽度则返回实际宽度，否则返回最大宽度 /// - Parameters: /// - text: 待计算的字符串 /// - height: 固定的高度 /// - font: 固定的字体 /// - maxWidth: 允许最大的宽度 private func calculateWidth(text: String, height: CGFloat, font: UIFont, maxWidth: CGFloat) -&amp;gt; CGFloat {  let tmpLbl = UILabel(frame: CGRect(x: 0, y: 0, width: CGFloat.greatestFiniteMagnitude, height: height))  tmpLbl.numberOfLines = 0  tmpLbl.lineBreakMode = .byCharWrapping  tmpLbl.font = font  tmpLbl.text = text  tmpLbl.sizeToFit()  let width = tmpLbl.frame.width &amp;gt; maxWidth ? maxWidth : tmpLbl.frame.width  return width } /// 根据高度和字体大小计算字符串宽度 func widthWithConstrainedHeight(height: CGFloat, fontSize: CGFloat) -&amp;gt; CGFloat {  let constraintRect = CGSize(width: .greatestFiniteMagnitude, height: height)  let boundingBox = self.boundingRect(with: constraintRect, options: [.usesLineFragmentOrigin, .usesFontLeading], attributes: [NSAttributedString.Key.font: UIFont.systemFont(ofSize: fontSize)], context: nil)  return boundingBox.width }  </content>
    </entry>
    
     <entry>
        <title>Live JavaScript debug</title>
        <url>https://iihui.github.io/post/safari-debug/</url>
        <categories>
          <category>safari</category>
        </categories>
        <tags>
          <tag>safari</tag>
        </tags>
        <content type="html">  从2020年4月开始，Safari支持Live JavaScript debug，使得在使用safari调试时可以使用本地文件覆盖从服务端下载的资源文件。Safari浏览器支持3种方式创建本地覆盖。
 创建本地覆盖 第一种 首先选中某个文件，然后点击右上角创建覆盖的图标，就会创建当前文件的本地覆盖，如下图所示：
第二种 依然是首先选中某个文件，然后点击鼠标右键，选中创建本地覆盖，如下图所示：
第三种 在左下角点击新增按钮，然后选中本地覆盖，然后输入正确的url，如下图所示：
参考资料
参考资料
</content>
    </entry>
    
     <entry>
        <title></title>
        <url>https://iihui.github.io/post/ios-customizeuiview/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> class RecommendView: UIView {  @IBOutlet weak var imageView: UIImageView!  @IBOutlet weak var subTitleLbl: UILabel!  @IBOutlet weak var titleLbl: UILabel!   @IBOutlet var contentView: UIView!   override init(frame: CGRect) { //每一步都必须实现父初始化  super.init(frame: frame)  contentView = loadViewFromNib()  contentView.frame = bounds  addSubview(contentView)  }   //可视化IB初始化调用  required init?(coder aDecoder: NSCoder) {  super.init(coder: aDecoder)  contentView = loadViewFromNib()  contentView.frame = bounds  addSubview(contentView)  }   //MARK：自定义方法  func loadViewFromNib() -&amp;gt; UIView {  let nib = UINib(nibName: String(describing: RecommendView.self), bundle: Bundle(for: RecommendView.self))  let view = nib.instantiate(withOwner: self, options: nil)[0] as! UIView  return view  } } 参考资料
</content>
    </entry>
    
     <entry>
        <title>Swift 范型</title>
        <url>https://iihui.github.io/post/swift-generirs/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> 范型类型 Swift允许自定义的范型类型包括类、结构体、枚举类型。
struct Stack {  var items = [Int]()  mutating func push(_ item:Int){  items.append(item)  }  mutating func pop(_ item:Int) -&amp;gt; Int {  return items.removeLast()  } } //调用 var stack_int = Stack() stack_int.push(7) stack_int.push(3) stack_int.push(2) print(stack_int)//Stack(items: [7, 3, 2]) 类型约束 范型函数和范型类型虽然可以和任何类型一起使用，但有时需要限制使用的类型，此时就需要使用类型约束。例如Swift中Dictionary的Key便被约束为必须遵守hashable协议。
 类型约束是指指定类型参数必须继承自特定的类，遵守某个协议或协议组合。
 func someFunction&amp;lt;T: SomeClass, U: SomeProtocol&amp;gt;(someT: T, someU: U) {  // `T`约束为继承自`SomeClass`的类型 `U`约束为遵守`SomeProtocol` 协议的类型 }  func findIndex&amp;lt;T : Equatable&amp;gt;(of valueToFind: T, in array:[T]) -&amp;gt; Int? {  for (index, value) in array.enumerated() {  if value == valueToFind {  return index  }  }  return nil } 关联类型 在定义协议时，有时声明一个或多个关联类型作为协议定义的一部分是很有用的。关联类型的作用，主要是提供某个类型的占位名称，然后作为协议的一部分去使用。关联类型的实际使用类型直到协议被实现时才会指定。关联类型使用关键字associatedtype指定。
//定义协议使用类型关联 protocol Container {  associatedtype Item  mutating func append(_ item : Item)  var count : Int{get}  subscript(i:Int)-&amp;gt;Item{get} } //定义整型Stack类型 struct IntStack : Container {  var items = [Int]()  mutating func push(_ item:Int){  items.append(item)  }  mutating func pop(_ item:Int) -&amp;gt; Int {  return items.removeLast()  }  //实现协议时，需要明确关联类型的实际类型  typealias Item = Int //!&amp;lt; ①   mutating func append(_ item: Item) {//!&amp;lt; ①若不存在，此处可直接 Int  push(item)  }   var count: Int {  items.count  }  subscript(i: Int) -&amp;gt; Int {  items[i]  } } 摘抄自
</content>
    </entry>
    
     <entry>
        <title>Swift中defer</title>
        <url>https://iihui.github.io/post/swift-defer/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  从语言设计上来说，defer是为了进行资源清理和返回前避免重复执行相关代码。它不是用来取巧实现某些功能，如果这样做只会让代码的可读性降低。
 典型用法 Swift中defer声明的block会在当前代码块执行退出后调用。这种延迟调用特性，一般用来进行资源释放或避免重复代码。
func operateOnFile(descriptor: Int32) {  let fileHandle = FileHandle(fileDescriptor: descriptor)   let data = fileHandle.readDataToEndOfFile()   if /* onlyRead */ {  fileHandle.closeFile()  return  }   let shouldWrite = /* 是否需要写文件 */  guard shouldWrite else {  fileHandle.closeFile()  return  }   fileHandle.seekToEndOfFile()  fileHandle.write(someData)  fileHandle.closeFile() } 上面代码需要在不同地方调用fileHandle.closeFile()关闭文件，更好的方法是使用defer统一处理。defer既可以就近在资源申请的地方就声明释放，也减少了未来添加代码时忘记释放资源的可能性。
func operateOnFile(descriptor: Int32) {  let fileHandle = FileHandle(fileDescriptor: descriptor)  defer { fileHandle.closeFile() }  let data = fileHandle.readDataToEndOfFile()   if /* onlyRead */ { return }   let shouldWrite = /* 是否需要写文件 */  guard shouldWrite else { return }   fileHandle.seekToEndOfFile()  fileHandle.write(someData) } 作用域  A defer statement is used for executing code just before transferring program control outside of the scope that the defer statement appears in.
 一般认为defer是在函数退出时调用，实际上它是在当前scope退出时调用。在 if，guard，for，try这些语句中使用defer时，应该要特别注意。
func remove(_ id: ID, acquireLock: Bool) {  if acquireLock {  lock.lock()  defer {  lock.unlock()  }  }  tasks[id] = nil } 因为defer是在当前scope退出时调用，上面代码等同于：
func remove(_ id: ID, acquireLock: Bool) {  if acquireLock {  lock.lock()  lock.unlock()  }  tasks[id] = nil } 同理，下面的defer相关的代码只有need为true时才执行：
func deferTest(need: Bool) {  if need {  defer {  print(&amp;#34;defer&amp;#34;)  }  }  print(&amp;#34;outside&amp;#34;) }  deferTest(need: false) deferTest(need: true)  // 执行后的结果 outside defer outside defer闭包不持有值 虽然defer后面跟了一个闭包，但是它更多地像是一个语法糖，和我们所熟知的闭包不一样，它并不会捕获持有闭包里的值：
func foo() {  var number = 1  defer {  print(&amp;#34;Statement 2: \(number)&amp;#34;)  }  number = 100  print(&amp;#34;Statement 1: \(number)&amp;#34;) } 上面代码将会输出：
Statement 1: 100 Statement 2: 100 如果在defer中要依赖某个变量时，需要自行复制：
func foo() {  var number = 1  var closureNumber = number  defer {  print(&amp;#34;Statement 2: \(closureNumber)&amp;#34;)  }  number = 100  print(&amp;#34;Statement 1: \(number)&amp;#34;) }  foo()  Statement 1: 100 Statement 2: 1 执行时机 defer的执行时机紧接在离开作用域之后，但在其它语句之前。这个特性为defer带来了一些很微妙的使用方式。下面代码先执行返回语句，然后自增，所以输出为0，1，2而不是1，2，3：
class Foo {  var num = 0   func foo() -&amp;gt; Int {  defer {  num &#43;= 1  }  return num  } }  let f = Foo() f.foo() // 返回值为0，然后num再自增 f.foo() // 返回值为1，然后num再自增 f.num // 最后num的值为2 如果没有defer，可能需要按下面这样定义foo方法：
class Foo {  var num = 0  func foo() -&amp;gt; Int {  num &#43;= 1  return num - 1  } } let f11 = Foo() debugPrint(f11.foo(), f11.foo()) 参考资料
</content>
    </entry>
    
     <entry>
        <title>屏幕旋转</title>
        <url>https://iihui.github.io/post/ios-rotate/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  iOS开发时经常会遇到要将某些界面强制竖屏或者横屏。要做到某个页面能强制横竖屏的前提是允许屏幕旋转，然后再在具体的界面强制横竖屏。但是要区分这个具体的界面时push还是present呈现的。
 全局允许横竖屏 第一种方式，是在Target中的General下Device Orientation中设置，但是这种方式设置的允许横竖屏会被AppDelegate.swift中对应的代码覆盖，所以一般不在这里设置。设置方式如下图所示：
另一种方法是在AppDelegate.swift中设置允许横竖屏，如下代码所示：
func application(_ application: UIApplication, supportedInterfaceOrientationsFor window: UIWindow?) -&amp;gt; UIInterfaceOrientationMask {  return .all } 界面强制竖屏 对于以present方式呈现的界面，需要在当前界面所属的UIViewController中重写以下两个属性：
override var supportedInterfaceOrientations: UIInterfaceOrientationMask {  return .portrait } override var shouldAutorotate: Bool {  return false } 而对于以push方式呈现的界面，需要重写对应的UINavigationController中重写上面的两个属性。为了方便可以写一个继承自UINavigationController，然后将强制横竖屏的代码交给要push的界面，如下所示：
class RotatableNavigationController: UINavigationController {   override var shouldAutorotate : Bool {  return self.topViewController?.shouldAutorotate ?? super.shouldAutorotate  }   override var supportedInterfaceOrientations : UIInterfaceOrientationMask {  return self.topViewController?.supportedInterfaceOrientations ?? super.supportedInterfaceOrientations  } }  </content>
    </entry>
    
     <entry>
        <title>WCDB</title>
        <url>https://iihui.github.io/post/ios-wcdb/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> 自定义类型入库 自定义类型要遵循ColumnCodable才能入库：
enum UserOrgType: String, ColumnCodable {   case CMB = &amp;#34;CMB&amp;#34;  case ODC = &amp;#34;3&amp;#34;   static var columnType: ColumnType = .text   init(with value: FundamentalValue) {  self = UserOrgType(rawValue: value.stringValue) ?? UserOrgType.CMB  }   func archivedValue() -&amp;gt; FundamentalValue {  return FundamentalValue(self.rawValue)  } } /// 查看用户表是否为空 func isEmpty() -&amp;gt; Bool {  do {  let count = try DBManager_V2.shared.userDb.getValue(on: UserInfoModel_V2.CodingKeys.openId.count(), fromTable: tableName).int64Value  return count == 0  } catch let error {  printError(msg: error.localizedDescription, type: .db)  return true  } } </content>
    </entry>
    
     <entry>
        <title>UIAlertViewController</title>
        <url>https://iihui.github.io/post/ios-alertviewcontroller/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  最近使用UIAlertViewController时，需要定制其背景颜色，在网上找到一个解决方案，基本思路是为UIAlertViewController设置一个计算属性，这个属性改变时即将UIAlertViewController的背景色修改。
 添加计算属性 class AlertController: UIAlertController {  /// Buttons background color.  var buttonBackgroundColor: UIColor = .darkGray {  didSet {  // Invalidate current colors on change.  view.setNeedsLayout()  }  }   override func viewDidLayoutSubviews() {  super.viewDidLayoutSubviews()   // Traverse view hierarchy.  view.allViews.forEach {  // If there was any non-clear background color, update to custom background.  if let color = $0.backgroundColor, color != .clear {  $0.backgroundColor = buttonBackgroundColor  }  // If view is UIVisualEffectView, remove it&amp;#39;s effect and customise color.  if let visualEffectView = $0 as? UIVisualEffectView {  visualEffectView.effect = nil  visualEffectView.backgroundColor = buttonBackgroundColor  }  }  // Update background color of popoverPresentationController (for iPads).  popoverPresentationController?.backgroundColor = buttonBackgroundColor  } } 获取views extension UIView {  /// All child subviews in view hierarchy plus self.  fileprivate var allViews: [UIView] {  var views = [self]  subviews.forEach {  views.append(contentsOf: $0.allViews)  }  return views  } } 扩展VC extension UIViewController {   func notify(msg: String) -&amp;gt; Void {  let alert = UIAlertController(title: &amp;#34;&amp;#34;, message: msg, preferredStyle: .alert)  if let visualEffectView = alert.view.searchVisualEffectsSubview() {  visualEffectView.effect = UIBlurEffect(style: .light)  }   alert.setMessage(font: UIFont.systemFont(ofSize: 17))   present(alert, animated: true, completion: nil)  DispatchQueue.main.asyncAfter(deadline: .now() &#43; 1.5) { [weak self] in  self?.dismiss(animated: true)  }  } }   func searchVisualEffectsSubview() -&amp;gt; UIVisualEffectView? {  if let visualEffectView = self as? UIVisualEffectView {  return visualEffectView  } else {  for subview in subviews {  if let found = subview.searchVisualEffectsSubview() {  return found  }  }  }  return nil  } 定制字体和颜色 extension UIAlertController {   func setBackgroundColor(color: UIColor) {  if let bgView = self.view.subviews.first, let groupView = bgView.subviews.first, let contentView = groupView.subviews.first {  contentView.backgroundColor = color  }  }   func setTitle(font: UIFont?, color: UIColor? = nil) {  guard let title = self.title else {  return  }  let attributeString = NSMutableAttributedString(string: title)  if let titleFont = font {  attributeString.addAttributes([NSAttributedString.Key.font: titleFont],  range: NSMakeRange(0, title.count))  }   if let titleColor = color {  attributeString.addAttributes([NSAttributedString.Key.foregroundColor: titleColor],  range: NSMakeRange(0, title.count))  }  self.setValue(attributeString, forKey: &amp;#34;attributedTitle&amp;#34;)  }   func setMessage(font: UIFont?, color: UIColor? = nil) {  guard let message = self.message else {  return  }  let attributeString = NSMutableAttributedString(string: message)  if let messageFont = font {  attributeString.addAttributes([NSAttributedString.Key.font: messageFont],  range: NSMakeRange(0, message.count))  }   if let messageColor = color {  attributeString.addAttributes([NSAttributedString.Key.foregroundColor: messageColor],  range: NSMakeRange(0, message.count))  }  self.setValue(attributeString, forKey: &amp;#34;attributedMessage&amp;#34;)  }   func setTint(color: UIColor) {  self.view.tintColor = color  } }  </content>
    </entry>
    
     <entry>
        <title>linux 命令大全</title>
        <url>https://iihui.github.io/post/linux-base/</url>
        <categories>
          <category>linux</category>
        </categories>
        <tags>
          <tag>linux</tag>
        </tags>
        <content type="html">  这篇笔记是学习Linux命令大全的读书笔记，用于记录那些个人认为有用的命令，供后续查询。
 shell 是什么 df df命令用于磁盘驱动器当前的可用空间
free free命令可以显示可用内存
</content>
    </entry>
    
     <entry>
        <title>vim 学习</title>
        <url>https://iihui.github.io/post/tool-vim/</url>
        <categories>
          <category>vim</category>
        </categories>
        <tags>
          <tag>vim</tag>
        </tags>
        <content type="html"> 配置文件 vim从一个名为.vimrc（在类Unix系统中，以.开头的文件为隐藏文件，为了看到这些文件，可以运行ls -a命令行）的文件中读取配置信息。
syntax on &amp;#34;支持语法高亮显示 filetype plugin indent on &amp;#34;启用根据文件类型缩进 set autoindent &amp;#34;开启新行时处理缩进 set expandtab &amp;#34;将制表符Tab展开为空格 set tabstop=4 &amp;#34;要计算的空格数 set shiftwidth=4 &amp;#34;用于自动缩进的空格数 set backspace=2 &amp;#34;在多终端上修正退格键backspace的行为 colorscheme murphy &amp;#34;修改配色 打开文件 vim test.txt会打开一个名为test.txt的文件。如果该文件存在，则读者会看到它的内容，如果文件不存在，则得到一个空白界面。
清空内容 首先进入到命令模式，然后输入gg命令， 接着输入dG命令。
无提示生成ssh-key ssh-keygen -q -t rsa -C &amp;#34;xxx.com&amp;#34; -N &amp;#34;&amp;#34; -f ~/.ssh/id_rsa_yst &amp;lt;&amp;lt;&amp;lt;y &amp;gt;/dev/null 2&amp;gt;&amp;amp;1 </content>
    </entry>
    
     <entry>
        <title>Mach-O 文件</title>
        <url>https://iihui.github.io/post/ios-macho/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  Mach-O为Mach Object文件格式的缩写，它是一种用于可执行文件、目标代码、动态库的文件格式。
 文件类型 常见的MachO文件有下面这些，可以通过file&#43;文件路径来查看文件的类型信息：
 目标文件.o 库文件.a | .dylib | xxx.framework/xxx 可执行文件 符号表文件.dysm  通用二进制 通用二进制文件是一种能够同时兼容多种架构的二进制文件，常用的架构有arm64,arm64e,armv7,armv7s，除了能够兼容多种架构，还有以下特点：
  能够为不同的架构提供最理想的性能。
  因为要存储多种架构的代码，通用二进制程序包要比单一架构的二进制程序包大。
  因为多种架构只是代码不同，但资源相同，通用二进制的资源只有一份，所以并不会比单一架构的程序包大小多一倍。
  运行时也只执行对应架构的代码，不会占用多余的内存。
  lipo lipo可以用来合并真机包和模拟器包：
lipo -create [真机编译路径/xxx.framework/xxx] [模拟器编译路径/xxx.framework/xxx] -output [合并后输出的文件路径] 也可以用来从通用二进制文件中拆分出不同架构：
// 从通用二进制文件拆分出不同的架构 lipo [通用二进制文件路径] -thin [要拆的架构] -output [拆出的二进制输出的路径] MachO的文件结构 MachO文件分为Header、Load、commands、Data三部分，如下图所示：
切换cocoapods版本  sudo gem uninstall cocoapods  sudo gem uninstall cocoapods-art  sudo gem install cocoapods -v 1.5.3  sudo gem install cocoapods-art -v 1.0.3 参考资料
查看Ruby镜像地址命令：
gem sources -l 首先在浏览器中输入https://get.rvm.io，得到一个新的地址，然后替换下面的https://raw.githubusercontent.com/rvm/rvm/master/binscripts/rvm-installer即可：
curl -sSL https://raw.githubusercontent.com/rvm/rvm/master/binscripts/rvm-installer | bash -s stable 使用命令rvm install 2.6.10安装2.6.10时，出现了如下提示：
ruby-2.6.10 - #removing src/ruby-2.6.10 - please wait Searching for binary rubies, this might take some time. No binary rubies available for: osx/13.3/x86_64/ruby-2.6.10. Continuing with compilation. Please read &amp;#39;rvm help mount&amp;#39; to get more information on binary rubies. Checking requirements for osx. Certificates bundle &amp;#39;/usr/local/etc/openssl@1.1/cert.pem&amp;#39; is already up to date. Requirements installation successful. Installing Ruby from source to: /Users/hui/.rvm/rubies/ruby-2.6.10, this may take a while depending on your cpu(s)... ruby-2.6.10 - #downloading ruby-2.6.10, this may take a while depending on your connection... ruby-2.6.10 - #extracting ruby-2.6.10 to /Users/hui/.rvm/src/ruby-2.6.10 - please wait ruby-2.6.10 - #configuring - please wait ruby-2.6.10 - #post-configuration - please wait ruby-2.6.10 - #compiling - please wait Error running &amp;#39;__rvm_make -j6&amp;#39;, please read /Users/hui/.rvm/log/1688696617_ruby-2.6.10/make.log  There has been an error while running make. Halting the installation. transdb.h updated Undefined symbols for architecture x86_64:  &amp;#34;__mh_execute_header&amp;#34;, referenced from:  _rb_dump_backtrace_with_lines in addr2line.o ld: symbol(s) not found for architecture x86_64 clang: error: linker command failed with exit code 1 (use -v to see invocation) RVM修改默认Ruby版本:
rvm use 2.6.3 --default HostkeyAlgorithms &#43;ssh-rsa PubkeyAcceptedAlgorithms &#43;ssh-rsa https://zhuanlan.zhihu.com/p/577209888
</content>
    </entry>
    
     <entry>
        <title>创建私有库</title>
        <url>https://iihui.github.io/post/ios-private-pods/</url>
        <categories>
          <category>ios</category>
        </categories>
        <tags>
          <tag>ios</tag><tag>pod</tag>
        </tags>
        <content type="html">  使用cocoapods可以创建远程私有库，供项目使用。首先需要在github上创建一个远程索引库，然后使用cocopods在本地创建文件夹，并与远程私有库进行关联。再在github上创建远程组件库，接着使用pod创建本地工程，然后修改组件库的podspec文件，并将本地工程与远程组件库关联，打上与podspec文件中版本号一致的tag，然后提交，最后将podspec文件提交本地索引库。
 远程私有索引库 首先在github上创建一个私有库，用来存放私有库的详细描述信息，如下图所示：
本地私有索引库 在创建本地索引库之前，首先需要查看本地已存在的索引库，以免创建同名的本地索引库，如下所示：
pod repo 然后使用如下命令，将远程库添加到本地，以创建本地索引库：
pod repo add MoSpec https://github.com/***/MoSpec.git 添加之后，可以再使用pod repo查看本地已存在的索引库，如下所示多了一个本地索引库:
创建基础组件仓库 下面就本地创建WCDBSwift为例讲解基础组件库的创建。WCDBSwift依赖于HY_SQLiteRepairKit和HY_WCDBOptimizedSQLCipher，而HY_SQLiteRepairKit又依赖于HY_WCDBOptimizedSQLCipher，所以开始从HY_WCDBOptimizedSQLCipher组件库开始：
本地组件库 首先使用pod命令在本地创建组件库，如下所示：
pod lib create HY_WCDBOptimizedSQLCipher 然后将所有代码源文件Classes目录下：
远程组件库 接着在github上创建远程组件库，通常需要和本地库的名字保持一致，如下所示：
修改podspec 在给定的模版上修改podspec文件，注意s.version的值将于tag保持一致，而s.source则表示上一步创建的远程组件库的地址，如下所示：
# # Be sure to run `pod lib lint HY_WCDBOptimizedSQLCipher.podspec&amp;#39; to ensure this is a # valid spec before submitting. # # Any lines starting with a # are optional, but their use is encouraged # To learn more about a Podspec see https://guides.cocoapods.org/syntax/podspec.html #  Pod::Spec.new do |s|  s.name = &amp;#39;HY_WCDBOptimizedSQLCipher&amp;#39;  s.version = &amp;#39;0.1.0&amp;#39;  s.summary = &amp;#39;HY_WCDBOptimizedSQLCipher from WeChat WCDBOptimizedSQLCipher 1.2.1.&amp;#39;  # This description is used to generate tags and improve search results. # * Think: What does it do? Why did you write it? What is the focus? # * Try to keep it short, snappy and to the point. # * Write the description between the DESC delimiters below. # * Finally, don&amp;#39;t worry about the indent, CocoaPods strips it!   s.description = &amp;lt;&amp;lt;-DESC  private WCDBOptimizedSQLCipher from WeChat WCDBOptimizedSQLCipher 1.2.1.  DESC   s.homepage = &amp;#39;https://github.com/***/HY_WCDBOptimizedSQLCipher&amp;#39;  s.license = { :type =&amp;gt; &amp;#39;MIT&amp;#39;, :file =&amp;gt; &amp;#39;LICENSE&amp;#39; }  s.author = { &amp;#39;***&amp;#39; =&amp;gt; &amp;#39;****&amp;#39; }  s.source = { :git =&amp;gt; &amp;#39;https://github.com/***/HY_WCDBOptimizedSQLCipher.git&amp;#39;, :tag =&amp;gt; s.version.to_s }   s.ios.deployment_target = &amp;#39;9.0&amp;#39;   s.module_name = &amp;#39;sqlcipher&amp;#39;  s.source_files = &amp;#39;HY_WCDBOptimizedSQLCipher/Classes/*.{h,c}&amp;#39;,&amp;#39;HY_WCDBOptimizedSQLCipher/Classes/src/*.{h,c}&amp;#39;,&amp;#39;HY_WCDBOptimizedSQLCipher/Classes/ext/*.{h,c}&amp;#39;,&amp;#39;HY_WCDBOptimizedSQLCipher/Classes/ext/**/*.{h,c}&amp;#39; s.public_header_files = &amp;#39;HY_WCDBOptimizedSQLCipher/Classes/sqlite3.h&amp;#39;,&amp;#39;HY_WCDBOptimizedSQLCipher/Classes/ext/fts3/fts3_tokenizer.h&amp;#39; s.frameworks = &amp;#39;Security&amp;#39;, &amp;#39;Foundation&amp;#39; s.requires_arc = false s.xcconfig = { &amp;#39;GCC_PREPROCESSOR_DEFINITIONS&amp;#39; =&amp;gt; &amp;#39;SQLITE_ENABLE_FTS3 SQLITE_ENABLE_FTS3_PARENTHESIS SQLITE_ENABLE_API_ARMOR SQLITE_OMIT_BUILTIN_TEST SQLITE_OMIT_AUTORESET SQLITE_ENABLE_UPDATE_DELETE_LIMIT SQLITE_ENABLE_RTREE SQLITE_ENABLE_LOCKING_STYLE=1 SQLITE_SYSTEM_MALLOC SQLITE_OMIT_LOAD_EXTENSION SQLITE_CORE SQLITE_THREADSAFE=2 SQLITE_DEFAULT_CACHE_SIZE=250 SQLITE_DEFAULT_CKPTFULLFSYNC=1 SQLITE_DEFAULT_PAGE_SIZE=4096 SQLITE_OMIT_SHARED_CACHE SQLITE_HAS_CODEC SQLCIPHER_CRYPTO_CC USE_PREAD=1 SQLITE_TEMP_STORE=2 SQLCIPHER_PREPROCESSED HAVE_USLEEP SQLITE_MALLOC_SOFT_LIMIT=0 SQLITE_WCDB_SIGNAL_RETRY=1 SQLITE_DEFAULT_MEMSTATUS=0 SQLITE_ENABLE_COLUMN_METADATA SQLITE_DEFAULT_WAL_SYNCHRONOUS=1 SQLITE_LIKE_DOESNT_MATCH_BLOBS SQLITE_MAX_EXPR_DEPTH=0 SQLITE_OMIT_DEPRECATED SQLITE_OMIT_PROGRESS_CALLBACK SQLITE_OMIT_SHARED_CACHE OMIT_CONSTTIME_MEM OMIT_MEMLOCK SQLITE_ENABLE_FTS3_TOKENIZER SQLITE_WCDB_CHECKPOINT_HANDLER SQLITE_MMAP_READWRITE SQLITE_ENABLE_DBSTAT_VTAB SQLITE_ENABLE_FTS5&amp;#39;, &amp;#39;CLANG_WARN_CONSTANT_CONVERSION&amp;#39; =&amp;gt; &amp;#39;YES&amp;#39;, &amp;#39;GCC_WARN_64_TO_32_BIT_CONVERSION&amp;#39; =&amp;gt; &amp;#39;NO&amp;#39;, &amp;#39;CLANG_WARN_UNREACHABLE_CODE&amp;#39; =&amp;gt; &amp;#39;NO&amp;#39;, &amp;#39;GCC_WARN_UNUSED_FUNCTION&amp;#39; =&amp;gt; &amp;#39;NO&amp;#39;, &amp;#39;GCC_WARN_UNUSED_VARIABLE&amp;#39; =&amp;gt; &amp;#39;NO&amp;#39;, &amp;#39;CLANG_WARN_COMMA&amp;#39; =&amp;gt; &amp;#39;NO&amp;#39;, &amp;#39;CLANG_WARN_STRICT_PROTOTYPES&amp;#39; =&amp;gt; &amp;#39;NO&amp;#39;, &amp;#39;APPLICATION_EXTENSION_API_ONLY&amp;#39; =&amp;gt; &amp;#39;YES&amp;#39;} s.header_dir = &amp;#39;sqlcipher&amp;#39; end 检查podspec 在终端下转到工程目录下，然后执行pod lib lint命令，以检查下一步修改的podspec文件：
本地验证组件 在终端下转到Example目录下，然后执行pod install命令，然后打开Xcode在模拟器或者跑一下工程，未报错则本地验证通过：
上传到远程库 在终端下或者使用sourceTree将本地库添加的文件以及修改的podspec提交然后上传到远程库：
添加tag 然后给本地库添加跟s.version一样的tag，然后再push到远程库：
关联到本地索引库 在终端下转到本地组件工程目录，使用pod repo push MoSpec HY_WCDBOptimizedSQLCipher.podspec --allow-warnings命令将podspec文件提交到本地索引库，提交的时候依然会验证 podspec文件，验证通过后会自动上传到在远程spec`索引库。
 参考资料 参考资料
</content>
    </entry>
    
     <entry>
        <title>指定Podfile中source</title>
        <url>https://iihui.github.io/post/ios-pods-question/</url>
        <categories>
          <category>iOS</category><category>pod</category>
        </categories>
        <tags>
          <tag>iOS</tag><tag>pod</tag>
        </tags>
        <content type="html">  在笔记本上安装好Cocoapods之后，执行pod install后报trunk repo update failed，解决方案是在Podfile中指定另一个源仓库。
 报错信息 解决方案 解决方案是在Podfile中指定source，如下所示：
platform :ios, &amp;#39;8.0&amp;#39; source &amp;#39;https://github.com/CocoaPods/Specs.git&amp;#39; use_frameworks!  target &amp;#39;NewWCDB&amp;#39; do  pod &amp;#39;WCDB.swift&amp;#39; end 如上图所示，此时，执行pod install是正常的，但是执行pod search依然会报错，此时就需要将trunk移除：
pod repo remove trunk  参考资料
</content>
    </entry>
    
     <entry>
        <title>AutoLayout</title>
        <url>https://iihui.github.io/post/ios-autolayout/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  苹果公司推出的AutoLayout是一个基于约束，动态计算视图大小和位置的库。它以布局引擎系统Layout Engine为核心，采用了Cassowary布局算法，在简化布局思路的同时，还保证了布局的高效性。布局算法Cassowary能够有效解析线性等式系统和线性不等式系统，用来表示用户界面中那些相等关系和不等关系，通过设定约束来表示一个视图相对于另一个视图的位置。
 原理 在Layout Engine中，每当约束发生变化，会重新计算布局，获取到布局后会调用superview.setNeedLayout()，然后触发Deffered Layout Pass做容错处理，然后Layout Engine会从上到下调用layoutSubviews()来确定各子视图的位置，算出来后将子视图的frame从Layout Engine中拷贝出来，然后进行绘制、渲染。
几个更新方法的区别
  setNeedsLayout 告知页面需要更新，但是不会立刻开始更新，也就是先做一个标记。
  layoutIfNeeded 如果有需要刷新的标记，立即调用layoutSubViews进行布局；如果没有标记，不会调用layoutSubbViews。如果希望立即刷新frame，要先调用setNeedsLayout，把标记为需要布局，然后马上调用layoutIfNeeded实现布局。
  layoutSubviews 对subviews进行布局，不能主动调用，需要的时候在子类中重写，系统会在合适的时候调用。
  setNeedsUpdateConstraints 告知需要更新约束，但是不会立刻开始，也就是先做一个标记，调用updateConstraintsIfNeeded会查看该标记。
  updateConstraintsIfNeeded 告知立刻更新约束，如果有需要刷新约束的标记，则立即更新，否则不更新约束。
  updateConstraints 系统更新约束？？？。
  系统调layoutSubviews时机   使用init初始化不会触发layoutSubviews，但是使用initWithFrame进行初始化且rect不为zero时会调用layoutSubviews。
  调用addSubview的时候会触发系统调用layoutSubviews。
  当view的frame发生改变时触发layoutSubviews调用。
  滚动一个UIScrollView会触发layoutSubviews调用。
  旋转屏幕会触发父UIView上的layoutSubviews事件。
  改变一个UIView大小的时候也会调用父UIView上的layoutSubviews事件。
  固有内容大小 Intrinsic content size 就是固有内容大小，对应的是intrinsicContentSize计算属性。实际上，可以通过继承可以重写UIView的固有内容大小，达到定制的目的：
class TestView: UIView {  override var intrinsicContentSize: CGSize {  return CGSize(width: 300, height: 800)  } } UITableView高度计算 自动计算 当布局满足self-satisfied（设置约束时，只有一个不确定时，例如高度）时，系统会自动计算高度，缺点时慢，因为没有缓存高度，每次都要计算一次。
//首先在viewDidLoad中cell预估高度,设一个接近cell高度的值 self.tableView.estimatedRowHeight = 100;  //然后在设置返回automaticDimension override func tableView(_ tableView:UITableView, heightForRawAt: indexPath IndexPath) -&amp;gt; CGFloat {  return UITableView.automaticDimension }  摘抄自这里
</content>
    </entry>
    
     <entry>
        <title>不常见的关键字</title>
        <url>https://iihui.github.io/post/ios-keywords/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  使用Swift写代码时，经常会遇到一些不常见的关键词或者常用关键词的特殊使用场景，因为比较少使用，通常这些不常见的关键词或者特殊场景很容易忘记。
 便利构造函数 关键字convenience用于初始化器（构造函数）中，称之为便利初始化器（构造函数）。通常是在对一些系统类进行扩展时使用，下面是对UIColor进行扩展：
extension UIColor {   convenience init(hex: String) {  var cString: String = hex.trimmingCharacters(in: .whitespacesAndNewlines).uppercased()   if (cString.hasPrefix(&amp;#34;#&amp;#34;)) {  cString.remove(at: cString.startIndex)  }   assert(cString.count == 6, &amp;#34;无效的hex值&amp;#34;)   var rgbValue: UInt64 = 0  Scanner(string: cString).scanHexInt64(&amp;amp;rgbValue)   self.init(  red: CGFloat((rgbValue &amp;amp; 0xFF0000) &amp;gt;&amp;gt; 16) / 255.0,  green: CGFloat((rgbValue &amp;amp; 0x00FF00) &amp;gt;&amp;gt; 8) / 255.0,  blue: CGFloat(rgbValue &amp;amp; 0x0000FF) / 255.0,  alpha: CGFloat(1.0)  )  } } Swift为了保证安全，不加修饰的init方法需要保证所有的非Optional的实例属性都被初始化。此时，如果想写一个自定义构造函数，就一定要把类型中所有的非Optional的实例属性初始化，如果类型中很多实例属性将会变得很麻烦。此时便利初始化器就发挥作用了，它通常在对系统类进行初始化器扩展时使用。
  必须在构造函数中，而且必须调用本类的初始化器，不能调用父类的初始化器。
  其本身不负责属性的创建和初始化工作。
  不能被重写。
  </content>
    </entry>
    
     <entry>
        <title>Keyboard Maestro 使用</title>
        <url>https://iihui.github.io/post/tool-maestro/</url>
        <categories>
          <category>tool</category>
        </categories>
        <tags>
          <tag>tool</tag>
        </tags>
        <content type="html">  Keyboard Maestro是一款神奇的软件，在我心里它与Alfred同样重要，也是我的装机必备软件。使用它可以省去安装很多软件，这篇文章记录平常工作中使用它的一些特性或技巧，以便后续查阅。
 快捷输入 粘贴方式输入 模拟键盘输入 打开应用 可以设置全局快捷键打开某个应用程序，下面设置了快捷键control&#43;s打开Safari：
开启和关闭wifi 如果想要开启和关闭wifi，可以使用如下的方式：
窗口管理 左半屏 右半屏 最大化 全屏 去格式粘贴 复制当前行 焦点 切换到屏幕一 切换到屏幕二 Execute a Script in Terminal 如果想要在系统的Terminal中运行脚本可以在这里下载压缩文件，然后把压缩文件代表的Action整体拖动到Keyboard Maestro中。
Imported action already exit 按照上面方式已经导入的Action，如果再重新导入的话会报Imported action already exists错误。那么需要到~/Library/Application Support/Keyboard Maestro/Keyboard Maestro Actions/目录下删除对应的Action，然后再重新导入。
Execute a Script in iTerm2 参考这里的代码，我自己写了一个AppleScript脚本，结合plist文件创建了Keyboard Maestro的Action，代码和文件如下所示：
# Description: Part of a KM action. Passes a command or script to the Terminal. # Author: Tom Floeren &amp;lt;ecdltf@mac.com&amp;gt;, http://dflect.net # Version: 1.0.1 # Mod. Date: 2017-01-17  (* set winFront to system attribute &amp;#34;KMPARAM_Bring_Terminal_to_foreground&amp;#34; set winNew to system attribute &amp;#34;KMPARAM_New_Terminal_window&amp;#34; set theScript to do shell script &amp;#34;echo $KMPARAM_Script&amp;#34;  if winNew is &amp;#34;1&amp;#34; then 	tell application &amp;#34;iTerm&amp;#34; 	launch 	do script theScript 	if winFront is &amp;#34;1&amp;#34; then activate 	end tell else 	tell application &amp;#34;iTerm&amp;#34; 	launch 	if winFront is &amp;#34;1&amp;#34; then activate 	set windowCount to (count of the windows) 	if windowCount is greater than 0 then 	repeat with w from 1 to windowCount 	if window 1 is busy or history of window 1 contains &amp;#34;[Process completed]&amp;#34; then 	set frontmost of window 1 to false 	else 	do script theScript in window 1 	set frontmost of window 1 to true 	return 	end if 	end repeat 	end if 	tell window 1 	do script theScript 	set frontmost to true 	end tell 	end tell end if *)  set theScript to do shell script &amp;#34;echo $KMPARAM_Script&amp;#34; # do shell script &amp;#34;echo deploy&amp;#34; set winFront to system attribute &amp;#34;KMPARAM_Bring_iTerm_to_foreground&amp;#34; # &amp;#34;1&amp;#34; set winNew to system attribute &amp;#34;KMPARAM_New_iTerm_window&amp;#34; # &amp;#34;1&amp;#34; if winNew is &amp;#34;1&amp;#34; then 	tell application &amp;#34;iTerm&amp;#34; 	launch 	create window with default profile 	tell current session of current window 	write text theScript 	#display dialog theScript 	end tell 	if winFront is &amp;#34;1&amp;#34; then activate 	end tell else 	tell application &amp;#34;iTerm&amp;#34; 	launch 	if winFront is &amp;#34;1&amp;#34; then activate 	set windowCount to (count of the windows) 	if windowCount is 0 then 	create window with default profile 	tell current session of current window 	write text theScript 	#display dialog theScript 	end tell 	return 	end if 	tell current session of current window 	write text theScript 	#display dialog theScript 	end tell 	end tell end if &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;!DOCTYPE plist PUBLIC &amp;#34;-//Apple//DTD PLIST 1.0//EN&amp;#34; &amp;#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd&amp;#34;&amp;gt; &amp;lt;plist version=&amp;#34;1.0&amp;#34;&amp;gt; &amp;lt;dict&amp;gt; 	&amp;lt;key&amp;gt;Name&amp;lt;/key&amp;gt; 	&amp;lt;string&amp;gt;Execute a Script in iTerm&amp;lt;/string&amp;gt; 	&amp;lt;key&amp;gt;Script&amp;lt;/key&amp;gt; 	&amp;lt;string&amp;gt;Action.scpt&amp;lt;/string&amp;gt; 	&amp;lt;key&amp;gt;Icon&amp;lt;/key&amp;gt; 	&amp;lt;string&amp;gt;Icon.png&amp;lt;/string&amp;gt; 	&amp;lt;key&amp;gt;Title&amp;lt;/key&amp;gt; 	&amp;lt;string&amp;gt;Execute ‘%Param%Script%’ in iTerm&amp;lt;/string&amp;gt; 	&amp;lt;key&amp;gt;Author&amp;lt;/key&amp;gt; 	&amp;lt;string&amp;gt;Tom Floeren&amp;lt;/string&amp;gt; 	&amp;lt;key&amp;gt;Help&amp;lt;/key&amp;gt; 	&amp;lt;string&amp;gt;Execute a script or a script file in the iTerm application.&amp;lt;/string&amp;gt; 	&amp;lt;key&amp;gt;Results&amp;lt;/key&amp;gt; 	&amp;lt;string&amp;gt;None&amp;lt;/string&amp;gt; 	&amp;lt;key&amp;gt;Parameters&amp;lt;/key&amp;gt; 	&amp;lt;array&amp;gt; 	&amp;lt;dict&amp;gt; 	&amp;lt;key&amp;gt;Label&amp;lt;/key&amp;gt; 	&amp;lt;string&amp;gt;Script&amp;lt;/string&amp;gt; 	&amp;lt;key&amp;gt;Type&amp;lt;/key&amp;gt; 	&amp;lt;string&amp;gt;Text&amp;lt;/string&amp;gt; 	&amp;lt;key&amp;gt;Default&amp;lt;/key&amp;gt; 	&amp;lt;string&amp;gt;&amp;lt;/string&amp;gt; 	&amp;lt;/dict&amp;gt; 	&amp;lt;dict&amp;gt; 	&amp;lt;key&amp;gt;Label&amp;lt;/key&amp;gt; 	&amp;lt;string&amp;gt;New iTerm window&amp;lt;/string&amp;gt; 	&amp;lt;key&amp;gt;Type&amp;lt;/key&amp;gt; 	&amp;lt;string&amp;gt;Checkbox&amp;lt;/string&amp;gt; 	&amp;lt;key&amp;gt;Default&amp;lt;/key&amp;gt; 	&amp;lt;string&amp;gt;1&amp;lt;/string&amp;gt; 	&amp;lt;/dict&amp;gt; 	&amp;lt;dict&amp;gt; 	&amp;lt;key&amp;gt;Label&amp;lt;/key&amp;gt; 	&amp;lt;string&amp;gt;Bring iTerm to foreground&amp;lt;/string&amp;gt; 	&amp;lt;key&amp;gt;Type&amp;lt;/key&amp;gt; 	&amp;lt;string&amp;gt;Checkbox&amp;lt;/string&amp;gt; 	&amp;lt;key&amp;gt;Default&amp;lt;/key&amp;gt; 	&amp;lt;string&amp;gt;1&amp;lt;/string&amp;gt; 	&amp;lt;/dict&amp;gt; 	&amp;lt;/array&amp;gt; &amp;lt;/dict&amp;gt; &amp;lt;/plist&amp;gt; </content>
    </entry>
    
     <entry>
        <title>git 使用</title>
        <url>https://iihui.github.io/post/tool-git/</url>
        <categories>
          <category>tool</category>
        </categories>
        <tags>
          <tag>git</tag>
        </tags>
        <content type="html"> 清理文件 如果本地.git文件太大，可以使用git gc命令清理不必要的文件并优化本地存储库。gc是garbage collection的缩写:
git gc [--aggressive] [--auto] [--quiet] [--prune=&amp;lt;date&amp;gt; | --no-prune] [--force] [--keep-largest-pack] 大小写敏感 默认情况下git追踪的项目对文件名大小写是不敏感的，但是git提供了命令使得当前项目或者所有项目都能区分文件名的大小写。
如果只需要对当前项目设置文件名大小写敏感。首先打开终端，利用cd命令，将目录切换到需要修改的git仓库下，输入如下命令使其对文件名大小写敏感：
git config core.ignorecase false 如果想要实现所有项目都对文件名大小写敏感，就需进行全局设置。执行如下命令，就能改变git的全局设置，使得文件名大小写是敏感的：
git config --global core.ignorecase false errno 54 使用pod install时报了error: RPC failed; curl 56 LibreSSL SSL_read: SSL_ERROR_SYSCALL, errno 54错误，如下图所示：
原因是在拉取大文件时，设置的缓存太小，需要增加缓存。缓存设置包括http和https两种，可以使用如下命令进行设置：
git config --global http.postBuffer 1048576000 git config --global https.postBuffer 1048576000 rebase 整合来自不同分支的修改主要有两种方法，一种是Merge，一种是rebase。Merge会把两个分支的最新快照（C3和C4），以及二者最近的共同祖先（C2）进行三方合并，合并的结果是生成一个新的快照并提交。
还有一种方法：可以提取在C4中引入的补丁和修改，然后在C3的基础上应用一次。 在 Git中，这种操作就叫做「变基」（rebase）。 可以使用rebase命令将提交到某一分支上的所有修改都移至另一分支上。在上面的例子中，可以检出 experiment 分支，然后将它变基到 master 分支上：
git checkout experiment git rebase master 它的原理是首先找到这两个分支（即当前分支experiment、变基操作的目标基底分支master） 的最近共同祖先 C2，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件，然后将当前分支指向目标基底 C3, 最后以此将之前另存为临时文件的修改依序应用：
SourceTree中使用rebase
Device not Configured 因为修改了git密码，在PyCharm中运行脚本拉取代码时报错：could not find Username for ... Device not configured。此时需要使用交互式命令行，重新输入用户名和密码。例如，使用git push命令，就会在终端自动提示要输入用户名和密码：
[ruby-2.7.2]~/Documents/Code/Modules/LC10_01_MoCore:517 ✓ ➭ git push Username for &amp;#39;http://xxx&amp;#39;: xxx Password for &amp;#39;http://xxx&amp;#39;: Everything up-to-date 更改ssh方式 最近往github推送代码时，出现了报错：Support for password authentication was removed on August 13。详细提示如下所示:
nothing to commit, working tree clean remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead. remote: Please see https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/ for more information. fatal: unable to access &amp;#39;https://github.com/xxx/xxx.git/&amp;#39;: The requested URL returned error: 403 于是按照官方文档添加SSH Key，并添加到github，再push代码的时候依然报错。切到工程目录，使用git remote -v命令，发现原仓库clone的时候是HTTPS方式。需要使用git remote set-url 命令切换到SSH方式：
git remote -v git remote set-url origin git@github.com:username/xxx.git 修改commit时间 有时需要自定义或修改commit时间，如果想要修改本地待提交commit的时间，可以使用如下命令：
git commit --amend --date=&amp;#34;2022-01-01T00:00:00&#43;0800&amp;#34; -am &amp;#34;update&amp;#34; 如果需要修改之前提交的某次commit时间，首先通过git log获取提交的id，然后执行如下命令：
git commit --amend --date=&amp;#34;2022-01-01T00:00:00&#43;0800&amp;#34; -C 02219d93287a939c4fd7b4678c7e87b369ae0961 对于之前已经提交到远程仓库的提交，需要再执行一次git push推送到远程仓库。
exited with 128 执行 brew tap homebrew/core命令时出现如下报错，需要用户主目录下的.bash_profile文件中添加export PATH=/opt/homebrew/bin:$PATH才能解决：
=&amp;gt; Tapping homebrew/core Cloning into &amp;#39;/usr/local/Homebrew/Library/Taps/homebrew/homebrew-core&amp;#39;... fatal: unable to access &amp;#39;https://github.com/Homebrew/homebrew-core/&amp;#39;: HTTP/2 stream 1 was not closed cleanly before end of the underlying stream Error: Failure while executing; `git clone https://github.com/Homebrew/homebrew-core /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core --origin=origin --template=` exited with 128 参考资料
homebrew/core 使用 brew tap homebrew/core命令修复时出现Cannot tap homebrew/core: invalid syntax in tap
Cloning into &amp;#39;/usr/local/Homebrew/Library/Taps/homebrew/homebrew-core&amp;#39;... remote: Enumerating objects: 1227237, done. remote: Counting objects: 100% (67/67), done. remote: Compressing objects: 100% (38/38), done. remote: Total 1227237 (delta 37), reused 58 (delta 29), pack-reused 1227170 Receiving objects: 100% (1227237/1227237), 499.01 MiB | 1.23 MiB/s, done. Resolving deltas: 100% (847288/847288), done. Error: Invalid formula: /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core/Formula/libgccjit.rb libgccjit: undefined method `on_arm&amp;#39; for #&amp;lt;Class:0x00007fdaadec9110&amp;gt; Error: Cannot tap homebrew/core: invalid syntax in tap! 参考资料
加速访问github 可以通过修改host文件的方式将加快github的访问。首先下载SwithHosts工具，然后点点击左上角的&#43;，Hosts类型选择远程，输入title和URL即可：
https://raw.hellogithub.com/hosts https://gitee.com/fliu2476/github-hosts/raw/main/hosts Replace CDN 访问stackoverflow.com很慢，是因为它使用了Google的CDN。一种解决方案是将Google的CDN替换为国内的。具体按下面这个操作即可：
  下载 ReplaceGoogleCDN 然后解压，找到 extension 子目录。 打开Chrome，输入: chrome://extensions/。 勾选Developer Mode。 选择Load unpacked extension... 然后定位到刚才解压的文件夹里面的extension目录，点击确定。 这就安装好了，去掉 Developer Mode 勾选。   fatal: not in a git directory fatal: not in a git directory Error: Command failed with exit 128: git git config --global --add safe.directory /usr/local/Homebrew git config --global --add safe.directory /usr/local/Homebrew/Library/Taps/homebrew/homebrew-cask git config --global --add safe.directory /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core Error: No such file or directory @ rb_sysopen 执行了上面的命令后，还是出现Error: No such file or directory @ rb_sysopen，解决方案是单独使用brew命令安装依赖：
==&amp;gt; Installing dependencies for node: icu4c and libuv ==&amp;gt; Installing node dependency: icu4c ==&amp;gt; Pouring icu4c-70.1.monterey.bottle.tar.gz Error: No such file or directory @ rb_sysopen - /Users/hui/Library/Caches/Homebrew/downloads/2d9f30e8aed78118c54346d53e7e5b9ed0e04385816d1cf0453f22b6644f14ad--icu4c-70.1.monterey.bottle.tar.gz brew install icu4c brew install libuv 同步远程已经删除分支 最近发现本地存在很多在远端已经删除的分支，为了同步服务端的分支，可以在终端下执行如下命令：
git remote prune origin curl: (79) Error in the SSH layer 使用curl的过程中遇到下面这个报错，查资料发现是因为查看的是目录，而不是文件:
curl: (79) Error in the SSH layer # 查看的是目录 curl -k --user xxx sftp://192.168.1.101/home 如果使用curl的时候想使用sftp无密码的方式上传文件到某个服务器时，可以使用如下命令，即使用sftp将local-file传输到位于/path/to/file的远程服务器上，而无需密码。需要注意的是，这种方式不支持目录上传，只支持文件：
curl --key ~/.ssh/id_rsa --pubkey ~/.ssh/id_rsa.pub sftp://user@remote-server/path/to/file -T local-file 如果已经将ssh-key公钥加入到远程主机authorized_keys，则可以去掉上面的--key和--pubkey。如果要使用curl设置SFTP免密码登录，可以按照以下步骤操作：
  使用ssh-keygen命令生成公钥/私钥对。这将在主目录中创建一个公钥文件（通常命名为id_rsa.pub）和一个私钥文件（通常命名为id_rsa）。
  使用ssh-copy-id命令将公钥复制到远程服务器。这将把公钥添加到远程服务器上的authorized_keys文件中，允许无需密码登录。
  ssh-copy-id user@remote-server
 3. 运行以下命令测试无密码登录：  ```shell sftp user@remote-server 如果一切设置正确，您应该能够无需密码登录。
scp Host key verification failed. 将当前机器的ssh-key公钥加入到远程主机authorized_keys目录的前提下，使用scp命令复制本地文件到远程机器上时，出现如下错误：
Host key verification failed. scp: Connection closed 这是因为主机密钥没有匹配。主机密钥是一个唯一的标识符，用来验证远程主机的身份。当连接到一个远程主机时，主机密钥将被与已知的主机密钥列表进行验证。如果有匹配的，连接将被允许继续。如果不匹配，连接将被拒绝。
主机密钥也被用来为每个连接生成一个加密签名。该签名用于验证客户端和服务器之间传输的数据的完整性。当出现Host key verification failed时，意味着为你试图连接的主机存储的密钥已经改变。这通常是由于连接到与你最初连接的服务器不同的服务器造成的（例如，你的服务器被一个新的服务器重建了）。
每当我们通过SSH连接到一个服务器时，该服务器的公钥就存储在我们的主目录中。该文件被称为 known_hosts。这个文件是用户账户的本地文件，包含了远程主机的已知密钥。这些是在第一次连接时从主机上收集的。与那些存储在~/.ssh/known_hosts文件中的密钥一样，这些密钥被用来验证远程主机的身份，从而防止冒充或中间人攻击。
当我们重新连接到同一台服务器时，SSH连接将验证当前的公钥是否与我们保存在known_hosts文件中的公钥相符。如果匹配，连接将继续进行。如果匹配失败，SSH将失败，并出现错误信息Host key verification failed happens。参照这个解决方案，可以在使用scp命令时添加如下选项：
scp -o StrictHostKeyChecking=no </content>
    </entry>
    
     <entry>
        <title>CLion 添加Google test</title>
        <url>https://iihui.github.io/post/clion-test/</url>
        <categories>
          <category>Code</category>
        </categories>
        <tags>
          <tag>CLion</tag>
        </tags>
        <content type="html">  首先在github下载最新的googletest，解压之后重命名为googletest。然后将其放入到CLion工程目录下，接着修改工程的CMakeList.txt文件。最后，修改main函数，编写单元测试用例。
 下载 在github下载最新的googletest，解压之后命名为googletest，然后将其放在工程目录下：
修改CMkeLists 接着修改CMakeLists.txt文件，使其将googletest纳入到工程中，以供使用：
cmake_minimum_required(VERSION 3.15) project(test)  set(CMAKE_CXX_STANDARD 14)  set(googleTestDir ./googletest)  #Add the google test subdirectory add_subdirectory(${googleTestDir}) #include googletest/include dirinclude_directories(${googleTestDir}/googletest/include) #include the googlemock/include dirinclude_directories(${googleTestDir}/googlemock/include)  set(SOURCE_FILE main.cpp) add_executable(test ${SOURCE_FILE})  # Link with GoogleTest target_link_libraries(test gtest gtest_main) #Link with GoogleMock target_link_libraries(test gmock gmock_main) 修改main.cpp CLion重新加载CMakeLists.txt文件未报错之后，开始按下面修改main.cpp文件：
#include &amp;lt;iostream&amp;gt;#include &amp;#34;gtest/gtest.h&amp;#34;int main(int argc, char** argv) {  testing::InitGoogleTest(&amp;amp;argc, argv);  return RUN_ALL_TESTS(); } 单元测试 最后按照googletest的语法规则编写测试用例，如下所示：
#include &amp;lt;iostream&amp;gt;#include &amp;#34;gtest/gtest.h&amp;#34; int add(int a, int b){  return a&#43;b; }  TEST(test1, add){  EXPECT_EQ(3, add(1,2));  EXPECT_EQ(0, add(-1,1)); }  int main(int argc, char** argv) {  testing::InitGoogleTest(&amp;amp;argc, argv);  return RUN_ALL_TESTS(); }  参考资料 参考资料
</content>
    </entry>
    
     <entry>
        <title>where 关键字</title>
        <url>https://iihui.github.io/post/ios-where/</url>
        <categories>
          <category>ios</category>
        </categories>
        <tags>
          <tag>swift</tag><tag>ios</tag>
        </tags>
        <content type="html">  Swift中的where关键字主要用于限定条件，既可在switch语句中使用，也可以在for中使用，还可以用在扩展中用于限定应该遵循某种协议。
 Usage in a switch 在switch语句中使用，关键字where一般是配合case let一起用于限定条件：
let names = [&amp;#34;dog&amp;#34;, &amp;#34;cat&amp;#34;, &amp;#34;fish&amp;#34;, &amp;#34;bigDog&amp;#34;, &amp;#34;bigCat&amp;#34;, &amp;#34;bigFish&amp;#34;] names.forEach {  switch $0 {  case let name where name.hasPrefix(&amp;#34;big&amp;#34;):  print(&amp;#34;wow this is a \(name)&amp;#34;)  default:  break  } }  let temperature = 54 switch temperature { case 0...49 where temperature % 2 == 0:  print(&amp;#34;Cold and even&amp;#34;) case 50...79 where temperature % 2 == 0:  print(&amp;#34;Warm and even&amp;#34;) case 80...110 where temperature % 2 == 0:  print(&amp;#34;Hot and even&amp;#34;) default:  print(&amp;#34;Temperature out of range or odd&amp;#34;) } Usage in a for loop 在for in使用where可用于添加限定条件，同filter函数具有相同的效果：
let names = [&amp;#34;dog&amp;#34;, &amp;#34;cat&amp;#34;, &amp;#34;fish&amp;#34;, &amp;#34;bigDog&amp;#34;, &amp;#34;bigCat&amp;#34;, &amp;#34;bigFish&amp;#34;] for name in names where name == &amp;#34;dog&amp;#34; {  print(&amp;#34;\(name)&amp;#34;) } Usage in first 在集合类型中的first方法中where用于限定条件：
// Returns John let firstJName = names.first(where: { name in  return name.first == &amp;#34;J&amp;#34; }) debugPrint(firstJName as Any) Usage in contains 在集合类型中的contains方法中where用于限定条件：
let fruits = [&amp;#34;Banana&amp;#34;, &amp;#34;Apple&amp;#34;, &amp;#34;Kiwi&amp;#34;] // Return ture let containsBanana = fruits.contains(where: { fruit in  return fruit == &amp;#34;Banana&amp;#34; }) Usage in protocol extensions 在扩展中使用where，目的也是进行限定。即希望扩展需要满足某些限定的条件下才可以用:
extension ContiguousArray where Element: BidirectionalCollection {  public func joined() -&amp;gt; FlattenBidirectionalCollection&amp;lt;ContiguousArray&amp;lt;Element&amp;gt;&amp;gt; }  extension ContiguousArray where Element: Sequence {  public func joined&amp;lt;Separator&amp;gt;(separator: Separator) -&amp;gt; JoinedSequence&amp;lt;ContiguousArray&amp;lt;Element&amp;gt;&amp;gt; where Separator: Sequence, Separator.Element == Element.Element }  extension Array where Element: Comparable {  public var isSorted: Bool {  var preIndex = startIndex  var curIndex = startIndex &#43; 1   while curIndex != endIndex {  if self[preIndex] &amp;gt; self[curIndex] {  return false  }  preIndex = curIndex  curIndex &#43; 1  }  return true  } }   extension Array where Element == Int {  func printAverageAge() {  let total = reduce(0, &#43;)  let average = total / count  print(&amp;#34;Average age is \(average)&amp;#34;)  } }  let ages = [20, 26, 40, 60, 84] ages.printAverageAge() // Average age is 46 Usage in initialisers extension String {  init&amp;lt;T: Collection&amp;gt;(collection: T) where T.Element == String {  self = collection.joined(separator: &amp;#34;,&amp;#34;)  } }  let clubs = String(collection: [&amp;#34;AJAX&amp;#34;, &amp;#34;Barcelona&amp;#34;, &amp;#34;PSG&amp;#34;]) print(clubs)  // prints &amp;#34;AJAX, Barcelona, PSG&amp;#34; case if case 语句case let x = y允许检查y是否能匹配x，而if case let x = y { ... }严格等同于 switch y { case let x : ...}，当只想与一条case匹配时，这种紧凑的语法更有用：
enum Media {  case Book(title: String, author: String, year: Int)  case Movie(title: String, director: String, year: Int)  case WebSite(urlString: String) } let media = Media.Movie(title: &amp;#34;Captain America: Civil War&amp;#34;, director: &amp;#34;Russo Brothers&amp;#34;, year: 2016)  if case let Media.Movie(title, _, _) = media {  debugPrint(&amp;#34;This is a movie named \(title)&amp;#34;) }  guard let url = URL(string: &amp;#34;https://www.baidu.com&amp;#34;) else {  return } let result = Result { try Data(contentsOf: url) } if case let .failure(error) = result {  // Handle error  print(error) }  let newStr: String? = nil if case .none = newStr {  debugPrint(&amp;#34;case .none&amp;#34;) }  if case .some(true) = newStr?.isEmpty {  debugPrint(&amp;#34;is Empty&amp;#34;) }  let age = 8 if case 0..&amp;lt;18 = age, age % 2 == 0 {  print(&amp;#34;未成年,而且年纪是3的倍数!&amp;#34;) } guard case enum NetworkResponse {  case Response(URLResponse, Data)  case Error(NSError) } func processRequestResponse(response: NetworkResponse) {  guard case let .Response(urlResp, data) = response,  let httpResp = urlResp as? HTTPURLResponse  , 200..&amp;lt;300 ~= httpResp.statusCode  else {  debugPrint(&amp;#34;Invalid response, can&amp;#39;t process&amp;#34;)  return  }  debugPrint(&amp;#34;Processing \(data.count)bytes…&amp;#34;) } for case let mediaList: [Media] = [  .Book(title: &amp;#34;Harry Potter and the Philosopher&amp;#39;s Stone&amp;#34;, author: &amp;#34;J.K. Rowling&amp;#34;, year: 1997),  .Movie(title: &amp;#34;Harry Potter and the Philosopher&amp;#39;s Stone&amp;#34;, director: &amp;#34;Chris Columbus&amp;#34;, year: 2001),  .Book(title: &amp;#34;Harry Potter and the Chamber of Secrets&amp;#34;, author: &amp;#34;J.K. Rowling&amp;#34;, year: 1999),  .Movie(title: &amp;#34;Harry Potter and the Chamber of Secrets&amp;#34;, director: &amp;#34;Chris Columbus&amp;#34;, year: 2002),  .Book(title: &amp;#34;Harry Potter and the Prisoner of Azkaban&amp;#34;, author: &amp;#34;J.K. Rowling&amp;#34;, year: 1999),  .Movie(title: &amp;#34;Harry Potter and the Prisoner of Azkaban&amp;#34;, director: &amp;#34;Alfonso Cuarón&amp;#34;, year: 2004),  .Movie(title: &amp;#34;J.K. Rowling: A Year in the Life&amp;#34;, director: &amp;#34;James Runcie&amp;#34;, year: 2007),  .WebSite(urlString: &amp;#34;https://en.wikipedia.org/wiki/List_of_Harry_Potter-related_topics&amp;#34;) ] debugPrint(&amp;#34;Movies only:&amp;#34;) for case let Media.Movie(title, _, year) in mediaList {  debugPrint(&amp;#34; - \(title)(\(year))&amp;#34;) } 不同于if case，在for case中可以使用where：
debugPrint(&amp;#34;All mediums with a title starting with &amp;#39;Harry Potter&amp;#39;&amp;#34;) for case let (title?, kind) in mediaList.map({ ($0.title, $0.kind) })  where title.hasPrefix(&amp;#34;Harry Potter&amp;#34;) {  debugPrint(&amp;#34; - [\(kind)] \(title)&amp;#34;) } 参考资料 参考资料
WKURLSchemeTask重定向 参考资料1
参考资料2
参考资料3
</content>
    </entry>
    
     <entry>
        <title>Swift 方法交换中的addMethod</title>
        <url>https://iihui.github.io/post/ios-addmethod/</url>
        <categories>
          <category>Swift</category><category>iOS</category>
        </categories>
        <tags>
          <tag>Swift</tag><tag>iOS</tag>
        </tags>
        <content type="html">  Swizzle是OC的黑魔法之一，可以在运行时对两个方法的实现进行交换，也就是s用户可以用自己的方法替换原来的方法实现，做一些其它事情。Swift也可以使用运行时的方法交换，如果要了解Swift的方法交换，首先应该了解class_addMethod这个方法的作用。
 class_addMethod 要了解class_addMethod方法的作用，首先看下面的这段代码，在下面的代码中直接交换了originalSelector和swizzledSelector
extension NSObject {  static func swizzlingForClass(_ forClass: AnyClass, originalSelector: Selector, swizzledSelector: Selector) {  guard let originalMethod = class_getInstanceMethod(forClass, originalSelector),  let swizzledMethod = class_getInstanceMethod(forClass, swizzledSelector) else {  return  }  method_exchangeImplementations(originalMethod, swizzledMethod)  } } 存在的问题 假设父类名为method的方法，子类未重写这个method方法，子类的中想要用来交换的方法为swizzledMethod。如果按照上面的方法交换时，因为父类有该方法，而子类未重写该方法，所以调用class_getInstanceMethod得到的是父类的method方法，所以它与子类的swizzledMethod方法进行交换需要分两种情形来讨论：
  如果在子类实例中调用method方法时，因为已经与自己的swizzledMethod方法交换，所以实际上调用的自己swizzledMethod，所以能够正常运行。
  如果在父类的实例中调用method方法，因为已经与子类的swizzledMethod方法交换，所以调用的是子类的swizzledMethod方法。也就是说此时是父类调用子类的方法，所以会崩溃。
  根据上面的讨论，首先应该判断子类是否重写了method方法，如果实重写了父类的该方法则直接进行交换。如果没有重写父类的该方法，则应该先在父类中新建一个同名的方法。为了新建一个同名的方法，首先应当了解class_addMethod这个函数。
完善的方案 根据上面的分析，先来看一下class_addMethod的函数原型，如下所示：
@available(iOS 2.0, *) public func class_addMethod(_ cls: AnyClass?, _ name: Selector, _ imp: IMP, _ types: UnsafePointer&amp;lt;Int8&amp;gt;?) -&amp;gt; Bool 这个方法的作用是在一个类中添加一个新方法(名字&#43;实现）,class_addMethod函数中参数的含义为下：
  cls表示需要添加方法的类
  name表示要添加的方法的selector（方法名，这里的方法名是一个结构体）
  imp 表示要添加的方法的实现的指针IMP（定义在这里)）
  types用来描述方法参数的字符串数组
  如果cls中含有name则添加失败，返回false。这个方法会重写cls父类中与name同名的方法，但是不会替换cls中已经存在的与cls同名的方法。但是，如果想要替换cls中与name同名的方法，应该调用method_setImplementation。
  因此，可以使用class_addMethod方法的返回值来确定当前类中是否存在能够交换的方法，如果存在(添加失败)则直接交换。
let didAddMethod: Bool = class_addMethod(object, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)) 上面的代码中如果didAddMethod返回为false，则说明可以直接进行方法交换，如果返回值为true，则说明在子类中添加originalSelector成功，并且originalSelector指向了子类的swizzledMethod的实现。但是swizzledSelector的实现还是它原来的实现，接下来就要将swizzledSelector指向originalMethod的实现。因此，完整的代码应该如下所示：
static func exchangeSelector(object:AnyClass,originalSelector: Selector, swizzledSelector: Selector) {  guard let originalMethod = class_getInstanceMethod(object, originalSelector) else {  return  }  guard let swizzledMethod = class_getInstanceMethod(object, swizzledSelector) else {  return  }  let didAddMethod: Bool = class_addMethod(object, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod))   if didAddMethod {  class_replaceMethod(object, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod))  } else {  method_exchangeImplementations(originalMethod, swizzledMethod)  } } 构建工具类 因为当前App埋点的时候很多地方需要使用到方法交换，因此决定写一个专门的工具类来实现Swift的方法交换，如下所示：
class MethodSwizzlingTools {  static func exchangeSelector(object: AnyClass, originalSelector: Selector, swizzledSelector: Selector) {  //对于class_getInstanceMethod方法，若类没有实现对应的方法，但父类实现了，则这个函数会返回父类的方法  guard let originalMethod = class_getInstanceMethod(object, originalSelector) else {  return  }  guard let swizzledMethod = class_getInstanceMethod(object, swizzledSelector) else {  return  }   //参考https://juejin.im/post/5cb6df44e51d456e6f45c6f1  let didAddMethod: Bool = class_addMethod(object, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod))   if didAddMethod {  class_replaceMethod(object, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod))  } else {  method_exchangeImplementations(originalMethod, swizzledMethod)  }  }   //交换两个不同类的方法，这两个类应该满足父子关系  static func exchangeSelector(originalClass: AnyClass, originalSelector: Selector, swizzledClass: AnyClass, swizzledSelector: Selector) {  guard let originalMethod = class_getInstanceMethod(originalClass, originalSelector), let swizzledMethod = class_getInstanceMethod(swizzledClass, swizzledSelector) else {  return  }   let didAddMethod: Bool = class_addMethod(originalClass, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod))   if didAddMethod {  class_replaceMethod(swizzledClass, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod))  } else {  method_exchangeImplementations(originalMethod, swizzledMethod)  }  } } 参考资料 参考资料
</content>
    </entry>
    
     <entry>
        <title>Any,AnyObject,AnyClass</title>
        <url>https://iihui.github.io/post/ios-any/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>swift</tag><tag>iOS</tag>
        </tags>
        <content type="html">  最近在看Swift中的方法交换，遇到Any、AnyObject与AnyClass次数较多，所以在网上找了一些文章看了一下他们的区别，以此篇为记。
 AnyObject AnyObject类似于OC中的id类型，表示任意的class类型。但在Swift中由于String、Array等都变成结构体了，AnyObject的适用范围就变窄了。
实际上AnyObject是一个成员为空的协议@objc public protocol AnyObject {}。它注释的第一行:The protocol to which all classes implicitly conform表明所有的类都隐式遵守了这个协议。
Any Any也是一个协议，根据其注释The protocol to which all types implicitly conform.表明所有的类型都遵守该协议，包括基本数据类型，enum, struct, func等等。因此Any可以表示任何类型的实例，包括函数类型
AnyClass 而AnyClass表示任意类的元类型，其定义为typealias AnyClass = AnyObject.Type。根据定义可知它为AnyObject.Type的别名。
AnyObject.Type中的.Type就是获取元类型。例如，对于Student类，Student.Type就是获取Student的元类型。再根据注释The protocol to which all class types implicitly conform，可知道所有的类的类型都隐式遵守这个协议。
self 于Self 在Swift中，.self可以用在类型后面取得类型本身，也可以在某个实例后面取得这个实例本身。定义协议的时候经常会使用Self，它不仅指代的是实现该协议的类型本身，也包括了这个类型的子类。
重要区别 AnyObject代表任意class类型的对象实例，Any代表任意类型，甚至包括方法类型，所以AnyObject是Any的子集。
类型转换 操作符is检查一个实例是否某个确定的类或者其子类类型，如果是则返回true，否则返回false。
class Cat {  func hairColor() -&amp;gt; String {  return &amp;#34;五颜六色&amp;#34;  } } class WhiteCat: Cat {  override func hairColor() -&amp;gt; String {  return &amp;#34;白色&amp;#34;  } } class BlackCat: Cat {  override func hairColor() -&amp;gt; String {  return &amp;#34;黑色&amp;#34;  } } //必须符合`Cat`类以及其子类，类型推断需要 let kinds = [WhiteCat(),BlackCat(),WhiteCat(),WhiteCat()] for item in kinds {  if item is WhiteCat {  print(&amp;#34;白猫&amp;#34;)// 3次  }  if item is BlackCat {  print(&amp;#34;黑猫&amp;#34;)// 1次  }  if item is Cat {  print(&amp;#34;猫&amp;#34;)// 4次  } } 向下转换 某个类型的常量或变量可能是其子类的实例，此时需要用到类型转换操作as？或as!向下转换为子类类型
  as?：类型转换的条件形式，向下转换为某个类型时，返回该类型的可选值，即转换失败时返回nil。
  as!：类型转换的强制形式，向下转换为某个类型时，会进行强制解包，即：转换失败时触发运行时错误。除非十分确定类型转换会成功，否则不建议使用该模式。
  参考资料 参考资料 参考资料
</content>
    </entry>
    
     <entry>
        <title>UIControl</title>
        <url>https://iihui.github.io/post/ios-uicontrol/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  UIControl是UIView的子类，也是UIResponder的子类。是UIButton，UISwitch，UITextField等控件的父类。它本身定义了一些属性和方法，但是不能直接使用。
 方法交换 extension UIControl {  class func swizzleMethod() {  struct Static {  static var token = NSUUID().uuidString  }   // 确保不是子类  if self != UIControl.self {  return  }  // 防止手动调用，造成交换多次  DispatchQueue.once(token: Static.token) {  MethodSwizzlingTools.exchangeSelector(object: self, originalSelector: #selector(UIControl.sendAction(_:to:for:)), swizzledSelector: #selector(userSendAction(_:to:for:)))  }  }   @objc func userSendAction(_ action: Selector, to target: Any?, for event: UIEvent?) {  self.userSendAction(action, to: target, for: event)  } </content>
    </entry>
    
     <entry>
        <title>Swift 中的反射</title>
        <url>https://iihui.github.io/post/ios-reflection/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>swift</tag><tag>iOS</tag>
        </tags>
        <content type="html">  reflection是指计算机程序在runtime时可以访问、检测和修改它本身状态或行为的一种能力。比较形象的说法就是，反射是程序在运行的时候能够观察并且修改自己的行为。
 @objc Swift是一门静态语言，和OC不同，不能在运行时做很多复杂的操作。Swift虽然不能像OC一样在运行时做很多事，但是还是做一些小动作，比如和Java类似的反射机制等。
标记@objc，可以用来标记函数和类、协议等等。这个标记表示该方法或者该类可以被用于运行时。例如，在Swift中类似按钮点击的selector都必须用@objc标记，表示该方法是运行时调用（按钮点击是运行时事件，编译器在编译时对没有调用到的非运行时函数会优化掉）。
在Swift 4之后的版本里，类继承 NSObjct不会再默认带@objc 标记，当重写NSObjct编辑器会自动提示带上@objc。
除了上面用@objc标记这种方法外，还可以通过Reflection来实现一些诸如运行时获取类型、成员信息，调用任意方法等行为。Reflection主要使用Mirror这个结构体来做一些事情。
Swift反射 Swift的反射机制是基于一个叫Mirror的Stuct来实现的。具体的操作方式为：首先创建一个你想要反射的类的实例，再传给Mirror的构造器来实例化一个Mirror对象，最后使用这个Mirror来获取你想要的东西。
尽管Swift一直都在强调强类型、编译时安全并推荐使用静态调度，但它的标准库仍然提供了一个基于Mirror的Struct来实现的反射机制。简单来说，例如你有一个Class A并创建了一个A的实例对象a，此时你就可以通过Mirror(reflecting: a)来生成一个Mirror对象m，然后遍历m.children就可以获取到a对象的所有属性：
// // main.swift import Foundation  protocol Drive {  func run() }  public class Tire { //轮胎  var brand: String? //品牌  var size: Float = 0 //大小 }  public class Vehicle: Drive {  var carType: String?  var tires: [Tire]?  var host: String?// 主人  var brand: String?//汽车品牌   func run() {  if let h = host {  print(&amp;#34;\(h)Drive a \(brand)\(carType)car run&amp;#34;)  } else {  print(&amp;#34;this car is not selled&amp;#34;)  }  } }  public class Trunk: Vehicle {  public var packintBox: String? }  public struct TranGroup { //货运集团  var trunks = {  return [Trunk]()  }()   var country: String?  var turnover: Float? }  //一个中国的货运集团 var tranGroup = TranGroup()  tranGroup.country = &amp;#34;天朝&amp;#34; tranGroup.turnover = 2222 let trunk1 = Trunk() trunk1.brand = &amp;#34;MAN&amp;#34; trunk1.host = &amp;#34;Stan&amp;#34; trunk1.packintBox = &amp;#34;Big And Long&amp;#34; tranGroup.trunks.append(trunk1) let mirrorTran = Mirror(reflecting: tranGroup) print(tranGroup) //打印出 TranGroup 相关信息 print(mirrorTran.subjectType) //打印出 TranGroup print(mirrorTran.displayStyle) //Optional(Swift.Mirror.DisplayStyle.Struct)，是个Struct类型 print(mirrorTran.superclassMirror) //nil，因为没有父类 for (key, value) in mirrorTran.children {  print(&amp;#34;\(key): \(value)&amp;#34;) }  //打印结果 TranGroup(trunks: [test.Trunk], country: Optional(&amp;#34;天朝&amp;#34;), turnover: Optional(2222.0)) TranGroup Optional(Swift.Mirror.DisplayStyle.struct) nil Optional(&amp;#34;trunks&amp;#34;) : [test.Trunk] Optional(&amp;#34;country&amp;#34;) : Optional(&amp;#34;天朝&amp;#34;) Optional(&amp;#34;turnover&amp;#34;) : Optional(2222.0) </content>
    </entry>
    
     <entry>
        <title>KVC 键值编码</title>
        <url>https://iihui.github.io/post/ios-kvc/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag><tag>oc</tag>
        </tags>
        <content type="html">  KVC(Key Value Coding)键值编码，指允许通过Key名字来直接访问对象的属性，而不需要调用明确的存取方法。这样，便能在运行时动态地访问和修改对象的属性值。在iOS中，无论是Swift还是OC，KVC都是通过对NSObject的扩展来实现的。所以，继承了NSObject的类型的对象都能使用KVC。
 KVC KVC是一种通过字符串间接访问对象的属性的方法，而不是通过调用存取方法（setter/getter）来获取属性，下面是KVC最为重要的四个方法：
- (nullable id)valueForKey:(NSString *)key; //直接通过Key(NSString属性的名字)来取值 - (void)setValue:(nullable id)value forKey:(NSString *)key; //通过Key(NSString属性的名字)来设值 - (nullable id)valueForKeyPath:(NSString *)keyPath; //通过KeyPath(xx.xx)来取值 - (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath; //通过KeyPath(xx.xx)来设值 寻找Key机制 在赋值和取之的时候都要先寻找Key，但这两者在寻找Key的方式是有区别的，接下来一一说明它们寻找Key的机制。
设置值 当调用setValue：属性值 forKey：@”name“，来设置值时，底层的执行机制如下：
  程序优先调用set&amp;lt;Key&amp;gt;:属性值方法，代码通过setter方法完成设置。这里的Key是指成员变量名，而不是forKey表示的值。
  如果没有找到setName:方法，KVC机制会检查&#43; (BOOL)accessInstanceVariablesDirectly方法有没有返回YES（默认返回）。如果重写了该方法并返回NO的话，那么接下来执行setValue：forUndefinedKey方法，不过一般开发者不会这么做。所以KVC机制会搜索该类里面有没有名为_&amp;lt;key&amp;gt;的成员变量，无论该变量是在类接口处定义，还是在类实现处定义，也无论用了什么样的访问修饰符，只在存在以_&amp;lt;key&amp;gt;命名的变量，KVC都可以对该成员变量赋值。
  如果该类既没有set&amp;lt;key&amp;gt;方法，也没有_&amp;lt;key&amp;gt;成员变量，KVC机制会搜索_is&amp;lt;Key&amp;gt;的成员变量。
  如果该类既没有set&amp;lt;Key&amp;gt;方法，也没有_&amp;lt;key&amp;gt;和_is&amp;lt;Key&amp;gt;成员变量，KVC机制再会继续搜索是否存在&amp;lt;key&amp;gt;和is&amp;lt;Key&amp;gt;的成员变量，再给它们赋值。
  如果上面列出的方法或者成员变量都不存在，系统将会执行该对象的setValue：forUndefinedKey方法，默认是抛出异常。
  如果想让这个类禁用KVC，只要重写&#43; (BOOL)accessInstanceVariablesDirectly方法，并让它返回NO即可。
@interface Dog : NSObject @end @implementation Dog {  NSString* toSetName;  NSString* isName;  //NSString* name;  NSString* _name;  NSString* _isName; } // -(void)setName:(NSString*)name{ // toSetName = name; // } //-(NSString*)getName{ // return toSetName; //} &#43;(BOOL)accessInstanceVariablesDirectly{  return NO; } -(id)valueForUndefinedKey:(NSString *)key{  NSLog(@&amp;#34;出现异常，该key不存在%@&amp;#34;,key);  return nil; } -(void)setValue:(id)value forUndefinedKey:(NSString *)key{  NSLog(@&amp;#34;出现异常，该key不存在%@&amp;#34;,key); } @end int main(int argc, const char * argv[]) {  @autoreleasepool {  // insert code here...  Dog* dog = [Dog new];  [dog setValue:@&amp;#34;newName&amp;#34; forKey:@&amp;#34;name&amp;#34;];  NSString* name = [dog valueForKey:@&amp;#34;toSetName&amp;#34;];  NSLog(@&amp;#34;%@&amp;#34;,name);  }  return 0; } 上面代码的输出为：
2020-02-15 09:33:48.596397&#43;0800 test[52035:3057928] 出现异常，该key不存在name 2020-02-15 09:33:48.596949&#43;0800 test[52035:3057928] 出现异常，该key不存在toSetName 2020-02-15 09:33:48.596987&#43;0800 test[52035:3057928] (null) 这是因为重写了&#43;(BOOL)accessInstanceVariablesDirectly，并让它返回了NO之后，KVC不再去找name系列成员变量，而是直接调用setValue：forUndefinedKey：。所以如果不想让自定义的类实现KVC，则可以像上面那样做。
如果将下面的注释取消：
 -(void)setName:(NSString*)name{  toSetName = name;  } -(NSString*)getName{  return toSetName; } 并将NSString* name = [dog valueForKey:@&amp;quot;toSetName&amp;quot;]; 换成 NSString* name = [dog valueForKey:@&amp;quot;name&amp;quot;]; 就可以得到正确的结果了：
2020-02-15 09:59:52.961889&#43;0800 test[52736:3072979] newName 根据上面的寻找机制，按照如下修改，仍然可以设置name的值：
#import &amp;#34;Dog.h&amp;#34;  @implementation Dog {  NSString* toSetName;  NSString* isName;  //NSString* name;  NSString* _name;  NSString* _isName; } // -(void)setName:(NSString*)name{ // toSetName = name; // } //-(NSString*)getName{ // return toSetName; //} &#43;(BOOL)accessInstanceVariablesDirectly{  return YES; } -(id)valueForUndefinedKey:(NSString *)key{  NSLog(@&amp;#34;出现异常，该key不存在%@&amp;#34;,key);  return nil; } -(void)setValue:(id)value forUndefinedKey:(NSString *)key{  NSLog(@&amp;#34;出现异常，该key不存在%@&amp;#34;,key); } @end  #import &amp;lt;Foundation/Foundation.h&amp;gt; #import &amp;#34;Dog.h&amp;#34;  int main(int argc, const char * argv[]) {  @autoreleasepool {  // insert code here...  Dog * dog = [Dog new];  [dog setValue:@&amp;#34;newName&amp;#34; forKey:@&amp;#34;name&amp;#34;];  NSString* name = [dog valueForKey:@&amp;#34;name&amp;#34;];  NSLog(@&amp;#34;%@&amp;#34;,name);  }  return 0;  } 打印的结果如下所示：
2020-02-15 10:09:25.756648&#43;0800 test[52930:3077204] newName 取值 当调用valueForKey：@”name“的代码时，KVC对key的搜索方式不同于setValue：属性值 forKey：@”name“，其搜索方式如下：
  首先按get&amp;lt;Key&amp;gt;,&amp;lt;key&amp;gt;,is&amp;lt;Key&amp;gt;的顺序方法查找getter方法，找到的话会直接调用。如果是BOOL或者Int等值类型， 会将其包装成一个NSNumber对象。
  如果上面的getter没有找到，KVC则会查找countOf&amp;lt;Key&amp;gt;,objectIn&amp;lt;Key&amp;gt;AtIndex或&amp;lt;Key&amp;gt;AtIndexes格式的方法。如果countOf&amp;lt;Key&amp;gt;方法和另外两个方法中的一个被找到，那么就会返回一个可以响应NSArray所有方法的代理集合(它是NSKeyValueArray，为NSArray的子类)，调用这个代理集合的方法，或者说给这个代理集合发送属于NSArray的方法，就会以countOf&amp;lt;Key&amp;gt;,objectIn&amp;lt;Key&amp;gt;AtIndex或&amp;lt;Key&amp;gt;AtIndexes这几个方法组合的形式调用。还有一个可选的get&amp;lt;Key&amp;gt;:range:方法。所以你想重新定义KVC的一些功能，你可以添加这些方法，需要注意的是你的方法名要符合KVC的标准命名方法，包括方法签名。
  如果上面的方法没有找到，那么会同时查找countOf&amp;lt;Key&amp;gt;，enumeratorOf&amp;lt;Key&amp;gt;,memberOf&amp;lt;Key&amp;gt;格式的方法。如果这三个方法都找到，那么就返回一个可以响应NSSet所的方法的代理集合，和上面一样，给这个代理集合发NSSet的消息，就会以countOf&amp;lt;Key&amp;gt;，enumeratorOf&amp;lt;Key&amp;gt;,memberOf&amp;lt;Key&amp;gt;组合的形式调用。
  如果还没有找到，再检查类方法&#43;(BOOL)accessInstanceVariablesDirectly,如果返回YES(默认行为)，那么和先前的设值一样，会按_&amp;lt;key&amp;gt;,_is&amp;lt;Key&amp;gt;,&amp;lt;key&amp;gt;,is&amp;lt;Key&amp;gt;的顺序搜索成员变量名，这里不推荐这么做，因为这样直接访问实例变量破坏了封装性，使代码更脆弱。如果重写了类方法&#43; (BOOL)accessInstanceVariablesDirectly返回NO的话，那么会直接调用valueForUndefinedKey:
  还没有找到的话，调用valueForUndefinedKey:
  KeyPath 一个类的成员变量有可能是自定义类或其他的复杂数据类型，可以先用KVC获取该属性，然后再次用KVC来获取这个自定义类的属性，但这样是比较繁琐的。因此，KVC提供了一个解决方案，那就是键路径keyPath。
KeyPath，表示键路径，是一个由点作分隔符的键组成的字符串（点语法），用于表示一个连接在一起的对象序列。其中，后一个键的性质是由前一个键的性质决定的（如同现代面向对象语言取成员）。所以，KVC对于keyPath是搜索机制第一步就是分离key，用小数点.来分割key，然后再像普通key一样按照先前介绍的顺序搜索下去。
有了键路径，就可以不通过相应的方法来直接取相关的性质（属性/方法）。通过键路径，可以指定对象中的一个任意深度的路径，使其指向相关对象的特定属性。
- (nullable id)valueForKeyPath:(NSString *)keyPath; //通过KeyPath来取值 - (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath; //通过KeyPath来设值 下面是一个例子：
@interface Address : NSObject  @end @interface Address() @property (nonatomic,copy)NSString* country; @end @implementation Address @end @interface People : NSObject @end @interface People() @property (nonatomic,copy) NSString* name; @property (nonatomic,strong) Address* address; @property (nonatomic,assign) NSInteger age; @end @implementation People @end int main(int argc, const char * argv[]) {  @autoreleasepool {  People* people1 = [People new];  Address* addr = [Address new];  addr.country = @&amp;#34;China&amp;#34;;  people1.address = addr;  NSString* country1 = people1.address.country;  NSString * country2 = [people1 valueForKeyPath:@&amp;#34;address.country&amp;#34;];  NSLog(@&amp;#34;country1:%@ country2:%@&amp;#34;,country1,country2);  [people1 setValue:@&amp;#34;USA&amp;#34; forKeyPath:@&amp;#34;address.country&amp;#34;];  country1 = people1.address.country;  country2 = [people1 valueForKeyPath:@&amp;#34;address.country&amp;#34;];  NSLog(@&amp;#34;country1:%@ country2:%@&amp;#34;,country1,country2);  }  return 0; } //打印结果 2020-02-15 11:13:48.223700&#43;0800 test[54340:3105892] country1:China country2:China 2020-02-15 11:13:48.224670&#43;0800 test[54340:3105892] country1:USA country2:USA 异常处理 KVC中最常见的异常就是不小心使用了错误的key，或者在设置值的时候不小心传递了nil。如果不小心传递了nil值，KVC会调用setNilValueForKey:方法，这个方法默认是抛出异常，所以一般而言还是重写这个方法：
@implementation People  -(void)setNilValueForKey:(NSString *)key{  NSLog(@&amp;#34;不能将%@设成nil&amp;#34;,key); } @end 非对象和自定义对象 不是每一个方法都返回对象，但是valueForKey：总是返回一个id对象。如果原本的变量类型是值类型或者结构体，返回值会封装成NSNumber或者NSValue对象。这两个类会处理从数字，布尔值到指针和结构体的任何类型。然后，如果需要使用的话，需手动转换成原来的类型。尽管valueForKey会自动将值类型封装成对象，但是setValue：forKey：却不行。必须手动将值类型转换成NSNumber或者NSValue类型，才能传递过去。
Address* add2 = [Address new]; add2.country = @&amp;#34;England&amp;#34;; [people1 setValue:add2 forKey:@&amp;#34;address&amp;#34;]; NSString* country1 = people1.address.country; NSString * country2 = [people1 valueForKeyPath:@&amp;#34;address.country&amp;#34;]; NSLog(@&amp;#34;country1:%@ country2:%@&amp;#34;,country1,country2); 缺点   一旦使用KVC，编译器将无法检查出错误，即不会对设置的键、键路径进行错误检查。
  执行效率要低于合成存取器方法和自定义的setter和getter方法。效率低的原因是使用KVC键值编码，它必须先解析字符串，然后在设置或者访问对象的实例变量。
  KVC的使用 KVC在iOS开发中是绝不可少的利器，这种基于运行时的编程方式极大地提高了灵活性，简化了代码，下面来列举iOS开发中KVC的使用场景。
动态的取值和设值 上面很多例子就是使用KVC动态地取值和设值，这是最基本的用途了，每一个iOS developer都应该要掌握。
访问私有成员 对于类中的私有成员，OC是无法直接访问的，但是KVC是可以的，可以参考前面Dog的例子。
Model和字典的相互转换 Model和字典的相互转换，具体参考。充分地运用了KVC和Runtime组合的技巧，只用了短短数行代码就是完成了很多功能。
修改一些控件的内部属性 众所周知很多UI控件都由很多内部UI控件组合而成的，但是Apple没有提供这访问这些控件的API，这样我们就无法正常地访问和修改这些控件的样式。而KVC在大多数情况可下可以解决这个问题，最常用的就是个性化UITextField中的placeHolderText了。下面演示如果修改placeHolder的文字样式。这里的关键点是如何获取要修改的样式的属性名，也就是key或者keyPath：
let count:UnsafeMutablePointer&amp;lt;UInt32&amp;gt; = UnsafeMutablePointer&amp;lt;UInt32&amp;gt;() var properties = class_copyIvarList(UITextField.self, count) while properties.memory.debugDescription != &amp;#34;0x0000000000000000&amp;#34;{  let t = ivar_getName(properties.memory)  let n = NSString(CString: t, encoding: NSUTF8StringEncoding)  print(n) //打印出所有属性，这里我用了Swift语言  properties = properties.successor() }  //上面省略了部分属性 Optional(_disabledBackgroundView) Optional(_systemBackgroundView) Optional(_floatingContentView) Optional(_contentBackdropView) Optional(_fieldEditorBackgroundView) Optional(_fieldEditorEffectView) Optional(_displayLabel) Optional(_placeholderLabel) //这个正是我想要修改的属性。 Optional(_dictationLabel) Optional(_suffixLabel) Optional(_prefixLabel) Optional(_iconView) //下面省略了部分属性 操作集合 Apple对KVC的valueForKey:方法作了一些特殊的实现，比如说NSArray和NSSet这样的容器类就实现了这些方法，所以可以用KVC很方便地操作集合。
高阶消息传递 当对容器类使用KVC时，valueForKey:将会被传递给容器中的每一个对象，而不是容器本身进行操作。结果会被添加进返回的容器中。这样，开发者可以很方便的操作集合来返回另一个集合。
NSArray* arrStr = @[@&amp;#34;english&amp;#34;,@&amp;#34;franch&amp;#34;,@&amp;#34;chinese&amp;#34;]; NSArray* arrCapStr = [arrStr valueForKey:@&amp;#34;capitalizedString&amp;#34;]; for (NSString* str in arrCapStr) {  NSLog(@&amp;#34;%@&amp;#34;,str); } NSArray* arrCapStrLength = [arrStr valueForKeyPath:@&amp;#34;capitalizedString.length&amp;#34;]; for (NSNumber* length in arrCapStrLength) {  NSLog(@&amp;#34;%ld&amp;#34;,(long)length.integerValue); }  //结果 2020-02-15 13:08:35.863142&#43;0800 test[55706:3138103] English 2020-02-15 13:08:35.863904&#43;0800 test[55706:3138103] Franch 2020-02-15 13:08:35.863924&#43;0800 test[55706:3138103] Chinese 2020-02-15 13:08:35.864765&#43;0800 test[55706:3138103] 7 2020-02-15 13:08:35.864805&#43;0800 test[55706:3138103] 6 2020-02-15 13:08:35.864820&#43;0800 test[55706:3138103] 7 方法capitalizedString被传递到NSArray中的每一项。NSArray的每一员都会执行capitalizedString并返回一个包含结果的新的NSArray。
参考资料 参考资料
</content>
    </entry>
    
     <entry>
        <title>工具使用文档</title>
        <url>https://iihui.github.io/post/tool-usage/</url>
        <categories>
          <category>tool</category>
        </categories>
        <tags>
          <tag>tool</tag>
        </tags>
        <content type="html">  在macOS开发时会使用各种软件，例如Visual Studio Code，Xcode，iTerm，AppCode等。这些工具的使用过程中，会遇到一些出现频率较低的问题，解决之后也容易忘记，这篇文章用来记录相关问题的解决方法，以期后续再遇到相同问题时节省时间。
 Visual Studio Code 列选择模式 如果要进行列选择，需要先按住快捷键shift &#43; option，然后左键单击并拖动鼠标，就可以进行范围选择。选择的效果如下图所示：
生成html模版 如果要生成html模板，首先新建一个文件，然后保存这个空白文件并将文件名后缀设置为html，接着输入!，再键入Tab，则可按提示生成html模版文件：
Word Wrap 如果要开启编辑器的Word Wrap，首先打开设置，接着输入关键字wrap搜索，接着找到Editor: Word Wrap这一项，将Controls how lines should wrap开关打开即可：
AppCode 列选择模式 如果Intellij系统的编辑器要进行列选择，需要先按住option键，然后左键单击再拖动鼠标，即可选择相应的范围。在AppCode中进行列选择的具体效果如下图所示：
 iTerm 设置为默认终端 因为经常使用iTerm2，所以想将它设置为默认终端。实际上iterm2本身支持修改自身为默认终端，只要在菜单栏点击Make Iterm2 to default Term即可，如下图所示：
常用快捷键   command &#43; d纵向将当前窗口分为大小相同的两个窗口。
  shift &#43; command &#43; d横向将当前窗口分为大小相同的两个窗口。
  设置滚动 在iTerm2中，默认只显示1000行的历史数据，这个行数实际上可以在设置中更改。打开iTerm2的设置，选中Profiles，再点击Terminal，最后在Scrollback lines这一行后面勾选Unlimited scrollback即可：
 Homebrew 替换源 使用Homebrew安装软件时，默认会先进行更新，但国内访问github经常不稳定，导致更新时特别慢。目前可行的方法是替换源，对于Homebrew而言需要替换4个模块的镜像，如下所示：
 Homebrew Homebrew Core Homebrew Cask Homebrew-bottles  目前来看，最全的是中科大镜像，其他家都缺少第4个，所以换了前三个后，执行brew update依然很慢，具体替换方式如下：
# 替换 Homebrew git -C &amp;#34;$(brew --repo)&amp;#34; remote set-url origin https://mirrors.ustc.edu.cn/brew.git  # 替换 Homebrew Core git -C &amp;#34;$(brew --repo homebrew/core)&amp;#34; remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git  # 替换 Homebrew Cask git -C &amp;#34;$(brew --repo homebrew/cask)&amp;#34; remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git  # 替换 Homebrew-bottles # 对于 bash 用户： echo &amp;#39;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles&amp;#39; &amp;gt;&amp;gt; ~/.bash_profile source ~/.bash_profile # 对于 zsh 用户： echo &amp;#39;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles&amp;#39; &amp;gt;&amp;gt; ~/.zshrc source ~/.zshrc 参考资料
替换为中科大的源，在.zshrc中添加如下变量，然后执行source ~/.zshrc命令：
export HOMEBREW_BREW_GIT_REMOTE=&amp;#34;https://mirrors.ustc.edu.cn/brew.git&amp;#34; export HOMEBREW_CORE_GIT_REMOTE=&amp;#34;https://mirrors.ustc.edu.cn/homebrew-core.git&amp;#34; export HOMEBREW_API_DOMAIN=&amp;#34;https://mirrors.ustc.edu.cn/homebrew-bottles/api&amp;#34; export HOMEBREW_BOTTLE_DOMAIN=&amp;#34;https://mirrors.ustc.edu.cn/homebrew-bottles&amp;#34; 若此时再使用brew update命令升级时出现错误：
HOMEBREW_BREW_GIT_REMOTE set: using https://mirrors.ustc.edu.cn/brew.git for Homebrew/brew Git remote. fatal: detected dubious ownership in repository at &amp;#39;/usr/local/Homebrew&amp;#39; To add an exception for this directory, call:  git config --global --add safe.directory /usr/local/Homebrew 执行git config --global --add safe.directory /usr/local/Homebrew即可。
 ideviceinstaller 安装App 使用ideviceinstaller安装App时，若Mac上只连了一台手机，可以直接使用如下命令进行ipa安装，其中的xxx代表具体的名字：
ideviceinstaller -i xxx.ipa 如果当前电脑连接了多部手机，需要通过设备的UDID来确定安装到哪台设备上。如果想要查看连接的所有设备的UDID，需要使用如下命令：
idevice_id -l 根据上一步获取到的手机UDID，并且在使用ideviceinstaller命令时添加-u选项，则可以将ipa文件安装到特定手机上：
ideviceinstaller -u xxx -i xxx.ipa 如果要查看连接到电脑手机的详细信息，需要使用ideviceinfo命令，其中的-s选项表示只是展示一些简单的信息：
ideviceinfo -s 查看安装的App 如果想要查看手机安装的所有第三方App，则添加-l选项即可：
ideviceinstaller -l 卸载应用 如果要卸载某台手机的某个应用，依然可以使用ideviceinstaller命令，其中的小写-u选项指定设备，大写-U用于指定卸载哪个应用：
ideviceinstaller -u udid -U bundleId  Word 修改默认语言 如果Mac系统设置为英文，安装Word后显示语言也默认为英文，为了设置中文显示，可以先关闭Word，然后执行如下命令：
defaults write com.microsoft.Word AppleLanguages &amp;#39;(&amp;#34;zh-cn&amp;#34;)&amp;#39; 其中com.microsoft.Word是Word的bundle identifier，可以通过在应用程序中选中应用，右键后选择Show Package Contents，然后在Contents下面打开Info.plist，找到Bundle identifier（最后一张图）所对应的值，具体步骤如下图所示：
实际上，上面的命令具有通用性，只要将com.microsoft.Word改成其它软件的 Bundle identifier值即可。例如，下面的命令就是修改Powerpoint &amp;amp; Excel的默认语言：
defaults write com.microsoft.Powerpoint AppleLanguages &amp;#39;(&amp;#34;zh-cn&amp;#34;)&amp;#39; defaults write com.microsoft.Excel AppleLanguages &amp;#39;(&amp;#34;zh-cn&amp;#34;)&amp;#39; 西文不自动换行 默认情况在Word中，不允许西文自动换行。可以当前文档右键选择段落&amp;mdash;&amp;gt;中文版式&amp;mdash;&amp;gt;勾选允许西文在单词中间换行。
ZeroTier One 今天打开ZeroTier One后发现提示Could not connect to the server。按照网上的资料使用如下两个命令，发现依然有报错：
sudo launchctl unload /Library/LaunchDaemons/com.zerotier.one.plist sudo launchctl load /Library/LaunchDaemons/com.zerotier.one.plist 第一条命令的报错信息为Could not find specified service，第二条命令的报错信息为Service is disabled。最后发现在App Cleaner &amp;amp; Uninstaller PRO软件中的System Daemons条目下的com.zerotier.one被关闭了，打开就能正常使用了：
/Library/LaunchDaemons/com.zerotier.one.plist: Could not find specified service Unload failed: 113: Could not find specified service  /Library/LaunchDaemons/com.zerotier.one.plist: Service is disabled Load failed: 119: Service is disabled Brave 蓝色边框 使用Brave浏览器全屏播放视频时经常出现蓝色边框，查找资料发现需要设置brave://flags/#enable-oop-rasterization，将默认值改为Enabled即可：
若依然显示蓝色边框，则需要检查一下是不是使用tab键选中了播放框，选中了的话就是蓝色的边框。若是的话，取消选中即可去除蓝色边框。
默认无痕模式 参考资料
Sqlcipher 使用Intellij idea不能直接打开用Sqlcipher加密过的Sqlite数据库文件。首先需要先从这里下载驱动文件到本地，然后如下图所示，右键工程右边的Database，接着点击&#43;号，选择Driver：
再在弹出的添加界面将Name填写好（此处我填写为Sqlcipher），Class填写为org.sqlite.JDBC，并将刚刚下载到本地的驱动文件添加到Driver Files中，最后点击OK按钮：
接着回到主界面，依次点击&#43;--&amp;gt;Data Source→Sqlcipher，输入Name，Authentication选择No auth，并且URL这一列输入类似jdbc:sqlite:/Users/xxx/xxx/xxx.db?cipher=sqlcipher&amp;amp;key=xxx&amp;amp;legacy=xxx&amp;amp;kdf_iter=xxx&amp;amp;kdf_algorithm=xxx&amp;amp;legacy_page_size=xxx&amp;amp;hmac_algorithm=xxx字符串，即可打开加密后的数据库表：
jdbc:sqlite:/Users/xxx/xxx.db?cipher=sqlcipher&amp;amp;key=xxx&amp;amp;legacy=xxx&amp;amp;kdf_iter=xxx&amp;amp;kdf_algorithm=xxx&amp;amp;legacy_page_size=xxx&amp;amp;hmac_algorithm=xxx 上面代码段中?前的xxx/xxx代表数据库文件路径，cipher表示使用sqlcipher加密，后面的xxx代表对应key所取的具体值，每个选项的具体值含义参考此链接和这个链接，下图是最后打开加密后的效果图：
如果加密的数据库，只是密码不同，可以在驱动的高级设置中，将这些参数都先设置好。只需找到刚刚设置的驱动，然后点击Advanced，再设置对应的字段(cipher,hmac_algorithm,legacy,legacy_page_size,kdf_iter,kdf_algorithm)，然后修改数据源的url（去除已经在高级中设置的那些字段）即可：
jdbc:sqlite:/Users/xxx/xxx/xxx.db?key=xxx 参考资料
CrossOver Font 在CrossOver中安装软件后若提示未安装宋体，则需要安装简体中文字体包。搜索Font，然后选择Adobe Source Han Sans Simplified Chinese Font Package安装即可：
制作dmg文件 首先在终端创建一个文件夹，然后在终端中进入刚刚创建的目录，接着使用ln -s命令创建待制作dmg应用程序的软链接：
mkdir test cd test ln -s /Applications 应用程序 接着从应用程序目录里拷贝已经安装的待制作dmg文件的App至上面刚创建的目录中。然后打开磁盘工具，选择File--&amp;gt;New Image--&amp;gt;Image From Folder，选择刚刚创建的文件夹，再选择dmg保存的目录即可：
参考资料
删除超过x天文件 # 在Downloads目录下，查找修改日期大于10天，然后删除 find ~/Downloads/ -type f -mtime &#43;365 -exec rm {} \;  # 在Downloads目录下，查找修改日期大于10天，并且后缀为.crash的文件，然后删除 find Downloads -type f -mtime &#43;10 -name &amp;#34;*.crash&amp;#34; -exec rm {} \;  # 在Downloads目录下，查找修改日期大于10天，并且后缀为.crash的文件，然后移动到垃圾桶 find Downloads -type f -mtime &#43;10 -name &amp;#34;*.crash&amp;#34; exec mv {} ~/.Trash \; 参考资料 参考资料
Xcode 命令行添加参数 最近在开发命令行工具，想要在运行时支持添加几个默认参数。此时，需要点击Edit Scheme--&amp;gt;Run--&amp;gt;Arguments，然后添加相关参数即可：
PandoraBox 在PandoraBox的14.09版本中，如果要设置端口转发，需在左侧的网络--&amp;gt;防火墙--&amp;gt;端口转发中添加即可。如果要固定IP可以到左侧的网络--&amp;gt;DHCP/DNS--&amp;gt;静态地址分配中添加。
https://www.cfos.de/zh-cn/cfos-personal-net/port-forwarding/pandorabox-sdk-version-14-09.htm#
private func chunkedToFile(dict: [AnyHashable: Any], outputStream: OutputStream, chunkSize: Int) {  outputStream.open()  defer { outputStream.close() }   // 手动写入JSON起始符号  let writeStr = { (str: String) in  guard let data = str.data(using: .utf8) else {  return  }  data.withUnsafeBytes { ptr in  outputStream.write(ptr.bindMemory(to: UInt8.self).baseAddress!, maxLength: data.count)  }  }  // JSON开始  writeStr(&amp;#34;{&amp;#34;)   let keys = Array(dict.keys)  for (index, key) in keys.enumerated() {  autoreleasepool {  guard let keyStr = key as? String,let value = dict[key] else {  return  }  // 先写入Key  writeStr(&amp;#34;\&amp;#34;\(keyStr)\&amp;#34;:&amp;#34;)   // 再写入Value（仅处理可直接序列化的部分）  if JSONSerialization.isValidJSONObject([value]),  let data = try? JSONSerialization.data(withJSONObject: value, options: []) {  outputStream.write([UInt8](data), maxLength: data.count)  } else {  writeStr(&amp;#34;null&amp;#34;)  }  // 非最后一个元素添加逗号  if index != keys.count - 1 {  writeStr(&amp;#34;,&amp;#34;)  }  }  }  // JSON结束  writeStr(&amp;#34;}&amp;#34;) }  public override var canGoBack: Bool {  guard webView.canGoBack else {  return false  }  // 若返回列表中只有一个，并且url和initialURL不同，则认为是重定向的url，此时不该显示返回按钮，否则点返回按钮，无法真正返回  // 这个结论只是个人观察出来的  if webView?.backForwardList.backList.count == 1,  let firstItem = webView?.backForwardList.backList.first,  firstItem.url != firstItem.initialURL {  return false  }  return true  } Obsidian Remember File State无法退出应用 在macOS上安装了Obsidian中的插件Remember File State后，发现按住command&#43;Q无法直接退出应用，只是关闭当前页面，需要再按一次command&#43;Q才能完全关闭应用。看了插件的代码，发现在main.js中绑定了退出快捷键，但它没有退出应用：
this.onAppQuit = (tasks) =&amp;gt; __async(this, null, function* () {  const _this = this;  tasks.addPromise(_this.rememberAllOpenedFileStates().then(() =&amp;gt; _this.writeStateDatabase(STATE_DB_PATH))); }); 将代码修改为如下方式：
this.onAppQuit = (tasks) =&amp;gt; {  const _this = this;   // 1. 立即执行保存操作（不阻塞退出）  _this.rememberAllOpenedFileStates()  .then(() =&amp;gt; _this.writeStateDatabase(STATE_DB_PATH))  .catch(err =&amp;gt; console.error(&amp;#34;保存失败:&amp;#34;, err));   // 2. 主动触发退出（绕过阻塞）  setTimeout(() =&amp;gt; {  window.app.quit(); // 直接调用 Obsidian 的退出方法  }, 200); // 短暂延迟确保保存任务已启动 }; 或者按下面方式优化异步流程（兼容性更强）：
this.onAppQuit = (tasks) =&amp;gt; __async(this, null, function* () {  const _this = this;   // 1. 同步执行保存操作  yield _this.rememberAllOpenedFileStates()  .then(() =&amp;gt; _this.writeStateDatabase(STATE_DB_PATH))  .catch(err =&amp;gt; console.error(err));   // 2. 立即退出（不再等待其他任务）  window.app.quit(); }); 若能够将rememberAllOpenedFileStates和writeStateDatabase改造成同步方法，就可以将代码修改为如下同步方式：
this.onAppQuit = (tasks) =&amp;gt; {  const _this = this;   try {  // 同步保存（无异步等待）  _this.rememberAllOpenedFileStatesSync(); // 假设存在同步方法  _this.writeStateDatabaseSync(STATE_DB_PATH);  } catch (err) {  console.error(&amp;#34;同步保存失败:&amp;#34;, err);  }   window.app.quit(); }; WebStorm Full Line complete 升级WebStorm到2025.1.1版本后发现内置的Full Line complete失效，通过Help--&amp;gt;Show Log in Finder查看日志发现Full Line complete未启动，且有报错信息：New quota refill state is: Error(exception=java.lang.IllegalStateException: Returned result does not match the condition.
此时，可以将JetBrains AI Assistant插件禁用，再看日志发现已有Full line native server is started和Full line native server address is localhost:56286，这表示Full Line complete已生效。
Ghostty 选择粘贴 Ghostty终端默认未开启选择即复制到系统粘贴板，添加如下配置项，然后重新加载配置后就开启了Ghostty的选择即复制：
copy-on-select = clipboard </content>
    </entry>
    
     <entry>
        <title>iOS 可视化埋点</title>
        <url>https://iihui.github.io/post/ios-log-point/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag><tag>oc</tag>
        </tags>
        <content type="html">  埋点方案大体上可以归为3类：代码埋点，可视化埋点，无埋点。代码埋点，由开发人员在触发事件的具体方法里，植入多行代码把需要上传的数据发送至服务端。可视化埋点，根据标识来识别每一个事件，针对指定的事件进行取参埋点。而事件的标识与参数信息都写在配置表中，通过动态下发配置表来实现埋点统计。无埋点，无埋点并不是不需要埋点，更准确的说应该是“全埋点”，前端的任意一个事件都被绑定一个标识，所有的事件都被记录下来。通过定期上传记录文件，配合文件解析，解析出想要的数据，并以此生成可视化报告供专业人员分析，因此实现无埋点统计。
 可视化埋点 可视化埋点并非完全摒弃了代码埋点，而是在代码埋点的上层封装的一套逻辑来代替手工埋点，大体上架构如下图：
要实现可视化埋点也有很多问题需要解决，比如事件唯一标识的确定，业务参数的获取，有逻辑判断的埋点配置项信息等等。
事件唯一标识 唯一标识的组成方式主要是由target &#43; action来确定，即任何一个事件都存在一个target与action。在此引入AOP编程，AOP（Aspect-Oriented-Programming）即面向切面编程的思想，基于Runtime的 Method Swizzling能力，来hook相应的方法，从而在hook方法中进行统一的埋点处理。例如所有的按钮被点击时，都会触发UIApplication的sendActio方法，我们hook这个方法，即可拦截所有按钮的点击事件:
事件的锁定主要是靠事件唯一标识符，而事件的唯一标识是事先写入配置表中，然后根据配置表来解析具体是哪个界面的哪个事件。
埋点数据分为两种类型：固定数据与可变的业务数据，固定数据可以直接写到配置表中，通过唯一标识来获取。对于业务数据，可以这么理解：数据是有持有者的，例如Controller的一个属性值，又如数据在Model的某一个层级。 这样就可以通过KVC(全称是Key Value Coding)的方式来递归获取该属性的值来取到业务数据。
统计术语 UV(Unique Visitor)：独立访客，将每个独立上网电脑（以cookie为依据）视为一位访客，一天之内（00:00-24:00），访问您网站的访客数量。一天之内相同cookie的访问只被计算1次。
PV（Page View）：访问量，即页面浏览量或者点击量，用户每次对网站的访问均被记录1次，用户对同一页面的多次访问，访问量值累计。
统计独立IP：00:00-24:00内相同IP地址只被计算一次，做网站优化的朋友最关心这个。
</content>
    </entry>
    
     <entry>
        <title>Objective-C Runtime</title>
        <url>https://iihui.github.io/post/oc-runtime/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>oc</tag><tag>iOS</tag>
        </tags>
        <content type="html">  Objective-C扩展了C语言，并加入了面向对象特性和Smalltalk式的消息传递机制。而这个扩展的核心是一个用C写的Runtime库，它是OC面向对象和动态机制的基石。OC的Runtime用于创建类对象、进行消息传递和转发。理解OC的Runtime机制可以更好地了解这个语言，适当的时候还能对语言进行扩展，从系统层面解决项目中的一些设计或技术问题。理解Runtime，首先应该了解它的核心——消息传递（Messaging）机制。
 Runtime版本 Runtime有两个版本: modern和legacy版。现用的Objective-C 2.*是Modern 版，只能运行在iOS和macOS 10.5之后的64位程序中。而macOS较老的32位程序仍采用Objective-C 1.*中的Legacy版本。两个版本最大的区别在于：当更改一个类的实例变量布局时，在早期版本中需要重新编译它的子类，而Modern版不需要重新编译子类。
高级编程语言想要成为可执行文件需要先编译为汇编语言，再将汇编语言转换为机器语言（机器语言是计算机能够识别的唯一语言）。但是，OC并不能直接编译为汇编语言，而是要先转写为纯C语言再进行编译和汇编操作，从OC到C的过渡是由runtime库来实现的。因为OC主要进行面向对象开发，而C语言是面向过程开发，这就需要将面向对象的类转变为面向过程的结构体。
消息传递 所有的OC方法调用[receiver selector]在编译时都会转化为对应的C函数objc_msgSend(receiver，selector)的调用。 例如一个对象方法调用[obj,foo]，Runtime执行方法调用的过程如下：
  首先，通过obj的isa指针找到它的class
  然后，在obj的class的objc_method_list找foo
  如果class的objc_method_list中没到foo，继续往它的super_class中寻找foo
  若找到foo这个函数，就去执行它的实现IMP，否则报错
  但上述流程存在效率低的问题：通常一个class只有20%的函数经常被调用，可能占总调用次数的80%，所以每次消息传递的时候都遍历一次objc_method_list并不合理。如果把经常被调用的函数缓存下来，就可以大大提高函数的查询效率。objc_cache就是做这样的事情，当找到selector后，它将selector的method_name作为key，method_imp作为value存储起来，当再次收到selector消息时，可以直接在objc_cache里找到，避免去遍历objc_method_list。
objc_msgSend定义 在runtime中，objc_msgSend的定义如下：
OBJC_EXPORT id objc_msgSend(id self, SEL op, ...) 要了解消息传递机制，首先需要了解类objc_class、对象objc_object、方法objc_method这几个结构体。
//对象 struct objc_object {  Class isa OBJC_ISA_AVAILABILITY; }; //类 struct objc_class {  Class isa OBJC_ISA_AVAILABILITY; #if !__OBJC2__  Class super_class OBJC2_UNAVAILABLE;  const char *name OBJC2_UNAVAILABLE;  long version OBJC2_UNAVAILABLE;  long info OBJC2_UNAVAILABLE;  long instance_size OBJC2_UNAVAILABLE;  struct objc_ivar_list *ivars OBJC2_UNAVAILABLE;  struct objc_method_list **methodLists OBJC2_UNAVAILABLE;  struct objc_cache *cache OBJC2_UNAVAILABLE;  struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; #endif } OBJC2_UNAVAILABLE; //方法列表 struct objc_method_list {  struct objc_method_list *obsolete OBJC2_UNAVAILABLE;  int method_count OBJC2_UNAVAILABLE; #ifdef __LP64__  int space OBJC2_UNAVAILABLE; #endif  /* variable length structure */  struct objc_method method_list[1] OBJC2_UNAVAILABLE; } OBJC2_UNAVAILABLE; //方法 struct objc_method {  SEL method_name OBJC2_UNAVAILABLE;  char *method_types OBJC2_UNAVAILABLE;  IMP method_imp OBJC2_UNAVAILABLE; } 类对象objc_class 在OC中，类是由Class类型来表示的，它实际上是一个指向objc_class结构体的指针：
typedef struct objc_class *Class; //Class是一个指向objc_class 的指针 其中objc_class结构体在objc/runtime.h中的定义如下：
struct objc_class {  Class _Nonnull isa OBJC_ISA_AVAILABILITY;  #if !__OBJC2__  Class _Nullable super_class OBJC2_UNAVAILABLE; // 指向父类的指针  const char * _Nonnull name OBJC2_UNAVAILABLE; // 类的名字  long version OBJC2_UNAVAILABLE; // 类的版本信息，默认为 0  long info OBJC2_UNAVAILABLE; // 类的信息，供运行期使用的一些位标识   long instance_size OBJC2_UNAVAILABLE; // 该类的实例变量大小;  struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; // 该类的实例变量列表  struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; // 方法定义的列表  struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; // 方法缓存  struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE; // 遵守的协议列表 #endif } OBJC2_UNAVAILABLE; 类对象就是一个结构体struct objc_class，这个结构体存放的数据称为元数据(metadata)。该结构体的第一个成员变量也是isa指针，这说明了Class本身其实是一个对象，称之为类对象。类对象在编译期产生用于创建实例对象，是单例。
实例对象(object) 在objc/runtime.h中，对象被定义为指向objc_object结构体的指针，objc_object结构体的定义如下：
//runtime对objc_object结构体的定义 struct objc_object {  Class isa OBJC_ISA_AVAILABILITY; //objc_object只有一个成员，就是指向O };  //id是一个指向objc_object结构体的指针： typedef struct objc_object *id; //id是指向objc_class指针的指针 类对象中的元数据存储的都是如何创建一个实例的相关信息，那么类对象和类方法应该从哪里创建呢？就是从isa指针指向的结构体创建，类对象的isa指针指向的我们称之为元类(meatclass)，元类中保存了创建类对象以及类方法所需的所有信息，因此整个结构应该如下图所示:
元类(meta class) 通过上图可以看出整个体系构成了一个自闭环，struct objc_object结构体实例的isa指针指向类对象，类对象的isa指针指向了元类，super_class指针指向了父类的类对象，而元类的super_class指针指向了父类的元类，那元类的isa指针又指向了自己(还不理解为什么会指向自己)。
元类(Meta Class)是一个类对象的类。在上面我们提到，所有的类自身也是一个对象，我们可以向这个对象发送消息(即调用类方法)。为了调用类方法，这个类的isa指针必须指向一个包含这些类方法的一个objc_class结构体。这就引出了meta-class的概念，元类中保存了创建类对象以及类方法所需的所有信息。
任何NSObject继承体系下的meta-class都使用NSObject的meta-class作为自己的所属类，而基类的meta-class的isa指针是指向它自己。
方法(method) 首先看一下objc_method的定义：
runtime.h /// An opaque type that represents a method in a class definition.代表类定义中一个方法的不透明类型 typedef struct objc_method *Method; struct objc_method {  SEL method_name OBJC2_UNAVAILABLE; //方法名  char *method_types OBJC2_UNAVAILABLE; //方法类型  IMP method_imp OBJC2_UNAVAILABLE; //方法实现 在objc_method的定义中，可以看到SEL和IMP，这说明SEL和IMP都是方法的属性:
  SEL method_name方法名
  char * method_types 方法类型
  IMP method_imp 方法实现
  SEL方法选择器 ojbc_msgSend函数第二个参数类型为SEL，可以理解为用于区分方法的ID，这个ID的数据结构就是SEL：
在objc/runtime.h,SEL被定义为指向objc_selector结构体的指针：
///objc.h /// An opaque type that represents a method selector.代表一个方法的不透明类型 typedef struct objc_selector *SEL; 而selector是SEL的一个实例：
@property SEL selector; selector的解释为：
A method selector is a C string that has been registered (or “mapped“) with the Objective-C runtime. Selectors generated by the compiler are automatically mapped by the runtime when the class is loaded. 也就是说selector就是个映射到方法的C字符串，可以用OC编译器命令@selector()或者Runtime系统的sel_registerName函数来获得一个SEL类型的方法选择器。
selector既然是一个字符串，应该类似className&#43;method的组合，命名的规则有两条：
  同一个类，selector不能重复
  不同的类，selector可以重复
  这也带来个弊端，就是在写C代码的时候，经常会用到函数重载，就是函数名相同，参数不同。但在OC中行不通，因为selector只记了method的name，没有参数，所以没法区分不同的method。
比如下面代码在OC中是会报错的：
- (void)caculate(NSInteger)num; - (void)caculate(CGFloat)num; 所以只能通过命名来区分：
- (void)caculateWithInt(NSInteger)num; - (void)caculateWithFloat(CGFloat)num; IMP IMP是指向一个方法实现的指针，实质上就是指向最终实现程序的内存地址的指针，它的定义为：
/// A pointer to the function of a method implementation. 指向一个方法实现的指针 typedef id (*IMP)(id, SEL, ...); #endif 在iOS的runtime中，方法通过selector和IMP两个属性，实现了快速查询方法及其实现，相对提高了性能，又保持了灵活性。
Objective-C在编译时，会依据每一个方法的名字、参数序列，生成一个唯一的整型标识(Int类型的地址)，这个标识就是SEL
Category(objc_catory) 当Catrgory表示一个指向分类的结构体的指针，它的定义如下：
struct category_t {  const char *name;  classref_t cls;  struct method_list_t *instanceMethods;  struct method_list_t *classMethods;  struct protocol_list_t *protocols;  struct property_list_t *instanceProperties; };   name是class_name而不是category_name。
  cls表示要扩展的类对象，编译期间是不会定义的，而是在Runtime阶段通过name对应到相应的类对象。
  instanceMethods表示category中所有给类添加的实例方法的列表。
  classMethods表示category中所有添加的类方法的列表。
  protocols 表示category实现的所有协议的列表。
  instanceProperties 表示category里所有的Properties，这就是我们可以通过objc_setAssociatedObject和objc_getAssociatedObject增加实例变量的原因，不过这个和一般的实例变量是不一样的。
  从上面的category_t结构体中可以看出，分类中可以添加实例方法，类方法，甚至可以实现协议，添加属性，不可以添加成员变量。
Runtime消息转发 OC在发送消息时会在相关的类对象中搜索方法列表，如果找不到则会沿着继承树向上一直搜索直到树根部（NSObject），如果还是找不到，那么消息转发就是失败了。此时，会执行doesNotRecognizeSelector:方法，报unrecognized selector错。
动态方法转发 首先，OC运行时会调用&#43;resolveInstanceMethod:或者 &#43;resolveClassMethod:，让你有机会提供一个函数实现。如果添加了函数并返回YES，那运行时系统就会重新启动一次消息发送的过程。
实现一个动态方法解析的例子：
- (void)viewDidLoad {  [super viewDidLoad];  // Do any additional setup after loading the view, typically from a nib.  //执行foo函数  [self performSelector:@selector(foo:)]; }  &#43; (BOOL)resolveInstanceMethod:(SEL)sel {  if (sel == @selector(foo:)) {//如果是执行foo函数，就动态解析，指定新的IMP  class_addMethod([self class], sel, (IMP)fooMethod, &amp;#34;v@:&amp;#34;);  return YES;  }  return [super resolveInstanceMethod:sel]; }  void fooMethod(id obj, SEL _cmd) {  NSLog(@&amp;#34;Doing foo&amp;#34;);//新的foo函数 } 可以看到虽然没有实现foo:这个函数，但是通过class_addMethod动态添加fooMethod函数，并执行fooMethod这个函数的IMP。但如果resolve方法返回NO，运行时就会移到下一步：forwardingTargetForSelector。
备用接收者 如果目标对象实现了-forwardingTargetForSelector:，Runtime这时就会调用这个方法，给你把这个消息转发给其他对象的机会。
实现一个备用接收者：
#import &amp;#34;ViewController.h&amp;#34; #import &amp;#34;objc/runtime.h&amp;#34;  @interface Person: NSObject  @end  @implementation Person  - (void)foo {  NSLog(@&amp;#34;Doing foo&amp;#34;);//Person的foo函数 }  @end  @interface ViewController ()  @end  @implementation ViewController  - (void)viewDidLoad {  [super viewDidLoad];  // Do any additional setup after loading the view, typically from a nib.  //执行foo函数  [self performSelector:@selector(foo)]; }  &#43; (BOOL)resolveInstanceMethod:(SEL)sel {  return NO;//返回NO，进入下一步转发 }  - (id)forwardingTargetForSelector:(SEL)aSelector {  if (aSelector == @selector(foo)) {  return [Person new];//返回Person对象，让Person对象接收这个消息  }   return [super forwardingTargetForSelector:aSelector]; }  @end 完整消息转发 如果在上一步还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了。
首先它会发送-methodSignatureForSelector:消息获得函数的参数和返回值类型。如果-methodSignatureForSelector:返回nil，则Runtime则会发出-doesNotRecognizeSelector:消息，程序这时也就挂掉了。如果返回了一个函数签名，Runtime就会创建一个NSInvocation对象并发送 -forwardInvocation:消息给目标对象。
#import &amp;#34;ViewController.h&amp;#34; #import &amp;#34;objc/runtime.h&amp;#34;  @interface Person: NSObject  @end  @implementation Person  - (void)foo {  NSLog(@&amp;#34;Doing foo&amp;#34;);//Person的foo函数 }  @end  @interface ViewController ()  @end  @implementation ViewController  - (void)viewDidLoad {  [super viewDidLoad];  // Do any additional setup after loading the view, typically from a nib.  //执行foo函数  [self performSelector:@selector(foo)]; }  &#43; (BOOL)resolveInstanceMethod:(SEL)sel {  return YES;//返回YES，进入下一步转发 }  - (id)forwardingTargetForSelector:(SEL)aSelector {  return nil;//返回nil，进入下一步转发 }  - (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {  if ([NSStringFromSelector(aSelector) isEqualToString:@&amp;#34;foo&amp;#34;]) {  return [NSMethodSignature signatureWithObjCTypes:&amp;#34;v@:&amp;#34;];//签名，进入forwardInvocation  }   return [super methodSignatureForSelector:aSelector]; }  - (void)forwardInvocation:(NSInvocation *)anInvocation {  SEL sel = anInvocation.selector;   Person *p = [Person new];  if([p respondsToSelector:sel]) {  [anInvocation invokeWithTarget:p];  }  else {  [self doesNotRecognizeSelector:sel];  }  }  @end instancetype和id的区别 instancetype和id都可以用来表示任意类型，将对象的类型确定往后推迟，用于体现OC语言的动态性，使其声明的对象具有运行时特性。区别是：
  instancetype只能作为返回值类型，但在编译期instancetype会进行类型检测，因此对于所有返回类的实例的类方法或实例方法，建议返回类型instancetype而不是id。
  id类型既可以作为返回类型，也可以作为参数类型，也可以作为变量类型，但id类型在编译期不会进行类型检测。
  selector selector是一个方法的名字。基于动态绑定环境下，method是一个组合体，包含了名字和实现。可以理解@selector()就是取类方法的编号，他的行为基本可以等同C语言中的函数指针，只不过C语言中，可以把函数名直接赋值给一个函数指针，而OC的类不能直接应用函数指针，这样只能做一个@selector语法来取，它的结果是一个SEL类型。而这个类型本质是类方法的编号（函数地址）。
target-action机制 目标是动作消息的接收者。例# 目标是动作消息的接收者。例目标是动作消息的接收者。例如一个控件，或者更为常见的是它的单元，以插座变量的形式保有其动作的目标。动作是控件发送给目标的消息，或者从目标的角度看，他是目标为了响应动作而实现的方法。程序需要某些机制来进行实践和指令的翻译，这个机制就是目标-动作机制。
Runtime的应用 Runtime的应用场景有很多，常见的如下：
  关联对象(Objective-C Associated Objects)，给分类添加属性
  方法魔法(Method Swizzling),添加和替换KVO实现
  实现NSCoding的自动归档和自动解档
  实现字典和模型的自动转换(MJExtension)
  关联对象 在OC中分类是不能自定义属性和变量的，但是可以通过关联对象实现给分类添加属性。Runtime给关联对象添加了以下几个接口：
3个接口 //关联对象 void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) //获取关联的对象 id objc_getAssociatedObject(id object, const void *key) //移除关联的对象 void objc_removeAssociatedObjects(id object) 参数解释 id object：被关联的对象 const void *key：关联的key，要求唯一 id value：关联的对象 objc_AssociationPolicy policy：内存管理的策略 内存管理策略的定义：
typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) {  OBJC_ASSOCIATION_ASSIGN = 0, /**&amp;lt; Specifies a weak reference to the associated object. */  OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**&amp;lt; Specifies a strong reference to the associated object. * The association is not made atomically. */  OBJC_ASSOCIATION_COPY_NONATOMIC = 3, /**&amp;lt; Specifies that the associated object is copied. * The association is not made atomically. */  OBJC_ASSOCIATION_RETAIN = 01401, /**&amp;lt; Specifies a strong reference to the associated object. * The association is made atomically. */  OBJC_ASSOCIATION_COPY = 01403 /**&amp;lt; Specifies that the associated object is copied. * The association is made atomically. */ }; 内存分配各个值的含义如下所示： 下面是OC中下实现一个UIView的Category添加自定义属性defaultColor：
#import &amp;#34;ViewController.h&amp;#34; #import &amp;#34;objc/runtime.h&amp;#34;  @interface UIView (DefaultColor)  @property (nonatomic, strong) UIColor *defaultColor;  @end  @implementation UIView (DefaultColor)  @dynamic defaultColor;  static char kDefaultColorKey;  - (void)setDefaultColor:(UIColor *)defaultColor {  objc_setAssociatedObject(self, &amp;amp;kDefaultColorKey, defaultColor, OBJC_ASSOCIATION_RETAIN_NONATOMIC); }  - (id)defaultColor {  return objc_getAssociatedObject(self, &amp;amp;kDefaultColorKey); }  @end  @interface ViewController ()  @end  @implementation ViewController  - (void)viewDidLoad {  [super viewDidLoad];  // Do any additional setup after loading the view, typically from a nib.   UIView *test = [UIView new];  test.defaultColor = [UIColor blackColor];  NSLog(@&amp;#34;%@&amp;#34;, test.defaultColor); }  @end 在Swift中是按如下使用方法使用的：
extension NSObject {  func setAssociated&amp;lt;T&amp;gt;(value: T, associatedKey: UnsafeRawPointer, policy: objc_AssociationPolicy = objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN_NONATOMIC) -&amp;gt; Void {  objc_setAssociatedObject(self, associatedKey, value, policy)  }   func getAssociated&amp;lt;T&amp;gt;(associatedKey: UnsafeRawPointer) -&amp;gt; T? {  let value = objc_getAssociatedObject(self, associatedKey) as? T  return value  } } Method Swizzling 方法添加 添加方法的实际上在上面的消息转发机制中已经提到了，其函数定义为：
//class_addMethod(Class _Nullable __unsafe_unretained cls, SEL _Nonnull name, IMP _Nonnull imp, const char * _Nullable types) class_addMethod([self class], sel, (IMP)fooMethod, &amp;#34;v@:&amp;#34;); 其中，参数的解释如下：
 cls表示被添加的类 name添加的方法的名称SEL imp方法的实现，该函数必须至少有两个参数self,_cmd  方法替换 下面OC代码实现替换ViewController的viewDidLoad方法：
@implementation ViewController  &#43; (void)load {  static dispatch_once_t onceToken;  dispatch_once(&amp;amp;onceToken, ^{  Class class = [self class];  SEL originalSelector = @selector(viewDidLoad);  SEL swizzledSelector = @selector(jkviewDidLoad);   Method originalMethod = class_getInstanceMethod(class,originalSelector);  Method swizzledMethod = class_getInstanceMethod(class,swizzledSelector);   //judge the method named swizzledMethod is already existed.  BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));  // if swizzledMethod is already existed.  if (didAddMethod) {  class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));  }  else {  method_exchangeImplementations(originalMethod, swizzledMethod);  }  }); }  - (void)jkviewDidLoad {  NSLog(@&amp;#34;替换的方法&amp;#34;);   [self jkviewDidLoad]; }  - (void)viewDidLoad {  NSLog(@&amp;#34;自带的方法&amp;#34;);   [super viewDidLoad]; }  @end OC的swizzling应该只在&#43;load中完成。在OC的Runtime中，每个类有两个方法都会自动调用。&#43;load是在一个类被初始装载时调用，&#43;initialize是在应用第一次调用该类的类方法或实例方法前调用的。两个方法都是可选的，并且只有在方法被实现的情况下才会被调用。
swizzling应该只在dispatch_once中完成，由于swizzling改变了全局的状态，所以我们需要确保每个预防措施在运行时都是可用的。原子操作就是这样一个用于确保代码只会被执行一次的预防措施，就算是在不同的线程中也能确保代码只执行一次。Grand Central Dispatch的dispatch_once满足了所需要的需求，并且应该被当做使用swizzling的初始化单例方法的标准。
在上图中，通过Swizzling特性，将selectorC的方法实现IMPc与selectorN的方法实现IMPn交换了，当调用selectorC，也就是给对象发送selectorC消息时，所查找到的方法实现就是IMPn而不是IMPc了。
KVO实现 KVO的全称是Key-value observing，译为键值观察。提供了一种当其它对象属性被修改的时候能通知当前对象的机制。再MVC大行其道的Cocoa中，KVO机制很适合实现model和controller类之间的通信。
KVO的实现依赖于OC强大的Runtime，当观察某对象A时，KVO机制动态创建一个对象A当前类的子类，并为这个新的子类重写了被观察属性keyPath的setter方法。setter方法随后负责通知观察对象属性的改变状况。
Apple使用了isa-swizzling来实现KVO。当观察对象A时，KVO机制动态创建一个新的名为：NSKVONotifying_A的新类，该类继承自对象A的本类，且KVO为 NSKVONotifying_A重写观察属性的setter方法，setter方法会负责在调用原setter方法之前和之后，通知所有观察对象属性值的更改情况。
NSKVONotifying_A类剖析：
NSLog(@&amp;#34;self-&amp;gt;isa:%@&amp;#34;,self-&amp;gt;isa); NSLog(@&amp;#34;self class:%@&amp;#34;,[self class]); 在建立KVO监听前，打印结果为：
self-&amp;gt;isa:A self class:A 在建立KVO监听之后，打印结果为：
self-&amp;gt;isa:NSKVONotifying_A self class:A 在这个过程，被观察对象的isa指针从指向原来的A类，被KVO机制修改为指向系统新创建的子类NSKVONotifying_A类，来实现当前类属性值改变的监听；
所以当我们从应用层面上看来，完全没有意识到有新的类出现，这是系统隐瞒了对KVO的底层实现过程，让我们误以为还是原来的类。但是此时如果我们创建一个新的名为NSKVONotifying_A的类，就会发现系统运行到注册KVO的那段代码时程序就崩溃，因为系统在注册监听的时候动态创建了名为NSKVONotifying_A的中间类，并指向这个中间类了。
子类setter方法剖析：
KVO的键值观察通知依赖于NSObject的两个方法willChangeValueForKey:和 didChangeValueForKey:，在存取数值的前后分别调用2个方法：被观察属性发生改变之前，willChangeValueForKey:被调用，通知系统该keyPath的属性值即将变更； 当改变发生后，didChangeValueForKey:被调用，通知系统该keyPath的属性值已经变更；之后，observeValueForKey:ofObject:change:context:也会被调用。且重写观察属性的setter方法这种继承方式的注入是在运行时而不是编译时实现的。
KVO为子类的观察者属性重写调用存取方法的工作原理在代码中相当于：
- (void)setName:(NSString *)newName {  [self willChangeValueForKey:@&amp;#34;name&amp;#34;]; //KVO 在调用存取方法之前总调用  [super setValue:newName forKey:@&amp;#34;name&amp;#34;]; //调用父类的存取方法  [self didChangeValueForKey:@&amp;#34;name&amp;#34;]; //KVO 在调用存取方法之后总调用 } 热更新JSPatch JSPatch是一个iOS动态更新框架，只需在项目中引入极小的引擎，就可以使用 JavaScript调用任何OC原生接口，获得脚本语言的优势：为项目动态添加模块，或替换项目原生代码动态修复bug。
关于消息转发，前面已经讲到过了，消息转发分为三级，我们可以在每级实现替换功能，实现消息转发，从而不会造成崩溃。JSPatch不仅能够实现消息转发，还可以实现方法添加、替换等一系列功能。
实现NSCoding的自动归档和自动解档 用Runtime提供的函数遍历Model自身所有属性，并对属性进行encode和decode操作。 核心方法：在Model的基类中重写方法：
- (id)initWithCoder:(NSCoder *)aDecoder {  if (self = [super init]) {  unsigned int outCount;  Ivar * ivars = class_copyIvarList([self class], &amp;amp;outCount);  for (int i = 0; i &amp;lt; outCount; i &#43;&#43;) {  Ivar ivar = ivars[i];  NSString * key = [NSString stringWithUTF8String:ivar_getName(ivar)];  [self setValue:[aDecoder decodeObjectForKey:key] forKey:key];  }  }  return self; }  - (void)encodeWithCoder:(NSCoder *)aCoder {  unsigned int outCount;  Ivar * ivars = class_copyIvarList([self class], &amp;amp;outCount);  for (int i = 0; i &amp;lt; outCount; i &#43;&#43;) {  Ivar ivar = ivars[i];  NSString * key = [NSString stringWithUTF8String:ivar_getName(ivar)];  [aCoder encodeObject:[self valueForKey:key] forKey:key];  } } 实现字典和模型的自动转换(MJExtension) 用runtime提供的函数遍历Model自身所有属性，如果属性在json中有对应的值，则将其赋值。 核心方法：在NSObject的分类中添加方法。
- (instancetype)initWithDict:(NSDictionary *)dict {   if (self = [self init]) {  //(1)获取类的属性及属性对应的类型  NSMutableArray * keys = [NSMutableArray array];  NSMutableArray * attributes = [NSMutableArray array];  /* * 例子 * name = value3 attribute = T@&amp;#34;NSString&amp;#34;,C,N,V_value3 * name = value4 attribute = T^i,N,V_value4 */  unsigned int outCount;  objc_property_t * properties = class_copyPropertyList([self class], &amp;amp;outCount);  for (int i = 0; i &amp;lt; outCount; i &#43;&#43;) {  objc_property_t property = properties[i];  //通过property_getName函数获得属性的名字  NSString * propertyName = [NSString stringWithCString:property_getName(property) encoding:NSUTF8StringEncoding];  [keys addObject:propertyName];  //通过property_getAttributes函数可以获得属性的名字和@encode编码  NSString * propertyAttribute = [NSString stringWithCString:property_getAttributes(property) encoding:NSUTF8StringEncoding];  [attributes addObject:propertyAttribute];  }  //立即释放properties指向的内存  free(properties);   //(2)根据类型给属性赋值  for (NSString * key in keys) {  if ([dict valueForKey:key] == nil) continue;  [self setValue:[dict valueForKey:key] forKey:key];  }  }  return self;  } 参考资料 参考资料 参考资料
</content>
    </entry>
    
     <entry>
        <title>陈小厨作品</title>
        <url>https://iihui.github.io/post/food-2020/</url>
        <categories>
          <category>美食</category>
        </categories>
        <tags>
          <tag>美食</tag>
        </tags>
        <content type="html">  2020年给自己定了些年度目标，用心下厨是其中一项。我是一个喜欢倒腾吃的人，每次看到自己做的东西既美味又有颜值的时候，总会很开心，但多数时候都忘了记录大致的步骤和拍照留存，2020年想给自己多留点值得回忆的东西，故以此为记。
 二月作品 猪血丸子、腊肉炒辣椒（猪血丸子先整个煮，再用冷水冷却，趁热切片，再放油小火煎，随后放佐料和辣椒中火翻炒）
花仙子桂花汤圆、湾仔码头水晶汤圆（烧开水再放汤圆，再小火慢煮，水开之后加一杯冷水，再开之后再加一杯冷水，然后煮到下面样子的时候捞出来）
萝卜和土豆炖牛腩和排骨（牛腩和排骨先煮，然后捞出来，洗干净，再和土豆萝卜一起放电饭煲里炖，炖差不多一个半小时）
排骨炖土豆（首先将排骨洗净，然后在放锅里煮，煮熟之后捞出来晾干，这一步主要是去浮沫，然后再放油煎一下排骨，煎完之后放土豆炒，之后放水煮即可，）
西兰花炒肉（首先将西兰花焯水，注意千万不要太久，然后炒肉，肉炒得差不多的时候放西兰花，再炒一段时间，炒得时间千万不要过长） 清炒胡萝卜（炒胡萝卜最关键的是切胡萝丝，一定要有耐心，厚度尽量保持一致，炒的时候不要太要太久，葱花最后要起锅的时候放）
炒长豆角丁（肉应该选那种肥瘦相间的，切成肉沫，肉沫应该先单独炒，放一些酸辣椒或者橄榄菜或许更好）
青椒炒肉(先炒肉，炒熟之后，再放姜蒜和小米椒大火炒几秒钟，再放青椒，翻炒一小会，最后和肉一起炒，临近起锅的时候放些生抽味道会更好)
早餐面（面上是卤豆腐，牛腩，腊猪血丸子）
 </content>
    </entry>
    
     <entry>
        <title>macOS 安装Homebrew 报错</title>
        <url>https://iihui.github.io/post/qa_install_brew/</url>
        <categories>
          <category>QA</category>
        </categories>
        <tags>
          <tag>QA</tag>
        </tags>
        <content type="html">  重装了macOS Catalina 10.15.2，但使用/usr/bin/ruby -e &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;安装Homebrew时报curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused错误，网上大多数说要设置代理，但于我而言没有任何效果。翻了一圈资料，猜测是系统的curl有问题，按照这个思路，首先应该使用另一种方式安装Homebrew，然后再利用Homebrew安装curl，最后设置Homebrew安装的curl优先级高于系统的curl。
 安装Homebrew 首先在浏览器中打开https://raw.githubusercontent.com/Homebrew/install/master/install。若不能打开，就是网络问题；如果能打开就如下图所示：
然后将这个网页的内容复制粘贴保存，并命名为brew_install.rb。再再终端中输入curl命令，如果出现curl: try &#39;curl --help&#39; or &#39;curl --manual&#39; for more information则表示curl本身没有问题：
接着在终端跳转到保存brew_install.rb的目录下，输入命令ruby brew_install.rb，以完成安装Homebrew。
安装并启用新curl 当上一步提示安装成功之后，则可以通过Homebrew安装curl，即在终端输入brew install curl，安装成功之后，如果在终端通过sh -c &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&amp;quot;命令安装oh my zsh 依然会报错curl: (35) Server aborted the SSL handshake 错误，这是因为brew安装的curl的优先级低于系统的。
接着就需要将Homebrew安装的curl的优先级调高，使其高于系统的curl，使用命令 brew link curl --force会提示 按照上面的提示，首先执行echo &#39;export PATH=&amp;quot;/usr/local/opt/curl/bin:$PATH&amp;quot;&#39; &amp;gt;&amp;gt; ~/.zshrc 然后将export LDFLAGS=&amp;quot;-L/usr/local/opt/curl/lib&amp;quot;和export CPPFLAGS=&amp;quot;-I/usr/local/opt/curl/include&amp;quot;放到.zshrc（我用的zsh，如果用户的是其他shell则修改对应的配置文件）中，至此问题解决。
参考资料 参考资料
另一种方式 由于众所周知的原因，安装homebrew经常报错，可以使用如下方式安装：
/bin/zsh -c &amp;#34;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&amp;#34; 参考资料
</content>
    </entry>
    
     <entry>
        <title>Almofire的使用</title>
        <url>https://iihui.github.io/post/ios-alamofire/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  如果使用过OC进行开发，那么知道AFNetworking这个网络操作库。Mattt Thompson作为AFNetworking的发起人，又基于Swift语言开发了一个新的网络操作库 Alamofire。Alamofire的优雅之处在于它完完全全是由Swift写成的，并且没有从AFNetworking那里继承任何特性。Alamofire网络库适用于iOS和macOS，它提供了链式request/response方法，JSON的传参和响应序列化，身份认证和其他特性。
 上传 func upLoadStaticsFile(){  do {  guard let sessionID = userInfoService.activeUser?.sessionID, let sessionIDSM = userInfoService.activeUse  return  }  let parameters = [&amp;#34;sessionID&amp;#34;: sessionID]  let formatter = DateFormatter()  formatter.dateFormat = &amp;#34;yyyy-MM-dd HH:mm:ss&amp;#34;  let temName = &amp;#34;\(formatter.string(from: Date()))-\(deviceID).txt&amp;#34;  let temPath = self.statisticsDir.path.stringByAppendingPathComponent(temName)  let path = self.statisticsDir.path.stringByAppendingPathComponent(fileName)  try FileManager.default.moveItem(atPath: path, toPath: temPath)  // 遍历埋点文件夹下的埋点数据文件,以获取  let fileList = try FileManager.default.contentsOfDirectory(atPath: statisticsDir.path)  let needUploadFileList = fileList.filter {  $0 != self.fileName  }  for file in needUploadFileList {  let path = self.statisticsDir.path.stringByAppendingPathComponent(file)  let dataURL = URL(fileURLWithPath: path)  let data = try Data(contentsOf: dataURL)  self.uploadFile(data: data, parameters: parameters, file: file, path: path)  }  } catch let error as NSError {  log.error(error.localizedDescription)  } } private func uploadFile(data: Data, parameters: [String: String], file: String, path: String) {  Alamofire.upload(multipartFormData: { multipartFormData in  multipartFormData.append(data, withName: &amp;#34;file&amp;#34;, fileName: file, mimeType: &amp;#34;text/plain&amp;#34;)  for (key, value) in parameters {  if let valueData = value.data(using: .utf8) {  multipartFormData.append(valueData, withName: key)  }  }  }, to: addreess, method: .post) { result in  switch result {  case .success:  do {  try FileManager.default.removeItem(atPath: path)  } catch let error as NSError {  log.error(error.localizedDescription)  }  case let .failure(error):  log.error(error.localizedDescription)  }  } } 下载 func requestScreenImage(url:String,completionHandler:@escaping (_ :Data?) -&amp;gt;Void){  Alamofire.request(url, method: .get).response { response in  if response.error == nil{  completionHandler(response.data)  }else{  completionHandler(nil)  }  } } func requestImage(url: String, completionHandler: @escaping (_ image: UIImage?) -&amp;gt; Void) {  self.tokenHttpController.requestLoginDataAndToken(type: .base64, success: { (data, token) in  let data = data?.extStringByUrlEncode ?? &amp;#34;&amp;#34;  let token = token?.extStringByUrlEncode ?? &amp;#34;&amp;#34;  let header: HTTPHeaders = [  &amp;#34;data&amp;#34;: data,  &amp;#34;token&amp;#34;: token  ]  Alamofire.request(url, method: .get, headers: header).response { (response) in  if let data = response.data {  let image = UIImage(data: data)  completionHandler(image)  }else{  completionHandler(nil)  }  }  }) {  completionHandler(nil)  } } func requestScreenADConfigInfo(completionHandler:@escaping (JSON) -&amp;gt; Void){  let url = ConfigRequestUrl  let op = ConfigRequestAction.getScreenPictureInfo  let meta = getDefaultMetaData(op)  var data = [String:String]()  if let model = ScreenADConfigDBRepository.Instance.getScreenConfigModel(),let jsonStr = model.screenConfigJsonStr{  if let dataJson = jsonStr.data(using: String.Encoding.utf8) {  do{  let json = try JSON(data:dataJson)  data[&amp;#34;configHash&amp;#34;] = json[&amp;#34;configHash&amp;#34;].stringValue  }catch{  data[&amp;#34;configHash&amp;#34;] = &amp;#34;&amp;#34;  }  }  }else{  data[&amp;#34;configHash&amp;#34;] = &amp;#34;&amp;#34;  }   switch UIDevice.current.userInterfaceIdiom{  case .pad: data[&amp;#34;type&amp;#34;] = &amp;#34;Pad&amp;#34;  case .phone: data[&amp;#34;type&amp;#34;] = &amp;#34;Phone&amp;#34;  default:break  }   var bodyData = [String:Any]()  bodyData[&amp;#34;meta&amp;#34;] = meta  bodyData[&amp;#34;data&amp;#34;] = data   Alamofire.request(url, method: .post, parameters: bodyData,encoding: JSONEncoding.default).responseJSON{ response in  switch response.result{  case .success(let value):  let json = JSON(value)  let subJSON = json[&amp;#34;data&amp;#34;]  let retCode = subJSON[&amp;#34;retCode&amp;#34;].stringValue  //retCode 为1表示有更新，0表示没有更新，其它表示出错  switch retCode{  case &amp;#34;1&amp;#34;:  completionHandler(subJSON)  case &amp;#34;0&amp;#34;: break  default:  let msg = subJSON[&amp;#34;retMsg&amp;#34;].stringValue  DPrint(msg)  }  case .failure(let error):  Dprint(error.localizedDescription)  }  } } func bindUserDevice(with model: LoginUserModel, and existUsers: ExistUsers, block: @escaping (_ model: UserInfoModel?, _ errorMsg: String?) -&amp;gt; Void) {  var dataDic = Dictionary&amp;lt;String, String&amp;gt;()  dataDic[&amp;#34;rand&amp;#34;] = UUID().uuidString   var metaDic = self.getDefaultMetaDic(forAction: ConfigRequestAction.bindUserDeviceV2)  metaDic[&amp;#34;ystID&amp;#34;] = model.ystId  metaDic[&amp;#34;sapID&amp;#34;] = model.sapId  metaDic[&amp;#34;inuseID&amp;#34;] = model.inUseId   let parameters = self.getRequestPostParameters(metaDic: metaDic, dataDic: dataDic)   Alamofire.request(ConfigRequestMoUrl, method: .post, parameters: parameters, encoding: JSONEncoding.default, headers: nil).responseJSON { (response) in  switch response.result {  case .success(let value):  let json = JSON(value)  if let retCode = json[&amp;#34;data&amp;#34;][&amp;#34;retCode&amp;#34;].string, retCode == &amp;#34;0&amp;#34; {  let model = UserInfoModel(from: json[&amp;#34;data&amp;#34;])  block(model, nil)  } else {  block(nil, json[&amp;#34;data&amp;#34;][&amp;#34;retMsg&amp;#34;].stringValue)  }  case .failure(_):  block(nil, &amp;#34;network is poor&amp;#34;)  }  } }  参考资料 参考资料 对比
</content>
    </entry>
    
     <entry>
        <title>UITableView 使用</title>
        <url>https://iihui.github.io/post/ios-uitableview/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  在iOS开发中，UITableView的使用频率较高，这篇文章主要用于记录一些常用的使用方法和问题解决方案。
 点击cell不变色 func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&amp;gt; UITableViewCell {  let cell = tableView.dequeueReusableCell(withIdentifier: cellId, for: indexPath) as! NoteDetailInfoCell  cell.selectionStyle = .none //点击该cell不变色  return cell }  Cell异步更新 在UITableView中经常要使用到异步请求，请求回来之后要更新相应cell的外观，由于UITableView中的cell存在复用问题，因此异步请求返回之后要特别小心处理。目前个人总结可以有三种方式。
使用内存缓存 在presenter中增加缓存，一般使用map来实现，然后一般以indexPath作为key（也可以其他具有唯一性的id作为key），以异步请求之后返回的某项数据作为value。异步返回之后，更新缓存，然后再在主线程中调用reload方法。
override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&amp;gt; UITableViewCell {  let cell = tableView.dequeueReusableCell(withIdentifier: self.zhGroupCellIdentifier, for: indexPath)  let model = self.presenter.dataSource[indexPath.row]  if let groupCell: ZHGroupCell = cell as? ZHGroupCell {  groupCell.nameLbl.text = model.sessionName  if let image = self.presenter.headCache[model.sessionID] {  groupCell.imgView.image = image  } else {  self.presenter.requestImage(id: model.sessionID,indexPath: indexPath) { [weak self] index in  DispatchQueue.main.async { [weak self] in  tableView.reloadRows(at: [index], with: .none)  }  }  }  }  }  return cell } /// 从服务端获取用户头像 private func getHeaderImageFromRemote(user: ContactsUser, indexPath: IndexPath) {  self.contactsHeadPhotoService.getServerImage(user: user) { [weak self] _ in  DispatchQueue.main.async { [weak self] in  if self?.tableView.cellForRow(at: indexPath) != nil {  if self?.isSearching == true {  self?.tableView.reloadRows(at: [indexPath], with: .none)  } else {  //非搜索状态时有可能有相同的联系人在不同的分组，所以选择全部reload  self?.tableView.reloadData()  }  }  }  } } 使用prepareForReuse() 使用KingFisher请求图片资源时，由于有些图片返回较慢，因为cell复用，可能会导致图片出现错乱，此时可以在prepareForReuse先取消相应的网络请求。
/// 因为使用kingfisher进行图片下载为异步的，所以要解决复用问题 override func prepareForReuse() {  super.prepareForReuse()  self.headerImageView.kf.cancelDownloadTask()  self.dkImageView.kf.cancelDownloadTask() } 设置对应cell 首先异步请求时多加一个indexPath参数，异步返回时把返回的数据和indexPath作为回调参数，然后根据indexPath找到对应的cell，最后更新cell的外观。
override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&amp;gt; UITableViewCell {  let cell = tableView.dequeueReusableCell(withIdentifier: self.zhGroupCellIdentifier, for: indexPath)  let model = self.presenter.dataSource[indexPath.row]  if let groupCell: ZHGroupCell = cell as? ZHGroupCell {  groupCell.nameLbl.text = model.sessionName  if let image = self.presenter.headCache[model.sessionID] {  groupCell.imgView.image = image  } else {  self.presenter.requestImage(id: model.sessionID,indexPath: indexPath) { [weak self] index in  DispatchQueue.main.async { [weak self] in  if let cell = tableView.cellForRow(at: index) as? ZHGroupCell,let model = self?.presenter.dataSource[index.row] {  cell.imgView?.image = self?.presenter.headCache[model.sessionID]  }  }  }  }  }  return cell } 分组显示 链接
range
动态调整footer高度 override func viewDidLayoutSubviews() {  super.viewDidLayoutSubviews()  guard let footerView = self.tableView.tableFooterView else {  return  }  let width = self.tableView.bounds.size.width  let size = footerView.systemLayoutSizeFitting(CGSize(width: width, height: UIView.layoutFittingCompressedSize.height))  if footerView.frame.size.height != size.height {  footerView.frame.size.height = size.height  self.tableView.tableFooterView = footerView  } } 参考
 </content>
    </entry>
    
     <entry>
        <title>Cocoapods 使用</title>
        <url>https://iihui.github.io/post/ios-cocoapods-storage/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> 放入制品库  项目需要引入百度语音合成SDK，但这个第三方库中包含的.a文件过于庞大，按规定不能直接放到代码仓库里，需要移到Cocoapods制品库中，然后再在项目中依赖这个组件。用已有的模板，只要按照要求修改对应文件，然后执行相应上传命令即可，这一过程可以总结为5个步骤。
 第一步 首先修改.podspec文件。为了修改.podspec文件，首先必须创建第三方库目录。下图为第三方库存放的目录结构，如需新建一个第三方库目录，则选中任意一个拷贝一份:
拷贝完了之后修改下图中长方形内文件或者文件夹(共3处)的名字，然后删除下图椭圆内的文件：
为了测试，将上图的副本重命名为BaiduTest，修改上面的3个地方的文件名，再删除文件后如下图所示:
然后修改.podspec文件，这个文件的修改必须使用终端文本编辑器（我使用vim编辑器），否则可能出错，这个文件也有三个地方需要修改。
第一个地方 首先修改s.name,s.version,s.summary,s.description这四个地方，其中s.name保持为上面修改的名字，版本号为0.0.1：
第二个地方 接下来修改s.homepage,只要将最后的名字修改为BaiduTest:
第三个地方 最后修改s.source,将后面两项修改即可，这两项的名字要和s.name和s.version保持一致:
 第二步 第二步修改push.py,目的是将LC10_01_BaiduTest这个目录打包并上传到仓库中，这个文件要修改两处:
第一个地方 将zipCommands后面的名字改为LC10_01_BaiduTest：
第二个地方 将uploadCommand命令后打包目录和打包后的文件的名字改成LC10_01_BaiduTest，如下图所示：
 第三步 第三步执行push.py，即转到push.py脚本所在目录执行./push.py即可。
第四步 修改工程所使用的podfile，在其中添加LC10_01_BaiduTest这一条目，如下图所示：
 第五步 第五步，在终端里首先执行pod repo-art update CocoaPods-cmb命令（可在任何目录），然后转到工程目录下执行pod update命令:
  pod repo-art update CocoaPods-cmb
  pod update
   incompatible target 发布MoUser组件时，使用pod lib lint进行本地检查，发现报错信息为not found for architecture ...
通过可以修改podspce文件，增加s.pod_target_xcconfig = { &#39;VALID_ARCHS&#39; =&amp;gt; &#39;arm64 armv7&#39;, &#39;EXCLUDED_ARCHS[sdk=iphonesimulator*]&#39; =&amp;gt; &#39;arm64&#39; }可以规避这个问题。
参考资料
@objc requires iOS 13.0.0 组件的二进制发布时，遇到了&#39;@objc&#39; instance method in extension of subclass of &#39;ModalViewController&#39; requires iOS 13.0.0 这样的报错信息。这是因为组件设置BUILD_LIBRARY_FOR_DISTRIBUTION = YES，这是因为Swift的ABI不稳定导致的，具体参考
</content>
    </entry>
    
     <entry>
        <title>引入百度语音合成</title>
        <url>https://iihui.github.io/post/ios-synthesizer/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  项目中需要用百度语音合成SDK，因此自己先建了一个Demo工程作为测试，总结下来为准备--&amp;gt; 导入 --&amp;gt; 创建应用 --&amp;gt; 测试。
 准备 首先从百度官网下载百度语音合成的SDK,如下图所示首先在左边选择语音合成，然后在右边选择iOS版的离在线融合SDK:
导入 有两部分需要导入，第一部分是导入百度语音合成所需的文件，第二部分是导入百度语音合成依赖的框架，下面分别讲解：
导入文件夹 接着新建一个测试工程，并将下载到的SDK解压，将下面的3个文件夹导入到项目中，3个文件夹的名称如下图所示:
导入框架 百度语音依赖如下红框里标识的framework，因此需要在TARGETS--&amp;gt;Build Phases-&amp;gt;LikBinary With Libraries中将这些framework导入到项目中：
创建应用 要使用百度语音合成，首先需要创建相关的应用，而创建应用的前提是有百度云帐号。注册好百度云帐号之后登录，在控制台选择百度语音：
然后选择创建百度语音应用：
接着填写相关信息，要注意的是语音包名要与测试工程的Bundle identifier一致（称为绑定），才可以使用百度语音合成的离在线模式:
测试代码 import UIKit  let APP_ID = &amp;#34;XXXXX&amp;#34; let API_KEY = &amp;#34;XXXXX&amp;#34; let SECRET_KEY = &amp;#34;XXXXX&amp;#34;  class ViewController: UIViewController, BDSSpeechSynthesizerDelegate {   fileprivate var synthesiser: BDSSpeechSynthesizer = BDSSpeechSynthesizer.sharedInstance()  @IBOutlet weak var synthesisButton: UIButton!  @IBOutlet weak var textView: UITextView!  @IBOutlet weak var offlineSwitch: UISwitch!   override func viewDidLoad() {  super.viewDidLoad()  BDSSpeechSynthesizer.setLogLevel(BDS_PUBLIC_LOG_VERBOSE)  self.synthesiser.setSynthesizerDelegate(self)  self.textView.delegate = self  self.configOffline()  }   @IBAction func clickedSynthesis(_ sender: UIButton) {  if let sentence = self.textView.text {  self.synthesiser.speakSentence(sentence, withError: nil)  }  }   @IBAction func offlineSwitchClicked(_ sender: UISwitch) {  if sender.isOn {  self.configOffline()  } else {  self.configOnline()  }  }   func configOnline() {  self.synthesiser.setApiKey(API_KEY, withSecretKey: SECRET_KEY)  var error = self.synthesiser.setSynthParam(4, for: BDS_SYNTHESIZER_PARAM_PITCH)  if let err = error {  print(err.localizedDescription)  }  error = self.synthesiser.setSynthParam(5, for: BDS_SYNTHESIZER_PARAM_SPEED)  if let err = error {  print(err.localizedDescription)  }  error = self.synthesiser.setSynthParam(9, for: BDS_SYNTHESIZER_PARAM_VOLUME)  if let err = error {  print(err.localizedDescription)  }  self.synthesiser.unloadDomainDataFromOfflineEngine()  }   func configOffline() {  let offlineEngineSpeechData = Bundle.main.path(forResource: &amp;#34;Chinese_And_English_Speech_Female&amp;#34;, ofType: &amp;#34;dat&amp;#34;)  let offlineChineseAndEnglishTextData = Bundle.main.path(forResource: &amp;#34;Chinese_And_English_Text&amp;#34;, ofType: &amp;#34;dat&amp;#34;)   let error = self.synthesiser.loadOfflineEngine(offlineChineseAndEnglishTextData, speechDataPath: offlineEngineSpeechData, licenseFilePath: nil, withAppCode: APP_ID)  if let err = error {  print(err.localizedDescription)  }  }   func synthesizerNewDataArrived(_ newData: Data!, dataFormat fmt: BDSAudioFormat, characterCount newLength: Int32, sentenceNumber SynthesizeSentence: Int) {   }   func synthesizerErrorOccurred(_ error: Error!, speaking SpeakSentence: Int, synthesizing SynthesizeSentence: Int) {  print(error.localizedDescription)  }   override func viewDidDisappear(_ animated: Bool) {  super.viewDidDisappear(animated)  self.synthesiser.speakSentence(&amp;#34;进入后台&amp;#34;, withError: nil)  } }  extension ViewController: UITextViewDelegate {  func textViewDidChange(_ textView: UITextView) {  if let text = textView.text {  //self.synthesiser?.speakSentence(text, withError: nil)  print(text)  }  } } 参考资料
</content>
    </entry>
    
     <entry>
        <title>半透明的悬浮提示窗</title>
        <url>https://iihui.github.io/post/ios-alert-window/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  项目中需要一个悬浮提示窗，从网上找到一篇以OC为示例的文章，因为公司项目是Swift写的，因此需要将OC转为Swift。
 OC代码 .h文件 //CustomAlertWindow.h #import &amp;lt;UIKit/UIKit.h&amp;gt; typedef NS_ENUM(NSInteger, AlertWindowPositionOption) {  AlertWindowPositionTopMiddle = 0,  AlertWindowPositionCenter,  AlertWindowPositionBottomMiddle };  @interface CustomAlertWindow : UIWindow &#43; (instancetype)aletWindowWithPositionOption:(AlertWindowPositionOption)positionType andInfoText:(NSString *)text; //显示 - (void)show; // 消失 - (void)dismiss; @end .m文件 //CustomAlertWindow.m  #import &amp;#34;CustomAlertWindow.h&amp;#34;  #define LABEL_MARGIN 10 //Label的外边距 #define CENTER_Y_TO_EDGE 80 //悬浮窗中心点距边缘的纵坐标值  @implementation CustomAlertWindow  &#43; (instancetype)aletWindowWithPositionOption:(AlertWindowPositionOption)positionType andInfoText:(NSString *)text {  return [[CustomAlertWindow alloc] initWithPositionOption:positionType andInfoText:text]; }  - (instancetype)initWithPositionOption:(AlertWindowPositionOption)positionType andInfoText:(NSString *)text {  self = [super init];  if (self) {  UILabel *infoLabel = [[UILabel alloc] initWithFrame:CGRectMake(0, 0, 40, 15)];  infoLabel.text = text;  infoLabel.textAlignment = NSTextAlignmentCenter;  infoLabel.font = [UIFont systemFontOfSize:13];  infoLabel.textColor = [UIColor whiteColor];  //label尺寸适应文字大小  [infoLabel sizeToFit];   //根据labelSize确定window的大小  CGSize labelSize = infoLabel.frame.size;  CGSize windowSize = CGSizeMake(labelSize.width &#43; 2*LABEL_MARGIN, labelSize.height &#43; 2*LABEL_MARGIN);  //根据window的尺寸确定label的中心点位置  infoLabel.center = CGPointMake(windowSize.width / 2, windowSize.height / 2);   //得到屏幕的尺寸  CGRect superRect = [[UIScreen mainScreen] bounds];  CGSize superSize = superRect.size;  //计算window的大小  self.frame = CGRectMake((superSize.width - windowSize.width) / 2, 0, windowSize.width, windowSize.height);   //根据指定的positionType设置window的center  switch (positionType) {  case AlertWindowPositionTopMiddle:  self.center = CGPointMake(superSize.width / 2, CENTER_Y_TO_EDGE);  break;   case AlertWindowPositionCenter:  self.center = CGPointMake(superSize.width / 2, superSize.height / 2);  break;   case AlertWindowPositionBottomMiddle:  self.center = CGPointMake(superSize.width / 2, superSize.height - CENTER_Y_TO_EDGE);  break;   default:  break;  }   self.windowLevel = UIWindowLevelAlert &#43; 1;  self.backgroundColor = [UIColor colorWithRed:64 / 255.0 green:64 / 255.0 blue:64 / 255.0 alpha:0.7];  self.layer.cornerRadius = 5;   [self addSubview:infoLabel];  }   return self; }  //显示window - (void)show {  [self makeKeyAndVisible]; }  //window消失 - (void)dismiss {  [self resignKeyWindow]; }  @end  Swift实现 根据上面的OC代码，将其改造为Swift代码：
import Foundation //参考自 https://www.jianshu.com/p/e31eeb26cdce enum positionStyle: Int {  case TopMiddle = 0  case Center = 1  case BottomMiddle = 2 }  class NoteAlertWindow: UIWindow {  fileprivate var style = positionStyle.TopMiddle  fileprivate var infoLabel: UILabel?  fileprivate var labelMargin: CGFloat = 10  fileprivate var centerYToEdge: CGFloat = 80   required init?(coder aDecoder: NSCoder) {  super.init(coder: aDecoder)  }   init(option: positionStyle, text: String) {  let frame = CGRect()  super.init(frame: frame)  self.style = option   if self.infoLabel == nil {  self.infoLabel = UILabel(frame: CGRect(x: 0, y: 0, width: 30, height: 15))  adjustWindow(message: text)  self.addSubview(self.infoLabel!)  }  }   func show() {  self.makeKeyAndVisible()  }   func dismiss() {  self.resignKey()  }   func moveCenter(center: CGPoint) {  self.center = center  }   func setMessage(text: String) {  adjustWindow(message: text)  }   fileprivate func adjustWindow(message: String) {  self.infoLabel?.text = message  self.infoLabel?.textAlignment = .center  self.infoLabel?.font = UIFont.systemFont(ofSize: 13)  self.infoLabel?.textColor = UIColor.white  self.infoLabel?.sizeToFit()   if let labelSize = self.infoLabel?.frame.size {  let windowSize = CGSize(width: labelSize.width &#43; 2 * self.labelMargin, height: labelSize.height &#43; 2 * self.labelMargin)  self.infoLabel?.center = CGPoint(x: windowSize.width / 2, y: windowSize.height / 2)  let superGect = UIScreen.main.bounds  let superSize = superGect.size   self.frame = CGRect(x: (superSize.width - windowSize.width) / 2, y: 0, width: windowSize.width, height: windowSize.height)   switch self.style {  case .TopMiddle: self.center = CGPoint(x: superSize.width / 2, y: self.centerYToEdge)  case .Center: self.center = CGPoint(x: superSize.width / 2, y: superSize.height / 2)  case .BottomMiddle: self.center = CGPoint(x: superSize.width / 2, y: superSize.height / 2 - self.centerYToEdge)  }   self.windowLevel = UIWindowLevelAlert &#43; 1  self.backgroundColor = UIColor(red: 64 / 255.0, green: 64 / 255.0, blue: 64 / 255.0, alpha: 0.7)  self.layer.cornerRadius = 5  }  } }  </content>
    </entry>
    
     <entry>
        <title>JS事件捕获</title>
        <url>https://iihui.github.io/post/js-event/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>JS</tag>
        </tags>
        <content type="html">  DOM事件从发生到开始经历了三个阶段，分别为捕获阶段、命中阶段以及冒泡阶段。捕获阶段表示从最上层开始，直到最下层(点击的那个target元素)，路过的所有节点都可以捕获到该事件。命中阶段:如果某个事件到达了target，它就会进行处理。冒泡阶段:事件从最下层向上传递，依次触发父元素的该事件处理。
 </content>
    </entry>
    
     <entry>
        <title>使用Visual Code的文件对比功能</title>
        <url>https://iihui.github.io/post/qa-compare/</url>
        <categories>
          <category>QA</category>
        </categories>
        <tags>
          <tag>QA</tag>
        </tags>
        <content type="html">  在使用坚果云的时候，由于较长时间没有同步，导致本地文件和云端文件冲突，再次同步时，坚果云保留了两个版本。为了弄清两个文件的差异，以进行修改，需要一个工具来比对。最初是想下载一个专门的文件对比软件，但转念一想或许Visual Code可以呢，一搜果真Visual Code自带文件对比功能。
 废话不多说，首先放上动图：
上面动图的操作可以分解为3步，第一步为打开左侧边栏，第二步为打开需要比较的文件，第三步为对比。
 第一步 首先打开SideBar，在菜单栏中依次点击View--&amp;gt;Appearance--&amp;gt;Toggle Side Bar,如下图所示:
 第二步 按住Command &#43; o(字母)打开要比较的文件，或者在菜单栏找到File---&amp;gt;Open：  第三步 在左侧的Open Editors目录下找到上一步需要比较的文件，然后点击鼠标右键，选中Compare Selected进行比对：  </content>
    </entry>
    
     <entry>
        <title>创建新的Target</title>
        <url>https://iihui.github.io/post/ios-new-target/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  项目需要新建一条众测流水线，因此首先需要基于DEV环境新建一个Target，然后将新建的Target配置到新建的流水线上。
 Duplicate 新Target的创建一般以已有的Target为模板，如下图所示，首先选中模板Target，然后右键点击选中Duplicate就能创建新的Target:
 修改Target名字 首先点击新的Target然后按回车键修改名字，此时修改的名字
修改plist 一旦点击Duplicate就会生成一个模板的copy,同时会生成一个新的plist文件，如下图所示： 新的plist文件和
</content>
    </entry>
    
     <entry>
        <title>Range的保存与恢复</title>
        <url>https://iihui.github.io/post/js-focus-save/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>JS</tag>
        </tags>
        <content type="html">  在iOS 11.3以下的UIWebview中插入图片时，因图片选择器的弹出导致UIWebview失去焦点，故在插入图片前需先保存图片将要插入的位置。
 保存range区域 图片选择器打开前，利用一个全局的Range对象保存插入前光标所在的位置的Range对象：
//插入图片和超链接的时候因为webview会失去焦点，因此需要保存range区域 let currentSelection; function backupRange() {  let selection = window.getSelection();  if (selection.rangeCount) {  let range = selection.getRangeAt(0);  this.currentSelection = {  &amp;#34;startContainer&amp;#34;: range.startContainer,  &amp;#34;startOffset&amp;#34;: range.startOffset,  &amp;#34;endContainer&amp;#34;: range.endContainer,  &amp;#34;endOffset&amp;#34;: range.endOffset  }  } }  恢复Range区域 选择图片后，插入时要找到图片选择器打开前光标所在的Range，以便插入到正确的位置：
//恢复保存的range区域 function restoreRange() {  if (this.currentSelection) {  let selection = window.getSelection();  selection.removeAllRanges();  let range = document.createRange();  range.setStart(this.currentSelection.startContainer, this.currentSelection.startOffset);  range.setEnd(this.currentSelection.endContainer, this.currentSelection.endOffset);  selection.addRange(range); // 向选区中添加一个区域  } }  </content>
    </entry>
    
     <entry>
        <title>Swift访问权限</title>
        <url>https://iihui.github.io/post/swift-access-controller/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  访问权限用于限制部分代码被其它源文件或者模块访问，目的是隐藏某些代码的实现细节。在Swift中可以设置类型(类、结构和枚举)的访问权限，也可以设置属性和方法的访问权限。Swift提供了5个访问级别，这些访问级别以模块和源文件为区分粒度。
 模块 模块是指独立的代码单元，在iOS中框架或应用程序就是一个独立模块。在一个模块中可以用import关键字导入另一个模块。
源文件 源文件即Swift中的源代码文件，它通常属于一个模块，即一个框架（Framework）或者应用程序。
访问级别 Swift有5个级别的访问权限，从高到低依次为open，public，internal，fileprivate和private。它们遵循的原则是，高级别的变量不允许被定义为低级别变量的成员变量。例如，一个private的类中不应该出现public的String。但是，低级别的变量可以定义在高级别的变量中。例如，public的class中可以含有private的Int值。
open open具有最高的访问权限。其修饰的类和方法可以在任意Module中被访问和重写，它是Swift3中新添加的访问权限。
public public的权限仅次于open，它与open区别在于：public修饰的对象可以在任意module中被访问，但是不能被其他module重写或继承。
open与public的区别 虽然open和public都有最高的访问级别，但open访问权限只适用于修饰class和class的成员，它与public有明显的不同：
  public修饰的class只允许外部模块调用，但是不允许外部模块继承，本模块可以继承。而open修饰的class既允许其他模块调用，也允许被子类继承。
  public修饰的成员只允许其他模块调用，但不能被外部模块重写(override)，本模块可以重写。而open修饰的成员既允许被其他模块调用，也允许成员被覆盖。
  open和public如果是用于继承某个类的话，那么open和public必须是在父类的约束限定之下。例如：不能父类是用public修饰，而子类却用open修饰。
  其他模块继承覆盖父类的成员时，也需要把成员声明为open。
  open class SubclassableParentClass {  public func foo() {  //  }   open func bar() {  //  }   public final func baz() {  //  } }  open class SubclassC: SubclassableParentClass {  //非法，成员没有被声明为open  override func bar() {  //  } } internal internal是默认的权限。它表示只能在当前定义的module中访问和重写。它可以被一个module中的多个文件访问，但不能被其他module访问。
fileprivate 由fileprivate修饰的实体可以在当前文件内被访问。若某个功能只要在文件内使用，则可以使用这个访问符修饰，这也是Swift 3新添加的权限。
private private是最低阶别的访问权限，它的对象只能在定义的作用域内使用，离开了这个作用域，即时是同一个文件的其他作用域，也无法访问。
</content>
    </entry>
    
     <entry>
        <title>img添加和取消点击监听</title>
        <url>https://iihui.github.io/post/js-image-addclicklistener/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>JS</tag>
        </tags>
        <content type="html">  一篇图文笔记可能有多张图片，目前的需求为单击图片后开始预览图片。想到的解决思路有两种，第一种是为每张图片添加点击事件的监听，这种方式的麻烦在于要监听是否有新图片插入，一旦有新图片插入时则要对其加入点击事件的监听；第二种则是全局监听点击事件，用户一旦点击，则判断该点击事件是否在img标签上，如果是则进入图片预览，否则什么也不做。
 第一种方式 每次进入图文笔记的浏览模式时为所有img添加点击事件的监听。因此，需要监听是否有新图片插入，一旦有新图片插入时需要将原来所有图片的点击事件的监听删除，再重新为所有图片添加新的点击监听。
添加监听 function addImagesClickListener(){  $(&amp;#39;body&amp;#39;).on(&amp;#39;click&amp;#39;, &amp;#39;img&amp;#39;, function () {  let position = this.offsetTop;  this.focus();  let result = {};  result.position = position.toString(); //顺便将图片所在纵位置返回  result.src = $(this).attr(&amp;#34;src&amp;#34;);  let jsonString = JSON.stringify(result);  let escapedJsonString = encodeURI(jsonString); //重新编码  let scheme = &amp;#34;position://&amp;#34;;  document.location.href = scheme &#43; &amp;#34;#&amp;#34; &#43; escapedJsonString; //向ios发送  }); }  取消监听  function removeImagesClickListener() {  // let pic = document.getElementsByTagName(&amp;#39;img&amp;#39;);  // for (i = 0; i &amp;lt; pic.length; i&#43;&#43;) {  // pic[i].off(&amp;#39;click&amp;#39;);  // }  $(&amp;#39;img&amp;#39;).each(function () {  $(this).off(&amp;#39;click&amp;#39;); //移除所有图片的点击监听  })  }  第二种方式 利用全局监听点击事件，检查该点击事件的元素是否在img上，如果是则进入图片预览模式，但是这种方式会与UIWebview键盘弹出有冲突，因此进入图片浏览时需要先关掉键盘：
//与软键盘弹出有冲突，应该先关闭键盘 function clickHandler(event) {  if (event.target instanceof HTMLImageElement) {  //点击的是图片标签,则获取点击图片的src  $(&amp;#39;img&amp;#39;).each(function () {  if (this.isSameNode(event.target)) {  //https://segmentfault.com/q/1010000000156830/a-1020000000156902  document.activeElement.blur(); //首先关闭键盘以免冲突  let result = {};  result.src = $(this).attr(&amp;#34;src&amp;#34;);  let jsonString = JSON.stringify(result);  let escapedJsonString = encodeURI(jsonString); //重新编码  let scheme = &amp;#34;position://&amp;#34;;  document.location.href = scheme &#43; &amp;#34;#&amp;#34; &#43; escapedJsonString; //向ios发送  }  });  } }  </content>
    </entry>
    
     <entry>
        <title>img点击监听</title>
        <url>https://iihui.github.io/post/js-image-clickedlistener/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>JS</tag>
        </tags>
        <content type="html">  一篇图文笔记可能有多张图片，目前的需求为单击图片后开始预览图片。想到的解决思路有两种，第一种是为每张图片添加点击事件的监听，这种方式的麻烦在于要监听是否有新图片插入，一旦有新图片插入时则要对其加入点击事件的监听；第二种则是全局监听点击事件，用户一旦点击，则判断该点击事件是否在img标签上，如果是则进入图片预览，否则什么也不做。
 第一种方式 每次进入图文笔记的浏览模式时为所有img添加点击事件的监听。因此，需要监听是否有新图片插入，一旦有新图片插入时需要将原来所有图片的点击事件的监听删除，再重新为所有图片添加新的点击监听。
添加监听 function addImagesClickListener(){  $(&amp;#39;body&amp;#39;).on(&amp;#39;click&amp;#39;, &amp;#39;img&amp;#39;, function () {  let position = this.offsetTop;  this.focus();  let result = {};  result.position = position.toString(); //顺便将图片所在纵位置返回  result.src = $(this).attr(&amp;#34;src&amp;#34;);  let jsonString = JSON.stringify(result);  let escapedJsonString = encodeURI(jsonString); //重新编码  let scheme = &amp;#34;position://&amp;#34;;  document.location.href = scheme &#43; &amp;#34;#&amp;#34; &#43; escapedJsonString; //向ios发送  }); }  取消监听  function removeImagesClickListener() {  // let pic = document.getElementsByTagName(&amp;#39;img&amp;#39;);  // for (i = 0; i &amp;lt; pic.length; i&#43;&#43;) {  // pic[i].off(&amp;#39;click&amp;#39;);  // }  $(&amp;#39;img&amp;#39;).each(function () {  $(this).off(&amp;#39;click&amp;#39;); //移除所有图片的点击监听  })  }  第二种方式 利用全局监听点击事件，一旦出现点击事件，则判断该点击事件的元素是否在img上，如果是则进入图片预览模式，但是这种方式会与UIWebview键盘弹出有冲突，因此进入图片浏览前需要先关掉键盘：
//与软键盘弹出有冲突，应该先关闭键盘 function clickHandler(event) {  if (event.target instanceof HTMLImageElement) {  //点击的是图片标签,则获取点击图片的src  $(&amp;#39;img&amp;#39;).each(function () {  if (this.isSameNode(event.target)) {  //https://segmentfault.com/q/1010000000156830/a-1020000000156902  document.activeElement.blur(); //首先关闭键盘以免冲突  let result = {};  result.src = $(this).attr(&amp;#34;src&amp;#34;);  let jsonString = JSON.stringify(result);  let escapedJsonString = encodeURI(jsonString); //重新编码  let scheme = &amp;#34;position://&amp;#34;;  document.location.href = scheme &#43; &amp;#34;#&amp;#34; &#43; escapedJsonString; //向ios发送  }  });  } }  </content>
    </entry>
    
     <entry>
        <title>单例模式</title>
        <url>https://iihui.github.io/post/ios-singleton/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  单例模式(Singleton Pattern)属于创建型模式，该模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有一个单例对象被创建。
 第一种方式 第一种方式是利用Swift中全局变量懒加载和全局变量初始化时默认使用dispatch_once以保证全局变量的构造器只会被调用一次:
let sharedManager = MyManager(string: someString) //定义全局变量 class MyManager {  let string: String  //初始化器  init(string: String) {  self.string = string  } }  第二种方式 利用static和private两个关键字,static关键字说明该变量是类变量而不是实例变量；而private保证了该类变量为单例：
class MyManager {  // 全局变量  static let shared = MyManager(string: someString)   // 属性  let string: String  // 初始化器  private init(string: String) {  self.string = string  } } // 使用 print(MyManager.shared)  第三种方式 第三种方式是让单例在闭包中初始化，同时加入类方法以获取单例。这种方式的好处是可以在闭包中做一些额外的配置：
class MyManager {  // private 修饰  private static let sharedManager: MyManager = {  let shared = MyManager(string: someString)  // 可以做一些其他的配置  // ...  return shared  }()  // Properties  let string: String  // 构造函数，由private修饰  private init(string: String) {  self.string = string  }  // 访问器  class func shared() -&amp;gt; MyManager {  return sharedManager  } } //使用 print(MyManager.shared()) 单例的缺陷   由于单例是共享的，因此程序员无法预测单例当前的状态。
  因为其它共享的实例可以修改，因此测试困难。
  无法对访问权限作出限定，容易造成管理上的混乱。
   参考资料
</content>
    </entry>
    
     <entry>
        <title>Papers教程</title>
        <url>https://iihui.github.io/post/tool-papers/</url>
        <categories>
          <category>Tool</category>
        </categories>
        <tags>
          <tag>Tool</tag>
        </tags>
        <content type="html">  Papers软件对自己的定位为个人科研图书馆，其主要功能为文献收集(Find)、文献整理(Organize)、文献阅读(Read)和文献引用(Cite)。这篇教程主要关注Papers的引用功能。
 四个功能 首先对上面提到的4个功能进行简介，以对Papers这个软件有个初步的认识，同时也可以了解文献管理软件的基本功能特点。
文献收集 文献收集：把原来需要借助浏览器从谷歌学术等学术站点搜索文献的功能整合到Papers软件中。即可以直接在Papers中搜索文献，而不用切换到浏览器去搜索文献。但因为这是国外开发的一款软件，因此不支持如百度学术这样的中文学术搜索站点：
文献整理 文献整理：利用Papers对收集到的学术资料进行整理。换句话说，就是对搜集到的文献资料进行分类整理，建立档案系统的过程。
有了完善的档案系统，后续需要查找某个文献的时候，只要在Papers中进行搜索就可以。如果需要引用某个文献只要按住快捷键搜索就可导入到Word中(随后详细介绍)。下面就你开题时我帮你查资料时，整理的一些参考文献：
文献阅读 文献阅读：是指可以在Papers中阅读文献，但只限于PDF文档和在Papers中搜索到的文章。可以事先将PDF文档导入到Papers中，或者在Papers中下载相关的PDF文档，再在其中阅读。下图即为阅读界面：
文献引用 文献引用：就是在Papers建立的个人图书馆中搜索相关的文献，然后将其对应的引用格插入到Word或者其他的文字编辑软件中，下面的动图是一个简单的例子：
上面的动图实际上是5个步骤组合起来的效果，后面会详细介绍，当前只做一个演示。
安装与打开 软件安装 通过上面4个功能的简介，你对这个软件应该有一点了解了，下面开始介绍怎么安装软件。先下载软件，然后按照下面的gif的步骤进行操作即可：
上面gif所演示的操作可以分解为3步：
  首先选中后缀为.dmg的文件，然后双击打开，出现下图所示的界面：   在上图中点击同意，然后出现下图所示的界面：   将上图中的Papers拖到Applications中，安装到此完成了。
   打开软件 首先在应用程序中找到Papers的图标，然后点击该图标以打开Papers软件：
当第一次打开时，会提示Papers是从互联网下载的应用程序，是否确定要打开它：
在上图中点击打开，软件会要求创建一个新库或者导入以前在电脑里保存的库(只有第一次打开才会有这个提示)：
因为是第一次安装，因此选择创建新库即可，上图中Other Location表示可以选择创建新的库的存放位置，选择默认即可，不用去设置。
软件界面 打开了软件，软件的5大区域映入眼帘，分别为左侧边栏，顶部按钮栏，主工作区,预览区域和右侧边栏，如下图所示：
顶部按钮 顶部按钮栏包括6个小按钮，如下图所示从左到右分别为搜索、库、标记、作者、来源以及阅读。除了搜索按钮外，其他5个按钮均表示分类查看文献：
  搜索：搜索文献(在此处搜索和在浏览器搜索有相似的效果)。
  库：表示查看导入到软件中的所有文献。
  标记：按照事先做好的标记来查看文献。
  作者：根据作者来查看文献。
  来源：根据文献的来源来查看。
  阅读：在这个软件中阅读打开的文献(指PDF文档或者网页)。
  左侧边栏 当点击某个顶部按钮后，左侧边栏显示的是分类和结构（具体功能决定于点击的是哪个顶部按钮），下图为前5个顶部按钮对应的左侧边栏：
 右侧边栏 当点击某个顶部按钮后，右侧边栏显示的是在主工作区中选中的某篇文献的属性。如下图所示，属性分为四种，从左到右分别表示概览、信息、笔记和动态：
  概览(Overview)：显示的是选中文献的类型(Type)、标题(Title)、作者(Authors)、来源(Sources)（这些信息在概览中不可以修改,需要在Info中修改）。同时可以给文献添加或修改评论(My Review)、关键字(Keyword)，也可以把选中的文献放入某个收藏集(Collection)，也可以给文章按1~5颗星的标准评分，添加颜色(Color)标记和旗标(Flag)。
  信息(Info): 这里可以修改文档大部分属性，如标题(Title)、副标题(Subtitle)、作者(Authors)、类型(Type)、出版日期(Published) 等。
  笔记(Notes): 如果对一篇文章进行了标注，添加了笔记，将在这里显示。
  动态(Activity): 显示的是与选中的文献相关的文献，以及社交网络分享情况。
  下图展示的是点击概览、信息、笔记和动态按钮后所展示的界面：
导入文献 通过安装软件和界面的展示，应该对这个软件有了一个整体的认识，那接下来就介绍怎么将参考文献导入到Papers中。
建立库的过程就是将文献不断导入到Papers软件中。导入文献有两种方式，一种是通过软件的搜索来导入，一种是通过导入文件的形式导入。
搜索导入 搜索导入指的是首先在软件中进行搜索，然后将搜索到的文献直接导入软件中，如下动图所示：
这种方式看起来虽然很方便，但有3只拦路虎🐯阻止了我们使用这个功能☹️：
  第一只🐯&amp;mdash;不支持中文站点。在前面讲文献收集的时候，我提到过因为是外国的软件，所以暂时不支持如百度学术等的中文站点的搜索，这导致了不能将中文参考文献直接导入到软件中(后面会说通过“曲线救国”的方式来导入)。   从上面的图来看，你可能会问谷歌学术不是支持中文搜索吗? 谷歌学术 是支持中文搜索，但是有两个问题要弄明白：首先正常状态下(不翻墙)我们不能直接访问谷歌学术，其次谷歌学术上收录中文期刊比较少，不如百度学术丰富。所以第二只🐯&amp;mdash;支持中文搜索的引擎收录的中文参考文献少而且正常情况下不能直接访问这些站点。
  第三只🐯&amp;mdash;搜索功能对于中文输入及其不友善。搜索的时候只能一个字一个字输入，不能一下子输入两个以上字的词(听起来就想很无语😁是吧？)。   啰嗦了这么一大堆，你可能会疑惑那为什么还要把这个搜索导入单独拿出来讲这么多？ 那是因为写论文时有很多参考文献都是英文的，搜中文不行，直接搜索导入英文参考文献它还是可以的😂。
文件导入 因为不支持中文站点的直接搜索，那么我们就先到百度学术上去搜索，看看能不能直接引用：
疑惑1 看到上面那个gif里的那个引用按钮是不是有点小雀跃？哈哈，竟然能直接引用诶😄。到最后一步是不是又有点懵了？&amp;mdash;我是该直接复制呢，还是选一个链接导入到文献管理软件呢？
哈哈，当然是选「利用其中一个链接导入到文献管理软件中」，因为复制粘贴的话，一旦在Word中删除或者添加一个文献时，引用的小上标的序号都需要修改，参考文献很多时，这个就变得异常麻烦。
疑惑2 上面那个疑惑解决了，看到导入链接有好几个选项，你是不是开始疑惑应该要选哪一个呢？
答案是选Papers支持导入的格式，在Papers的菜单栏中依次打开File---&amp;gt;Import可以查看支持的导入格式：
和上面一对比，可以发现BibTex、EndNote和Refman(不需要知道这三种格式具体是怎么样的)都支持。所以这3种都是可以选的，在Word中我通常会选EndNote，因此下面的介绍都默认选择EndNote格式的引用。
下载 点击EndNote之后会自动下载引用文件，引用文件是存储文献中的作者、发表年代以及发表的期刊等信息的文件，不是指文献本身，如下所示：
上面下载的引用文件默认是保存到下载目录，如果下载目录没有叫做xueshu.enw的文件，那么刚刚下载的引用文件就会被命名为xueshu.enw，如果已经有了就会被命名为xushu-2.enw，如果再下载新的引用文件则会命名为xushu-3.enw，依次类推，如下所示：
导入 下载后引用文件，就要将其导入到Papers中，使其成为文献库的一部分。导入分为两种方式，第一种是还没有打开papers软件，第二种情况是已经打开Papers软件。
未打开导入 先看还没有打开Papers软件的情况，首先选中要导入的引用文件(如果要选多个就按住shift键，然后一个一个添加)，然后双击即可(是不是超简单呢😄):
 打开导入 如果已经打开了Papers软件，那么就在顶部的菜单栏中找到File--&amp;gt;Import--&amp;gt;EndNoteEnw导入即可：
修改信息 修改作者 问题引入 按照上面的方式导入了引用文件，按理来说此时应该就可以直接进入引用了。那接下来我们就开始引用，看会不会出现什么问题。假如我们要引用《音乐的德育功能》这篇论文：
从上面的动图，不难看出作者的名字从焉树芬变成了芬焉树，也就是Papers把作者的姓放在了后面。看到这你应该明白这是中西方文化差异引起的。
那你肯定会有疑问，是不是哪个地方能改呢。还真被你猜到了，在Papers中的设置中可以修改(但你接下来会发现软件的开发者太不友好了)，在菜单栏按照如下操作Papers--&amp;gt;Preferences--&amp;gt;Sources--&amp;gt;Author Format：
上面的例子中作者的中文名字叫做冯登科，从动图中可以发现，所有的组合都没能正确显示冯登科(看Example那一行)，最接近的中间还有个,。
看到这里你可能会想这个软件好菜😂，为什么一到中文就不行了呢？ 其实它对英文参考文献是很友好的，只是还没有对中文进行优化。
解决方案 是不是没有解决方法呢？这个问题是有一种解决方案的，先来看动图的操作：
为了详细的介绍，将上面的操作可以分解为3步：
  首先单击选中参考文献：   在右侧栏选中info(第二个按钮)   然后单击选中Author下的姓名: 然后先删除First、Middle、Last， 再选中Company or Institute,然后在Last那一项下输入焉树芬，改完之后点击Save就可以保存了:   最后再在Word中引用显示的姓名就正常了☺️。
修改其他 在右侧边栏里提到过info这一项可以修改很多信息，只要点击相应的项就可以了，如下图所示：
添加收藏集 当一篇参考文献导入之后，我们可以将其归为某一类。归为某一类通常是加入收藏集(Collection)，下图就是我在使用过程中的归类:
将某个参考文献加入到收藏集(Collection)相当简单，只要在右侧边栏选中概览(第一个按钮)，然后单击Add to collection就可以开始添加：
在最后一步中，如果把参考文献加入已有的收藏集，则只要选中相应行的矩形就可以，如果不存在你要加的收藏集，则只要在Fiter那一行输入新的名字，然后按回车键(Enter)即可:
添加好收藏集就可以查看收藏集下面的参考文献了，首先点击顶部按钮的库，然后选中相应的收藏集，如下图所示: 引用文献 导入了引用文件，将信息修正并加入到对应的收藏集之后，所有的准备工作就算是完成了，接下来开始引用参考文献。
配置快捷键 上面已经好几次出现了引用参考文献，可能会有疑惑——在Word中是怎么把下面这个参考文献搜索界面调出来的?
答案就是事先配置快捷键，只要事先为引用配置了快捷键，在Word中只要按住改快捷键就可以调出这个搜索界面，配置快捷键的方法如下:
为了更清楚的展示上面的操作，将其分解为3步：
  首先在菜单栏找到Papers按钮，然后再点击选中Preferencses(也可以直接按住快捷键Command&#43;,)：   然后再在弹出的界面中，点击选中Citations:   最后单击选中Click to record shortcut，会提示type shortcut，此时只要按住Shift &#43; M(也可以是其其它快捷键)就把快捷键设置好了:
  设置引用样式 对于同一篇参考文献，世界上不同的国家和期刊会使用不同的引用样式，我查看了你学校的硕士毕业论文参考文献格式要求，发现是用的国标，所以需要修改参考文献样式，操作如下动图所示:
为了更清楚的展示上面的操作，将其分解为6步：
 首先在菜单栏找到Papers按钮，然后再点击选中Preferencses(也可以直接按住快捷键Command&#43;,)：  然后再在弹出的界面中，点击选中Citations:  然后在Favorite Styles下拉选中More Styles:  然后在搜索框里搜索GB(表示国标):  然后选中7714-GB2005(numberic,Chinese)，选中之后点击Done:  点击Done之后会返回到上一个界面，此时在Favorite Styles下拉，然后选中7714-GB2005(numberic,Chinese):   开始引用 看到这里是不是已经开始头晕了😂，不要紧，先去休息下吧，精彩稍后继续💤💤💤。到这一步的时候，其实所有的准备工作都已经做好了，接下来只管引用参考文献就好了。参考文献的引用可以分为两步，第一步是插入占位，第二步为格式化。
插入占位 所谓插入，就是在论文中找到对应的位置插入一个占位符以标识某一句是引用自哪篇文章,如下图所示:
插入占位的步骤的动图如下:
上面的动图可以分解为3步:
 首先，按住快捷键Shift&#43;M,以调出参考文献搜索界面：  然后，从搜索结果里选中目标文章，然后按回车键(Enter键):  最后，选中insert Citation进行插入:   格式化 所谓格式化，就是把上一步的所有的占位符变为数字上标，并在文章最后以设置的样式显示参考文献，如下图所示: 上面的操作可以分解为2步:
 首先，按住快捷键Shift&#43;M,以调出参考文献搜索界面,此时如果上次没有进行搜索过的话会出现如下界面： 如果上次搜索过文献，则会出现下面这个界面，那么首先应当删除搜索框里的内容，这样才会显示Format manuscript选项:  在上一步出现了Format manuscript的界面，单击选中这一项，即进行格式化:   总结 哈哈终于写完啦☺️，上面就是插入参考文献的完整过程，使用流程图总结，如下图所示：
参考资料 参考资料 参考资料
</content>
    </entry>
    
     <entry>
        <title>Swift中for循环</title>
        <url>https://iihui.github.io/post/swift-for-in/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  Swift中只有一种形式for循环，即for in。但是for-in有多种形式，既包括常规用法又包括区间循环。
 常规用法 常规用法一般用于直接访问数组中的元素，可以分为直接访问和按索引访问：
let arr = [34, 78, 789, -12] for item in arr {  debugPrint(item) } 在OC中是通过索引i来访问数组中的元素，在Swift中需要借助枚举enumerated()来实现。此时可以使用offset来获取索引值，element来获取数组元素。
let arr = [34, 78, 789, -12] for item in arr.enumerated() {  print(item.offset, item.element) } let arr = [34, 78, 789, -12] for (i, num) in arr.enumerated() {  print(i, num) } 区间循环 在Swift中...表示闭区间，例如0...10表示0，1，2，...，10。而..&amp;lt;表示前闭后开区间，例如0..&amp;lt;10表示0，1，2，...，9，它不包含10。
for i in 0...10 {  debugPrint(i) }  for i in 0..&amp;lt;10 {  debugPrint(i) } 如果要使用倒序，则需要将顺序区间进行reversed()。需要注意的是在...和..&amp;lt;这两种区间表示中要求左边界小于等于右边界。
for i in (0...10).reversed() {  debugPrint(i) } 此外，Swift还提供了一种更灵活的stride，以满足不同的递增条件以和开闭区间的结合：
func stride&amp;lt;T&amp;gt;(from start: T, to end: T, by stride: T.Stride) func stride&amp;lt;T&amp;gt;(from start: T, through end: T, by stride: T.Stride) //from:开始位置包括上边界 by：递增步长 //to：结束位置，前闭后开区间，不包含右边界 //through：结束位置，全闭区间，包含右边界 for i in stride(from: 0, to: 10, by: 2) {  debugPrint(i, terminator: &amp;#34;\t&amp;#34;) //0 2 4 6 8 } for i in stride(from: 0, through: 10, by: 2) {  debugPrint(i, terminator: &amp;#34;\t&amp;#34;) //0 2 4 6 8 10 } 如果要实现递减，则需要将by改成负数:
for i in stride(from: 10, through: 0, by: -2) {  debugPrint(i, terminator: &amp;#34;\t&amp;#34;) //10 8 6 4 2 0 } 需要注意的是：如果中途改变by的值，不会起作用，查看源码发现by是以传值的方式传递到stride函数中的：
var step = -3 for i in stride(from: 10, through: 0, by: step) {  debugPrint(i, terminator: &amp;#34;\t&amp;#34;) // 10 7 4 1  //虽然改变了step但结果依然是10 7 4 1  step -= 2 } 参考资料
</content>
    </entry>
    
     <entry>
        <title>基本内排序算法Swift实现</title>
        <url>https://iihui.github.io/post/swift-sort/</url>
        <categories>
          <category>算法</category>
        </categories>
        <tags>
          <tag>算法</tag>
        </tags>
        <content type="html">  排序就是重新排列表中的元素，使表中的元素满足按关键字递增或者递减的排列过程。排序算法分为内排序和外排序。内排序是指排序期间元素全部放在内存中的排序；而外排序是指在排序期间元素太多，不能同时全部存放在内存中，必须在排序过程中根据要求，不断在内，外存之间移动的排序。内排序可归纳为插入排序，选择排序，交换排序、归并排序，计数排序，基数排序等。
 插入排序 直接插入排序 直接插入排序是在有序的基础上进行排序。对于数组来说第一个元素默认是有序的，从第二个元素开始，在前面已经有序的元素中找到当前元素应该在的位置进行插入：
//直接插入排序，时间复杂度为O(n^2)，空间复杂度为O(1)，稳定的排序算法 static func insertSort&amp;lt;T: Comparable&amp;gt;(data: [T]) -&amp;gt; [T] {  var result = data  var j: Int  for i in 1 ..&amp;lt; result.count {  let tmp = result[i]  j = i - 1  while j &amp;gt;= 0 {  if result[j] &amp;gt; tmp {  result[j &#43; 1] = result[j]  j -= 1  } else {  break  }  }  result[j &#43; 1] = tmp  }  return result }  直接插入排序是稳定的排序算法 时间复杂度为$O(n^2)$ 空间复杂度为$O(1)$   折半插入排序 折半插入排序，在查找当前元素应该插入的位置时，利用前面元素已经有序的特点，以二分法进行查找：
//二分插入排序,时间复杂度为O(nlog(n))，空间复杂度为O(1)，不稳定的排序算法,例子为(2,2,2) static func binarySort&amp;lt;T: Comparable&amp;gt;(data: [T]) -&amp;gt; [T] {  var result = data  var start, end, mid: Int  for i in 1 ..&amp;lt; result.count {  let tmp = result[i]  start = 0  end = i - 1  while start &amp;lt;= end {  mid = start &#43; (end - start) / 2  if result[mid] == result[i] {  end = mid  break  } else if result[mid] &amp;gt; result[i] {  end = mid - 1  } else {  start = mid &#43; 1  }  }  for j in stride(from: i - 1, through: end &#43; 1, by: -1) {  result[j &#43; 1] = result[j]  }  result[end &#43; 1] = tmp  }  return result }  是不稳定的排序算法，例如(1,1,1,1,1) 时间复杂度为$O(n^2)$，二分查找插入位置，因为不是查找相等值，而是基于比较查插入合适的位置，所以必须查到最后一个元素才知道插入位置。 空间复杂度为$O(1)$   Shell排序 希尔排序是先将待排序的表分割为若干形如$L[i,i&#43;d,i&#43;2d,..i&#43;kd]$的子表，分别进行直接插入排序，当整个表中元素已呈基本有序时，再对全体进行一次直接插入排序。
//shell排序，时间复杂度O(nlog^k(n)),空间复杂度为O(1),不稳定的排序算法，例子为(2,2,1) static func shellSort&amp;lt;T: Comparable&amp;gt;(data: [T]) -&amp;gt; [T] {  var result = data  var step = result.count / 2  while step &amp;gt;= 1 {  self.assistShellSort(data: &amp;amp;result, step: step)  step /= 2  }  return result } static private func assistShellSort&amp;lt;T: Comparable&amp;gt;(data: inout [T], step: Int) {  guard step &amp;gt;= 1 else {  return  }  var j = 0  for i in 1 ..&amp;lt; data.count {  let tmp = data[i]  j = i - step  while j &amp;gt;= 0 {  if data[j] &amp;gt; tmp {  data[j &#43; step] = data[j]  j -= step  } else {  break  }  }  data[j &#43; step] = tmp  } }  是不稳定的排序算法，例如(2,1,1) 空间复杂度为$O(1)$   选择排序 简单选择排序 简单选择排序，首先从数组所有元素中找到最小的元素，然后将其与第一个元素进行交换，这样第一个元素就变成了最小元素；然后从第二个元素开始找剩下元素中最小的那一个，并将这个最小元素与第二个元素进行交换，如此第二个元素就变成第二小的元素，依次类推：
//选择排序，时间复杂度为O(n^2),空间复杂度为O(1),不稳定的排序算法，例子为(2,2,1) static func selectSort&amp;lt;T: Comparable&amp;gt;(data: [T]) -&amp;gt; [T] {  var result = data  var index: Int  for i in 0 ..&amp;lt; result.count - 1 {  index = i  for j in i &#43; 1 ..&amp;lt; result.count {  if result[j] &amp;lt; result[index] {  index = j  }  }  if index != i {  (result[index], result[i]) = (result[i], result[index])  }  }  return result }  不稳定的排序算法，例如2,2,1 时间复杂度为$O(n^2)$ 空间复杂度为$O(1)$   堆排序 堆排序算法，是先将数组排成大顶堆（也可以是小顶堆）。然后将堆顶元素（当前最大）和数组的最后一个元素进行交换，那么此时堆顶到数组的倒数第二个元素之间的堆可能就不再满足堆的定义，需要调整。调整好之后，堆顶元素即为堆顶到数组的倒数第二个元素之间最大的元素，此时将堆顶元素和倒数第二个元素交换，此时又可能不满足堆的定义了，因此再调整堆，如此继续，直到处理完所有数据。
//堆排序，时间复杂度为O(nlog(n))，空间复杂度为O(1)，不稳定的排序算法，例子为(2,2,1) static func heapSort&amp;lt;T: Comparable&amp;gt;(data: [T]) -&amp;gt; [T] {  var result = data  //首先排序为大顶堆  for i in stride(from: (result.count - 1) / 2, through: 0, by: -1) {  self.adjustHeap(data: &amp;amp;result, start: i, end: result.count - 1)  }  //然后交换，再重新调整为大顶堆  for i in stride(from: result.count - 1, through: 1, by: -1) {  (result[0], result[i]) = (result[i], result[0])  self.adjustHeap(data: &amp;amp;result, start: 0, end: i - 1)  }  return result } //辅助函数，默认除了第一个元素不满足大顶堆，所以要调整第一个元素到合适位置 static private func adjustHeap&amp;lt;T: Comparable&amp;gt;(data: inout [T], start: Int, end: Int)  var parent = start, child = 2 * start &#43; 1  while child &amp;lt;= end {  if child &amp;lt; end, data[child] &amp;lt; data[child &#43; 1] {  child &#43;= 1  }  if data[parent] &amp;lt; data[child] {  (data[parent], data[child]) = (data[child], data[parent])  parent = child  child = 2 * parent &#43; 1  }else{  break  }  } }  是不稳定的排序算法,例如(1,2,2) 时间复杂度为$O(nlog(n))$ 空间复杂度为$O(1)$   交换排序  交换排序，就是根据序列中两个元素关键字的比较结果来对换这两个记录在序列中的位置。
 冒泡排序 冒泡排序假设待排序表长为n，从后往前（或从前往后）两两比较相邻元素的值，若为逆序$A[i-1]&amp;gt;A[i]$，则交换它们，直到序列比较完。称之为一趟冒泡，结果将最小的元素交换到待排序列的第一个位置（关键字最小的元素如气泡一般逐渐往上漂浮，直到水面，这就是冒泡排序的名字的由来）。下一趟冒泡时，前一趟确定的最小元素不再参与比较，待排序减少一个元素，每趟冒泡的结果把序列中的最小元素放到序列的最终位置，&amp;hellip;，这样最多做$n-1$趟冒泡就能把所有元素排好序。
//交换排序，时间复杂度为O(n^2),空间复杂度为O(1),稳定的排序算法 static func bubbleSort&amp;lt;T: Comparable&amp;gt;(data: [T]) -&amp;gt; [T] {  var result = data  var flag = false //用于标识本趟是否有交换  for i in 0 ..&amp;lt; result.count - 1 {  flag = false  for j in 0 ..&amp;lt; result.count - i - 1 {  // 大数沉底  if result[j] &amp;gt; result[j &#43; 1] {  (result[j], result[j &#43; 1]) = (result[j &#43; 1], result[j])  flag = true  }  }  if flag == false {  break  }  }  return result }  是稳定的排序算法 时间复杂度为$O(n^2)$ 空间复杂度为$O(1)$   快速排序 //快速排序，时间复杂度为O(nlog(n))，空间复杂度为log(n),不稳定的排序算法，例子(2,2,1) static func quickSort&amp;lt;T: Comparable&amp;gt;(data: inout [T], start: Int, end: Int) {  guard start &amp;lt; end else {  return  }  let pivot = assistQuickSort(data: &amp;amp;data, start: start, end: end)  if pivot &amp;gt; start {  quickSort(data: &amp;amp;data, start: start, end: pivot - 1)  }  if end &amp;gt; pivot {  quickSort(data: &amp;amp;data, start: pivot &#43; 1, end: end)  } } //在start...end之间随机抽取一个数字，并将其放置其最终的位置 static private func assistQuickSort&amp;lt;T: Comparable&amp;gt;(data: inout [T], start: Int, end: Int) -&amp;gt; Int {  let index = Int.randomIntNumber(lower: start, upper: end &#43; 1)  (data[end], data[index]) = (data[index], data[end])  var small = start - 1  for i in start ..&amp;lt; end {  if data[i] &amp;lt; data[end] {  small &#43;= 1  if small != i {  (data[small], data[i]) = (data[i], data[small])  }  }  }  small &#43;= 1  (data[small], data[end]) = (data[end], data[small])  return small } extension Int {  //返回的结果： [lower,upper) 之间的半开半闭区间的数。  public static func randomIntNumber(lower: Int = 0, upper: Int = Int(UInt32.max)) -&amp;gt; Int {  return lower &#43; Int(arc4random_uniform(UInt32(upper - lower)))  }   //生成某个区间的随机数  public static func randomIntNumber(range: Range&amp;lt;Int&amp;gt;) -&amp;gt; Int {  return randomIntNumber(lower: range.lowerBound, upper: range.upperBound)  } }   是不稳定的排序算法，例如(3,2,2)时，Pivot为0
  时间复杂度为$O(nlog(n))$
  空间复杂度为$O(log(n))$
  平均条件下，最快的排序算法
   归并排序  归并的含义是将两个或者两个以上的有序表组合成一个新的有序表。假定待排序表含有n个记录，则可以视为n个有序子表，每个表的长度为1，然后两两归并，得到$\biggl\lceil\frac{n}{2}\biggr\rceil$个长度为2或1的有序表，再两两归并，&amp;hellip;，如此重复，直到合并成一个长度为n的有序表为止，这种排序方法称为二路归并排序。
 //归并排序，时间复杂度为O(nlog(n)),空间复杂度为(O(n),稳定的排序算法 static func mergeSort&amp;lt;T: Comparable&amp;gt;(data: [T]) -&amp;gt; [T] {  var result = data  var assist = data  self.mergeSort(data: &amp;amp;result, assist: &amp;amp;assist, start: 0, end: result.count - 1)  return result } static private func mergeSort&amp;lt;T: Comparable&amp;gt;(data: inout [T], assist: inout [T], start: Int, en  if start &amp;lt; end {  let mid = start &#43; (end - start) / 2  mergeSort(data: &amp;amp;data, assist: &amp;amp;assist, start: start, end: mid)  mergeSort(data: &amp;amp;data, assist: &amp;amp;assist, start: mid &#43; 1, end: end)  var index = start, i = start, j = mid &#43; 1  while i &amp;lt;= mid &amp;amp;&amp;amp; j &amp;lt;= end {  if data[i] &amp;lt; data[j] {  assist[index] = data[i]  i &#43;= 1  } else {  assist[index] = data[j]  j &#43;= 1  }  index &#43;= 1  }  while i &amp;lt;= mid {  assist[index] = data[i]  index &#43;= 1  i &#43;= 1  }  while j &amp;lt;= mid {  assist[index] = data[j]  index &#43;= 1  j &#43;= 1  }  data = assist  } } func mergeSort(data:inout Array&amp;lt;Int&amp;gt;){  var assist = data  mergeSort(data: &amp;amp;data, assist: &amp;amp;assist,start: 0,end: data.count-1) }  func mergeSort(data:inout Array&amp;lt;Int&amp;gt;,assist:inout Array&amp;lt;Int&amp;gt;,start:Int,end:Int){  if start == end{  assist[start] = data[start]  return  }  let length = (end - start)/2  mergeSort(data: &amp;amp;data, assist: &amp;amp;assist, start: start, end: start &#43; length)  mergeSort(data: &amp;amp;data, assist: &amp;amp;assist, start: start &#43; length &#43; 1, end: end)   var i=start, j = start &#43; length &#43; 1,k = start  while i &amp;lt;= start &#43; length &amp;amp;&amp;amp; j &amp;lt;= end{  if data[i] &amp;lt;= data[j]{  assist[k] = data[i]  i &#43;= 1  }else{  assist[k] = data[j]  j &#43;= 1  }  k &#43;= 1  }   if i &amp;lt;= start &#43; length {  assist[k...(k &#43; (start &#43; length - i))] = data[i...start&#43;length]  }  if j &amp;lt;= end {  assist[k...(k &#43; (end - j))] = data[j...end]  }  data = assist }  计数排序 计数排序是一种非比较性质的排序算法，元素从未排序状态变为已排序状态的过程，是由额外空间的辅助和元素本身的值决定的。计数排序过程中不存在元素之间的比较和交换操作，根据元素本身的值，将每个元素出现的次数记录到辅助空间后，通过对辅助空间内数据的计算，即可确定每一个元素最终的位置。
//计数排序，时间复杂度为O(n&#43;K),空间复杂度为O(n&#43;K),稳定的排序算法 static func countSort(data: [Int]) -&amp;gt; [Int]? {  guard let arr = preCountSort(data: data), let max = arr.max() else  return nil  }  var countArr = [Int](repeating: 0, count: max &#43; 1)  for item in arr {  countArr[item] &#43;= 1  }  for i in 1 ..&amp;lt; countArr.count {  countArr[i] &#43;= countArr[i - 1]  }  var result = [Int](repeating: 0, count: arr.count)  for i in stride(from: arr.count - 1, through: 0, by: -1) {  result[countArr[arr[i]] - 1] = arr[i]  countArr[arr[i]] -= 1  }  let realResult = postCountSort(data: data, result: result)  return realResult } static private func preCountSort(data: [Int]) -&amp;gt; [Int]? {  guard let min = data.min() else {  return nil  }  if min &amp;lt; 0 {  let adder = abs(min)  let result = data.map {  $0 &#43; adder  }  return result  } else {  return data  } } static private func postCountSort(data: [Int], result: [Int]) -&amp;gt; [Int]?  guard data.count == result.count, let min = data.min() else {  return nil  }  var realResult = result  if min &amp;lt; 0 {  realResult = result.map {  $0 &#43; min  }  }  return realResult } 参考资料
 基数排序 基数排序(Radix Sort)是桶排序的扩展，它的基本思想是：将整数按位数切割成不同的数字，然后按每个位数分别比较。具体做法是：将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后,待排序序列就变成一个有序序列。
//十进制的基数排序 static func radixSort(data: [Int]) -&amp;gt; [Int]? {  guard var arr = preRadixSort(data: data), let max = arr.max() else {  return nil  }  var assist = 1  while assist &amp;lt;= max {  inRadixSort(data: &amp;amp;arr, assist: assist, radix: 10)  assist *= 10  }  return arr } static private func preRadixSort(data: [Int]) -&amp;gt; [Int]? {  for item in data {  if item &amp;lt; 0 {  return nil  }  }  return data } static private func inRadixSort(data: inout [Int], assist: Int, radix: Int) {  var countArr = [Int](repeating: 0, count: 10)  for item in data {  countArr[(item / assist) % radix] &#43;= 1  }  var tmpArr = data  for i in 1 ..&amp;lt; countArr.count {  countArr[i] &#43;= countArr[i - 1]  }  for i in stride(from: data.count - 1, through: 0, by: -1) {  tmpArr[countArr[(data[i] / assist) % radix] - 1] = data[i]  countArr[(data[i] / assist) % radix] -= 1  }  data = tmpArr } 总结  </content>
    </entry>
    
     <entry>
        <title>Framework</title>
        <url>https://iihui.github.io/post/ios-framework/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> 链接库 库是一种共享程序代码的方式，分为静态库和动态库。静态库链接时被完整地拷贝到可执行文件，多次使用时就会有多个副本。
而动态库在链接时不复制，程序运行时由系统动态加载到内存，供程序调用。动态库只加载一次到内存，然后供多个程序共用，以节省内存。
静态库的形式 在iOS中静态库分为.a和.framework。.a是一个纯二进制文件，.framework中除了二进制文件之外，还有资源文件。.a文件不能直接使用，至少要有.h文件配合，而.framework文件可以直接使用。
$$ .a &#43; .h &#43; sourceFile = .framework$$
 动态库的形式 在iOS中动态库分为.dylib和.framework两种形式。.framework既可以是动态库又可以是静态库，需要在构建的时候进行设置：
 构建Framework 一般构建 新建项目时选择Cocoa Touch Framwork： 然后输入Product Name： 为了让制作出的framework在低版本的系统上也能使用，可以在General-&amp;gt;Deployment Info里设置一个较低的发布版本: 将需要添加的文件加入到项目中，进行编译，如下图所示选择不同的active scheme则会生成对应于不同平台的framework：  引入OC代码 如果要在framework中引入OC代码，则首先将.m和.h文件拖入到项目中。然后在设置时选中相应的tagert，找到Build Phases,再在其下的Header中找到相应的头文件，将该头文件从project拖到public下:
再在创建工程时，自动生成的.h文件中引入刚刚拖到工程中的.h文件：  使用Framework 首先将自己构建的Framework拖到目标工程中，如下图所示： 添加的时候选中Copy items if needed和Create groups，然后需要加到哪个target就在对应的target前进行勾选: 添加完成后如下图所示： 然后到相应的target的设置中，找到General下的Embedded Binaries：
接着点击&#43;号添加相应的Framework： 最后的效果如下图所示:  参考资料 参考 参考
</content>
    </entry>
    
     <entry>
        <title>桥接文件</title>
        <url>https://iihui.github.io/post/ios-bridge/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> 因为历史原因，在使用Swift编程时，常常需要用到OC类中的方法，此时就需要使用桥接文件来引入OC中的头文件，以告诉Swift。
手动创建桥接文件 第一步 首先使用快捷键Command&#43;N来新建一个文件： 第二步 选择Header File: 第三步 给Header File命名： 第四步 点击工程配置，添加关联： 第五步 设置桥接文件的路径： 第六步 将要引入的OC头文件，加入到桥接文件中，例如：
//透云QR解码 #import &amp;#34;TYQRViewController.h&amp;#34;  //显示GIF的Label #import &amp;#34;UIImage&#43;GIF.h&amp;#34; #import &amp;#34;CFTextModel.h&amp;#34; #import &amp;#34;CFLabel.h&amp;#34; #import &amp;#34;CFTableViewCell.h&amp;#34; #import &amp;#34;CFTextView.h&amp;#34;  // 百度语音 #import &amp;#34;BDSEventManager.h&amp;#34; #import &amp;#34;BDSASRDefines.h&amp;#34; #import &amp;#34;BDSASRParameters.h&amp;#34; 参考 参考资料
 </content>
    </entry>
    
     <entry>
        <title>JS的prototype</title>
        <url>https://iihui.github.io/post/js-prototype/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>js</tag>
        </tags>
        <content type="html">  在JS中，每当定义一个对象(函数也是对象)时，对象中都会包含一些预定义的属性；每个对象都有一个prototype对象，这个属性指向函数的原型对象。
 原型对象 缘由 Brendan Eich在设计JS时，将所有的数据类型都设计为对象，因此需要有一种机制将这些对象都联系起来。但他只想设计一种简易的脚本语言，所以没有引入类的概念，因为一旦有了类的概念，JS就是一种完整的面向对象的编程语言。
借鉴了Java和C&#43;&#43;使用new来生成实例，Brendan Eich利用new后面跟构造函数「因为没有类的概念」生成对象。
function DOG(name) {  this.name = name;  this.species = &amp;#39;犬科&amp;#39;; } var dogA = new DOG(&amp;#34;大毛&amp;#34;); var dogB = new DOG(&amp;#34;二毛&amp;#34;); 上面这两个对象的species属性都是独立的，修改其中一个，不会影响到另外一个，即每一个实例对象都有自己属性和方法的副本，通过这种方式无法达到数据共享。
 引入 考虑到数据共享的需要，Brendan Eich打算为构造函数设置一个prototype属性，这个属性包含一个对象，所有实例对象需要共享的属性和方法，都放在这个对象里面；那些不需要共享的属性和方法，就放在构造函数中。
实例对象一旦创建，将自动引用prototype对象的属性和方法。即实例对象的属性和方法，分为两种，一种是本地的，另一种是引用的。
function DOG(name) {  this.name = name; } DOG.prototype = { species: &amp;#34;犬科&amp;#34; };  var dogA = new DOG(&amp;#34;大毛&amp;#34;); var dogB = new DOG(&amp;#34;二毛&amp;#34;);  alert(dogA.species); // 犬科 alert(dogB.species); // 犬科  总结 由于所有的实例对象共享一个prototype对象，因此在外界看起来，prototype就好像是实例对象的原型，而实例对象则好像继承了prototype对象一样。
 参考资料 参考资料
 </content>
    </entry>
    
     <entry>
        <title>javascript中this指针</title>
        <url>https://iihui.github.io/post/js-this/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>js</tag>
        </tags>
        <content type="html">  在JavaScript中，this是动态绑定，或称为运行期绑定的，这导致JavaScript中的this关键字具有多重含义。它可以是全局对象、当前对象或者任意对象，这完全取决于函数的调用方式。
  作为对象方法调用 在JS中，函数也是对象，因此函数可以作为一个对象的属性，此时该函数被称为该对象的方法，在使用这种调用方式时，this被自然地绑定到该对象。
var point = { x : 0, y : 0, moveTo : function(x, y) {  this.x = this.x &#43; x;  this.y = this.y &#43; y;  } };  point.moveTo(1, 1)//this 绑定到当前对象，即 point 对象  作为函数调用 函数可以直接调用，此时this绑定到全局对象，在浏览器中，window就是该全局对象。在下面的例子中，函数调用时，this被绑定到全局对象，接下来执行赋值语句，相当于隐式的声明了一个全局变量。
function makeNoSense(x) {  this.x = x; }  makeNoSense(5); x;// x 已经成为一个值为 5 的全局变量 对于内部函数(即声明在另一个函数体中的函数)，如果使用this指针，那么绑定的是全局对象，会产生下面问题：
var point = {  x: 0,  y: 0,  moveTo: function(x, y) {  // 内部函数  var moveX = function(x) {  this.x = x; //this 绑定到了哪里？  };  // 内部函数  var moveY = function(y) {  this.y = y; //this 绑定到了哪里？  };   moveX(x);  moveY(y);  } }; point.moveTo(1, 1); point.x; //==&amp;gt;0 point.y; //==&amp;gt;0 x; //==&amp;gt;1 y; //==&amp;gt;1 这属于JavaScript的设计缺陷，正确的设计方式是内部函数的this应该绑定到其外层函数对应的对象上，为了规避这一缺陷，使用变量替换的方式：
var point = {  x: 0,  y: 0,  moveTo: function(x, y) {  var that = this;  // 内部函数  var moveX = function(x) {  that.x = x;  };  // 内部函数  var moveY = function(y) {  that.y = y;  };  moveX(x);  moveY(y);  } }; point.moveTo(1, 1); point.x; //==&amp;gt;1 point.y; //==&amp;gt;1  作为构造函数调用 JavaScript支持面向对象编程，但它没有类的概念，而是使用基于原型prototype的继承方式。
相应的JavaScript中的构造函数也很特殊，如果不使用new调用，则和普通函数一样。约定俗成，构造函数以大写字母开头，以提醒调用者使用正确的方式调用。
function Point(x, y){  this.x = x;  this.y = y; }  使用apply或call调用 在JS中函数也是对象，对象则有方法，apply和call就是函数对象的方法。他们允许切换函数执行的上下文环境context,即this绑定的对象。
function Point(x, y) {  this.x = x;  this.y = y;  this.moveTo = function(x, y) {  this.x = x;  this.y = y;  }; }  var p1 = new Point(0, 0); var p2 = { x: 0, y: 0 }; p1.moveTo(1, 1); p1.moveTo.apply(p2, [10, 10]); //p1的方法应用到p2 函数存在①定义时上下文；②运行时上下文；③上下文是可以改变的。在JS中call和apply都是为了改变某个函数执行的上下文context而存在的，即是改变函数体内的this的指向。
var func = function(arg1, arg2) {  //语句 }; func.call(this, arg1, arg2); func.apply(this, [arg1, arg2])  参考资料 参考资料 一定要看
 </content>
    </entry>
    
     <entry>
        <title>selection 对象</title>
        <url>https://iihui.github.io/post/js-selection/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>js</tag>
        </tags>
        <content type="html">  在富文本编辑器中，需要控制光标的各种状态信息，位置信息。浏览器提供了selection对象和range对象来操作光标。
 selection Selection对象表示用户选择的文本范围或插入符号的当前位置。它代表页面中的文本选区可能横跨多个元素(element)，文本选区由用户拖拽鼠标而产生。
let selection = window.getSelection(); 通常需要操作selection对象所对应的用户选择区(range)(俗称拖蓝)，获取方式为:
if (selection.rangeCount &amp;gt; 0) {  let range = selection.getRangeAt(0); } //或者 if (selection.rangeCount) {  let range = selection.getRangeAt(0); } range对象 range对象代表页面上一段连续的区域，通过range对象可以获取或者修改页面上的任何区域，也可以通过Range的方法进行复制和移动页面上的任何区域。
  startContainer: range范围的起始节点。
  endContainer:range 范围的结束节点。
  startOffset: 如果startContainer是文本节点、注释节点、或者CDATA节点，则返回起点在startContainer中的字符偏移量，如果startContainer是元素节点，则返回起点在startContainer.childNodes中的次序。
  endOffset: 表示终点，含义与startOffset类似。
  commonAncestorContainer: 返回包含startContainer和endContainer的最近祖先节点。
  collapsed:返回一个用于判断range起始位置和终止位置是否相同的布尔值。
  range常用方法   setStart(node,offset):设置起点的位置，node是对startContainer的引用，偏移则是startOffset。
  setEnd(node,offset): 设置的终点的位置，node是对endContainer的引用，偏移则是endOffset。
  selectNode(referenceNode)：设置Range的范围，包括referenceNode和它的所有子孙节点。
  selectNodeContents(referenceNode)设置Range的范围，包括它的所有后代节点，但不包含referenceNode节点。与selectNode区别较大。
  collapse(bool): 向起点start折叠。
  insertNode(node): 在range的起始处插入节点。
  cloneRange(): 返回一个当前Range的副本
  function resetRange(startContainer, startOffset, endContainer, endOffset) {  let selection = window.getSelection();  selection.removeAllRanges();  let range = document.createRange();  range.setStart(startContainer, startOffset);  range.setEnd(endContainer, endOffset);  selection.addRange(range); } 参考资料
Chapter 1 在ES6及更高版本，有一种定义函数的简洁语法。这种简洁的语法使用箭头=&amp;gt;来分隔参数列表和函数体，以这种方式定义的函数被称为箭头函数。箭头函数常用于将一个未命名的函数作为参数传递给另一个函数。
const plus1 = x =&amp;gt; x &#43; 1; const square1 = x =&amp;gt; x * x;  console.log(plus1(12)) // 13 console.log(square1(3)) // 9 Chapter 2 JavaScript是一种区分大小写的语言，并会忽略程序中标记之间的空格。多数情况下，也会忽略换行符（但有例外情况）。因为可以在程序中自由使用空格和换行符，所以能以整齐一致的方式格式化和缩进程序，使代码易于阅读。
像其它语言一样，JavaScript使用分号分隔不同的语句。若两条语句分别写在不同的行上，通常可以省略它们之间的分号。
需要注意的是，并不是会将每一个换行符都视为分号，只有在不添加隐式分号就无法继续解析代码的情况下，才会将换行符视为分号。更确切地说（除了稍后要介绍的三种例外情况），如果下一个非空格字符不能被解释为当前语句的继续，才会将换行符视为分号。
Chapter 3 JavaScript的类型被分为两大类，基础类型和对象类型。特殊值null和undefined也是基础类型值，但它们不是数值，字符串或布尔值。这两个值通常认为是各自类型的唯一成员。
只要不是数字、字符串、布尔值、Symbol、null或undefined，其他值都是对象。对象是属性的集合，每个属性都有一个名称和一个值。普通的对象是无序的名字和值的集合，函数和类也是特殊的对象。
Number 当一个数字直接出现在程序中时，它被称为数值字面量。可以在数字字面量中使用下划线，将较长的字面量分割成更易于阅读的字块：
let billion = 1_000_000_000; let bytes = 0x89_AB_CD_EF; let bits = 0b0001_1101_0111; let fraction = 0.123_456_789; JavaScript的算术运算在溢出、下溢或除以零的情况下都不会产生错误。当数值运算的结果超过最大可表示的数值（溢出）时，其结果是一个特殊的无穷大值，即Infinity。同样，当负数的绝对值大于负数的最大绝对值时，结果就是负无穷大，即-Infinity。无穷大数值的行为与我们所期望的一样，它与任何数值相加、相减、相乘或相除的结果都是无穷大数值（可能符号相反）。
当数值运算的结果比可表示的最小数字更接近零时，就会出现下溢。在这种情况下，JavaScript返回0。如果负数出现下溢，JavaScript会返回一个被称为negative zero特殊值。这个值与普通的0几乎没有区别，很少的情况需要区别。
在JavaScript中，除以0并不会产生一个错误，它只是简单地返回正无穷或负无穷。但有一个例外，0除以0并不会返回一个明确定义的数值，而是返回NaN。如果尝试用无穷大除以无穷大、取负数的平方根或使用不能转换为数字的非数字操作数的算术运算符，也会得到NaN。
JavaScript预定义了全局常量Infinity和NaN，用于保存正无穷大和非数字值，这些值也可以作为Number对象的属性使用：
console.log(Infinity, Number.POSITIVE_INFINITY, 1 / 0, Number.MAX_VALUE * 2) console.log(-Infinity, Number.NEGATIVE_INFINITY, -1 / 0, -Number.MAX_VALUE * 2) console.log(NaN, Number.NaN, 0 / 0, Infinity / Infinity) console.log(Number.MIN_VALUE / 2, -Number.MIN_VALUE / 2, -1 / Infinity, -0)  // 执行后的结果 Infinity Infinity Infinity Infinity -Infinity -Infinity -Infinity -Infinity NaN NaN NaN NaN 0 -0 -0 -0 NaN有一个不同寻常的特性：它不与任何其它值（包括它自己）进行比较。这意味着不能使用x === NAN来判断x的值是否为NaN。相反，必须写成x != x或Number.isNaN(x)来判断x的值是否为NaN。当且仅当x的值与全局常量NaN相同时，这些表达式才会为true。
全局函数isNaN()和Number.isNaN()是相似的。如果参数为NaN，或者参数为无法转换为数字的值，则返回true。如果函数Number.isFinite()的参数是NaN、Infinity或-Infinity以外的数字，则返回true。如果全局函数isFinite()的参数是或可以转换为有限数值，则返回true。
负零值也有些不同寻常，它与正零比较是相等的（即使是使用JavaScript的严格相等进行测试），这意味着这两个值几乎没有区别，除非用作除数时：
let zero = 0; let negz = -0; console.log(zero === negz) console.log(1 / zero, 1 / negz) console.log(1 / zero === 1 / negz)  // 执行的结果 true Infinity -Infinity false Binary Floating-Point and Rounding Errors 实数有无限多个，但JavaScript的浮点格式只能表示其中的有限个数。也就是说，在处理实数时，数字的表示往往是实际数字的近似值。
JavaScript使用的IEEE-754浮点表示法是一种二进制表示法。这种表示法可以精确地表示1/2,1/8和1/1024等，但不能精确地表示0.1。虽然这种表示法有足够高的精度，能够让数值非常近似地表示0.1，但也无法精确地表示，这可能会导致一些问题：
let x = .3 - .2; let y = .2 - .1; console.log(x, y) // 0.09999999999999998 0.1 console.log(x === y) // false console.log(x === .1, y === .1) // false true  // 打印的结果 0.09999999999999998 0.1 false false true 上面代码中，由于舍入误差.3和.2近似值之差与.2和.1近似值之差并不相等。但这并不是JavaScript特有的问题，而是所有使用二进制浮点数编程语言共有的问题。
此外，请注意上面代码中的x和y值非常接近，也极其接近正确值。计算出来的值几乎可以满足任何需要，但当试图比较两个值是否相等时才会出现问题。
如果使用浮点近似值对我们的程序有问题，可以考虑使用缩放整数。例如，可以使用整数值而不是小数值来处理货币。
Arbitrary Precision Integers with BigInt 在ES2020中定义的最新特性之一是一种名为BigInt的新数值类型。顾名思义，BigInt是一种数值类型，其值为整数。添加BigInt类型主要是为了允许表示64位整数，这是与许多其他编程语言和API兼容所必需的。
如果需要处理比较大的数字，BigInt值以有数千甚至数百万位。但请注意，BigInt并不适合用于加密，因为它实现时没有考虑预防时序攻击。
BigInt字面量是一串数字后面跟小写字母n。默认情况下，字面量的基数是10，但可以通过前置0b,0o和0x来表示二进制、八进制和十六进制。
console.log(1234n, 0b11111n, 0o7777n, 0x8000000n) // 1234n 31n 4095n 134217728n 可以使用BigInt()函数把普通的数值或字符串转换为BigInt值:
console.log(BigInt(Number.MAX_SAFE_INTEGER)) let string = &amp;#34;1&amp;#34; &#43; &amp;#34;0&amp;#34;.repeat(30); console.log(BigInt(string))  // 打印的值 9007199254740991n 1000000000000000000000000000000n BigInt的算术运算与常规数值的算术运算类似，只不过除法会丢弃余数，并向下取整：
console.log(1000n &#43; 2000n, 2000n * 3000n, 3000n / 997n, 3000n % 997n)  // 打印的值 3000n 6000000n 3n 9n 虽然&#43;, -, *, /, %和**运算符号均可以用于BigInt。但必须注意的是，不能将BigInt类型的操作数与普通数字操作数混合使用。
但是，比较运算符可以处理混合类型。位操作数通常可以用于BigInt操作数，但Math对象的任何函数都不接收BigInt操作数。
let timestamp = Date.now(); // The current time as a timestamp (a number). let now = new Date(); // The current time as a Date object. let ms = now.getTime(); // Convert to a millisecond timestamp. let iso = now.toISOString(); // Convert to a string in standard format. Text 表示文本的类型是字符串。字符串是由16bit值组成的不可变有序序列，每个数值通常代表一个Unicode字符。字符串的长度就是它包含16bit值的个数。字符串（及其数组）使用基于0的索引，第一个16bit值的索引为0，第二个16bit值的索引为1，以此类推。
空字符串就是长度为0的字符串。 JavaScript没有表示字符串中单个元素的特殊类型。若要表示单个16bit值，只需使用长度为1的字符串。
JavaScript使用UTF-16编码Unicode字符集 ，字符串是无符号16bit值序列。常见的Unicode字符，它的码点适合16bit，并且可以用字符串的一个元素来表示。若Unicode字符的码点不适合用16bit来表示的，则使用UTF-16规则编码为两个16bit值的序列（称为surrogate pair）。这意味着长度为2（两个16bit值）的JavaScript字符串可能只代表一个Unicode字符：
euro = &amp;#34;€&amp;#34;; love = &amp;#34;😍&amp;#34;; console.log(euro.length, love.length)  // 打印的值 1 2 JavaScript定义的大多数字符串方法都是对16bit值而非字符进行操作。它们不会特殊处理surrogate pair，不会对字符串进行归一化处理，甚至不会确保字符串是格式正确的UTF-16字符串。
在ES6中字符串是可迭代的。需要注意的是，如果对字符串使用for/of循环或...操作符，迭代的是字符而不是16bit值。
const str = &amp;#34;😍4567&amp;#34; console.log(&amp;#34;str length:&amp;#34;, str.length) for (const item of str) {  console.log(item) }  // 执行结果 str length: 6 😍 4 5 6 7 String Literals 若要使用字符串字面量，可以将字符串放到一对匹配的单引号，双引号或者反引号中。双引号和反引号字符可以出现在由单引号包含的字符串，反引号和单引号类似。
&amp;#34;&amp;#34; // The empty string: it has zero characters &amp;#39;testing&amp;#39; &amp;#34;3.14&amp;#34; &amp;#39;name=&amp;#34;myform&amp;#34;&amp;#39; &amp;#34;Wouldn&amp;#39;t you prefer O&amp;#39;Reilly&amp;#39;s book?&amp;#34; &amp;#34;τ is the ratio of a circle&amp;#39;s circumference to its radius&amp;#34; `&amp;#34;She said &amp;#39;hi&amp;#39;&amp;#34;, he said.` // length 25 使用反引号包含字符串是ES6的一大特色，它允许将表达式插值到字符串字面中。最早版本的JavaScript要求字符串字面量写在一行上，因此可能经常看到代码通过使用&#43;运算符连接单行字符串来创建长字符串。
但是，从ES5开始，可以在每一行（最后一行除外）的结尾使用反斜线，将字符串字面量分成多行。反斜线和它后面的行结束符都不是字符串字面量的一部分。
如果需要在单引号或双引号字符串字面量中包含换行符，需要使用字符\n。ES6的字符串反引号语法允许将字符串分成多行，在这种情况下，行结束符是字符串字面量的一部分：
// A string representing 2 lines written on one line: let s1 = &amp;#39;two\nlines&amp;#39;  // A one-line string written on 3 lines: &amp;#34;one\ long\ line&amp;#34;  // A two-line string written on two lines: `the newline character at the end of this line is included literally in this string`  {  let s1 = &amp;#39;two\nlines&amp;#39;  let s2 = &amp;#34;one\ long\ line&amp;#34;  let s3 = `the newline character at the end of this line is included literally in this string`  console.log(s1)  console.log(s2)  console.log(s3)  }  // 执行结果 two lines onelongline the newline character at the end of this line is included literally in this string 需要注意的是，在使用单引号定界字符串时，必须注意英文里的缩写和所有格形式，比如can&#39;t和O&#39;Reilly中的单引号，此时需要使用反斜杠字符进行转义：
&amp;#39;You\&amp;#39;re right, it can\&amp;#39;t be a quote&amp;#39; 反斜杠在JavaScript字符串中有特殊作用，它与后面的字符组合在一起，可以在字符串中表示一个无法直接表示的字符，例如\n表示一个换行符。在上面示例代码中，之所以称为转义序列，就是反斜杠转换了通常意义上单引号的含义，不再表示字符串定界符。
let str = &amp;#39;dddt\oonnn&amp;#39; console.log(str)  // 打印的结果 dddtoonnn 拼接字符串是JavaScript的一个内置特性，如果对字符串使用&#43;操作符，那么字符串就会拼接起来。可以使用标准的===或!==操作符比较字符串，只有当这两个字符串具有完全相同的16bit序列值才相等。
let msg = &amp;#34;Hello,&amp;#34; &#43; &amp;#34;world&amp;#34;; let greeting = &amp;#34;Welcome to my blog&amp;#34;; console.log(greeting) 字符串也可以使用&amp;lt;,&amp;lt;=,&amp;gt;,&amp;gt;=操作符，字符串的比较都是通过比较16bit值来完成的。要确定一个字符串的长度可以使用其length属性：
s.length 字符串还有其它相关API：
let s = &amp;#34;Hello,&amp;#34; &#43; &amp;#34;world&amp;#34;;  // Obtaining portions of a string s.substring(1, 4) // ell s.slice(1, 4) // ell s.slice(-3) // rld s.split(&amp;#34;, &amp;#34;) // [&amp;#34;Hello&amp;#34;,&amp;#34;world&amp;#34;]  // Searching a string s.indexOf(&amp;#34;l&amp;#34;) // 2: position of first letter l s.indexOf(&amp;#34;l&amp;#34;, 3) // 3: position of first &amp;#34;l&amp;#34; at or after 3 s.indexOf(&amp;#34;zz&amp;#34;) // -1: s does not include the substring &amp;#34;zz&amp;#34; s.lastIndexOf(&amp;#34;l&amp;#34;) // 10: position of last letter l  // Boolean searching functions in ES6 and later s.startsWith(&amp;#34;Hell&amp;#34;) // =&amp;gt; true: the string starts with these s.endsWith(&amp;#34;!&amp;#34;) // =&amp;gt; false: s does not end with that s.includes(&amp;#34;or&amp;#34;) // =&amp;gt; true: s includes substring &amp;#34;or&amp;#34;  // Creating modified versions of a string s.replace(&amp;#34;llo&amp;#34;, &amp;#34;ya&amp;#34;) // =&amp;gt; &amp;#34;Heya, world&amp;#34; s.toLowerCase() s.toUpperCase() s.normalize() // Unicode NFC normalization: ES6 s.normalize(&amp;#34;NFD&amp;#34;) // NFD normalization. Also &amp;#34;NFKC&amp;#34;, &amp;#34;NFKD&amp;#34;  // Inspecting individual (16-bit) characters of a string s.charAt(0) // =&amp;gt; &amp;#34;H&amp;#34;: the first character s.charAt(s.length-1) // =&amp;gt; &amp;#34;d&amp;#34;: the last character s.charCodeAt(0) // =&amp;gt; 72: 16-bit number at the specified position s.codePointAt(0) // =&amp;gt; 72: ES6, works for codepoints &amp;gt; 16 bits   // String padding functions in ES2017 &amp;#34;x&amp;#34;.padStart(3) // =&amp;gt; &amp;#34; x&amp;#34;: add spaces on the left to a length of 3 &amp;#34;x&amp;#34;.padEnd(3) // =&amp;gt; &amp;#34;x &amp;#34;: add spaces on the right to a length of 3 &amp;#34;x&amp;#34;.padStart(3, &amp;#34;*&amp;#34;) // =&amp;gt; &amp;#34;**x&amp;#34;: add stars on the left to a length of 3 &amp;#34;x&amp;#34;.padEnd(3, &amp;#34;-&amp;#34;) // =&amp;gt; &amp;#34;x--&amp;#34;: add dashes on the right to a length of 3  // Space trimming functions. trim() is ES5; others ES2019 &amp;#34; test &amp;#34;.trim() // =&amp;gt; &amp;#34;test&amp;#34;: remove spaces at start and end &amp;#34; test &amp;#34;.trimStart() // =&amp;gt; &amp;#34;test &amp;#34;: remove spaces on left. Also trimLeft &amp;#34; test &amp;#34;.trimEnd() // =&amp;gt; &amp;#34; test&amp;#34;: remove spaces at right. Also trimRight  // Miscellaneous string methods s.concat(&amp;#34;!&amp;#34;) // =&amp;gt; &amp;#34;Hello, world!&amp;#34;: just use &#43; operator instead &amp;#34;&amp;lt;&amp;gt;&amp;#34;.repeat(5) // =&amp;gt; &amp;#34;&amp;lt;&amp;gt;&amp;lt;&amp;gt;&amp;lt;&amp;gt;&amp;lt;&amp;gt;&amp;lt;&amp;gt;&amp;#34;: concatenate n copies. ES6 需要注意的是，字符串是不可变的。字符串的replace()和toUpperCase()等方法会返回新的字符串，它们不会修改原来的字符串。字符串能够被当作只读数组，可以使用方括号而不是charAt()访问字符串中的单个字符（16bit值）：
let s = &amp;#34;hello, world&amp;#34;; console.log(s[0], s[s.length - 1]) // h d Template Literals 在 ES6及更高版本中，字符串字面量可以用反引号分隔：
let s = `hello world`; console.log(s) // hello world 这不仅是另一种表示字面量的方式，更是因为template literals能够包含任意表达式。反引号字符串字面的最终值是先计算包含的表达式的值，然后将这些表达式计算后的值转换为字符串，最后将这些计算出的字符串与反引号字符串内的字面量相结合而得出：
let name = &amp;#34;Bill&amp;#34;; let greeting = `Hello ${name}.`; console.log(greeting) // Hello Bill. 在${}中的内容被解释成表达式，而在花括号外的内容是普通的字符串字面量。模板字面量可能包含很多表达式，它可以包含任何普通字符串中能够出现的转义字符，也可以跨越多行而无需转义字符。
下面的模板字面量包含四个JavaScript 表达式、一个Unicode转义序列和至少四个换行符（表达式值中也可能包含换行符）：
let errorMessage = `\ \u2718 Test failure at ${filename}:${linenumber}: ${exception.message}Stack trace: ${exception.stack}`;  console.log(errorMessage) 上面字符串第一行末尾的反斜线转义了第一个换行符，因此生成的字符串以Unicode 字符✘（\u2718）而不是换行符开始。
模板字面量的一个强大但不常用的功能是，如果一个函数名（或tag）出现在字符串开始的反引号前面，那么模板字面量的文本和里面表达式的值都会传递给该函数。这个tagged template literal的值就是这个函数的返回值。
ES6有一个内置的tag函数String.raw()，这个函数返回反引号中未经处理的文本，即不会处理任何反斜杠转义字符：
console.log(`\n`.length); console.log(String.raw`\n`.length); // 打印的结果 1 2 自定义模板标签函数是一个非常强大的特性，这些函数不需要返回字符串，并且可以被当成构造函数使用，就像为语言本身定义了一种新的字面量语法一样。
Pattern Matching JavaScript定义了一种称为正则表达式（或 RegExp）的数据类型，用于描述和匹配文本字符串中的模式。RegExp并不是基本数据类型之一，但它拥有像数字和字符串一样的字面语法，因此看起来像是基本数据类型。正则表达式字面的语法很复杂，而且它们定义的API也不简单。
一对斜杠之间的文本构成了正则表达式字面量，其中第二个斜杠后面可以跟着一个或多个字母，用于修改模式的含义：
/^HTML/; // Match the letters HTML at the start of a string /[1-9][0-9]*/; // Match a nonzero digit, followed by any of digits /\bjavascript\b/i; // Match &amp;#34;javascript&amp;#34; as a word, case-insensitive RegExp对象定义了一系列有用的方法，字符串也有方法接收RegExp参数：
let text = &amp;#34;testing: 1, 2, 3&amp;#34;; // Sample text let pattern = /\d&#43;/g; // Matches all instances of one or more digits  pattern.test(text) // =&amp;gt; true: a match exists text.search(pattern) // =&amp;gt; 9: position of first match text.match(pattern) // =&amp;gt; [&amp;#34;1&amp;#34;, &amp;#34;2&amp;#34;, &amp;#34;3&amp;#34;] text.replace(pattern, &amp;#34;#&amp;#34;) // &amp;#34;testing: #,#,#&amp;#34; text.split(/\D&#43;/) // [&amp;#34;&amp;#34;, &amp;#34;1&amp;#34;, &amp;#34;2&amp;#34;, &amp;#34;3&amp;#34;] split on nondigits Boolean Values JavaScript的任何值都可以转换为布尔值，下面的值都会转为false。false和下面能转换为false的6个值，被称为falsy值：
undefined null 0 -0 NaN &amp;#34;&amp;#34; // the empty string 其它的值，包括所有对象都能转换为true，true和这些能转换为true的值被称为truthy值。假设一个变量保存一个对象，要么其值是null，要么保存真正的对象，可以使用下面两种方式判断：
if (o !== null) {  console.log(&amp;#34;o is not null&amp;#34;) } else {  console.log(&amp;#34;o is null&amp;#34;) }  if (o) {  console.log(&amp;#34;o is not null&amp;#34;) } else {  console.log(&amp;#34;o is null&amp;#34;) } 布尔值有一个toString()方法，可用于将自己转换为字符串&amp;quot;true&amp;quot;或&amp;quot;false&amp;quot;。除此之外，布尔值再没有其它有用的方法。
console.log(true.toString(), false.toString()) // true false  // 执行结果 true false null and undefined null是一个语言关键词，用于表示某个值不存在。使用typeof操作符作用于null，将会返回字符串object。这表明null是一种特殊的对象值，它表示no object：
console.log(typeof null)  // 打印的值 object 实际上，null通常被视为其自身类型的唯一成员，可以用来表示数字、字符串和对象的&amp;quot;no object&amp;quot;。大多数编程语言都有与JavaScript的null相对应的值，如NULL、nil 或None。
undefined也表示值不存在，但它表示一种更深层次的不存在。具体来说，以下场景都是undefined:
 变量未初始化时值为undefined。 在查询对象不存在的属性或数组元素时也会得到undefined。 没有传实参的函数参数的值是undefined。  undefined是一个预定义的全局常量，而非像null那样是语言关键字。这个常量的初始化值就是undefined。对undefined应用typeof操作符会返回字符串undefined，表示这个值是该特殊类型的唯一成员。
console.log(typeof undefined) // undefined 因为null和undefine都可以表示某个值不存在，所以经常被混用。相等操作==认为它们相等，要区分它们必须使用全等操作符===。
console.log(null == undefined, null === undefined) // 执行结果 true false Symbols Symbols是ES6引入的，用作非字符串属性名。要了解Symbols，需要知道基本的Object类型是一个无序的属性集合，其中的每个属性都有一个名称和一个值。对象的属性名通常是字符串，但在ES6及之后，Symbols也可以实现这个目的。
let strName = &amp;#34;string name&amp;#34;; let symName = Symbol(&amp;#34;propName&amp;#34;); console.log(typeof strName); console.log(typeof symName); let o = {}; o[strName] = 1; o[symName] = 2; console.log(o) console.log(Symbol())  // 执行的结果 String Symbol Object {string name: 1, Symbol(propname): 2} Symbol() Symbol没有字面量语法，要获取一个Symbol值，需要调用Symbol()函数。这个函数永远不会返回相同的值，即使调用时传入相同的参数。
这意味着，调用Symbol()取得的值，可以安全地作为属性名以添加对象新的属性，无需担心覆盖原有的属性。类似地，可以使用那些未被共享的符号属性名，可以确保程序中的其它代码不会意外的重写这个属性。
实践中，Symbol通常用作一种语言扩展机制。ES6新增了for/of循环可迭代对象，为此需要定义一种标准的机制让类变成可迭代的。但是，如果选择任何特定的字符串作为这个迭代器方法名，都可能破坏已有的代码，因此Symbol应运而生。
Symbol()函数可选地接受一个字符串参数，返回唯一的符号值。如果在调用的时候传递一个字符串参数，那么调用Symbol的toString()方法得到的结果中会包含该字符串。但传入两个相同的字符串，调用Symbol两次获取到的Symbol值是不同的。
let s = Symbol(&amp;#34;sym_x&amp;#34;); console.log(s.toString()) // Symbol(sym_x) let s1 = Symbol(&amp;#34;sym_x&amp;#34;) console.log(s1.toString()) // Symbol(sym_x) console.log(s1 === s)  // 打印的值 Symbol(sym_x) Symbol(sym_x) false 方法toString()是Symbol实例中唯一有趣的方法。但是，还应该了解另外两个与Symbol相关的函数。有时，使用Symbol时希望它们是私有的，这样就可以保证自定义的属性不会与其它代码使用的属性发生冲突。
但有时，可能希望定义一个Symbol值，并与其它代码共享。如果要定义某种扩展，并希望其它代码也能使用，就会出现这种情况。
为了满足后一种场景，JavaScript定义了一个全局Symbol注册表。Symbol.for()函数接收一个字符串参数，返回一个与所传字符串相关联的Symbol值。如果该字符串尚未关联任何Symbol，则会创建并返回一个新的Symbol。否则，将返回已存在的Symbol。
也就是说，Symbol.for()函数与Symbol()函数完全不同。 Symbol()两次调用不会返回相同的值，但Symbol.for()在调用相同字符串时总是返回相同的值。传递给 Symbol.for()的字符串会出现在返回符号的 toString()输出中，也可以调用Symbol.keyFor()来获取。
let s = Symbol.for(&amp;#34;shared&amp;#34;); let t = Symbol.for(&amp;#34;shared&amp;#34;); console.log(s === t, s.toString(), Symbol.keyFor(t))  // 打印的值 true Symbol(shared) shared The Global Object 全局对象的属性是全局性定义的标识符，可以在程序的任何地方使用。JavaScript解释器启动后或每次浏览器加载新页面时，都会创建一个新的全局对象，并为这个全局对象添加一组初始的属性：
 undefined、Infinity和NaN这样的全局常量。 isNaN()，parseInt()和eval()这样的全局函数。 Date()，RegExp()，String()，Object()和Array()这样的构造函数。 Math和JSON这样的全局对象。  全局对象的初始属性不是保留字，但它们应该都被当成保留字。在Node中，全局对象有一个属性名为global，表示这个全局对象本身。
在浏览器中，Window对象对浏览器窗口中所有JavaScript代码而言，充当了全局对象的角色。这个全局的Window对象有一个自引用的window属性，可以引用全局对象。
Immutable Primitive Values and Mutable Object References 基本类型(undefined，null，布尔值，数值和字符串）和对象类型（包括数组和函数）有一个本质区别，基本类型是不可变的，对象类型是可变的。
let object = {x: 12} object.x = 13 object.y = 14 基本类型是按值比较的，而对象类型不是按值比较的。两个不同的对象即使拥有完全相同的属性和值，它们也不相等。两个不同的数组即使具有相同顺序的相同元素，也是不相等的。
let x = 12; let o = {x: 1}, p = {x: 1}; console.log(o === p) let a = [], b = []; console.log(a === b) 区别于基本数据类型，对象类型也被称为引用类型。使用这种术语，对象值就是引用，对象是按引用比较的。两个对象相等当且仅当它们引用同一个底层对象：
// 数组是引用类型 let a = []; // 引用赋值 let b = a; b[0] = 1; console.log(a[0]) // 1 // a和b引用同一个对象 console.log(a === b) // true 从上面代码中可以看出，将对象（或数组）赋值给变量只是赋值引用，并不会创建对象的新副本。如果要创建对象或数组的新副本，必须明确复制对象的属性或数组的元素：
let a = [&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;]; let b = []; for (let i = 0; i &amp;lt; a.length; i&#43;&#43;) {  b[i] = a[i]; } // 复制数组 let c = Array.from(b); console.log(a, b, c)  console.log(a === b, a === c, b === c) // false false false 类似的，如果想比较两个不同的对象或数组，必须比较它们的所有属性或数组中的每个元素。下面函数用于比较两个不同数组的内容是否相等：
function equalArrays(a, b) {  if (a === b) return true;  if (a.length != b.length) return false;  for (let i = 0; i &amp;lt; a.length; i&#43;&#43;) {  if (a[i] !== b[i]) return false;  }  return true; } Type Conversions 不同于其他静态类型语言，JavaScript的类型非常灵活，这一点在上面介绍布尔值已经看到了。如果在需要布尔值，我们提供了一个其它类型的值，则这些值会自动转换为布尔值。
对于其它类型也是一样的，如果想要一个字符，传入的任何值都会转换成字符串。如果想要数值，会尝试把传递的值转换为一个数值，如果无法转换，就会转换为NaN。
console.log(10 &#43; &amp;#34; objects&amp;#34;) console.log(&amp;#34;7&amp;#34; * &amp;#34;4&amp;#34;) let n = 1 - &amp;#34;x&amp;#34;; console.log(n) console.log(n &#43; &amp;#34; objects&amp;#34;)  // 执行的结果 10 objects 28 NaN NaN objects 下面表格总结了值如何从一种类型转换成另一种类型。粗体部分突出显示了可能会让我们感到吃惊的转换。空格表示不需要进行类型转换，也不执行类型转换。
let a = [1] &#43; 1 let b = [8] &#43; 1 console.log(a, b, typeof a, typeof b, Number([8]) &#43; 1)  // 执行结果 11 81 string string 9 Conversions and Equality 有两种操作符测试两个值是否相等，一种是严格相等操作符===，若两个值的类型不同，则它认为它们不相等。因为JavaScript在类型上比较灵活，所以定义了==操作符，这个操作符判定相等的标准相当灵活：
null == undefined // =&amp;gt; true: These two values are treated as equal. &amp;#34;0&amp;#34; == 0 // =&amp;gt; true: String converts to a number before comparing. 0 == false // =&amp;gt; true: Boolean converts to number before comparing. &amp;#34;0&amp;#34; == false // =&amp;gt; true: Both operands convert to 0 before comparing! 需要注意的是，一个值可以转换为另一种类型，但这并不意味这两个值是相等的。例如，undefined在需要布尔值的地方会转换为false，但这不意味着undefined == false的结果为true：
console.log(false == undefined) // false 操作符和语句期待不同的类型，因此会执行以这些目标类型的转换。if语句会将undefined转换为false，但==操作符不会尝试将操作数转换为布尔类型。
Explicit Conversions 虽然会执行很多类型自动转换，但有时需要进行显式类型转换，以保证代码清晰。显式类型转最简单的方法是使用Boolean(), Number()和String()函数。
console.log(Number(&amp;#34;3&amp;#34;), String(false), Boolean([])) // 3 false true 除了null和undefined，任何其它值都有toString()方法，并且调用toString方法的返回值和直接调用String()函数的结果一样。
console.log(null.toString()) // Uncaught TypeError: Cannot read properties of null (reading &amp;#39;toString&amp;#39;)  console.log(undefined.toString()) //Uncaught TypeError: Cannot read properties of undefined (reading &amp;#39;toString&amp;#39;)  console.log(String(null), String(undefined)) // null undefined 某些操作符会进行隐式类型转换。如二元操作符&#43;的一个操作数是字符串，则会将另一个操作数转换为字符串。一元操作符会把自己的操作数转换为数值。一元操作符!会先把它的操作数转换为布尔类型，然后再取反。
x &#43; &amp;#34;&amp;#34; // =&amp;gt; String(x) &#43;x // =&amp;gt; Number(x) x-0 // =&amp;gt; Number(x) !!x // =&amp;gt; Boolean(x): Note double ! Number类定义的toString()方法接受一个可选参数，以指定基数或底数。如果没有特殊指定这个参数，则默认基数是10:
let n = 17; let binary = &amp;#34;0b&amp;#34; &#43; n.toString(2); let octal = &amp;#34;0o&amp;#34; &#43; n.toString(8); let hex = &amp;#34;0x&amp;#34; &#43; n.toString(16);  console.log(n, binary, octal, hex)  // 打印结果 17 0b10001 0o21 0x11 如果把字符串传给Number()函数，它会尝试把字符串转换为整数或浮点字面量。但是，这个函数只能处理以10为基数，且末尾不能有无关字符。
但全局的函数parseInt()和parseFloat()更灵活。若整数以0x或0X开头，parseInt()会将其解析为十六进制，并且parseInt()和parseFloat()都会跳过开头的空格，尽量多地解析数字字符，忽略后面的无关字符。如果第一个非空字符不是有效的数值字面量，将会返回NaN:
console.log(&amp;#34;3 blind mice&amp;#34;) // 3 console.log(parseFloat(&amp;#34; 3.14 meters&amp;#34;)) // 3.14 console.log(parseInt(&amp;#34;-12.34&amp;#34;)) // -12 console.log(parseInt(&amp;#34;0xFF&amp;#34;)) // 255 console.log(parseInt(&amp;#34;0xff&amp;#34;)) // 255 console.log(parseInt(&amp;#34;-0XFF&amp;#34;)) //- 255 console.log(parseFloat(&amp;#34;.1&amp;#34;)) // 0.1 console.log(parseInt(&amp;#34;0.1&amp;#34;)) // 0.1 console.log(parseInt(&amp;#34;.1&amp;#34;)) // NaN console.log(parseFloat(&amp;#34;$72.47&amp;#34;)) // NaN parseInt()接收可选的第二个参数，用于指定数值的基数，合法的值是2到36:
console.log(parseInt(&amp;#34;11&amp;#34;, 23)) // 24 console.log(parseInt(&amp;#34;ff&amp;#34;, 16)) // 255 console.log(parseInt(&amp;#34;zz&amp;#34;, 36)) // 1295 console.log(parseInt(&amp;#34;077&amp;#34;, 8)) // 63 console.log(parseInt(&amp;#34;077&amp;#34;, 10)) // 77 Object to Primitive Conversions 上面已经讲解了从一个基本类型到另一种基本类型的转换，这一部分讲解将对象转换为基本类型的规则。该节冗长而晦涩。
Variable Declaration and Assignment 在使用变量和常量之前，都必须先声明它。在ES6之后，使用let和const关键字声明，在ES6之前使用var声明，并且使用var关键字更特殊一些。
Declarations with let and const 如果使用let声明变量时，未初始化值，则在变量被初始化之前，它的值为undefined：
let i; let sum;  // 一次定义多个变量 let i, sum;  let message = &amp;#34;hello&amp;#34;; let i = 0, j = 0, k = 0;  // 初始化时可以使用之前已经声明的变量 let x = 2, y = x * x; 要声明常量而非变量时，需要使用const关键词。使用const声明常量时必须同时初始化（这与Swift有显著区别）。常量的值不能被改变，如果尝试重新赋值，则会抛出TypeError。声明常量的一个常见约定是全部字母大写。
const H0 = 74; const C = 299792.458; const AU = 1.496E8; 在同一个作用域内使用多个let或const声明同一个名字是语法错误。在嵌套作用域内声明同名的变量是合法的，但不推荐这样做。
const x = 1; if (x === 1) {  const x = 2;  console.log(x) // 2 } console.log(x) // 1 Variable Declarations with var 在ES6之前，声明变量的唯一方式是使用var关键词，并且不允许声明常量。使用var声明变量的语法和使用let关键词一样：
var x; var data = [], count = data.length; for (var i = 0; i &amp;lt; count, i&#43;&#43;) {  console.log(data[i]) } 虽然var和let有相同的语法，但它们也有重要的区别：
 使用var声明的变量不具有块作用域。这种变量的作用域仅限于包含变量声明的函数体，无论它在函数中嵌套层次有多深。 如果在函数外部使用var声明变量，则会声明一个全局变量。但与let声明的全局变量有一个重要区别，var声明的全局变量被实现为全局对象的属性，全局对象可以使用globalThis引用。 使用var多次声明同名变量是合法的。因为var具有函数作用域，而非块作用域，所以经常会出现声明同名变量的情况。 使用var声明变量，该变量会被提升到函数的顶部，但变量的初始化仍然在代码所在位置。  在严格模式下，如果试图使用未声明的变量，运行代码时会出现引用错误。然而，在非严格模式，如果为一个未使用let、const或var声明的名称赋值，最终会创建一个新的全局变量。无论引用的代码嵌套在函数和代码块中多深，它都将是一个全局变量，这几乎不是我们想要的，而且容易出错，也是使用严格模式的最佳原因之一。
Destructuring Assignment ES6实现了一种复合声明与赋值语法，叫做解构赋值。在解构赋值中，等号右边是一个数组或对象，等号左边以模拟或数组和对象的方式指定一个或多个变量名字。
let [x, y] = [1, 2]; [x, y] = [x &#43; 1, y &#43; 1]; // 同时赋值 [x, y] = [y, x]; // 交换两个变量的值 console.log(x, y)  // 打印的值 3 2 解构赋值可以让返回数组的函数变得非常便捷：
function toPolar(x, y) {  return [Math.sqrt(x * x &#43; y * y), Math.atan2(y, x)]; }  function toCartesian(r, theta) {  return [r * Math.cos(theta), r * Math.sin(theta)]; }  let [r,theta] = toPolar(1.0, 1.0); let [x,y] = toCartesian(r,theta); 在循环中也可以使用解构赋值：
let o = {x: 1, y: 2}; // The object we&amp;#39;ll loop over for (const [name, value] of Object.entries(o)) {  console.log(name, value); }  for ([name, value] of Object.entries(o)) {  console.log(name, value); } 解构赋值时，等号左边的变量数量不必与等号右边的数组元素个数匹配，左边多余的变量的初始值为undefined，右边多余的值会被忽略。左边变量列表可以包含额外的逗号，用于跳过右侧某些值：
let [x, y] = [1]; [x, y] = [1, 2, 3]; [, x, , y] = [1, 2, 3, 4]; console.log(x, y) // 2 4 在解构赋值时，如果想把所有未使用或剩余的值收集到一个变量中，可以在左侧最后一个变量名前加上3个点：
let [x, ...y] = [1, 2, 3, 4]; console.log(x, y)  // 执行结果 1 [ 2, 3, 4 ] 解构赋值可以用于嵌套数组，此时左边也应该看起来像一个内嵌的数组字面量：
let [a, [b, c]] = [1, [2, 2.5], 3]; // a == 1; b == 2; c == 2.5 console.log(a, b, c)  // 执行结果 1 2 2.5 数组解构的一个重要特性是等号右侧并不要求是数组。实际上，解构右侧可以使用任何可迭代对象，任何可以在for/of循环中使用的对象都可被解构：
let [first, ...rest] = &amp;#34;Hello&amp;#34;; console.log(first, rest) // first == &amp;#34;H&amp;#34;; rest == [&amp;#34;e&amp;#34;,&amp;#34;l&amp;#34;,&amp;#34;l&amp;#34;,&amp;#34;o&amp;#34;] 解构赋值在右侧是对象值的情况下也可以执行。此时，左侧看起来像是一个对象字面量，即一个包含在花括号内以逗号分隔的变量名列表：
let transparent = {r: 0.0, g: 0.0, b: 0.0, a: 1.0}; let {r, g, b} = transparent; // r == 0.0; g == 0.0; b == 0.0 下面示例展示了把Math对象的全局函数复制给变量，这种方式可以简化代码：
// Same as const sin=Math.sin, cos=Math.cos, tan=Math.tan const {sin, cos, tan} = Math; console.log(sin(30), cos(30), tan(30))  // 执行结果 // -0.9880316240928618 0.15425144988758405 -6.405331196646276 需要注意的是，如果等号左侧不是Math对象的属性名，则该变量的值为undefined。在上面解构中，我们选择了和要解构对象的属性一致的变量名，但这不是必须的：
// Same as const cosine = Math.cos, tangent = Math.tan; const {cos: cosine, tan: tangent} = Math; console.log(cosine(12)) // 0.8438539587324921 Chapter 4 表达式是一个可以被求值并产生一个值的短语，嵌入到程序中的常量是最简单的表达式之一，变量名也是一种简单的表达式，它的值为赋给该变量的值相同。
复杂的表达式由简单的表达式组成，例如一个数组访问表达式由一个求值为数组的表达式、一个左方括号，一个求值为整数的表达式和一个右方括号构成。
Primary Expressions 最简单的表达式被称为基础表达式，是指那些独立存在，不再包含更简单表达式的表达式。基础表达式包含常量，字面量，某些关键字和变量引用。
  字面量是可以直接嵌入到程序中的常量值。
1.23 // A number literal &amp;#34;hello&amp;#34; // A string literal /pattern/ // A regular expression literal   保留字也是基础表达式。
true false null this   常量，变量或全局对象属性的引用。
i sum undefined 当程序中出现任何标识符时，都被假设为常量或变量或全局对象的属性，并查询它的值。如果不存在该名字的变量，则会抛出ReferenceError。
  Object and Array Initializers 对象和数组初始化器也是表达式，值为新创建的对象或数组。这些初始化表达式也被称为对象字面量或数组字面量。与真正的字面量不同，它们不是基础表达式。
[] // An empty array: no expressions inside brackets means no elements [1&#43;2,3&#43;4] // A 2-element array. First element is 3, second is 7 let matrix = [[1,2,3], [4,5,6], [7,8,9]]; let sparseArray = [1,,,,5];  let p = { x: 2.3, y: -1.2 } // An object with 2 properties let q = {}; // An empty object with no properties q.x = 2.3; q.y = -1.2; // Now q has the same properties as p 在ES6中，对象字面量有更丰富的语法，可以嵌套。
let rectangle = {  upperLeft: {x: 2, y: 2},  lowerRight: {x: 4, y: 5} }; Property Access Expressions 属性访问表达式求值对象属性或数组的元素，有两种属性访问语法。第一种是使用点操作符，另一种是使用方括号，示例如下：
let o = {x: 1, y: {z: 3}}; let a = [o, 4, [5, 6]]; console.log(o.x, o.y.z, o[&amp;#34;x&amp;#34;], a[1], a[2][&amp;#34;1&amp;#34;])  // 执行结果 1 3 1 4 6 无论使用哪种属性访问表达式，位于.或[前的表达式都会被求值，如果求值结果为null或undefined，表达式就会抛出TypeError，因为null或undefined是不能有属性的两个值。
Operator Overview 多数操作符都是类似&#43;和=这样的标点符号，也有一些delete和instanceof这样的关键字操作符。关键字操作符也是常规操作符，只不过它们的语法没有那么简短而已。
尽管typeof是最高优先级的操作符，但typeof操作符基于属性访问，数组索引以及函数调用，这些操作的优先级全部高于操作符。
操作符&#43;优先字符串拼接，只要操作数是字符串或可以转换为字符串的对象，另一个操作数也会被转换为字符串并执行拼接操作。只有任何操作数都不是字符串或string-like才会执行加法操作。
eval()期待一个参数，如果传入的是非字符串参数，它会简单地返回这个值。如果传入字符串，它会尝试把这个字符串当作JavaScript字符串来解析，解析失败会抛出SyntaxError，如果解析成功，它会求值代码并返回该字符串中最后一个表达式或语句的值，如果最后一个表达式或语句没有值则返回undefined。
操作符??求值其先定义的操作数，如果左边的操作数不是null或undefined，就返回该值。否则，它会返回右操作数的值。
typeof是一个元操作符，放在自己的操作数前面，这个操作数可以是任意类型。typeof操作符的返回值是一个字符串，表明操作数的类型。
需要注意的是，如果操作数的值是null，typeof返回字符串object。如果想区分null和对象，必须显式测试这个特殊值。
delete是一元操作符，它尝试删除其操作数指定的对象属性或数组元素。
let o = {x: 1, y: 2}; // Start with an object delete o.x; // Delete one of its properties &amp;#34;x&amp;#34; in o // =&amp;gt; false: the property does not exist anymore  let a = [1, 2, 3]; // Start with an array delete a[2]; // Delete the last element of the array 2 in a // =&amp;gt; false: array element 2 doesn&amp;#39;t exist anymore a.length // =&amp;gt; 3: note that array length doesn&amp;#39;t change, though 被删除的属性和数组元素会被设置为undefined。尝试读取删除的属性或数组元素时，会返回undefined值，通过in操作符可以测试某个属性是否存在。删除某个数组元素会在数组中留下一个坑，并不会改变数组长度。
Chapter 5 表达式称为短语，语句就是句子或命令，使用分号结尾。与逗号操作符将多个表达式组合成一个表达式一样，花括号将多个语句组合成一个复合语句。
{  x = Math.PI;  cx = Math.cos(x);  console.log(&amp;#34;cos(π) = &amp;#34; &#43; cx); } 解释器在执行空语句时什么也不会做，空语句在某些情况会有用，比如创建一个空循环体：
let a = [12, 34, 5, 89, 9, 23] for (const item of a) {  console.log(item) } for (let i = 0; i &amp;lt; a.length; a[i&#43;&#43;] = 0) ; for (const item of a) {  console.log(item) } 在for (let i = 0; i &amp;lt; a.length; a[i&#43;&#43;] = 0) ;这个循环中，所有工作都由表达式a[i&#43;&#43;] = 0完成，因此不需要循环体。但是，JavaScript语法要求使用语句作为循环体，因此使用了一个空语句，即一个分号。
switch语句首先对紧跟其后的表达式求值，然后按照顺序求值case表达式，直到遇到匹配的值。这里的匹配使用===全等操作符，而不是==相等操作符，因此表达式必须在没有类型转换的情况下匹配。
for/of 对for循环而言，3个表达式中的任何一个都可以省略，只有两个分号是必需的。ES6定义了一个新循环语句for/of，这种新循环虽然使用了for关键字，但它与常规for是完全不同的两种循环。for/of循环专门用于可迭代对象。数组，字符串，集合和映射都是可迭代对象。
let data = [1, 2, 3, 4, 5, 6, 7, 8, 9], sum = 0; for (const element of data) {  sum &#43;= element; } console.log(sum)  // 执行结果 45 在上面代码中，data数组中的每个元素都会运行一次循环体。在每次执行循环体之前，都会把数组的下一个元素赋值给element变量，并且是按照从头到尾的顺序迭代的。
实际上，对象默认是不可迭代的，运行时尝试对普通对象使用for/of会抛出TypeError。下面定义了一个对象，但因为默认不可迭代，因此会抛异常：
let object1 = {&amp;#34;ab&amp;#34;: 12, &amp;#34;dc&amp;#34;: 45} for (const element of object1) {  console.log(element) }  // TypeError: object1 is not iterable 如果想要迭代对象的属性，可以使用for/in循环，或者使用Object.keys()方法和for/of:
let o = {x: 1, y: 2, z: 3}; let keys = &amp;#34;&amp;#34;; for (let k of Object.keys(o)) {  keys &#43;= k; } console.log(keys)  // 执行结果 xyz 需要注意的是，对对象key的迭代并不像上述数组示例那样是实时的。在循环体中对对象o所做的修复不会对迭代产生任何影响。如果不关心对象的key，而关心对象的value，可以像下面这样遍历对象的value：
let sum = 0; for (let v of Object.values(o)) {  sum &#43;= v; } console.log(sum)  // 执行结果 6  {  let o = {x: 1, y: 2, z: 3};  let sum = 0;  for (let v of Object.values(o)) {  sum &#43;= v;  if(v == 3) {  o[&amp;#34;z&amp;#34;] = 4  }  }  console.log(sum) }  // 执行结果 6 如果对对象的key和value都感兴趣，可以使用for/of和Object.entries()以及解构赋值。Object.entries()返回一个数组，其中的每个元素是对象属性键值对的数组。在下面示例中，使用重构赋值将这些内部数组解包为两个单独的变量：
let pairs = &amp;#34;&amp;#34;; for (let [k, v] of Object.entries(o)) {  pairs &#43;= k &#43; v; } console.log(pairs)  // 执行结果 x1y2z3 字符串是按照Unicode码点，也就是字符，而不是UTF-16字符迭代的。虽然字符串I😀😁的长度为5，但使用for/of只会迭代3次：
let test = &amp;#34;I😀😁&amp;#34; console.log(test.length) // 打印值为5 for (let item of test) {  console.log(item) }  // 打印结果 I 😀 😀 ES6内置的Set和Map类都是可迭代的：
let text = &amp;#34;Na na na na na na na na Batman!&amp;#34;; let wordSet = new Set(text.split(&amp;#34; &amp;#34;)); let unique = []; for (const word of wordSet) {  unique.push(word); } console.log(unique) // [&amp;#34;Na&amp;#34;, &amp;#34;na&amp;#34;, &amp;#34;Batman!&amp;#34;] Map对象的迭代器并不迭代key或value，而是迭代键值对。每次迭代，迭代器都会返回一个数组，第一个元素是key，第二个元素是相应的value。
let m = new Map([[1, &amp;#34;one&amp;#34;]]); for (let [key, value] of m) {  console.log(key, value) } // 1 one 在ES2018引入了一种新的迭代器，被称为异步迭代器，以及一种for/of循环变体（称为for/await循环），可与异步迭代器一起工作。
async function printStream(stream) {  for await (let chunk of stream) {  console.log(chunk);  } } for/in 一个for/in循环看起来非常像for/of循环，只是将关键字of改成了in。for/of循环要求在of后面是一个可迭代对象，而for/in循环则可以在in后面使用任何对象。for/of循环是ES6新增的特性，但for/in从一开始就是JavaScript的一部分，for/in循环迭代的是指定对象的属性名：
// Assign property names of o to variable p for (let p in o) {  // Print the value of each property  console.log(o[p]); } 要执行for/in语句，解释器首先会求值对象表达式，如果结果为null或undefined，解释器会跳过循环，继续执行下一条语句。否则，解释器会对对象的每个可枚举属性执行一次循环体。不过，在每次迭代之前，解释器都会对variable表达式进行求值，并将属性名称（字符串值）赋值给variable表达式。
for (variable in object)  statement 需要注意的是，for/in循环中的variable可以是任意表达式，只要它求值后适合做赋值操作符的左值。每次循环都会对该表达式求值，这意味着每次求值的结果都可能不同。例如，可以使用以下代码将对象o的所有属性名复制到数组a中：
let o = {x: 1, y: 2, z: 3}; let a = [], i = 0; for (a[i&#43;&#43;] in o) /* empty */; for (const item of a) {  console.log(item) } 数组只是一个特殊的对象，数组索引就是对象的属性，可以使用for/in循环。下面使用for/in遍历的是数组的索引，如果想要遍历数组元素，可以使用for/of循环。
for (let i in a) console.log(i);  // 执行结果 0，1，2 for/in循环实际上并不枚举对象的所有属性，它不会枚举Symbol属性。在字符串属性中，for/in只会循环遍历可枚举的属性。
JavaScript核心定义的各种内置方法都是不可枚举的。例如，所有对象都有一个toString()方法，但for/in循环不会枚举这个toString属性。除了内置方法外，内置对象的许多其它属性也是不可枚举的。默认情况下，我们用代码定义的所有属性和方法都是可枚举的。
可枚举的继承属性也会被for/in循环枚举。这意味着，在使用for/in循环时，还会遍历继承的属性，那么循环可能不会按照我们期望的方式运行。因此，许多程序员喜欢使用带有Object.keys()的for/of循环，而不是for/in循环。
如果在for/in循环体中删除了一个尚未枚举的属性，该属性将不会再被枚举。如果在循环体定义了对象的新属性，这些属性可能被枚举，也可能不被枚举。
需要强调的是，for/in循环的in后面可以是任意对象，for/of循环是ES6新增的，而for/in是一开始就有的。
Chapter 6 对象是属性的无序集合，每个属性都有名字和值。属性名通常是字符串，也可以是Symbol。可以说对象是把字符串映射为值。这种把字符串映射为值有很多种叫法，如散列，字典或关联数组。但是，对象不仅仅是简单的字符串到值的映射。
除了维护自定义属性，对象也可以从其它对象继承属性，这个其它对象称为其原型。对象的方法通常继承自属性，这种原型继承是JavaScript的关键特性。
对象是动态的，属性通常可以添加或删除。属性有一个名字和值，属性名可以是任意字符串，包括空字符串或任意符号Symbol，但对象不能包含两个同名的属性。
不是字符串、数字、符号、布尔值或null或undefined以及Symbol的任何值都是对象。尽管字符串、数字和布尔值不是对象，但它们的行为却与不可变对象类似。
Creating Objects 可以通过对象字面量，new关键字和Object.create()函数创建对象。创建一个对象最简单的方式是在代码中直接使用对象字面量。
对象字面量是一个以逗号分隔的列表，其中包含以冒号分隔的name:value对，并用花括号括起来。属性名可以是标识符或字符串字面量（允许空字符串），属性值可以是任何表达式，表达式的值可能是基础值或对象值。
let empty = {}; let point = {x: 0, y: 0}; let p2 = {x: point.x, y: point.y &#43; 1}; let book = {  &amp;#34;main title&amp;#34;: &amp;#34;JavaScript&amp;#34;,  &amp;#34;sub-title&amp;#34;: &amp;#34;The Definitive Guide&amp;#34;,  for: &amp;#34;all audiences&amp;#34;,  author: {  firstname: &amp;#34;David&amp;#34;,  surname: &amp;#34;Flanagan&amp;#34;  } } 在对象字面量最后一个属性后面添加逗号是合法的，有些编程风格指南鼓励添加这些逗号，方便以后在对象字面量的末尾添加新属性时，不容易出现语法错误。
对象字面量是一个表达式，每次求值时会创建和初始化一个不同的对象。这意味着，同一个对象字面量如果出现在循环或出现在被重复调用的函数中时，可以创建多个不同的新对象。
Creating Objects with new 操作符new可以创建和初始化一个新对象。new关键字必须紧跟一个函数调用，这个跟在new后面的函数被称为构造器。下面是一些内置类型的构造器：
let o = new Object(); let a = new Array(); let d = new Date(); let r = new Map(); Prototypes 几乎每个对象都有一个与之关联的第二个对象，这个关联的第二个对象被称为原型。第一个对象继承原型的属性，通过字面量创建的对象都有同一个原型对象，可以使用Object.prototype引用这个原型对象。
使用new关键字和构造函数新创建的对象，是以构造函数的prototype属性值作为它们的原型。也就是说，使用new Object()创建的对象继承自Object.prototype，与通过{}创建的对象一样。
console.log(Object.prototype) 类似地，通过new Array()创建的对象以Array.prototype为原型，通过new Date()创建的对象是以Date.prototype为原型。
几乎所有对象都有原型，但只有少数对象有prototype属性，正是这些有prototype属性的对象为所有其它对象定义了原型。
需要注意的是，Object.prototype是少有的没有原型的对象，它不继承任何属性。其它的原型对象都是普通的有原型的对象。多数内置构造器都有一个原型，这个原型继承自Object.prototype。
例如，Date.prototype继承了 Object.prototype的属性，因此通过new Date()创建的Date对象同时继承了Date.prototype和Object.prototype的属性。这种一系列关联的原型对象被称为原型链。
Object.create() 函数Object.create()用于创建一个新对象，使用第一个参数作为新对象的原型。
let o1 = Object.create({x: 1, y: 2}); console.log(o1.x &#43; o1.y)  // 执行结果 3 传入null可以创建一个没有原型的对象，但这样创建的新对象不会继承任何东西，连toString()这样的基本方法都没有。
let o2 = Object.create(null); // o2 inherits no props or methods. console.log(o2.toString()) // TypeError: o2.toString is not a function 如果想创建一个普通的空对象(类似于{}或new Object()创建的对象)，在调用函数Object.create()时传入Object.prototype即可:
let o3 = Object.create(Object.prototype); // o3 is like {} or new Object(). 创建具有任意原型的新对象的功能非常强大。Object.create()还有一个可选的第二个参数，用于描述新对象的属性。
方法Object.create()的一种用途是防止一个无法控制的库函数对对象进行意外（但非恶意）修改。与其将对象直接传递给这个库函数，不如传递一个继承自该对象的新对象。如果函数读取该对象的属性，就会看到继承的值。但是，如果函数设置属性，这些写入不会影响原始的对象。
Querying and Setting Properties 如果要获取属性值，可以使用.或[]操作符。两个操作符左边都必须是一个值为对象的表达式，如果使用点操作符，右操作数必须是对象的属性名，而如果使用[]操作符，在方括号里的值必须是表达式，该表达式的值必须是字符串或能够转换为字符串或Symbol。
let author = book.author; // Get the &amp;#34;author&amp;#34; property of the book. let name = author.surname; // Get the &amp;#34;surname&amp;#34; property of the author. let title = book[&amp;#34;main title&amp;#34;]; // Get the &amp;#34;main title&amp;#34; property of the book. 如果要创建或设置一个属性，同样可以使用点或方括号操作符，只需要把它们放到赋值表达式=的左边：
book.edition = 7; // Create an &amp;#34;edition&amp;#34; property of book. book[&amp;#34;main title&amp;#34;] = &amp;#34;ECMAScript&amp;#34;; // Change the &amp;#34;main title&amp;#34; property. Objects As Associative Arrays 访问对象的属性，下面两个表达式返回同一个值。在第一种方式中，使用点和标识符。在第二种方式中，使用方括号和字符串：
object.property object[&amp;#34;property&amp;#34;] 第二种方式使用方括号和字符串，看起来像是访问数组，只不过是以字符串而不是数值作为索引。这种数组被称为关联数组（或散列，映射、字典），对象就是关联数组。
在C&#43;&#43;、Java以及其它类似强类型的语言中，对象只有固定数量的属性，属性名必须预先定义好。因为JavaScript是一种松散类型语言，可以为任何对象创建任意数量的属性。
使用方括号访问对象属性，属性名一般是通过字符串来表示的。因为字符串是一种数据类型，所以可以在程序运行时创建和修改。
let customer = {address0: 10, address1: 11, address2: 333, address3: 999} let addr = &amp;#34;&amp;#34;; for (let i = 0; i &amp;lt; 4; i&#43;&#43;) {  addr &#43;= customer[`address${i}`] &#43; &amp;#34;\n&amp;#34;; } console.log(addr)  // 执行结果 10 11 333 999 Inheritance 假设从对象o中查询属性x，如果o没有这个名字的自有属性，则会从o的原型对象查询属性x。如果原型对象也没有这个叫x的自有属性，但它又有自己的原型，则会继续查询这个原型的原型。这个过程会一直持续，直到找到属性x，或者查到一个对象的原型为null为止。
let o = {}; o.x = 1; let p = Object.create(o); p.y = 2; let q = Object.create(p); q.z = 3; let f = q.toString(); console.log(f) // [object Object] console.log(q.x &#43; q.y) // 3 假设要为对象o的属性x赋值，如果对象o已经有了x这个自有属性，那么赋值就是简单地修改这个已存在的属性值。否则，赋值语句会创建一个名为x的属性，如果o已经继承了属性x，那么这个新创建的属性x就会隐藏继承的同名属性x。
属性赋值时检查原型链，只是为了确定当前赋值是否合法，如果o继承了一个只读属性x，那么赋值就是不允许的。如果赋值是允许的，则会新建属性或修改已存在的自有属性的值，不会修改原型链中的对象属性。
在查询属性时会发生继承，而在设置属性时不会发生继承，这是JavaScript的一个关键特性，因为它允许我们有选择性地覆盖继承的属性：
let unitcircle = {r: 1}; let c = Object.create(unitcircle); c.x = 1; c.y = 2; c.r = 2; console.log(unitcircle.r) // 1 属性赋值要么失败，要么在原对象中创建或设置一个已存在的属性。但有一个例外，如果对象o继承了属性x，但这个属性是通过setter方法来访问的，那么此时会调用setter方法，而不是创建一个新的属性x。需要注意的是，setter方法调用是在对象o上，而不是原型对象上定义的属性。因此，如果在setter方法中定义了任何属性，那么就是在o上定义，而不会对原型链上对象有任何影响。
Property Access Errors 需要注意的是，查询对象不存在的属性不会报错，如果在对象的自有属性或继承属性都没找到属性x，则属性表达式访问o.x的值为undefined。但是，查询不存在对象的属性是会报错的，因为null和undefined的值没有属性，查询这两个值的属性是错误的。
let len = book.subtitle.length; // Uncaught TypeError: Cannot read properties of undefined (reading &amp;#39;length&amp;#39;) ES2020通过?.支持条件式属性访问，用它可以把前面的赋值表达式改成如下形式：
let surname = book?.author?.surname; 如果尝试在null或undefined上设置属性也会导致TypeError错误。尝试在对象o上设置属性p，在以下情况均会失败：
 对象o有一个只读自有属性p，不能设置只读属性。 对象o有一个只读继承属性p，不能用同名自有属性隐藏该只读属性。 对象o没有自有属性p，o也没有通过setter方法继承属性p，并且o的extensible属性值是fasle。这是因为p在o上不存在，如果没有要调用的setter方法，那么p必须要添加到o上。但因为o是不可扩展的，所以不能在它上面定义新属性。  Deleting Properties 操作符delete用于从对象中移除属性。它唯一的操作数应该是一个属性访问表达式。需要注意的是，delete并不操作属性的值，而是操作属性本身。
delete book.author; delete book[&amp;#34;main title&amp;#34;]; 操作符delete只删除自有属性，不删除继承属性。如果要删除继承来的属性，必须从定义属性的原型对象上删除，但这样做会影响继承该原型的所有对象。
如果delete操作成功或操作没有影响（如不能删除不存在的属性），则delete表达式的结果为true。对非属性表达式使用delete，同样也会求值为true。
操作符delete不会删除configurable属性值为false的属性。内置对象的某些属性是不可configurable的，与使用变量或函数声明创建的全局对象的属性一样也是不可配置的。
在严格模式下，尝试删除不可配置的属性会导致TypeError。在非严格模式下，尝试删除不可配置的属性，直接返回false。
// In strict mode, all these deletions throw TypeError instead of returning false delete Object.prototype // =&amp;gt; false: property is non-configurable var x = 1; delete globalThis.x // =&amp;gt; false: can&amp;#39;t delete this property function f() {} // Declare a global function delete globalThis.f // =&amp;gt; false: can&amp;#39;t delete this property either 在非严格模式下，删除全局对象configurable为true的属性时，可以省略对全局对象的引用，只在delete操作符后面加上属性名：
globalThis.x = 1; // Create a configurable global property (no let or var) delete x // =&amp;gt; true: this property can be deleted 在严格模式下，如果delete的操作数是类似x这样的非限定标识符，就会引发语法错误，必须写出完整的属性访问表达式：
globalThis.x = 1; // Create a configurable global property (no let or var) delete x // SyntaxError in strict mode delete globalThis.x; Testing Properties 检查对象是否有一个给定属性的名字，可以使用in操作符、hasOwnProperty()或propertyIsEnumerable()方法。操作符in要求左边是一个属性名字符串，右边是一个对象。如果对象有包含相应名字的自有属性或继承属性，都返回true。
let o = {}; o.x = 1; let p = Object.create(o); p.y = 2; let q = Object.create(p); q.z = 3; let f = q.toString(); console.log(q.x &#43; q.y) console.log(x in o) // false console.log(&amp;#34;x&amp;#34; in o, &amp;#34;toString&amp;#34; in o) // true true 而方法hasOwnProperty()用于测试对象是否存在某个自有属性，如果是继承属性，则返回false：
let o = { x: 1 }; o.hasOwnProperty(&amp;#34;x&amp;#34;) // =&amp;gt; true: o has an own property x o.hasOwnProperty(&amp;#34;y&amp;#34;) // =&amp;gt; false: o doesn&amp;#39;t have a property y o.hasOwnProperty(&amp;#34;toString&amp;#34;) // =&amp;gt; false: toString is an inherited property 而propertyIsEnumerable()方法重新定义了hasOwnProperty()测试。只有当指定的属性是自有属性且其enumerable属性为true时，才返回true。某些内置属性是不可枚举的（enumerable属性为false），使用常规的代码创建的属性都是可枚举的，除非使用相关技术将它们限制为不可枚举的。
let o = {x: 1}; o.hasOwnProperty(&amp;#34;x&amp;#34;) // =&amp;gt; true: o has an own enumerable property x o.propertyIsEnumerable(&amp;#34;toString&amp;#34;) // =&amp;gt; false: not an own property Object.prototype.propertyIsEnumerable(&amp;#34;toString&amp;#34;) // =&amp;gt; false: not enumerable  // 执行结果 true false false 一般情况，只需查询属性并使用!==来确保它不是underfined的，而无需使用in操作符：
let o = {x: 1}; console.log(o.x !== undefined, o.y !== undefined, o.toString !== undefined) 但有一件事in操作符可以做，而简单的属性访问判断做不到。操作符in可以区分不存在的属性和存在但设置为undefind的属性：
let o = {x: undefined}; // Property is explicitly set to undefined o.x !== undefined // =&amp;gt; false: property exists but is undefined o.y !== undefined // =&amp;gt; false: property doesn&amp;#39;t even exist &amp;#34;x&amp;#34; in o // =&amp;gt; true: the property exists &amp;#34;y&amp;#34; in o // =&amp;gt; false: the property doesn&amp;#39;t exist delete o.x; // Delete the property x &amp;#34;x&amp;#34; in o // =&amp;gt; false: it doesn&amp;#39;t exist anymore Enumerating Properties 有时，并不想测试单个属性是否存在，而是想遍历或获取对象所有属性列表。有几种不同的方法可以做到这一点。前面介绍的for/in循环可以遍历特定对象的每个可枚举（自有或继承）属性。对象继承的内置方法是不可枚举的，代码添加的属性默认是可枚举的：
let o = {x: 1, y: 2, z: 3}; console.log(o.propertyIsEnumerable(&amp;#34;toString&amp;#34;)) // false for (let p in o) {  console.log(p); }  // 执行结果 false x y z 为了防止通过for/in枚举继承的属性，可以在循环体内添加hasOwnProperty进行过滤：
let o = {x: 1, y: 2, z: 3}; console.log(o.propertyIsEnumerable(&amp;#34;toString&amp;#34;)) // false for (let p in o) {  if (o.hasOwnProperty(p)) {  console.log(p);  } }  // 执行结果 false x y z 有4个函数可以用来获取属性名数组：
 Object.keys()返回对象可枚举自有属性名的数组。它不包含不可枚举属性、继承属性或符号属性。 Object.getOwnPropertyNames()返回自有属性名，包括不可枚举自有属性，只要属性名是字符串即可。 Object.getOwnPropertySymbols()返回所有自有Symbol属性，不管是否可枚举的。 Reflect.ownKeys()返回所有自有属性名，包括枚举和不可枚举，字符串或Symbol属性。  Property Enumeration Order ES6正式定义了枚举对象的自有属性顺序。Object.keys(), Object.getOwnPropertyNames(), Object.getOwnPropertySymbols(), Reflect.ownKeys(),JSON.stringify()等相关方法都按照下面顺序列出属性：
 首先列出名为非负整数字符串的属性，按照数值顺序从小到大。这条规则意味着数组和类数组对象的属性会按照顺序被枚举。 在列出类似数组索引的所有属性后，再列出剩余属性名为字符串的属性。这些属性按照他们被添加到对象的先后顺序列出。对于在对象字面量中定义的属性，按照它们在字面量中出现的顺序列出。 最后，符号属性将按其被添加到对象中的顺序列出来。  Extending Objects 在程序中，把一个对象的属性复制到另一个对象是很常见的，使用下面代码很容易做到：
let target = {x: 1}, source = {y: 2, z: 3}; for (let key of Object.keys(source)) {  target[key] = source[key]; } console.log(target) 因为这是一种常见操作，因此不同框架定义了不同的工具方法来执行这种操作，在ES6中，这种能力以Object.assign()的形式出现在了JavaScript核心中。
这个函数期望两个以上的参数，它修改并返回第一个参数（目标对象），不会修改第二个以及后续的参数（源对象）。对于每个待复制对象，会复制可枚举的自有属性（包括符号属性）。
Object.assign(o, defaults); // overwrites everything in o with defaults o = Object.assign({}, defaults, o); 使用扩展操作符...也可以表达这种对象复制和覆盖操作：
o = {...defaults, ...o}; 为了避免额外的创建和复制对象的开销，可以重写一版Object.assign()，只复制那些不存在的属性：
function merge(target, ...sources) {  for (let source of sources) {  for (let key of Object.keys(source)) {  // This is different than Object.assign()  if (!(key in target)) {  target[key] = source[key];  }  }  }  return target; }  Object.assign({x: 1}, {x: 2, y: 2}, {y: 3, z: 4}) // =&amp;gt; {x: 2, y: 3, z: 4} merge({x: 1}, {x: 2, y: 2}, {y: 3, z: 4}) // =&amp;gt; {x: 1, y: 2, z: 4} Serializing Objects 对象序列化是把对象转换为字符串的过程，之后可以将字符串恢复为对象。函数JSON.stringify()用于序列化对象，JSON.parse()用户恢复对象。
let o = {x: 1, y: {z: [false, null, &amp;#34;&amp;#34;]}}; // Define a test object let s = JSON.stringify(o); // s == &amp;#39;{&amp;#34;x&amp;#34;:1,&amp;#34;y&amp;#34;:{&amp;#34;z&amp;#34;:[false,null,&amp;#34;&amp;#34;]}}&amp;#39; let p = JSON.parse(s); console.log(s) console.log(p)  // 执行结果 {&amp;#34;x&amp;#34;:1,&amp;#34;y&amp;#34;:{&amp;#34;z&amp;#34;:[false,null,&amp;#34;&amp;#34;]}} { x: 1, y: { z: [ false, null, &amp;#39;&amp;#39; ] } } 函数JSON.stringify()只序列化对象可枚举的自有属性，如果属性值无法序列化，则该属性会从输出的字符串中删除。
Object Methods 所有对象（除了那些显式创建的没有原型的）都从Object.prototype继承属性，这些继承属性主要是方法。因为这些方法普遍可用的，所以程序员对它们很感兴趣。
例如，前面已经看到过的hasOwnProperty()和propertyIsEnumerable()方法，以及定义在Object构造函数上的静态方法，例如Object.create()和Object.keys()。
The toString() Method 方法toString()不接受参数，它返回一个字符串，以某种方式表示调用该方法的对象的值。只要在需要将对象转换为字符串的地方，就会调用对象的这个方法。例如，当使用&#43;运算符将字符串与对象连接起来时，或者当将对象传递给一个需要字符串的方法时。
let s = {x: 1, y: 1}.toString(); // s == &amp;#34;[object Object]&amp;#34; console.log(s) 由于这个默认的方法不会显示太有用的信息，很多类都会重新定义自己的toString()方法：
let point = {  x: 1, y: 2, toString: function () {  return `(${this.x}, ${this.y})`;  } }; console.log(String(point)) // =&amp;gt; &amp;#34;(1, 2)&amp;#34;: toString() is used for string conversions The valueOf() Method 方法valueOf()和toString()类似，它是在一个对象需要转换为除了字符串的其它基础类型值时使用。如果在需要基础类型的地方传入了一个对象，则valueOf()会被自动调用。
默认的valueOf()方法没有做什么，因此一些内置类定义了自己的valueOf()方法。Date类的valueOf()方法将日期转换为数字，因此可以使用&amp;lt;和&amp;gt;进行比较。
let point = {  x: 3, y: 4, valueOf: function () {  return Math.hypot(this.x, this.y);  } }; console.log(Number(point)) The toJSON() Method 实际上Object.prototype并没有定义toJSON()方法，但方法JSON.stringify()会从待序列化的对象中寻找toJSON()方法，如果待序列化的对象有这个toJSON()方法，就会调用它。
let point = {  x: 1, y: 2, toString: function () {  return `(${this.x}, ${this.y})`;  }, toJSON: function () {  return this.toString();  } }; console.log(JSON.stringify([point])) // =&amp;gt; &amp;#39;[&amp;#34;(1, 2)&amp;#34;]&amp;#39; Extended Object Literal Syntax 最近的几个JavaScript版本扩展了字面量语法。假设变量x和y中保存着值，而想创建一个具有属性x和属性y，并且值也是x和y。如果使用基本的对象字面量语法，则需要把每个标识符重复两次：
let x = 1, y = 2; let o = {  x: x, y: y }; console.log(o)  // 执行结果 { x: 1, y: 2 } 在ES6及之后，可以删掉其中的冒号和重复的标识符，得到非常简洁的代码：
let x = 1, y = 2; let o = {x, y}; console.log(o.x &#43; o.y) // 3 Computed Property Names 有时候属性的名字不是在编译时可以直接写在源代码中的常量，这个属性名是保存在一个变量或者通过函数调用而得到。不能对这种属性使用基本字面量，必须先创建一个对象，然后再添加这种属性。
const PROPERTY_NAME = &amp;#34;p1&amp;#34;; function computePropertyName() {  return &amp;#34;p&amp;#34; &#43; 2; } let o = {}; o[PROPERTY_NAME] = 1; o[computePropertyName()] = 2; 使用ES6的计算属性特性可以直接使用字面量创建对象：
const PROPERTY_NAME = &amp;#34;p1&amp;#34;; function computePropertyName() {  return &amp;#34;p&amp;#34; &#43; 2; } let p = {  [PROPERTY_NAME]: 1, [computePropertyName()]: 2 }; console.log(p) 有了这个语法，就可以在方括号中加入任意表达式，这个表达式的值（必要时转换为字符串）会被用作属性的名字。
Symbols as Property Names 计算属性语法也让另一个非常重要的字面量特性成为可能。在ES6及以后，属性名可以是字符串或Symbol。如果赋值Symbol给一个变量或常量，可以使用计算属性语法将该Symbol作为属性名。
const extension = Symbol(&amp;#34;my extension symbol&amp;#34;); let o = {  [extension]: { /* extension data stored in this object */} }; o[extension].x = 0; // This won&amp;#39;t conflict with other properties of o 符号是不透明值，除了用作属性名之外，不能用它们作任何事情。每个Symbol都与其它Symbol不同，这意味着Symbol非常适合用于创建唯一属性名。
Spread Operator 在ES2018后，可以在对象字面量中使用扩展操作符...把已有对象的属性复制到新对象中:
let position = {x: 0, y: 0}; let dimensions = {width: 100, height: 75}; let rect = {...position, ...dimensions}; console.log(rect.x &#43; rect.y &#43; rect.width &#43; rect.height) // 175 需要注意的是这个...语法经常被称为展开操作符，但它却不是真正意义上的操作符。实际上，它是仅在对象字面量中有效的一种特殊语法（在其它上下文中，三个点有其它用途，但只有在对象字面的上下文中，三点才会将一个对象插值到另一个对象中）。
需要注意的是，如果扩展对象和被扩展对象有一个同名属性，那么这个属性的值由后面的对象决定：
let o = { x: 1 }; let p = { x: 0, ...o }; console.log(p) // { x: 1 }  p.x // =&amp;gt; 1: the value from object o overrides the initial value  let q = { ...o, x: 2 }; console.log(q) // { x: 2 }  q.x // =&amp;gt; 2: the value 2 overrides the previous value from o. 另外要注意，展开操作符只展开对象的自有属性，不扩展任何继承属性：
let o = Object.create({x: 1}); // o inherits the property x let p = { ...o }; console.log(p) // {}  p.x // =&amp;gt; undefined 需要注意的是，虽然展开操作符只有3个圆点，但它可能给解释器带来巨大工作量。如果对象有n个属性，把这些属性展开到另一个对象的时间复杂度可能是$O(n)$。
这意味着，如果在循环或递归函数中使用展开操作符向一个的大对象不断追加属性时，很可能使得时间复杂度变为$O(n^2)$。
Shorthand Methods 把函数定义成一个对象的属性时，这个函数被称为方法。在ES6以前，需要像定义对象的其他属性一样，通过函数定义表达式在对象字面量定义一个方法。
let square = {  area: function () {  return this.side * this.side;  }, side: 10 }; console.log(square.area()) // 100 但在ES6中，对象字面量语法经过扩展，允许一种省略function关键字和冒号的的简写方法：
let square = {  area() {  return this.side * this.side;  }, side: 10 }; console.log(square.area()) // 100 Property Getters and Setters 目前讨论的所有属性都是数据属性，一个属性名和普通值。除了数据属性，还支持为对象定义访问器属性，这种属性不是一个值，而是一个或者两个访问器方法，一个getter方法和一个setter方法。
如果一个属性既有getter方法又有setter方法，它就是一个读写属性。如果只有一个getter方法，它就是一个只读属性。如果只有一个setter方法，那它就是一个只写属性。如果试图读取只写属性，会得到undefined。
访问属性可以通过对象字面语法的扩展来定义（与我们在这里看到的其他ES6扩展不同，getters和setters是在ES5中引入的）：
let o = {  // An ordinary data property  dataProp: value,  // An accessor property defined as a pair of functions.  get accessorProp() {  return this.dataProp;  },  set accessorProp(value) {  this.dataProp = value;  } }; 访问属性是通过一个或两个方法来定义的，方法名是属性名。除了前缀get和set，这两个方法看起来就像是用ES6简写的语法定义的普通方法一样。
let p = {  // x and y are regular read-write data properties.  x: 1.0, y: 1.0,  // r is a read-write accessor property with getter and setter.  // Don&amp;#39;t forget to put a comma after accessor methods.  get r() {  return Math.hypot(this.x, this.y);  },  set r(newvalue) {  let oldvalue = Math.hypot(this.x, this.y);  let ratio = newvalue / oldvalue;  this.x *= ratio;  this.y *= ratio;  },  // theta is a read-only accessor property with getter only.  get theta() {  return Math.atan2(this.y, this.x);  } }; console.log(p.r) // 1.4142135623730951 console.log(p.theta) // 0.7853981633974483 上面示例中使用了this关键字，表示当前对象。访问属性也是可以被继承的，可以把上面定义的对象p作为其他对象的原型。
// A new object that inherits getters and setters let q = Object.create(p); q.x = 3; // Create q&amp;#39;s own data properties q.y = 4; console.log(q.r) // 5.0 console.log(q.theta) // 0.9272952180016122 Chapter 7 数组是值的有序集合，其中的值叫做元素，每个元素有一个数值表示的位置，叫做索引。JavaScript的数组元素是无类型限制的，即同一数组中的元素可以是任意类型。也就是说，同一个数组中的元素可能有不同的类型。
JavaScript的数组是动态的，它们会按需增长或减少，因此创建数组时无须声明一个固定大小，也无须在大小变化时重新为它们分配空间。
数组可以是稀疏的，即数组中的元素不一定具有连续的索引，中间可能有间隙。每个数组都有length属性。对于非稀疏数组，这个属性保存数组中元素的个数，对于稀疏数组，这个属性值大于数组中元素个数。
数组是一种特殊的对象，数组索引更像是属性名，只不过恰巧是整数而已。在实现时通常会对数组进行特别优化，从而使得通过数值索引访问的数组元素明显快于访问常规的对象属性。
ES6增加了一批新的数组类，被称为定型数组。定型数组具有固定长度和固定的元素类型，数组具有极高的性能，支持对二进制数据的字节级访问。
Creating Arrays 创建数组有以下几种方式：
 数组字面量。 可迭代对象使用展开操作符。 Array()构造器。 工厂方法Array.of()和Array.from()  Array Literals 创建数组最简单的方式是数组字面量，数组字面量只是在方括号中简单地以逗号分隔每个元素。
let emptyArr = []; // An array with no elements let primes = [2, 3, 5, 7, 11]; // An array with 5 numeric elements let misc = [1.1, true, &amp;#34;a&amp;#34;,]; // 3 elements of various types &#43; trailing comma console.log(emptyArr, primes, misc)  // 执行结果 [] [ 2, 3, 5, 7, 11 ] [ 1.1, true, &amp;#39;a&amp;#39; ] 数组字面量中的元素不必一定是常量，可以是任意表达式：
let base = 1024; let table = [base, base &#43; 1, base &#43; 2, base &#43; 3]; console.log(table)  // 执行结果 [ 1024, 1025, 1026, 1027 ] 数组字面量可以包含对象字面量或其它数组字面量：
let b = [[1, {x: 1, y: 2}], [2, {x: 3, y: 4}]]; console.log(b)  // 执行结果 [ [ 1, { x: 1, y: 2 } ], [ 2, { x: 3, y: 4 } ] ] 如果一个数组字面量在一行中包含多个连续逗号，且两个连续逗号中间没有值，那么这个数组就是稀疏的。省略了值的数组元素并不存在，在查询时结果为undefined：
let count = [1, , 3]; // Elements at indexes 0 and 2. No element at index 1 let undefs = [, ,]; // An array with no elements but a length of 2 console.log(count,undefs[0], undefs[1])  // 执行结果 [ 1, &amp;lt;1 empty item&amp;gt;, 3 ] undefined undefined 数组字面量允许可选的尾逗号，因此数组字面量[,,]的长度(length属性)为2，而不是3。
console.log([, ,].length) // 2 The Spread Operator 从ES6开始，可以使用展开操作符...（不是一个真正的运算符）能将一个数组的所有元素包含在一个数组字面量中，如下所示：
let aa = [1, 2, 3]; let ab = [0, ...aa, 4]; // ab === [0, 1, 2, 3, 4] console.log(aa, ab, aa.length, ab.length)  // 打印的值 [1, 2, 3] [0, 1, 2, 3, 4] 3 5   let a1 = [1, [2, 3]]; let ab1 = [0, ...a1, 4]; // b === [0, 1, 2, 3, 4] console.log(a1, ab1, a1.length, ab1.length) // ab1 === [0, [1,2,3], 4] 上面3个点会展开数组a，它所有的元素成为正在创建的数组字面量中的元素。也就是...a被数组a中的所有元素所替代，并作为外层数组字面量的一部分被列出。
请注意，虽然将这3个点称为展开运算符，但它并不是一个真正的运算符，因为它只能用于数组字面量和函数调用。展开操作符是一种便捷的方式创建数组的副本：
let original = [1, 2, 3]; let copy = [...original]; let copy1 = original; copy[0] = 0; // Modifying the copy does not change the original console.log(original[0], copy[0], original === copy, copy1 === original) // 1 0 false true  // 执行结果 1 0 false true 实际上，展开操作符对于所有可迭代的对象都是可用的。字符串是可迭代的，因此可以使用展开操作符将字符串转换为字符数组：
let digits = [...&amp;#34;0123456789ABCDEF&amp;#34;]; console.log(digits)  // 执行结果 [&amp;#34;0&amp;#34;, &amp;#34;1&amp;#34;, &amp;#34;2&amp;#34;, &amp;#34;3&amp;#34;, &amp;#34;4&amp;#34;, &amp;#34;5&amp;#34;, &amp;#34;6&amp;#34;, &amp;#34;7&amp;#34;, &amp;#34;8&amp;#34;, &amp;#34;9&amp;#34;, &amp;#34;A&amp;#34;, &amp;#34;B&amp;#34;, &amp;#34;C&amp;#34;, &amp;#34;D&amp;#34;, &amp;#34;E&amp;#34;, &amp;#34;F&amp;#34;] 集合对象是可迭代的，因此移除数组中重复元素的一种简单方式是将数组先转换为集合，然后使用展开操作符将集合转换回数组：
let letters = [...&amp;#34;hello world&amp;#34;]; // 字符串展开为数组 console.log([...new Set(letters)]) // 数组转换为集合  // 执行结果 [&amp;#34;h&amp;#34;, &amp;#34;e&amp;#34;, &amp;#34;l&amp;#34;, &amp;#34;o&amp;#34;, &amp;#34; &amp;#34;, &amp;#34;w&amp;#34;, &amp;#34;r&amp;#34;, &amp;#34;d&amp;#34;] The Array() Constructor 另一种创建数组的方式是使用Array()构造器，我们能以三种不同方式调用Array构造器。第一种方式是调用构造器的时候不传任何参数：
let a = new Array(); 这种方式创建了一个空数组，里面没有任何元素，等同于数组字面量[]。第二种方式是调用构造器时传入一个数值参数，以指定数组的长度：
let a = new Array(10); console.log(a.length) // 10 这种方式创建了一个指定长度的数组。如果事先知道需要多少元素，这种形式可用于预分配数组。但需要注意的是，数组中不会存储任何值，甚至没有为数组定义数组索引属性。
let a = new Array(10); console.log(a.length) console.log(a[0])  // 执行结果 10 undefined 第三种方式是为数组明确指定两个或多个数组元素或一个非数字元素。在这种方式下，构造器的所有参数都成为了新数组的中的元素：
let a1 = new Array(5, 4, 3, 2, 1, &amp;#34;testing, testing&amp;#34;); let a2 = new Array(&amp;#34;element&amp;#34;) console.log(a1) console.log(a2)  // 打印的结果 [5, 4, 3, 2, 1, &amp;#34;testing, testing&amp;#34;] [&amp;#34;element&amp;#34;] Array.of() 当Array()构造器使用一个数字参数调用时，这个数字表示数组长度。但当多于一个参数调用Array()构造器时，它将这些传入的参数当成数组元素。这意味着Array()构造器不能创建只包含单个数值元素的数组。
在ES6，函数Array.of()能够解决这个问题，它是一个工厂方法，以其所有参数值（不管有多少个）创建和返回一个新的数组：
Array.of() // =&amp;gt; []; returns empty array with no arguments Array.of(10)// =&amp;gt; [10]; can create arrays with a single numeric argument Array.of(1, 2, 3) // =&amp;gt; [1, 2, 3] Array.from() 另一个数组工厂方法是ES6引入的，它期望一个可迭代的或类数组对象作为它的第一个参数并返回一个新的数组，这个新生成的数组包含了传入对象的所有元素。对于可迭代的参数，Array.from(iterable)的作用如同3个点展开操作符[...iterable]。
let copy = Array.from(original); Array.from()同样重要，因为它定义了一种为类数组对象创建真正数组副本的方法。类数组对象是具长度属性的非数组对象，其存储值的属性名称恰好是整数。某些网络浏览器方法的返回值是类数组对象，如果先将它们转换为真数组，处理起来会更容易：
let trueArr = Array.from(arraylike); 工厂方法Array.from()接受第二个可选的参数，如果传递函数作为第二个参数，那么在构建新数组时，原对象中的每个元素都将传递给这个指定的函数，函数的返回值将存储在新数组中。
Reading and Writing Array Elements 访问数组中的某个元素使用操作符[]，数组的引用应出现在方括号的左侧。方括号内应是一个值为非负整数的任意表达式，可以使用这种语法读取和写入数组元素的值。
let a = [&amp;#34;world&amp;#34;]; let value = a[0]; a[1] = 3.14; let i = 2; a[i] = 3; a[i &#43; 1] = &amp;#34;hello&amp;#34;; console.log(a[3]) // hello a[a[i]] = a[0]; console.log(a.length, a[3]) // 4 world 数组的特殊之处在于，当使用的属性名是小于$2^{32}-1$的非负整数时，会自动维护数组长度属性的值。例如，在上面代码中，创建了只有一个元素的数组a。然后在索引1、2和3处赋值，数组的length属性也会随之改变:
a.length // =&amp;gt; 4 数组是特殊类型的对象，访问数组元素时使用的方括号与访问对象属性时使用的方括号作用相同。JavaScript会将数字索引转换为字符串，然后使用该字符串作为属性名称。将索引从数值转换为字符串并没有什么特别之处，普通对象也可以这样做：
let o2 = {};// Create a plain object o2[1] = &amp;#34;one&amp;#34;; // Index it with an integer o2[&amp;#34;1&amp;#34;] // =&amp;gt; &amp;#34;one&amp;#34;; 数值和字符串属性是一样的 console.log(o2[&amp;#34;1&amp;#34;]) // one 明确区分数组索引和对象属性名称是很有帮助的。所有索引都是属性名，但只有0到$2^{32}-2$之间的整数属性名才是索引。所有数组都是对象，可以在数组上创建任意名称的属性。但是，如果使用的属性是数组索引，那么数组就会根据需要更新其length属性。
需要注意的是，可以使用负数或非整数的数值为数组建立&amp;quot;索引&amp;quot;。这样做时，数值会先被转换为字符串，字符串被用作属性名称。由于转换成字符串后该名称不是非负整数，因此会被视为常规对象属性，而不是数组索引。同样，如果在数组中使用一个恰好是非负整数的字符串作为属性，它将被视为数组索引，而不是对象属性。使用与整数相同的浮点数也是如此：
a[-1.23] = true; // This creates a property named &amp;#34;-1.23&amp;#34; 当成普通的属性 a[&amp;#34;1000&amp;#34;] = 0; // This the 1001st element of the array a[1.000] = 1; // Array index 1. Same as a[1] = 1; 事实上，数组索引只是对象属性名称的一种特殊类型，这意味着数组没有out of bounds错误的概念。当尝试查询对象的一个不存在的属性时，不会出现错误，只会返回undefined，这一点对于数组和对象都是一样的：
let a = [true, false]; // This array has elements at indexes 0 and 1 a[2] // =&amp;gt; undefined; no element at this index. a[-1] // =&amp;gt; undefined; no property with this name. Sparse Arrays 稀疏数组是指元素没有从0开始的连续索引的数组。 通常，数组的length属性表示数组中元素的个数。如果数组是稀疏的，则length属性的值会大于所有元素个数。稀疏数组可以通过Array()构造函数创建，也可以通过赋值给一个大于当前数组长度的数组索引来创建。
let a = new Array(5); // No elements, but a.length is 5. b = []; // Create an array with no elements and length = 0. b[1000] = 0; // Assignment adds one element but sets length to 1001. console.log(b.length) // 1001 与密集数组相比，足够稀疏的数组通常以更慢、更节省内存的方式实现，在这样的数组中查找元素所需的时间与普通对象属性查找的时间差不多。
需要注意的是，在数组字面量中省略一个值（使用连续重复的逗号，例如[1,,3]），得到的数组就是稀疏的，省略的元素根本不存在的:
let a1 = [,]; let a2 = [undefined]; // 属性值判断 console.log(0 in a1, 0 in a2) // false true 了解稀疏数组是理解数组本质的重要部分。不过，在实际工作中，大多数数组都不是稀疏数组。而且，如果确实需要使用稀疏数组，代码中很可能会像处理undefined元素的非稀疏数组一样处理它。
Array Length 每个数组都有一个length属性，正是这个属性使得数组和普通的对象不同。对于密集数组（即非稀疏数组），length属性指定数组中的元素个数，其值比数组中的最高索引大一：
console.log([].length, [&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;].length) // 0 3 当一个数组是稀疏数组，其属性length的值大于数组中的元素个数。一个数组（无论是否稀疏）永远不会有索引大于或等于长度的元素。为了保持这种不变性，数组有两种特殊的行为。第一种行为：如果索引i大于或等于数组当前长度的数组元素赋值，则length属性的值将被设置为i&#43;1。
数组为保持长度不变而实施的第二个特殊行为是，如果将length属性设置为一个小于其当前值的非负整数n，则任何索引大于或等于n的数组元素都会从数组中删除：
a = [1,2,3,4,5]; // Start with a 5-element array. a.length = 3; // a is now [1,2,3]. console.log(a) // [1,2,3] a.length = 0; // Delete all elements. a is []. console.log(a) // [] a.length = 5; // Length is 5, but no elements, like new Array(5) console.log(a) // [] Adding and Deleting Array Elements 添加数组元素最简单的方式是赋值给新的索引：
let a = []; // Start with an empty array. a[0] = &amp;#34;zero&amp;#34;; a[1] = &amp;#34;one&amp;#34;;  // 执行结果 [ &amp;#39;zero&amp;#39;, &amp;#39;one&amp;#39; ] 也可以使用push方法添加一个或多个元素到数组尾部：
let a = []; a.push(&amp;#34;zero&amp;#34;) a.push(&amp;#34;one&amp;#34;, &amp;#34;two&amp;#34;) console.log(a) // [&amp;#34;zero&amp;#34;, &amp;#34;one&amp;#34;, &amp;#34;two&amp;#34;] 当push一个元素到数组a中，相当于赋值到a[a.length]。也可以使用unshift()方法将值插入到数组开头，并移动已经存在的元素到更高的索引。
let a = []; a.push(&amp;#34;zero&amp;#34;) a.push(&amp;#34;one&amp;#34;, &amp;#34;two&amp;#34;) a.unshift(&amp;#34;-1&amp;#34;) console.log(a)  // 执行结果 [ &amp;#39;-1&amp;#39;, &amp;#39;zero&amp;#39;, &amp;#39;one&amp;#39;, &amp;#39;two&amp;#39; ] 方法pop()移除数组的最后一个元素，并返回它，数组元素长度会减1。相似地，shift()方法移除第一个元素，并将数组长度减1，其它元素往前移动。
let a = []; a.push(&amp;#34;zero&amp;#34;) a.push(&amp;#34;one&amp;#34;, &amp;#34;two&amp;#34;) // [&amp;#34;zero&amp;#34;, &amp;#34;one&amp;#34;] a.shift() console.log(a) // [&amp;#39;one&amp;#39;, &amp;#39;two&amp;#39;] let b = a.pop() // 移除最后一个元素 console.log(b) // two console.log(a) // [&amp;#39;one&amp;#39;] 可以使用操作符delete删除数组中的元素，但既不会改变数组长度，也不会将索引较高的元素向下移动以填补删除属性留下的空隙。如果从数组中删除一个元素，数组就会变成稀疏数组。
let a = [1,2,3]; delete a[2]; // a now has no element at index 2 2 in a // =&amp;gt; false: no array index 2 is defined a.length // =&amp;gt; 3: delete does not affect array length 如上所述，只需将length属性设置为所需的新长度，就可以从数组末尾删除元素。最后，方法splice()是插入、删除或替换数组元素的通用方法。它可以改变长度属性，并根据需要将数组元素移到更高或更低的索引中。
Iterating Arrays 从 ES6开始，遍历数组（或任何可迭代对象）中每个元素的最简单方法是使用for/of循环：
let letters = [...&amp;#34;Hello world&amp;#34;]; let string = &amp;#34;&amp;#34;; for (const letter of letters) {  string &#43;= letter; } console.log(string) // Hello world 循环for/of使用的内置数组迭代器会按索引升序返回数组元素。对于稀疏数组，迭代器没有特殊行为，对于不存在的数组元素，迭代器会简单地返回undefined。
如果想要对数组使用for/of循环，并需要知道数组每个元素的索引，可以使用数组的entries()方法并解构赋值，就像下面这样：
let letters = [...&amp;#34;Hello world&amp;#34;]; let string = &amp;#34;&amp;#34;; for (let letter of letters) {  string &#43;= letter; } console.log(string) // =&amp;gt; &amp;#34;Hello world&amp;#34; let everyOther = &amp;#34;&amp;#34;; for (let [index, letter] of letters.entries()) {  if (index % 2 === 0) everyOther &#43;= letter; } console.log(everyOther) // =&amp;gt; &amp;#34;Hlowrd&amp;#34; 另一种迭代数组的方式是forEach()。这不是for循环的新形式，而是一种数组方法，提供了一种数组迭代的功能性方法。可以向数组的forEach()方法传递一个函数，然后forEach()会在数组的每个元素上调用一次这个传入的函数：
let uppercase = &amp;#34;&amp;#34;; letters.forEach(letter =&amp;gt; { // Note arrow function syntax here  uppercase &#43;= letter.toUpperCase(); }); console.log(uppercase) // HELLO WORLD 正如我们期待的，forEach()按照顺序迭代数组，它实际上将数组的索引传递到传入的函数中作为第二个参数，这在某些情况下是很有用的。与for/of循环不同，循环forEach()能识别稀疏数组，不会调用函数来处理不存在的元素。
也可以使用老式的for循环来遍历数组中的元素：
let vowels = &amp;#34;&amp;#34;; for (let i = 0; i &amp;lt; letters.length; i&#43;&#43;) { // For each index in the array // Get the element at that index  let letter = letters[i];  if (/[aeiou]/.test(letter)) { // Use a regular expression test  vowels &#43;= letter;  } } console.log(vowels) // eoo 在嵌套循环或其它对性能要求较高的情况下，有时会看到这种基本数组迭代循环的写法，即数组长度只查询一次，而不是每次迭代都查询。以下两种for循环形式都是惯用的，但并不常见，而且在现代解释器中，它们对性能的影响也不明显：
// 减少数组长度只查询一次 for (let i = 0, len = letters.length; i &amp;lt; len; i&#43;&#43;) {  // loop body remains the same }  // Iterate backwards from the end of the array to the start for (let i = letters.length - 1; i &amp;gt;= 0; i--) {  // loop body remains the same } 上面这些例子假定数组是密集的，所有元素都包含有效数据。如果情况并非如此，则应在使用数组元素前对其进行测试。如果想跳过undefined的元素，可以像下面这样：
for (let i = 0; i &amp;lt; a.length; i&#43;&#43;) {  if (a[i] === undefined) continue; // Skip undefined &#43; nonexistent elements  // loop body here } Multidimensional Arrays JavaScript不支持真正的多维数组，但可以使用数组的数组来近似多维数组。要访问二维数组中的值，只需使用[]操作符两次即可。例如，假设变量matrix是一个数组，其中的每个元素matrix[x]是一个数组。
// Create a multidimensional array let table = new Array(10); // 10 rows of the table for (let i = 0; i &amp;lt; table.length; i&#43;&#43;) {  // Each row has 10 columns  table[i] = new Array(10); } // Initialize the array for (let row = 0; row &amp;lt; table.length; row&#43;&#43;) {  for (let col = 0; col &amp;lt; table[row].length; col&#43;&#43;) {  table[row][col] = row * col;  } } console.log(table[5][7]) // 35 Array Methods 迭代器方法用于遍历数组元素，通常对于其中的每个元素调用一次指定的函数。栈和队列方法用于在开头或末尾向数组中添加元素或从数组中删除元素。子数组方法用于提取、删除、插入、填充和复制更大数组的连续区域。搜索和排序方法用于在数组中查找元素和对数组元素进行排序。
Array Iterator Methods 方法forEach()用于迭代数组中的每个元素，并对每个元素调用一次指定的函数。传统的forEach()方法的第一个参数是函数。forEach在调用这个函数时会给它传3个参数：数组元素的值，数组元素的索引值和数组本身。如果只关注数组元素的值，可以把函数写成只接受一个参数，即忽略其它参数：
let data = [1, 2, 3, 4, 5], sum = 0; // Compute the sum of the elements of the array data.forEach(value =&amp;gt; {  sum &#43;= value; }); console.log(sum) // 15 // Now increment each array element data.forEach(function (v, i, a) {  a[i] = v &#43; 1; }); console.log(data) // [ 2, 3, 4, 5, 6 ] 需要注意的是，forEach()不提供提前终止循环的方式。换句话说，在这里没有与常规for循环中的break语句对等的机制。
方法map()把数组的每个元素分传递给指定的函数，返回这个函数的返回值构成的新数组。需要注意的是map返回一个新数组，不会改变调用它的数组。如果数组是稀疏的，则缺失的元素不会调用我们的函数，但返回的数组和原始数组一样稀疏，长度相同，缺失的元素也相同。
let a = [1, 2, 3]; console.log(a.map(x =&amp;gt; x * x)) // [1, 4, 9] 方法filter()返回一个数组，该数组包含调用它的数组的子数组。传给这个方法的函数应该是断言函数，即返回true和false的函数。如果函数返回true或返回的值能转换true，则该元素是新数组的元素。
let a = [5, 4, 3, 2, 1]; console.log(a.filter(x =&amp;gt; x &amp;lt; 3)) // =&amp;gt; [2, 1]; values less than 3 console.log(a.filter((x,i) =&amp;gt; i%2 === 0)) // =&amp;gt; [5, 3, 1]; every other value 需要注意的是，方法filter会跳过稀疏数组中缺失的元素，它返回的数组始终是稠密的。因此，可以使用filter方法清理掉稀疏数组中的空隙。
let dense = sparse.filter(() =&amp;gt; true); 如果既想清理稀疏数组中的空隙，又想删除值为undefined和null的元素，则可以像下面这样写：
a = a.filter(x =&amp;gt; x !== undefined &amp;amp;&amp;amp; x !== null); 方法find()和findIndex()与filter()类似，它们都遍历数组，寻找断言函数返回true的元素。但与filter()不同的是，这两个方法会在断言函数找到第一个元素时就停止。find()返回匹配的元素，findIndex()返回匹配元素的索引。如果没有找到匹配的元素，则find()返回undefinded，而findIndex返回-1。
方法every()和some()是数组断言方法，即它们会对数组元素调用传入的断言函数，最后返回true或false。every方法与数学上的全称量词类似，它只在断言函数对数组的所有元素都返回true才返回true。
let a = [1, 2, 3, 4, 5]; a.every(x =&amp;gt; x &amp;lt; 10) // true a.every(x =&amp;gt; x % 2 === 0) // =&amp;gt; false: not all values are even. 方法some()类似于数学上的存在量词，只要数组元素中有一个让断言函数返回true，它就返回true，但必须数组中的所有元素对断言函数都返回false才返回false。
let a = [1, 2, 3, 4, 5]; a.some(x =&amp;gt; x % 2 === 0) // =&amp;gt; true; a has some even numbers. a.some(isNaN) // =&amp;gt; false; a has no non-numbers. 方法reduce()和reduceRight()使用指定的函数归并数组元素，最终产生一个值。在函数式编程中，归并是一个常见操作，有时候也被称为inject或fold。
let a = [1, 2, 3, 4, 5]; let a1 = a.reduce((x, y) =&amp;gt; x &#43; y, 0) let a2 = a.reduce((x, y) =&amp;gt; x * y, 1) let a3 = a.reduce((x, y) =&amp;gt; (x &amp;gt; y) ? x : y) console.log(a1, a2, a3) // 15 120 5 方法reduce()接收两个参数，第一个参数是执行归并操作的函数。这个归并函数的任务就是把两个值组合或归并为一个值并返回这个值。第二个参数是可选的，是传递给归并函数的初始值。
在reduce()中使用函数与forEach()和map()中使用函数不同。我们熟悉的值、索引和数组本身在这里作为第二、第三和第四个参数，而第一个参数是上一次归并操作的结果值。在第一次调用归并方法时，第一个参数是调用reduce方法时传递的第二个参数，在后续的调用中，第一个参数是上一次调用的返回值。
如果不指定初始值，方法reduce()会使用数组的第一个元素作为初始值。这意味着首次调用归并函数将以数组的第一个和第二个元素作为归并函数的第一和第二个参数。
如果不传入初始值，在空数组上调用reduce()会导致TypeError。如果调用它时只有一个值，比如用只包含一个元素的数组调用且不传初始值，或者用空数组调用但传了初始值，则reudce()直接返回这个值，不会调用归并函数。
方法reduceRight()和reduce()类似，只不过是从高索引向低索引（从右向左）处理数组。如果归并操作具有从右向左的结合性，那就要考虑使用reduceRight()。
Flattening arrays with flat() and flatMap() 在ES2019中，flat()方法用于创建并返回一个新数组，这个新数组包含与它调用flat()数组相同的元素，只不过其中任何本身也是数组元素被打平，填充到返回的数组中。
[1, [2, 3]].flat(); // [ 1, 2, 3 ] [1, [2, [3]]].flat(); // [ 1, 2, [ 3 ] ] 在不传参数调用时，方法flat()只会打平第一级嵌套。原始数组中本身也是数组的元素会被打平，但打平后的元素如果还是数组则不会再打平。如果想打平更多层级，需要给flat()传一个数值参数，表示需要打平的层级：
let a = [1, [2, [3, [4]]] console.log(a.flat()) // =&amp;gt; [1, 2, [3, [4]]] console.log(a.flat(1)) // =&amp;gt; [1, 2, [3, [4]]] console.log(a.flat(2)) // =&amp;gt; [1, 2, 3, [4]] console.log(a.flat(3)) // =&amp;gt; [1, 2, 3, 4] console.log(a.flat(4)) // =&amp;gt; [1, 2, 3, 4] 方法flatMap()与map()相似，只不过返回的数组会自动被打平，就像传给了flat()一样。换句话说，调用a.flatMap(f)等同于a.map(f).flat()，但执行效率较高。
方法concat()创建并返回一个新数组，新数组包含调用concat()方法的数组的元素，以及传递给concat()的参数。如果这些参数中有数组，则拼接的是它们的元素而非数组本身。
let a = [1, 2, 3]; console.log(a.concat(4, 5)) // [ 1, 2, 3, 4, 5 ] console.log(a.concat([4, 5], [6, 7])) // [1, 2, 3, 4, 5, 6, 7] console.log(a.concat(4, [5, [6, 7]])) // [ 1, 2, 3, 4, 5, [ 6, 7 ] ] Chapter 8 JavaScript中的函数是对象，可以把函数赋值给变量，然后再传递给其它函数。因为函数是对象，所以可以在函数上设置属性，甚至调用函数的相关方法。
函数可以嵌套定义在其它函数里，内嵌的函数可以访问定义在函数作用域的任何变量。这意味着，函数是闭包，基于闭包可以实现重要且强大的编辑技巧。
Defining Functions 定义函数最直接的方式是使用function关键字，这个关键字既可以作为函数声明使用，也可以作为表达式使用。函数声明由function关键字后面跟着如下内容：
 命名函数的标识符。这个名字对于函数声明是必要的部分。它作为一个变量名使用，新定义的函数对象会赋值给这个变量。 一对圆括号，中间包含逗号分隔的零个或多个标识符。这些标识符是函数的参数名，它们就像是函数体内的局部变量。 一对花括号，其中包含了零个或多个语句。这些语句构成函数体，将在函数被调用时执行。  下面是一些函数声明的示例：
function printprops(o) {  for (let p in o) {  console.log(`${p}: ${o[p]}\n`);  } }  function distance(x1, y1, x2, y2) {  let dx = x2 - x1;  let dy = y2 - y1;  return Math.sqrt(dx * dx &#43; dy * dy); } 关于函数声明，需要重点注意的是，函数的名称会变成一个变量，其值就是函数本身。函数声明语句会被提升到包含enclosing script、函数或代码块的顶部。因此，可以在函数定义之前出现的代码中调用后面定义的函数。另一种说法是，代码块中声明的所有函数都将在整个代码块中起作用，即这些函数是在开始执行该代码块中的任何代码之前定义。
let dis = distance(1, 2, 3, 4) console.log(dis) function distance(x1, y1, x2, y2) {  let dx = x2 - x1;  let dy = y2 - y1;  return Math.sqrt(dx * dx &#43; dy * dy); } // 执行的结果 2.8284271247461903 语句return导致函数停止并将其表达式的值返回给调用者。如果return语句没有关联的表达式，则函数返回undefined。如果函数并不包含return语句，那么就简单地执行函数体内每个语句，直到最后返回undefined。
Function Expressions 函数表达式看起来像函数声明，但它们出现在复杂表达式或语句的上下文中，而且函数表达式中的函数名是可选的，以下是几个函数表达式的示例：
const square = function (x) {  return x * x; };  // 函数名是可选的，包含函数名对于递归十分有用 const f = function fact(x) {  if (x &amp;lt;= 1) return 1; else return x * fact(x - 1); };  // Function expressions can also be used as arguments to other functions: [3, 2, 1].sort(function (a, b) {  return a - b; });  // Function expressions are sometimes defined and immediately invoked let tensquared = (function (x) {  return x * x; }(10)); 需要注意的是，函数名对于定义为表达式的函数而言是可选，多数情况下函数表达式省略函数名。函数声明实际上是声明一个变量，然后把函数对象赋值给它。而函数表达式不会声明变量，至于要把新定义的函数对象赋值给一个常量还是变量取决于我们，最佳实践是使用const把函数表达式赋值给常量，这样就不会因赋值而意外覆盖函数。
函数是允许有名字的，像factorial函数，需要引用自己。如果一个函数表达式包含名字，则该函数的局部函数作用域将包含该函数名与函数对象的绑定。实际上，函数名变成了函数中的一个局部变量。大多数定义为表达式的函数都不需要名称，这使得它们的定义更加紧凑。
使用函数声明定义一个函数f()和将函数表达式赋值给变量f有重要区别。当使用函数声明的形式，函数对象会在包含它们的代码开始运行之前创建，定义会被前置，这样就可以在定义语句上方的代码中调用这些函数。
但是，定义为表达式的函数并非如此，这些函数在定义它们的表达式实际求值之前并不存在。此外，要调用一个函数，必须能够引用该函数，而以表达式定义的函数在赋值给变量之前是无法引用的，因此用表达式定义的函数在定义之前是无法调用的。
Arrow Functions 在ES6中，可以使用一种特别简洁的语法来定义函数，叫做箭头函数。因为箭头函数是表达式而不是语句，所以不必使用function关键字，而且也不需要函数名。
箭头函数的一般形式是圆括号中逗号分隔的参数列表，后面跟箭头=&amp;gt;，再跟包含在花括号中的函数体：
const sum = (x, y) =&amp;gt; { return x &#43; y; }; 如果函数体只有一个return语句，那么可以省略return语句、语句末尾的分号以及花括号，将函数体写成一个表达式，这个表达式的值将被返回：
const sum = (x, y) =&amp;gt; x &#43; y; 更进一步，如果箭头函数只有一个参数，也可以省略包含参数列表的圆括号：
const polynomial = x =&amp;gt; x*x &#43; 2*x &#43; 3; 需要注意的是，对于没有参数的箭头函数必须把空圆括号写出来。还要注意的是，在写箭头函数时，不能在函数参数和箭头之间放置换行符。
const constantFunc = () =&amp;gt; 42; 如果箭头函数的函数体是一个return语句，但要返回的表达式是对象字面量，则必须把这个对象字面量放在一对圆括号中，以避免解释器分不清花括号到底表示函数体还是对象字面量。
const f = x =&amp;gt; {  return {value: x}; // Good: f() returns an object }; const g = x =&amp;gt; ({value: x}); // Good: g() returns an object const h = x =&amp;gt; {  value: x // Bad: h() returns nothing }; const i = x =&amp;gt; {  v: x, w:x // Bad: Syntax Error }; 箭头函数与以其他方式定义的函数有一个关键区别：它们从定义它们的环境继承this关键字的值，而不是像以其他方式定义的函数那样定义自己的调用上下文。箭头函数与其他函数还有一个区别，就是它们没有prototype属性，这意味着箭头函数不能作为新类的构造函数。
在ES2020中，可以在函数表达式后面、左圆括号前面插入?.，从而只在函数不是null和undefined时调用函数。也就是说f?.(x)相当于下面语句：
(f !== null &amp;amp;&amp;amp; f !== undefined) ? f(x) : undefined Nested Functions 在JavaScript中，函数可以内嵌到其他函数中：
function hypotenuse(a, b) {  function square(x) {  return x * x;  }  return Math.sqrt(square(a) &#43; square(b)); } console.log(hypotenuse(12, 14)) 嵌套函数有趣之处在于其变量作用域规则：它们可以访问被嵌套函数（或多个函数）的参数和变量。例如，上面代码中内层函数square()可以读写外层函数hypotenuse()定义的参数a和b。嵌套函数的这些作用域规则非常重要。
Invoking Functions 构成函数主体的代码不是在定义函数时执行的，而是在调用函数时执行的，函数有五种调用方式：
 作为函数 作为方法 作为构造器 通过call()和apply()方法间接调用 通过语言特性，隐含地实现了与普通函数调用不同的功能  Function Invocation 函数可以作为普通函数调用，也可以使用调用表达式作为方法调用。调用表达式由一个求值为函数对象的表达式、一个左圆括号、一个以逗号分隔的零个或多个参数表达式列表和一个右圆括号组成。
如果函数表达式是属性访问表达式，即函数是对象的属性或数组的元素，那么它就是方法调用表达式。下面是常规的函数调用表达式：
printprops({x: 1}); let probability = factorial(5) / factorial(13); let total = distance(0, 0, 2, 1) &#43; distance(2, 1, 3, 5); 在调用过程中，每个参数表达式（括号之间的表达式）都会被求值，求值结果将成为函数的参数。这些值被赋值给在函数定义中命名的参数。
对于常规函数调用，函数的返回值就是调用表达式的值。如果函数返回是因为解释器到了函数终点，那么返回值是undefined。如果函数返回是因为解释器执行了返回语句，那么返回值就是返回语句后面的表达式的值，如果返回语句没有值，那么返回值也是undefined。
在非严格模式下调用函数时，调用上下文（this的值）是全局对象。而在严格模式下，调用上下文是undefined。需要注意的是，使用箭头语法定义的函数有不同的行为：它们总是继承定义它们时有效的this值。
作为函数（而不是方法）调用的函数通常不使用this关键字。不过，该关键字可用于确定严格模式是否生效：
const strict = (function () {  return !this; }()); console.log(strict) // false 递归函数是一种可以调用自身的函数，如factorial()函数。某些算法，例如涉及树形数据结构的算法，可以用递归函数来实现，而且特别优雅。不过，在编写递归函数时，必须考虑内存限制。当函数A调用函数B，然后函数B又调用函数C时，解释器需要跟踪这三个函数的执行上下文。当函数C执行完毕时，解释器需要知道在哪里继续执行函数B，而当函数B执行完毕时，解释器需要知道在哪里继续执行函数A。
当一个函数调用另一个函数时，一个新的执行上下文就会被推入堆栈。当该函数返回时，其执行上下文对象会从堆栈中弹出。如果一个函数递归调用自身100次，那么栈中就会推入100个对象，然后再从栈中取出这100个对象。这个调用栈需要占用内存。在现代硬件上，编写数百次自我调用的递归函数通常是没有问题的。但如果一个函数自我调用了上万次，就很可能会出现Maximum call-stack size exceeded这样的错误。
Method Invocation 方法只不过是存储在对象中的函数。如果有一个函数f和一个对象o，就可以使用下面一行定义一个名为m的方法：
o.m = f; 在定义了对象o的方法m 后，可以像下面这样调用它：
o.m(); 如果方法m期望两个参数，则可以按下面这样调用方法：
o.m(x, y); 上面函数表达式本身就是一个属性访问表达式，这意味着函数是作为方法而不是普通函数被调用的。方法调用的参数和返回值的处理与普通函数调用完全相同。
方法调用与函数调用有一个重要区别：调用上下文。属性访问表达式由两部分组成：对象和属性名称。在这样的方法调用表达式中，对象o成为调用上下文，函数体可以使用关键字this来引用该对象。下面是一个具体示例：
// An object literal let calculator = {  operand1: 1,  operand2: 1,  add() { // We&amp;#39;re using method shorthand syntax for this function  // Note the use of the this keyword to refer to the containing object.  this.result = this.operand1 &#43; this.operand2;  } }; calculator.add(); // A method invocation to compute 1&#43;1. console.log(calculator.result) // =&amp;gt; 2 大多数方法调用是使用点号进行属性访问，但使用方括号的属性访问表达式也可以执行方法调用。例如，以下两种情况都是方法调用：
o[&amp;#34;m&amp;#34;](x, y); // Another way to write o.m(x,y). a[0](z) // Also a method invocation (assuming a[0] is a function). 方法调用可能涉及更复杂的属性访问表达式：
customer.surname.toUpperCase(); // Invoke method on customer.surname f().m(); // Invoke method m() on return value of f() 方法和this关键字是面向对象编程范式的核心。任何作为方法使用的函数实际上都传递了一个隐式参数—调用它的对象。一般情况下，方法会对该对象执行某种操作，而方法调用语法是表达函数对该对象进行操作这一事实的优雅方式。比较下面两行:
rect.setSize(width, height); setRectSize(rect, width, height); 上面这两行代码中调用的假定函数可能对对象rect执行完全相同的操作，但第一行中的方法调用语法更清楚地表明操作的主要焦点是对象rect。
需要注意的是this是一个关键字，不是变量或属性名，不允许赋值给this。关键字this不像变量那样有作用域，除了箭头函数外，嵌套函数不会继承包含函数的this值。
如果嵌套函数作为方法被调用，其this值就是被调用的对象。如果嵌套函数（不是箭头函数）作为函数调用，那么它的this值要么是全局对象（非严格模式），要么是undefined（严格模式）。
一个常见的错误是，认为在方法中定义并作为函数调用的嵌套函数可以使用此值获取方法的调用上下文。下面的代码演示了这个问题：
let o = {  m: function () {  let self = this;  console.log(this === o) // true  f();  function f() {  console.log(this === o) // false  console.log(self === o) // true  }  } }; o.m(); 上面代码中，内嵌了函数f()，关键词this不等于对象o。这被普遍认为是JavaScript语言中的一个缺陷，因此必须加以注意。上面代码演示了一种常见的变通方法。在方法m中，我们将this值赋值给变量self，而在嵌套函数f中，可以使用self代替this来引用包含的对象。
在ES6及以后，解决这一问题的另一种方法是将嵌套函数f转换为箭头函数，这样就能正确地继承this值：
const f = () =&amp;gt; {  console.log(this === o) // true, since arrow functions inherit this }; 需要注意的是，定义为表达式而非语句的函数不会被提升（hoisted），因此为了使上面代码正常运行，需要将箭头函数f定义移到前面一些，使其在被调用之前出现。
let o = {  m: function () {  // 函数表达式需要在调用之前定义  const f = () =&amp;gt; {  console.log(this === o) // true, since arrow functions inherit this  };  console.log(this === o) // true  f();  } }; o.m(); 另一种解决方案是调用嵌套函数的bind() 方法来定义一个新函数，该函数会在指定对象上隐式调用：
let o = {  m: function () {  console.log(this === o) // true  const f = (function () {  console.log(this === o) // true, since arrow functions inherit this  }).bind(this);  f();  } }; o.m(); Constructor Invocation 如果函数或方法调用前有关键字new，那么它就是构造函数调用。构造函数调用在处理参数、调用上下文和返回值方面与普通函数和方法调用不同。
如果构造函数调用的时候包含了参数列表，那么这些参数表达式将以与函数和方法调用相同的方式进行求值并传递给函数。可以在构造函数调用中省略一对空括号，但这种做法并不常见，下面两行代码是等价的：
o = new Object(); o = new Object; 构造函数调用会创造一个空的对象，该对象继承自构造函数的prototype属性所指定的对象。构造函数的目的是初始化对象，这个新创建的对象被用作调用上下文，因此构造函数可以使用this关键字来引用它。
需要注意的是，即使构造函数的调用看起来像方法调用，新对象也会被用作调用上下文。也就是说，在表达式new o.m()中，o并未被用作调用上下文。
构造函数通常不使用返回关键字，它们通常会初始化新对象，然后在构造函数体结束时隐式返回。在这种情况下，新对象就是构造函数调用表达式的值。
如果构造函数显式地使用return语句返回对象，那么该对象就会成为调用表达式的值。如果构造函数在使用return时没有返回值，或者返回的是一个基础值，那么返回值将被忽略，新对象将作为调用表达式的值。
Indirect Invocation 函数是对象，如同所有其他所有对象一样，它也有方法。其中的两个方法call() 和apply()可以间接调用函数。这两种方法都允许明确指定调用的this值，这意味着可以将任何函数作为任何对象的方法来调用，即使它实际上不是该对象的方法。这两种方法还允许调用时指定参数。call()方法使用自己的参数列表作为函数的参数，而apply()方法则希望使用一个值数组作为参数。
Implicit Function Invocation JavaScript语言有多种功能看起来不像函数调用，但却会导致函数被调用。在编写可能被隐式调用的函数时要格外小心，与普通函数相比，这些函数中的错误、副作用和性能问题更难诊断和修复。
可能导致隐式函数调用包括：
 如果一个对象定义了get和set方法，那么查询和设置属性的值的时候会激活这些方法。 在字符串上下文中使用对象时（如与字符串连接时），会调用对象的toString()方法。同样，在数字上下文中使用对象时，也会调用其valueOf() 方法。 在循环遍历可迭代对象的元素时，会发生一些方法调用。 带tag的模板字面意义是一种变相的函数调用。 代理对象的行为完全由函数控制，对这些对象的任何操作都会调用一个函数。  Function Arguments and Parameters 函数定义没有指定函数参数的预期类型，函数调用也不会对传递的参数值进行任何类型检查。事实上，函数调用甚至不会检查传递的参数个数。
下面将介绍在调用函数时，如果传递的参数个数少于声明时的参数个数，或者传递的参数个数多于声明时的参数个数，会发生什么情况。还会演示了如果需要确保函数不被调用不适当的参数，如何显式地测试函数参数的类型。
Optional Parameters and Defaults 当调用函数的参数少于声明的参数个数时，剩余参数将被设置为默认值，通常是undefined。在编写函数时，将某些参数设置为可选参数通常很有用。下面是一个例子：
function getPropertyNames(o, a) {  if (a === undefined) a = []; // If undefined, use a new array  for (let property in o)  a.push(property);  return a; } // getPropertyNames() can be invoked with one or two arguments: let o = {x: 1}, p = {y: 2, z: 3}; let a = getPropertyNames(o); getPropertyNames(p, a); console.log(a) // [ &amp;#39;x&amp;#39;, &amp;#39;y&amp;#39;, &amp;#39;z&amp;#39; ] 在上面函数的第一行中，可以使用||操作符，而不是使用if语句：
a = a || []; 运算符||在第一个参数为true时返回该参数，否则返回第二个参数。在这种情况下，如果传递了任何对象作为第二个参数，函数将使用该对象。但如果省略了第二个参数（或传递了空值或其他falsy值），则将使用一个新创建的空数组。
需要注意的是，在设计带有可选参数的函数时，应确保将可选参数放在参数列表的末尾，以便可以省略它们。调用时不能省略第一个参数而传递第二个参数：必须明确传递undefined作为第一个参数。
在ES6及更高版本中，可以直接在函数的参数列表中为每个函数参数定义默认值。只需在参数名称后面加上等号和默认值，即可在没有参数时使用该参数：
// Append the names of the enumerable properties of object o to the // array a, and return a. If a is omitted, create and return a new array. function getPropertyNames(o, a = []) {  for (let property in o) a.push(property);  return a; } 参数缺省表达式在调用函数时求值，而不是在定义函数时求值，因此每次调用只传入一个参数的getPropertyNames()函数时，都会创建并传递一个新的空数组。
如果参数缺省值是常量（或字面表达式，如[]和{}），可能最容易对函数进行推理。但这并不是必需的，可以使用变量或函数调用来计算参数的默认值。一个有趣的例子是，对于有多个参数的函数，可以使用前一个参数的值来定义后面参数的默认值：
const rectangle = (width, height = width * 2) =&amp;gt; ({width, height}); console.log( rectangle(1)) // { width: 1, height: 2 } Rest Parameters and Variable-Length Argument Lists 使用参数缺省值，可以使用比定义时更少的参数调用函数。而可变参数恰恰相反：它们允许编写可以使用任意个数参数的函数。下面是一个函数示例，它期望使用一个或多个数字参数，并返回最大的参数：
function max(first = -Infinity, ...rest) {  let maxValue = first; // Start by assuming the first arg is biggest  // Then loop through the rest of the arguments, looking for bigger  for (let n of rest) {  if (n &amp;gt; maxValue) {  maxValue = n;  }  }  // Return the biggest  return maxValue; } console.log(max(1, 10, 100, 2, 3, 1000, 4, 5, 6)) 声明可变参数时，可变参数必须是最后一个参数。当调用一个有可变参数的函数时，会先将实参先赋值给非可变参数，然后将其余实参存储到数组中。最后一点很重要：在函数体中，其余参数的值始终是一个数组。数组可能是空的，但其余参数永远不会是undefined。
The Arguments Object 可变参数是ES6引入的，在此之前，varargs函数是使用Arguments对象编写的：在任何函数体中，标识符 arguments都是指该调用的Arguments对象，Arguments对象是一个类似数组的对象，它允许通过数字而不是名称来检索传递给函数的参数值。下面是前面的max()函数，改写后使用了Arguments对象而不是可变参数：
function max(x) {  let maxValue = -Infinity;  // Loop through the arguments, looking for, and remembering, the biggest.  for (let i = 0; i &amp;lt; arguments.length; i&#43;&#43;) {  if (arguments[i] &amp;gt; maxValue) maxValue = arguments[i];  }  // Return the biggest  return maxValue; } console.log(max(1, 10, 100, 2, 3, 1000, 4, 5, 6)) The Spread Operator for Function Calls 展开操作符...用于将数组（或任何其它可迭代对象，如字符串）中的元素拆开或展开。我们已经看到了数组字面量中的展开操作符。在函数调用中也能以同样的方式使用...：
let numbers = [5, 2, 10, -1, 9, 100, 1]; Math.min(...numbers)// =&amp;gt; -1 需要注意的是，...不是真正的操作符，它无法求值。相反，它是一种特殊的JavaScript语法，可用于数组字面量和函数调用。
Destructuring Function Arguments into Parameters 当使用一系列实参调用函数时，这些值会被赋给函数声明时的参数。函数调用的初始阶段很像变量赋值。因此，在函数中使用destructuring assignment技术也就不足为奇了。
假设定义函数时，参数名在一对方括号中时，实际上是告诉函数期望每对方括号传递一个数组值。作为调用过程的一部分，数组参数将解包为单独命名的参数：
function vectorAdd([x1, y1], [x2, y2]) { // Unpack 2 arguments into 4 parameters  return [x1 &#43; x2, y1 &#43; y2]; } console.log(vectorAdd([1, 2], [3, 4])) // [4,6] 类似的，如果定义函数时期望一个对象参数，则可以解构这个对象。下面示例代码中，把一个对象解构为两个参数。因为参数名和属性名相同，所以相当清晰。
function vectorMultiply({x, y}, scalar) {  return {x: x * scalar, y: y * scalar}; } console.log(vectorMultiply({x: 1, y: 2}, 2)) // =&amp;gt; {x: 2, y: 4} 如果把形参解构的属性命名为和实参不同的名字，则会让代码更加冗长和难以理解：
function vectorAdd({x: x1, y: y1}, {x: x2, y: y2}) {  return {x: x1 &#43; x2, y: y1 &#43; y2}; } vectorAdd({x: 1, y: 2}, {x: 3, y: 4}) // =&amp;gt; {x: 4, y: 6} 在解构赋值中，也可以为形参定义默认值：
function vectorMultiply({x, y, z = 0}, scalar) {  return {x: x * scalar, y: y * scalar, z: z * scalar}; } vectorMultiply({x: 1, y: 2}, 2) // =&amp;gt; {x: 2, y: 4, z: 0} 在ES2018中，解构对象时，也可以使用可变参数。此时可变参数的值是一个对象，包含了所有未解构的属性：
function vectorMultiply({x, y, z = 0, ...props}, scalar) {  return {x: x * scalar, y: y * scalar, z: z * scalar, ...props}; } vectorMultiply({x: 1, y: 2, w: -1}, 2) 需要注意的是，除了解构对象和数组，还可以解构对象数组，拥有数组属性的对象，以及有对象属性的对象，无论层级多深。
function drawCircle({x, y, radius, color: [r, g, b]}) {  // Not yet implemented } Argument Types 方法参数没有声明类型，在调用时也没有检查参数。可以为函数参数选择描述性的名称，并在每个函数的注释中仔细记录这些名称，从而帮助代码实现自文档化。
JavaSrcipt会按需进行类型转换。因此，如果编写了一个期望使用字符串参数的函数，然后使用其他类型的值调用该函数，那么当函数尝试将传递的实参值用作字符串时，它将被简单地转换为字符串。所有基础类型都可以转换为字符串，而且所有对象都有toString() 方法（即使不一定有用处），因此在这种情况下不会出现错误。
但不是没有例外，再来看看前面展示的arraycopy()方法。它期望一个或两个数组参数，如果参数类型不对就失败。当函数传入错误值时，最好能立即以可预测的方式失败，而不是在开始执行后以可能不清楚的错误信息失败。下面是一个执行类型检查的函数示例：
function sum(a) {  let total = 0;  for (let element of a) { // Throws TypeError if a is not iterable  if (typeof element !== &amp;#34;number&amp;#34;) {  throw new TypeError(&amp;#34;sum(): elements must be numbers&amp;#34;);  }  total &#43;= element;  }  return total; } Functions as Values 函数最重要的特性是它们能够被定义和调用。函数定义和调用是JavaScript和其他大多数语言的语法特性。但在JavaScript中，函数不仅是语法，而且是值。这意味函数可以赋值给变量，存储为对象的属性或者作为数组的元素，传递给函数等。
function square(x) {  return x * x; } let s = square; console.log(s(4)) // 16 console.log(square(4)) // 16 除了变量，函数还可以赋值给对象属性，此时称函数为方法：
let o = {  square: function (x) {  return x * x;  } }; // An object literal let y = o.square(16); console.log(y) 当把函数作为数组中的元素时，函数甚至不需要名字：
let a = [x =&amp;gt; x * x, 20]; console.log(a[0](a[1])) // 400 在方法Array.sort()中，可选地接受一个函数作为参数，并根据函数的返回值决定如何排序。这个函数的任务非常简单，对于传递给它的两个参数，它要确定哪个在前哪个在后。这个函数参数使得Array.sort()变得非常灵活。
下面代码演示了把函数当作值，可以做什么事情：
function add(x, y) {  return x &#43; y; } function subtract(x, y) {  return x - y; } function multiply(x, y) {  return x * y; } function divide(x, y) {  return x / y; } // Here&amp;#39;s a function that takes one of the preceding functions // as an argument and invokes it on two operands function operate(operator, operand1, operand2) {  return operator(operand1, operand2); } let i = operate(add, operate(add, 2, 3), operate(multiply, 4, 5)); const operators = {  add: (x, y) =&amp;gt; x &#43; y,  subtract: (x, y) =&amp;gt; x - y,  multiply: (x, y) =&amp;gt; x * y,  divide: (x, y) =&amp;gt; x / y,  pow: Math.pow // This works for predefined functions too };  function operate2(operation, operand1, operand2) {  if (typeof operators[operation] === &amp;#34;function&amp;#34;) {  return operators[operation](operand1, operand2);  } else throw &amp;#34;unknown operator&amp;#34;; } operate2(&amp;#34;add&amp;#34;, &amp;#34;hello&amp;#34;, operate2(&amp;#34;add&amp;#34;, &amp;#34; &amp;#34;, &amp;#34;world&amp;#34;)) operate2(&amp;#34;pow&amp;#34;, 10, 2) Defining Your Own Function Properties 需要注意的是，函数不是基础值，而是一种特殊的对象，这意味着函数可以有属性。当函数需要一个静态变量，它的值在函数调用时都能访问到，则通常把这个变量定义为函数自身的一个属性。
例如，假设想编写一个函数，每次调用时都返回一个唯一的整数。该函数绝不能两次返回相同的值。为了做到这一点，函数需要跟踪它已经返回的值，而且这些信息必须在函数调用时持续存在。可以将这些信息存储在全局变量中，但这是不必要的，因为只有函数本身会使用这些信息。最好将这些信息存储在函数对象的一个属性中。下面是一个每次调用都返回唯一整数的示例：
// 函数声明会被提升，因此在声明之前可以给它赋值 uniqueInteger.counter = 0; function uniqueInteger() {  return uniqueInteger.counter&#43;&#43; } uniqueInteger() // 0 uniqueInteger() // 1 下面的factorial()函数使用了自身的属性来缓存之前的计算结果（函数将自身作为一个数组）：
function factorial(n) {  if (Number.isInteger(n) &amp;amp;&amp;amp; n &amp;gt; 0) {  if (!(n in factorial)) {  // Compute and cache it  factorial[n] = n * factorial(n - 1);  }  return factorial[n];  } else {  return NaN  } } factorial[1] = 1; factorial(6) factorial[5] Functions as Namespaces 在函数中声明的变量，对于外部来说是不可见的。因此，有时可以把函数作为临时的命名空间使用，这样可以保证在其中定义的变量不会污染全局命名空间。
假设有一段JavaScript代码，想在几个不同的的程序中使用它，并且假设这段代码跟多数代码一样定义了存储中间计算结果的变量。这段代码可能被很多其他程序用到，我们不知道那些程序创建的变量会不会跟这段代码中的变量冲突。解决方案是把这段代码放到一个函数中，然后调用这个函数，原本会定义的全局变量就变成了这个函数的局部变量了。
function chunkNamespace() {  // Chunk of code goes here  // Any variables defined in the chunk are local to this function  // instead of cluttering up the global namespace. } chunkNamespace(); // But don&amp;#39;t forget to invoke the function! 上面代码之定义了一个全局变量，即函数chunkNamespace。如果连定义一个属性也嫌多，可以在一个表达式中定义并调用函数：
(function () { // chunkNamespace() function rewritten as an unnamed expression.  // Chunk of code goes here }()); // End the function literal and invoke it now. 在单个表达式中定义并调用匿名函数的技术很常用，因此甚至有了别称immediately invoked function expression。关键字function左侧的圆括号是必需的，如果去掉，会把function关键字作为函数声明来解析。
Closures 和其他许多现代编程语言一样，JavaScript使用lexical scoping。这意味着，函数执行时使用的变量作用域是定义函数时变量作用域，而不是调用函数的变量作用域。
为了实现lexical scoping，函数对象的内部状态不仅要包括函数代码，还要包括函数定义所在作用域的引用。这种函数对象于作用域（即一组变量绑定）组合起来解析函数变量的机制，被称为闭包。
严格来讲，所有的函数都是闭包，但因为多数情况下，函数定义和调用在同一个作用域，所以是否涉及闭包无关紧要。当闭包的定义和调用涉及不同的作用域时，闭包就变得有趣了。
最常见的情况是嵌套函数对象从定义它的函数中返回。有许多强大的编程技术都涉及到这种嵌套函数闭包，它们的使用在JavaScript编程中已变得相对普遍。初次接触闭包时，可能会感到困惑，但重要的是，必须充分了解它们，才能轻松自如地使用它们。
理解闭包的第一步是回顾嵌套函数的lexical scoping规则，请看下面的代码：
let scope = &amp;#34;global scope&amp;#34;;  function checkscope() {  let scope = &amp;#34;local scope&amp;#34;;  function f() {  return scope;  }  return f(); }  checkscope() // local scope 在checkscope中首先定义了一个局部变量scope，然后定义了返回该变量的函数并调用了这个函数。很显然，调用checkscope时返回了字符串local scope。如果稍微做一些修改：
let scope = &amp;#34;global scope&amp;#34;;  function checkscope() {  let scope = &amp;#34;local scope&amp;#34;;  function f() {  return scope;  }  return f; }  let s = checkscope()() console.log(s) 在上面代码中，把checkscope中的一对圆括号移动到了外层。移动前是调用内嵌函数并返回结果。而现在checkscope返回的是嵌套函数。因为lexical scoping，函数执行时使用的是定义他们的作用域，内嵌函数f()是在变量scope被绑定到值为local scope的作用域中定义的。当f被执行时，这个绑定依然生效，不管它是哪里被执行的。因此上面checkscope()()执行后返回的是字符串local scope。简单地说，这正是闭包惊人且强大的本质：它们会捕获定义它们的外部函数的局部变量（和参数）绑定。
之前定义了一个函数uniqueInteger()，这个函数使用一个自身的属性来跟踪要返回的下一个值。但该方法有一个缺点，很容易被错误或恶意的代码重置计数器，或者把计数器设置为非整数值，导致uniqueInteger()不具有唯一性。
闭包可以捕获一次函数调用的局部变量，可以将这些变量作为私有状态。因此，可以像下面这样改写函数uniqueInteger()，使用立即调用函数表达式定义一个命名空间，再通过闭包利用该命名空间来保证自己的状态私有：
let uniqueInteger = (function () { // Define and invoke  let counter = 0; // Private state of function below  return function () {  return counter&#43;&#43;;  }; }());  console.log(uniqueInteger()) console.log(uniqueInteger()) Function Properties, Methods, and Constructor 在JavaScript程序中，函数也是值，使用typeof操作符后，会返回function。但函数实际上是一种特殊的对象，因此函数也有属性和方法，甚至还有一个Function()构造函数来创建新函数对象。
The length Property 函数的只读属性length，表示函数在参数列表中声明的形参个数。这个值通常表示调用函数时应该传入的参数个数，如果函数有可变参数，则可变参数不会被计算在length属性中：
console.log(uniqueInteger.length, checkscope.length) // 0 0 The name Property 函数的只读属性name，表示定义函数时使用的名字。如果是未命名函数，则表示在第一次创建这个函数时赋值给该函数的变量名或属性名。
The prototype Property 除了箭头函数，所有函数都有一个prototype属性。每个函数都有自己的的prototype。当函数被作为构造函数使用时，新创建的对象从这个原型对象中继承属性。
The call() and apply() Methods 方法call和apply允许间接调用一个函数，就像这个函数是某个对象的方法一样。call和apply的第一个参数都是要在其上调用的当前函数的对象，也就是函数的调用上下文，在函数体内它会变成this关键字值。如果要把f()作为对象o的方法进行调用，可以使用call和apply：
f.call(o); f.apply(o); 上面两行代码类似于下面代码：
o.m = f; o.m(); delete o.m; 箭头函数从定义它的上下文中基础this值。这个this值不能通过call和apply方法重写。如果对箭头函数调用这两个方法，那第一个参数会被忽略。
除了作为调用上下文传给call的第一参数，后续的所有参数都会传给被调用的函数（箭头函数也不会忽略这些参数）：
f.call(o, 1, 2); apply方法和call方法类似，只不过传入的参数应当以数组形式：
f.apply(o, [1,2]); The bind() Method 方法bind的首要目的是绑定一个函数到一个对象。如果在函数f上调用了bind()并且传递了对象o，这个方法将返回一个新的函数。如果作为函数来调用这个新函数，就会像f是o的方法一样调用原函数：
let o = {x: 1}; let g = f.bind(o); g(2) let p = {x: 10, g}; p.g(2) 箭头函数从其定义的环境中继承其this值，且该值不能用bind()覆盖。因此如果前面代码中的函数f()被定义为箭头函数，则绑定将不起作用。
The toString() Method 与所有 JavaScript对象一样，函数也有一个toString()方法。ECMAScript规范要求该方法返回与函数声明语法一致的字符串。实际上，大多数（但不是全部）toString()方法的实现都会返回函数的完整源代码。内置函数通常会返回一个包含类似[native code]的字符串作为函数体。
Chapter 9 类意味着一组对象从同一个原型对象中继承属性。因此，原型对象是类的核心特征。函数Object.create()返回一个新的对象，它继承某个特定的原型对象。如果我们创建了一下原型对象，接着使用Object.create()创建一个继承这个原型对象，就是定义了类。通常一个类的实例需要进一步初始化，因此常见的做法是定义一个函数来创建和初始化新对象。
Classes and Constructors 构造函数是一种专门用于初始化新对象的函数，需要使用new关键字调用。构造器调用的关键是使用是使用它的prototype属性被用作新对象的原型。
之前说几乎所有对象都有原型，但只有少数对象有prototype属性。现在可以明确了：只有函数对象有prototype属性。这意味同一个构造函数创建的所有对象都继承同一个对象。
function Range(from, to) {  // Store the start and end points (state) of this new range object.  // These are noninherited properties that are unique to this object.  this.from = from;  this.to = to; }  Range.prototype = {  includes: function (x) {  return this.from &amp;lt;= x &amp;amp;&amp;amp; x &amp;lt;= this.to;  },  [Symbol.iterator]: function* () {  for (let x = Math.ceil(this.from); x &amp;lt;= this.to; x&#43;&#43;) yield x;  },  toString: function () {  return &amp;#34;(&amp;#34; &#43; this.from &#43; &amp;#34;...&amp;#34; &#43; this.to &#43; &amp;#34;)&amp;#34;;  } }  let r = new Range(1, 3); r.includes(2) r.toString() console.log([...r]) 在函数体内，可以通过一个特殊表达式new.target判断函数是否作为构造函数被调用了，如果该表达式有值，说明函数是作为构造函数，通过new关键词调用的：
function C() {  if (!new.target) return new C(); // initialization code goes here } Constructors, Class Identity, and instanceof 原型对象是类的基本特征：两个对象是同一个类的实例，当且仅当它们继承自同一个原型对象。初始化新对象状态的构造函数并不是基本的：两个构造函数的原型属性可能指向同一个原型对象。那么，这两个构造函数都可以用来创建同一个类的实例。
Classes with the class Keyword ES6才引入class关键字才有了自己的语法：
class Range {  constructor(from, to) {  // Store the start and end points (state) of this new range object.  // These are noninherited properties that are unique to this object.  this.from = from;  this.to = to;  }   // Return true if x is in the range, false otherwise // This method works for textual and Date ranges as well as numeric.  includes(x) {  return this.from &amp;lt;= x &amp;amp;&amp;amp; x &amp;lt;= this.to;  }   // A generator function that makes instances of the class iterable. // Note that it only works for numeric ranges.  * [Symbol.iterator]() {  for (let x = Math.ceil(this.from); x &amp;lt;= this.to; x&#43;&#43;) yield x;  }   // Return a string representation of the range  toString() {  return `(${this.from}...${this.to})`;  } }  let r = new Range(1, 3); r.includes(2) r.toString() console.log([...r]) 如果想定义一个继承另一个现有类的类，可以使用extends关键字和class关键字：
class Span extends Range {   constructor(start, length) {  if (length &amp;gt;= 0) {  super(start, start &#43; length);  } else {  super(start &#43; length, start);  }  }  } </content>
    </entry>
    
     <entry>
        <title>KVO 介绍</title>
        <url>https://iihui.github.io/post/ios-kvo/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag><tag>oc</tag><tag>swift</tag>
        </tags>
        <content type="html">  在应用开发中，经常需要使用观察者模式，以监听某些对象属性的变化，然后进行相应操作。OC提供了一套简洁优雅的观察方式——KVO。KVO(key-value observing)是一种通知机制，当指定的被观察者对象的属性被修改时，KVO会自动通知相应的观察者。KVO由NSKeyValueObserving协议提供支持，NSObject类继承了该协议，所以任何NSObject的子类都可使用该方法。
 KVO的使用 KVO的使用比较简单，只需要给对象的指定属性添加监听，并设置监听类型。每当对指定的属性进行读写操作时，OC就会调用observeValueForKeyPath方法，在observeValueForKeyPath中进行判断，确定是哪个对象的事件。
下面的例子是便实现一个属性值的监听。可总结为三步：第一步是添加监听；第二步是实现协议；第三步是移除监听：
Person *person = [Person alloc] init]; /* 作用:给对象绑定一个监听器(观察者) - Observer 观察者 - KeyPath 要监听的属性 - options 选项(方便在监听的方法中拿到属性值) */ [person addObserver:person forKeyPath:@&amp;#34;name&amp;#34; options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:nil]; // 移除监听 [person removeObserver:person forKeyPath:@&amp;#34;name&amp;#34;]; /** * 当监听的属性值发生改变 * * @param keyPath 要改变的属性 * @param object 要改变的属性所属的对象 * @param change 改变的内容 * @param context 上下文 */ - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&amp;lt;NSString *,id&amp;gt; *)change context:(void *)context{  NSLog(@&amp;#34;%@------%@------%@&amp;#34;, keyPath, object, change); } 添加监听 //第一个参数 observer观察者 （这里观察self.myKVO对象的属性变化） //第二个参数 keyPath被观察的属性名称(这里观察 self.myKVO 中 num 属性值的改变) //第三个参数 options： 观察属性的新值、旧值等的一些配置（枚举值，可以根据需要设置，例如这里可以使用两项） //第四个参数 context： 上下文，可以为 KVO 的回调方法传值（例如设定为一个放置数据的字典） - (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context; 实现协议 在回调方法中处理属性值发生变化。
//keyPath:属性名称 //object:被观察的对象 //change:变化前后的值都存储在change字典中 //context:注册观察者时，context 传过来的值  - (void)observeValueForKeyPath:(nullable NSString *)keyPath ofObject:(nullable id)object change:(nullable NSDictionary *)change context:(nullable void *)context; 移除观察者。 - (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath; 注意事项 使用KVO消息传递机制有两个要求：
  观察者必须知道被观察者对象，即在同一作用域。
  观察者还需要知道被观察对象的生命周期，因为在销毁发送者对象之间，需要取消观察者的注册。
  Swift中属性观察器 在Swift中有两个属性观察者willSet和didSet,类似于触发器。用来监控属性除初始化之外的属性值变化，当属性值发生变化时可以对此作出响应。
 不仅可以在属性值发生变化后触发didSet,也可以在属性值改变前触发willSet。 给属性添加观察者必须要声明清楚属性的类型，否则编译器报错。 willSet可以带一个newName的参数，没有的话，默认命名为newValue。 didSet 可以带一个oldName的参数，表示旧的值，不带的话，默认命名为oldValue。 属性初始化时，willSet和didSet不会调用。只有初始化上下文之外，属性值发生变化时才会调用。 即使设置的值和原来的一样，willSet和didSet也会被调用。  var firstName: String = &amp;#34;First&amp;#34; {  willSet { //新值设置之前被调用，在此可以进行条件筛选，过滤数据  print(&amp;#34;willSet的新值是\(newValue)&amp;#34;)  }  didSet { //新值设置之后立即调用，在此可以进行条件筛选，过滤数据,可以直接绑定数据到UI上面  print(&amp;#34;didSet的旧值是\(oldValue)--- 新值是 \(firstName)&amp;#34;)  self.nameLabel.text = firstName  } }  Swift实现KVO值监听 利用设计模式中的观察者模式，观察者定义了对象之间的一对多依赖。当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。观察者模式适用在一个被观察者（数据源）要通知多个观察者的场景。
参考资料 参考资料
</content>
    </entry>
    
     <entry>
        <title>给图片添加点击监听</title>
        <url>https://iihui.github.io/post/js-img/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>js</tag>
        </tags>
        <content type="html"> 给所有图片添加监听 function setImagesClick(){  $(&amp;#39;body&amp;#39;).on(&amp;#39;click&amp;#39;,&amp;#39;img&amp;#39;,function(){  let position = this.offsetTop; //当前元素距离顶部的距离  //window.scrollTo(0,position)  let result = {};  result.position = position.toString()  let jsonString = JSON.stringify(result);  let escapedJsonString = encodeURI(jsonString); //重新编码  let scheme = &amp;#34;position://&amp;#34;;  document.location.href = scheme &#43; &amp;#34;#&amp;#34; &#43; escapedJsonString; //向ios发送  }); } 参考资料
 </content>
    </entry>
    
     <entry>
        <title>RunLoop</title>
        <url>https://iihui.github.io/post/ios-runloop/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> 概念 一般来讲，一个线程一次只能执行一个任务，执行完成后，线程就会退出。若我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是下面这样的：
function loop() {  initialize();  do {  var message = get_next_message();  process_message(message);  } while (message != quit); } 这种模型被称为Event Loop,实现这种模型的关键点在于：
 如何管理事件/消息 如何让线程在没有处理消息时休眠以避免资源占用，在有消息到来时立刻被唤醒。  因此，RunLoop实质上是一个对象，这个对象管理了其需要处理的事件和消息
 参考资料
</content>
    </entry>
    
     <entry>
        <title>权限检查</title>
        <url>https://iihui.github.io/post/ios-authority/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> 相机权限检查 相机和音频的权限分为4种，分别是.denied,restricted,.authorized,.notDetermined,.authorized四种:
  .denied 未授权，用户曾经选择过拒绝授权。
  .authorized 已经授权。
  .restricted 未授权，例如家长控制。
  .notDetermined 没有询问过用户是否授权，所以是未确定状态。
  //MARK:检查相机访问权限 func cameraPermissionCheck(){  let authStatus = AVCaptureDevice.authorizationStatus(forMediaType: AVMediaTypeVideo)  switch authStatus {  case .denied, .restricted:  let alert = UIAlertController(title: &amp;#34;提示&amp;#34;.localized, message: CameraAccessMsg, preferredStyle: .alert)  let settingAction = UIAlertAction(title: &amp;#34;去设置&amp;#34;.localized, style: .default) { (_) in  let url = NSURL(string: UIApplicationOpenSettingsURLString)!  if UIApplication.shared.canOpenURL(url as URL){  UIApplication.shared.openURL(url as URL)  }  }  let cancelAction = UIAlertAction(title: &amp;#34;取消&amp;#34;.localized, style: .cancel) { (_) in  DPrint(&amp;#34;cancel!&amp;#34;)  }  alert.addAction(settingAction)  alert.addAction(cancelAction)  self.present(alert, animated: true, completion: nil)  default:break  } } func cameraPermissionCheck(){  let msg = &amp;#34;没有相机访问权限，请移步到设置--&amp;gt;隐私--&amp;gt;相机--&amp;gt;APP&amp;#34;  let authStatus = AVCaptureDevice.authorizationStatus(for: .video)  switch authStatus {  case .denied, .restricted,.notDetermined:  let alert = UIAlertController(title: &amp;#34;提示&amp;#34;, message: msg, preferredStyle: .alert)  let settingAction = UIAlertAction(title: &amp;#34;去设置&amp;#34;, style: .default) { (_) in  let url = URL(string: UIApplicationOpenSettingsURLString)  if let cameraURL = url,UIApplication.shared.canOpenURL(cameraURL){  UIApplication.shared.open(cameraURL, options: [:], completionHandler: nil)  }  }  let cancelAction = UIAlertAction(title: &amp;#34;取消&amp;#34;, style: .cancel) { (_) in  print(&amp;#34;点击了取消&amp;#34;)  }  alert.addAction(settingAction)  alert.addAction(cancelAction)  self.present(alert, animated: true, completion: nil)  default:break  } } override func viewDidAppear(_ animated: Bool) {  super.viewDidAppear(animated)  cameraPermissionCheck() }  麦克风权限检查 let status = AVCaptureDevice.authorizationStatus(forMediaType: AVMediaTypeAudio) if status == .denied || status == .restricted {  let message = &amp;#34;麦克风访问权限被禁用，请前往系统设置-&amp;gt;隐私-&amp;gt;麦克风中，启用本程序对麦克风的访问权限&amp;#34;.localized  let tipsAlertController = UIAlertController(title: &amp;#34;提示&amp;#34;.localized, message: message, preferredStyle: .alert)  let confirm = UIAlertAction(title: &amp;#34;去设置&amp;#34;.localized, style: .default){ (_) in  let url = NSURL(string: UIApplicationOpenSettingsURLString)!  if UIApplication.shared.canOpenURL(url as URL) {  UIApplication.shared.openURL(url as URL)  }  }  let cancelAction = UIAlertAction(title: &amp;#34;取消&amp;#34;.localized, style: .cancel) { (_) in  self.dismiss(animated: true, completion: nil)  }   tipsAlertController.addAction(confirm)  tipsAlertController.addAction(cancelAction)  self.present(tipsAlertController, animated: true, completion: nil) } 参考资料
 </content>
    </entry>
    
     <entry>
        <title>CABasicAnimation</title>
        <url>https://iihui.github.io/post/ios-animation/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> 关键帧动画 所谓关键帧动画，就是将Layer的属性作为KeyPath来注册，只要指定动画的起始帧和结束帧，然后自动计算和实现中间的过度的一种动画方式。
func recordingButtonAnimation(){  let animation = CABasicAnimation(keyPath: &amp;#34;opacity&amp;#34;)  animation.fromValue = 1.0  animation.toValue = 0.3  animation.fillMode = kCAFillModeForwards  animation.isRemovedOnCompletion = false  animation.duration = self.animationDuration  self.recordButton.layer.add(animation, forKey: nil) }  //添加定时器 if recordingAnimationTimer == nil{  recordingAnimationTimer = Timer.scheduledTimer(timeInterval: self.animationDuration, target: self, selector: #selector(recordingButtonAnimation), userInfo: nil, repeats: true) }  //销毁定时器 self.recordingAnimationTimer?.invalidate() //移除动画层 self.recordButton.layer.removeAllAnimations() 属性说明：
 duration动画时长，默认为0,不设置的话会快速执行完动画 speed 执行速度，默认为1倍速度，如果设置了该属性，则执行时长为$\frac{duration}{speed}$ repeatCount重复次数，默认为0，如果需要设置为永久的话可以设置为HUGE_VALE autoreverses 动画执行完是否执行逆动画，默认不执行 fromValue 开始值 toValue 结束值  当CABasicAnimation执行完动画后会回归动画开始的状态，如果想要让它变成动画执行最后的状态，设置一下两个属性：
animation.removedOnCompletion = false animation.fillMode = kCAFillModeForwards 如果要设置永久重复，则需要将repeatCount的值置为HUGE或者.greatestFiniteMagnitude。
let animation = CABasicAnimation(keyPath: &amp;#34;opacity&amp;#34;) animation.duration = 1.0 animation.repeatCount = .greatestFiniteMagnitude//HUGE animation.autoreverses = true animation.fromValue = 1.0 animation.toValue = 0.0 testButton.layer.add(animation, forKey: nil) 当给一个CALayer添加动画时，动画其实并没有改变这个Layer的实质属性，取而代之，系统会创建一个原始Layer的拷贝。苹果称这个原始Layer为Model Layer，而这个复制的Layer被称为Presentation Layer。
Presentation Layer的属性会随着动画的进度实时改变，而Model Layer中对应的属性不会发生变化。 默认情况下，系统会在duration时间后自动移除CAKeyframeAnimation。当移除某个动画后，系统会自动销毁这个Layer的Presentation Layer，只留下Model Layer。因为Model Layer的属性没有发生变化，所以视图一瞬间就回到了动画的初始状态。要解决这种状态需要先把removeOnCompletion设置为false,然后设置fillMode为kCAFillModeForwards。
animation.removedOnCompletion = false animation.fillMode = kCAFillModeForwards 关于fillMode它有四个值：
 KCAFillModelRemoved 这个是默认值，表示动画开始前和结束后对Model Layer没有影响，动画结束会回到视图的初始状态。 kCAFillModeForwards 当动画结束后，Model Layer会保持动画的最后状态。 kCAFillModeBackwards 在动画开始前，只要将动画加入到一个Layer,则Layer立即进入动画的初始状态并等待动画开始。 kCAFillModeBoth 动画加入Layer后，Layer便处于初始状态，动画结束后Layer保持最后的状态。   添加引导动画 fileprivate var guideImageView:UIImageView? private let guideKey = &amp;#34;GUIDE_NOTE_SPEECH_KEY&amp;#34; //应用级别的引导，如果增加用户的id，则是用户级别的引导 func showGuide(){  let isShowed = UserDefaults.standard.value(forKey: self.guideKey)  if isShowed == nil {  let guideImage = UIImage(named: &amp;#34;guide_note_speech&amp;#34;)  if self.guideImageView == nil{  self.guideImageView = UIImageView(image: guideImage)  let width:CGFloat = 132  let height:CGFloat = 100  let x = bottomView.bounds.width/2 &#43; 15  let y = topView.bounds.size.height &#43; centerView.bounds.size.height &#43; soundWaveView.bounds.size.height - height &#43; 20   if let guideView = self.guideImageView{  self.guideImageView?.frame = CGRect(x: x, y: y, width: width, height: height)  self.view.addSubview(guideView)   let startPoint = CGPoint(x: 0, y: 1)  setAnchorPoint(point: startPoint, view: guideView)   UIView.animate(withDuration: 1.2, delay: 0, options: [.repeat, .autoreverse], animations: {  guideView.transform = CGAffineTransform(scaleX: 0.8, y: 0.8)  }, completion:nil)  }  }  } } 需要注意的是：因为上面的函数涉及到bounds的计算，因此guideShow函数应当放到viewDidLayoutSubviews()中，或者viewDidAppear(_ animated: Bool)中，经过试验，发现如果放到viewDidLayoutSubviews()中，图片会变黑很多。
override func viewDidLayoutSubviews() {  super.viewDidLayoutSubviews()  showGuide() } override func viewDidAppear(_ animated: Bool) {  super.viewDidAppear(animated)  showGuide() } 取消引导动画时，首先应当移除引导的imageview，并将key记录到plist文件中。如果设置时用户点击某个按钮时移除引导，则将如下代码添加到相应UIButton的响应函数中：
if let guideView = self.guideImageView{  self.removeGuide(view: guideView) } func removeGuide(view:UIView) {  view.removeFromSuperview()  UserDefaults.standard.setValue(true, forKey: self.guideKey) } 如果是用户点击imageView的任何地方，移除引导，则应先在imageView里添加手势，如下所示：
func tapGuide(gesture: UITapGestureRecognizer) {  gesture.view?.removeFromSuperview()  UserDefaults.standard.setValue(true, forKey: self.guideKey) } guideImageView.isUserInteractionEnabled = true let tapGesture = UITapGestureRecognizer(target: self, action: #selector(tapGuide(gesture:))) guideImageView.addGestureRecognizer(tapGesture) 适配iPad添加横竖屏的支持
private let guideKey = &amp;#34;GUIDE_NOTE_SPEECH_KEY12&amp;#34; func showGuide(){  let isShowed = UserDefaults.standard.value(forKey: self.guideKey)  if isShowed == nil {  self.guideImageView?.removeFromSuperview()  let guideImage = UIImage(named: &amp;#34;guide_note_speech&amp;#34;)  self.guideImageView = UIImageView(image: guideImage)   let width:CGFloat = 132  let height:CGFloat = 100  let bounds = UIScreen.main.bounds  let x = bounds.size.width/2 &#43; 20   var y = bounds.size.height - self.bottomView.bounds.size.height - height  if let navHeight = self.navigationController?.navigationBar.bounds.size.height{  y -= navHeight  }   if let guideView = self.guideImageView{  self.guideImageView?.frame = CGRect(x: x, y: y, width: width, height: height)  guideView.alpha = 0.8  self.view.addSubview(guideView)  let startPoint = CGPoint(x: 0, y: 1)  setAnchorPoint(point: startPoint, view: guideView)   UIView.animate(withDuration: 1.6, delay: 0, options: [.repeat, .autoreverse], animations: {  guideView.transform = CGAffineTransform(scaleX: 0.8, y: 0.8)  }, completion:nil)  }  } } 参考资料 参考资料 参考资料 参考资料
 两个效果 let transformA = CGAffineTransform(scaleX: 0.5, y: 0.5) let transformB = CGAffineTransform(translationX:100, y：100) guideImageView.transform = transformA.concatenating(transformB) 参考资料
CABasicAnimation  使用CABasicAnimation做旋转动画时，发现切到后台之后，再切回到前台时，动画停止了。查阅相关资料，发现切到后台之后，CABasicAnimation被移除了，为此，需要将isRemovedOnCompletion属性置为false。
 private func addAnimation() {  let rotationAnimation = CABasicAnimation(keyPath: &amp;#34;transform.rotation&amp;#34;)  rotationAnimation.fromValue = 0.0  rotationAnimation.toValue = 2 * Double.pi  rotationAnimation.dutation = 1.0  rotationAnimation.repeatCount = .infinity  rotationAnimation.isRemovedOnCompletion = false  self.imageView.layer.add(rotationAnimation, forKey: nil) }  </content>
    </entry>
    
     <entry>
        <title>透明度渐变动画</title>
        <url>https://iihui.github.io/post/ios-opicity-animation/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> CABasicAnimation关键帧动画 所谓关键帧动画，就是将Layer的属性作为KeyPath来注册，只要指定动画的起始帧和结束帧，然后自动计算和实现中间的过度的一种动画方式。
func recordingButtonAnimation(){  let animation = CABasicAnimation(keyPath: &amp;#34;opacity&amp;#34;)  animation.fromValue = 1.0  animation.toValue = 0.3  animation.fillMode = kCAFillModeForwards  animation.isRemovedOnCompletion = false  animation.duration = self.animationDuration  self.recordButton.layer.add(animation, forKey: nil) }  //添加定时器 if recordingAnimationTimer == nil{  recordingAnimationTimer = Timer.scheduledTimer(timeInterval: self.animationDuration, target: self, selector: #selector(recordingButtonAnimation), userInfo: nil, repeats: true) }  //销毁定时器 self.recordingAnimationTimer?.invalidate() //移除动画层 self.recordButton.layer.removeAllAnimations() 属性说明：
 duration动画时长，默认为0,不设置的话会快速执行完动画 speed 执行速度，默认为1倍速度，如果设置了该属性，则执行时长为$\frac{duration}{speed}$ repeatCount重复次数，默认为0，如果需要设置为永久的话可以设置为HUGE_VALE autoreverses 动画执行完是否执行逆动画，默认不执行 fromValue 开始值 toValue 结束值  CABasicAnimation执行完动画后会回归动画开始的状态，如果想要让它变成动画执行最后的状态，设置一下两个属性：
animation.removedOnCompletion = false animation.fillMode = kCAFillModeForwards 如果要设置永久重复，则需要将repeatCount的值置为HUGE或者.greatestFiniteMagnitude。
let animation = CABasicAnimation(keyPath: &amp;#34;opacity&amp;#34;) animation.duration = 1.0 animation.repeatCount = .greatestFiniteMagnitude//HUGE animation.autoreverses = true animation.fromValue = 1.0 animation.toValue = 0.0 testButton.layer.add(animation, forKey: nil)  添加引导动画 fileprivate var guideImageView:UIImageView? private let guideKey = &amp;#34;GUIDE_NOTE_SPEECH_KEY&amp;#34; //应用级别的引导，如果增加用户的id，则是用户级别的引导 func showGuide(){  let isShowed = UserDefaults.standard.value(forKey: self.guideKey)  if isShowed == nil {  let guideImage = UIImage(named: &amp;#34;guide_note_speech&amp;#34;)  if self.guideImageView == nil{  self.guideImageView = UIImageView(image: guideImage)  let width:CGFloat = 132  let height:CGFloat = 100  let x = bottomView.bounds.width/2 &#43; 15  let y = topView.bounds.size.height &#43; centerView.bounds.size.height &#43; soundWaveView.bounds.size.height - height &#43; 20   if let guideView = self.guideImageView{  self.guideImageView?.frame = CGRect(x: x, y: y, width: width, height: height)  self.view.addSubview(guideView)   let startPoint = CGPoint(x: 0, y: 1)  setAnchorPoint(point: startPoint, view: guideView)   UIView.animate(withDuration: 1.2, delay: 0, options: [.repeat, .autoreverse], animations: {  guideView.transform = CGAffineTransform(scaleX: 0.8, y: 0.8)  }, completion:nil)  }  }  } } 需要注意的是：因为上面的函数涉及到bounds的计算，因此guideShow函数应当放到viewDidLayoutSubviews()中，或者viewDidAppear(_ animated: Bool)中，经过试验，发现如果放到viewDidLayoutSubviews()中，图片会变黑很多。
override func viewDidLayoutSubviews() {  super.viewDidLayoutSubviews()  showGuide() } override func viewDidAppear(_ animated: Bool) {  super.viewDidAppear(animated)  showGuide() } 取消引导动画时，首先应当移除引导的imageview，并将key记录到plist文件中。如果设置时用户点击某个按钮时移除引导，则将如下代码添加到相应UIButton的响应函数中：
if let guideView = self.guideImageView{  self.removeGuide(view: guideView) } func removeGuide(view:UIView) {  view.removeFromSuperview()  UserDefaults.standard.setValue(true, forKey: self.guideKey) } 如果是用户点击imageView的任何地方，移除引导，则应先在imageView里添加手势，如下所示：
func tapGuide(gesture: UITapGestureRecognizer) {  gesture.view?.removeFromSuperview()  UserDefaults.standard.setValue(true, forKey: self.guideKey) } guideImageView.isUserInteractionEnabled = true let tapGesture = UITapGestureRecognizer(target: self, action: #selector(tapGuide(gesture:))) guideImageView.addGestureRecognizer(tapGesture) 适配iPad添加横竖屏的支持
private let guideKey = &amp;#34;GUIDE_NOTE_SPEECH_KEY12&amp;#34; func showGuide(){  let isShowed = UserDefaults.standard.value(forKey: self.guideKey)  if isShowed == nil {  self.guideImageView?.removeFromSuperview()  let guideImage = UIImage(named: &amp;#34;guide_note_speech&amp;#34;)  self.guideImageView = UIImageView(image: guideImage)   let width:CGFloat = 132  let height:CGFloat = 100  let bounds = UIScreen.main.bounds  let x = bounds.size.width/2 &#43; 20   var y = bounds.size.height - self.bottomView.bounds.size.height - height  if let navHeight = self.navigationController?.navigationBar.bounds.size.height{  y -= navHeight  }   if let guideView = self.guideImageView{  self.guideImageView?.frame = CGRect(x: x, y: y, width: width, height: height)  guideView.alpha = 0.8  self.view.addSubview(guideView)  let startPoint = CGPoint(x: 0, y: 1)  setAnchorPoint(point: startPoint, view: guideView)   UIView.animate(withDuration: 1.6, delay: 0, options: [.repeat, .autoreverse], animations: {  guideView.transform = CGAffineTransform(scaleX: 0.8, y: 0.8)  }, completion:nil)  }  } } 参考资料 参考资料 参考资料 参考资料
 同时添加两个效果 let transformA = CGAffineTransform(scaleX: 0.5, y: 0.5) let transformB = CGAffineTransform(translationX:100, y：100) guideImageView.transform = transformA.concatenating(transformB) 参考资料
 </content>
    </entry>
    
     <entry>
        <title>iOS视频开发入门</title>
        <url>https://iihui.github.io/post/ios-video/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> 视频实质 纯粹的视频（不包括音频）实质上就是一组帧图片，经过视频编码成为视频(video)文件再把音频（audio）文件以及字幕文件组装在一起成为视频（movie）文件。
1秒内出现的图片数就是帧率，图片间隔越小画面就越流畅，所以帧率越高效果就越好，需要的存储空间也就越多。
录制视频的3种实现方式   UIImagePickerViewController：只能设置一些简单的参数来实现基本的视频录制的效果，自定义程度不高。
  AVFoundation：苹果提供的底层多媒体框架，用于音视频采集、解码、视频编辑等，使用AVFoundation进行视频录制有以下两种方式：
  AVCaptureSession &#43; AVCaptureMoiveFileOutput。
  AVCaptureSession &#43; AVAssetWriter。
    UIImagePickerController 这种方式只能设置一些简单的参数，自定义程度不高，只能自定义界面上的操作按钮以及视频的画质：
- (void)viewDidLoad {  [super viewDidLoad];   if ([self isVideoRecordingAvailable]) {  return;  }  self.sourceType = UIImagePickerControllerSourceTypeCamera;  self.mediaTypes = @[(NSString *)kUTTypeMovie];  self.delegate = self;   //隐藏系统自带UI  self.showsCameraControls = NO;  //设置摄像头  [self switchCameraIsFront:NO];  //设置视频画质类别  self.videoQuality = UIImagePickerControllerQualityTypeMedium;  //设置散光灯类型  self.cameraFlashMode = UIImagePickerControllerCameraFlashModeAuto;  //设置录制的最大时长  self.videoMaximumDuration = 20; } - (BOOL)isVideoRecordingAvailable {  if([UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypeCamera]){  NSArray *availableMediaTypes = [UIImagePickerController availableMediaTypesForSourceType:UIImagePickerControllerSourceTypeCamera];  if([availableMediaTypes containsObject:(NSString *)kUTTypeMovie]){  return YES;  }  }  return NO; } - (void)switchCameraIsFront:(BOOL)front {  if (front) {  if([UIImagePickerController isCameraDeviceAvailable:UIImagePickerControllerCameraDeviceFront]){  [self setCameraDevice:UIImagePickerControllerCameraDeviceFront];   }  } else {  if([UIImagePickerController isCameraDeviceAvailable:UIImagePickerControllerCameraDeviceRear]){  [self setCameraDevice:UIImagePickerControllerCameraDeviceRear];   }  } }  AVCaptureSession&#43;AVCaptureMovieFileOutput 采用AVCaptureSession&#43;AVCaptureMovieFileOutput进行视频录制一般要经过以下6步：
 创建捕捉会话AVCaptureSession,用于控制input到output的流向。 设置视频的输入设备 AVCaptureDeviceInput，用于视频采集，然后将设备绑定到AVCaptureSession的输入口input中。 设置音频输入设备 AVCaptureDeviceInput，用于音频采集，然后将设备绑定到AVCaptureSession的输入口input中。 设置输出源AVCaptureMovieFileOutput。此时音频和视频会合并在一起，在代理方法中也可以单独拿到视频或者音频数据，给AVCaptureMovieFileOutput指定路径，开始录制之后就会向这个路径写入数据。 添加视频预览层。 开始采集数据，这个时候还没有写入数据，用户点击录制后就可以开始写入数据。  如果需要对视频进行实时处理，则需要对相机缓冲区中的视频流进行处理：
 定义一个视频数据输出AVCaptureVideoDataOutput,并将其添加到Session上。 设置接受的Controller作为视频数据输出缓冲区Sample Buffer的代理。 实现代理方法。   参考资料 参考资料
 AVCaptureSession&#43;AVAssetWriter 基本流程为
 创建捕捉会话 设置视频的输入和输出 设置音频的输入和输出 添加视频预览层 开始采集数据，这个时候还没有写入数据，用户点击录制的时候才开始写入数据 初始化AVAssetWriter，我们会拿到视频和音频数据流，用AVAssetWriter写入文件，这一步需要自己实现。   录制视频开启蓝牙录音 思路是先判断是否有蓝牙或者耳机插入，如果有则将其设置为音频输入源，否则使用默认的麦克风，应当注意的是要在设置了音频输入源之后，再设置self.captureSession.usesApplicationAudioSession = true和self.captureSession.automaticallyConfiguresApplicationAudioSession = false。
fileprivate var isBlueToothAvailable = false fileprivate var audioSession = AVAudioSession.sharedInstance() func isBlueToothConnected()-&amp;gt;Bool{  let route = AVAudioSession.sharedInstance().currentRoute  for item in route.outputs{  if item.portType == AVAudioSessionPortHeadphones || item.portType == AVAudioSessionPortBluetoothA2DP{  self.isBlueToothAvailable = true  return true  }  }  return false }  if isBlueToothConnected(){  do{  try audioSession.setCategory(AVAudioSessionCategoryPlayAndRecord, with: AVAudioSessionCategoryOptions.allowBluetooth)  }catch{} }  if self.isBlueToothAvailable {  self.captureSession.usesApplicationAudioSession = true  self.captureSession.automaticallyConfiguresApplicationAudioSession = false } 参考资料
</content>
    </entry>
    
     <entry>
        <title>HTML入门</title>
        <url>https://iihui.github.io/post/htm-primer/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>html</tag>
        </tags>
        <content type="html"> 简介 HTML指的是超文本标记语言 (Hyper Text Markup Language)，它不是一种编程语言，而是一种标志语言，标记语言是一套标记标签，使用标记标签来描述网页。
 .htm or .html 当保存HTML文件时，可以使用.htm,也可以使用.html文件后缀。使用.htm,这只是长久以来形成的习惯，因为过去的很多软件只允许三个字母的文件后缀。对于新的软件，使用.html完全没有问题。
 HTML标签 HTML标签是由尖括号包围的关键词，比如&amp;lt;html&amp;gt;。标签通常是成对出现的「也有可能是单个出现」，比如&amp;lt;b&amp;gt;和&amp;lt;/b&amp;gt;；标签对中的第一个标签时开始标签，第二个标签是结束标签。
 HTML元素 HTML文档用于描述网页「HTML文档也被称为网页」，文档包含HTML标签和纯文本。HTML元素，指的是从开始标签(start tag)到结束标签(end tag)的所有代码。元素的内容是开始标签与结束标签之间的内容。
某些HTML元素具有空内容，没有内容的HTML元素被称为空元素,空元素在开始标签中进行关闭。
&amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt;  &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt;  &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34;&amp;gt;  &amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;ie=edge&amp;#34;&amp;gt;  &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt;  &amp;lt;div&amp;gt;测试&amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;  HTML属性 大多数HTML元素可拥有属性,属性提供了有关HTML元素的更多的信息，属性总是以名称/值对的形式出现，比如：name=&amp;quot;value&amp;quot;：
  属性总是在HTML元素的开始标签中规定。
  属性和属性值对大小写不敏感。不过，万维网联盟在其HTML 4 推荐标准中推荐小写的属性/属性值。而新版本的(X)HTML要求使用小写属性。
  属性值应该始终被包括在引号内，双引号是最常用的，不过使用单引号也没有问题。
  &amp;lt;a href=&amp;#34;http://www.w3school.com.cn&amp;#34;&amp;gt;This is a link&amp;lt;/a&amp;gt;  外部样式表 &amp;lt;head&amp;gt; &amp;lt;link rel=&amp;#34;stylesheet&amp;#34; type=&amp;#34;text/css&amp;#34; href=&amp;#34;mystyle.css&amp;#34;&amp;gt; &amp;lt;/head&amp;gt;  &amp;lt;head&amp;gt; &amp;lt;link href=&amp;#34;./style.css&amp;#34; rel=&amp;#34;stylesheet&amp;#34; type=&amp;#34;text/css&amp;#34;&amp;gt; &amp;lt;/head&amp;gt;  内部样式表 &amp;lt;head&amp;gt; &amp;lt;style type=&amp;#34;text/css&amp;#34;&amp;gt; body {background-color: red} p {margin-left: 20px} &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt;  内联样式表 &amp;lt;p style=&amp;#34;color: red; margin-left: 20px&amp;#34;&amp;gt; This is a paragraph &amp;lt;/p&amp;gt;  超链接 超链接可以是一个字，一个词，或者一组词，也可以是一副图像，你可以点击这些内容来跳转到新的文档或者当前文档的某个部分。
通过使用&amp;lt;a&amp;gt;标签在HTML中创建新链接，可以有两种使用超链接的方式：
  通过使用href属性创建指向另一个文档的链接。
  通过使用name属性，创建文档内的书签（锚）。
   页面间跳转 &amp;lt;a href=&amp;#34;http://www.w3school.com.cn/&amp;#34;&amp;gt;Visit W3School&amp;lt;/a&amp;gt; &amp;lt;a href=&amp;#34;http://www.w3school.com.cn/html/html_links.asp#tips&amp;#34;&amp;gt;有用的提示&amp;lt;/a&amp;gt;&amp;lt;!--从其他页面创建指向该页面的锚--&amp;gt;  页面内跳转 页面内的跳转需要两个步骤：
  设置一个锚点链接&amp;lt;a href=&amp;quot;#miao&amp;quot;&amp;gt;去找喵星人&amp;lt;/a&amp;gt;。需要注意的是要在href的属性值value前加#。
  在页面中需要的位置设置一个锚点&amp;lt;a name=&amp;quot;miao&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;，标签中按需填写必要的文字，一般不写内容。设置锚点有两种方式
  &amp;lt;a name=&amp;quot;miao&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;。
  &amp;lt;h3 id=&amp;quot;miao&amp;quot;&amp;gt;喵星人基地&amp;lt;/h3&amp;gt;。这种方式不用单独添加一个a标签来设置锚点。
    &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; 	&amp;lt;meta charset=&amp;#34;utf-8&amp;#34;&amp;gt; 	&amp;lt;title&amp;gt;测试&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; 	&amp;lt;ul&amp;gt;  &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;#miao&amp;#34;&amp;gt;去找喵星人&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;!--同一个文档中创建指向该锚的链接--&amp;gt;  &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;#wang&amp;#34;&amp;gt;去找汪星人&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;!--同一个文档中创建指向该锚的链接--&amp;gt;  &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;#meng&amp;#34;&amp;gt;其他萌物&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;!--同一个文档中创建指向该锚的链接--&amp;gt;  &amp;lt;/ul&amp;gt;   &amp;lt;a name=&amp;#34;miao&amp;#34;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;!--设置锚点方法1--&amp;gt;  &amp;lt;h3 id=&amp;#34;miao&amp;#34;&amp;gt;喵星人基地&amp;lt;/h3&amp;gt;&amp;lt;!--设置锚点方法2--&amp;gt;  &amp;lt;p&amp;gt;喵喵喵~&amp;lt;/p&amp;gt;  &amp;lt;p&amp;gt;喵喵喵~&amp;lt;/p&amp;gt;  &amp;lt;p&amp;gt;喵喵喵~&amp;lt;/p&amp;gt;  &amp;lt;p&amp;gt;喵喵喵~&amp;lt;/p&amp;gt;  &amp;lt;p&amp;gt;喵喵喵~&amp;lt;/p&amp;gt;  &amp;lt;p&amp;gt;喵喵喵~&amp;lt;/p&amp;gt;   &amp;lt;a name=&amp;#34;wang&amp;#34;&amp;gt;&amp;lt;/a&amp;gt;  &amp;lt;p&amp;gt;汪汪汪~&amp;lt;/p&amp;gt;  &amp;lt;p&amp;gt;汪汪汪~&amp;lt;/p&amp;gt;  &amp;lt;p&amp;gt;汪汪汪~&amp;lt;/p&amp;gt;  &amp;lt;p&amp;gt;汪汪汪~&amp;lt;/p&amp;gt;  &amp;lt;p&amp;gt;汪汪汪~&amp;lt;/p&amp;gt;  &amp;lt;p&amp;gt;汪汪汪~&amp;lt;/p&amp;gt;   &amp;lt;a name=&amp;#34;meng&amp;#34;&amp;gt;&amp;lt;/a&amp;gt;  &amp;lt;p&amp;gt;萌萌萌~&amp;lt;/p&amp;gt;  &amp;lt;p&amp;gt;萌萌萌~&amp;lt;/p&amp;gt;  &amp;lt;p&amp;gt;萌萌萌~&amp;lt;/p&amp;gt;  &amp;lt;p&amp;gt;萌萌萌~&amp;lt;/p&amp;gt;  &amp;lt;p&amp;gt;萌萌萌~&amp;lt;/p&amp;gt;  &amp;lt;p&amp;gt;萌萌萌~&amp;lt;/p&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 参考资料
 图片 在HTML中，图像由&amp;lt;img&amp;gt;标签定义，&amp;lt;img&amp;gt;是空标签，即只包含属性，没有闭合标签。
&amp;lt;img src=&amp;#34;https://i.loli.net/2018/12/06/5c09153160635.jpg&amp;#34; alt=&amp;#34;none&amp;#34;&amp;gt; &amp;lt;!--`alt`属性表示当图片找不到时，应该显示的替换文本--&amp;gt;  span标签 span标签表示无语义行内元素，常用来组合文档内的行内元素，以便通过样式来格式化它们。
 类 可以为元素表设置类，然后为相同的类定义CSS样式：
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;style&amp;gt; .cities {  background-color:black;  color:white;  margin:20px;  padding:20px; } &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt;  &amp;lt;body&amp;gt;  &amp;lt;div class=&amp;#34;cities&amp;#34;&amp;gt; &amp;lt;h2&amp;gt;London&amp;lt;/h2&amp;gt; &amp;lt;p&amp;gt;London is the capital city of England. It is the most populous city in the United Kingdom, with a metropolitan area of over 13 million inhabitants.&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt;  &amp;lt;div class=&amp;#34;cities&amp;#34;&amp;gt; &amp;lt;h2&amp;gt;Paris&amp;lt;/h2&amp;gt; &amp;lt;p&amp;gt;Paris is the capital and most populous city of France.&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt;  &amp;lt;div class=&amp;#34;cities&amp;#34;&amp;gt; &amp;lt;h2&amp;gt;Tokyo&amp;lt;/h2&amp;gt; &amp;lt;p&amp;gt;Tokyo is the capital of Japan, the center of the Greater Tokyo Area, and the most populous metropolitan area in the world.&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt;  &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;  HTML布局 &amp;lt;div&amp;gt;元素常用于布局工具，因为能够轻松通过CSS对其进行定位，下面这个例子使用4个&amp;lt;div&amp;gt;元素来创建多列布局：
&amp;lt;body&amp;gt;  &amp;lt;div id=&amp;#34;header&amp;#34;&amp;gt; &amp;lt;h1&amp;gt;City Gallery&amp;lt;/h1&amp;gt; &amp;lt;/div&amp;gt;  &amp;lt;div id=&amp;#34;nav&amp;#34;&amp;gt; London&amp;lt;br&amp;gt; Paris&amp;lt;br&amp;gt; Tokyo&amp;lt;br&amp;gt; &amp;lt;/div&amp;gt;  &amp;lt;div id=&amp;#34;section&amp;#34;&amp;gt; &amp;lt;h1&amp;gt;London&amp;lt;/h1&amp;gt; &amp;lt;p&amp;gt; London is the capital city of England. It is the most populous city in the United Kingdom, with a metropolitan area of over 13 million inhabitants. &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; Standing on the River Thames, London has been a major settlement for two millennia, its history going back to its founding by the Romans, who named it Londinium. &amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt;  &amp;lt;div id=&amp;#34;footer&amp;#34;&amp;gt; Copyright W3School.com.cn &amp;lt;/div&amp;gt;  &amp;lt;/body&amp;gt; &amp;lt;style&amp;gt; #header {  background-color:black;  color:white;  text-align:center;  padding:5px; } #nav {  line-height:30px;  background-color:#eeeeee;  height:300px;  width:100px;  float:left;  padding:5px; } #section {  width:350px;  float:left;  padding:10px; } #footer {  background-color:black;  color:white;  clear:both;  text-align:center;  padding:5px; } &amp;lt;/style&amp;gt;  HTML框架 通过使用框架，你可以在同一个浏览器窗口中显示不止一个页面。每份HTML文档称为一个框架，并且每个框架都独立于其他的框架。
使用框架的缺点——开发人员必须同时跟踪更多的HTML文档。
结构框架标签frameset定义如何将窗口分割为框架，每个frameset定义了一系列行与列。rows/columns的值规定了每行与每列占据屏幕面积。
&amp;lt;frameset cols=&amp;#34;25%,75%&amp;#34;&amp;gt;  &amp;lt;frame src=&amp;#34;frame_a.htm&amp;#34;&amp;gt;  &amp;lt;frame src=&amp;#34;frame_b.htm&amp;#34;&amp;gt; &amp;lt;/frameset&amp;gt; 上面的代码设置两列的框架集，第一列被设置占浏览器的25%，第二列占浏览器的75%。
假如一个框架有可见边框，用户可以拖动边框来改变它的大小。为了避免这种情况发生，可以在&amp;lt;frame&amp;gt;标签中加入：noresize=&amp;quot;noresize&amp;quot;。
不能将&amp;lt;body&amp;gt;&amp;lt;/body&amp;gt;标签与&amp;lt;frameset&amp;gt;&amp;lt;/frameset&amp;gt;标签同时使用。不过，假如你添加包含一段文本的&amp;lt;noframes&amp;gt;标签，就必须将这段文字嵌套于 &amp;lt;body&amp;gt;&amp;lt;/body&amp;gt;标签内。
 内联框架 内联框架用于在网页内显示页面，使用iframe标签，其中width和height可以设置宽度和高度，默认值是像素，也可以使用百分比来显示。
&amp;lt;body&amp;gt;  &amp;lt;iframe src=&amp;#34;http://localhost:1313/post/htm-primer/&amp;#34; width=&amp;#34;600&amp;#34; height=&amp;#34;600&amp;#34;&amp;gt;&amp;lt;/iframe&amp;gt; &amp;lt;/body&amp;gt; ifame标签的frameborder属性规定是否显示 iframe周围的边框，值为0表示移除边框。
frame可用作链接的目标（target）。链接的target属性必须引用 iframe的name属性。
&amp;lt;iframe src=&amp;#34;http://localhost:1313/post/htm-primer/&amp;#34; width=&amp;#34;600&amp;#34; height=&amp;#34;600&amp;#34; frameborder=&amp;#34;0&amp;#34;&amp;gt;&amp;lt;/iframe&amp;gt; &amp;lt;br/&amp;gt; &amp;lt;iframe src=&amp;#34;http://localhost:1313/post/htm-primer/&amp;#34; name=&amp;#34;iframe_a&amp;#34;&amp;gt;&amp;lt;/iframe&amp;gt; &amp;lt;p&amp;gt;&amp;lt;a href=&amp;#34;http://www.w3school.com.cn&amp;#34; target=&amp;#34;iframe_a&amp;#34;&amp;gt;W3School.com.cn&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;  背景颜色 &amp;lt;body&amp;gt;标签具有两个配置背景的属性，背景可以是颜色或者图片，分别是背景颜色属性bgcolor和背景图片属性background。bgcolor用于设置背景颜色；而background将背景设置为图片，其属性值为图片的URL。
&amp;lt;body bgcolor=&amp;#34;#000000&amp;#34;&amp;gt; &amp;lt;body bgcolor=&amp;#34;rgb(0,0,0)&amp;#34;&amp;gt; &amp;lt;body bgcolor=&amp;#34;black&amp;#34;&amp;gt; &amp;lt;body background=&amp;#34;clouds.gif&amp;#34;&amp;gt; &amp;lt;body background=&amp;#34;http://www.w3school.com.cn/clouds.gif&amp;#34;&amp;gt; &amp;lt;body&amp;gt;标签中的背景颜色（bgcolor）、背景（background）和文本（text）属性在最新的HTML标准（HTML4和XHTML）中已被废弃。W3C在其的推荐标准中已删除这些属性。
 HTML脚本 &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;script type=&amp;#34;text/javascript&amp;#34;&amp;gt; document.write(&amp;#34;&amp;lt;h1&amp;gt;Hello World!&amp;lt;/h1&amp;gt;&amp;#34;) &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;  HTML头部 head元素是所有头部元素的容器，head内部的元素可包含脚本，指示浏览器在何处可以找到样式表，提供元信息等。以下标签都可以加到&amp;lt;head&amp;gt;部分：
  &amp;lt;title&amp;gt;:定义浏览器工具栏中的标题。
&amp;lt;title&amp;gt;RichTextEditor&amp;lt;/title&amp;gt;   &amp;lt;base&amp;gt;: 为页面上所有的链接规定默认的地址或默认目标。
&amp;lt;head&amp;gt; &amp;lt;base href=&amp;#34;http://www.w3school.com.cn/images/&amp;#34; /&amp;gt; &amp;lt;base target=&amp;#34;_blank&amp;#34; /&amp;gt; &amp;lt;/head&amp;gt;   &amp;lt;link&amp;gt;: 定义文档与外部资源之间的关系。
&amp;lt;head&amp;gt; &amp;lt;link rel=&amp;#34;stylesheet&amp;#34; type=&amp;#34;text/css&amp;#34; href=&amp;#34;mystyle.css&amp;#34; /&amp;gt; &amp;lt;/head&amp;gt;   &amp;lt;meta&amp;gt;:定义文档的元数据信息，元数据用于规定页面的描述，关键词，修改时间等。
 &amp;lt;meta charset=&amp;#34;utf-8&amp;#34;&amp;gt;  &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0,maximum-scale=1.0, user-scalable=no&amp;#34; &amp;gt;  &amp;lt;meta content=&amp;#34;ie=edge&amp;#34; http-equiv=&amp;#34;X-UA-Compatible&amp;#34;&amp;gt;   &amp;lt;script&amp;gt;:用于定义客户端的脚本。
  &amp;lt;style&amp;gt;: 定义样式信息。
&amp;lt;head&amp;gt; &amp;lt;style type=&amp;#34;text/css&amp;#34;&amp;gt;  body {background-color:yellow}  p {color:blue} &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt;    HTML URL URL统一资源定位器，也被称为网址，其用于定位万维网上的文档（或其他数据）:
scheme://host.domain:port/path/filename  scheme: 定义因特网服务的类型，例如http,https,ftp,file等。 host: 定义域主机，http的默认主机是www。 domain: 定义因特网的域名，例如mmhui.top。 :post: 定义主机上的端口，http默认是80。 Path: 定义服务器上的路径，如果省略，则文档必须位于网站的根目录下。 filename:定义文档或者资源的名称。   URL的编码 URL只能使用ASCII字符集来通过因特网进行发送，但是URL中常常包含ASCII集合之外的字符，URL必须转换为有效的ASCII格式。
URL编码使用%其后跟随两位的十六进制的数来替代非ASCII字符。
 文档类型 HTML文档存在不同的版本，只有事先声明HTML文档的版本，浏览器才能完全正确的显示出HTML页面。!DOCTYPE可以用于声明HTML文档的版本：
html 5 文档 &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;!--html5文档--&amp;gt; html 4.1 文档 &amp;lt;!DOCTYPE HTML PUBLIC &amp;#34;-//W3C//DTD HTML 4.01 Transitional//EN&amp;#34; &amp;#34;http://www.w3.org/TR/html4/loose.dtd&amp;#34;&amp;gt; &amp;lt;!--html 4.1 文档--&amp;gt; xhtml 1.0 文档 &amp;lt;!DOCTYPE html PUBLIC &amp;#34;-//W3C//DTD XHTML 1.0 Transitional//EN&amp;#34; &amp;#34;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&amp;#34;&amp;gt; &amp;lt;!--xhtml 1.0文档--&amp;gt;  高度 function getInfo(){  let s = &amp;#34;&amp;#34;;  s &#43;= &amp;#34; 网页可见区域宽：&amp;#34;&#43; document.body.clientWidth;  s &#43;= &amp;#34; 网页可见区域高：&amp;#34;&#43; document.body.clientHeight;  s &#43;= &amp;#34; 网页可见区域宽：&amp;#34;&#43; document.body.offsetWidth &#43; &amp;#34; (包括边线和滚动条的宽)&amp;#34;;  s &#43;= &amp;#34; 网页可见区域高：&amp;#34;&#43; document.body.offsetHeight &#43; &amp;#34; (包括边线的宽)&amp;#34;;  s &#43;= &amp;#34; 网页正文全文宽：&amp;#34;&#43; document.body.scrollWidth;  s &#43;= &amp;#34; 网页正文全文高：&amp;#34;&#43; document.body.scrollHeight;  s &#43;= &amp;#34; 网页被卷去的高(ff)：&amp;#34;&#43; document.body.scrollTop;  s &#43;= &amp;#34; 网页被卷去的高(ie)：&amp;#34;&#43; document.documentElement.scrollTop;  s &#43;= &amp;#34; 网页被卷去的左：&amp;#34;&#43; document.body.scrollLeft;  s &#43;= &amp;#34; 网页正文部分上：&amp;#34;&#43; window.screenTop;  s &#43;= &amp;#34; 网页正文部分左：&amp;#34;&#43; window.screenLeft;  s &#43;= &amp;#34; 屏幕分辨率的高：&amp;#34;&#43; window.screen.height;  s &#43;= &amp;#34; 屏幕分辨率的宽：&amp;#34;&#43; window.screen.width;  s &#43;= &amp;#34; 屏幕可用工作区高度：&amp;#34;&#43; window.screen.availHeight;  s &#43;= &amp;#34; 屏幕可用工作区宽度：&amp;#34;&#43; window.screen.availWidth;  s &#43;= &amp;#34; 你的屏幕设置是 &amp;#34;&#43; window.screen.colorDepth &#43;&amp;#34; 位彩色&amp;#34;;  s &#43;= &amp;#34; 你的屏幕设置 &amp;#34;&#43; window.screen.deviceXDPI &#43;&amp;#34; 像素/英寸&amp;#34;; } 去除UIWebview底部的黑线   将UIWebView的opaque设置为false。
  设置UIWebView的背景颜色以清除颜色。
   </content>
    </entry>
    
     <entry>
        <title>CSS 入门</title>
        <url>https://iihui.github.io/post/css-primer/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>CSS</tag><tag>code</tag>
        </tags>
        <content type="html"> 关注点分离和混合 关注点分离 关注点分离的意思是：各种技术只负责自己的领域，不要混合在一起，形成耦合。对于网页开发来说，主要是三种技术分离。
  HTML:负责网页的结构，称为语义层。
  CSS:负责网页的样式，称为视觉层。
  JavaScript:负责网页的逻辑和交互，称为逻辑层或者交互层。
  也就是说不要写行内样式和行内脚本，例如下面的代码就很糟糕：
&amp;lt;h1 style=&amp;#34;color:red;font-size:46px;&amp;#34; onclick=&amp;#34;alert(&amp;#39;Hi&amp;#39;)&amp;#34;&amp;gt;  Hello World &amp;lt;/h1&amp;gt;  关注点混合 而React出现之后，这个原则就不适用了，因为React是组件结构，强制要求把HTML,CSS,JavaScript写在一起。
const style = {  &amp;#39;color&amp;#39;: &amp;#39;red&amp;#39;,  &amp;#39;fontSize&amp;#39;: &amp;#39;46px&amp;#39; };  const clickHandler = () =&amp;gt; alert(&amp;#39;hi&amp;#39;);  ReactDOM.render(  &amp;lt;h1 style={style} onclick={clickHandler} &amp;gt;  Hello, world!  &amp;lt;/h1&amp;gt;  document.getElementById(&amp;#39;example&amp;#39;) ); 上面代码写在一个文件中，封装了结构、样式和逻辑，完全违背了关注点分离的原则。但是，这种方式有利于组件的隔离。每个组件包含了所有需要用到的代码，不依赖外部，组件之间没有耦合，很方便复用。所以，随着React的走红和组件模式深入人心，这种关注点混合的新写法逐渐成为主流。
CSS 实例 CSS规则是由两个主要的部分构成：选择器以及一条或者多条声明，声明总是以分号结束。
* { margin:0; padding:0; } p { font-size:2em; } .info { background:#ff0; } p.info { background:#ff0; } p.info.error { color:#900; font-weight:bold; } #info { background:#ff0; } p#info { background:#ff0; } CSS的注释是由/*开始，以*/结束，用于解释代码，并可以随意编辑它，浏览器会忽略它。
 选择器 CSS的基本选择器包括：  通用选择器，匹配任何元素。 标签选择器，匹配所有使用该标签的元素。 class选择器，匹配所有class属性中包含info的元素。 id选择器，匹配所有id属性为footer的元素。   标签选择器 标签选择器，即将HTML中的标签作为选择器：
p { &amp;lt;!--标签选择器--&amp;gt;  line-height: auto; //行距自动变化  margin-top: 0px;  margin-bottom: 15px; /*24*/ }  html, body { &amp;lt;!--标签选择器--&amp;gt; 	padding: 0; 	margin: 0; 	font-family: Arial, Helvetica, sans-serif; }  id选择器 id选择器可以为标有特定的id的HTML元素指定特定的样式。HTML元素以id属性来设置id选择器，CSS中id选择器以#来定义：
#separatorDiv {  -webkit-user-select: none;  padding-left: 10px;  padding-right: 10px; }  #content {  outline: 0px solid transparent; } 需要特别注意的是ID属性不要以数字开头，否则ID在火狐浏览器中不起作用。
 class选择器 class选择器用于描述一组元素的样式，class选择器有别于id选择器，class可以在多个元素中使用。class选择器在HTML中以class属性表示, 在 CSS中，类选择器以一个点.号显示。在下例中，所有拥有center类的HTML元素均为居中:
.center {text-align:center;} 同样地，类名的第一个不能使用数字，否则无法在火狐浏览器中起作用。
参考资料
 innerHeight 和outerHeight 通过window.innerHeight和window.outerHeight可以得到整个窗口的高度，其中：
  innerHeight 是DOM视口的大小，包括滚动条。
  couterHeight 是整个浏览器窗口的大小，包括窗口标题，工具栏和状态栏等。
  在不支持window.innerHeight的浏览器中，可以读取documentElement和body的高度，它们的大小和window.innerHeight类似，但有区别。
document.documentElement.clientHeight document.body.clientHeight 其中documentElement是文档根元素——&amp;lt;html&amp;gt;标签，而body就是&amp;lt;body&amp;gt;标签。因此为了解决兼容性问题，常常使用如下代码：
var height = window.innerHeight || document.documentElement.clientHeight|| document.body.clientHeight; 实际上后面两种方式获取的高度和window.innerHeight是不一样的，这3个属性的值逐渐变小，具体来说:
  window.innerHeight包括整个DOM：内容，边框以及滚动条高度。
  documentElement.clientHeight不包括整个文档滚动条高度，但包括&amp;lt;html&amp;gt;元素的边框高度。
  body.clientHeight不包括整个文档的滚动条高度，也不包括&amp;lt;html&amp;gt;元素的边框高度，也不包括&amp;lt;body&amp;gt;的边框和滚动条高度。
   滚动高度 使用JS控制页面滚动时（如回到顶部），需要知道页面当前滚动到了哪里，以及将要滚动到哪里。这涉及到4个DOM属性，所有的DOM元素都有以下4个属性。
  clientHeight 内部可视区域的高度。
  offsetHeight 整个可视区域的高度，包括border和scrollbar在内。
  scrollHeight 元素内部的高度，包括溢出的部分。
  scrollTop 元素内容向上滚动了多少像素，如果没有滚动则返回0。
   参考资料
</content>
    </entry>
    
     <entry>
        <title>Xcode</title>
        <url>https://iihui.github.io/post/xcode-quick/</url>
        <categories>
          <category>tool</category>
        </categories>
        <tags>
          <tag>tool</tag>
        </tags>
        <content type="html"> 快捷键 键盘图标  ⌘——Command () ⌃ ——Control ⌥——Option (alt) ⇧——Shift ⇪——Caps Lock  快捷键  Command&#43;R 运行 Command&#43;B 编译 Command&#43;. 停止 Command &#43; Shift &#43; K 清除工程 Command &#43; K 清除控制台信息 Command &#43; N 新建文件 Command &#43; Shift &#43; N 创建新工程  导航栏   Command&#43;0~9 工程导航
  Command &#43; 0 快速打开实用面板
  Command &#43; 1 查看工程文件
  Command &#43; 2 版本控制导航
  Command &#43; 3 符号导航(类)
  Command &#43; 4 警告和错误导航
  Command &#43; 5 测试导航
  Command &#43; 6 调试导航
  Command &#43; 7 断点导航
  Command &#43; 9 报告导航
    Command &#43; Option &#43; 0 打开右侧导航栏
  Command &#43; Option &#43; T 打开工具栏
  Command &#43; Shift &#43; Y 打开底部导航栏
  Command &#43; Z 撤销
  Command &#43; Shift &#43; Z 反撤销
  查找与跳转  Command &#43; F 在当前文档中查找 Command &#43; Shift &#43; G 搜索上一处 Command &#43; G 搜索下一处 Command &#43; L 跳转到特定行 Command &#43; Shift &#43; O（字母） 快速查找打开类 Command &#43; Shift &#43; J 快速定位到当前类在项目中的位置 Command &#43; Shift &#43; 0(数字zero)查看帮助文档 Command &#43; Control&#43;↑/Command&#43;Control&#43;↓ 类文件和实现文件之间跳转 Command&#43;Control&#43;←/Command&#43;Control&#43;→ 回到上一个/下一个打开的页面 Command&#43;Option&#43;←/Command&#43;Option&#43;→ 收放方法体，即将方法体收起或者展开 Control &#43; 6 在当前类查找变量和方法 「键入方法或者变量名&#43;Enter跳转」  光标操作  Control &#43; F 向右一个字符 Control &#43; B 向左一个字符 Control &#43; P 向上一行 Control &#43; N 向下一行 Control &#43; A 跳到行首 Control &#43; E 跳到行尾 Control &#43; T 调换光标两边的字符 Control &#43; D 删除光标右侧的单个字符 Control &#43; K 删除本行剩余的字符  整体位移  Command &#43; [ 选中的代码整体左移 Command &#43; ] 选中的代码整体右移 Command &#43; Option &#43; [ 选中的代码整体上移 Command &#43; Option &#43; ] 选中的代码整体下移  补充   Command &#43; Option &#43; 点击桌面上空白的区域:把除Finder窗口以外的所有窗口隐藏起来，直接显示桌面。分别点击Dock栏上各个相关应用程序图标就可以解除窗口的隐藏状态了。
  Command &#43; Option &#43; H: 把所有已打开的程序窗口（不包括当前正在运行的应用程序窗口）最小化到Dock栏上。注意不是关闭哦，是最小化。如果需要把程序窗口恢复到屏幕上，直接点击相应的应用程序图标就可以了。
  编译选项 在schema中添加DYLD_PRINT_STATISTICS可统计启动时间。
参考资料1 参考资料2 参考资料3
Interface Builder IBOutlet Swift编译器在看到@IBOutlet声明时不会进行任何特殊处理。它存在的意义仅仅是提示XCode这个属性需要关联到storyboard或nib文件中的对象上。
从storyboard中创建@IBOutlet变量或者操作方法，有两种方式。第一种是先在storyboard中选中某个对象，然后同时按住Control键和鼠标左键并拖动光标到辅助编辑器上，然后松开鼠标左键，便可得到如下界面：
第二种方法也是先在storyboard中选中某个对象，然后按住鼠标右键，接着拖动光标到辅助编辑器上，最后放开鼠标右键，即可得到上图所示的界面。
复制对象 除了从对象库中拖出一个对象，也可以按住option键不放，并拖动想要复制的对象，以生成副本。按住option键是告诉Interface Builder创建一个被拖动对象的副本。
不可见对象 如果有不可见的用户界面元素，比如空白标签，但又希望能看到它们在storyboard中的位置，可以设置Editor→Canvas→Show Bounds Rectangles，便可看到空白标签：
约束设置 打开视图结构文档缩略图，选中要设置的对象，按住鼠标右键同时拖动到某个对象上，然后松开鼠标右键，便可得到一个设置约束的灰色的浮动框，点击任意一个都会生效：
在上图中，为了一次可以设置多个约束，需要一直按住shift键，然后点击需要设置的约束，便可设置多个约束，效果如下图所示：
Xcode Source Editor 如果在System Preferences--&amp;gt;Extensions下没有Xcode Source Editor。参考此篇文章，最快的方式是将Xcode重命名，然后再改回名字为Xcode，或者把Xcode移出Application文件夹，然后再移回来即可。
</content>
    </entry>
    
     <entry>
        <title>OC 入门</title>
        <url>https://iihui.github.io/post/oc-tour/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>OC</tag><tag>iOS</tag>
        </tags>
        <content type="html">  Objective-C简称OC， 是C语言的严格超集——任何C语言程序不经过修改都可以直接通过OC的编译器，在OC中使用C语言代码也是完全合法的。OC被描述为覆盖在C语言上的一层，因为OC的原意就是在C语言的主体上加入面向对象的特性。
 文件扩展名    文件扩展名 类型和作用     .h 头文件，包含类，类型，函数和常数声明   .m 源代码文件，典型的源代码文件扩展名，可以包含OC和C代码   .mm 源代码文件，带这种扩展名的源代码文件，除了可以包含OC和C代码以外，还可以包含C&#43;&#43;代码    源代码中需要包含头文件的时候，可以使用标准的#include编译选项，也可以使用#import选项，但是OC中使用#import可以确保相同的文件只包含一次，因此一般使用#import来引入头文件。
 语法 Objective-C最大的特色使用Smalltalk的消息传递模型。在OC中与其说是对象调用方法，不如说向对象传递消息更为精确。
调用方法 在OC中，调用方法视为向对象发送消息，所有方法(类方法和实例方法)都被视为对消息的回应。
所有消息的处理直到运行时（runtime）才会动态决定，并交由类自行决定如何处理收到的消息。也就是说，一个类不保证一定会回应收到的消息，如果类收到了一个无法处理的消息，程序只会抛出异常，不会出错或崩溃。
在OC中发送消息的语法为：
[obj method: argument]; //C&#43;&#43;对应的是obj.method(argument); 一个例子:
[car fly] 上面的例子典型的C&#43;&#43;意义解读是:调用car类的fly方法。若car类里头没有定义fly方法，那编译肯定不会通过。但是OC里，应当解读为:发送一个fly的消息给car对象，fly是消息，而car是消息的接收者。car收到消息后会决定如何回应这个消息，若car类别内定义有fly方法就运行方法内之代码，若car内不存在fly方法，则程序依旧可以通过编译，运行期则抛出异常。
因此OC天生具备鸭子类型的动态类型绑定能力，运行期间才处理消息，允许发送未知消息给对象，可以发送消息给整个对象集合而不需要检查每个对象的类型，也具备消息转发机制。同时空对象nil接受消息后默认不做任何回应，所以发送消息给nil也不用担心崩溃。
 字符串 作为C语言的超集，OC支持C语言字符串方面的约定：单个字符被单引号包括，字符串被双引号包括。但是，大多数OC通常不使用C语言风格的字符串，大多数框架把字符串传递给NSString对象NSString类提供了字符串的类包装，包含了所有你期望的优点——包括对保存任意长度字符串的内建内存管理机制，支持Unicode，printf风格的格式化工具等。
因为这种字符串使用的非常频繁，OC提供了一个助记符可以方便地从常量值创建NSString对象，即在普通的双引号字符串前放置一个@符号:
NSString* myString = @&amp;#34;My String\n&amp;#34;; NSString* anotherString = [NSString stringWithFormat:@&amp;#34;%d %s&amp;#34;, 1, @&amp;#34;String&amp;#34;];  // 从一个C语言字符串创建Objective-C字符串 NSString* fromCString = [NSString stringWithCString:&amp;#34;A C string&amp;#34; encoding:NSASCIIStringEncoding];  类 OC类的说明包含两个部分：定义(interface)和实现(implementation)。类定义包含了类声明、实例变量的定义以及相关的方法（包括类方法和实例方法）；实现则包含了类方法的实际代码。
类的声明总是以@interface编译选项开始，由@end编译选项结束。类名之后的（用冒号分隔）是父类的名字。类的变量声明在被大括号包含的代码块中。变量块后是类声明的方法的列表，每个变量和方法声明都以分号结尾。
 Interface 定义部分，以关键字@interface作为开始，@end作为结束，其中定义的实例变量的默认权限是protected：
@interface MyObject : NSObject {  int memberVar1; // 实例变量，在定义部分声明的实例变量的默认访问权限是protected  id memberVar2; //id 类型表示任意类型 }  &#43;(return_type) class_method; // 类方法  -(return_type) instance_method1; // 实例方法 -(return_type) instance_method2: (int) p1; -(return_type) instance_method3: (int) p1 andPar: (int) p2; @end 方法前面的&#43;或者-号代表函数的类型：加号&#43;代表类方法（class method），不需要实例就可以调用，与C&#43;&#43;的静态函数（static member function）相似；减号-表示一般的实例方法（instance method）。
下面是与OC对应的C&#43;&#43;的声明：
class MyObject : public NSObject { protected:  int memberVar1; // 实体变量  void * memberVar2;   public:  static return_type class_method(); // 类方法   return_type instance_method1(); // 实例方法  return_type instance_method2( int p1 );  return_type instance_method3( int p1, int p2 ); } OC定义一个新方法时，名称内的冒号代表传递参数：
- (void) setColorToRed: (float)red Green: (float)green Blue:(float)blue; /* 声明方法*/  [myColor setColorToRed: 1.0 Green: 0.8 Blue: 0.2]; /* 调用方法*/ 上面这个方法的签名是setColorToRed:Green:Blue。每个冒号后面都带着一个float类别的参数，分别代表红绿蓝三色。
 Implementation 实现块包含了公开的方法的实现，以及定义私有变量以及方法，以关键字@implementation作为区块的开始，@end结尾。
@implementation MyObject {  int memberVar3; //私有实例变量 }  &#43;(return_type) class_method {  .... //方法的实现部分 } -(return_type) instance_method1 {  .... } -(return_type) instance_method2: (int) p1 {  .... } -(return_type) instance_method3: (int) p1 andPar: (int) p2 {  .... } @end   不只Interface区域可定义实体变量，Implementation区块也可以定义实体变量。
  两者的差别在于访问权限的不同，Interface区块内的实体变量默认权限为protected。而在implementation区域定义的实体变量则默认为private，故在Implementation区块定义私有成员更匹配面向对象之封装原则，因为类的私有信息就不需暴露在公开interface(.h文件)中。
   创建对象 OC创建对象需通过alloc以及init两个消息,alloc的作用是分配内存，init是初始化对象。init与alloc都是定义在NSObject里的方法，父对象收到这两个信息并做出正确回应后，新对象才创建完毕。
MyObject * my = [[MyObject alloc] init]; 在OC 2.0里，若创建对象不需要参数，则可以直接使用new
MyObject * my = [MyObject new];  方法 在OC中类可以声明两种类型的方法：实例方法和类方法。实例方法在类的一个具体实例的范围内执行，即要调用实例方法前，需要首先创建类的实例，而类方法不需要创建一个实例。
方法声明包括方法类型标识符，返回值类型，一个或多个方法标识关键字，参数类型和名信息，下图展示 insertObject:atIndex: 实例方法的声明。
  声明由一个减号-开始，这表明这是一个实例方法。方法实际的名字(insertObject:atIndex:)是所有方法标识关键的级联，包含了冒号。
  冒号表明了参数的出现，如果方法没有参数，你可以省略第一个(也是唯一的)方法标识关键字后面的冒号。
  当需要调用一个方法时，即传递消息给对应的对象，这里的消息是指方法标识符以及传递给方法的参数信息。
  发送给对象的所有消息都会动态分发，这样有利于实现OC的多态行为。
  如果子类定义了和父类具有相同标识符的方法，那么子类首先收到消息，然后选择把收到的消息转发（也可以不转发）给他的父类。
  消息被中括号包括。中括号里，接收消息的对象在左边，消息（包括消息需要的任何参数）在右边。例如，给myArray变量传递消息insertObject:atIndex:消息，需要使用如下的语法：
[myArray insertObject:anObj atIndex:0]; 为了避免过多地声明本地变量保存临时结果，OC允许使用嵌套消息，每个嵌套消息的返回值可以作为其他消息的参数。例如，有另外一个对象叫做myAppObject有方法可以访问数组对象，以及插入一个对象到一个数组，就可以将前面的例子写成如下的形式：
[[myAppObject getArray] insertObject:[myAppObject getObjectToInsert] atIndex:0]; 消息也可以传递给类本身，当给类发消息的时候，指定的方法必须为类方法。类方法的典型用途是用做创建新类实例的工厂方法，或者是访问类相关的共享信息的途径。
NSMutableArray* myArray = nil; // nil 基本上等同于 NULL  // 创建一个新的数组，并把它赋值给 myArray 变量 myArray = [NSMutableArray arrayWithCapacity:0]; 上面是一个类方法作为一个工厂方法来使用。arrayWithCapacity是NSMutableArray类的类方法，为类的新实例分配内容并初始化，然后返回。
 属性 属性使用一个等式来表示：@property = 成员变量 &#43; getter &#43; setter，即一个属性包含了一个成员变量以及该成员变量的getter和setter方法：
@property = 成员变量 &#43; getter &#43; setter 为什么OC要添加属性，这就要从成员变量说起。成员变量的写法，一般如下：
@interface Person :NSObject {  int _age; //定义成员变量，_下划线开始是苹果的编程规范 } @end 成员变量具有如下的特点：
  只能通过对象来访问
  成员变量离不开类，离开了类就不是成员变量
  成员变量不能在定义的时候同时进行初始化
  成员变量存储在当前对象对应的堆空间中，不会自动释放，只能手动释放
  成员变量前加_是苹果的编程规范
  在OC中.访问符是为getter和setter服务的，而在OC中成员变量默认是没有getter和setter方法，因此在类外无法直接访问。如果需要访问就要自定义的getter和setter方法，然后通过自定义的getter和setter方法来访问成员变量。
因此，苹果为了大众方便，在iOS 5以后使用了属性@property。定义属性时会自动将getter和setter方法实现了，你无须再手动去实现getter和setter方法。当然了，如果你需要在getter和setter方法中想要做点事情，直接重写就好。
顺带地，@property还会生成一个成员变量，变量名就是_属性名。当然这个名字你也可以修改，是在.m文件中的implements中去定义：
@synthesize name = myName; 参考文献 参考文献
属性提供了一些关键字用以控制setter和getter的实现细节, 这些关键字我们称为属性的属性(attribute)，总共有三类:
 读写性readonly,readwrite。其中readonly表示只能读取, 不能写入（系统默认是可读写的）  @property (readonly)NSString *name; 表示只能读取 @property (readwrite)NSString *name；表示可以读写  原子性控制atomic，nonatomic。其中atomic表示属性对应的setter和getter方法在多线程访问下绝对安全。而nonatomic表示不做线程安全处理，只是普通的setter和getter方法。使用atomic, 需要不断地对setter和getter加锁解锁以保证线程安全, 会很占用系统资源, 降低系统性能。  @property(readwrite,nonatomic)NSString *name;表示name 可读写, 无原子性   语义设置assign, retain, copy,strong,weak。这5个属性决定了setter方法中是如何赋值的。
 其中assign实现setter和getter是直接赋值，计数器不会加一，简单的赋值方法，默认赋值方式，适合基本数据类型。相当于说两个对象指向同个内存区，一个地方的变了，其他的也跟着改变。  @property(nonatomic, assign) NSInteger age; -(void)setName:(NSInteger )age {  _age = age; } -(NSInteger )age {  return _age; }   strong : 表示强引用关系，即拥有对象的所有权。
  weak : 表示弱引用，不拥有对象的所有权，当目标对象被销毁之后，属性值会被自动设为nil;
  ​copy(拷贝)：把原来的对象拷贝过来，计数器会加一，比如原来对象的地址为0x01 ,拷贝过来的对象的地址为0x02。用于希望保持一份传入值的拷贝，而不是值自身的情况，即把原来的对象完整的赋值到另外一地方，重新加载一内存区，一个地方变了不影响另一个地方的对象。是内容拷贝。
  ​retain(保留)：这种方式传递的是指针，原有的对象和被赋值的对象的地址是一样的。释放旧的对象,将旧对象的值赋予输入对象,再提高输入对象的索引计数为1。是指针拷贝。
     设计模式 设计模式的两个目标
 可复用性：得到较高的生产效率。 可扩展性：当用户的需求发生变化时，做很少的变化就能够满足用户的需求。  单例模式 单例设计模式：自始至终一个类只有一个对象实例。Cocoa中主要的单例类有：
 UIApplication NSNotificationCenter NSUserDefaults NSFileManager NSBundle  OC中单例模式： //singleton.h @interface Singleton:NSObject &#43; (Singleton *) sharedManager @property (nonatomic,strong) NSString * singletonData; @end  //singleton.m @implemention Singleton @synthesize singletonData = _singletonData; static Singleton * sharedManager = nil &#43; (Singleton *) sharedManager{  static dispatch_once_t once;  dispatch_once(&amp;amp;once,^{  sharedManager = [[self alloc] init];  });  return sharedManager; } 单例设计模式使用场景：
 在整个过程中只需要一个实例保存状态。 无状态对象(只有方法，没有属性）  单例模式时，访问对象时，修改状态的时候要十分小心（它就像一个全局变量）。
UIApplication  sharedApplication方法：它是创建和获得UIApplication实例的实例方法。 openURL:方法：该方法可以打开一些内置的iOS应用，其中包括打开浏览器、打开Google地图、拨打电话、发送短信和发送Email等。  [[UIApplication sharedApplication] openURL: [NSURL URLWithString:@&amp;#34;http://www.baidu.com&amp;#34;]];  委托模式 委托：某个对象指定另一个对象处理某些特定任务（某些方法的实现）的设计模式。例如当没空的时候委托别人帮忙买火车票，乘车人、乘车日期以及出发地和目的地就是协议「规定」（协议通俗的说就是某种规定，如果能执行这种规定就说遵守了某个协议）。
在上面的类图中带空心三角形的实线表示继承；带空心三角形的虚线表示实现接口；带箭头的实线表示单向关联（has）。上面的意思是通用类有一个叫做“委托协议”的成员，它被赋值为（绑定到）为一个委托对象实例，而委托对象实现了委托协议中的相关方法。然后通过这个委托对象实例来做相应的动作（完成委托的事情）。
  委托需要做的工作有： 1.1 定义协议与协议中的方法 1.2 声明委托变量 1.3 设置代理（委托变量绑定到哪个对象实例） 1.4 通过委托变量调用委托方法
  代理需要做的工作有: 2.1 遵循协议（在类的定义时声明遵循相应的协议） 2.2 实现委托方法（实现协议中的方法）
  场景 场景：Boss准备举行一场party，准备邀请Atany来参加party，但是Boss没空写email给Atany，于是他委托Henry与Mary来做这件事情。
在YGViewController.h（根控制器，程序第一个界面，类似于Boss）中首先定义协议，接着声明委托变量（Boss并没有实现inviteToMyParty这个方法，他没有自己去邀请）：
#import &amp;lt;UIKit/UIKit.h&amp;gt; @protocol InviteDelegate -(void)inviteToMyParty:(NSString *)personName;//1.1定义协议与方法 @end  @interface YGViewController : UIViewController @property (assign,nonatomic) id&amp;lt;InviteDelegate&amp;gt; delegate;//1.2声明委托变量 - (IBAction)ClickByMary:(id)sender;//委托给Mary - (IBAction)ClickByHenry:(id)sender;//委托给Henry @end 然后再设置代理，最后通过委托变量调用委托方法：
- (IBAction)ClickByMary:(id)sender {  Mary *mary = [[Mary alloc]init];  self.delegate = mary;//1.3设置代理  [self.delegate inviteToMyParty:@&amp;#34;atany&amp;#34;];//1.4通过委托变量调用委托方法 } - (IBAction)ClickByHenry:(id)sender {  Henry *henry = [[Henry alloc]init];  self.delegate = henry;//1.3设置代理  [self.delegate inviteToMyParty:@&amp;#34;atany&amp;#34;];//1.4通过委托变量调用委托方法 } BOSS可以选择不同的代理（Henry与Mary）来做这件事情（inviteToMyParty），而自己却不用做。以Henry为例，首先遵循协议，然后实现协议中的委托方法：
#import &amp;lt;UIKit/UIKit.h&amp;gt; #import &amp;#34;YGViewController.h&amp;#34;  @interface Henry : UIViewController &amp;lt;InviteDelegate&amp;gt;//2.1遵循协议 @end  -(void)inviteToMyParty:(NSString *)personName{  NSString *hello = [NSString stringWithFormat:@&amp;#34;Hello,%@&amp;#34;,personName];  NSString *str = [NSString stringWithFormat:@&amp;#34;Hey Boy,this is Henry,Come to our party Please!!&amp;#34;];  UIAlertView *alert = [[UIAlertView alloc]initWithTitle:hello message:str delegate:self cancelButtonTitle:@&amp;#34;OK&amp;#34; otherButtonTitles:nil];  [alert show]; }  观察者设计模式 观察模式的定义
有很多观察者正在观察对象的变化，当对象发生时会通知所有的观察者
KVO是观察对象属性的变化 通知机制观察的是对象的变化
NSNotification 可以通过object（NSObject） 和 userInfo（NSDictionary） 来回传数据
投送通知：postNotification
KVO要搞清楚谁是观察者，谁是被观察者
模态视图：关闭不能通过故事板，只能通过代码实现
runtime  runtime是一套存C语言的API，OC代码最终都会被编译器转为运行时代码，通过消息机制决定函数的调用方式。
 消息机制的基本原理 在OC语言中，对象方法调用都是类似[receiver selector]的形式，其本质：让对象在运行时发送消息的过程。
方法调用[receiver selector]分为两个过程：
  编译阶段。[receiver selector]方法被编译器转化，分为两种情况
 不带参数的方法被编译为objc_msgSend(receiver,selector) 带参数的方法被编译为objc_msgSend(receiver,selector,org1,org2,...)    运行阶段：消息接收者receiver寻找对应的selector，也分为两种情况
 接收者能找到对应的selector，直接执行receiver对象的selector方法 接收者找不到对应的selector，消息被转发或者临时向接收者添加这个selector对应的实现内容，否则崩溃。    总而言之，OC调用方法[receiver selector]，编译阶段确定了要向那个接收者发送message消息，但是接收者如何响应决定于运行时的判断。
</content>
    </entry>
    
     <entry>
        <title>swift中的方法</title>
        <url>https://iihui.github.io/post/swift-method/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  在Swift中方法是关联了特定类型的函数。类，结构体，枚举类型都能定义实例方法，方法封装了给定类型特定的任务和功能。
 实例方法 实例方法是属于特定实例（类实例、结构体实例或者枚举实例）的函数。实例方法只能在类型的具体实例里被调用，不能独立于实例而被调用，也就是说不能直接使用类名直接调用。
class Counter {  var count = 0  func increment() {  count &#43;= 1  }  func increment(by amount: Int) {  count &#43;= amount  }  func reset() {  count = 0  } } 异变方法 在Swift中结构体和枚举是值类型。默认情况下，值类型属性不能被自身的实例方法修改。如果需要改变结构体或者枚举类型的属性，应该将实例方法进行异变。即在实例方法的func关键字前添加mutating关键字：
struct Point {  var x = 0.0, y = 0.0  mutating func moveBy(x deltaX: Double, y deltaY: Double) {  x &#43;= deltaX  y &#43;= deltaY  } } 但是，不能在常量结构体类型里调用异变方法，因为常量代表自身属性不能被改变，即使这些属性是变量属性：
let fixedPoint = Point(x: 3.0, y: 3.0) fixedPoint.moveBy(x: 2.0, y: 3.0) //编译器会报错，因为常量结构体里的数据不能被修改，而moveBy声明是异变的，所以矛盾，编译器会报错。 self属性 每一个类的实例都隐含一个叫做self的属性，它完全和实例本身相等，可以使用self来调用实例的方法或者使用实例的属性。
struct Point {  var x = 0.0, y = 0.0  func isToTheRightOf(x: Double) -&amp;gt; Bool {  return self.x &amp;gt; x //形参的优先级别高于实例属性  } } 枚举的异变方法可以设置隐含的self属性为相同枚举里的不同成员。也就是在枚举类型中其异变的方法中，self也是可以变换的：
enum TriStateSwitch {  case off, low, high  mutating func next() {  switch self {  case .off:  self = .low  case .low:  self = .high  case .high:  self = .off  }  } } 类型方法 类型方法是用来定义类型本身调用的方法，通过在func关键字前加static来实现。类还可以用关键字class来允许子类重写父类的方法实现。
在类方法中，隐含的self指向的是类本身而不是类的实例。同样在类型方法中，有self访问的属性与同名的形参相比，优先级低一些：
struct Point{  static var x = 12  static func test(x:Int)-&amp;gt;Bool{  return self.x &amp;gt; x  } } Modern Concurrency 基于闭包的代码很多都类似如下：
struct UserInfo: Codable {  var username: String  var avatar_url: String }  class UserAPI {   func fetchUserInfo(  completionHandler: @escaping (_ userInfo: UserInfo?, _ error: Error?) -&amp;gt;  Void  ) {   let url = URL(  string:  &amp;#34;https://www.andyibanez.com/fairesepages.github.io/books/async-await/user_profile.json&amp;#34;  )!  let session = URLSession.shared  let dataTask = session.dataTask(with: url) { data, response, error in  if let error = error {  completionHandler(nil, error)  } else if let data = data {  do {  let userInfo = try JSONDecoder().decode(UserInfo.self, from: data)  completionHandler(userInfo, nil)  } catch {  completionHandler(nil, error)  }  }  }  dataTask.resume()  } }   let userApi = UserAPI() userApi.fetchUserInfo { value, error in  if let userInfo = value {  debugPrint(userInfo.username, userInfo.avatar_url)  } else {  debugPrint(error?.localizedDescription ?? &amp;#34;无错误信息&amp;#34;)  } } 上面代码对于新学者来说，看起来可能有些吃力，但对于有经验的开发者来说，一看就知道这个方法是在做什么，即发送请求获取用户相关信息。
Introducing async/await 在过程式编程中，代码是按顺序从上往下执行。若上面代码能通过函数的返回语句来传递数据，而不是通过闭包传递数据，岂不是更好？这正是新系统能做到的。如果去掉闭包，可以编写更自然的代码，更容易地表达我们的意图，让接手的开发人员更清楚地掌握代码是做什么的。
The async keyword 新系统的核心是async和await关键字，理解如何使用这两个关键词对于使用新系统的其余部分至关重要。可以异步运行的函数或可以与其它函数同时运行的函数，在这些函数的返回类型前添加async关键字，就是告诉编译器，这个函数是异步的。
func fetchUserInfo() async throws -&amp;gt; UserInfo {  /*...*/  return UserInfo(username: &amp;#34;Test&amp;#34;, avatar_url: &amp;#34;test&amp;#34;) } 上面声明中可以看到completionHandler已经没了，如同在回调completionHandler中返回Error一样，上面定义的函数也可能抛出Error。将fetchUserInfo标记为抛出错误，即在async后面添加关键字throws，可以使得错误处理更自然。函数的返回值类型标记为非可选的UserInfo，也可以省去解包的步骤。
为了能够调用async关键字标记的函数，我们需要一个concurrent context（并发上下文），有几种方式创建这种并发上下文：
  标记为async的函数体是一个concurrent context。若一个函数未使用async标记，则它不能直接调用async函数，下面代码会出现编译错误：
func authenticateAndFetchProfile() {  // ... 	let userProfile = try await fetchUserInfo() //... }   但是，若没有并发上下文会怎样呢？在代码调用层次的某处，可能会遇到无并发上下文来运行async标记的异步函数。幸运的是，有一种创建异步上下文的方法可以帮助我们解决这个问题，即创建一个Task对象。
Task（任务）是一个功能非常强大的对象，可以用它来进行多线程处理，还能对它们进行一些控制，比如取消。现在，我们只使用Task来创建并发上下文，Task有一个带有闭包的初始化器，这个闭包本身就是一个并发上下文：
func authenticateAndFetchProfile() {  Task { //...  let userProfile = try await fetchUserInfo() //...  debugPrint(userProfile.username, userProfile.avatar_url)  } } 上面示例代码中，虽然函数authenticateAndFetchProfile没有被标记为async，但因为在函数体内创建了一个Task，所以在创建Task的闭包中可以调用async标记的函数。
The await keyword 每一次async函数的调用都必须在某个点有与之对应的await关键字。需要注意的是，await本身具有特殊的语义，它不仅仅是用来调用async函数的语法。
如果在代码执行过程中遇到await关键字，我们的程序可能选择挂起当前正在执行的函数。因为这个原因，await关键字通常也被称为挂起点。但请注意，这是系统可能会做出的决定，我们无法主动进行控制。
当我们说可能会挂起时，意思是当前的执行将被暂停，而调用的async函数将会在其它地方继续执行。如果当前函数被挂起，其后的代码将暂停执行（从调用async函数开始，之后的所有代码均不会执行），直到调用的async函数执行完成后才会恢复。
func authenticateAndFetchProfile() async {  do {  //...  print(&amp;#34;Fetching user info&amp;#34;)  let userProfile = try await fetchUserInfo()  print(&amp;#34;User info fetched&amp;#34;) //...  } catch {  debugPrint(error.localizedDescription)  } } 上面代码执行后，首先会打印字符串Fetching user info，过一小会儿才打印User info fetched，则正是代码语句的书写顺序。而且，我们成功地删除了闭包且不需要任何其它额外的操作就实现按顺序输出。
在await调用挂起期间发生的事情是：我们将控制权交还给系统，因此我们无法控制何时能够再次获得控制权。调用fetchUserInfo()的同一个线程将被释放去做其它工作，具体做什么工作无需我们关心，因为这些是由系统调度处理的。其它工作可能是我们应用内的另一个任务，或者是系统外部的任务。在我们获得控制权之前，无法继续执行代码中的任何语句。
因此，上面示例代码将按照书写顺序执行打印语句，但打印User info fetched可能需要一点时间，因为我们已经将调用线程交给了系统，获取用户信息是一个耗时任务。当用户信息获取完成时，fetchUserInfo函数调用将到达其函数体中的return语句，这个return语句将控制权返回给我们。但请注意，系统将决定何时将控制权交还给我们，但这并不是在遇到return语句后立即发生。系统可能正在执行其它并发任务，它需要处理高其它优先级的问题，然后才会交还控制权给我们。
总之，在遇到一个挂起点（await关键字）后，如果系统选择挂起，那么它下面的内容将不会执行，直至控制权重新交还给我们。在挂起期间，系统会利用该线程做其它工作。
任何在await调用之后发生的事情被称为continuation，控制权恢复后，我们需要继续做这些事情，这很重要。因为我们可能在不同线程重新拿到控制权，即await下面的语句可能在不同的线程中运行。这意味着在上面示例代码中，第一个打印语句可能在一个线程中运行，而第二个打印语句可能在一个完全不同的线程中运行。
使用async/await并不能让我们免于在主线程上做UI工作，所以如果需要更新UI，需要将这项工作推迟到主线程上。在实践中，这是通过一个名为@MainActor的系统级全局actor来完成的。
Using async/await 苹果所有基于闭包的并发API都有一个async/await版本，可以在iOS 15及更高版本上使用。虽然使用Xcode 13.3可以在iOS 13及更高版本上使用async/await，但苹果原生支持的async/await版本API仅在iOS 15及以上版本中可用。
定义async函数时，可以使用throws标记。一般来说，如果正在建模可能抛出错误或返回有效值的代码，可以简单地将函数标记为throws，然后将结果类型标识为调用成功后能得到的对象。本质上，原来的completionHandler闭包内容已经移动到函数签名中。
func fetchUserInfo() async throws -&amp;gt; UserInfo {  // } 一开始就能看出，async/await能帮我们写出更语义化的代码。在Swift中，可以在函数中抛出错误，但令人惊讶的是，很多开发者并不这样做。这是因为大多数应用本质上是并发的（例如，处理网络请求），而且我们无法以一种符合Swift风格的方式处理闭包中的错误，因此只能将错误作为闭包的一部分返回。使用async/await后，函数签名更易读，也更具self-documented（自文档化）。
我们开始使用苹果在iOS 15中提供的async/await的API。所有返回数据的URLSession方法都有async/await变体。到目前为止一切顺利，但下面这段代码还不能编译，因为在函数体中没有返回任何内容。
func fetchUserInfo() async throws -&amp;gt; UserInfo {  let url = URL(string: &amp;#34;https://www.andyibanez.com/ fairesepages.github.io/books/async-await/user_profile.json&amp;#34;)!  let session = URLSession.shared  let (userInfoData, response) = try await session.data(from: url) } 我们需要理解这样一个事实：上面对session.data(from:)的调用已不再接受闭包，也不再需要调用resume()了，只要调用data(from:)的async版本，任务就会自动开始。现在需要将JSON解析成可以使用的对象并返回。
下面是完整的aync版本的fetchUserInfo。因为使用了async和await，我们将原本15行的代码简化为了5行，能够真正体会到async/await的优雅。
func fetchUserInfo() async throws -&amp;gt; UserInfo {  let url = URL(string: &amp;#34;https://www.andyibanez.com/fairesepages.github.io/books/async-await/user_profile.json&amp;#34;)!  let session = URLSession.shared  let (userInfoData, response) = try await session.data(from: url)  let userInfo = try JSONDecoder().decode(UserInfo.self, from: userInfoData)  return userInfo } 因为Swift支持方法重载，fetchUserInfo()和fetchUserInfo(completionHandler:)可以并存。通过将函数标记为async，我们创建了一个并发上下文，在其中可以调用其它async函数，并且fetchUserInfo的调用者本身需要在并发上下文中（要么将它自己标记为async，要么在Task {}中调用）。
当代码执行到let (userInfoData, response) = try await session.data(from: url)时，代码会被挂起，此时执行它的线程可以去做其它工作（其它工作可能与我们的应用程序无关）。由于fetchUserInfo函数被挂起，下面将数据转换为对象的那一行代码也不会执行，因为它依赖于上面那行返回的数据。
当session.data(from:)完成了下载，它会通知系统已准备好将结果返回给调用者。系统最后通过返回结果并将其赋给(userInfoData, response)变量，来通知我们的应用程序。系统返回结果并赋值给两个变量后，代码会按照编写顺序继续执行，即解析JSON，然后将该对象返回给调用者，这是最纯粹的过程化编程。
当然，代码也有可能抛出错误。当设备没有联网或服务器宕机时，代码会抛出异常。如果出现错误，我们可以直观地知道会发生什么，因为它和非异步的情况完全一样：session.data(from:) 会抛出一个错误（遵循Error协议的对象），且其下面的所有代码行都不会被执行。因此，在上面示例代码中，调用者必须使用try、try? 或 try! 调用fetchUserInfo()（在这种情况下，使用try!是完全不推荐的）。
上面示例中session.data(from:)返回一个元组，因此我们可以将其解构为两个不同的变量。因为没有使用 response变量，可以用下划线来代替，但我在那里放上response是为了表明，如果API有其他要求（比如需要检查 headers，或者以不同的方式处理HTTP状态码），可以使用这个类型为URLResponse的变量。需要将其转换为HTTPURLResponse才能从中获取有意义的信息。
async get properties 关键字async/await并不局限于函数调用，还可以在只读计算属性中使用它。下面示例代码展示了如何做到这一点的：
var userInfo: UserInfo {  get async throws {  let url = URL(string: &amp;#34;https://www.andyibanez.com/ fairesepages.github.io/books/async-await/user_profile.json&amp;#34;)!  let session = URLSession.shared  let (userInfoData, _) = try await session.data(from: url)  let userInfo = try JSONDecoder().decode(UserInfo.self, from: userInfoData)  return userInfo  } } 在声明计算属性时可以同时使用async和throws标记。但一般不推荐这样使用，除非已实现了某种缓存机制。否则若频繁地访问该属性，因为存在异步调用会导致访问显著的延迟。可能在某些情况下避免缓存机制是有意义的，但必须逐个案例进行分析。
async/await in iOS 13 and iOS 14 之前已经提到，虽然async/await在iOS 13和iOS 14上可以使用，但在这两个版本上苹果并没有提供使用async/await的系统API。你可能会疑惑，如果苹果在这些版本中一开始就没有提供任何async/await的系统API，那为什么还要在这些版本中支持async/await呢？如果需要在iOS 13和iOS 14中支持async/await版本的系统API，可以使用Continuations来实现系统方法的async/await变体。
Continuations Continuations很有用，因为利用它不仅能够将基于闭包的代码改为async/await版本，还能将第三方库和框架的代码进行封装。使用Continuations能够帮助我们创建一致的代码库，在必要时只使用async/await版本而不是使用基于闭包的调用。
并非所有基于闭包的代码都必然涉及并发或多线程处理。在Swift和苹果SDK中，存在大量接受闭包的调用，这些调用与并发毫无关联。例如，集合中广受欢迎的filter、map和reduce方法，正是通过闭包对元素进行操作的。请牢记一点，几乎不可能存在完全不使用闭包的项目，这是完全正常的。因为async/await的设计目标，仅是消除并发相关任务中基于闭包的调用方式。
Understanding Continuations 简而言之，Continuations是指async调用完成后发生的一切。当我们使用async/await时，continuation就是指await调用之后的所有内容。
如果使用的是基于闭包的代码，continuation指的是在回调completion handlers中的代码。而如果使用的是基于delegate的代码，continuation就是在某个操作完成后相关代理方法调用。新的并发系统允许我们将基于闭包式的或基于delegate式的continuation转换为async/await版本。
Converting closure-based calls into async/await 下面是基于闭包的函数定义：
func fetchUserInfo(  completionHandler: @escaping (_ userInfo: UserInfo?, _ error: Error?) -&amp;gt;  Void ) {  let url = URL(string:&amp;#34;https://www.andyibanez.com/fairesepages.github.io/books/async-await/user_profile.json&amp;#34;)!  let session = URLSession.shared  let dataTask = session.dataTask(with: url) { data, response, error in  if let error = error {  completionHandler(nil, error)  } else if let data = data {  do {  let userInfo = try JSONDecoder().decode(UserInfo.self, from: data)  completionHandler(userInfo, nil)  } catch {  completionHandler(nil, error)  }  }  }  dataTask.resume() } 可以使用withCheckedThrowingContinuation将上面闭包式的函数转换为async版本（下面代码和promiseKit相似）。下面代码本质上是将基于闭包的代码封装在withCheckedThrowingContinuation（是一个方法，该方法提供带参闭包）中。
func fetchUserInfo2() async throws -&amp;gt; UserInfo {  try await withCheckedThrowingContinuation { continuation in  fetchUserInfo { userInfo, error in  if let user = userInfo {  continuation.resume(returning: user)  } else if let err = error {  continuation.resume(throwing: err)  } else {  // Throw a generic error.  let err = NSError(domain: &amp;#34;com.socialmedia.app&amp;#34;, code: 400)  continuation.resume(throwing: err)  }  }  } } withCheckedThrowingContinuation是一种提供带参闭包的方法，闭包中的这个参数实际上就是continuation，当使用闭包的异步调用完成后，需要使用这个continuation来resume它。这个continuation的类型是CheckedContinuation&amp;lt;T, any Error&amp;gt;，这意味着我们可以使用一个对象或Error来resume它。这种设计完全合理，因为涉及网络调用的操作始终存在失败的可能性。
上面代码中的withCheckedThrowingContinuation是一个可能抛出错误的async函数，因此我们在调用它（省略了所需的圆括号）时使用了try await。当函数fetchUserInfo成功获取到userInfo时，我们调用continuation.resume(returning: user)来resume对应的continuation，当fetchUserInfo调用发生错误时，我们使用continuation.resume(throwing: err)抛出异常。
当调用continuation.resume(returning:)时，会使得async版本的fetchUserInfo()调用者返回结果对象；而使用continuation.resume(throwing:)时，则会使其抛出错误。请注意，使用continuation时必须在某个时刻精确调用一次continuation（只能一次）。既不能忘记调用，也不能调用多次，若忘记调用，程序将陷入死锁状态。
除了使用withCheckedThrowingContinuation创建continuation，还有其它三种方式创建continuation，即共有四种方法来创建continuations：
  withCheckedThrowingContinuation
  withCheckedContinuation
  withUnsafeThrowingContinuation
  withUnsafeContinuation
  若确认原始的闭包代码中不返回任何错误时，可以使用withCheckedContinuation。不安全的变体-withUnsafeThrowingContinuation和withUnsafeContinuation ，与对应的Checked相似。主要区别在于，当使用Checked Continuations时，Swift会在遇到任何违规情况（如多次调用continuations或完全忘记调用continuation）时通过记录错误来保护你。
不安全continuations没有这些功能，但它们可能稍微快一点。总体来说，不建议使用不安全的continuations，但也请注意，在大多数情况下可以互换使用它们。
Converting delegate-based code into async/await 将基于delegate的代码转换为async/await是一个更复杂的过程，因为这类API可能会根据发生的不同类型事件调用不同delegate方法，这会形成跳跃式的代码结构。基于代理的API可能非常混乱，尤其是当它们有大量可能的方法调用时。
尽管不同调用可能发生在同一线程中，但由于方法调用方式的特性，其行为往往难以预测。例如，ContactsUI框架提供的CNContactPickerViewController对象：当用户选择联系人时通过一个方法通知，而若用户取消选择，则会调用另一个方法通知。
在下面示例中，我们可以为调用者创建一个更简洁的API，围绕CNContactPickerViewControllerDelegate及其方法创建一个包装对象来实现：
// 原实现 func promptContact() {  let picker = CNContactPickerViewController()  picker.delegate = self  picker.displayedPropertyKeys = [CNContactGivenNameKey, CNContactNamePrefixKey, CNContactNameSuffixKey]  present(picker, animated: true) }  // 改造后的实现 func promptContact() {  Task {  let contactPicker = ContactPicker(viewController: self)  if let contact = await contactPicker.pickContact() {  // Contact selected…  } else {  // Selection Cancelled…  }  } }  import Foundation import ContactsUI class ContactPicker: NSObject, CNContactPickerDelegate {  private typealias ContactCheckedContinuation = CheckedContinuation&amp;lt;CNContact?, Never&amp;gt;  private unowned var viewController: UIViewController  /// 存储Continuation，在代理方法调用的时候以便它调用  private var contactContinuation: ContactCheckedContinuation?  private var picker: CNContactPickerViewController   init(viewController: UIViewController) {  self.viewController = viewController  picker = CNContactPickerViewController()  super.init()  picker.delegate = self  }   @MainActor func pickContact() async -&amp;gt; CNContact? {  // 打开人员选择器  viewController.present(picker, animated: true)  // 等待返回CNContact?  return await withCheckedContinuation({ (continuation: ContactCheckedContinuation) in  // 保存continuation   self.contactContinuation = continuation  })  }   @MainActor  private func contactPicker(_ picker: CNContactPickerViewController, didSelect contact: CNContact) {  contactContinuation?.resume(returning: contact)  contactContinuation = nil  picker.dismiss(animated: true, completion: nil)  }   @MainActor  private func contactPickerDidCancel(_ picker: CNContactPickerViewController) {  contactContinuation?.resume(returning: nil)  contactContinuation = nil  }  } 上面delegate中的方法contactPicker和contactPickerDidCancel执行时，都可以resume(恢复)contactContinuation，要么在取消选人的时候传递nil，要么在选择人后传递contact。下面是调用ContactPicker的示例代码：
func promptContact() {  Task {  let contactPicker = ContactPicker(viewController: self)  if let contact = await contactPicker.pickContact() {  let nameFormatter = CNContactFormatter()  nameFormatter.style = .fullName  let contactName = nameFormatter.string(from: contact)  selectedContactLabel.text = contactName  selectedContactLabel.textColor = .black  selectedContactLabel.isHidden = false  } else {  selectedContactLabel.text = &amp;#34;Cancelled&amp;#34;  selectedContactLabel.textColor = .red  selectedContactLabel.isHidden = false  }  } } 经过ContactPicker封装后，原先的ViewController中的代码就减少了很多，类也变得小很多。虽然我们成功为基于代理的调用提供了async/await版本，这确实很棒，但应该考虑这样做是否真的有必要。有时，基于委托的调用（如CoreBluetooth、CoreLocation）的复杂性可能不值得为其提供async/await版本。
Supporting async/await in iOS 13 and 14 之前有提到过，但需要再强调一下，虽然在Xcode 13.3中就可以使用async/await，但在这两个版本的系统中苹果并没有提供系统库的async版本，直到iOS 15才开始提供系统库的async版本。因此，为了兼容iOS 13和14系统，建议扩展系统库方法并利用available检查器：
extension LAContext {   @available(iOS, introduced: 13, deprecated: 15, message: &amp;#34;This method is no longer necessary. Use the API available in iOS 15.&amp;#34;)  func evaluatePolicy(_ policy: LAPolicy, localizedReason: String) async throws -&amp;gt; Bool {  try await withCheckedThrowingContinuation({ continuation in  self.evaluatePolicy(policy, localizedReason:localizedReason) { success, error in  if let err = error {  continuation.resume(throwing: err)  } else {  continuation.resume(returning: success)  }  }  })  } } 在上面代码中，使用@available可以保证这段代码仅运行在iOS 13和iOS 14。老版本的iOS系统不支持async/await，因此可以把低于iOS 12及以下的系统排除在外。当上面方法运行在iOS 15以上的系统时，会得到的警告：This method is no longer necessary Use the API available in iOS 15。当target最低支持到iOS 15以后，上面扩展方法就可以删除了。
上面的continuation允许我们平滑地将基于闭包的调用转换为SDK已经存在的async/await调用。但仅限于针对iOS 15及更高版本时。转换时已经不再返回错误，而是将该方法转换为抛出异常的类型。
下面代码和上面代码没有太大的区别，最大的不同就是返回类型为(Data, Response)类型的元组，但总体而言，将此方法暴露给iOS 14和13系统并不复杂。需要注意的是，我们对返回的data和response进行了强制解包。这样做的原因是：若查看API的原始async签名，元组中的这些属性并未标记为可选类型，因此可安全地假设若未出现错误，这两个变量必为非空值。若对此存疑，可将元组元素标记为可选类型。
extension URLSession {   @available(iOS, introduced: 13, deprecated: 15, message: &amp;#34;This method is no longer necessary. Use the API available in iOS 15.&amp;#34;)  func data(from url: URL) async throws -&amp;gt; (Data, URLResponse) {  try await withCheckedThrowingContinuation({ continuation in  self.dataTask(with: url) { data, response, error in  if let error = error {  continuation.resume(throwing: error) }  else {  continuation.resume(returning: (data!, response!))  }  }.resume()  })  } } 下面是一段无关代码封装：
actor SharedAsyncNetworkManager {  static let shared = SharedAsyncNetworkManager()  private var currentTask: Task&amp;lt;Data, Error&amp;gt;?   func fetchData() async throws -&amp;gt; Data {  if let existingTask = currentTask {  return try await existingTask.value  }  let task = Task&amp;lt;Data, Error&amp;gt; {  defer { currentTask = nil }   let url = URL(string: &amp;#34;https://api.example.com/data&amp;#34;)!  let (data, _) = try await URLSession.shared.data(from: url)  return data  }   currentTask = task  return try await task.value  }   func clearCache() {  currentTask = nil  } } Structured Concurrency 截至目前，已经广泛地讨论了async/await是什么以及它是如何工作的。也已看到这种新工具如何帮助我们编写结构化的代码，使其代码结构类似于过程式编程。使用async/await能够摆脱那些破坏代码线性可读性的其他类型的回调，例如闭包和委托。但我们也已看到，所有这些代码实际上并不是同时运行、并发或多线程执行的。
我们定义并发为：一个线程（或你的程序）同时处理多件事情的能力。这个定义并不严格意味着同时做多件事，通常人们谈到并发时，实际上指的是多线程或并行。为了与社区对这个词的定义保持一致，当我们谈到并发时，指的是同时执行多个任务。
Understanding Structured Concurrency 结构化并发遵循结构化编程的相同思路。即按照预期的顺序编写代码，并看到可预测（或至少半可预测）的结果。与基于闭包的代码不同，结构化并发中定义的变量具有明确的作用域，因此可以预期代码不会跳转到破坏代码阅读流程的其它地方。这使得我们无需关心如内存管理等其他细节（例如，块中捕获的变量会怎样？闭包能否被保留？weak self等）。
而且，这仅适用于只考虑非并发的基于闭包的调用。你能想象一下代码中有多个基于闭包的并发调用，很多独立的代码同时运行的情况吗？
在结构化并发中，可以同时运行多个代码路径，并得到可预测的结果，而无需思考那些跳转多个基于闭包调用的代码迷宫。在新的async/await系统，提供了两种方式构建结构化并发：async let构造和task groups。
The async let construct 结构化并发的async let构造也被称为async let绑定。下面两段代码都是使用async let构建结构化并发，仅在return这一行有区别，但它们的效果是一样的，且第二种方式更简洁：
func fetchData1() async throws -&amp;gt; (userInfo: UserInfo, followers: UserInfo) {  async let userInfo = fetchUserInfo()  async let followers = fetchFellows()  return (try await userInfo, try await followers) }  func fetchData2() async throws -&amp;gt; (userInfo: UserInfo, followers: UserInfo) {  async let userInfo = fetchUserInfo()  async let followers = fetchFellows()  return try await(userInfo, followers) } 要并发运行代码，只需在let声明前添加async关键字，声明的其余部分看起来像是正常的变量初始化。仍需要注意的是，若要执行async let操作，必须处于异步上下文中，既可以处于一个Task中，也可以处于一个标记为async的函数中。
当代码执行到async let声明时，赋值语句之后的所有操作都将在其它位置执行（被调用的函数和方法可能在不同线程中运行），各项任务将并行执行。async let任务作为创建它们的任务的子任务被创建。
如果在async let调用之间添加print语句，将会看到它们会被立即调用。userInfo 和followers将同时运行，但代码会在即将返回时暂停。需要注意的是，await关键字是一个挂起点，这意味着fetchUserInfo和fetchFellows都返回或其中某一个抛出错误之前，函数都是被挂起的。
之前有说过，每一次async调用必须有与之对应的await，但并不要求async和await必须在同一行。如上面实示例代码，在使用async let时，当真正需要使用对应变量的值时，才需要使用await关键字。因此，如果async let调用返回一个其它函数依赖的值，就在调用处使用await。如果需要在函数内部并发获取多个值，可以在返回语句处直接使用await，这并未违反async调用必须与await关键字配对的原则。
使用aync let是非常有用的，并且与之相应的可以在任何地方使用await关键字，如单个变量声明，或在等待数组元素时，或者像上面示例在返回元组之前等场景。
需要特别注意的是，虽然我们使用async let构造来明确表达并行执行任务的意图，但依然由系统决定是否真的并行运行你的代码，或是否为多个调用复用同一个线程。换言之，系统可能会选择在不同的但共享的线程中运行fetchUserInfo和fetchFollowingAndFollowers，实质上是在主线程之外串行执行这两项任务。
Task Groups 若预先知道有多个并发量，使用async let来构建是理想选择。但有时我们事先并不知道完成某个任务有多少个并发量。为了应对这种场景，async/await提供了任务组（task groups）的解决方案。
任务组是一种结构化的并发工具，允许我们同时运行未知数量的（可能）并发任务，前提是这些任务是相关的。当任务过多时，Swift不会一次运行所有任务，它会对任务进行优先级排序，并尽可能多地并行执行其中部分任务。
Task Groups in Action 为了创建任务组，可以使用withTaskGroup和withThrowingTaskGroup函数。如同创建continuations一样，创建任务组也区分是否抛出异常。当任务组能顺利完成时使用前者，任务组可能抛出错误时使用后者。
需要注意的是，计算机系统并不具备无限数量的线程。下面示例代码中，任务组会尽最大努力并行下载所有图片，但会对任务进行优化和优先级排序。若需同时处理大量并发任务，请注意任务组可能会将部分任务排入队列以备后续执行，且并非所有任务都会同时运行。
import Foundation  struct ServerImage: Codable {  let imageName: String  let url: URL }  func download(serverImages: [ServerImage]) async throws -&amp;gt; [URL] {  var urls: [URL] = []  try await withThrowingTaskGroup(of: URL.self) { group in  for image in serverImages {  group.addTask(priority: .userInitiated) {  let imageUrl = try await self.download(image)  return imageUrl  }  }  // 这里也使用try await   for try await imageUrl in group {  urls.append(imageUrl)  }  }  return urls }  func fetchImageList() async throws -&amp;gt; [ServerImage] {  let (data, _) = try await URLSession.shared.data(from: imageListURL)  let urls = try jsonDecoder.decode([ServerImage].self, from: data)  return urls }  func download(_ serverImage: ServerImage) async throws -&amp;gt; URL {  let fileManager = FileManager.default  let tmpDir = fileManager.temporaryDirectory  let (downloadedImageUrl, _) = try await URLSession.shared.download(from: serverImage.url)  // If the destination already exists, remove it.  let destinationUrl = tmpDir.appendingPathComponent(serverImage.imageName)  try? fileManager.removeItem(at: destinationUrl)  try fileManager.moveItem(at: downloadedImageUrl, to: destinationUrl)  return destinationUrl } 从高层次来看，上面函数download(serverImages:) 首先声明一个URL数组变量。然后我们将把所有下载图片的本地URL存储在此变量中。随后创建一个任务组——该任务组本身即为可等待的操作——最后返回图片。由此再次体现了async/await机制带来的线性执行特性。
不管是使用withTaskGroup还是使用withThrowingTaskGroup创建任务组，都需要指定该任务组产生的数据类型。上面示例中，任务组产生的是URL数组，因为download(serverImages:)方法将返回URL。在withTaskGroup和withThrowingTaskGroup的闭包都会返回任务组本身，在上面示例中参数group就是任务组本身。往任务组提交任务使用addTask方法，任务一旦提交后便会立即开始执行。
在download(serverImages:)函数中，我们遍历所有服务器图片，每次迭代都会创建一个下载图片的任务。在最佳情况下，任务组能同时执行所有任务。与async/await系统中的其它工具类似，系统会对任务进行优先级排序。若资源充足，它将尝试并行执行所有任务。但若任务组未能同时执行每个任务（尤其当提交大量任务时），请勿感到意外。我们可选择性指定优先级，上面采用的是.userInitiated优先级，这是当前可用的最高优先级。
需要特别注意的是，添加到组中的任务可能不会按照提交顺序执行。要使用任务组，关键是要设计出与执行顺序无关的代码。
最后，在withThrowingTaskGroup内部，还有另一个循环——一个await的for循环。该循环将接收所有下载完成的URL。它会逐个接收每个URL，因此我们不能让URLs变量处于无效状态。再次强调，不要期望URLs会按特定顺序获取。group本身是一个集合，因此不仅可以使用for-in遍历它，还可以使用filter、map、reduce这样的高阶函数来处理结果。而且，for循环中也可以使用await关键字来处理随时间发出值的代码。
还需要注意的是，只要任务组中的一个任务出现错误，整个任务组就会抛出异常。请记住这一点，因为它可能导致意想不到的行为，如果图片下载可能会失败，那么在这个特定项目中为下载任务提供一个默认图片可能是个好主意。
Unstructured Concurrency 结构化并发遵循与结构化编程相同的理念，结构化并发的自然对应概念是非结构并发。非结构化并发提供了更大的灵活性，但代价是可用性略有降低。在处理非结构并发时，代码未必遵循我们所喜爱的自上而下的结构。幸运的是，处理非结构并发仍然非常简单，这种灵活性不会显著增加程序的复杂性。
Tasks in Depth 对于非结构的并发，依然是使用Task对象。Task是一个很重要的对象，它允许我们做两件非常重要的事情：
 通过初始化创建Task后，就会立即异步启动闭包中的代码。 Task创建了一个并发上下文，使我们能够通过调用async方法的方式实现并发操作。  Creating Tasks Task是一个对象，它可以存储值、错误、两者兼有或两者皆无。要创建一个异步、非结构的任务，我们调用Task并使用一个闭包初始化它，该闭包是我们希望异步执行的代码。下面示例代码是使用Task调用标记为async的方法：
func authenticateAndFetchProfile() {  Task {  // ...  let userProfile = try await fetchUserInfo()  // ...  debugPrint(userProfile)  } }  func fetchUserInfo() async -&amp;gt; String {  debugPrint(&amp;#34;fetchUserInfo&amp;#34;)  return &amp;#34;Return Test&amp;#34; } 当需要使用Task做并发时，首先可灵活配置的参数便是优先级。优先级是Task.Priority类型（与处理任务组时使用的优先级相同）。下面是可以使用的优先级列表：
static let background: TaskPriority static let high: TaskPriority static let low: TaskPriority static var medium: TaskPriority static let userInitiated: TaskPriority static let utility: TaskPriority Task是一个对象，可以使用变量存储它，这正是其被称为非结构并发的部分原因。可以创建多个Task对象，将其存储在变量中，甚至存储在collections中。非结构化并发相较于结构化并发的一个独特优势在于支持任务取消。调用cancel()方法即可取消任务，在结构化的Task无法做到这一点：
func authenticate() {  let authenticationTask = Task&amp;lt;Bool, Error&amp;gt; {  let context = LAContext()  let policy = LAPolicy.deviceOwnerAuthenticationWithBiometrics  return try await context.evaluatePolicy(policy, localizedReason: &amp;#34;To log in&amp;#34;)  }  // 取消Task  authenticationTask.cancel() } 在上面示例代码中，创建了一个类型为Task&amp;lt;Bool, Error&amp;gt;的变量，这是因为context.evaluatePolicy返回一个Bool值且可能抛出一个Error。
我们可以await某个Task的值。下面示例代码中，需要使用try await，这是因为我们定义的authenticationTask可能返回一个Bool值，也可能抛出错误。
func authenticate() {  let authenticationTask = Task&amp;lt;Bool, Error&amp;gt; {  let context = LAContext()  let policy = LAPolicy.deviceOwnerAuthenticationWithBiometrics  return try await context.evaluatePolicy(policy, localizedReason: &amp;#34;To log in&amp;#34;)  }   Task {  let status = try await authenticationTask.value  if status {  debugPrint(&amp;#34;sucess&amp;#34;)  }  } } 需要注意的是，上面代码创建Task时，并没有使用do-catch语句。上面代码隐式地创建了一个Task&amp;lt;(), Error&amp;gt;类型的任务，因为Task中不返回任何值，但会抛出异常。Task不需要显式的do-catch语句体，因为错误会被闭包本身捕获。
当在代码中使用Task {}创建一个新任务时，它将继承产生这个任务的上下文信息。继承的信息包括任务运行的Actor（如果在@MainActor上运行的任务中产生了任务，那么该任务也将在@MainActor上运行）和优先级。如果新生成的任务是一个根任务（即创建异步上下文但自身未在该上下文中运行），那么它将继承其所运行线程的Actor。
Unstructured Concurrency in Action 既然你已经更清楚地理解了什么是非结构化并发，并且终于明白了Task对象是什么，我们就可以开始编写一些示例代码，以便更好地理解其工作原理。
enum ImageDownloadStatus { 	case downloading(_ task: Task&amp;lt;Void, Never&amp;gt;) 	case error(_ error: Error) 	case downloaded(_ localImageURL: URL) }  struct ImageDownload: Identifiable {  let id: UUID = UUID()  let status: ImageDownloadStatus } The Task Tree Swift中的新并发系统由一种称为任务树的基础结构驱动。正如名称所示，任务树为我们提供了一种并发在后台如何运作的思维模型。任务树决定了任务如何与其它任务关联运行。它还控制数据如何传递给子任务。之前我们提到过，一个任务会从启动它的任务那里继承actor、优先级和任务局部变量。这要归功于任务树。任务会生成子任务，而这些子任务会从父任务那里继承所有这些属性。
下面代码中，直觉上我们会认为每个async let调用会隐式地启动一个新任务，但事实并非如此。每个async let调用会启动一个新的子任务。这个区别很重要，因为Task只能显式创建。
func fetchData() async throws -&amp;gt; (userInfo: UserInfo, followers: UserInfo) {  async let userInfo = fetchUserInfo()  async let followers = fetchFellows()  return try await(userInfo, followers) } 每个子任务都会继承我们之前从父任务接受的信息（在上面这种情况下，父任务就是fetchData()函数本身），这些信息包括actor，priority和局部变量。
当在一个Task中创建一个新Task，它还将继承父Task的属性，但与隐式任务不同，可以根据自己的需求稍作调整，例如以不同的优先级生成该新Task。
任务树的另一个需要特别注意的是：父任务只有在其所有子任务都完成工作后才能完成。即使终止是不成功（即抛出了错误），它仍然是一个终止，当出现这种异常情况时，任务也可以完成。
Error Propagation fetchData本身可能会抛出异常，它所生成的所有子任务也是如此。假设fetchUserInfo出现了错误，如果函数抛出错误，那么函数会在该点停止执行，将错误传递给调用者，并且不会执行该点之后的任何代码。到目前为止，这正是若完全不使用新的并发系统时所发生的情况。这就是Swift（以及许多其他编程语言）中的错误传播机制。
但当使用新的并发系统时，情况并不那么直观。fetchUserInfo可能会抛出错误，但fetchFollowingAndFollowers可能正常完成并返回预期的值。如果发生错误，它将沿着任务树向上传播，直到到达调用者。任何其它正在等待或并发运行的子任务将被标记为已取消。
Task Cancellation 任务取消是非常重要的，但它的运作方式和我们第一眼看到的有所不同。如果重新阅读上一段的最后一句话，会发现我们说的是这些任务“将被标记为已取消”。
在新的并发系统，任务取消是协作式的。取消一个任务仅仅意味着你通知它打算取消它。任务本身需要找到一个合适的时间点来终止自己，而你需要自行实现这一逻辑。
任务取消之所以是协作式的，是因为存在一些敏感但重要的任务，它们可能无法接受被强制终止执行。如果你正在一个并发任务中写入数据库或者修改用户文件，突然取消它可能会导致用户数据损坏。
若一个任务被取消掉，那么它的所有子任务也会被标记为被取消，这样是试图确保不会进行不必要的工作。
Task Cancellation and Task Groups 理解结构化并发与任务组可以使你的代码向调用者返回部分结果而不是完整集合非常重要。接下来分析下面的代码段：
func download(serverImages: [ServerImage]) async throws -&amp;gt; [URL] {  var urls: [URL] = []  try await withThrowingTaskGroup(of: URL.self) { group in  for image in serverImages {  group.addTask(priority: .userInitiated) {  let imageUrl = try await self.download(image)  return imageUrl  }  }  for try await imageUrl in group {  urls.append(imageUrl)  }  }  return urls } 如果有10张图片需要下载，并且在所有图片下载完成之前发生错误（或者你调用group.cancelAll()取消任务组）, urls数组将包含一个不完整的部分结果，只包含它在异常退出之前成功下载的图片。请确保你记录下这种行为，因为调用你代码的用户可能不了解这一点，从而导致他们的程序出现意外行为。
Unstructured Concurrency with Detached Tasks 任务树确保任务继承一些来自父任务的属性，例如优先级，actor和局部变量。完全有可能从一个不继承任何父任务属性的任务启动另一个任务，这些任务被称为分离任务。当需要非严格相关的并发时，它们非常有用。例如，从互联网下载图片可以是一个任务，之后可能希望将这些图片存储到本地缓存中。将图片存储到本地缓存的过程可以是一个分离任务，这样即使该任务被取消，但图片已经下载完成，缓存保存操作仍能顺利进行而不会出现问题。
Task.detached(priority: .low) {  imageManager.writeImageToCache(image) } 上面创建了一个分离任务，从语法上看，和标准任务之间没有太大区别，但在使用它们时要注意任务树和继承属性。指定优先级是可选的，就像在使用普通任务时一样。
Actors 运行一些任务时，经常需要将结果传递到主线程。但也有一些情况，需要在程序中使用共享的可变状态，即一个可以被代码读取和写入的公共可变资源。这个资源可以是一个简单的变量，也可以是一个文件，或者任何其它在并发访问时危险的资源（但这些资源又需要在多个任务之间同时可用）。
如果有多段代码访问一个只读资源，程序不会出现问题，不必担心数据损坏。但如果有多个任务，并且至少一个可以向共享资源写入数据，那很可能会出现问题。这种情况称为数据竞争（data race or race condition)，数据竞争是十分危险的。
如果多段代码可以同时写入一个文件，将会导致数据损坏。如果多个任务从该资源中读取数据，它们可能会得到垃圾数据，这些数据可能与它们试图读取的数据不一致。最糟糕的是，如果在底层编写并发代码，很容易引入数据竞争，而且调试起来也非常困难。
因此，如果使用的是值语义（如结构体或枚举），就不会遇到这个问题。值语义是只读的，如果值发生变化，会创建一个副本，且所有的修改都局限于该变量。每个任务都会操作数据的不同副本，尽管这可能并非你所期望的。
Introducing Actors Actor是Swift中引入的一种新引用类型，由新的并发模型支持。Actor自身的状态与程序的其余部分隔离，并对外部访问可变状态提供同步保护。简单来说，如果一个Actor包含一个可被多个任务读写的基本变量，那么Actor会确保同一时间只有一个任务能够执行操作，从而保证对资源的互斥访问。
每次访问可变状态都必须通过Actor来完成。声明一个Actor非常简单，只需使用actor 关键字，然后为其命名，这与声明结构体（struct）或类（class）非常相似。作为引用类型，actor与类有许多相似的功能：它们可以遵循协议（protocol），也能通过扩展（extension）获得更多功能。与类的主要区别在于，actor会隔离自身状态。一个actor可能会挂起零次或多次（即在其方法内部包含其它await调用），因此可以轻松地将Actor与Swift的其它新并发系统组件集成。
actor VideogameLibrary {  var videogames: [Videogame] = []   func countGames(by company: String) -&amp;gt; Int {  let games = fetchGames(by: company)  return games.count  }   func add(games: [Videogame]) {  self.videogames.append(contentsOf: games)  }   func fetchGames(by year: Int) -&amp;gt; [Videogame] {  let games = videogames.filter { $0.releaseYear == year }  return games  } }  struct Videogame {  let title: String  let releaseYear: Int  let company: String } 从上面定义可以看出，actor的声明看起来和类的声明十分相似，它也是一种引用类型，可以预期它与类的行为类似。你可能会问为什么actor是引用类型而不是值类型。原因很简单：actor封装了可变的共享状态。它是一种期望被多个代码片段修改的类型。如果它是一个struct，调用者修改它时得到的是副本。
Interacting with an Actor 需要特别注意，所有的actor调用必须是异步的，因此需要await关键字，这就是actor用来同步状态并防止并发修改的机制。因为actor的调用可以awaited，所以其它调用者会被挂起，等待轮到它们访问actor。
而在actor内部，不需要异步调用自身的方法和属性。因为actor是被隔离的，其内部任何调用都按顺序执行，直到内部操作完成。
let library = VideogameLibrary()  func addGames(to library: VideogameLibrary) {  let zelda5 = Videogame(title: &amp;#34;The Legend of Zelda: Ocarina of Time&amp;#34;, releaseYear: 1998, company: &amp;#34;Nintendo&amp;#34;)  let zelda6 = Videogame(title: &amp;#34;The Legend of Zelda: Majora&amp;#39;s Mask&amp;#34;, releaseYear: 2020, company: &amp;#34;Nintendo&amp;#34;)  let tales1 = Videogame(title: &amp;#34;Tales of Symphonia&amp;#34;, releaseYear: 2004, company: &amp;#34;Namco&amp;#34;)  let tales2 = Videogame(title: &amp;#34;Tales of the Abyss&amp;#34;, releaseYear: 2005, company: &amp;#34;Namco&amp;#34;)  let eternalSonata = Videogame(title: &amp;#34;Eternal Sonata&amp;#34;, releaseYear: 2008, company: &amp;#34;tri-Crescendo&amp;#34;)  let games = [zelda5, zelda6, tales1, tales2, eternalSonata]   library.add(games: games) } 上面在VideogameLibrary之外定义的方法addGames是一个简单函数，仅用于快速添加一些Videogame，如果尝试编译这段代码，会出现错误：Actor-isolated instance method ‘add(games:)’ can not be referenced from a non-isolated context。
尽管VideogameLibrary中的add(games:)方法本身没有被标记为async，但actor暴露给我们的API确实是异步的，这是actor提供的保护机制。编译器在避免我们误用actor，以避免引入数据竞争。
这意味着，actor只能在异步上下文中运行，若要让代码编译通过，需要在add(games:)方法中添加await关键字，并将其包裹在Task（或Task.detached）中。
let library = VideogameLibrary()  func addGames(to library: VideogameLibrary) {  let zelda5 = Videogame(title: &amp;#34;The Legend of Zelda: Ocarina of Time&amp;#34;, releaseYear: 1998, company: &amp;#34;Nintendo&amp;#34;)  let zelda6 = Videogame(title: &amp;#34;The Legend of Zelda: Majora&amp;#39;s Mask&amp;#34;, releaseYear: 2020, company: &amp;#34;Nintendo&amp;#34;)  let tales1 = Videogame(title: &amp;#34;Tales of Symphonia&amp;#34;, releaseYear: 2004, company: &amp;#34;Namco&amp;#34;)  let tales2 = Videogame(title: &amp;#34;Tales of the Abyss&amp;#34;, releaseYear: 2005, company: &amp;#34;Namco&amp;#34;)  let eternalSonata = Videogame(title: &amp;#34;Eternal Sonata&amp;#34;, releaseYear: 2008, company: &amp;#34;tri-Crescendo&amp;#34;)  let games = [zelda5, zelda6, tales1, tales2, eternalSonata]   Task{  await library.add(games: games)  }  } 当多次调用add(games:)方法时，actor只会一次执行其中一个调用（一个接着一个，不会并发执行）。下面示例代码中，我们创建了一个新方法，用于向库中添加更多的Videogame。
func addNewGames(to library: VideogameLibrary) {  let pokemon1 = Videogame(title: &amp;#34;Pokémon Yellow&amp;#34;, releaseYear: 1998, company: &amp;#34;Game Freak&amp;#34;)  let pokemon2 = Videogame(title: &amp;#34;Pokémon Gold&amp;#34;, releaseYear: 1999, company: &amp;#34;Game Freak&amp;#34;)  let pokemon3 = Videogame(title: &amp;#34;Pokémon Ruby&amp;#34;, releaseYear: 2002, company: &amp;#34;Game Freak&amp;#34;)  let games = [pokemon1, pokemon2, pokemon3]  	Task {  await library.add(games: games)  } } 现在有两个添加Videogame的方法了，下面每个方法都调用一次：
addGames(to: library) addNewGames(to: library) 现在有趣的事情发生了，我们不知道是addGames先添加成功还是addNewGames先添加成功。但可以保证的是，无论哪一个先执行，actor都会确保在另一个执行之前，函数中的所有Videogame都已经成功添加到数组中。
因此，数组要么包含addGames中按添加顺序排列的所有game，然后是addNewGames中按添加顺序排列的game，要么包含addNewGames中按添加顺序排列的所有game，然后是addGames中按正确顺序排列的game。永远不会以交错顺序或任何其它排列的方式添加game。
此外，对整个actor的访问是同步的。如果同一时间既向library中添加game，又在library中查询game，actor将只执行其中一个调用，直到完成后才会执行另一个。
Task {  addGames(to: library) }  Task {  let games1998 = await library.fetchGames(by: 1998)  print(&amp;#34;\(games1998.count)games&amp;#34;) }  Task {  addNewGames(to: library) } 理想情况下，上面代码执行完后会打印2 games，但由于Task试图并发地访问actor，三个任务只有一个能够先执行其中代码（一个接一个执行，但顺序不确定）。上面代码执行后，多数情况会打印0 gmaes，也可能打印1 games。互斥访问意味着一次只有一个任务可以进入actor并执行其工作（不管调用的是actor的哪种方法）。对actor的任何调用都会阻塞其它试图调用actor的操作，直到actor完成工作，其它任务才能调用actor。
这也是一个很好的机会用来展示Task的优先级是如何工作的。可以通过为添加game的任务分配更高的优先级，告诉编译器希望先添加game。下面示例代码更改了Task的优先级。其中.utility是最低优先级，因此通常它会最后执行，即打印的结果为2 games。
Task(priority: .high) {  addGames(to: library) }  Task(priority: .utility) {  let games1998 = await library.fetchGames(by: 1998)  print(&amp;#34;\(games1998.count)games&amp;#34;) }  Task(priority: .high) {  addNewGames(to: library) } Nonisolated Access to an Actor 有时可能已经知道访问一个actor不会导致数据竞争。对于这些情况，可以将actor中的某些方法标记为nonisolated。为了阐明如何使用nonisolated，我们先添加一个新类型：
struct Owner {  let name: String  let favoriteGenre: String } 然后将owner添加到VideogameLibrary中：
actor VideogameLibrary {  var videogames: [Videogame] = []  /// 只读属性，不会出现数据竞争  let owner: Owner   init(ower: Owner) {  self.owner = ower  }   nonisolated func fetchOwnerInfo() -&amp;gt; String {  return &amp;#34;\(owner.name)(\(owner.favoriteGenre))&amp;#34;  }   func fetchGames(by company: String) -&amp;gt; [Videogame] {  let games = videogames.filter { $0.title.caseInsensitiveCompare(company) == .orderedSame }  return games  }   func countGames(by company: String) -&amp;gt; Int {  let games = fetchGames(by: company)  return games.count  }   func add(games: [Videogame]) {  self.videogames.append(contentsOf: games)  }   func fetchGames(by year: Int) -&amp;gt; [Videogame] {  let games = videogames.filter { $0.releaseYear == year }  return games  }  } 调用actor中的nonisolated方法时，不需要异步调用，即不需要await关键字，也就是说不再需要并发上下文，下面代码不会出现编译错误：
func printOwnerInfo(of library: VideogameLibrary) {  let ownerInfo = library.fetchOwnerInfo()  print(ownerInfo) } Actors and Protocol Conformance 如果想让某个actor遵循协议，或者通过extension来扩展actor，需要注意一个重要事项：当actor打算遵循一个协议时，如果该协议有可变的需求，将会在遵循协议的过程中遇到问题。
actor Game {  let name: String  let year: Int   init(name: String, year: Int) {  self.name = name  self.year = year  } }  extension Game: Equatable {  static func == (lhs: Game, rhs: Game) -&amp;gt; Bool {  return lhs.name == rhs.name  } } 上面代码不会出现编译错误，但继续按下面方式扩展actor时，会出现编译错误：Actor-isolated instance method &#39;hash(into:)&#39; cannot be used to satisfy nonisolated protocol requirement。
extension Game: Hashable {  func hash(into hasher: inout Hasher) {   } } 规避这个编译错误的方案很简单，添加nonisolated关键字即可：
extension Game: Hashable {  nonisolated func hash(into hasher: inout Hasher) {  //  } } 这能够满足编译器的要求，但我们必须思考在这里使用nonisolated否合理。方法hash(into:)是否依赖于隔离的属性？如果依赖，你尝试实现该方法的任何努力都可能失败。你可能会遇到一些情形，确实很难符合那些期望其方法为同步的协议。
Actor Reentrancy 当我们进入一个actor，如果它有很多调用其它异步方法的事情要做，那么它可能会被挂起。这可能导致一个常见的，被称为Actor Reentrancy的问题。
Actor Reentrancy问题发生在到达await调用之前你假设程序的整体状态。用一个例子来解释这个问题，我们将VideogameLibrary添加一个新方法：
func addGamesAndPrintResults(_ games: [Videogame]) async throws {  let existingGameCount = videogames.count  // Imagine a long-running operation is taking place here.  try await Task.sleep(nanoseconds: 1_000_000_000)  add(games: games)  let newGameCount = existingGameCount &#43; games.count  print(&amp;#34;Games before: \(existingGameCount)&amp;#34;)  print(&amp;#34;Games now: \(newGameCount)&amp;#34;) } Actor Reentrancy问题发生在多个任务进入上面方法时，当一个任务进入时，它会记录videogames的数量，然后遇到一个长时间的await调用。在await调用完成前，第二个任务可能进入此方法，并记录videogames的数量。如果第一个任务在第二个任务离开await之前完成，那么第二个任务中的existingGameCount变量的值是错误的。
这里的问题是我们假设在进入await调用之前有多少个games。在离开一个挂起点后，程序的状态可能并不是之前那样。我们在await调用之前检查我们的假设，不幸的是actor无法在这种情况下保护我们。但一个经验法则是，在一个await调用之后检查你的假设。在这种情况下，我们的假设是VideogameLibrary中的游戏数量。
如果我们是在从挂起返回后计算这个数值，那就更有意义了。通过简单地将existingGameCount变量移动到合适的位置，程序就会被修复。下面将existingGameCount变量放在了一个更合理的位置。
func addGamesAndPrintResults(_ games: [Videogame]) async throws {  // Imagine a long-running operation is taking place here.  try await Task.sleep(nanoseconds: 1_000_000_000)  let existingGameCount = videogames.count  add(games: games)  let newGameCount = existingGameCount &#43; games.count  print(&amp;#34;Games before: \(existingGameCount)&amp;#34;)  print(&amp;#34;Games now: \(newGameCount)&amp;#34;) } Actors and Detached Tasks 会议一些，detached任务不会继承父任务的任何东西，包括父任务可能正在运行的actor：
func playRandomGame() {  guard let game = videogames.randomElement() else { return }  print(&amp;#34;Playing \(game.title)&amp;#34;) }  func playRandomGameLater() {  Task.detached {  await self.playRandomGame()  } } 方法playRandomGame是隔离在actor中的。但需要注意的是，playRandomGameLater要求我们使用await调用self.playRandomGame。这是因为一旦我们启动了分离任务，就跳转到了另一个actor。处于不同的actor中将迫使我们使用await调用该actor的方法。
General Tips for Working with Actors 当我们有共享可变变量时，actor是非常有用的，它使得访问可变数据变得容易，但它绝不是万能的解决方案。为了有效的使用actor，下面有一些建议：
 actor越简单越好。虽然actor会通过Swift编译器保护在多数情形下免受误用，但它们无法保护免受actor重入等问题的影响。保持actor小巧有助于更有效地使用它们。 保证actor的操作是原子的。原子操作被视为一个单一单元。方法简短将有助于此。一般来说，原子性意味着可以一次性完成所有工作，或者如果单个操作失败，则整个操作将被丢弃。尽可能避免在actor中调用await将有助于原子性。 对所需状态的所有假设应该放在await调用之后，当它们被用在actor的方法中时。如果你的方法中只有一个await调用，这很容易做到，但如果有多个，就很难推断你的程序状态。 不要将一个actor作为ObservableObject在SwiftUI中使用。编译器不会阻止你这样做，但 ObservableObject会期望它始终在主线程上运行。如果 actor中包含耗时操作，会导致你的SwiftUI应用出现明显的卡顿。  Sendable Types 最简单的并发程序涉及并发操作时通常是相对隔离的。但在复杂程序中，需要在隔离边界之间传递数据，从一个异步任务到另一个，从一个actor到acotr。这些数据必须是线程安全的。正如我们在actor中学到的，在异步域之间共享可变数据可能会导致数据竞争，从而导致数据损坏。
Swift需要一种安全的方式在隔离边界之间共享数据。Swift Evolution团队提出了一个非常优雅的解决方案，并引入了sendable types。
Understanding Sendable Types 一个sendable type可以跨异步task和actor之间共享。按照定义，一个sendable type需要能够防止数据竞争，这种类型应该无法被多个操作同时修改，只能提供同步访问。
Swift有一些可以安全地在并发环境中使用的，开箱即用的sendable类型：
 值类型。包括枚举和结构体，只要它们不包含任何不可发送类型的属性，值类型就是sendable的。如果尝试修改一个值类型，就会创建一个包含原数据的新副本。这使得结构体和枚举能够在新的并发系统能够开箱即用。值类型可能会创建多个副本，但已有的副本会一直保持原样，直到被删除。 Actors。acotr被设计为可以共享可变数据，因此他们存在的目的是在新并发模型中被使用。你可以无限制地在隔离边界之间共享actor，但要注意actor中可能有nonisolated的功能。actor始终是可发送的。 类。类可以是可发送的，但需要满足某些条件。类是引用类型，对类的实例进行修改实际上是修改了真实的数据。不像结构体，对类实例的修改不会创建原数据的副本。若一个被标记为final的类拥有只读属性，那么它非常容易使其成为可发送的。另一种方式是，如果类拥有可变属性且没有被标记为private，可以通过在类内部实现自己的同步机制来使其可发送。这听起来很难做，实际上也确实如此。 方法和闭包也可是可发送的，但需要显式地进行。  在许多情形下，Swift可以推断类型的可发送性。结构体和actor就是例子。但是如果你做了一些工作使得一个类是线程安全的，当Swift编译器是无法推断出来的，并且会阻止你在编译器认为危险的方式上使用它。
The Sendable Protocol 在Swift中，除了值类型和actor之外的可发送类型需要遵守Sendable协议。通过简单地遵守Sendable协议，编译器会检查你对可发送类型的使用，以确保不会以可能导致数据竞争的方式使用它们。
Analyzing Sendable Types Structs 为了更好地理解sendable types的行为，通过分析以了解其特点和注意事项。多数情况下，struct是开箱即用的可发送类型，但也有例外情况使得某个struct是不可发送的类型。假设一个结构体有一个类属性：
class TVShow {  let title: String  var rating: Int   init(title: String, rating: Int) {  self.title = title  self.rating = rating  }  }  struct TVShowLibrary {  var shows: [TVShow] = [] } 如果试图用这个结构体跨越隔离边界（例如在非隔离上下文中声明一个TVShowLibrary并在Task.detached {}中捕获它），即使TVShowLibrary是一个结构体，编译器也会阻止你。在普通的Task {}捕获不会受到影响，因为它们会继承顶层上下文的actor，下面代码中顶层上下文的actor是@MainActor。下面示例代码中，我们声明了一个TVShowLibrary实例，然后两个Tasks中都捕获它了。
var tvShowLibrary = TVShowLibrary() let show = TVShow(name: &amp;#34;Card Captor Sakura&amp;#34;) tvShowLibrary.shows &#43;= [show]  Task {  tvShowLibrary.shows.first?.rating = 20  print(&amp;#34;Current score Task 1: \(tvShowLibrary.shows.first!.rating)&amp;#34;) }  Task {  tvShowLibrary.shows.first?.rating = 30  print(&amp;#34;Current score Task 2: \(tvShowLibrary.shows.first!.rating)&amp;#34;) } 直觉上，我们可能会认为编译器会阻止这样做。毕竟我们是在两个任务中同时捕获并修改一个可变值。但这样做是完全可接受的，因为这两个Task的调用对应同一个actor（启动它们的actor）。如果是从非异步上下文中启动任务的，它们将继承主线程actor。
结构体默认是可发送的，除非它里面的属性是不可发送。上面的TVShowLibrary是不可发送的，因为它有一个数组属性，而数组中的元素TVShow是一个类，因此整个TVShowLibrary是不可发送的。
var tvShowLibrary = TVShowLibrary() let show = TVShow(name: &amp;#34;Card Captor Sakura&amp;#34;) tvShowLibrary.shows &#43;= [show]  Task.detached {  tvShowLibrary.shows.first?.rating = 20  print(&amp;#34;Current score Task 1: \(tvShowLibrary.shows.first!.rating)&amp;#34;) }  Task.detached {  tvShowLibrary.shows.first?.rating = 30  print(&amp;#34;Current score Task 2: \(tvShowLibrary.shows.first!.rating)&amp;#34;) } 因为Task.detached没有从顶层上下文中继承actor，即上面两个Task变成了是完全相互独立的，这会导致数据竞争。Swift为了避免出现这种错误，编译器时会出现错误或提示（根据Xcode版本不同而不同）。
对于上面这种情况，最合理的解决方案是将TVShowLibrary改为一个actor而不是一个struct。这是因为多个任务都对修改它感兴趣，这正是actor的完美用法。
Classes class默认是不可发送的。但是，当class被标记为final并且具有只读属性时，可以使它们遵循Sendable协议。即可以将TVShow标记为遵循Sendable，这样你的代码将能够编译，不会有任何警告。下面代码展示了们尝试这样做时会得到的警告。
class TVShow:Sendable {  let name: String  var rating:Int = 0   init(name: String) {  self.name = name  } }  // 出现的警告 Non-final class &amp;#39;TVShow&amp;#39; cannot conform to &amp;#39;Sendable&amp;#39;; use &amp;#39;@unchecked Sendable&amp;#39;; this is an error in the Swift 6 language mode  Stored property &amp;#39;rating&amp;#39; of &amp;#39;Sendable&amp;#39;-conforming class &amp;#39;TVShow&amp;#39; is mutable; this is an error in the Swift 6 language mode 将TVShow标记为final时可以消除第一个警告，将rating改为let声明时才能消除第二个警告，当这样做之后我们后续也不能修改rating的值了。
final class TVShow:Sendable {  let name: String  let rating:Int = 0   init(name: String) {  self.name = name  } } 一般来说，如果你需要使得定义的类变成Sendable的，将其标记为final并使所有属性变成只读的是最佳做法，但在这里是不可能的，情况就是这样。
我们唯一能修复这个类的方法是选择退出编译器的安全检查。要做到这一点，需要在Sendable协议前添加@unchecked关键字。下面是不会产生任何警告的TVShow类。
class TVShow: @unchecked Sendable {  let name: String  var rating:Int = 0   init(name: String) {  self.name = name  } } 但需要注意的是，使用@unchecked只是临时规避编译器检查。因为这个类本身没有同步保护机制，当多个任务或actor同时修改它时会导致数据竞争。可以通过使用类似使用NSLock等机制来添加同步保护。下面代码展示了一个简单实现的例子。
class TVShow: @unchecked Sendable {  let mutex = NSLock()  let name: String  var rating: Int = 0 {  willSet {  mutex.lock()  }  didSet {  mutex.unlock()  }  }   init(name: String) {  self.name = name  } } 不建议在生产环境中使用此代码，除非你真正理解锁等concurrency primitives的工作原理。新的并发系统旨在帮助开发者无需关注这些细节。
Closures 在Swift闭包是一等公民，可以将闭包和函数引用传递给代码的其它部分，以便随时调用它们。在使用Swift中集合的filter、map和reduce方法时可能已经见过这一点。
library.shows.filter { $0.rating &amp;gt;= 10 &amp;amp;&amp;amp; $0.rating &amp;lt;= 30 } 因为可以将函数和闭包传递给代码中的其它部分，所以可以确信它们也应该是可发送的。因为函数或闭包不能遵循协议，但我们可以使用@Sendable属性来替代。当使用@Sendable属性时，编译器会认为它不需要对任何内容进行同步，因为@Sendable函数的主体是可发送的，而可发送的闭包只能捕获可发送的类型。
查看Task的定义，可以发现泛型Success遵循了Sendable协议。因此，task可以操作Sendable类型。
@frozen struct Task&amp;lt;Success, Failure&amp;gt; where Success : Sendable, Failure : Error 接着查看Task的初始化器以及detached静态方法：
@discardableResult init( priority: TaskPriority? = nil, operation: @escaping () async -&amp;gt; Success )  //...  @discardableResult static func detached( priority: TaskPriority? = nil, operation: @escaping () async throws -&amp;gt; Success ) -&amp;gt; Task&amp;lt;Success, Failure&amp;gt; 我们已经确认Success是遵循Sendable协议的，这是Swift通过其机制确保非Sendable类型不能被传递到其他并发区域的方式。初始化器接受一个返回Sendable类型的闭包，而detached方法返回一个具有相同要求的Task。
我们可以参照这种方式创建自己的Sendable函数，下面代码声明了一个使用@Sendable标记的闭包，这个方法会在执行方法之前打印一些内容，在执行之后也会打印一些内容。可以使用这样的函数来对你的方法进行基准测试。
func logBeginningAndEnd(operation: @Sendable () -&amp;gt; Void) {  print(&amp;#34;Calling Closure&amp;#34;)  operation()  print(&amp;#34;Closure finished&amp;#34;) } 我们尝试着调用这个方法，传递一个非sendable的东西：
var tvShowLibrary = TVShowLibrary()  logBeginningAndEnd {  let showsCount = tvShowLibrary.shows.count  print(&amp;#34;\(showsCount)Shows&amp;#34;) } 函数logBeginningAndEnd要求闭包参数要求是sendable的，但传递的实参却是非sendable的，此时编译器会给出警告：Converting non-sendable function value to ‘@Sendable () -&amp;gt; Void。
所以，如果确定你的函数可以在不同的线程间共享，请不要忘记将它们标标记为@Sendable，这样系统就不会发出任何不必要的警告。
@Sendable func doSomething() {  } 当然，不要对每一个函数或方法都标记为@Sendable。只有在你确定这些函数可以在不同的并发域中安全使用，并且有意这样使用时，才这么做。
最后，如果有一个可以存储闭包的变量，也可以将其限制为@Sendable闭包。下面代码声明了一个类，该类有一个可以存储@Sendable闭包的属性。
class MyClass {  var aClosure: @Sendable () -&amp;gt; Void   init(aClosure: @escaping @Sendable () -&amp;gt; Void) {  self.aClosure = aClosure  }  }  let myObject = MyClass { @Sendable in  let a = 3 } The Main Actor &amp;amp; Final Actors Actors是引用类型，它同步自身的内部状态，可以从不同线程安全地修改它们。这是通过保证同一时间只有一个任务或线程可以修改actor的状态来实现的。actor是可发送的类型，意味着它可用于并发环境。actor是可以实例化的，并在大部分情况下，像普通class一样的类型。
但是，有时我们遇到需要总是保证在同一个线程上运行，但可能被分散到各处，甚至跨不同文件时的场景，又该如何处理呢？
The Main Thread 主线程唯一职责是运行UI相关代码。如果想更新一个标签、给视图添加颜色或切换一个开关，需要在主线程上执行这些操作。不允许在主线程之外更新UI，若在主线程外更新UI，轻则编译器给出警告，重则会导致运行时崩溃。如果正在运行异步任务—无论是使用新的并发系统还是旧工具如GCD，并且希望在UI中显示返回的数据，都在主线程上执行这一操作。
因为主线程负责更新UI，如果在主线程执行任何耗时操作，会使应用挂起几秒钟，或导致UI出现明显卡顿和画面掉帧。如果应用长时间挂起，系统会采取措施终止它。这就是为什么很多API，包括URLSession中的所有网络调用，默认在单独的线程中运行的原因，无论使用这些方法的async/await版本还是传统的基于闭包方式的方法。可以强制让URLSession和其他异步API在主线程运行，但建议千万不要这么做。
简而言之，使用UIKit（以及由此延伸的SwiftUI）进行的任何操作都需要在主线程上执行，并且需要避免在主线程上执行耗时的工作。传统上，我们会将数据传递到主线程，调用类似DispatchQueue.main.async的方法。这种方法接受一个在主线程执行的闭包，因此非常适合在主线程中操作你的UI。DispatchQueue是GCD中的一个对象，而main静态属性指的是主线程队列，它始终在主线程运行。这是一种快速且无痛的方法，可以回到主线程，安全，但如果你大量使用它，也会产生相当多的pyramids of doom。在iOS中，任何以UI前缀开头的对象（如UIButton、UISwitch）或在macOS中的任何AppKit对象都只能在主线程中进行修改。
从Xcode 14及其所有配套的OS发布版本开始，UIImage和UIColor是“所有UI前缀的对象都应从主线程进行修改”这一规则的例外。从这个Xcode版本开始，UIImage和UIColor遵循Sendable协议，因此可以安全地在不同的并发域之间传递。
在现代的并发系统中，系统会决定是否将你的任务在不同的线程中启动。请记住我们之前学过的，当任务遇到 await关键字时会暂停，而系统会决定在另一个线程中启动该调用。如果发生暂停，你并不知道代码会在哪里执行，甚至不知道使用哪个线程来交付结果。那么在使用新的并发系统时，我们如何将结果传递给主线程，以便在完成耗时任务后更新我们的UI呢？嗯，很高兴你问到了！
The Main Actor 终于可以解释一下一直在使用的东西，但很难找到一个合适的时机来解释它。是的，就是main actor，它在代码中显示为@MainActor。
UIKit和SwiftUI都是大型的frameworks，它们由成百上千个类组成，很可能分散在框架的不同文件中，它们都有一个要求，即任何UI更新都应在主线程进行。将声明标记为@MainActor意味着该特定功能将在主线程上运行。@MainActor本质上被视为一个属性。在iOS 15、macOS 12、watchOS 8和tvOS 16中，这些框架中的大多数类都标记为@MainActor。在使用SwiftUI时，创建ObservableObjects应手动标记为@MainActor，因为该协议本身并不包含这一功能。将UIKit、SwiftUI和AppKit中的所有对象标记为@MainActor是一种非常优雅的解决方案，以确保它们都在主线程上运行。
Using the @MainActor 如同@Sendable属性，也可以在许多不同地方使用@MainActor属性。可以在类型声明中使用它，比如结构体或类。下面声明了一个结构体和一个类，其中类是用@MainActor标记的：
struct MusicAlbum {  let name: String  let artist: String  let releaseYear: Int }  @MainActor class MusicLibrary {  var name: String  var albums: [MusicAlbum] = []   init(name: String) {  self.name = name  }  } 因为这个原因，想要在类MusicLibrary实例上执行的每一个操作都需要在main actor上运行。MusicLibrary中的每一个属性和方法也会在main actor上运行。想象一下有一个函数createLibraryAndAddAlbum，它是在 MusicLibrary对象本身的上下文之外创建的。你可能试图在这个新函数中对MusicLibrary进行操作。下面示例代码，尝试在一个不在@MainActor上运行的上下文中使用这个类型。
func createLibraryAndAddAlbum() {  let library = MusicLibrary(name: &amp;#34;Andy&amp;#39;s Library&amp;#34;)  let album = MusicAlbum(name: &amp;#34;Imaginareum&amp;#34;, artist: &amp;#34;Nightwish&amp;#34;, releaseYear: 2011)  library.shows &#43;= [album] } 如果尝试编译上面代码，会得到与在不同并发域之间传递非可发送类型时类似的错误：
Call to main actor-isolated initializer &amp;#39;init(name:)&amp;#39; in a synchronous nonisolated context ... Property &amp;#39;albums&amp;#39; isolated to global actor &amp;#39;MainActor&amp;#39; can not be mutated from this context 若在createLibraryAndAddAlbum前加上@MainActor，那么函数也会在main actor中运行。MusicLibrary和createLibraryAndAddAlbum函数将会在相同的actor（同一线程）中运行。无论这两个是否在同一个文件中，甚至跨不同的框架也没关系。这就是为什么main actor被称为全局actor的原因。
@MainActor func createLibraryAndAddAlbum() {  let library = MusicLibrary(name: &amp;#34;Andy&amp;#39;s Library&amp;#34;)  let album = MusicAlbum(name: &amp;#34;Imaginareum&amp;#34;, artist: &amp;#34;Nightwish&amp;#34;, releaseYear: 2011)  library.shows &#43;= [album] } 如果在不同的actor中，可以调用标记为@MainActor的方法，但这样做需要异步进行（使用await或async let），因为@MainActor会在所有使用它的声明中同步其自身的内部状态。
@MainActor func populateFromWebService() async {  albums = []  albums = try await WebService.shared.albumsFromService() } 假设populateFromWebService方法是一个长时间运行的会被挂起的操作，这个actor将会在哪运行？长时间运行的操作（populateFromWebService函数本身）仍然会在不同的线程上运行。你不知道它会在哪里运行，只知道main actor的方法会挂起，而该线程会在返回之前执行其他工作。
在主actor自身上执行的是对albums方法的赋值。仅仅是赋值。populateFromWebService会在其他地方运行，但将它返回的数据赋值给self.albums则会在main actor上执行。很多人误以为populateFromWebService本身会在main actor上执行。也就是说，如果这个方法是从一个慢服务下载一些JSON数据并解析或者做任何可能需要比毫秒更长时间的操作，它会在主线程上运行。这是不正确的，幸运的是全局演员系统比这更聪明。如果在@MainActor上运行某些操作，始终要明白所有语句都会在主演员上执行，但如果它发现一个挂起调用，触发挂起的执行将会在其他地方进行，而数据将返回（并赋值）在主线程上。await的“左边”部分会在主线程上执行，而await关键字的“右边”部分则会在其他地方执行，可以说。
</content>
    </entry>
    
     <entry>
        <title>JavaScript 数据类型</title>
        <url>https://iihui.github.io/post/js-data-struct/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>JS</tag>
        </tags>
        <content type="html"> JavaScript不需要进行类型声明，因此它是一种弱类型的语言，这意味着可以在任何阶段改变变量的数据类型。
字符串 字符串是由零个或者多个字符组成，必须包含在引号中，单引号和双引号都可以。
 数值 如果想给一个变量赋一个数值，不必限定它必须是一个整数。JavaScript允许使用带小数点的数值，并且允许任意位的小数。
 数组 字符串、数值、布尔值都被称为标量（如果某个变量称为标量，那么在任何时候它就只能有一个值）。
数组的声明 var beatles = Array(4) //声明长度 var beatles = Array() var beatles = Array(&amp;#34;John&amp;#34;,&amp;#34;Paul&amp;#34;,&amp;#34;George&amp;#34;,&amp;#34;Ringo&amp;#34;} var bratles = [&amp;#34;John&amp;#34;,&amp;#34;Paul&amp;#34;,&amp;#34;George&amp;#34;,&amp;#34;Ringo&amp;#34;] var lennon = [&amp;#34;john&amp;#34;,1992,false] //数组中声明不同类型的元素 填充数组 var lennon = Array() lennon[&amp;#34;name&amp;#34;] = &amp;#34;john&amp;#34; lennon[&amp;#34;year&amp;#34;] = 1940 lennon[&amp;#34;living&amp;#34;] = false  对象 与数组相似，对象也是使用一个名字来表示一组值，对象的每个值都是对象的一个属性。
var lennon = Object() lennon.name = &amp;#34;john&amp;#34; lennon.year = 1980 lennon.living = false  var lennon = {name:&amp;#34;john&amp;#34;,year:1940,living:false} //更简洁的声明方式  运算符 相等操作符==并不是表示严格意义的相等。例如下面的代码中==操作符认为空字符和false的值是相等的，因此返回真。
var a = false var b = &amp;#34;&amp;#34; if ( a == b){  alert(&amp;#34;a 等于 b“) } 如果要进行严格意义的相等判断，则需要使用===，这个全等操作符，不仅比较值而且比较类型。同理，要比较严格不等也要使用！==。
</content>
    </entry>
    
     <entry>
        <title>泼辣修图中的人像工具</title>
        <url>https://iihui.github.io/post/pixel-portrait/</url>
        <categories>
          <category>后期</category>
        </categories>
        <tags>
          <tag>后期</tag><tag>泼辣</tag>
        </tags>
        <content type="html">  在泼辣修图中有22个强大且易用的人像调整工具，涵盖了面部结构、五官大小、肤色亮度等等的调整。当图片中出现一张脸时，泼辣修图会智能的识别脸部并区分其五官，选中相应的区域然后调整对应的参数即可。
 自动调整 点击自动增强，程序可以自动优化五官、结构和肤色，使得照片呈现更好的状态。
 皮肤控制 皮肤控制选项包括平滑，光泽，阴影，高光，色相，跑和度，下面一一说明：
皮肤平滑：提高数值可以实现磨皮效果，让皮肤更加光滑细腻，降低数值可以增加皮肤质感。
皮肤光泽：提高数值可以为面部补光，让面部看起来更加白皙明亮，降低数值可以降低面部的亮度。
皮肤阴影：控制面部较暗区域的亮度，一般而言我们需要降低皮肤阴影的数值，提高皮肤高光的数值，让面部的立体感更加强烈。
皮肤高光：控制面部较亮区域的亮度，一般而言我们需要降低皮肤阴影的数值，提高皮肤高光的数值，让面部的立体感更加强烈。
皮肤色相：改变皮肤的色彩，例如让皮肤由偏红色转变为偏黄色.
皮肤饱和度：控制面部皮肤的色彩鲜艳程度，如果我们感觉面部过于泛红时可以降低该选项；如果感觉面部皮肤没有气色时，可以提高该选项。
 面部控制 面部控制选项包括面部宽度，下巴宽度，前额宽度。其中面部宽度用于调整面部的宽度，下巴高度用于控制下巴的高度，前额宽度用于控制额头的高低：
 眼睛控制 眼睛控制包括眼睛大小、亮度、对比度以及清晰度：
 鼻子调整 鼻子控制包括：鼻子宽度和鼻子长度：
 嘴巴调整 嘴巴控制包括微笑、嘴高度、嘴宽度、亮度以及饱和度：
 牙齿控制 牙齿控制包括牙美白和牙亮度：
 参考资料
</content>
    </entry>
    
     <entry>
        <title>泼辣修图后期术语3</title>
        <url>https://iihui.github.io/post/pixel-term3/</url>
        <categories>
          <category>后期</category>
        </categories>
        <tags>
          <tag>后期</tag>
        </tags>
        <content type="html"> 质感 质感：质感是指物体的材质与质量所带给人的感觉。在泼辣修图中，质感选项下的调整包括清晰度、锐化、降噪色彩、降噪明度。
清晰度 清晰度用来调整画面的清晰程度。提高清晰度数值可以让画面更加清晰，可以用来修复轻微失焦的画面。降低清晰度数值可以画面更加模糊，有时候可以用它来模拟动漫效果、水彩效果等。
 锐化 锐化是补偿图像的轮廓，增强图像的边缘及灰度跳变的部分，使图像变得清晰。它的效果相较于清晰度更加细腻。
 降噪色彩 噪点分为两种：色彩噪点与明度噪点。所谓色彩噪点，就是带有颜色的画面噪点；所谓明度噪点，就是不带有色彩的画面噪点。
下面的左图，可以明显的观察到颜色噪点的存在（为了方便观察，此处的锐化值提高到了&#43;50）。当对中间这张图应用了色彩降噪之后，画面留下的就是明度噪点，可以看到，明度噪点就是类似黑白颗粒一样的存在。最右边这张图是同时使用色彩降噪和明度降噪之后的效果，可以看到画面相较于原图更加纯净。
 去雾 去雾是指消除画面中的雾霾或为画面添加雾霾。提高去雾值，让画面更加通透自然；降低去雾值，为画面加入雾气。
 曲线 曲线分为白色曲线、红色曲线、绿色曲线、蓝色曲线，白色曲线又称为RGB曲线，红色曲线、绿色曲线、蓝色曲线又统称为通道曲线。
曲线的初始形态是一条45度的直线，当调整这条直线的形态时就可以达到调整画面的目的。利用白色曲线可以调整画面的曝光，利用红色曲线、绿色曲线、蓝色曲线可以调整画面的色彩。
 白色曲线 </content>
    </entry>
    
     <entry>
        <title>泼辣修图后期术语2</title>
        <url>https://iihui.github.io/post/pixel-term2/</url>
        <categories>
          <category>后期</category>
        </categories>
        <tags>
          <tag>后期</tag><tag>泼辣</tag>
        </tags>
        <content type="html"> 曝光 曝光：用于调整画面的明亮程度。提高曝光值会让画面变得更加明亮，整体显得干净而又轻盈；降低曝光值会让画面变得更加昏暗，整体显得沉重而又严肃。
 高光、白色色阶、黑色色阶、阴影 可以按照曝光去划分照片的区域，例如把照片划分为最亮的区域、较亮的区域、较暗的区域和最暗的区域，这样我们就可以实现对照片的精细调整。
在泼辣修图中，这4个区域，按照如下关系进行对应：①高光——最亮的区域；②白色色阶——较亮的区域；③黑色色阶——较暗的区域；④阴影——最暗的区域。
高光对应的是画面中最亮的部分，例如天空。降低高光值，可以降低天空的亮度，让天空的细节得到更好的呈现。
白色色阶对应的是画面中比较亮的部分，它的影响范围一般比高光更大。这两个参数调整并不会对画面中较暗的区域，如下图所示调整高光和白色色阶并不会影响阴影和黑色色阶部分：  阴影对应最暗的区域；黑色色阶对应的是画面中比较暗的部分，它影响的范围一般比阴影更大。阴影和黑色色阶两个参数调整并不会对画面中较亮的区域。  色温 当黑体发射的光的颜色与某个光源所发射的光的颜色相同时，这个黑体加热的温度称之为该光源的颜色温度，简称色温。简而言之色温就是指光线的颜色，不同的光源具有不同的色温。
当色温越高的时候，光源发出的颜色就越偏冷，大致是经历一个红——橙红——黄——黄白——白——蓝白的渐变过程。 一天中的色温也是在不停发生变化的，例如日出之前的色温是蓝色，日出之后的色温是橙色，中午的色温是白色，而晚上的色温是黄色等等，引起太阳光颜色变化的原因主要是因为大气层的反射作用，而并不是因为太阳的温度发生了大幅度的改变。
为画面加入黄色可以提高色温值；或画面加入蓝色可以降低色温值。  白平衡 白平衡是指将白色还原为白色的过程。如果我们身处一个黄色光源的环境之中，那么环境中的白色会被渲染成黄色。由于人眼具有智能色偏修正的功能，即使进入这样一个环境，过不了多久我们就能适应这个环境的光源色彩，因此有可能感觉不到白色发生了异常。但是，相机没有智能色偏修正，因此需要借助白平衡的能力来实现纠正色偏的效果。
可以通过为相机设置一个机内色温值来实现白平衡的效果，当机内色温值与外界一致时，相机就能正确的表现白色。例如现在外界色温是4000K，我们将机内色温也设置为4000K时，白色就能被相机还原为白色。
如果相机内设置的色温大于环境中的色温时，相机就会认为外界色温是偏蓝色的，因此需要增加黄色来中和蓝色，以实现还原白色的效果。
如果相机内设置的色温小于环境中的色温时，相机就会认为外界色温是偏黄色的，因此需要增加蓝色来中和黄色，以实现还原白色的效果。
 使用色温值来调节白平衡 不同的色温能够给人不同的心理感受。例如暖色能够给人一种温暖、温馨、和谐的感觉；冷色则能够给人一种平静、阴凉、寒冷的感觉；中性色则能给人一种安宁、舒适、稳定的感觉。
在后期创作的时候，就要学会使用不同的色温去辅助我们表达不同的感情效果。可以利用色温工具实现画面的白平衡，从而得到一个更加中性的色彩取向。
  当画面偏蓝的时候，可以提高色温值，为画面加入暖色（黄色），从而实现白平衡的效果。   当画面偏黄的时候，我们可以降低色温值，为画面加入冷色（蓝色），从而实现白平衡的效果。    色调 色调：为画面加入洋红色（品红色）可以提高色调值；为画面加入绿色可以降低色调值。也就是说，当降低色调工具的值时，可以为画面加入绿色，当我们提高色调工具的值时，可以为画面加入洋红色。 如果画面偏洋红色，就可以降低色调为画面加入绿色，从而削弱洋红色，以呈现出更加中性的色调：  色温和色调工具通常结合起来帮助我们调整画面的白平衡以及渲染画面的色彩。例如这一张照片：
为了降低画面的色温值，为画面加入蓝色；提高色调值，为画面加入洋红色：  色调分离 利用色调分离工具可以为画面的阴影或高光加入指定的色彩。当为高光加入某种色彩时，它主要会影响画面中亮度较高的区域；当我们为阴影加入某种色彩时，它主要会影响画面中亮度较低的区域。
可以看到，当为高光加入黄色的时候，天空（比较亮的区域）受到了较为明显的影响，但是地面（比较暗的区域）受到的影响则不大；
于此同时，当为阴影加入蓝色的时候，地面（比较暗的区域）受到的影响比较明显，但是天空（比较亮的区域）受到的影响则不大。
 暗角 是指因为镜头存在光学缺陷等原因导致相机进光不均匀，因此出现照片四周亮度较低的现象。
当为画面增添暗角时，可以让画面的视觉焦点更加集中；在后期中，我们不仅仅会为照片添加暗角，有时候也会为照片添加亮角，即照片四周亮度高于中间，这可以营造一种明亮、纯洁的画面氛围。在泼辣修图中，质感选项下的调整包括暗角程度、暗角羽化、暗角高光、暗角大小、暗角圆度。
 暗角程度 用于控制暗角的浓烈程度。数值为正值时，为画面加入白色边角；数值为负值时，为画面加入黑色边角；绝对值越大，效果越强烈。  暗角羽化 暗角羽化用于控制暗角的羽化程度（柔和程度），数值越大边缘越柔和。
 暗角高光 暗角高光：数值越大，画面中的高光部分受到暗角影响的程度就越小（营造不规则的暗角风格）。
 暗角大小 暗角大小：控制暗角的影响范围，数值越小不受暗角影响的区域就越小（当然受影响的区域就越大）。
 暗角圆度 暗角圆度：控制暗角的圆形程度。数值越大暗角越呈现出圆形，数值越小暗角越呈现出方形。
 </content>
    </entry>
    
     <entry>
        <title>泼辣修图后期术语1</title>
        <url>https://iihui.github.io/post/pixel-term1/</url>
        <categories>
          <category>后期</category>
        </categories>
        <tags>
          <tag>后期</tag><tag>泼辣</tag>
        </tags>
        <content type="html"> 对比度 维基百科对比度的解释为：画面黑与白的比值，即从黑到白的渐变层次。比值越大，从黑到白的渐变层次越多，从而色彩表现越丰富。对比度对于视觉的影响非常关键，一般说来对比度越大，图像越清晰越醒目，色彩也越鲜明亮丽；对比度小，则让整个画面灰蒙蒙的。
提高对比度可以让画面更加通透，但是会损失一些细节；降低对比度会让画面获得相对更加丰富的细节，但是会让画面灰蒙蒙的。
 饱和度 饱和度是指色彩的纯度，一种颜色的饱和度越高，它就越鲜艳；反之，一种颜色的饱和度越低，它就越接近于灰色。
一张照片的饱和度越高，越能引起人的注意，但是过高的饱和度有时候会让人产生反感的情绪：
一张照片的饱和度越低，画面就越平和，就越能给人安静、舒适的视觉感受，但是过低的饱和度有时候会让画面产生不通透感。
提高饱和度的数值时，画面会变得更加鲜艳，但是如果数值提高得过高，有时候会让画面出现色彩溢出等不正常现象。
降低饱和度的数值时，画面会变得更加偏灰，如果将数值降至最低，画面会变成黑白照片。
 自然饱和度 自然饱和度工具相当于智能饱和度工具，它可以控制画面的饱和度程度，不会让画面过于饱和。
相比于饱和度，自然饱和度会保护饱和度高的地方，比如说提升自然饱和度的时候，本来高饱和的区域提升幅度较弱，本来低饱和的区域提升幅度较强，而饱和度则是同等幅度提升所有颜色的饱和度。
因此，在进行后期的调整的时候，特别是调整风光类照片的时候，可以更多的采用自然饱和度工具去调整画面的色彩，这样不容易出现过度饱和的问题。
 增强画面表现力 有时候感觉画面有些沉闷，这时可以尝试提高画面的饱和度，让画面的色彩更加鲜艳，从而让画面拥有更强的色彩表现力。
 削弱色彩攻击性 画面饱和度过高会让色彩的攻击性增强，但是过高的饱和度容易让画面对人产生过度的刺激，有时候过高的饱和度还会让画面显得沉重，或者画面显得比较脏。这时就可以通过降低画面的饱和度削弱色彩的攻击性。
 变黑白照片 将画面的饱和度降到最低时，画面就可以变成黑白照片，如下图所示：
 调整局部色彩 可以利用HSL、笔刷等工具分别调整不同颜色或不同区域的饱和度，让画面形成高饱和和低饱和并存的局部色彩效果，更好的凸显画面主体、增强画面的视觉表现力。
利用HSL调整青色的饱和度，将其值调到-100可以得到下图：
 色相 色相（Hue）是指色彩的相貌名称，例如红色、橙色、紫色等。它是颜色的首要特征，是区别各种不同色彩最准确的标准。除了黑白灰以外的其他颜色都有色相属性。
当使用HSL工具去调整色相时，可以将一种颜色转变为另一种颜色。例如选中蓝色，调整蓝色的色相时：
画面中的树叶和向日葵并没有受到影响，这是因为树叶和向日葵的颜色并不是蓝色，因此我们在调整蓝色色相的时候，其他颜色并不会受到影响。
 明度 即是指一种颜色的明亮程度，明度越高，颜色越明亮（白一点），明度越小，颜色越深沉（暗一点）。同一种颜色有明暗之分，例如浅蓝色和深蓝色，不同颜色之间也有明暗之分，例如黄色的明度就相对比较高，紫色的明度就相对比较低。
可以看到在HSL工具中，当调整蓝色明度的时候，画面中蓝色（天空）发生了变化，其颜色更加明亮或深沉。但是画面中的绿色（树叶）、黄色（向日葵）则不受影响。
 亮度 亮度用于调整画面的灰色，相较于“曝光”，它的调整范围主要集中于中间调，可以用于修复画面的细节。提高亮度的效果近似于提高曝光&#43;降低对比度；降低亮度的效果近似于降低曝光&#43;提高对比度。
HSL HSL工具可以帮助我们来调整一种颜色的色相、饱和度、明度。例如当选中蓝色，然后调整蓝色的色相。可以看到，天空的颜色发生了改变，左边、中间和右边的天空颜色都明显不同，这是因为我们改变了蓝色的色相，而天空是蓝色的，所以受到了影响。
画面中的树叶和向日葵并没有受到影响，这是因为树叶和向日葵的颜色并不是蓝色，因此我们在调整蓝色色相的时候，其他颜色并不会受到影响。
 同理，选中蓝色，然后调整蓝色的饱和度。提高饱和度之后，天空的色彩变得更加鲜艳了；降低饱和度之后，天空的色彩更加偏向于灰色了：
与此同时，画面中的树叶和向日葵并没有受到影响，因为我们调整的是蓝色的饱和度，但是树叶和向日葵的颜色并不是蓝色，所以说饱和度并不会随之改变。
 利用HSL分区调整 分区调整，就是指把照片按照一定的标准划分为不同的区域，然后对这些区域分别调整。而HSL工具就可以把画面按照色彩进行划分，然后针对不同的色彩进行调整。在HSL工具里面，可以选择洋红色、紫色、蓝色、青色、红色、橙色、黄色、绿色这8种颜色进行分别调整。
 提高饱和度让天空更鲜艳 在调整天空颜色时，一般选择蓝色和青色，这是最为常见的天空颜色。在下图中，如果选择红色，然后调整红色的饱和度，天空将不会受到影响；而当选中蓝色，然后提高蓝色的饱和度时，则可以看到天空的颜色明显变得更加鲜艳了。
 利用明度调整天空的亮度 例如选中蓝色，当降低蓝色的明度时，可以看到第二张照片相对于第一张照片天空的亮度降低了；当提高蓝色的明度时，可以看到第三张照片中的天空变得更加明亮了。
因此，可以利用较高明度的天空去表达一种轻盈、通透的场景氛围，可以利用较低明度的天空去表达一种深沉、压抑的场景氛围。
 利用色相渲染天空色彩 不同色相对于人的心理存在不同的影响，我们可以利用色相的这一特性去渲染天空的色彩，使画面呈现出不同的场景氛围。
例如选中蓝色，然后提高蓝色的色相值，这时候天空一般会呈现出紫色，画面会给人一种晚霞的场景感；当降低蓝色的色相值，这时候天空一般会呈现出青色，能够给人一种微妙的离奇感，因为它不同于我们常见的天空色彩。
 利用HSL调整草地/树木 在下图中，草地显得有些枯黄，如果想要将它们变成蓝天绿草的效果，该如何处理呢？ 画面中的这些草地是黄色的，因此可以选中黄色，然后调整黄色的色相，使草地的颜色由黄色转换为绿色：
提高黄色的色相，使其有黄色转换为绿色，然后提高黄色的饱和度，使草地的颜色更加鲜艳，然后降低黄色的明度，使草地的颜色更加深沉。
 经过这样的调整之后，可以发现画面中还存在一些枯草，这些枯草对应的色彩是橙色，因此可以选中橙色，然后调整橙色的色相，将橙色转换为绿色：
提高橙色的色相，使画面中草地的颜色由橙色转变为绿色；然后提高橙色的饱和度，使得草地的颜色更加鲜艳；然后降低橙色的明度，让草地存在高明度与低明度的对比，从而让画面更加富有层次感。
 然后可以调整一下画面的天空，利用前面学习的调整天空的方法，这张照片中天空的色彩更加倾向于青色，因此我们选中青色，然后调整青色：
提高青色的饱和度，使得天空的颜色更加鲜艳，我们降低青色的明度，使得天空的亮度变低，从而呈现出更加丰富的细节。
 经过这样几步简单的调整，这张照片就呈现出蓝天绿草的景观了。利用HSL工具调整草地/树木的时候，我们的思维过程是这样的：
  确定最终色
  选择目标色
  色彩输出
  使用HSL工具之前，首先要思考的是我们最终想要呈现的效果是怎样的。例如，在上图中，我们最终想要的效果是让天空更蓝、草地变绿，这就是需要的最终色。
 例如看到下面这张枫叶时，可能想到调整画面中的黄色和橙色，因为这两个颜色比较接近，其他颜色都离画面中枫叶的颜色太远了。 但是当调整黄色的时候，发现画面基本上没有变化时，就可以确定调整橙色了。按下图右侧的数值，依次调整色相，饱和度，明度:  </content>
    </entry>
    
     <entry>
        <title>使用pixelmator pro修改证件照背景颜色</title>
        <url>https://iihui.github.io/post/pixel-background/</url>
        <categories>
          <category>后期</category>
        </categories>
        <tags>
          <tag>后期</tag><tag>mator</tag>
        </tags>
        <content type="html">  现有一张白底的证件照需要修改为蓝底的。使用pixelmator pro这款软件，自己摸索出了2种方法来实现这个需求。
 第一种方法 第一种方法的思路，首先将头像抠出来，然后新建一个同样大小的文件，再将抠出来图层粘贴到新建的图层，最后改变背景的颜色。可归纳为抠图$\to$新建$\to$换背景。
抠头像 首先使用pixelmator pro将原照片打开，然后使用快速选择中的快速选区，如下图所示：
然后移动圆圈，左键点击选中那只兔子,如下图所示黄色部分：
最后释放鼠标左键，表示选中对应区域，如下图虚线所示
 新建文件 选中兔子之后，将按住command&#43;c复制，然后新建一个新的文件，如下图所示，其中红色框中表示可以调整大小：
然后将之前抠出来的那只兔子，粘贴到新的文件中，就形成了如下所示的两个图层：
 填充背景颜色 然后选中上图的白色背景图层，在右边的工具栏中选中样式，如下图所示：
然后选择填充，填充的时候选择颜色，不要选渐变。然后选择喜欢的颜色，至此就完成了背景的更改：
 第二种方法 第二种方法的思路是先选中背景颜色的区域，然后对这个区域用另外一种颜色进行填充。可归纳为选择$\to$替换。
按颜色选择背景 首先在右侧的工具栏中选择快速选择，然后选择选择颜色，如下所示：
然后选择背景颜色区域对应的颜色，如下图虚线所示：
 填充背景颜色 选择好颜色区域之后，然后在右侧的工具栏中选择颜色填充，如下图所示：
然后选择相应的颜色在我们选定的区域内进行填充，如下图所示，但是在填充的时候要选择平滑边缘，至此背景色就已经改好了。
 </content>
    </entry>
    
     <entry>
        <title>Go 实现各种内排序算法</title>
        <url>https://iihui.github.io/post/go-sort/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html"> 内排序是指在排序过程中，数据都能够放在内存中处理，排序时不涉及数据的内、外交换。
插入类排序 直接插入排序 func InsertSort(data []int) { 	var i, j, cur int 	length := len(data) //获得切片对应数组的长度  	for i = 1; i &amp;lt; length; i&#43;&#43; { 	cur = data[i] 	for j = i - 1; j &amp;gt;= 0; j-- { 	if data[j] &amp;gt; cur { 	data[j&#43;1] = data[j] 	} else { 	break 	} 	} 	data[j&#43;1] = cur 	} }  二分直接插入排序 func BinInsertSort(data []int) { 	var cur, start, mid, end int 	length := len(data) 	for i := 1; i &amp;lt; length; i&#43;&#43; { 	cur = data[i] 	start = 0 	end = i - 1 	for start &amp;lt;= end { 	mid = start &#43; (end-start)/2 	if data[mid] == cur { 	end = mid 	break 	} else if data[mid] &amp;gt; cur { 	end = mid - 1 	} else { 	start = mid &#43; 1 	} 	}  	for j := i - 1; j &amp;gt;= end&#43;1; j-- { 	data[j&#43;1] = data[j] 	} 	data[end&#43;1] = cur 	} }  shell排序 func shellCore(data [] int, step int) { 	var i, j, cur int 	length := len(data) 	for i = step; i &amp;lt; length; i&#43;&#43; { 	cur = data[i] 	for j = i - step; j &amp;gt;= 0; j -= step { 	if data[j] &amp;gt; cur { 	data[j&#43;step] = data[j] 	} else { 	break 	} 	} 	data[j&#43;step] = cur 	} }  func ShellSort(data [] int) { 	step := len(data) / 2 	for step &amp;gt; 0 { 	shellCore(data, step) 	step /= 2 	} }  交换类排序 冒泡排序 func BubbleSortBig(data []int) { //大数沉底 	length := len(data)  	for i := 1; i &amp;lt; length; i&#43;&#43; { 	flag := false //标志本趟是否有交换 	for j := 0; j &amp;lt; length-i; j&#43;&#43; { 	if data[j] &amp;gt; data[j&#43;1] { 	data[j], data[j&#43;1] = data[j&#43;1], data[j] //并行赋值 	flag = true 	} 	}  	if !flag { 	break 	} 	} } func BubbleSortSmall(data [] int) { //小数上浮 	length := len(data) 	for i := 1; i &amp;lt; length; i&#43;&#43; { 	flag := false 	for j := length - 1; j &amp;gt;= i; j-- { 	if data[j] &amp;lt; data[j-1] { 	data[j], data[j-1] = data[j-1], data[j] //并行赋值 	flag = true 	} 	} 	if !flag { 	break 	} 	} }  快速排序 func partition(data [] int, start int, end int) int { 	small := start - 1 	index := rand.Intn(end-start) &#43; start //找到随机的基准 	data[index], data[end] = data[end], data[index] //并行赋值  	for i := start; i &amp;lt; end; i&#43;&#43; { 	if data[i] &amp;lt; data[end] { 	small&#43;&#43; 	if small &amp;lt; i { 	data[small], data[i] = data[i], data[small] //并行赋值 	} 	} 	} 	small&#43;&#43; 	data[small], data[end] = data[end], data[small] //并行赋值 	return small }  func QuickSort(data []int, start int, end int) { 	if start &amp;lt; end { 	pivot := partition(data, start, end)  	if pivot &amp;gt; start { 	QuickSort(data, start, pivot-1) 	}  	if end &amp;gt; pivot { 	QuickSort(data, pivot&#43;1, end) 	} 	} }  选择类排序 简单选择排序 func SelectSort(data []int) { 	length := len(data)  	for i := 0; i &amp;lt; length-1; i&#43;&#43; { 	index := i 	for j := i &#43; 1; j &amp;lt; length; j&#43;&#43; { 	if data[j] &amp;lt; data[index] { 	index = j 	} 	} 	if index != i { 	data[i], data[index] = data[index], data[i] 	} 	} }  堆排序 func adjustHeap(data []int, start int, end int) { 	for parent, child := start, 2*start&#43;1; child &amp;lt;= end; child = 2*parent &#43; 1 { 	if child &amp;lt; end &amp;amp;&amp;amp; data[child] &amp;lt; data[child&#43;1] { //注意控制条件 	child&#43;&#43; 	}  	if data[parent] &amp;lt; data[child] { 	data[parent], data[child] = data[child], data[parent] 	parent = child 	} else { 	break 	} 	} }  func HeapSort(data []int) { 	length := len(data) 	for i := (length - 2) / 2; i &amp;gt;= 0; i-- { 	adjustHeap(data, i, length-1) 	}  	for i := length - 1; i &amp;gt; 0; i-- { 	data[i], data[0] = data[0], data[i] 	adjustHeap(data, 0, i-1) 	} }  归并排序 func mergeCore(data, assist []int, start, end int) { 	if start == end { 	assist[start] = data[start] 	return 	}  	mid := start &#43; (end-start)/2 	mergeCore(data, assist, start, mid) 	mergeCore(data, assist, mid&#43;1, end)  	i, j, k := start, mid&#43;1, start  	for i &amp;lt;= mid &amp;amp;&amp;amp; j &amp;lt;= end { 	if data[i] &amp;lt; data[j] { 	assist[k] = data[i] 	k&#43;&#43; 	i&#43;&#43; 	} else { 	assist[k] = data[j] 	k&#43;&#43; //Go中后置&#43;&#43;不能作为表达式，只能是语句 	j&#43;&#43; 	} 	}  	for i &amp;lt;= mid { 	assist[k] = data[i] 	k&#43;&#43; //Go中后置&#43;&#43;不能作为表达式，只能是语句 	i&#43;&#43; 	} 	for j &amp;lt;= end { 	assist[k] = data[j] 	k&#43;&#43; //Go中后置&#43;&#43;不能作为表达式，只能是语句 	j&#43;&#43; 	}  	for i := start; i &amp;lt;= end; i&#43;&#43; { 	data[i] = assist[i] 	} }  func MergeSort(data [] int) { 	assist := make([]int, len(data)) //需要重新生成一个切片 	mergeCore(data, assist, 0, len(data)-1) }  计数排序 func CountSort(data []int, radix int) { 	length := len(data) 	count := make([]int, radix) 	assist := make([]int, length)  	for i := 0; i &amp;lt; length; i&#43;&#43; { 	count[data[i]]&#43;&#43; 	}  	for i := 1; i &amp;lt; radix; i&#43;&#43; { 	count[i] &#43;= count[i-1] 	}  	for i := length - 1; i &amp;gt;= 0; i-- { 	count[data[i]]-- //下标是从0开始的，因此先减1 	assist[count[data[i]]] = data[i] 	}  	for i := 0; i &amp;lt; length; i&#43;&#43; { 	data[i] = assist[i] 	} }  基数排序 func findMax(data []int) int { 	length, max := len(data), data[0] 	for i := 1; i &amp;lt; length; i&#43;&#43; { 	if data[i] &amp;gt; max { 	max = data[i] 	} 	} 	return max }  func BucketSort(data []int, radix, exp int) { 	length, count, assist := len(data), make([]int, radix), make([]int, len(data)) 	for i := 0; i &amp;lt; length; i&#43;&#43; { 	count[(data[i]/exp)%radix]&#43;&#43; 	}  	for i := 1; i &amp;lt; radix; i&#43;&#43; { 	count[i] &#43;= count[i-1] 	}  	for i := length - 1; i &amp;gt;= 0; i-- { 	count[(data[i]/exp)%radix]-- 	assist[count[(data[i]/exp)%radix]] = data[i] 	}  	for i := 0; i &amp;lt; length; i&#43;&#43; { 	data[i] = assist[i] 	}  }  func RadixSort(data []int, radix int) { 	max := findMax(data) 	for exp := 1; exp &amp;lt;= max; exp *= radix { 	BucketSort(data, radix, exp) 	} }  </content>
    </entry>
    
     <entry>
        <title>C&#43;&#43; 常见知识点</title>
        <url>https://iihui.github.io/post/cpp-base/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>C&#43;&#43;</tag>
        </tags>
        <content type="html"> static的作用   对普通函数和全局变量而言static具有隐藏作用：将其修饰的全局变量和函数的作用域限定在本文件中。不加static修饰的函数和全局变量具有全局可见性。
  普通局部变量而言
  未初始化的static普通局部变量，编译器会将其初始化为0，因为BSS段(未初始化数据段）中所有的字节都默认为0x00。
  使用static修饰的普通局部变量的生存期为整个源程序，即初始化一次便具有记忆性。但是，作用域只在定义该变量的函数中。
void testLocalStaticVar(){  static int x = 4;  x&#43;&#43;;  std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; }  int main(int argc, char **argv) {  for (int i = 0; i &amp;lt; 3; &#43;&#43;i) {  testLocalStaticVar(); }   return 0; } // 5,6,7     成员变量：
  属于类的，只有一份，每个对象共享，可以使用类名直接调用。
  除了基本整型的const static整型可以在类的定义体中初始化，其他的必须在类外初始化。
  sizeof计算的时候不会计算静态数据成员，因为它不放在栈区，放在全局（静态）存储区。
    成员函数：
  不与任何对象实例关联，所以没有this指针，因此不能访问非静态成员变量和成员函数。
  static成员函数不能声明为const。毕竟将函数声明为const就承诺不会修改该函数所属对象，而static成员函数不属于任何对象实例。
  因为没有this指针的开销，所以静态成员函数与类的非静态成员函数相比速度上有少许增长。
     const的作用 对于普通变量而言const修饰符的目的为了替代宏定义，与宏定义对比，总共有5点区别：
  const常量有类型，编译器对其进行类型安全检查；而宏定义没有类型，编译器只对宏定义进行字符替换。
  #define是一个编译时概念，在预处理的时候展开，进行直接替换，存储在代码段，不分配内存，生命周期止于编译时期；而const常量存在于数据段，分配内存，属于运行时的概念。
  宏定义可以使用#undef来使之前的宏定义失效；const常量定义后将在定义域内永久有效。
  使用const常量可能比使用#define产生更小的目标代码（例如代码中使用100次同一个宏定义）。
  常量折叠（编译期间简化常量表达式&amp;ndash;对常量表达式求值,并将求得的值替换表达式，放入到常量表中)。
   普通变量与const修饰符需注意的3点：
  声明const变量时必须进行初始化
  const对象的动态数组：必须提供数组的初始化
  const全局变量：在全局作用域中声明的const变量是定义该对象的文件的局部变量，此变量只存在于那个文件中，不能被其他文件所访问。
   指针变量和const修饰符：
  const指针：一旦初始化便不能再指向别的对象，但是可以通过解引用来改变所绑定对象的值。
  指向const对象的指针：不能通过解引用来改变所指的对象的值，但是可以更改所指向的对象，即解除绑定，重新再绑定。
  指向const对象的const指针：一旦初始化便不能再指向别的对象，也不能通过解引用来改变所指的对象的值。
   函数与const修饰符：
  函数的返回值和const修饰符：
 如果返回值是值类型(非指针、引用类型），对于内部数据类型来说，返回值是否是常量并没有关系。而对类类型如果返回值为某个对象的const或某个对象的引用const，则返回值具有const属性，只能访问返回值的公有(可能也可以保护成员）数据成员和const成员函数，并且不允许进行赋值操作。     如果返回值是指针类型，函数不能返回局部变量的指针，因为函数调用之后栈被清理，只能返回指向堆区的分配的存储空间的指针，或者指向静态存储区的指针，因为在函数返回后它们依然有效。   函数的参数和const修饰符：
  如果是传值：对函数调用者的约束不太大，可以传入一个const变量也可以传入一个普通变量，只能说明在函数中不会改变其值。
  如果是传指针：对于指向非const变量的指针参数，只能传入一个指向非const变量的指针，不能传入一个const指针，因为指明不能通过解引用来改变值。因此，若是传地址，则无论什么时候传递一个地址给函数，应该尽可能用const修饰它（除非此实参在函数内需要修改），如果不这么做，就使得指向const的指针不能做实参。
     函数参数为const引用时可以接收临时对象。   成员变量和const修饰符：
  对于类来说const变量是可变的，但是对于对象实例来说是不可变的。
  必须在构造函数的成初始化列表中初始化。
   成员函数和const修饰符：
  this指针类型由obj * const 变为 const obj * const
  const对象实例、指向const对象的指针、指向const对象的引都只能调用const成员函数。const实施于成员函数的目的，确保该成员函数可作用于const对象实例。如果不存在const成员函数，则const对象实例无法调用任何成员函数。
  对于非const对象而言可以调用const成员函数和非const成员函数。
   C&#43;&#43;构造函数 构造函数的特点 构造函数是一种特殊的成员函数， 它具有如下特点：
  名字与类名相同。
  没有返回值。
  在对象创建时自动调用，但是不能被显式调用。
   构造函数的作用   给创建的对象建立一个标识符;
  为对象数据成员开辟内存空间;
  完成对象数据成员的初始化。
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-02 上午8.27.52.png)
   构造函数的分类 构造函数可以分为普通的构造函数和拷贝(复制)构造函数：
  普通的构造函数
  拷贝构造函数: 对于一个构造函数的第一个参数为如下的几种，而且其他参数都有默认值，称为拷贝构造函数：
 A &amp;amp; const A &amp;amp; volatile A &amp;amp; 其中volatile（不稳定的）编译器访问该变量的代码不再进行优化 const volatile A &amp;amp;     防止默认拷贝发生：声明一个私有的拷贝构造函数
  因此一个类其实可以有多个拷贝构造函数，拷贝构造函数又分为：
  浅拷贝：只对对象中的数据成员进行简单的赋值。
  深拷贝：对于对象中动态成员重新分配空间。
   malloc/free和new/delete的区别   malloc/free是标准库函数，而new/delete是C&#43;&#43;运算符。
  new自动计算需要分配的空间，而malloc需要手工计算字节数。
  new是类型安全的，因为new中内置了sizeof, 具有类型转换和类型安全检查功能，而malloc不是类型安全的。
int * p = new float[2]; //编译时指出错误 int *p = (int*)malloc(2*sizeof(double)); //编译时无法指出错误   new首先调用operator new标准库函数，分配足够大的原始的未类型化的空间。接下来调用相关对象的构造函数，以初始化对象。最后返回新分配并构造的对象的指针。而malloc不能调用构造函数；delete将调用该实例的析构函数，然后调用operator delete标准库函数以施放该实例占用的空间，free不能调用析构函数。 ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-02 上午8.27.52.png)
  malloc/free需要头文件支持，而new/delete不需要。
  new操作自由存储区(free store)上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。
  自由存储区是C&#43;&#43;基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。
  堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。
  那么自由存储区是否能够是堆（问题等价于new是否能在堆上动态分配内存），这取决于operator new的实现细节。自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。
  特别地，new甚至可以不为对象分配内存。定位new的功能可以办到这一点： ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-02 上午8.26.28.png)
    new内存分配失败时会抛出bad_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL。
  是否可以被重载 ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-02 上午8.29.22.png)
  new与malloc是否可以相互调用：operator new /operator delete的实现可以基于malloc，而malloc的实现不可以去调用new。
  能够直观地重新分配内存：使用malloc分配的内存后，如果在使用过程中发现内存不足，可以使用realloc函数进行内存重新分配实现内存的扩充。realloc先判断当前的指针所指内存是否有足够的连续空间，如果有，原地扩大可分配的内存地址，并且返回原来的地址指针。如果空间不够，先按照新指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存区域。
  内存分配不足的处理：在operator new抛出异常以反映一个未获得满足的需求之前，它先调用一个用户指定的错误处理函数，这就是new-handler。 ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-02 上午8.32.56.png) ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-02 上午8.30.59.png)
   堆和栈的区别 堆和栈的区别，总共分为6点：   C&#43;&#43;空类默认生成的成员函数   构造函数
  拷贝构造函数
  赋值操作符
  析构函数
  取址运算符
  取址运算符const版本
   delete和delete[]的区别   针对基本数据类型：使用new分配后的不管是数组还是非数组形式内存空间用两种方式均可，原因是：分配简单类型内存时，内存大小已经确定，系统可以记忆并且进行管理，在析构时，系统并不会调用析构函数。
  针对类类型：
  delete ptr;代表用来释放内存，且只用来释放ptr指向的内存。
  delete[] ptr; 用来释放ptr指向的内存，还逐一调用数组中每个对象的destructor。 ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-01 下午2.51.46.png)
  delete a;仅释放了a指针指向的内存空间 , 也就是只调用了 a[0]对象的析构函数， 剩下的从a[1]到a[9]这9个用户自行分配的m_cBuffer对应内存空间将不能释放从而造成内存泄漏。
  delete [] a;释放了a指针指向的全部内存空间，也就是调用a[0]到a[9]对象的析构函数释放分配的内存空间。
     虚函数表 ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-01 下午11.09.32.png)
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-01 下午11.10.04.png)
 一般继承 ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-01 下午11.10.31.png)
多重继承-无虚函数覆盖 多重继承时，有几个基类就有几个vptr
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-01 下午11.11.02.png)
这样做就是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数。
 多重继承-有虚函数覆盖 ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-01 下午11.11.54.png)
 哪些函数不能为虚函数   普通函数 ： 只能重载不能被重写,即不能被继承
  静态成员函数: 不属于任何对象实例，因而没有动态绑定的
  构造函数
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-01 下午11.07.52.png) 按照 动态绑定原理，此时B的构造函数会覆盖掉A的构造函数
  友元函数： C&#43;&#43;不支持友元函数的继承
  内联函数：
  赋值操作符重载函数
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-01 下午11.08.16.png)
   C&#43;&#43;对象布局   单一的一般继承   多重继承   重复继承   菱形继承 ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-01 下午11.06.45.png)    内存溢出 内存溢出(out of memory）：是指程序在申请内存时，没有足够的内存空间供其使用。导致不够用的原因很多,泄漏只是其中一种。通常在运行大型软件或游戏时，软件或游戏所需要的内存远远超出了你主机内安装的内存所承受大小，就叫内存溢出。
内存溢出的几种情况：
  比如系统只有存放integer的空间，但你却申请了存放long，那就是内存溢出。
  比方定义了20个字节大小的内存空间，却写入了21个字节的数据。通俗的说，就是内存不够，没办法支持当前程序。（当发生内存溢出时，程序将无法进行，强制终止。）
   内存泄漏 内存泄漏是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。
内存泄漏的分类：
  常发性内存泄漏。发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。
  偶发性内存泄漏。发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。
  一次性内存泄漏。发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。比如，在类的构造函数中分配内存，在析构函数中却没有释放该内存，所以内存泄漏只会发生一次。
  隐式内存泄漏。程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。 但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。
   C&#43;&#43;中哪些操作符是不能重载的   .  （成员访问运算符)
  .* (成员指针访问运算符）
  :: （域运算符）
  sizeof
  ?: (条件运算符）
  typeid 域运算符和sizeof运算符的运算对象是类型而不是变量或者一般的表达式，不具备重载的特征
   C&#43;&#43;强制类型转换 static_cast   static_cast也可以用在于基类与派生类指针或引用类型之间的转换。然而它不做运行时的检查，不如dynamic_cast安全。static_cast仅仅是依靠类型转换语句中提供的信息来进行转换，而dynamic_cast则会遍历整个类继承体系进行类型检查,因此dynamic_cast在执行效率上比static_cast要差一些。
  编译器隐式执行的任何类型转换都可以由static_cast来完成，比如int与float、double与char、enum与int之间的转换等。
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-02 上午9.45.33.png)
   const_cast  将转换掉表达式的const性质。 ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-02 上午9.39.34.png)  那既然const变量的值是肯定不会发生变化的，还需要这个const_cast类型转化有何用？这就引出了const_cast的最常用用法：
如果 有一个函数，它的形参是non-const类型变量，而且函数不会对实参的值进行改动，这时我们可以使用类型为const的变量来调用函数，此时const_cast就派上用场了。
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-02 上午9.41.33.png)
const_cast绝对不是为了改变const变量的值而设计的！在函数参数的传递上const_cast的作用才显现出来。
 只有使用const_cast才能将const性质性质转化掉。试图使用其他三种形式的强制转换都会导致编译时的错误。（添加const还可以用其他转换符，如static_const）
  除了添加const或删除const特性，使用const_cast符来执行其他任何类型的转换都会引起编译错误。
   dynamic_cast   类型必须为类的指针，引用、void*
  需要检查运行时类型信息，而这个信息存储在虚函数表中，所以只有定义了虚函数的类才可以使用，否则会出现编译错误
  如果绑定到引用或指针对象的类型不是目标类型，则dynamci_cast失败，指针会返回0，引用会抛出bad_cast异常。
   reinterpret_cast 仅仅重新解释类型，但没有进行二进制的转换:
  转换的类型必须是一个指针、引用、算术类型、函数指针或者成员指针
  在比特位级别上进行转换。它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值）
  最普通的用途就是在函数指针类型之间进行转换
   C&#43;&#43; 中的引用   引用是变量的别名，定义引用的时候必须先初始化
  不能定义引用数组
  不能定义引用的引用
  引用可以减少构造开销
  当函数返回引用类型时，没有复制返回值，返回的是对象本身，所以不要返回局部对象的引用
  函数参数为const引用时可以接收临时对象
   </content>
    </entry>
    
     <entry>
        <title>线性表</title>
        <url>https://iihui.github.io/post/arith-linear-list/</url>
        <categories>
          <category>算法</category>
        </categories>
        <tags>
          <tag>算法</tag>
        </tags>
        <content type="html">  线性表是由 $n$个具有相同特性的元素$(n \ge 0)$ 组成的一个有限序列，是一种逻辑结构。它的特征在于：①表中所有数据元素类型相同。②表由有限个数据元素构成。③表中数据元素是位置相关的（这一点表明线性表不同于集合)，并且每个元素都有一个对应的序号，表中元素可以重复出现。
 逻辑结构 线性表是一种逻辑结构，其一般表示为: ($a_1,a_2,&amp;hellip;,a_{i-1},a_i,a_{i&#43;1},&amp;hellip;,a_n$)
  除了起始元素$a_1$没有前驱元素之外，其他元素$a_i$有且仅有一个前驱元素$a_{i-1}$。
  除了终端元素$a_n$没有后继元素外，其他元素$a_i$有且仅有一个后继元素$a_{i&#43;1}$。
  根据上面的表示，在线性表中，每个元素至多只有一个前驱元素，并且至多只有一个后继元素。
存储结构 线性表是一种逻辑结构，其存储结构有两种：
  顺序存储：顺序表
  链式存储：单链表
  顺序表 线性表的顺序存储是指一组地址连续的存储单元依次存储线性表中的各个元素，使得线性表中在逻辑结构上相邻的数据元素存储在相邻的物理存储单元中。即通过数据元素物理存储的相邻关系来反映数据元素之间逻辑上的相邻关系，采用顺序存储结构的线性表通常称为顺序表。
顺序表的特点 根据顺序表的定义，总结顺序表有以下的特征：
  属于直接映射——逻辑上相邻的元素，其物理位置也相邻。
  具有随机存取特性，通过首地址和元素序号可以在 $O(1)$ 时间内找到指定元素。
  存储密度高，其值为$1$。$存储密度=\frac{节点数据本身所占用的存储量}{节点结构占用的存储量}$
  删除和插入元素需要移动大量元素：
  插入元素移动的平均次数$=\frac{1}{n}\sum_{i=1}^{n}(n-i&#43;1)=\frac{n}{2}$, 因此时间复杂度为$O(n)$。
  删除元素移动的平均次数$=\frac{1}{n}\sum_{i=1}^{n}(n-i)=\frac{n-1}{2}$，因此时间复杂度为$O(n)$。
    描述顺序表的结构 为了描述顺序表，需要知道：① 顺序表的起始地址；② 顺序表的最大长度；③ 顺序表的当前长度。
#define MaxSize 1000 typedef struct {  int data[MaxSize];  int length; } SqList; 一些习题 最长平台 给定一个有$n$个元素的整型数组$data$,其中连续的相等元素构成的子序列称为平台，请设计一个算法求 $data$ 中最长平台的长度。
template&amp;lt;typename T&amp;gt; int linerArith&amp;lt;T&amp;gt;::maximumPlatform(T *data, int length) {  int start = 0;  int maxLen = 1;  int curLen = 1;   for (int i = 1; i &amp;lt; length; &#43;&#43;i) {  if (data[i] == data[start]) {  curLen&#43;&#43;;  } else {  if (curLen &amp;gt; maxLen) {  maxLen = curLen;  }  curLen = 1;  start = i;  }  }  //可能最后一个连续的子序列为最大平台  if (curLen &amp;gt; maxLen) {  maxLen = curLen;  }  return maxLen; } 以key为轴调整 设有一个数组 $data$， 其元素为整型数据，设计一个算法将 $data$ 中所有小于 $key$ 的整数放在前半部分，大于等于 $key$ 的整数放在后半部分。
template&amp;lt;typename T&amp;gt; void linerArith&amp;lt;T&amp;gt;::rotate(T *data, int length, int key) {  assert(length &amp;gt;= 0);  int start = 0, end = length - 1;  while (start &amp;lt; end) {  while (start &amp;lt; end &amp;amp;&amp;amp; data[start] &amp;lt; key) {  start&#43;&#43;;  }  while (start &amp;lt; end &amp;amp;&amp;amp; data[end] &amp;gt;= key) {  end--;  }  if (start &amp;lt; end) {  std::swap(data[start], data[end]);  }  } } 以第一个元素为轴调整 设有一个数组 $data$，其元素为整型。设计一个尽可能高效的算法，以第一个元素为分界线，将所有小于等于它的元素移到该元素前面，将所有大于它的元素移到该元素的后面。
template&amp;lt;typename T&amp;gt; void linerArith&amp;lt;T&amp;gt;::rotateByFirst(T *data, int length) {  assert(length &amp;gt;= 0);  int start = 0, end = length - 1;  T pivot = data[0];   while (start &amp;lt; end) {  while (start &amp;lt; end &amp;amp;&amp;amp; data[start] &amp;lt;= pivot) {  start&#43;&#43;;  }   while (start &amp;lt; end &amp;amp;&amp;amp; data[end] &amp;gt; pivot) {  end--;  }   if (start &amp;lt; end) {  std::swap(data[start], data[end]);  }  }  //因为忽略了第一个元素，因此这里需要检查最终位置的那个元素和第一个元素的大小关系  if (data[start] &amp;lt; pivot) {  std::swap(data[start], data[0]);  } }  template&amp;lt;typename T&amp;gt; void linerArith&amp;lt;T&amp;gt;::rotateByFirstVersion2(T *data, int length) {  assert(length &amp;gt;= 0);  int start = 0, end = length - 1;  int pivot = data[0];   while (start &amp;lt; end) {  while (start &amp;lt; end &amp;amp;&amp;amp; data[end] &amp;gt; pivot) {  end--;  }  if (start &amp;lt; end) {  data[start&#43;&#43;] = data[end];  }   while (start &amp;lt; end &amp;amp;&amp;amp; data[start] &amp;lt;= pivot) {  start&#43;&#43;;  }  if (start &amp;lt; end) {  data[end--] = data[start];  }  }  data[start] = pivot; //找到最终位置 }  // 剑指offer里快速排序的思路,该方法保持相对次序不变 template&amp;lt;typename T&amp;gt; void linerArith&amp;lt;T&amp;gt;::rotateByFirstVersion3(T *data, int length) {  assert(length &amp;gt;= 0);  int i = 0;  T pivot = data[0];  for (int j = 1; j &amp;lt; length; &#43;&#43;j) {  //是小于不是&amp;lt;=,因为第一个元素要被替换掉  if (data[j] &amp;lt; pivot) {  i&#43;&#43;;  if (i &amp;lt; j) {  std::swap(data[i], data[j]);  }  }  }  //最后交换下标为0的元素和下标为i的元素  std::swap(data[0],data[i]); } void move1(SqList &amp;amp;L) {  int i = 0;  j = L.length - 1;  int pivot = L.data[0];  int tmp;   while (i &amp;lt; j) {  while (i &amp;lt; j &amp;amp;&amp;amp; L.data[j] &amp;gt; pivot)  j--;  while (i &amp;lt; j &amp;amp;&amp;amp; L.data[i] &amp;lt;= pivot) //第一个元素肯定会被忽略掉  i&#43;&#43;;   //此处可以添加一个 i &amp;lt; j 的判断，这里省略掉是因为前面已经判断i&amp;lt;j,  //所以到这里的时候最多也是i==j, 这时候直接交换也是没有副作用的  tmp = L.data[i];  L.data[i] = L.data[j];  L.data[j] = tmp;   }   if (L.data[i] &amp;lt; pivot)//因为忽略了第一个元素，因此这里需要检查最终位置的那个元素和第一个元素的大小关系  {  tmp = L.data[0];  L.data[0] = L.data[i];  L.data[i] = tmp;  } }  void move2(SqList &amp;amp;L) {  int i = 0, j = L.length - 1;  int pivot = L.data[0];   while (i &amp;lt; j) {  while (i &amp;lt; j &amp;amp;&amp;amp; L.data[j] &amp;gt; pivot) j--; //先从最后开始，因为第一个元素需要首先被替换  if (i &amp;lt; j) {  L.data[i] = L.data[j];  i&#43;&#43;;  }   while (i &amp;lt; j &amp;amp;&amp;amp; L.data[i] &amp;lt;= pivot) i&#43;&#43;;  if (i &amp;lt; j) {  L.data[j] = L.data[i];  j--;  }  }  L.data[i] = pivot; //最后找到最终的位置 }   void move3(SqList &amp;amp;L) //剑指offer里快速排序的思路 { //该算法可以保持相对次序不变  int i = 0;  int pivot = L.data[0];  int tmp;   for (int j = 1; j &amp;lt; L.length; j&#43;&#43;) {  if (data[j] &amp;lt; pivot) {  i&#43;&#43;;  if (i &amp;lt; j) //是小于不是&amp;lt;=,因为第一个元素要被替换掉  {  tmp = L.data[i];  L.data[i] = L.data[j];  L.data[j] = tmp;  }  }  }  tmp = L.data[0]; //最后交换下标为0的元素和下标为i的元素  L.data[0] = L.data[i];  L.data[i] = tmp; } 删除元素 已知长度为$n$的数组$data$，编写一个时间复杂度为$O(n)$,空间复杂度为$O(1)$ 的算法，该算法删除线性表中所有值为$value$的元素。
template&amp;lt;typename T&amp;gt; int linerArith&amp;lt;T&amp;gt;::deleteSameElement(T *data, int length, int value) {  assert(length &amp;gt;= 0);  int base = 0;  for (int i = 0; i &amp;lt; length; &#43;&#43;i) {  if (data[i] != value) {  data[base&#43;&#43;] = data[i];  }  }  return base; }  template&amp;lt;typename T&amp;gt; int linerArith&amp;lt;T&amp;gt;::deleteSameElement(T *data, int length, int value) {  assert(length &amp;gt;= 0);  int count = 0; //不同的是记录目前等于value的元素个数  for (int i = 0; i &amp;lt; length; &#43;&#43;i) {  if (data[i] == value) {  count&#43;&#43;;  } else {  data[i - count] = data[i];  }  }  return length - count; } 一般类似的题目有：已知长度为 $n$ 的线性表 $L$ 采用顺序存储结构，试设计一个时间复杂度空间复杂度两方面都尽可能高效的算法，该算法删除线性表中元素值为$[x,y]$之间的所有数据元素。
单链表 单链表是任意一组存储单元存放线性表中的元素，每个节点通过一个指针指向其后继节点。这组存储单元可以是连续的也可以是不连续的。单链表具有如下的特点：
  通过首节点(带哨兵节点或不带哨兵节点)的指针来标识一个单链表。
  从一个已知节点出发，只能访问该节点和通过 $next$ 指针访问其后继节点，无法直接找到该节点之前的其他节点。
  在单链表中插入一个节点或者删除一个节点必须找到其前驱节点，插入和删除操作不需要移动节点。「删除一个节点也可以不用知道其前驱节点，只要将其后继节点的元素内容往前移到当前节点，并将当前节点的后继修改为其后继节点的后继节点，然后删除后继节点即可。但是要考虑该节点是否为最后一个节点，或者第一个节点」
  typedef struct LinkedNode {  T data; //T表示数据类型  struct LinkedNode *next; } LinkedList; 建立单链表 建立单链表有两种方式，一种是从头部插入；另一种是从尾部插入。从头部插入节点生成的单链表，最后节点元素顺序与插入元素的顺序相反，即成逆序排列了。
void creatLinkedList(LinkedList *&amp;amp;L, int *a, int n) {  LinkedList *cur;  L = (LinkedList *) malloc(sizeof(LinkedList));  L-&amp;gt;next = NULL;   for (int i = 0; i &amp;lt; n; i&#43;&#43;) {  cur = (LinkedList *)(malloc(sizeof(LinkedList)));  cur-&amp;gt;data = a[i];  cur-&amp;gt;next = L-&amp;gt;next;  L-&amp;gt;next = cur; //当前节点成为哨兵节点的下一个节点  } } 尾插法是在单链表的尾部插入节点元素，最后生成的单链表的节点元素顺序和插入元素的顺序是相同的。
void creatLinkedList(LinkedList *&amp;amp;L, int *a, int n) {  LinkedList *cur, *tail;  L = (LinkedList *) malloc(sizeof(LinkedList));  tail = L; //tail始终指向最后的节点，开始时指向链表的头结点   for (int i = 0; i &amp;lt; n; i&#43;&#43;) {  cur = (LinkedList *) malloc(sizeof(LinkedList));  cur-&amp;gt;data = a[i];  tail-&amp;gt;next = cur;  tail = cur;  }  tail-&amp;gt;next = NULL; } 基本操作  按序号查找节点值算法  bool findNode(LinkedList *L,int i,int &amp;amp;result) {  int j=0;  LinkedList *cur=L;   while(cur!=NULL &amp;amp;&amp;amp; j&amp;lt;i)  {  j&#43;&#43;;  cur=cur-&amp;gt;next;  }  if(NULL==cur) return false;   result=cur-&amp;gt;data;  return true;  } 按元素值查找序号算法  int findNode(LinkedList *L,int key) {  LinkedList *cur=L-&amp;gt;next;  int index=0;   while(cur!=NULL &amp;amp;&amp;amp; cur-&amp;gt;data!=key)  {  index&#43;&#43;;  cur=cur-&amp;gt;next;  }   if(cur!=NULL) return index;  else return -1; //返回-1，表示没有找到该元素 }   插入元素：将值为$x$的元素的新节点插入到第$i$个节点的位置上，即先在单链表中找到插入节点的前驱节点，即第$i-1$个节点，再在其后插入新节点。
 cur-&amp;gt;next=pre-&amp;gt;next; //cur表示将要插入到链表中的节点,插入的位置是节点pre之后  pre-&amp;gt;next=cur;   删除元素:将单链表中的第$i$个节点删除。
 cur=pre-&amp;gt;next; //pre-&amp;gt;next是待删除的节点，cur是待删除节点的上一个节点  pre-&amp;gt;next=cur-&amp;gt;next;  free (cur);    就地逆置 有一个线性表$(a_1,a_2,&amp;hellip;,a_n)$ 采用带哨兵节点的单链表$L$存储，设计一个就地算法将其就地逆置，所谓“就地”是指算法的辅助空间为$O(1)$。
void reverse(LinkedList * &amp;amp; L) //传入引用 {  LinkedList *cur=L-&amp;gt;next;  LinkedList *next;  L-&amp;gt;next=NULL;  while(cur!=NULL)  {  next=ptr-&amp;gt;next; //先保存下一个节点，然后使用头插法进行逆置  cur-&amp;gt;next=L-&amp;gt;next;  L-&amp;gt;next=cur;  cur=next;  } }  拆分链表 设$C={a_1,b_1,a_2,b_2,&amp;hellip;,a_n,b_n}$ 为一线性表，采用带哨兵节点的$hc$单链表存放，设计一个就地算法，将其拆分为两个线性表（它们都是用单链表存放）使得$A={a_1,a_2,&amp;hellip;,a_n},B={b_n,b_{n-1},&amp;hellip;,b_2,b_1}$，即$A$是正序排列，$B$是逆序排列。
//参数传入引用，ha存储是A，hb存储的是B void split(LinkedList *hc,LinkedList *&amp;amp;ha,LinkedList *&amp;amp; hb) {  LinkedList *tail=ha;  LinkedList *cur=hc-&amp;gt;next;  LinkedList *next;   hb-&amp;gt;next=NULL;  while(cur != NULL)  {  tail-&amp;gt;next=cur; //尾插法  tail=cur;   cur=cur-&amp;gt;next;   next=cur-&amp;gt;next;  cur-&amp;gt;next= hb-&amp;gt;next; //头插法  hb-&amp;gt;next= cur;  cur=next;  }  tail-&amp;gt;next=NULL; //别忘了 } 递增排序 有一个带哨兵结点的单链表$L$,设计一个算法使其元素递增有序。最基本的想法是使用直接插入排序的思想，一个一个排，不同于数组排序，这里单链表只能从头开始查找。
void sort（LinkedList * &amp;amp;L) {  LinkedList *cur=L-&amp;gt;next;  LinkedList *next=cur-&amp;gt;next;  LinkedList *pre,*assist; //   cur-&amp;gt;next=NULL; //只含有一个元素的有序单链表  cur=next;   while(cur!=NULL)  {  next=cur-&amp;gt;next; //首先保存下一个链表节点  pre=L; //单链表只能从头开始往后寻找节点   assist=pre-&amp;gt;next; //assist从头开始遍历  while(assist!=NULL &amp;amp;&amp;amp; assist-&amp;gt;data &amp;lt; cur-&amp;gt;data)  {  pre=assist; //pre记录插入位置的前一个节点  assist=assist-&amp;gt;next;  }   cur-&amp;gt;next=pre-&amp;gt;next; //pre的下一个节点就是要插入的位置  pre-&amp;gt;next=cur; //pre的下一个节点就是要插入的位置   cur=next;  } }  公共节点 给定两个单链表，编写算法找出其公共的节点。第一种方法分析：从头到尾扫描单链表$A$，判断当前元素是否在单链表$B$中出现，若在则插入到单链表$C$中。
void findSameNode(LinkedList *A,LinkedList *B,LinkedList *&amp;amp;C) {  LinkedList *curA=A-&amp;gt;next;  LinkedList *curB=B-&amp;gt;next;  LinkedList *tail; //尾插法构建新的单链表   C=(LinkedList*)malloc(sizeof(LinkedList)); //静态存储区分配内存  C-&amp;gt;next=NULL;  tail=C;  while(curA!=NULL)  {  curB=B-&amp;gt;next;  while(curB!=NULL &amp;amp;&amp;amp; curB-&amp;gt;data!= curA-&amp;gt;data)  curB=curB-&amp;gt;next;   if(curB!=NULL)  {  tail-&amp;gt;next=curA;  tail=curA;  }  curA=curA-&amp;gt;next;  }  tail-&amp;gt;next=NULL; //尾插法最后应该将尾巴的next域置空 } 第二种方法分析：借用两个辅助栈，分别存储两个链表遍历时的序列，然后同时将两个辅助栈中元素弹出，直到弹出的元素不相等，弹出时采用头插法进行构造新的单链表。
第三种方法分析：首先遍历两个链表，得到两个单链表的长度差$k$，然后长的单链表先走$k-1$步，然后短的和长的同时走，直到遇到相等的元素，即为新的单链表的首节点。
 精选习题 循环左移 将$n$个整数存放到一维数组$R$中。试设计一个在时间和空间尽可能高的算法。将$R$中保存的序列循环左移$p （0 \lt q\lt n)$个位置，即将$R$中的数据由$(X_0,X_1,...,X_{n-1})$变换为$(X_p,X_{p&#43;1},...,X_{n-1},X_0,X_1,....,X_{p-1})$
void reverse(int R[],int start,int end) {  int i=start,j=end;  int assist;  while(i&amp;lt;j)  {  assist=R[i];  R[i]=R[j];  R[j]=assist;  i&#43;&#43;;  j--;  } }  void leftShift(int R[],int n,int p) {  if(p&amp;gt;0 &amp;amp;&amp;amp;p&amp;lt;n)  {  reverse(R,0,n-1);  reverse(R,0,n-p-1);  reverse(R,n-p,n-1);  } }  寻找中位数 给定两个数组$A$和$B$,数组的长度为$n$,两个数组都分别有序，求出两个数组中的所有数排序后的中位数「偶数序列中间两数的前一个为其中位数」。
解法一 因为数组$A$和$B$均有序，因此将两个数组排序后，第$n$个数就是题目中所要找的中位数。
int search(int A[], int B[], int n) {  int i = 0, j = 0, k = 0;   while (i &amp;lt; n &amp;amp;&amp;amp; j &amp;lt; n) {  k&#43;&#43;;  if (A[i] &amp;lt; B[j]) {  if (k == n)  return A[i];  i&#43;&#43;;  } else {  if (k == n)  return B[j];  j&#43;&#43;;  }  } } 解法二 分别求出两个升序序列$A$，$B$的中位数，记为$a，b$。若$a=b$,则$a$或$b$即为所求，否则舍弃$a,b$中较小者所在序列的较小一半，同时舍弃较大者所在序列的较大一半，要求两次舍弃的元素个数相同（每次从左侧和右侧删除相同个数的元素后，新的两个数组，它们的中位数与原始数组的中位数是相同的）。重复上述过程，直到两个序列均只含一个元素为止，则较小的即为所求的中位数。
int searchMid(int A[], int B[], int n) {  int startA, midA, endA;   startA = 0;  endA = n - 1;  startB = 0;  endB = n - 1;   while (startA != endA || startB != endB) {  midA = (startA &#43; endA) / 2;  midB = (startB &#43; endB) / 2;   if (A[midA] == B[midB])  return A[midA];   if (A[midA] &amp;lt; B[midB]) {  if ((startA &#43; endA) % 2 == 0)//若元素个数为奇数时  {  startA = midA; //舍弃A中间点以前的部分且保留中间点  endB = midB; //舍弃B中间点以后的部分且保留中间点  } else //若元素个数为偶数时  {  startA = midA &#43; 1; //舍弃A的前半部分,每次舍弃的长度相同，可以保证同时到达  endB = midB; //舍弃B的后半部分  }  } else if (A[midA] &amp;gt; B[midB]) {  if ((startA &#43; endA) % 2 == 0)//若元素个数为奇数时  {  endA = midA; //舍弃A中间点以后的部分且保留中间点  startB = midB;//舍弃B中间点以前的部分且保留中间点  } else //若元素个数为偶数时  {  endA = midA; //舍弃A的后半部分  startB = midB &#43; 1; //舍弃B的前半部分  }  }  }   return A[startA] &amp;lt; B[startB] ? A[startA] : B[startB]; //较小者即为所求 }   若$A$和$B$数组的长度为$2k&#43;1$，取$A$数组的中位数为$A[k]$，$B$数组的中位数为$B[k]$，$A$和$B$组合起来的中位数应该是第$2k&#43;1$大的那个数。如果$A[k]==B[k]$，则$A[k]$必定为第$2k&#43;1$大的数，是所有数字的中位数。如果$A[k]\gt B[k]$，则$A[k]$至少为第$2k&#43;2$大的数，$B[k]$至多为第$2k&#43;1$大的数，中位数介于$B[k]$和$A[k]$之间。
  若$A$和$B$数组的长度为$2k$，按照题目所述条件，则$A$的中位数为$A[k-1]$,则$B$的中位数为$B[k-1]$,$A$和$B$组合起来的中位数应该是第$2k$大的那个数，若$A[k-1]==B[k-1]$,则$B[k-1]$必为第$2k$大的那个数，即所有数字的中位数。如果$A[k-1]\gt B[k-1]$，则$A[k-1]$至少为第$2k$大的数，$B[k-1]$至多为第$2k-1$大的数，中位数介于$B[k-1]$和$A[k-1]$之间。
   次数大于一半 已知一个整数序列$A=(a_0,a_1,...,a_{n-1})$，在这个序列中若存在「不要求连续的序列」$a_{p_1} = ... = a_{p_m} = x，0&amp;lt;= a_{i} &amp;lt; n, m &amp;gt; n/2 , (0 &amp;lt;= p_k &amp;lt; n, 1&amp;lt;=k&amp;lt;=m)$,则称 $x 为 A$ 的主元素，例如$A=(0,5,5,3,5,7,5,5)$,则$5$为主元素；又如$A=(0,5,5,3,5,1,5,7)$，则$A$中没有主元素。假设$A$中的 $n$ 个元素保存在一个一维数组中，请设一个尽可能高效的算法，找出$A$的主元素。若存在主元素，则输出该元素，否则输出$-1$。
解法一 主元素问题方法一：对数组中元素进行计数，然后查看出现次数最多的元素，若次数大于一半，则为主元素。这种方式只需要对数组扫描一遍，时间复杂度为$O(n)$,空间复杂度为$O(n)$。
int moreThanHalf(int A[],int n) {  int *count=(int*)malloc(sizeof(int)*n);  int index=0;   for(int i=0;i&amp;lt;n;i&#43;&#43;) count[i]=0;   for(int i=0;i&amp;lt;n;i&#43;&#43;)  {  count[A[i]]&#43;&#43;;  if(count[A[i]) &amp;gt; count[A[index]]) index=A[i];  }   if(count[index]&amp;gt;(n/2))  return index;  else  return -1; }  解法二 首先使用快速排序，将元素排好序，然后统计相同元素出现的最大次数。统计的时候可以使用求最长平台的算法。时间复杂度为$O(nlogn)$,空间复杂度为$O(n)$。
void quickSort(int A[],int start,int end) {  int i=start,j=end;   if(i&amp;lt;j)  {  while(i&amp;lt;j)  {  while(i&amp;lt;j &amp;amp;&amp;amp; A[j]&amp;gt;tmp) j--;  A[i]=A[j];  if(i&amp;lt;j)  {  A[i]=A[j];  i&#43;&#43;;  }  while(i&amp;lt;j &amp;amp;&amp;amp; A[i]&amp;lt;=tmp) i&#43;&#43;;  if(i&amp;lt;j)  {  A[j]=A[i];  j--;  }  }  quickSort(A,start,i-1);  quickSort(A, i&#43;1, end);  } } //然后使用平台算法  解法三 数组中存在主元素时，所有的非主元素个数和必少于一半。如让主元素与一个非主元素&amp;quot;配对“，则最后多出来的元素（没有元素与之配对）就是主元素。从前往后扫描数组元素，假定遇到的当前值选定为主元素，再次遇到它时计数加1，遇到不等的值时，计数减1。当计数减为0后，将遇到的下一个值重新选定为主元素。扫描完毕，当前选定的元素（计数值大于0）可能是主元素，但未必是主元素。还需要对数组再进行一次扫描，记录它出现的实际个数，以判定它是否是主元素。时间复杂度为$O(n)$,空间复杂度为 $O(1)$。
void moreThanHalf(int A[],int n) {  int pivot=A[0];  int count=1;  int count2=0;  for(int i=1;i&amp;lt;n;i&#43;&#43;)  {  if(A[i]==base)  count&#43;&#43;;  else  {  if(count&amp;gt;0) count--;  else  {  pivot=A[i];  count=1;  }  }  }   if(count &amp;gt; 0)  {  count2=0;  for(int i=0;i&amp;lt;n;i&#43;&#43;)  {  if(pivot==A[i])  count2&#43;&#43;;  }   if(count2 &amp;gt; n/2)  return pivot;  }  return ERROR; //ERROR 代表不会在序列中出现的那个数 }  </content>
    </entry>
    
     <entry>
        <title>Go 标签</title>
        <url>https://iihui.github.io/post/go-label/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html">  在for,switch或者select中都可以配合标签形式的标识符使用——某一行第一个以冒号结尾的单词（因为gofmt会自动将后续代码移动至下一行）。
 一个实例 package main  import &amp;#34;fmt&amp;#34;  func main() {  LABEL1: 	for i := 0; i &amp;lt;= 5; i&#43;&#43; { 	for j := 0; j &amp;lt;= 5; j&#43;&#43; { 	if j == 4 { 	continue LABEL1 	} 	fmt.Printf(&amp;#34;i is: %d, and j is: %d\n&amp;#34;, i, j) 	} 	} 注意事项   标签的名称是大小写敏感的，为了提升可读性，一般建议标签全部使用大写。
  使用逆向的go to语句容易产生意大利苗条似的代码，所以应该避免。逆向是指先使用go to语句，后定义标签。
  如果一定要使用标签，建议使用正向标签。但是，标签和go to 语句之间不能有变量定义，否则会出现编译错误。
  定义了标签，如果不使用标签会产生编译错误。
  正确使用标签的情形：发生错误时，跳出无限循环，并关闭某些东西。
   </content>
    </entry>
    
     <entry>
        <title>Go 中if语句</title>
        <url>https://iihui.github.io/post/go-if/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html"> if是用于测试某个条件（布尔型，又被称为逻辑型）的语句，如果该条件成立，则会执行if后由大括号括起来的代码块，否则就忽略该代码块继续执行后续的代码。Go中if语句总共有三种形式，分别是：
  不带else的if；
  带一个else的if语句；
  带else if的if语句；
  包含初始化的if语句
  不带else的if 测试条件是布尔型的语句，如果该条件成立，则执行大括号中的内容。
if condition { //{ 与condition 须在同一行  //do something } 带else的if if condition {  //do something }else{  //do something }  带else if的if if condition1 {  // do something  }  else if condition2 { // do something else } else { // catch-all or default }  带初始化的if if initialization; condition { // do something }   在if条件中声明的变量的作用域只存在于if结构中，即在if结构的大括号之间，如果使用if-else结构则在else代码块中变量也会存在。
  如果变量在if结构之前就已经存在，那么在if结构中，该变量原来的值会被隐藏。
   注意事项   需要注意的是，即使代码块之间只有一条语句，大括号也不能被省略。
  关键字if和else之后的左大括号{必须和关键字在同一行，这是编译器强制规定的。
  如果使用了else-if结构，则前段代码块的右大括号}必须和else-if关键字在同一行，这是编译器强制规定的。
  使用gofmt格式化代码之后，每个分支内的代码都会缩进4个或8个空格，或者是1个 tab，并且右大括号与对应的if关键字垂直对齐。
  当if结构内有break、continue、goto或者return语句时，Go 代码的常见写法是省略else部分。
   </content>
    </entry>
    
     <entry>
        <title>位运算</title>
        <url>https://iihui.github.io/post/arith-bits/</url>
        <categories>
          <category>算法</category>
        </categories>
        <tags>
          <tag>算法</tag>
        </tags>
        <content type="html"> 判断是否为2的n次方 对于正整数来说，如果一个数为$x=2^n$,那么必然有一位为1，右边其它位全为0。那么$(x-1)$在其对应为1的位置上为0，对应位右边全部为1。因此，x&amp;amp;(x-1)的值则为0。
// 要求x是正整数 (x&amp;amp;(x-1) == 0) 位运算实现加法 对于二进制加法，如果不考虑相加时的进位，则有：1&#43;1=0，0&#43;1=1，1&#43;0=1，0&#43;0=0，这是二进制的异或。再考虑相加时有进位时的情况：1&#43;1=1，1&#43;0=0，0&#43;1=0，0&#43;0=0，这是二进制的与运算。
因此，二进制可以按照如下的方式进行：①首先不考虑进位的情况时，计算各位的累加得到值a；②然后考虑有进位的情况，先计算进位并将其左移得到b，如果b的值为0，那么a的值就是最后的计算结果，如果b的值不为0，则a&#43;b是最后的结果。
非递归实现 int add(int x,int y) {  int result=x,carray=y,tmp;  while(carray!=0)  {  tmp = (result &amp;amp; carray) &amp;lt;&amp;lt;1;  result ^= carray;  carray = tmp;  }  return result; } /// 位运算加法 /// - Parameters: /// - x: 被加数 /// - y: 加数 /// - Returns: x &#43; y 的和  public class Arithmetic {  public static func add(x:Int ,y:Int) -&amp;gt; Int {  var sum = x  var carry = y  while carry != 0 {  let tmp = (sum &amp;amp; carry) &amp;lt;&amp;lt; 1  sum ^= carry  carry = tmp  }  return sum  } }  func testArith() throws {  XCTAssert(Arithmetic.add(x:23,y:23) == 46) } 递归方式实现 int recAddNoArithm(int a, int b) {  if (b == 0)  return a;  int sum = a ^ b;  int carry = (a &amp;amp; b) &amp;lt;&amp;lt; 1;   return recAddNoArithm(sum, carry); } 位运算实现减法 减法可以转换为加法，例如a-b可以写成a&#43;(-b)。因此，只要先通过b的值，求得-b的值，然后再利用上面的加法实现就可以得到a-b的值。由b求-b的快捷方式是按位取反，然后末位加1，因此位运算的减法如下所示：
int subNoArithm(int a, int b) {  auto sub = nonRecAddNoArithm(~b, 1);  return nonRecAddNoArithm(a, sub); } 交换两个数的值 在异或运算中，偶数个相同的数异或的结果为0；奇数个相同的数的异或的结果为还是当前数；某个数和0进行异或的结果仍为原数，并且异或运算是支持交换律的：
a = a ^ b; b = a ^ b; a = a ^ b; 上面是a在公式左边出现两次，或者b在公式左边出现两次，这两次是最开始和最后出现：
b = a ^ b; a = a ^ b; b = a ^ b; 两个数较大者 主要运用异或的特点：偶数个相同的数异或的结果为0；奇数个相同数异或结果还是当前数；某个数和0进行异或的结果仍为原数，并且异或运算是支持交换律的，对于-1来说其二进制位全部为1。
y ^ ((x ^ y) &amp;amp; (-(x &amp;gt;= y)) //快速记忆：y 在前则找较大者 两个数较小者 x ^ ((x ^ y) &amp;amp; (-( x &amp;gt;= y)) //快速记忆：x 在前则找较小者 两个数的平均值  (x &amp;amp; y) &#43; (x ^ y &amp;gt;&amp;gt; 1); 二进制中1的个数 利用n &amp;amp; (n-1) 第一种方式每次使用公式n&amp;amp;(n-1)可以去除二进制表示中的1位1，当所有位置的1都被去除之后，结果为0，这就是终止条件。
int getBinary1Bits1(int n) {  int count = 0;  while (n != 0)  {  n = n &amp;amp; (n - 1); //n &amp;amp; （n-1)每次可以去除二进制表示中的一个1  count&#43;&#43;;  }  return count; }  //注意参数的变化 int getBinary1Bits2(unsigned int n) {  int count = 0;  while (n &amp;gt; 0) //终止条件是 n&amp;gt;0,因为 n 总是&amp;gt;=0  {  n = n &amp;amp; (n - 1);  count&#43;&#43;;  }  return count; } 利用标识位 第二种方式，使用一个标识数，其初始值设置为1。然后，使用这次标识数与当前数进行位与运算，便可得到当前位是否为1；接着，使标识数向左移动一位，然后重复上一步，最终得到1的个数。
int getBinary1Bits3(int n) {  int count = 0;  unsigned int flag = 1; //标识数应该声明为无符号数   while (flag != 0)  {  if (flag &amp;amp; n)  {  count&#43;&#43;;  }  flag = flag &amp;lt;&amp;lt; 1;  }  return count; } 利用汉明编码 第三种方式使用汉明：
typedef unsigned int64 uint64; //assume this gives 64-bits const uint64 m1 = 0x5555555555555555; //binary: 0101... const uint64 m2 = 0x3333333333333333; //binary: 00110011.. const uint64 m4 = 0x0f0f0f0f0f0f0f0f; //binary: 4 zeros, 4 ones ... const uint64 m8 = 0x00ff00ff00ff00ff; //binary: 8 zeros, 8 ones ... const uint64 m16 = 0x0000ffff0000ffff; //binary: 16 zeros, 16 ones ... const uint64 m32 = 0x00000000ffffffff; //binary: 32 zeros, 32 ones ... const uint64 hff = 0xffffffffffffffff; //binary: all ones const uint64 h01 = 0x0101010101010101; //the sum of 256 to the power of 0,1,2,3...  //This is a naive implementation, shown for comparison, //and to help in understanding the better functions. //It uses 24 arithmetic operations (shift, add, and). int popcount_1(uint64 x) {  x = (x &amp;amp; m1 ) &#43; ((x &amp;gt;&amp;gt; 1) &amp;amp; m1 ); //put count of each 2 bits into those 2 bits  x = (x &amp;amp; m2 ) &#43; ((x &amp;gt;&amp;gt; 2) &amp;amp; m2 ); //put count of each 4 bits into those 4 bits  x = (x &amp;amp; m4 ) &#43; ((x &amp;gt;&amp;gt; 4) &amp;amp; m4 ); //put count of each 8 bits into those 8 bits  x = (x &amp;amp; m8 ) &#43; ((x &amp;gt;&amp;gt; 8) &amp;amp; m8 ); //put count of each 16 bits into those 16 bits  x = (x &amp;amp; m16) &#43; ((x &amp;gt;&amp;gt; 16) &amp;amp; m16); //put count of each 32 bits into those 32 bits  x = (x &amp;amp; m32) &#43; ((x &amp;gt;&amp;gt; 32) &amp;amp; m32); //put count of each 64 bits into those 64 bits  return x; }  </content>
    </entry>
    
     <entry>
        <title>败者树</title>
        <url>https://iihui.github.io/post/arith-loser-tree/</url>
        <categories>
          <category>算法</category>
        </categories>
        <tags>
          <tag>算法</tag>
        </tags>
        <content type="html">  胜者树和败者树都是完全二叉树，是树形选择排序的一种变型。每个叶子结点相当于一个选手，每个中间结点相当于一场比赛，每一层相当于一轮比赛。不同的是，胜者树的中间结点记录的是胜者的标号；而败者树的中间结点记录的败者的标号。胜者树与败者树都可以在$log(n)$的时间内找到最值。任何一个叶子结点的值改变后，利用中间结点的信息，还是能够快速地找到最值，在k路归并排序中经常用到。
 胜者树 胜者树的父节点保存的是两两比较胜出者的下标，所以当重构时（一个选手的值发生改变时）只要找到其父节点然后与其兄弟节点比较，并将父节点更改为新的胜利节点的下标。
这是因为重构时覆盖原来叶子节点的下一个节点都比原叶子节点小，这里的小是指胜利的反方向，此时只要和败者比较就可以了，因为不清楚上一次的败者是谁，所以一定要和兄弟以及父节点比较。
因此，只要沿着发生改变的结点到根结点的路径修改这棵二叉树，而不必改变其他比赛的结果。在下面给出的例子的图示中都是数值越小表示胜利。
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-09-29 下午9.29.49.png)
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-09-29 下午9.32.04.png)
但是，胜者树每上升一次需要访问两个节点——父节点和兄弟节点。而对于败者树来说，它只要访问父节点，这是败者树的优势。
 败者树 对于胜者树来说，在节点上升的时候首先需要获得父节点，然后再获得兄弟节点，然后再比较。这时人们又想能否减少访存次数，于是就有了败者树。
在败者树中，用父结点记录其左右子结点进行比赛的败者，让胜者参加下一轮的比赛。败者树的根结点记录的是败者，因此，需要加一个结点来记录比赛的最终胜者。
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-09-29 下午9.37.52.png)
败者树重构过程如下：①首先，将新进入败者树的新结点与其父结点进行比较，并将败者存放在父结点中；②然后，将第1步中比较后的胜者再与上一级的父结点比较。
因为重构时覆盖原来叶子节点的下一个节点都比原叶子节点小，这里的小是指胜利的反方向，所以只要和败者比即可。此时父节点记录的就是败者，因此，只要和父节点比较即可。所以说对于败者树来说，它只要访问父节点，这是败者树的优势。
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-09-29 下午9.41.55.png)
 胜者树和败者树与堆的区别 相同点 胜者树、败者树和堆的相同点：空间和时间复杂度均相同——调整一次的时间复杂度都是 $O(logN)$，空间复杂度为$O(1)$。
 不同点 堆排序中每次取出当前最小值之后，把最后一个数换到堆顶。在调整堆的时候，每次都要选出父节点的两个孩子节点的最小值，然后再用孩子节点的最小值和父节点进行比较，所以每调整一次需要比较两次。
所以胜者树相对于堆来说减少了一次比较，败者树相对于胜者树来说减少了一个访存，但是并不能保证每次都可以减少一次访存。例如上题，假如$b_3$一开始是13，而不是6，那么$b_3$是败者，而此时$b_3$ 被替换为6时，由于此前 $b_3$ 为败者，因此此时就要和兄弟节点比较了，所以此时访存次数为2。
也就是说，堆排序中一定要和兄弟节点和父节点比较，即访存2次，比较2次；而胜者树只要和兄弟比较，但是需要访问兄弟节点和父节点，即访存2次，比较1次；而败者数一般和父节点比较，可能要和兄弟节点比较，因此访存此数可能比胜者树少1次，即访存是1次或者2次，比较1次。
 外排序 在外排序的K路归并的时候，由于需要访问外存，而对于计算来说此时访问外存是最主要的时间耗费。此时，常使用败者树来进行K路归并排序，归并的时候K个叶子节点保存的就是K个文件中的当前最小值。
所以对于K个有序段进行K路归并时的步骤为：
  取每个输入有序段的第一个数据作为败者树的叶子节点，建立初始败者树。然后，两两叶子节点进行比较，在双亲节点中记录比赛的败者，而让胜者去参加更高一层的比赛。最后，在根节点之上胜出的冠军是关键字最小者。
  胜出的记录写到输出归并段中，在对应的叶子节点处补充其输入有序段的下一个记录，若该段有序变空，则补充一个大关键字（比所有记录关键字都大，设为 $k_{max}$）。
  调整败者树，选择新的关键字最小的记录。从补充记录的叶子节点向上和双亲节点的关键字比较，败者留在该双亲节点，胜者继续向上，直到根节点，最后将胜者放到根节点的双亲节点中。
  若胜出的记录的关键字等于$k_{max}$,则归并结束，否则转到第2步。
   最佳归并树 若参加归并的初始归并段有m个，做k路平衡归并，最佳归并树是带权路径长度最短的k次哈夫曼树。则构造步骤如下：
  若 $(m-1),mod,(k-1) \neq 0$,则需要附加 $(k-1)-(m-1),mod,(k-1)$ 个长度为0的虚段，以使每次归并都可以对应$k$个段。
  按照哈夫曼树的构造规则构造最佳归并树。
  参考1 参考2 参考3
 </content>
    </entry>
    
     <entry>
        <title>剑指offer题集1</title>
        <url>https://iihui.github.io/post/arith-sword-1/</url>
        <categories>
          <category>算法</category>
        </categories>
        <tags>
          <tag>算法</tag>
        </tags>
        <content type="html"> 二维数组中查找 在一个二维数组中，每一行都按从左到右递增的顺序排序，每一列都按从上到下递增的顺序排列，试从该二维数组查找给定的元素。
首先应该从右上角的元素(记为cur)开始比较，如果当前要查找的元素key的值比cur大，那么就应该往cur所在行的下面开始寻找；如果key的值比cur小，那么应该往cur所在列的左边寻找，具体代码如下：
bool findKeyInMatrix(int *matrix, int rows, int colums, int key) {  bool found = false;   if (matrix != nullptr &amp;amp;&amp;amp; rows &amp;gt;= 0 &amp;amp;&amp;amp; colums &amp;gt;= 0) {  int row = 0;  int column = colums - 1; //row=0,column=colums-1表示定位到右上角的元素  int cur = 0;   while (row &amp;lt; rows &amp;amp;&amp;amp; colums &amp;gt;= 0) {  cur = matrix[row * colums &#43; column];  if (cur == key) {  found = true;  break;  } else if (cur &amp;gt; key) {  column--;  } else {  row&#43;&#43;;  }  };  }  return found; }  字符串的赋值操作符重载 对于自定义的字符串类的赋值操作符的重载时，需要注意4点：①是否传入常引用const A &amp;amp;。②传入的引用是否是自身。 ③是否释放掉原来的空间。 ④是否返回*this。
class CMyString { private:  char *pdata; public:  CMyString(char *ptr = NULL);   CMyString(const CMyString &amp;amp;str);   CMyString &amp;amp;operator=(const CMyString &amp;amp;str); } ~CMyString() {}  };  CMyString &amp;amp;CMyString::operator=(const CMyString &amp;amp;str) {  if (this != &amp;amp;str) {  CMyString tmp(str);  char *ptmp = tmp.pdata;  tmp.pdata = pdata;  pdata = ptmp;  }  return *this; } 在这个赋值操作符重载函数中，首先创建了一个临时变量tmp，如果分配内存不成功的话，那么会抛出bad_alloc异常，此时也不会修改原来的对象实例。
如果正常分配的话，因为tmp是临时变量，所以在if的作用域结束之后，那么会自动调用析构函数，此时就会析构掉tmp.pdata所指向的内存。因为tmp.pdata已经和pdata交换了，所以这相当于自动调用析构函数释放实例的内存。
从尾到头打印链表 从尾到头打印链表中的元素，有两种解决方法，一种是递归算法，另一种是利用栈来实现非递归算法。下面是递归算法的实现：
void recPrintLinkedList(LinkedNode *head) {  if (head != nullptr)  {  recPrintLinkedList(head-&amp;gt;next);  std::cout&amp;lt;&amp;lt;head-&amp;gt;data&amp;lt;&amp;lt;&amp;#34;\t&amp;#34;;  } } 非递归算法是借助栈的后进先出的特性，首先遍历链表的所有元素，并将它们存入到栈中。当遍历完栈的时候就可以出栈：
void nonRecPrintLinkedList(LinkedNode *head) {  if(head != nullptr)  {  stack&amp;lt;LinkedNode*&amp;gt; st;  LinkedNode * cur = head;   while(cur != nullptr)  {  st.push(cur);  cur = cur-&amp;gt;next;  }   while(!st.empty())  {  cur = st.top();  st.pop();  std::cout&amp;lt;&amp;lt;cur-&amp;gt;data&amp;lt;&amp;lt;&amp;#39;\t&amp;#39;;  }  } }  两个栈实现队列 将stack1作为入队使用， 将stack2作为出队使用。当stack2不空时，就从stack2直接弹出元素，否则将stack1里元素先全部弹出到stack2中，再从stack2中弹出，这样便实现了先进先出。
template &amp;lt;typename T&amp;gt; class stackQueue {  public:  stackQueue(void){};  ~stackQueue(){};  void push(const T &amp;amp;node);  void pop();  T &amp;amp;top();   private:  stack&amp;lt;T&amp;gt; stack1;  stack&amp;lt;T&amp;gt; stack2; };  template &amp;lt;typename T&amp;gt; void stackQueue&amp;lt;T&amp;gt;::push(const T &amp;amp;node) {  stack1.push(node); }  template &amp;lt;typename T&amp;gt; void stackQueue&amp;lt;T&amp;gt;::pop() {  if (stack2.empty()) {  while (!stack1.empty())  {  stack2.push(stack1.top());  stack1.pop();  }  }  if (stack2.empty())  throw string(&amp;#34;queue is empty!&amp;#34;);   stack2.pop(); }  template &amp;lt;typename T&amp;gt; T &amp;amp;stackQueue&amp;lt;T&amp;gt;::top() {  return stack2.top(); } 两个队列实现一个栈 总是保持一个队列是空，出栈的时候将不空的那个队列的前$n-1$个元素都放到空的那个队列里，然后出剩下的那一个元素；入队的时候入到不空的那个队列里。
template &amp;lt;typename T&amp;gt; class queueStack { public:  queueStack(void){};  ~queueStack(){};  void push(const T &amp;amp; node);  T pop();  private:  queue&amp;lt;T&amp;gt; queue1;  queue&amp;lt;T&amp;gt; queue2; };  template &amp;lt;typename T&amp;gt;void queueStack&amp;lt;T&amp;gt;::push(const T &amp;amp;node) {  if(queue1.empty() &amp;amp;&amp;amp; queue2.empty())  {  queue1.push(node);  }  else if(queue1.empty())  {  queue1.push(node);  }  else if(queue2.empty())  {  queue2.push(node);  }  else  throw string(&amp;#34;Error!&amp;#34;); }  template &amp;lt;typename T&amp;gt;T queueStack&amp;lt;T&amp;gt;::pop() {  if(!queue1.empty() &amp;amp;&amp;amp; queue2.empty())  {  while(queue1.size() != 1)  {  queue2.push(queue1.front());  queue1.pop();  }  T &amp;amp; data = queue1.front();  queue1.pop();  return data;  }  else if(queue1.empty() &amp;amp;&amp;amp; !queue2.empty())  {  while(queue2.size() != 1)  {  queue1.push(queue2.front());  queue2.pop();  }  T &amp;amp; data = queue2.front();  queue2.pop();  return data;  }  else  throw string(&amp;#34;Error!&amp;#34;); } 快速排序 快速排序中，基准元素的选择有3种方式：①选择待排序区间左边的第一个元素。②选择待排序空间的中间元素。③随机从待排序区间中选择一个元素。下面的代码是随机选择基准元素：
int quickSortPartition(int *input, int length, int start, int end) {  if (input == nullptr || start &amp;lt; 0 || length &amp;lt;= 0 || end &amp;gt;= length)  {  return -1; // 参数错误  }   srand(time(NULL)); //C风格   int index = rand() % (end - start &#43; 1);  int small = start - 1;   swap(input[index], input[end]);  for (int i = start; i &amp;lt; end; &#43;&#43;i)  {  if (input[i] &amp;lt; input[end])  {  small&#43;&#43;;  if (small &amp;lt; i)  {  swap(input[small], input[i]);  }  }  }   small&#43;&#43;;  swap(input[small], input[end]);  return small; }  void quickSortMore(int *input, int length, int start, int end) {  if (start == end)  return;   int index = quickSortPartition(input,length,start,end);   if (index &amp;gt; start)  quickSortMore(input,length,start,index-1);   if (end &amp;gt; index)  quickSortMore(input,length,index&#43;1,end); } 旋转数组中的最小值 把一个数组的最开始的若干元素移动到数组的末尾，称之为数组的旋转。输入一个递增的数组的一个旋转，找到数组中的最小元素。
最简单的方法是从头到尾遍历一遍数组，就可以找到最小的元素，但是这种方法没有用到旋转数组的前部和后部是有序这一特点。
int findSpinArrayMin(int *data, int length) {  if (data == nullptr || length &amp;lt; 0)  return -1;   int start = 0;  int end = length - 1;  int mid, result = -1;   while (data[start] &amp;gt;= data[end])  {  if (end - start == 1)  {  mid = end;  break;  }  mid = (start &#43; end) / 2;   if (data[start] == data[mid] &amp;amp;&amp;amp; data[mid] == data[end])  {  return minInOrder(data, start, end);  }   if (data[mid] &amp;gt;= data[end])  start = mid;   else if (data[mid] &amp;lt;= data[end])  end = mid;  }   return data[mid]; }  int minInOrder(int *data, int start, int end) {  int result = data[start];   for (int i = start &#43; 1; i &amp;lt;= end; &#43;&#43;i)  {  if (result &amp;gt; data[i])  result = data[i];  }  return result; } 斐波那契数列 首先根据定义很容易想到递归算法，但是递归算法会重复计算很多次，所以实际上浪费了很多资源
long long recFibonacci(unsigned int n) {  if (n &amp;lt;= 1)  return n;  else  return recFibonacci(n - 1) &#43; recFibonacci(n - 2); } 使用非递归解法，不必重复计算
long long nonRecFibonacci(unsigned int n) {  if (n &amp;lt;= 1)  return n;   long long first = 0, second = 1, result = 0;   for (int i = 2; i &amp;lt;= n; i&#43;&#43;)  {  result = first &#43; second;  first = second;  second = result;  }   return result; } 数组的整数次方 实现函数double power(double base,int exponent),求 base的expoent次方，不使用库函数，同时不考虑大数问题。但是在这个问题上需要考虑base接近于0的情况。
double power(double base, int exponent) {  double result = 1.0;  unsigned int absExponent = (unsigned int) (exponent);   if (base &amp;gt; 0.000001 &amp;amp;&amp;amp; base &amp;lt; 0.000001 &amp;amp;&amp;amp; exponent &amp;lt; 0)  return 0;    if (exponent &amp;lt; 0)  {  absExponent = (unsigned int) (-exponent);  }   for (unsigned int i = 0; i &amp;lt; absExponent; &#43;&#43;i)  {  result *= base;  }   if (exponent &amp;lt; 0)  result = 1.0 / result;    return result; } 优化的方法，使用如下方法
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-17 下午2.42.37.png)
double powerOptimize(double base, int exponent) {  if (exponent == 0)  return 1;   if (exponent == 1)  return base;   double result = powerOptimize(base, exponent &amp;gt;&amp;gt; 1);  result *= result;   if ((exponent &amp;amp; 0x1) == 1)  result *= base;   return result; } 打印1到最大的n位数 输入数字 n，打印1到最大的 n 位十进制数
void printNdigits(unsigned int n) {  auto *digits = new char[n &#43; 1];  memset(digits, &amp;#39;0&amp;#39;, (n &#43; 1) * sizeof(char));  digits[n] = &amp;#39;\0&amp;#39;;   while (!incrementByone(digits))  {  printNumber(digits);  }  delete[] digits; }  bool incrementByone(char *digits) {  int length = strlen(digits);  bool isOverFlow = false;  int takeOver = 0;  int cur = 0;   for (auto i = length-1; i &amp;gt;= 0; --i)  {  cur = digits[i]-&amp;#39;0&amp;#39;&#43;takeOver;  if( i==length-1)  cur &#43;&#43;;   if(cur &amp;gt; 10)  {  if(i == 0)  isOverFlow = true;  else  {  cur -= 10;  digits[i]=&amp;#39;0&amp;#39;&#43;cur;  takeOver =1;  }   }  else  {  digits[i]=&amp;#39;0&amp;#39;&#43;cur;  break;  }  }   return isOverFlow; }  void printNumber(const char *digits) {  if (digits != nullptr)  {  while (*digits == &amp;#39;0&amp;#39;)  {  digits&#43;&#43;;  }  cout &amp;lt;&amp;lt; digits &amp;lt;&amp;lt; endl;  } } 递归方式，如果将前面的数字补0的话，就会发现n位所有十进制数其实就是n个从0开始到9的全排列，就是把数字从0到9排列一遍，就得到了十进制的全排列。
void newPrintNdigts(unsigned int n) {  auto *digits = new char[n &#43; 1];  digits[n] = &amp;#39;\0&amp;#39;;   for (int i = 0; i &amp;lt; 10; &#43;&#43;i)  {  digits[0] =char(i&#43;&amp;#39;0&amp;#39;);  recPrintNdigits(digits,n,0);  }  delete[] digits; }  void recPrintNdigits(char *digits, int length, int index) {  if(index == length-1)  {  printNumber(digits);  return;  }   for (int i = 0; i &amp;lt; 10; &#43;&#43;i)  {  digits[index&#43;1] = char(i&#43;&amp;#39;0&amp;#39;);  recPrintNdigits(digits,length,index&#43;1);  } } 在O(1)时间内删除节点 在 $O(1)$ 时间复杂度内删除某个节点,假设要删除的节点一定在链表中。如果删除的不是尾节点，则只要将它的下一个节点的数据移到该节点即可。
void deleteLinkedNode(LinkedNode * &amp;amp;root, LinkedNode * key) {  if( root == nullptr || key == nullptr || !isNodeInLinkedList(root, key))  return;   if(key-&amp;gt;next != nullptr) //删除的如果不是尾节点  {  LinkedNode * next = key-&amp;gt;next;  key-&amp;gt;data = next-&amp;gt;data;  key-&amp;gt;next = next-&amp;gt;next;  delete next;  next = nullptr;  }  else if( root-&amp;gt;next == nullptr) //删除的是尾节点，而且链表只有一个节点  {  delete root;  root = nullptr;  } else //删除的是尾节点，且链表不止一个节点  {  LinkedNode * pre = root;  LinkedNode * cur = root-&amp;gt;next;   while(cur != nullptr )  {  pre = cur;  cur = cur-&amp;gt;next;  }  pre-&amp;gt;next = nullptr;  delete cur;  cur = nullptr;  } } 链表中的倒数第 k 个节点 输入一个链表，输出该链表中的倒数第 k 个节点，其中链表的尾节点为倒数第1个节点。
基本思路是用两个指针，其中第一个游标先向前走k-1次，然后和另外一个游标一起往前走，如果第一个游标走到尾节点，那么第二个游标也就到了倒数第k个节点。
LinkedNode *findLastKthNodeFaster(LinkedNode *root, int k) {  if( root == nullptr || k &amp;lt;= 0)  return nullptr;   LinkedNode * cur = root;  LinkedNode * result = root;   for (int i = 0; i &amp;lt; k-1; &#43;&#43;i)  {  if (cur-&amp;gt;next != nullptr) //要考虑k的值是否超过了链表的总节点数目  cur = cur-&amp;gt;next;  else  return nullptr;  }  while (cur != nullptr)  {  cur = cur-&amp;gt;next;  result = result-&amp;gt;next;  }  return result; }  反转链表 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头结点。分为递归和非递归解法，非递归使用头插法即可
LinkedNode * reverseLinkedList(LinkedNode *pHead) {  if (pHead == nullptr)  return nullptr;   LinkedNode *newHead = pHead;  LinkedNode *cur = pHead-&amp;gt;next;  newHead-&amp;gt;next = nullptr;   LinkedNode *next = nullptr;   while (cur != nullptr)  {  next = cur-&amp;gt;next;  cur-&amp;gt;next = newHead;  newHead = cur;  cur = next;  }   return newHead; } 递归解法
LinkedNode *recurReversionLinkedList(LinkedNode *head) {  LinkedNode *cur = nullptr;  LinkedNode *tmp = nullptr;  LinkedNode *recurHead = nullptr;   if(head == nullptr)  {  return nullptr;  }   if(head-&amp;gt;next == nullptr)  return head;  else  {  cur = head;  tmp = head-&amp;gt;next;  recurHead = recurReversionLinkedList(tmp); //得到反转之后的头节点  tmp-&amp;gt;next = cur; //此时tmp就是最后一个节点了,应该将cur放到此时的最后一个节点tmp的后面  cur-&amp;gt;next = nullptr;  return recurHead;  } } 压缩字符串 给定一段字符串，仅压缩连续重复出现的字符，例如字符串abcbc压缩后为1a1b1c，xxxyyyyzz压缩后为3x4y2z
void compressString(const char *src) {  assert(src != nullptr);  auto length = strlen(src);   auto *result = new char[2 * length &#43; 1]; //当字符都不相同时，压缩后的字符串长度变为原来的2倍   int i = 0, j = 0, k = 0;  char cur;   while (src[i] != &amp;#39;\0&amp;#39;)  {  cur = src[i];  j = i &#43; 1;  while (src[j] == cur)  {  j&#43;&#43;;  }   result[k&#43;&#43;] = (char) (j - i &#43; &amp;#39;0&amp;#39;);  result[k&#43;&#43;] = cur;  i = j;  }  result[k] = &amp;#39;\0&amp;#39;;  cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; endl;  delete[] result; } 删除多余空格 在不开辟额外空间的情况下删除开始和结尾处的空格，并将中间的多个连续的空格合成一个。
void deleteSpaces2(char *str) {  auto length = strlen(str);  auto i = length - 1;  int j =0;   while (str[i] == &amp;#39; &amp;#39;) i--;  str[i&#43;1] = &amp;#39;\0&amp;#39;;   i = 0;  while (str[i] == &amp;#39; &amp;#39;) i&#43;&#43;;    while(str[i] != &amp;#39;\0&amp;#39;)  {  str[j&#43;&#43;] = str[i&#43;&#43;];   if(str[i] == &amp;#39; &amp;#39;)  {  while(str[i] == &amp;#39; &amp;#39;) i&#43;&#43;;  str[j&#43;&#43;] = &amp;#39; &amp;#39;;  }  }  str[j] = &amp;#39;\0&amp;#39;;  cout&amp;lt;&amp;lt;&amp;#34;***&amp;#34;&amp;lt;&amp;lt;str&amp;lt;&amp;lt;&amp;#34;***&amp;#34;&amp;lt;&amp;lt;endl; } 合并两个有序的链表 当得到两个链表中值较小的头节点并把它链接到已经合并的链表之后，两个链表剩余的节点依然是有序的，因此合并的步骤和之前的步骤一样。
LinkedNode *mergeOrderLinkedList(LinkedNode *head1, LinkedNode *head2) {  if (head1 == nullptr)  return head2;  else if (head2 == nullptr)  return head1;   LinkedNode *mergeHead = nullptr;   if (head1-&amp;gt;data &amp;lt;= head2-&amp;gt;data)  {  mergeHead = head1;  mergeHead-&amp;gt;next = mergeOrderLinkedList(head1-&amp;gt;next, head2);  } else  {  mergeHead = head2;  mergeHead-&amp;gt;next = mergeOrderLinkedList(head1, head2-&amp;gt;next);  }   return mergeHead; } 树的子结构 输入两棵二叉树 A 和 B，判断 B 是不是 A 的子树
bool hasSubTree(BinTreeNode *root1, BinTreeNode *root2) {  bool result = false;  if(root1 != nullptr &amp;amp;&amp;amp; root2 != nullptr )  {  if(root1-&amp;gt;data == root2-&amp;gt;data)  result = DoesTree1HasTree2(root1,root2);   if(false == result)  {  result = hasSubTree(root1-&amp;gt;leftChild,root2);  }   if(false == result)  {  result = hasSubTree(root1-&amp;gt;rightChild,root2);  }  }   return result; }  bool DoesTree1HasTree2(BinTreeNode *root1, BinTreeNode *root2) {  if(root2 == nullptr)  return true;  else if(root1 == nullptr)  return false;   if(root1-&amp;gt;data != root2-&amp;gt;data)  return false;    return DoesTree1HasTree2(root1-&amp;gt;rightChild,root2-&amp;gt;leftChild) &amp;amp;&amp;amp; DoesTree1HasTree2(root1-&amp;gt;rightChild,root2-&amp;gt;rightChild); } 树的镜像 先前序遍历这棵树的每一个节点，如果遍历到的节点有子节点则交换它们，当交换完所有的非叶子节点的左右子节点之后，就得到了树的镜像
void changeToMirror(BinTreeNode *root) {  if (root == nullptr)  return;   if (root-&amp;gt;leftChild == nullptr &amp;amp;&amp;amp; root-&amp;gt;rightChild == nullptr)  return;   BinTreeNode *tmp;  tmp = root-&amp;gt;leftChild;  root-&amp;gt;leftChild = root-&amp;gt;rightChild;  root-&amp;gt;rightChild = tmp;   if(nullptr != root-&amp;gt;leftChild)  changeToMirror(root-&amp;gt;leftChild);   if(nullptr != root-&amp;gt;rightChild)  changeToMirror(root-&amp;gt;rightChild); }  顺时针打印矩阵 void clockwisePrintMatrix(int **input, int columns, int rows) {  if (input == nullptr || columns &amp;lt; 0)  return;   int start = 0;  while (columns &amp;gt; start * 2 &amp;amp;&amp;amp; rows &amp;gt; start * 2) //打印进行的条件  {  printMatrixInCircle(input, columns, rows, start);  start&#43;&#43;;  } }  void printMatrixInCircle(int **input, int rows, int columns, int start) {  int endX = columns - 1 - start; //记录行的最右边  int endY = rows - 1 - start; //记录列的最下边   //从左往右打印一行  for (int i = start; i &amp;lt;= endX ; &#43;&#43;i)  {  cout&amp;lt;&amp;lt;input[start][i]&amp;lt;&amp;lt;&amp;#34;\t&amp;#34;;  }   //从上往下打印一列  for (int i = start&#43;1; i&amp;lt;= endY; &#43;&#43;i)  {  cout&amp;lt;&amp;lt;input[i][endX]&amp;lt;&amp;lt;&amp;#34;\t&amp;#34;;  }   for (int i = endX-1; i &amp;gt;=start ; --i)  {  cout&amp;lt;&amp;lt;input[endY][i]&amp;lt;&amp;lt;&amp;#34;\t&amp;#34;;  }   for (int i = endY-1; i &amp;gt; start ; --i)  {  cout&amp;lt;&amp;lt;input[i][start]&amp;lt;&amp;lt;&amp;#34;\t&amp;#34;;  }   cout&amp;lt;&amp;lt;endl; }  包含min函数的栈 定义栈的数据结构，在该类型中实现一个能够得到栈的最小元素的min函数。
利用一个辅助栈，每次将最小的元素（当前最小和入栈压入的新元素比较）都保存在这个辅助栈中。当弹出元素时，辅助栈中的元素也弹出一个。
判断正确的出栈序列 输入两个整数序列，第一个表示栈的压入顺序，第二个表示弹出序列，判断弹出序列是否是第一个压入序列的有效弹出序列。
使用一个辅助栈来保存压入序列，如果下一个弹出的数字刚好是栈顶数字，那么直接弹出，如果下一个弹出的数字不在栈顶，则把压栈序列中还未压入的数字压入到栈中，直到把下一个需要弹出的数字压入到栈顶为止，如果所有数字都压入到栈中了还未找到下一个弹出的数字，那么该序列就不是合法的弹出序列。
下面这个是针对与栈中元素是整型变量的：
bool isPopOrder(const int *pushOrder, const int *popOrder, int length) {  bool result = false;  const int *nextPush = pushOrder;  const int *nextPop = popOrder;  stack&amp;lt;int&amp;gt; st;   if (pushOrder != nullptr &amp;amp;&amp;amp; popOrder != nullptr &amp;amp;&amp;amp; length &amp;gt; 0)  {  while ((nextPop - popOrder) &amp;lt; length)  {  while (st.empty() || *nextPop != st.top())  {  if ((nextPush - pushOrder) == length)  break;   st.push(*nextPush);  nextPush&#43;&#43;;  }   if (st.top() != *nextPush)  break;   nextPop&#43;&#43;;  st.pop();  }   if (st.empty() &amp;amp;&amp;amp; (nextPop - popOrder == length))  result = true;  }   return result; } 这个是针对于栈中元素是字符型
bool isPopOrder(const char *pushOrder, const char *popOrder) {  bool result = false;  auto length = strlen(pushOrder);   if(popOrder != nullptr &amp;amp;&amp;amp; pushOrder != nullptr &amp;amp;&amp;amp; length == strlen(popOrder))  {  stack&amp;lt;char&amp;gt; st;  const char * nextPush = pushOrder;  const char * nextPop = popOrder;   while(*nextPop != &amp;#39;\0&amp;#39;)  {  while(st.empty() || *nextPop != st.top())  {  if(*nextPush == &amp;#39;\0&amp;#39;)  break;   st.push(*nextPush);  nextPush&#43;&#43;;  }   if(*nextPop != st.top())  break;   nextPop&#43;&#43;;  st.pop();  }   if(st.empty() &amp;amp;&amp;amp; *nextPop == &amp;#39;\0&amp;#39;)  result = true;  }   return result; }  二叉搜索树的后序遍历序列 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果，如果是则返回true，不是则返回false
bool verifySquenceOfBST(int *input, int length) {  bool result = false;   if (input == nullptr || length &amp;lt;= 0)  return result;   int cur = input[length - 1]; //根节点  int index = 0;  int mid = 0;   while (index &amp;lt; length &amp;amp;&amp;amp; input[index] &amp;lt; cur)  {  index&#43;&#43;;  }  mid = index;   while (index &amp;lt; length &amp;amp;&amp;amp; input[index] &amp;gt; cur)  {  index&#43;&#43;;  }   if (index == length - 1) //注意边界判断  {  bool left = false, right = false;  if (mid &amp;gt; 0)  left = verifySquenceOfBST(input, mid);   if (mid &amp;lt; length - 1)  right = verifySquenceOfBST(input &#43; mid, length - mid - 1);   result = left &amp;amp;&amp;amp; right;  }   return result; }  二叉树中从根开始和为某一值的路径 输入一棵二叉树和一个整数，打印二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到某一节点所经过的节点形成一条路径。
void findPath(BinTreeNode *root, int sum) {  if (root == nullptr)  return;   vector&amp;lt;char&amp;gt; path;  int currentSum = 0;  findPath(root, path, sum, currentSum); }  void findPath(BinTreeNode *root, vector&amp;lt;char&amp;gt; &amp;amp;path, int sum, int currentsum) {  currentsum &#43;= root-&amp;gt;data;  path.push_back(root-&amp;gt;data);  if (sum == currentsum)  {  for (auto it = path.begin(); it != path.end(); it&#43;&#43;)  {  cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#39;\t&amp;#39;;  }  cout &amp;lt;&amp;lt; endl;  }   if (root-&amp;gt;leftChild != nullptr)  {  findPath(root-&amp;gt;leftChild, path, currentsum, sum);  }   if (root-&amp;gt;rightChild != nullptr)  {  findPath(root-&amp;gt;rightChild, path, currentsum, sum);  }   path.pop_back(); } 不用vector算法的写法：
void printSumPath(BinTreeNode *root, char *path, int length, int sum) {  if (root == nullptr)  return;   path[length] = root-&amp;gt;data;  sum -= root-&amp;gt;data;  length&#43;&#43;;   if (0 == sum)  {  for (int i = 0; i &amp;lt;= length; &#43;&#43;i)  {  cout &amp;lt;&amp;lt; path[i];  }  cout &amp;lt;&amp;lt; endl;  }   if (root-&amp;gt;leftChild != nullptr)  {  printSumPath(root-&amp;gt;leftChild, path, length, sum);  }   if (root-&amp;gt;rightChild != nullptr)  {  printSumPath(root-&amp;gt;rightChild, path, length, sum);  }   length--; //减不减其实无所谓 }  二叉树中和为某一值的路径 一棵二叉树每个节点包含一个整数，设计一个算法输出所有满足条件的路径：在此路径上所有给定的节点之和为给定值，不必从根节点开始
void printSumPath(BinTreeNode *root, vector&amp;lt;char&amp;gt; &amp;amp;path, int sum, int level) {  if(root != nullptr)  {  path.push_back(root-&amp;gt;data);   int currentSum = sum;   for (int i = level; i &amp;gt;=0; &#43;&#43;i)  {  currentSum-=path[i];   if(currentSum == 0)  printSumPath(path,i,level);  }  level&#43;&#43;;  if(root-&amp;gt;leftChild != nullptr)  printSumPath(root-&amp;gt;leftChild,path,sum,level);   if(root-&amp;gt;rightChild != nullptr)  printSumPath(root-&amp;gt;rightChild,path,sum,level);   path.pop_back();  } }  void printSumPath(vector&amp;lt;char&amp;gt; path, int start, int end) {  for (int i = start; i &amp;lt;= end; &#43;&#43;i)  {  cout&amp;lt;&amp;lt;path[i]&amp;lt;&amp;lt;&amp;#39;\t&amp;#39;;  }  cout&amp;lt;&amp;lt;endl; }  </content>
    </entry>
    
     <entry>
        <title>C&#43;&#43;智能指针</title>
        <url>https://iihui.github.io/post/cpp-smart-pointer/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>C&#43;&#43;</tag>
        </tags>
        <content type="html">  智能指针是一个类，它对普通指针进行封装，使智能指针类对象具有普通指针类型一样的操作。具体而言，复制对象时，副本和原对象都指向同一存储区域，如果通过一个副本改变其所指的值，则通过另一对象访问的值也会改变。与普通指针所不同的是，智能指针能够对内存进行进行自动管理，避免出现悬垂指针等情况。
 普通指针 对于普通指针，当有多个指针指向同一个基础对象时，如果某个指针delete了该基础对象，对这个指针来说已经明确说明它所指的对象被释放掉了，所以它不会再对所指对象进行操作。但是，对于剩下的指向同一个基础对象的指针来说，它们依然指向已经被删除的基础对象并随时准备对它进行操作，于是悬垂指针就形成了。
int * ptr1 = new int (1); int * ptr2 = ptr1; int * ptr3 = prt2;  cout &amp;lt;&amp;lt; *ptr1 &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; *ptr2 &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; *ptr3 &amp;lt;&amp;lt; endl;  delete ptr1; cout &amp;lt;&amp;lt; *ptr2 &amp;lt;&amp;lt; endl; ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-13 下午4.12.02.png)
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-13 下午4.12.12.png)
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-13 下午4.12.32.png)
从图可以看出，错误的产生来自于ptr1的“无知”：它并不知道还有其他指针共享着它指向的对象。如果有个办法让ptr1知道，除了它自己外还有两个指针指向基础对象，而它不应该删除基础对象，那么悬垂指针的问题就得以解决了。
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-13 下午4.14.30.png)
 引用计数 如何来让指针知道还有其他指针的存在呢？这个时候该引入引用计数的概念了。引用计数是这样一个技巧，它允许有多个相同值的对象共享这个值的实现。引用计数的使用常有两个目的：
  一旦一个对象通过调用new被分配出来，记录谁拥有这个对象是很重要的，因为其所有者要负责对它进行delete。但是对象所有者可以有多个，且所有权能够被传递，这就使得内存跟踪变得困难。引用计数可以跟踪对象所有权，并能够自动销毁对象。可以说引用计数是个简单的垃圾回收体系。
  节省内存，提高程序运行效率。如果很多对象有相同的值，为这多个相同的值存储多个副本是很浪费空间的，所以最好做法是让左右对象都共享同一个值的实现。C&#43;&#43;标准库中string类采取一种称为“写时复制”的技术，使得只有当字符串被修改的时候才创建各自的拷贝，否则可能（标准库允许使用但没强制要求）采用引用计数技术来管理共享对象的多个对象。
   智能指针实现 智能指针的实现策略有两种：辅助类与句柄类，这里介绍辅助类实现
基础类 class Point { public:  Point(int xVal = 0, int yVal = 0) :x(xVal), y(yVal) { }  int getX() const { return x; }  int getY() const { return y; }  void setX(int xVal) { x = xVal; }  void setY(int yVal) { y = yVal; }  private:  int x, y; };  辅助类 在创建智能指针类之前，我们先创建一个辅助类。这个类的所有成员皆为私有类型，因为它不被普通用户所使用。为了只为智能指针使用，还需要把智能指针类声明为辅助类的友元。这个辅助类含有两个数据成员：计数count与基础对象指针。也即辅助类用以封装使用计数与基础对象指针。
class U_Ptr { private:   friend class SmartPtr;  U_Ptr(Point *ptr) :p(ptr), count(1) { }  ~U_Ptr() { delete p; }   int count;  Point *p; };  智能指针类 引用计数是实现智能指针的一种通用方法。智能指针将一个计数器与类指向的对象相关联，引用计数跟踪共有多少个类对象共享同一指针。它的具体做法如下：
  当创建类的新对象时，初始化指针，并将引用计数设置为1
  当对象作为另一个对象的副本时，复制构造函数复制副本指针，并增加与指针相应的引用计数（加1）
  使用赋值操作符对一个对象进行赋值时，处理复杂一点：先使左操作数的指针的引用计数减1（因为指针已经指向别的地方），如果减1后引用计数为0，则释放指针所指对象内存。然后增加右操作数所指对象的引用计数（为何增加：因为此时做操作数指向对象即右操作数指向对象）。
  析构函数：调用析构函数时，析构函数先使引用计数减1，如果减至0则delete对象。
  class SmartPtr {  public:  SmartPtr(Point *ptr) : rp(new U_Ptr(ptr)) {}  SmartPtr(const SmartPtr &amp;amp;sp) : rp(sp.rp) { &#43;&#43;rp-&amp;gt;count; }  SmartPtr &amp;amp;operator=(const SmartPtr &amp;amp;rhs) {  &#43;&#43;rhs.rp-&amp;gt;count;  if (--rp-&amp;gt;count == 0) delete rp;  rp = rhs.rp;  return *this;  }  ~SmartPtr() {  if (--rp-&amp;gt;count == 0)  delete rp;  else  cout &amp;lt;&amp;lt; &amp;#34;还有&amp;#34; &amp;lt;&amp;lt; rp-&amp;gt;count &amp;lt;&amp;lt; &amp;#34;个指针指向基础对象&amp;#34; &amp;lt;&amp;lt; endl;  }   private:  U_Ptr *rp; };  使用与测试 int main() {  Point *pa = new Point(10, 20); //定义一个基础对象类指针  //定义三个智能指针类对象，对象都指向基础类对象pa  //使用花括号控制三个指针指针的生命期，观察计数的变化  {  SmartPtr sptr1(pa); //此时计数count=1  {  SmartPtr sptr2(sptr1); //调用复制构造函数，此时计数为count=2  {  SmartPtr sptr3 = sptr1; //调用赋值操作符，此时计数为conut=3  } //此时count=2  } //此时count=1；  } //此时count=0；pa对象被delete掉  cout &amp;lt;&amp;lt; pa-&amp;gt;getX() &amp;lt;&amp;lt; endl;   return 0; }  改进一 虽然此时的SmartPtr类称为智能指针，但它目前并不能像真正的指针那样有-&amp;gt;、*等操作符，为了使它看起来更像一个指针，我们来为它重载这些操作符。代码如下所示：
class SmartPtr { public:  SmartPtr(Point *ptr) :rp(new U_Ptr(ptr)) { }  SmartPtr(const SmartPtr &amp;amp;sp) :rp(sp.rp) { &#43;&#43;rp-&amp;gt;count; }  SmartPtr&amp;amp; operator=(const SmartPtr&amp;amp; rhs) {  &#43;&#43;rhs.rp-&amp;gt;count;  if (--rp-&amp;gt;count == 0)  delete rp;  rp = rhs.rp;  return *this;  }  ~SmartPtr() {  if (--rp-&amp;gt;count == 0)  delete rp;  else  cout &amp;lt;&amp;lt; &amp;#34;还有&amp;#34; &amp;lt;&amp;lt; rp-&amp;gt;count &amp;lt;&amp;lt; &amp;#34;个指针指向基础对象&amp;#34; &amp;lt;&amp;lt; endl;  }   Point &amp;amp; operator *() //重载*操作符  {  return *(rp-&amp;gt;p);  }  Point* operator -&amp;gt;() //重载-&amp;gt;操作符  {  return rp-&amp;gt;p;  } private:  U_Ptr *rp; };  改进二 目前这个智能指针智能用于管理Point类的基础对象，如果此时定义了个矩阵的基础对象类，那不是还得重新写一个属于矩阵类的智能指针类吗？但是矩阵类的智能指针类设计思想和Point类一样啊，就不能借用吗？答案当然是能，那就是使用模板技术。
//模板类作为友元时要先有声明 template &amp;lt;typename T&amp;gt; class SmartPtr;  template &amp;lt;typename T&amp;gt; class U_Ptr //辅助类 {  private:  //该类成员访问权限全部为private，因为不想让用户直接使用该类  friend class SmartPtr&amp;lt;  T&amp;gt;; //定义智能指针类为友元，因为智能指针类需要直接操纵辅助类   //构造函数的参数为基础对象的指针  U_Ptr(T *ptr) : p(ptr), count(1) {}   //析构函数  ~U_Ptr() { delete p; }  //引用计数  int count;   //基础对象指针  T *p; };  template &amp;lt;typename T&amp;gt; class SmartPtr //智能指针类 {  public:  SmartPtr(T *ptr) : rp(new U_Ptr&amp;lt;T&amp;gt;(ptr)) {} //构造函数  SmartPtr(const SmartPtr&amp;lt;T&amp;gt; &amp;amp;sp) : rp(sp.rp) { &#43;&#43;rp-&amp;gt;count; } //复制构造函数  SmartPtr &amp;amp;operator=(const SmartPtr&amp;lt;T&amp;gt; &amp;amp;rhs) { //重载赋值操作符  &#43;&#43;rhs.rp-&amp;gt;count; //首先将右操作数引用计数加1，  if (--rp-&amp;gt;count == 0) //然后将引用计数减1，可以应对自赋值  delete rp;  rp = rhs.rp;  return *this;  }   T &amp;amp;operator*() //重载*操作符  {  return *(rp-&amp;gt;p);  }  T *operator-&amp;gt;() //重载-&amp;gt;操作符  {  return rp-&amp;gt;p;  }   ~SmartPtr() { //析构函数  if (--rp-&amp;gt;count ==  0) //当引用计数减为0时，删除辅助类对象指针，从而删除基础对象  delete rp;  else  cout &amp;lt;&amp;lt; &amp;#34;还有&amp;#34; &amp;lt;&amp;lt; rp-&amp;gt;count &amp;lt;&amp;lt; &amp;#34;个指针指向基础对象&amp;#34; &amp;lt;&amp;lt; endl;  }   private:  U_Ptr&amp;lt;T&amp;gt; *rp; //辅助类对象指针 };  </content>
    </entry>
    
     <entry>
        <title>Go 中映射(字典）</title>
        <url>https://iihui.github.io/post/go-map/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html">  映射(或称为字典)是一种数据结构，用于存储一系列无序的键值对，它是基于键来存储值。映射的键可以是任何值，只要这个值可以使用==运算符做比较即可。切片、函数以及包含切片的结构类型这些类型由于具有引用语义， 不能作为映射的键。
 创建和初始化 使用make函数 //创建一个映射，键的类型是string，值的类型是int dict1 := make(map[string]int) dict2 := make(map[string]int,5) //长度为5  使用字面量 // 创建一个映射，键和值的类型都是 string，使用两个键值对初始化映射 dict2 := map[string]string{&amp;#34;Red&amp;#34;: &amp;#34;#da1337&amp;#34;, &amp;#34;Orange&amp;#34;: &amp;#34;#e95a22&amp;#34;} 需要注意的是，直接使用var m map[string][int]这种方式定义的map变量的初始值为nil,并且这个变量是只能读不能写的，也就是说可以按照键来读值，读出来是类型的默认零值，但是不可以往里面添加键值对，否则会产生一个运行时错误。
// 通过声明映射创建一个 nil 映射 var colors map[string]string  // 将 Red 的代码加入到映射 colors[&amp;#34;Red&amp;#34;] = &amp;#34;#da1337&amp;#34; //产生运行时错误  //Runtime Error: //panic: runtime error: assignment to entry in nil map 相比于值为nil的映射，空映射有初始化过程，但是映射此时的容量为0，此时的映射是可以用来存储键值对的：
// 创建一个空映射，用来存储颜色以及颜色对应的十六进制代码 colors := map[string]string{} //空映射 // 将 Red 的代码加入到映射 colors[&amp;#34;Red&amp;#34;] = &amp;#34;#da1337&amp;#34; 内容为空的映射与nil是不同的，空映射可以添加键值，nil字典不可以添加键值：
var m1 map[string]int //nil映射 m2 := map[string]int{} //空映射  println(m1==nil,m2==nil)//true false  使用映射 映射的使用包括：①根据键来取值——通常要通过ok-idiom模式来判断给定的键是否有值； ②作为函数参数——因为是引用类型，因此函数中做的更改可以影响被调函数中原引用的值。
根据键取值 value, exists := colors[&amp;#34;Blue&amp;#34;] // 这个键存在吗？，这就是ok-idiom模式  if exists {  fmt.Println(value)  } // 创建一个映射，存储颜色以及颜色对应的十六进制代码 colors := map[string]string{ &amp;#34;AliceBlue&amp;#34;: &amp;#34;#f0f8ff&amp;#34;, &amp;#34;Coral&amp;#34;: &amp;#34;#ff7F50&amp;#34;, &amp;#34;DarkGray&amp;#34;: &amp;#34;#a9a9a9&amp;#34;, &amp;#34;ForestGreen&amp;#34;: &amp;#34;#228b22&amp;#34;, }  // 显示映射里的所有颜色 for key, value := range colors {  fmt.Printf(&amp;#34;Key: %s Value: %s\n&amp;#34;, key, value) } 作为函数参数 因为映射是引用类型，在函数间传递映射并不会制造出该映射的一个副本。实际上，当传递映射给一个函数，并对这个映射做了修改时，所有对这个映射的引用都会察觉到这个修改。
colors := map[string]string{ 	&amp;#34;AliceBlue&amp;#34;:&amp;#34;#f0f8ff&amp;#34;, 	&amp;#34;Coral&amp;#34;:&amp;#34;#ff7F50&amp;#34;, 	&amp;#34;DarkGray&amp;#34;:&amp;#34;#a9a9a9&amp;#34;, 	&amp;#34;ForestGreen&amp;#34;: &amp;#34;#228b22&amp;#34;, }  // 显示映射里的所有颜色 for key, value := range colors { 	fmt.Printf(&amp;#34;Key: %s Value: %s\n&amp;#34;, key, value) }  // 调用函数来移除指定的键 removeColor(colors, &amp;#34;Coral&amp;#34;)  // 显示映射里的所有颜色  for key, value := range colors { 	fmt.Printf(&amp;#34;Key: %s Value: %s\n&amp;#34;, key, value) }   func removeColor(colors map[string]string, key string) { 	delete(colors, key) }  注意事项 字典map是无序的，每次打印出来的结果都会不一样，不能通过index获取（下标获取）只能通过key获取
字典要求key必须支持相等运算符==,!=的数据类型，所以切片以及包含切片的结构体不能为key。键的值，可以是数字、字符串、指针、数组、结构体以及接口类型。
内置的len函数返回key的数量，不可以使用cap（即cap不接受字典类型，因为它没有容量的概念）。
map的初始化可以通过key:val的方式初始化：
rating := map[string]float32{&amp;#34;C&amp;#34;: 5, &amp;#34;Go&amp;#34;: 1.83} fmt.Println(rating) //map[C:5 Go:1.83] map是一种引用类型，如果两个map同时指向同一个底层，那么一个改变，另一个也改变。
m := make(map[string]string) m[&amp;#34;Hello&amp;#34;] = &amp;#34;hello&amp;#34; m1 := m m1[&amp;#34;Hello&amp;#34;] = &amp;#34;world&amp;#34; fmt.Println(m, m1) //map[Hello:world] map[Hello:world] 访问不存在的键值，默认返回的是value的默认零值，不会引发错误，但推荐使用ok-idiom模式。
m := make(map[string]bool) m[&amp;#34;chen&amp;#34;] = true fmt.Println(m[&amp;#34;xiao&amp;#34;]) //默认零值false 当value是结构体或者数组时，不能直接修改value中的成员，正确的做法是返回整个value，待修改后再设置字典键值，或直接用指针类型。
type user struct { 	name string 	age byte } m := map[int]user{ 	1: {&amp;#34;Tom&amp;#34;, 19}, }  m[1].age = 20 //错误,结构体的value不能直接修改  u := m[1] //先取出来，在改变value的值，然后再根据索引改变map中value的值 u.age = 20 m[1] = u 不能对nil字典进行写操作，但却能读，读出来的value是其类型对应的零值。
println(m[&amp;#34;a&amp;#34;]) m[&amp;#34;a&amp;#34;] = 1 //错误 内容为空的字典与nil是不同的，内容为空的字典可以添加键值，但是nil字典不可以。
var m1 map[string]int m2 := map[string]int{}  println(m1 == nil, m2 == nil) //true false 在迭代期间(for range)删除或者新增键值是安全的，但是在运行时会对字典并发操作作出检测，如果某个任务正在对字典进行写操作，那么其他任务就不能对该字典进行并发操作（读，写，删除）否则会导致进程崩溃，即是所谓的线程不安全的。
应该使用make来创建map，永远不要使用new来创建map，因为map是引用类型，需要初始化某些东西，而new是将内存清0。
map中的value可以是任意类型，包括函数：
a6 := map[int]func() int{ 	1: func() int { return 1 }, 	2: func() int { return 2 }, 	3: func() int { return 3 }, }  fmt.Println(a6) //map[1:0x10982f0 2:0x1098300 3:0x1098310] map的长度是不固定的，可以根据key-value动态的伸缩，因此不存在固定长度和最大长度「但受内存限制」。如果提前能预估key-value的个数，可以在使用make指定长度，这样可以减少因为动态增长key-value带来的性能消耗问题。m:=make(map[string]int,10)
如果一个key要对应多个value，这时候建议将slice作为value。例如，当要处理unix机器上的所有进程，以父进程（pid为整型变量）作为 key，所有的子进程（以所有子进程的pid组成的切片）作为value。
使用delete(map1, key1)从map中删除键值对，如果key1不存在，该操作不会产生错误。
假设我们想获取一个map类型的切片，我们必须使用两次make函数，第一次分配切片，第二次分配切片中每个map元素。
items := make([]map[int]int, 5) //注意写法 for i := range items { 	items[i] = make(map[int]int, 1)  	items[i][1] = 2 } fmt.Printf(&amp;#34;Version A: Value of items: %v\n&amp;#34;, items) map默认是无序的，不管是按照key还是按照value默认都不排序；这与C&#43;&#43;中的map有很大区别。
 </content>
    </entry>
    
     <entry>
        <title>Go 切片</title>
        <url>https://iihui.github.io/post/go-slice/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html"> 定义 切片是围绕动态数组的概念来构建的，但是本身并非动态数组或数组指针，它通过内部指针引用底层数组，设定相关属性，将数据读写操作限定到指定区域。切片这个名字来自于——创建一个新的切片就是把底层数组切出一部分。
type slice struct{  array unsafe.Pointer // slice中指向底层数组指定位置的的指针  len int // slice 的长度  cap int //slice 容量，即最大长度，就是slice开始位置到数组的最后位置的长度 } ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-03 下午3.38.29.png)
 声明和初始化 使用make 一种创建切片的方法是使用内置的切片的长度，如下所示使用make函数。当使用make时，需要传入一个参数，指定长度：
slice1 := make([]string, 5) //只指定长度，切片的长度和容量相等，均为5 slice2 := make([]int, 3, 5) //分别指定长度和容量，长度为3，容量为5 make在创建切片的时候，可以指定两个长度信息，分别表示切片的当前长度和容量大小「概念参考C&#43;&#43;标准库中的vector。不允许创建容量小于长度的切片，否则会出现编译错误。
 利用字面量 另一种常用的创建切片的方法是使用切片字面量。这种方法和创建数组类似，只是不需要指定[]运算符里的值。初始的长度和容量会基于初始化时提供的元素的个数确定。
// 创建字符串切片，其长度和容量都是 5 个元素 slice1 := []string{&amp;#34;Red&amp;#34;, &amp;#34;Blue&amp;#34;, &amp;#34;Green&amp;#34;, &amp;#34;Yellow&amp;#34;, &amp;#34;Pink&amp;#34;} // 创建一个整型切片，其长度和容量都是 3 个元素 slice2 := []int{10, 20, 30} 如果在 [] 运算符里指定了一个值，那么创建的就是数组而不是切片。
// 创建有 3 个元素的整型数组 array := [3]int{10, 20, 30} // 创建长度和容量都是 3 的整型切片 slice := []int{10, 20, 30} 当使用切片字面量时， 可以设置初始长度和容量，即在就是在初始化时给出所需的长度和容量作为索引：
// 创建字符串切片，使用空字符串初始化第 100 个元素 slice := []string{99: &amp;#34;&amp;#34;} //最大的索引是99，因此长度为99&#43;1 fmt.Println(len(slice1),cap(slice1)) //长度为100，容量也为100  从已知切片创建 切片可以从一个数组中获取，前提是这个数组必须是可寻址的。切片通过array[i:j]来获取，表示的区间是[i,j)即前闭后开区间，长度为j-i，对于底层数组容量为k的数组来说，切片slice[i:j]的容量为k-i。
var arr =[10]byte{&amp;#39;a&amp;#39;,&amp;#39;b&amp;#39;,&amp;#39;c&amp;#39;,&amp;#39;d&amp;#39;} //array 声明长度 var a,b []byte //slice，方括号里不声明长度 a = arr[1:3] //前闭后开,长度为2,容量为9 b = arr[2:4] //前闭后开，长度为2，容量为8 fmt.Println(a,b) //[98 99] [99 100] 或者从一个已经存在的的切片中再次声明，即将原切片看成是[cap]slice,据此创建的新切片对象不能超出cap。
// 创建一个整型切片，其长度和容量都是 5 slice := []int{10, 20, 30, 40, 50} // 创建一个新切片，其长度为 2 个元素，容量为 4 newSlice := slice[1:3] ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-03 下午4.41.43.png)
 nil切片 在声明切片时不做任何初始化，就会创建一个nil切片，nil切片无底层数组，因此不可按下标访问。nil切片变为正常的切片有两种方式：①利用赋值。 ②使用append函数。
var slice []int //不做任何初始化，创建的为nil切片 fmt.Println(slice==nil) //true ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-03 下午4.27.26.png)
 空切片 空切片相对于nil切片而言，已经完成了初始化——即其内部指针已经被赋值为非0，而nil切片内部的指针为nil。但是，空切片的len(s)和cap(s)的值都为0。
// 使用 make 创建空的整型切片 slice1 := make([]int, 0) //空切片 // 使用切片字面量创建空的整型切片 slice2 := []int{} //nil切片 fmt.Println(slice1==nil,slice2==nil)//false false ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-03 下午4.29.26.png)
 注意 切片是引用类型 切片是引用类型，所以当引用改变其中元素的值时，其他所有引用都会改变该值：
var arr =[10]byte{81,82,83,84,85,86} //array var a,b,c [] byte //nil slice  a = arr[1:3] b = arr[2:4] fmt.Println(a,b) //[98 99] [99 100]  c = a[0:2] //c切片来自于切片a，切片a发生变化时，c就会跟着变化 fmt.Println(c) //[82,83]  a = arr[1:5] fmt.Println(a,c) //[82 83 84 85] [82 83] slice := []int{10, 20, 30, 40, 50} newSlice := slice[1:3] fmt.Println(slice,newSlice)//[10 20 30 40 50] [20 30] // 修改newSlice索引为1的元素，同时也修改了原来的 slice 的索引为 2 的元素 newSlice[1] = 35 fmt.Println(slice,newSlice) //[10 20 35 40 50] [35 88] ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-03 下午4.42.59.png)
 索引越界 索引越界会引发运行时错误：
// 创建一个整型切片，其长度和容量都是 5 个元素 slice := []int{10, 20, 30, 40, 50} // 创建一个新切片，其长度为 2 个元素，容量为 4 个元素 newSlice := slice[1:3] // 修改newSlice索引为3的元素，这个元素对于newSlice来说并不存在 newSlice[3] = 45 //因为newSlice的长度为2，因此索引只包括0，1 // 这个切片操作试图设置容量为4，这比可用的容量大 source := []string{&amp;#34;Apple&amp;#34;, &amp;#34;Orange&amp;#34;, &amp;#34;Plum&amp;#34;, &amp;#34;Banana&amp;#34;, &amp;#34;Grape&amp;#34;} slice := source[2:3:6] //容量大于已有容量，因为包括2在内的索引为2，3，4，只有3个元素了  切片增长 使用append向slice里面追加一个或者多个元素，总是会增加新切片的长度，而容量有可能会改变，这取决于被操作的切片的可用容量。
使用append会返回一个和原slice一样类型的slice。并且会改变slice所引用的数组的内容，从而影响到引用同一数组的其他slice。因此使用append函数可能会影响之前的切片。
// 创建一个整型切片，其长度和容量都是 5 个元素 slice := []int{10, 20, 30, 40, 50}  // 创建一个新切片，其长度为 2 个元素，容量为 4 个元素 newSlice := slice[1:3] //[20 30] fmt.Println(slice,newSlice)//[10 20 30 40 50] [20 30]  // 使用原有的容量来分配一个新元素，将新元素赋值为 60 newSlice = append(newSlice, 60) //替换 slice 中 40 为 60 fmt.Println(slice,newSlice) //[10 20 30 60 50] [20 30 60] ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-03 下午5.04.54.png)
如果切片的底层数组没有足够的可用容量——是指超出切片的cap限制，而非底层数组长度限制，因为数组长度len可小于数组容量cap。此时，append 函数会创建一个新的底层数组，将被引用的现有的值复制到新数组里，再追加新的值：
// 创建一个整型切片其长度和容量都是 4 个元素 slice := []int{10, 20, 30, 40} // 向切片追加一个新元素 fmt.Println(slice) //[10 20 30 40] newSlice := append(slice, 50)// 将新元素赋值为 50 fmt.Println(slice,newSlice)//[10 20 30 40] [10 20 30 40 50] 当这个append操作完成后， 拥有一个全新的底层数组，这个数组的容量是原来的两倍「新分配的底层数组是原cap的2倍，而非原数组的2倍」，此外新分配时并非总是2倍，对于较大的切片，会尝试扩容1/4，以节约内存。
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-03 下午5.34.08.png)
在切片的容量小于1000个元素时，总是会成倍地增加容量。一旦元素个数超过1000，容量的增长因子会设为1.25，也就是会每次增加25%的容量。随着语言的演化，这种增长算法可能会有所改变。
因此在对切片使用append函数时，要特别注意是否超出了容量，如果超出了容量，则会创建一个新的底层数组
 迭代切片 当迭代切片时，关键字range会返回两个值。第一个值是当前迭代到的索引位置(下标），第二个值是该位置对应元素值的一份副本。
slice := []int{10, 20, 30, 40} // 迭代每一个元素，并显示其值 for index, value := range slice {  fmt.Printf(&amp;#34;Index: %d Value: %d\n&amp;#34;, index, value) } ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-03 下午5.45.17.png)
使用for-range迭代数组和切片有很重要的区别，如下所示：
data :=[3] int{10,20,30} for i,x := range data { //更新数组的值之后,x的值不起作用,猜测是另外使用了一个数组来复制原数组，因为数组不是引用类型 	if i == 0{ 	data[0] &#43;= 100 	data[1] &#43;= 200 	data[2] &#43;= 300 	} 	fmt.Println(x,data[i]) }//10 110 20 220 30 330   for i,x := range data[:] { //更新引用中的值之后,x的值在下一轮立即起作用 	if i == 0{ 	data[0] &#43;= 100 	data[1] &#43;= 200 	data[2] &#43;= 300 	} 	fmt.Println(x,data[i]) }//110 210 420 420 630 630  函数参数为切片 由于与切片关联的数据包含在底层数组里，不属于切片本身，所以将切片复制到任意函数的时候，对底层数组大小都不会有影响，复制时只会复制切片本身，不会涉及底层数组，但是操作时可能改变顶层数组。
// 分配包含 100 万个整型值的切片 slice := make([]int, 1e6) // 将 slice 传递到函数 foo slice = foo(slice) // 函数 foo 接收一个整型切片，并返回这个切片 func foo(slice []int) []int { ... return slice } ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-03 下午5.54.25.png)
在函数间传递24字节（64位机器）的数据会非常快速、简单。这也是切片效率高的地方。不需要传递指针和处理复杂的语法，只需要复制切片，按想要的方式修改数据，然后传递回一份新的切片副本。
 </content>
    </entry>
    
     <entry>
        <title>Go 数组</title>
        <url>https://iihui.github.io/post/go-array/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html"> 定义 在Go语言里，数组是一个长度固定的数据类型，用于连续存储多个具有相同的类型的元素。数组存储的类型可以是内置类型，如整型或者字符串，也可以是某种结构类型。
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-03 下午3.13.38.png)
 声明和初始化 声明 声明数组时需要指定内部存储的数据的类型，以及需要存储的元素的数量，这个数量也称为数组的长度。数组长度必须是一个常量表达式，并且是一个非负数，数组长度最大为2Gb。
var a [5]int //[5]与int紧贴 一旦声明，数组里存储的数据类型和数组长度就都不能改变了。如果需要存储更多的元素， 就需要先创建一个更长的数组，再把原来数组里的值复制到新数组里。
在Go语言中声明变量时，总会使用对应类型的零值来对变量进行初始化。数组也不例外。 当数组初始化时，数组内每个元素都初始化为对应类型的零值。
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-03 下午3.16.38.png)
 初始化 如果使用...替代数组的长度，Go语言会根据初始化时数组元素的数量来确定该数组的长度。
array1 := [5]int{10,20,30,40,50} //前面的数字5来确定数组的长度 array2 := [...]int{1,2,3,4,5} //后面的数据元素来确定数组的长度 // var array3 [...]int =[...]int{12,35.89}这种方式是不行的， //也就是说[...]int 声明数组的时候，[...]int只能出现在=的右边，不能在左边出现 如果知道数组的长度，并且准备给每个值都指定具体值，就可以使用如下的形式来声明数组：
array :=[5]int{1:10,2:20} //数组长度已知，给数组中某些元素赋予特殊的值 ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-03 下午3.21.09.png)
array := [4][2]int{1: {20, 21}, 3: {40, 41}}  注意事项   使用下标来访问数组时，因为会检测下标的大小，所以一旦超出了数组的长度，那么会给出提示；如果没有检测到超出范围而实际上超出了数组长度，则运行时会panic。
  数组变量的类型包括数组长度和每个元素的类型。只有这两部分都相同的数组，才是类型相同的数组，才能相互赋值。
  多维数组的类型包括每一维度的长度以及数据的类型。
  在函数之间传递变量时，总是以值的方式传递的。如果这个变量是一个数组，意味着整个数组，不管有多长都会完整复制，并传递给函数。如果数组长度很大的话，会影响性能，此时建议使用切片。
var array [1e6]int // 将数组传递给函数 foo foo(array) // 函数 foo 接受一个 100 万个整型值的数组 func foo(array [1e6]int) { ... }   定义数组时，数组长度必须是非负整型常量表达式，长度是类型的组成部分，也就是说元素类型相同，但长度不同的数组不属于同一类型。
var d1 [3] int var d2 [4] int d1 = d2 //错误， d1 和 d2 不属于同一类型，不能赋值，不能比较   未提供初始化值的元素自动初始化为类型零值。
var d1 [3] int //初始化为[0 0 0] var d2 [4] int //初始化为[0 0 0 0] d3 := [5]int{2,3,4} //初始化为 [2 3 4 0 0] fmt.Println(d1,d2,d3) //[0 0 0] [0 0 0 0] [2 3 4 0 0]   数组初始化时，可指定位置进行初始化，只要不超出数组的长度范围即可。
d4 := [4]int{5,3:10} //[5 0 0 10]   编译器可以按照初始化值的数量确定数组长度，数组在声明的时候使用[...]即可
d5 := [...]int{34,8,9} //长度为3 d6 := [...]int{5,3:10} //长度为4，内容为[5 0 0 10]   在定义多维数组时，仅第一维可以允许使用...，即省略第1维的长度。
  内置函数len和cap可以返回第一维长度
d7 :=[3][4]int {{2},{3}} fmt.Println(len(d7),cap(d7)) //3,3 返回的是第一维的长度   如果数组中的元素支持==，！= 等操作符，那么数组也支持该操作。
var d1 [4] int //d1数组中元素全部为0 var d2 [4] int //d2数组中元素全部为0 d3 := [4]int{2,3,4} d4 := [4]int{5,3:10} fmt.Println(d1==d2,d3==d4) //true false   分清指针数组和数组指针：数组的地址为数组指针，而数组中的元素类型为指针则为数组指针。
d11,d12:=20,10 d13:=[...]*int{&amp;amp;d11,&amp;amp;d12} //指针数组 d14:=&amp;amp;d13 //数组指针 fmt.Println(d13,d14) //[0xc420072250 0xc420072258] &amp;amp;[0xc420072250 0xc420072258]   可以获取数组中任意元素的地址，只要在数组元素前加&amp;amp;即可。
d4 := [4]int{5,3:10} fmt.Println(&amp;amp;d4,&amp;amp;d4[0],&amp;amp;d4[3])//&amp;amp;[5 0 0 10] 0xc4200680e0 0xc4200680f8    </content>
    </entry>
    
     <entry>
        <title>Go 未命名类型</title>
        <url>https://iihui.github.io/post/go-undef-type/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html"> 未命名类型 在Go中数组、切片、字典、通道类型与具体元素类型或长度属性相关，故被称为未命名类型。具有相同声明的未命名类型被称为同一类型，在 Go 中未命名类型共有8类。
  具有相同基础类型的指针
  具有相同元素类型和长度的数组array
  具有相同元素类型的切片slice
  具有相同键和值类型的字典map
  具有相同数据类型以及操作方向的通道channel
  具有相同字段序列（字段名、字段类型、标签以及字段顺序）的结构体struct
  具有相同签名的（参数和返回值列表，不包括参数名）的函数func，其中函数的参数顺序也属于签名的组成部分
  具有相同方法集（方法名，方法签名，不包括顺序）的接口interface
  容易被忽略的是struct tag它属于类型组成的一部分，而不仅仅是元数据描述
  var a struct{  x int `x`  s string `s`  }  var b struct{  x int  s string }  b=a //cannot use a (type struct { x int &amp;#34;x&amp;#34;; s string &amp;#34;s&amp;#34; })  //as type struct { x int; s string } in assignment fmt.Println(b) 未命名类型的转换规则   所属类型完全相同
  基础类型相同，其中一个是未命名类型
  数据类型相同，将双向通道赋值给单向通道，且其中一个是未命名类型
 type data [2]int //data是使用数组新定义的类型  var d data =[2]int{1,2} //基础类型相同，其中一个是未命名类型   doubleChan := make(chan int,3) //双向通道  var singleChan chan&amp;lt;- int = doubleChan //双向通道赋值给单向通道   </content>
    </entry>
    
     <entry>
        <title>Go 接口</title>
        <url>https://iihui.github.io/post/go-interface/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html"> 接口定义 接口代表一种调用契约，是多个方法声明的集合。在某些动态语言中接口(interface)也被称为协议(protocol)。准备交互的双方，共同遵守事先的约定规则，使得在无须知道对方身份的情况下进行协作。接口关心的是做什么，而不关心怎么做，谁来做。
接口解除了类型依赖，有助于减少用户可视方法，屏蔽内部结构和实现细节。但这并不意味着可以滥用接口，因为实现接口会有运行时开销。接口最常见的使用场景是对包外提供访问，或预留扩展空间。
接口定义了一组方法，但是这些方法不包括实现代码，接口中也不包含变量「我的理解是不包含普通变量，但可以有接口变量」。
在Go中只要目标类型方法集内包含接口声明的全部方法，就被当作实现了该接口，不需要做显式的声明。显然这是一种非侵入式的设计方法，这种设计方法的好处是，在前期开发时设计出合理的接口并不容易，等后期代码重构时，模块分拆时再分离出接口时比较容易。
 注意事项 按照约定，接口名字首选以er或者r结尾，其次为able为后缀，最次以I开头。在定义接口时需要注意的事项：
  接口的本质可以认为是一个指针，但和指针又不完全相同——指向接口变量的指针是非法的，如下是var ai namer在内存中的布局： ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-12-18 上午8.54.39.png)
  接口定义中，不能出现变量定义。「我的理解是不可以有普通变量，但是可以嵌入其他接口」
  Go中接口都很简短，一般0到3个方法。
  接口定义中只能声明方法，不能包含方法的具体实现。
  接口定义中，不能定义接口自己的方法。
  编译器会根据目标类型的方法集来确定该类型是否实现了该接口，如果目标类型的方法集中没有完全实现接口中声明的方法，那么该目标类型就不可以赋值给该接口变量。
  即使接口在类型之后才定义，二者处于不同的包中，被单独编译。但是，只要类型实现了接口中的方法，它就实现了此接口。
  一个接口可以包含一个或多个其他接口，这相当于直接将这些内嵌接口的方法列举在外层接口中一样。
  可以像嵌入匿名字段那样，嵌入其他接口类型。此时目标类型方法集中必须包含嵌入的接口方法在内的全部方法，才能算实现了该接口。也就是说嵌入其他接口类型，相当于将嵌入的接口声明的全部方法导入。这就要求嵌入接口中的方法与本接口中不能有同名的方法，因为Go不支持重载。
  在接口中嵌入接口时，超集接口变量可以隐式转换为嵌入的接口变量。反过来不行——因为信息不完整了。
  在嵌入接口类型时，不能嵌入自身或循环嵌入，那会导致递归错误。
  支持匿名接口类型：①可以直接用于变量定义 ②可用于结构体字段类型。
  多个类型可以实现同一个接口，实现某个接口的类型（除了实现接口方法外）可以有其他的方法，这就说明一个类型可以实现多个接口。
  接口变量的默认值是nil(因为接口也是一种引用类型)。
  对于两个接口变量对应的目标类型支持判等运算，那么这两个变量就可以做相等运算。
  如果接口没有任何方法声明，那么就是一个空接口，它的用途和Java中的Object一样，可以被赋值为任何类型的对象。
   接口嵌套接口 一个接口可以包含一个或多个其他的接口，这相当于直接将这些内嵌接口的方法列举在外层接口中一样。
type ReadWrite interface{  Read(b buffer) bool  Write(b buffer) bool }  type Lock interface{  Lock()  Unlock() }  type File interface{  ReadWrite //嵌入接口  Lock  Close() //自己的方法 }  检测和转换接口变量 一个接口变量可以被任何实现了该接口的类型的变量赋值，即接口变量在运行时存在多态行为。因此需要一种方法来检测某个时刻一个接口变量是否是某个类型T。
v:=x.(T) //未检测类型断言  if v,ok := x.(T); ok{ //检测类型断言  do something  return } 其中x表示接口类型的变量，且必须是接口类型变量，否则编译器会报错。而T表示需要被检测的目标类型。在检测类型断言中，如果转换合法，那么v是x转换到T类型的值，ok为true，否则v是T类型的零值，ok的值为false，此时不会有运行时错误发生。
当需要检测的类型较多时，建议使用type-switch，但是在type-switch不允许有fallthrough。
switch t := areaIntf.(type) {  case *Square:  fmt.Printf(&amp;#34;Type Square %T with value %v\n&amp;#34;, t, t)  case *Circle:  fmt.Printf(&amp;#34;Type Circle %T with value %v\n&amp;#34;, t, t)  case nil:  fmt.Printf(&amp;#34;nil value: nothing to check?\n&amp;#34;)  default:  fmt.Printf(&amp;#34;Unexpected type %T\n&amp;#34;, t) } 但是所有的case语句中列举的类型(nil除外)都必须实现对应的接口，如果被检测类型没有匹配case语句列举的类型，就会执行default语句。
 空接口 空接口是不包含任何方法，它对实现不做任何要求。任何类型都实现了空接口，any或Any是空接口一个很好的别名或者缩写。
type any interface{} 可以给一个空接口类型的变量var val interface{} 赋任何类型的值。
每个空接口变量在内存中占据两个字节，一个用来存储它包含的类型，另一个用来存储它包含的数据或者指向数据的指针。
 执行机制 接口是一种契约，实现类型必须满足它，它描述了类型的行为，规定类型可以做什么。接口将类型能做什么和如何做分离开来，使得相同接口变量在不同时刻表现出不同的行为，这就是多态的本质。
从内部实现上来看，接口自身也是一种结构体，只是编译器会对其作出很多限制。接口使用一个名为itab的结构体存储运行期所需的相关类型信息。
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-12-18 上午8.54.39.png)
type iface struct{  tab * itab //类型信息  data unsafe.Pointer //实际对象指针 }  type itab struct{  inter *interfacetype //接口类型  _type *_type //实际对象类型  fun [1]uintptr //实际对象方法地址 } 接口有一个重要的特性：将对象赋值给接口变量时，会复制该对象。我们甚至无法修改接口存储的复制品，因为它是unaddreable，即使将其复制出来，使用本地变量修改后，依然无法对iface.data赋值。解决的方法是将对象指针赋值给接口，那么接口内存储的就是指针的复制品。
只有当接口变量的内部的两个指针(itab,data)都为nil时，接口才等于nil。因此造成的错误并不少见，尤其是在函数返回error时，详见Go学习笔记P149。
var a interface{}=nil var b interface{}=(*int)(nil) println(a==nil,b==nil) //true false 类型推断可将接口变量还原为原始类型，或者用来判断是否实现了某个更具体的接口类型
type data int func (d data) String() string{  return fmt.Sprintf(&amp;#34;data:&amp;#34;%d&amp;#34;,d) }  var d data=16 if n,ok:=x.(fmt.Stringer); ok{ //转换为更具体的接口类型  fmt.Println(n) }  if d2,ok:=x.(data); ok{ //转换为原始类型  fmt.Println(d2) }  e:=x.(error) //错误，main.data is not error fmt.Println(e) 使用ok-idiom模式，即使转换失败也不会引发panic。还可以用switch语句在多种类型间作出推断匹配，这样接口就能有更多的发挥空间。
var x interface{}=func(x int)string{  return fmt.Sprintf(&amp;#34;d:%d&amp;#34;,x) }  switch v := x.type{  case nil:  println(&amp;#34;nil&amp;#34;)  case *int:  println(*v)  case func(int)string:  println(v(100)  case fmt.Stringer:  fmt.println(v)  default:  fmt.println(&amp;#34;unknown&amp;#34;) } 如上所示的type switch中不支持fallthrought。
 </content>
    </entry>
    
     <entry>
        <title>Go 定义类型</title>
        <url>https://iihui.github.io/post/go-struct/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html">  值的类型给编译器提供两部分信息：①需要分配多少内存给这个值；②这段内存表示什么。Go语言允许用户定义类型，当用户声明一个新类型时，这个声明就给编译器提供一个框架，告知必要的内存大小和表示信息。
 结构体 Go语言中声明用户定义的类型有两种方法，①最常用的方法是使用关键字struct，它可以让用户创建一个结构类型；②另一种是使用根据已有类型来定义新的类型。
结构体的定义 结构体类型通过组合一系列固定且唯一的字段来声明，结构体中每个字段都会用一个已知类型声明。结构体声明以关键字type开始，之后是新类型的名字，最后是关键字struct。
type user struct {  name string  email string  ext int  privileged bool } var bill user //像声明内置类型变量一样声明  结构体的初始化 当声明结构体变量时，这个变量对应的值总是会被初始化。这个值要么用指定的值初始化，要么使用类型零值做初始化。
既然要创建初始化一个结构类型，可以使用结构体字面量来完成这个初始化。结构体字面量使用一对大括号括住内部字段的初始值，结构字面量可以对结构类型变量初始化可以采用两种形式。
一种是顺序字面量，另一种是命名字面量。初始化的时候，使用顺序字面量对结构体变量进行初始化称为顺序初始化，而使用命名字面量进行初始化称为命名初始化。推荐使用命名初始化，这样在扩充结构体的字段时就不会导致初始化错误。
user{ //命名字面量  name : &amp;#34;Lisa&amp;#34;,  email : &amp;#34;Lisa@gmail.com&amp;#34;,  ext : 123,  privileged : true, }  //顺序字面量进行顺序初始化，必须要和结构声明中的字段的顺序一致 lisa := user{&amp;#34;Lisa&amp;#34;,&amp;#34;Lisa@gmail.com&amp;#34;,123,true} //顺序方式 u1 ：= user{&amp;#34;Andy&amp;#34;,&amp;#34;Andy@gmail.com&amp;#34;} //错误，顺序初始化时参数不够 使用命名字面量进行初始化称为命名初始化：
type node struct {  _ int  id int  next * node }  n1 := node{  id:1, //逗号不可以省略，未初始化的为类型默认零值 }  n2 := node{  id:2,  next: &amp;amp;n1, //即使是结构体的最后一个变量，逗号不可以省略 }  fmt.Println(n1,n2)//{0 1 &amp;lt;nil&amp;gt;} {0 2 0xc4200be4e0}  匿名结构体 可直接定义匿名结构体类型变量，或用做结构体的命名字段类型「不能是匿名字段类型，因为类型已经没有名字」。匿名结构体在作为结构体的字段值时因其缺少类型标识，无法进行直接初始化，前面的两种方式的字面量都需要结构体类型名字：
u := struct { // 直接定义匿名结构体  name string  age byte }{  name : &amp;#34;Tom&amp;#34;,  age : 12, }  type file struct{  name string  attr struct { //匿名结构体字段  owner int  perm int }  f := file {  name: &amp;#34;test.dat&amp;#34; // attr: { //错误 // owner: 1, // perm: 0755, //}, }  f.attr.owner = 1 //也可以在初始化语句中再次定义，但那样看上去会非常丑陋 f.attr.perm = 0755  注意事项 只有在所有字段类全部支持判等操作时，才可以做相等操作:
type data struct {  x int  y map[string]int }  d1 := data{ //命名初始化  x: 100, }  d2 := data{ //命名初始化  x: 100, }  println(d1 == d2) 可以使用指针直接操作结构字段，但不能是多级指针。
type user struct {  name string  age int }  p := &amp;amp; user{  name : &amp;#34;Tom&amp;#34;  age : 12 }  p.name = &amp;#34;Mary&amp;#34; //指针直接操作结构体字段 p.age &#43;&#43; //指针直接操作结构体字段  p2 := &amp;amp; p *p2.name = &amp;#34;Jack&amp;#34; //错误，不能使用多级指针直接操作结构体字段  空结构体 空结构体struct {}是指没有字段的结构类型，它比较特殊，因为无论是其自身，还是作为数组元素类型，其长度均为0。
var a struct{} var b [100] struct{}  println(unsafe.Sizeof(a),unsafe.Sizeof(b))//0 0 对于空结构体来说，尽管没有分配数组内存，但依然可以操作元素，对应切片len,cap属性也正常。
var d[100] struct{} s := d[:]  d[1] = struct{}{} d[2] = struct{}{}  fmt.Println(s[3],len(s),cap(s)) //{} 100 100 实际上，这类长度为0的空结构体对象通常指向runtime.zerobase变量。 空结构体可作为通道元素类型，用于事件通知。
a := [10]struct{}{} b := a[:] c := [0]int{}  fmt.Println(&amp;amp;a,&amp;amp;b,&amp;amp;c)  结构体的匿名字段 所谓匿名字段，是指没有名字，仅有类型的字段，也称作嵌入字段或嵌入类型。
type attr struct {  perm int }  type file struct {  name string  attr //匿名字段,但不是匿名结构体，注意区别 } 从编译器的角度看，这只是隐式的以类型作为字段名字。可直接引用匿名字段的成员，但初始化时须当作独立字段。
f := file{  name : &amp;#34;test.data&amp;#34;,  attr : attr{ //显式初始化匿名字段，注意于匿名结构体那一小结的区别  perm : 0755,  }, //分号不能少 }  f.perm = 0644 //直接设置匿名字段成员 println(f.perm) 如果嵌入其他包中的类型，则隐式字段名字「不是匿名字段，是匿名字段的名字」不包括包名：
type data stuct {  os.File //匿名字段，包括包名 }  func main{  d := data {  File : os.File{} //匿名字段初始化时，字段名字不包括包名 } 不仅仅是结构体，除接口指针和多级指针以外任何命名类型都可以作为结构体的匿名字段：
type data stuct {  * int  string }  x := 100 d := data {  int: &amp;amp;x, //指针作为匿名字段时，其隐式名字为基础类型的名字  string: &amp;#34;abc&amp;#34;, } 需要注意的是，不能将基础类型和其指针类型同时嵌入，因为两者隐式名字相同。
type data stuct { * int //指针类型 int //基础类型 }  虽然可以像普通字段那样访问匿名字段成员，但会存在重名问题。默认情况下，编译器从当前显式名字字段开始，逐步向内查找匿名字段成员。如匿名字段成员被外层同名字段遮蔽，那么必须使用显式字段名。
type file struct {  name string }  type data struct{  file  name string }  d := data {  name : &amp;#34;data&amp;#34;  file : file{&amp;#34;file&amp;#34;} //匿名字段初始化 }  d.name = &amp;#34;data2&amp;#34; d.file.name = &amp;#34;file2&amp;#34; //同名字段，使用显式字段名访问 data.file.name 如果多个相同层级的匿名字段成员重名，就只能使用显式字段名，因为编译器无法确定目标：
type file struct {  name string }  type log struct {  name string }  type data struct {  file  log }  func main(){  d := data{}  d.name = &amp;#34;name&amp;#34; //错误，必须使用显式字段名  d.file.name = &amp;#34;file&amp;#34;  d.log.name = &amp;#34;log&amp;#34; }  字段标签 字段标签并不是注释，而是用来对字段进行描述的元数据。尽管它不属于数据成员，但却是类型的组成部分。在运行期，可用反射获取标签信息，它常被用作格式校验，数据库关系映射等。
type user struct{  name string `昵称`  sex type `性别` }  内存布局 在Go中不管结构体包含多少个字段，其内存总是一次性分配的，各字段在相邻的地址空间按定义顺序排列。当然，引用类型、字符串和指针，结构内存中只包含其基本(头部)数据。
在分配内存时，字段须做对齐处理，通常以所有字段中最长的基础类型宽度为标准。
比较特殊的空结构体类型。如果它是最后一个字段，那么编译器将其当作长度为1的类型做对齐处理，以便其地址不会越界，避免引发垃圾回收错误。
如果仅有一个空结构体字段，那么同样按1对齐，只不过长度为0，且指向runtime.zerobase变量。
 根据已有类型定义新类型 另一种声明用户定义的类型的方法是，基于一个已有的类型，将其作为新类型的类型说明。当需要一个可以用已有类型表示的新类型的时候，这种方法会非常有用。
type Duration int64 给不同类型的变量赋值会产生编译错误
package main type Duration int64  func main(){  var dur Duration  dur = int64(1000) //会出现编译错误 }  </content>
    </entry>
    
     <entry>
        <title>Go 延迟调用</title>
        <url>https://iihui.github.io/post/go-defer/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html">  关键字defer允许我们推迟到函数返回前一刻(或任意位置执行return语句之后)才执行某个语句或函数。
 为什么要在返回之后才执行这些语句？因为return语句同样可以包含一些操作，而不是单纯地返回某个值，实际上此时return语句要做三件事：①如果有命名参数，将返回值赋给命名返回值。②执行defer语句或函数。③结束函数的执行。
语句defer向当前函数注册稍后执行的函数调用，这些函数被称为延迟调用，因为它们直到当前函数执行结束之后才被执行，常用于资源释放，解除锁定，以及错误处理等操作。
执行顺序 同一函数中注册多个defer语句时，执行时将会按照注册顺序先进后出的顺序执行即FILO的次序执行。
如果遇到panic语句，那么和遇到return语句一样，会触发延迟调用，并且延迟调用会先于panic中的打印语句。
func main() { 	defer_call() }  func defer_call() { 	defer func() { fmt.Println(&amp;#34;打印前&amp;#34;) }() //最后调用 	defer func() { fmt.Println(&amp;#34;打印中&amp;#34;) }() //中间调用 	defer func() { fmt.Println(&amp;#34;打印后&amp;#34;) }() //最先调用  	panic(&amp;#34;触发异常&amp;#34;) //在defer之后执行 } //打印后 //打印中 //打印前 //panic: 触发异常 编译器通过插入额外的指令来实现延迟调用执行，而return和panic语句都会终止当前函数流程，引发延迟调用。此外，return语句不是ret汇编指令，它会更新返回值，如下例所示：
func TestDefer() (z int) { 	defer func() { 	println(&amp;#34;defer&amp;#34;, z) //100 	z &#43;= 100 	}() 	return 100 //最后z的值为200，实际执行次序为z=100， call defer，ret }  使用场景 延迟调用一般用于做一些收尾工作，例如：①关闭文件流；②关闭数据库连接；③解锁一个加锁的资源；④打印最终的报告。
一个基础但十分实用的实现代码执行追踪的方案就是在进入和离开某个函数打印相关的消息，即可以提炼为下面两个函数
func trace(s string) {  fmt.Println(&amp;#34;entering:&amp;#34;, s) } func untrace(s string) {  fmt.Println(&amp;#34;leaving:&amp;#34;, s) }  注意事项 延迟调用注册的是调用，必须提供执行所需要的参数（哪怕为空），参数在注册的时候被复制并缓存起来，如对状态敏感，可改用指针或闭包。
 func TestDeferRegister(){ 	x, y := 1,2 	defer func(a int){ //传给参数a的值被缓存起来 	println(&amp;#34;defer x,y =&amp;#34;,a,y) //y是在延迟调用时读取被改变之后的值 	}(x)  	x &#43;= 100 	y &#43;= 200  	println(x,y) //y对于defer函数来说是外部变量  }  //101 202  //defer x,y = 1 202  如果在延迟函数中使用外部变量，就应该通过参数传入。具体实例见下面代码：
func printNumber() { 	for i := 0; i &amp;lt; 5; i&#43;&#43; { 	defer func () { 	fmt.Printf(&amp;#34;%d\t&amp;#34;,i) 	} 	} }//输出为5 5 5 5 5 func printNumber() { 	for i := 0; i &amp;lt; 5; i&#43;&#43; { 	defer func (n int) { 	fmt.Printf(&amp;#34;%d\t&amp;#34;,i)		}(i) 	} } //输出为4 3 2 1 0 第一个函数的输出为5 5 5 5 5，是因为使用了外部变量i，当触发延迟调用的时候，i的值已经变成了5。
第二个函数的输出为4 3 2 1 0，是因为匿名函数被传入了一个参数，每次注册的时候，会将传入的参数缓存起来。
 </content>
    </entry>
    
     <entry>
        <title>Go 方法</title>
        <url>https://iihui.github.io/post/go-method/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html"> 方法 在Go中结构体就像是类的一种简化形式，方法就像类中的方法。方法是与对象实例绑定的特殊函数，方法和函数定义语法区别在于:方法有前置实例接收参数receiver，编译器以此确定方法所属类型。
接收者类型几乎可以是任何类型，不仅仅是结构体类型，甚至可以是函数类型。但是，有两种类型不可以有方法：
  接收者不能是一个接口类型， 因为接口是一个抽象定义，但是方法需要具体实现。
  接收者的类型不能是本身类型是指针的类型，例如type TP *int,那么TP就不可以定义方法。
  一个类型加上它的方法等价于面向对象中的一个类。在Go中，类型的代码和绑定在它上面的方法的代码可以不放置在一起，它们可以存在于不同的源文件，唯一的要求——它们必须在同一个包中。
 使用 package main  import ( 	&amp;#34;fmt&amp;#34; )  type user struct { 	name string 	email string }  // 使用user值类型作为接收者 func (u user) notify() { 	fmt.Printf(&amp;#34;Sending User Email To %s&amp;lt;%s&amp;gt;\n&amp;#34;, u.name, u.email) }  // 使用指针类型作为接收者 func (u *user) changeEmail(email string) { 	u.email = email }  // func main() { 	bill := user{&amp;#34;Bill&amp;#34;, &amp;#34;bill@email.com&amp;#34;} 	bill.notify() //值类型来调用方法  	lisa := &amp;amp;user{&amp;#34;Lisa&amp;#34;, &amp;#34;lisa@email.com&amp;#34;} 	lisa.notify() //指向user类型值的指针也可以调用使用值类型作为接收者的方法  	bill.changeEmail(&amp;#34;bill@newdomain.com&amp;#34;) 	bill.notify() //使用值来调用以指针作为接收者的类型  	lisa.changeEmail(&amp;#34;Lisa@newdomain.com&amp;#34;) 	lisa.notify() //指针类调用以指针类型作为接收者的类型 }  注意事项   方法是一种特殊的函数，因此方法是不支持重载的，即一个类型的方法集中的所有方法是不能够有同名的方法。
  如果方法内部不引用实例，可省略参数名，仅保留类型。
  接收者receiver类型可以是基础类型或指针类型，区别在于调用时对象实例是否被复制。值接收者使用值的副本来调用方法，而指针接受者使用实际值来调用方法。
type N int func TestMethod() {  var a N = 25  //println(a.toString())  a.value()  fmt.Printf(&amp;#34;a: %p,%v\n&amp;#34;, &amp;amp;a, a)   a.pointer()  fmt.Printf(&amp;#34;a: %p,%v\n&amp;#34;, &amp;amp;a, a) }  func (n N) value() { //值类型的接受者，调用的时候会复制，所以n的值的更改不会体现到接收者的类型上来  n&#43;&#43;  fmt.Printf(&amp;#34;v: %p,%v\n&amp;#34;, &amp;amp;n, n) }  func (n *N) pointer() {  (*n)&#43;&#43;  fmt.Printf(&amp;#34;p: %p, %v\n&amp;#34;, n, *n) }   可使用实例值或者指针调用方法，编译器会根据方法receiver类型自动在基础类型和指针类型间转换。
var a N = 25 p := &amp;amp;a a.value() a.pointer() p.value() p.pointer()   只能使用一级指针调用方法，不能使用多级指针调用方法。
var a N = 25 p := &amp;amp;a p2 := &amp;amp;p p2.value() //错误，使用多级指针 p2.pointer() //错误，使用多级指针调用   指针类型的receiver必须是合法地址（包括nil），或能获取实例的地址，否则会出现运行时错误。
var b * N b.value() //b 相当于nil,可以调用，但是会出现运行时错误，因为没有指向具体实例，所以在传参数时出现错误 //N{}.pointer()   别名类型能定义方法的前提是其原始类型没有定义过该方法。
  在Go中类型和作用在它上面的方法必须在同一个包里定义，这就是为什么不能在int、float或类似这样的标准类型上定义方法。有一个比较曲折的绕过这种规定的方式：可以先定义该类型（比如int或float）的别名类型，然后再为别名类型定义方法。
   receiver建议 选择方法的receiver的建议
  要修改实例状态，用 * T
  无须修改的小对象或固定值，建议用T
  大对象建议使用 *T，以减少复制成本
  引用类型，字符串，函数等指针包装对象，直接用T
  若包含 Mutex 等同步字段，用*T，避免因复制造成锁操作无效
  其他无法确定的情况，都用 *T
  可以像访问匿名字段那样调用其方法，由编译器负责查找，尽管可以直接访问匿名字段的成员和方法，但它们仍不属于继承关系
type data struct { 	sync.Mutex } d := data{} d.Lock() defer d.Unlock()  方法集 类型有一个与之对应的方法集，这决定了它是否实现某个接口。当一个匿名类型被内嵌在结构体中时，匿名类型的可见方法也同样被内嵌。这在效果上等同于外层类型继承了这些方法。这个机制提供了一种简单的方式来模拟经典面向对象语言中的子类和继承相关的效果。
  类型T的方法集包含了所有的receiver T方法
  类型*T包含了所有receiver T&#43;*T方法
  匿名嵌入S，T的方法集中包含所有receiver S方法
  匿名嵌入*S，T的方法集中包含所有receiver S&#43;*S方法
  匿名嵌入S或*S，*T的方法集中包含所有receiver S &#43; *S方法
  和内嵌类型方法具有同样名字的外层类型的方法会覆写内嵌类型对应的方法。
func (S) sVal() {} func (*S) sPtr() {} func (T) tVale() {} func (*T) tPtr() {}  func MethodSet(a interface{}) { 	t := reflect.TypeOf(a)  	for i, n := 0, t.NumMethod(); i &amp;lt; n; i&#43;&#43; { 	m := t.Method(i) 	fmt.Println(m.Name, m.Type) 	} }  方法表达式 方法和函数一样，除直接调用外，还可赋值变量，作为参数传递，依照具体的引用方法不同，分为 expression 和 value 两种。
Method Expression 通过类型引用的Method Expression会被还原成普通函数样式,receiver是第一参数，调用时须显式传参，可以是T或*T，只要该方法存在于该类型方法集中即可。
type N int func (n N) test() { 	fmt.Printf(&amp;#34;test.n:,%p,%d\n&amp;#34;, &amp;amp;n, n) }  var n N = 25 fmt.Printf(&amp;#34;main.n:,%p,%d\n&amp;#34;, &amp;amp;n, n)  f1 := N.test f1(n)  f2 := (*N).test //尽管*N方法集包装test方法receiver类型不同，但编译器会保证按原定义类型拷贝传值 f2(&amp;amp;n) //main.n:,0xc42006e1a8,25 //test.n:,0xc42006e1c8,25 //test.n:,0xc42006e1d8,25 还可以直接以表达式的方式调用
N.test(n) (*N).test(&amp;amp;n) //test.n:,0xc42006e1c8,25 //test.n:,0xc42006e1d8,25  Method Value 基于实例或指针引用的method value，参数签名不会改变，依旧按正常方式调用，但当method value被赋值给变量或作为参数传递时，会立即计算并复制该方法执行所需的receiver对象与其绑定，以便在稍后的执行时，能隐式传入receiver参数。
var n N = 25 p := &amp;amp;n  n&#43;&#43; t1 := n.test  n&#43;&#43; t2 := p.test  n&#43;&#43; fmt.Printf(&amp;#34;main.n:,%p,%d\n&amp;#34;, &amp;amp;n, n)  t1() t2() //main.n:,0xc42000e258,28 //test.n:,0xc42000e278,26 //test.n:,0xc42000e288,27 当method value作为参数时，会复制含receiver在内的整个method value
func call(m func()){  m() }  var n N = 25 p := &amp;amp;n  fmt.Printf(&amp;#34;main.n:,%p,%d\n&amp;#34;, &amp;amp;n, n)  n&#43;&#43; call(n.test)  n&#43;&#43; call(p.test)  //main.n:,0xc42006e1a8,25 //test.n:,0xc42006e1c8,26 //test.n:,0xc42006e1d8,27 如果目标方法的receiver是指针类型，那么被复制的仅是指针
只要receiver参数类型正确，使用nil同样可以执行
type N int func (n N) value(){} func (n *N) pointer(){} var ptr *N  ptr.pointer() (*N)(nil).pointer() (*N).pointer(nil)  </content>
    </entry>
    
     <entry>
        <title>Go 包</title>
        <url>https://iihui.github.io/post/go-package/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html">  包是结构化的一种方式,所有Go语言的程序都会组织成若干组文件，每组文件被称为一个包。每个文件都属于且仅属于一个包，一个包中可以包含许多以.go为扩展名的源文件。
 包中源文件 源文件都使用UTF-8编码，每个源文件都属于包的一部分，在文件头部用package声明所属包。
每一个可独立运行的Go语言程序必定包含一个main包，在这个main包中必定包含一个入口函数main，这个函数没有参数也没有返回值。
入口函数main没有参数，必须放到main包中，如果 main函数没有放到main包中，构建工具就不会生成可执行文件。
如果一个源文件被声明属于main代码包，且该文件代码中包含无参数声明和无返回值声明的main函数，则它是命令源码文件。命令源文件可以通过go run命令直接启动运行。
同一个代码包中可以有多个命令源文件，可通过go run命令分别运行，但这会使go build和go install命令无法编译和安装该代码包，因此不应该把多个命令源文件放入到同一个包中。
库源码文件声明的包名会和它所属的目录名一致（建议这样做），且库源码文件中不包含无参数声明和无返回值声明的main函数。
 工作空间 Go的工作空间就是一个对应于特定工程的目录，它包含3个目录，分别是src、bin、pkg目录。
  src目录用以代码包的形式组织并保存Go源码文件。
  pkg目录用以保存使用go install命令安装后的代码包的归档文件。归档文件是指那些以.a结尾的文件。该目录与GOROOT目录下的pkg目录的功能类似，区别在于工作区下的pkg目录保存的用户代码的归档文件。
  bin目录，与pkg目录类似，在通过go install命令完成安装后，保存由Go命令源码文件生成的可执行文件。
  通常需要将工作空间的路径添加GOPATH环境变量列表中，工作空间可以有一个或者多个。
  GOPATH中不要包含Go语言的根目录，以便将Go语言本身的工作空间同用户的工作区严格分开。
  通过go install命令获取的源码，将会下载到GOPATH中设定的第一个工作空间中，并在其中完成编译和安装。
  只有当环境变量GOPATH中只包含一个工作区的目录路径时，go install命令才会把命令的源码文件安装到当前工作区的bin目录下。否则执行go install就会出错，此时需要设置环境变量GOBIN，用于存放所有因安装Go命令源码文件而产生的可执行文件。
  在工作空间里，包括子包在内的所有源码文件都保存在src目录下。至于bin、pkg两个目录，其主要影响go install/get 命令，它们将编译结果安装到两个目录下，以实现增量编译。
使用标准库或第三方包前，须用import导入，参数是工作空间中以src为起始的绝对路径。
对于一个导入的包，编译器首先从标准库开始搜索，如果未找到然后就依次搜索GOPATH列表中的各个工作空间。一旦找到了导入的包，即刻停止搜索。
编译器等相关工具按GOPATH设置的路径搜索目标，导入目标库时，排在列表前面的路径比当前工作空间的优先级别更高。其中go get默认将下载的第三方包保存到列表中的第一个工作空间内。
环境变量GOROOT用于指示工具链和标准库的存放路径。环境变量PATH中也应该添加一项GOROOT/bin，这样就可以在任意目录中使用Go的命令了。
 4种方式导入 使用标准库或第三方包，须用import导入，参数是工作空间中以src目录为起始的绝对路径。
import语句告诉编译器到磁盘的哪里去找想要导入的包，编译器会使用Go环境变量设置的路径，通过引入的相对路径来查找磁盘上的包。
编译器首先会查找Go的安装目录，然后才会按顺序查找GOPATH变量中列出的目录。包的导入，总共有四种方式：
import &amp;#34;study/test&amp;#34; //默认方式： test.A import X &amp;#34;study/test&amp;#34; //别名方式： X.A import . &amp;#34;study/test&amp;#34; //简便方式：A import _ &amp;#34;study/test&amp;#34; //初始化方式，无法引用，仅用来初始化目标包，即调用init函数 在Go中未使用的导入(不包括初始化方式)会被编译器视为错误，这与C&#43;&#43;有很大的区别。
 注意事项 一个应用程序可以包含不同的包，按照惯例所有的包名都应该使用小写字母。在Go的安装文件中包含了一些可以直接使用的包——标准库。
属于同一包的源文件必须全部一起被编译，一个包就是编译时的一个单元。如果对一个包进行了重新编译，那么使用了这个包的客户端程序必须全部重新编译。
按照惯例，每个目录只包含一个包，包名一般和目录的名字相同，但这不是强制规定，包名和目录名可以不一样。
除了标识符_,包中所有的代码对象的标识符必须是唯一的，以避免名称冲突，但是相同的标识符可以在不同的包中使用，因为可以使用包名来区分它们。
当标识符以一个大写字母开头，那么它就可以被外部包的代码所使用，这种方式称之为包的导出。标识符如果以小写字母开头，则对外部包是不可见的，但是它们在内部包中是可见可用的。
  处于同一文件夹下的代码文件，必须使用同一个包名。
  在Go中按照惯例包和文件夹同名。实际上，包名和目录名并无关系，不要求保持一致。
  程序中每个代码文件中的init函数都会在main函数之前被执行。执行顺序为全局变量的初始化、init函数的执行，main函数的执行。
  以下几个包被保留，有特殊含义
  main： 可执行入口（入口函数main.main)。
  all: 标准库以及GOPATH中能找到的所有包。
  std,cmd: 标准库以及工具链。
  documentation: 存储文档信息，无法导入（和目录名无关）。
    所有成员在包内均可访问，无论是否在同一源码文件中；但只有名称首字母大写的为可导出成员，在包外是可见的。
  包内每个源码文件可定义一到多个初始化init函数，但编译器不保证执行次序，实际上所有这些初始化函数（包括标准库和导入第三方包）都由编译器自动生成的一个包装函数进行调用，因此可保证在单一线程上执行，且执行一次。
  编译器首先①确保完成所有全局变量初始化，然后②才执行初始化函数。直到这些全部结束后，运行时才正式③进入到main.main入口函数。
  使用import导入标准库或第三方包，必须删除未使用的导入，否则编译器会将其当作错误处理。
   </content>
    </entry>
    
     <entry>
        <title>Go 数据</title>
        <url>https://iihui.github.io/post/go-data/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html"> 数据类型 Go 中数据分为基本类型，数组，引用，字典（映射)，通道，函数，结构体，接口等等。
  切片slice可实现类似动态数组的功能y := make([]int, 0, 5); append(y,7)。
  将字典map类型内置，可以直接从运行层面获得性能优化。
  所谓ok-idiom模式，就是在返回值中用一个名为ok的布尔值来标识操作是否成功，因为很多操作默认返回零值，所以需要额外说明。
m := make(map[string]int) m[&amp;#34;a&amp;#34;]=1 z,ok:=m[&amp;#34;b&amp;#34;] fmt.Println(z,ok)   可以为任意类型定义方法:
type X int func (x * X) inc() {  *x&#43;&#43;  }    字符串 字符串是用一对双引号&amp;quot;&amp;quot;或者反引号括起来定义的，均采用UTF-8编码，并且是不可变的。
  字符串是一个不可变(byte）字节序列，本身是一个复合序列。头部指针指向字节数组，但没有nullptr结尾，默认以UTF-8存储字符，字面量里允许16进制，8进制以及UTF编码。
type stringStruct struct{ //字符串的底层结构  str unsafe.Pointer  len int }   字符串的默认值是&amp;quot;&amp;quot;而不是 nil。
  使用$`$定义不做转义处理的原始字符串, 并且支持跨行。
s := `line\r\n, //`开始定义不做转义的字符串  line 2` fmt.Println(s)   支持==、!=、&amp;lt;、&amp;gt;、&#43;、&#43;= 操作符，使用加法操作符跨行时，加法操作符必须接在上一行的结尾。
s：=&amp;#34;ab&amp;#34;&#43;  &amp;#34;cd&amp;#34; fmt.Println(s==&amp;#34;abcd&amp;#34;, s &amp;gt; &amp;#34;abc&amp;#34;) //true true   允许以索引号访问字节数组（非字符），但不能获取元素地址，因为字符串是不可变的。
s：=&amp;#34;hello&amp;#34; fmt.Println(s[0]) //但是不可以使用 &amp;amp;s[0]   以切片语法（起始和结束索引号）返回子串时，其内部依旧指向原字节数组。
s := &amp;#34;abcdefg&amp;#34; s1 := s[:3] //abc，前闭后开 s2:=s[1:4] //bcd s3:=s[2:] //cdefg  fmt.Println(s1,s2,s3) fmt.Printf(&amp;#34;%#v\n&amp;#34;,(*reflect.StringHeader)(unsafe.Pointer(&amp;amp;s))) //&amp;amp;reflect.StringHeader{Data:0x10b4007, Len:7} fmt.Printf(&amp;#34;%#v\n&amp;#34;,(*reflect.StringHeader)(unsafe.Pointer(&amp;amp;s1)))//&amp;amp;reflect.StringHeader{Data:0x10b4007, Len:3}   使用for遍历字符串时，分为byte 和 rune两种方式。因为字符串是UTF-8编码的，而UTF-8是变长编码，因此不难理解会有这两种形式。
s := &amp;#34;吉林&amp;#34; for i:=0;i&amp;lt;len(s) ;i&#43;&#43; { //byte形式  fmt.Printf(&amp;#34;%d:[%c]\n&amp;#34;,i,s[i]) //0:[å]1:[]2:[]3:[æ]4:[]5:[] }  for i,c:=range s { //rune形式 	fmt.Printf(&amp;#34;%d:[%c]\n&amp;#34;,i,c) //0:[吉]3:[林]  }   要修改字符串，必须将其转换为可变类型[]byte 或[]rune,待完成后再转换回来，但是不管如何转换，都必须重新分配内存，并复制数据。
  使用加法操作符拼接字符串时，每次都必须重新分配内存，因为字符串是不变的。
  字符串操作通常在堆上分配内存，这会对Web高并发应用造成较大影响，会有大量字符串对象要做垃圾回收，建议使用[]byte缓存池。
  使用单引号的字面量，其默认是rune（专门用来存储unicode码点，它是uint32的别名）。
  不能使用索引的方式修改字符串的值，但是可以使用使用赋值的方式修改整个字符串的值，类比与C&#43;&#43;中字符指针指向字符串常量时，不能以索引的形式修改单个字符，但是能够改变字符指针的指向。
s := &amp;#34;abcdef&amp;#34; fmt.Println(s,&amp;amp;s) //abcdef 0xc42000e3c0 s =&amp;#34;hello&amp;#34; //重新指向 fmt.Println(s,&amp;amp;s) //hello 0xc42000e3c0 s[1]=&amp;#39;c&amp;#39; //这是错误的,因为字符串的内部指针指向的是不可变字节，不能获取地址    数组   定义数组时，数组长度必须是非负整型常量表达式，长度是类型的组成部分，也就是说元素类型相同，但长度不同的数组不属于同一类型。
var d1 [3] int var d2 [4] int d1 = d2 // d1 和 d2 不属于同一类型，不能赋值，不能比较   未提供初始化值的元素自动初始化为类型零值（不同类型的零值不一样的）。
var d1 [3] int var d2 [4] int d3 := [5]int{2,3,4} fmt.Println(d1,d2,d3) //[0 0 0] [0 0 0 0] [2 3 4 0 0]   数组初始化时，可指定位置进行初始化。
d4 := [4]int{5,3:10} //[5 0 0 10]   编译器可以按照初始化值的数量确定数组长度。其中声明时的...一定不可以被省略。
d5 := [...]int{34,8,9} //长度为3 d6 := [...]int{5,3:10} //长度为4，内容为[5 0 0 10]   在定义多维数组时，仅第一维可以允许使用...，即省略第1维的长度。
  内置函数len和cap可以返回数组的第一维长度。
d7 :=[3][4]int {{2},{3}} fmt.Println(len(d7),cap(d7)) //3,3   如元素支持==，！= 等操作符，那么数组也支持该操作，这与C和C&#43;&#43;有很大的区别。
var d1 [4] int var d2 [4] int d3 := [4]int{2,3,4} d4 := [4]int{5,3:10} fmt.Println(d1==d2,d3==d4) //true false   分清指针数组和数组指针，这个概念和C与C&#43;&#43;是一样的。
d11,d12:=20,10 d13:=[]*int{&amp;amp;d11,&amp;amp;d12} //指针数组 d14:=&amp;amp;d13 //数组指针 fmt.Println(d13,d14) //[0xc420072250 0xc420072258] &amp;amp;[0xc420072250 0xc420072258]   可以获取任意元素的地址；而对于字符串来说，是不可以获取单个字符的地址。
d4 := [4]int{5,3:10} fmt.Println(&amp;amp;d4,&amp;amp;d4[0],&amp;amp;d4[3])//&amp;amp;[5 0 0 10] 0xc4200680e0 0xc4200680f8   数组的赋值和传参都会复制整个数组，为了避免数据复制，可以改用指针或切片。
   切片 切片本身并非动态数组或数组指针，它通过内部指针引用底层数组，设定相关属性，将数据读写操作限定到指定区域。
type slice struct{  array unsafe.Pointer // 指向数组中slice中指定的开始位置  len int // slice 的长度  cap int //最大长度，就是slice开始位置到数组的最后位置的长度 } 切片可以从一个数组或一个已经存在的的切片中再次声明。切片通过 array[i:j] 来获取，表示的区间是[i,j)即前闭后开区间，长度为j-i。
var arr =[10]byte{&amp;#39;a&amp;#39;,&amp;#39;b&amp;#39;,&amp;#39;c&amp;#39;,&amp;#39;d&amp;#39;} //array 声明长度 var a,b[] byte //slice，方括号里不声明长度  a = arr[1:3] b = arr[2:4]  fmt.Println(a,b) //[98 99] [99 100] 切片是引用类型，所以当指向相同的底层结构的切片改变元素的值时，其他所有引用该底层数组的切片都会改变该值。
var arr =[10]byte{81,82,83,84,85,86} //array  var a,b,c [] byte //slice  a = arr[1:3] b = arr[2:4]  fmt.Println(a,b) //[98 99] [99 100]  c = a[0:2]  fmt.Println(c) //[82,83]  a = arr[1:5]  fmt.Println(a,c) //[82 83 84 85] [82 83] 函数append向slice里面追加一个或者多个元素，然后返回一个和 slice一样类型的slice。并且会改变slice所引用的数组的内容，从而影响到引用同一数组的其他slice。
 字典 map是引用类型，应该使用make来分配空间。在声明的时候不需要知道map的长度，因为map是动态增长的。
未初始化的map的值是nil,此时不能对nil字典进行写操作，但是可以进行读操作。
  key可以是任意使用==或者!=操作符比较的类型，所以切片不能作为key(只包含内建类型的struct可以作为key，即不包含切片的数组)，指针和接口类型都可以作为key。
  value可以是任意类型，通过空接口可以存储任意类型的值，map也可以使用函数作为自己的值。
  字典map是无序的（因为key是无序的，导致value也是无序的），所以每次打印出来的结果都会不一样。
  value不能通过下标获取，只能通过key获取，此时的索引是key而不是下标。
  map的长度可以动态增长，当map增加到容量上限的时候，如果再增加新的Key-value对，map的大小会自动加1。出于性能考虑，对于大的map或者会快速扩张的map，即使只是大概知道容量，也最好预先标明容量。
  内置的len函数返回key的数量，不支持cap；而数组和切片中都可以使用len和cap函数。
  map的初始化可以通过key:val的方式初始化：
rating :=map[string]float32{&amp;#34;C&amp;#34;:5,&amp;#34;Go&amp;#34;:1.83} fmt.Println(rating) //map[C:5 Go:1.83]   map是一种引用类型，如果两个map同时指向同一个底层，那么一个改变，另一个也改变：
m := make(map[string]string) m [&amp;#34;Hello&amp;#34;] = &amp;#34;hello&amp;#34; m1 := m m1[&amp;#34;Hello&amp;#34;] = &amp;#34;world&amp;#34; fmt.Println(m,m1) //map[Hello:world] map[Hello:world]   访问不存在的键值，默认返回的是value的类型零值，不会引发错误，因此推荐使用ok-idiom模式，确定是否正确返回。
m := make(map[string]bool) m[&amp;#34;chen&amp;#34;] = true fmt.Println(m[&amp;#34;xiao&amp;#34;]) //false   当value是数组或者结构体成员时，不能直接修改value成员，正确的做法是返回整个value，待修改后再设置字典键值，或直接用指针类型。
  不能对nil字典进行写操作，但却能读。
var m map[string] int println(m[&amp;#34;a&amp;#34;]) m[&amp;#34;a&amp;#34;]=1 //错误   内容为空的字典与nil是不同的，内容为空的字典是可以写的，而nil字典不可以写。
var m1 map[string]int m2 := map[string]int{}  println(m1==nil,m2==nil)//true false   在迭代期间删除或者新增键值是安全的。
  运行时会对字典并发操作作出检测，如果某个任务正在对字典进行写操作，那么其他任务就不能对该字典进行并发操作（读，写，删除）否则会导致进程崩溃。
  map默认是无序的，不管是按照key还是按照value默认都不排序，如果想要为map排序，必须将key拷贝到一个切片，再对切片进行排序，然后使用切片的for-range的方法打印出所有的key和value。
   </content>
    </entry>
    
     <entry>
        <title>Go 函数</title>
        <url>https://iihui.github.io/post/go-func/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html"> Go中有3种类型的函数，第一种是普通带名字的函数，第二种是匿名函数(或者被称为lambda函数)，第三种是方法（含有接收者的特殊函数）。
特点 在Go中关键字func用于定义函数，相比于其他语言，Go中函数有以下的特点：
  函数是一等公民，即可作为参数或者返回值，可以存入变量，与变量的地位是等同的。
  函数可定义多个返回值，也可以对返回值命名。
  Go 中函数无需前置说明，即可以先使用后定义。
  Go中函数不支持同名重载，主要是因为函数重载需要匹配多余的类型而影响性能。因此，对于参数类型不同的功能相似的函数要取不同的名字。
  Go中不支持默认参数。
  Go函数中不支持命名嵌套定义(nested)——即在函数中再定义有名函数，但在函数中使可以定义匿名函数，而且可以将匿名函数赋值给变量，然后使用该变量来调用相应的函数。
  Go中函数支持不定长参数，但是必须放在末尾。
  Go中支持匿名函数和闭包。
  函数中的左花括号不可以另起一行。
   定义 每个普通函数的声明都包含一个名字，一个形参列表，一个可选的返回列表以及函数体。
func name(parameter-list)(result-list){  body } 函数的类型称之为函数签名。当两个函数拥有相同的形参列表和返回值列表时，认为两个函数的类型或签名是相同的。下面四种方式声明一个含有两个形参和一个返回值的函数：
func add(x int, y int)int{ return x&#43;y} func sub(x,y int)(z int) { z=x-y; return } func first(x int, _ int) int {return x} func zero(int, int) int {return 0} 函数形参以及命名返回值都属于函数最外层作用域的局部变量；实参是按值传递的，所以函数接收到的是每个实参的副本，修改函数的形参并不会影响到调用者提供的实参。但是，如果提供的实参包含引用类型，例如指针，slice，map、函数或者通道，那么当函数使用形参变量时就会可能间接地修改实参变量。
函数只能判断是否为nil，不支持其他比较操作可以认为函数是一种引用类型。
func A() {} func B() {} func main() { 	fmt.Println(hellolib.A == nil) //可以比较，结果为false } 从函数返回局部变量指针是安全的，编译器会通过逃逸分析(escape analysis）对函数中的指针进行扫描，查看它的作用域是否在函数内，来决定是否在堆上分配内存。
func LocalPtr() *int { 	x := 0x100 	return &amp;amp;x } fmt.Println(hellolib.LocalPtr()) //变成了堆内存,0xc42007a078  参数与返回值 参数   不支持有默认值的参数。
  不支持命名实参调用（即根据参数的名字打乱顺序调用，R语言支持这种方式）。
  调用时必须按照签名顺序传递指定类型和数量的实参，就算以_命名的参数也不能被忽略。
  在参数列表中，相邻的同类型参数可合并，这样写更方便一点：
func f(a, b int) {  fmt.Println(&amp;#34;Test&amp;#34;) }   参数可视作局部变量，因此不能在相同层次定义同名变量。
  不管是指针，引用类型还是其他类型参数，都是值拷贝，区别在于是拷贝目标对象还是拷贝指针。
  在函数调用前，会为形参和返回值分配内存空间，并将实参拷贝到形参内存中。
  变参（不定长）本质上是一个切片，只能接收0到多个同类型参数，且必须放到列表尾部。变参的长度可以为0，也就是说不传入参数。
func tt1(a ...int) {  fmt.Println(a) } func main() {  tt1() //可以不带参数调用 }   如果不定长参数的值都存储在切片中（不能是数组，如果是数组必须先转为切片），则使用slice...（3个点不能少）的方式进行展开，以传递参数。
  不定长参数可以作为对应类型的切片（不做任何修改）进行二次传递，而反过来不行，如上一条所示，必须在切片后面加...才能传递给不定长的参数。
  如果想传递类型不同的变长参数，一种方法是使用结构体，一种方式使用空接口。
  在函数调用中，切片、字典、通道以及接口都是按引用类型传递。
   返回值 有返回值的函数，必须有明确的return终止语句。除非有panic或者无break的死循环，才可以没有return语句。
func TestReturn(x int) int { 	for { 	break 	} } 命名返回值和参数一样，可当作函数局部变量使用，最后由return隐式返回。但是，这些特殊的“局部变量”可能会被不同层级的同名变量遮蔽，此时需要显式return返回。
func Add(x, y int) (z int) { 	{ 	z := x &#43; y //重新定义新的变量 	return z //因为有遮蔽作用，所有不可以直接使用隐式return，而需要显式的返回一个值，这相当于将新的z赋值给旧的z 	} 	return }  匿名函数 匿名函数如其名字一样，表示没有名字的函数。在定义匿名函数时，参数列表的第一对括号必须紧挨着关键字func，因为匿名函数没有名字，花括号{}涵盖着函数体，所以最后的一对圆括号()表示对该匿名函数的调用。
可以在函数内部定义匿名函数，形成类似嵌套的效果，①匿名函数可以直接调用;②或者保存到变量，作为参数或返回值。
func main() { 	func() { //匿名函数开始 	sum = 0.0 	for i := 1; i &amp;lt;= 1e6; i&#43;&#43; { 	sum &#43;= i 	} 	}() //表示调用 } 将匿名函数赋值给变量，与为普通函数提供名字标识符有着本质区别，编译器会为匿名函数生成一个随机符号名。
add := func(x, y int) int { 	return x &#43; y } println(add(23, 34)) 匿名函数可以作为参数。如下所示，相当于给匿名函数取了一个名字。
func add(f func()) { 	f() }  func main() { 	add(func() { 	println(&amp;#34;hello,world!&amp;#34;) 	}) } 在Go中不使用的匿名函数会被编译器当作错误。
在Go中普通函数和匿名函数都可作为结构体字段，或经通道传递，因为函数是一等公民。
 闭包 匿名函数同样被称之为闭包（函数式编程语言的术语）：它们被允许调用定义在其它环境下的变量。闭包可使得某个函数捕捉到一些外部状态，例如：函数被创建时的状态。另一种表示方式为：一个闭包继承了函数所声明时的作用域。这种状态（作用域内的变量）都被共享到闭包的环境中，因此这些变量可以在闭包中被操作，直到被销毁。
在Go中闭包函数保存并积累其中的变量的值，不管外部函数退出与否，它都能够继续操作外部函数中的局部变量。
func main() { 	var f = Adder() 	fmt.Print(f(1), &amp;#34; - &amp;#34;) 	fmt.Print(f(20), &amp;#34; - &amp;#34;) 	fmt.Print(f(300)) //输出结果为：1-21-321 }  func Adder() func(int) int { 	var x int 	return func(delta int) int { 	x &#43;= delta 	return x 	} } 在闭包中使用到的变量可以是在闭包函数体内声明的，也可以是在外部函数声明的：
var g int go func(i int) { 	s := 0 	for j := 0; j &amp;lt; i; j&#43;&#43; { 	s &#43;= j 	} 	g = s }(1000) // Passes argument 1000 to the function literal. 一个返回值为另一个函数的函数可以被称之为工厂函数，这在需要创建一系列相似的函数的时候非常有用：书写一个工厂函数而不是针对每种情况都书写一个函数。
可以返回其它函数的函数和接受其它函数作为参数的函数均被称之为高阶函数，是函数式语言的特点。
闭包只是在形式和表现上像函数，但实际上不是函数。函数是一些可执行的代码，这些代码在函数被定义后就确定了，不会在执行时发生变化，所以一个函数只有一个实例。
闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。
所谓引用环境是指在程序执行中的某个点所有处于活跃状态的约束所组成的集合。其中的约束是指一个变量的名字和其所代表的对象之间的联系。
那么为什么要把引用环境与函数组合起来呢？这主要是因为在支持嵌套作用域的语言中，有时不能简单直接地确定函数的引用环境。这样的语言一般具有这样的特性：
  函数是一阶值（First-class value），即函数可以作为另一个函数的返回值或参数，还可以作为一个变量的值。
  函数可以嵌套定义，即在一个函数内部可以定义另一个函数。
   延迟调用 语句defer向当前函数注册稍后执行函数调用，这些调用被称为延迟调用，因为它们直到函数执行结束前才被执行「遇到return或者panic也会触发延迟调用」。延迟调用常用于资源的释放，解除锁定，以及错误处理等操作。
  延迟调用注册时，必须提供执行所需参数(哪怕为空),参数值在注册时被拷贝缓存起来。
  多个延迟注册按照FILO(后进先出)次序执行。
  编译器通过插入额外指令来实现延迟调用执行，而return和panic语句会终止当前函数流程，引发延迟调用。
  在Go中，return语句不是ret汇编指令，它会先更新返回值。即Go中函数的return value不是原子操作，而是在编译器中分解为两部分：返回值赋值 和 return。而defer刚好被插入到末尾的return前执行。
func TestDefer() (z int) { 	defer func() { 	fmt.Println(&amp;#34;defer&amp;#34;, z) //100 	z &#43;= 100 	}() 	return 100 //先将100赋值给z，然后执行defer函数，最后返回200 } 相比于直接使用CALL指令调用函数，延迟调用则花费更大代价，包括注册、调用等操作，还有额外的缓存开销。
var m sync.Mutex  func call() { 	m.Lock() 	m.Unlock() } func deferCall() { 	m.Lock() 	defer m.Unlock() } func BenchmarkCall(b *testing.B) { 	for i := 0; i &amp;lt; b.N; i&#43;&#43; { 	call() 	} } func BenchmarkDefer(b *testing.B) { 	for i := 0; i &amp;lt; b.N; i&#43;&#43; { 	deferCall() 	} }  error 标准库将 error定义为接口类型，以便实现自定义错误类型。
type error inferface{  Error() string //只要实现了该方法，就认为是自定义的接口类型  } 按照惯例error总是最后一个返回参数，标准库提供了相关创建函数，可方便地创建包含简单错误文本的error对象
var errDivByZero = errors.New(&amp;#34;division by zero&amp;#34;)  func div(x,y int)(int, error){ 	if y ==0{ 	return 0,errDivByZero 	} 	return x/y,nil }  func TestDiv(){ 	z,err:= div(5,0) 	if err == errDivByZero{ 	log.Fatalln(err) 	} 	fmt.Println(z) } 如果要自定义错误类型，则只要实现Error方法就可以
type DivError struct { 	x,y int }  func(DivError) Error() string{ 	return &amp;#34;division by zero&amp;#34; }  func div1(x,y int)(int,error){ 	if y==0 { 	return 0,DivError{x,y} 	}  	return x/y,nil } 通常建议应该通过错误变量，而非错误文本内容来判定错误类型。
 panic和recover 与error相比，panic/recover在使用上更接近try/catch。它们是内置函数而非语句。panic会立即中断当前函数流程，执行延迟调用。而在延迟调用函数中，recover可捕获并返回panic提交的错误对象。
func panic(v interface{}) func recover() interface{} func TestPanic(){ 	defer func(){ 	if err:=recover();err !=nil{ 	log.Fatalln(err) 	} 	}()  	panic(&amp;#34;I am dead&amp;#34;) 	println(&amp;#34;exit&amp;#34;) //不会被执行 }   连续调用panic，仅最后一个panic会被recover捕获
  在延迟函数调用panic，不会影响后续延迟调用执行，而recover之后panic，可被再次捕获。
  recover必须在延迟调用函数中执行才能正常工作。
  除非是不可恢复性，导致系统无法正常工作错误，否则不建议使用panic。
  调试阶段，可使用runtime/debug.PrintStack函数输出完整调用堆栈信息。
   </content>
    </entry>
    
     <entry>
        <title>Go 表达式</title>
        <url>https://iihui.github.io/post/go-expression/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html"> 运算符 在Go中，一元运算符优先级最高，二元则分为5个级别，二元运算符遵循相同优先级从左到右依次计算，二元运算符从高到低的5个等级为：
* / % &amp;lt;&amp;lt; &amp;gt;&amp;gt; &amp;amp; &amp;amp;^
&#43; - | ^
== != &amp;lt; &amp;lt;= &amp;gt; &amp;gt;=
&amp;amp;&amp;amp;
||
二元运算符中除了移位操作外，操作数类型必须相同。如果其中一个是无显式类型声明的常量（该常量声明时，没有给出类型），那么该常量操作数会自动转型。
在Go中，位移右操作数必须是无符号整数，或可以转换的无显式类型常量（用整数字面值来定义常量时，未指定常量的类型）。
b := 23 x := 1 &amp;lt;&amp;lt; b // 错误，b的类型是int，使用简短模式声明的是变量 自增与自减「只有后置&#43;&#43;与后置--」不再是运算符，只能作为独立语句，不能用于表达式,也就是不能作为if中的condition，这与其他语言有很大的区别。
a := 1 //&#43;&#43;a //错误，只有后置&#43;&#43;与--  if a&#43;&#43; &amp;gt; 1{ //❌，不能作为表达式 } p := &amp;amp;a *p&#43;&#43; //优先级一样等价于(*p)&#43;&#43; 指针类型 指针类型支持相等运算符，但不支持做加减运算和类型转换。
指针没有专门指向成员的-&amp;gt; 运算符，统一使用.来选择表达式，编译器会自动做转换。
零长度对象的地址是否相等和具体的实现版本有关，但是绝对不等于nil。
var a, b struct{} print(&amp;amp;a, &amp;amp;b) //xc420039f56 0xc420039f56 fmt.Println(&amp;amp;a == &amp;amp;b, &amp;amp;a == nil) //true false 复合类型初始化 对复合类型（数组、切片、字典、结构体）变量初始化时，要遵循如下原则
  初始化表达式必须包含类型标签。
  左花括号必须在类型尾部，不能另起一行。
  多个成员初始值以逗号分隔。
  允许多行，但每行须以逗号或者右花括号结束。
  流控制 Go语言中仅支持三种控制语句，分别是if、switch、for。不同于其他语言，这3种控制语句中均可以有预处理语句「大多数情况下是变量定义」。
if 语句 if条件表达式可以省略括号「推荐的做法」；并且条件表达式的值必须是布尔类型；其中左括号不能另起一行。
x := 3 if x &amp;gt; 3 { 	fmt.Println(&amp;#34;A&amp;#34;) } else if x &amp;lt; 3 &amp;amp;&amp;amp; x &amp;gt; 0 { 	fmt.Println(&amp;#34;B&amp;#34;) } else { 	fmt.Println(&amp;#34;C&amp;#34;) } if中的条件判断语句之前：①允许声明一个变量；②执行函数调用。在预处理语句和条件语句间，它们使用分号分隔。如果是变量定义的话，这个变量的作用域只能在该条件逻辑块中，既包括if又包括else。
if a,b := x&#43;1,x&#43;10; a&amp;lt;b{  fmt.Println(a,b) }else { 	fmt.Println(&amp;#34;Test&amp;#34;) } 	if InitIF(); x &amp;lt; 10{ 	fmt.Println(&amp;#34;initif&amp;#34;) } func InitIF(){ 	fmt.Println(&amp;#34;Init&amp;#34;) } switch语句 一个case中可以有多个匹配条件，此时只要匹配其中一个就可以了。对于case是常量的情况，不能有重复的情况：
a, b, c, x := 1, 2, 3, 2 switch x { case a, b: 	fmt.Println(&amp;#34;a|b&amp;#34;) case c: 	fmt.Println(&amp;#34;c&amp;#34;) case 4: 	fmt.Println(&amp;#34;d&amp;#34;) default: 	fmt.Println(&amp;#34;z&amp;#34;) } switch中的条件表达式支持非常量值，这比C和C&#43;&#43;更灵活
switch支持初始化语句，按从上往下匹配，只有全部匹配失败时才执行default块,不会因为default语句在前面就先匹配default块。考虑到default的作用相当于else，所以建议将其放到末尾。
switch y := 5; y { default: 	y &#43;= 100 	fmt.Println(y) case 5: 	y &#43;= 50 	fmt.Println(y) } //55 不能出现重复的case常量值；相邻的空case不构成多条件匹配「这个与C和C&#43;&#43;有明显的区别」
无需显式执行break语句，case执行完毕后自动中断。
如需贯通后续case （按照源码顺序) 必须执行fallthrough,但不再匹配后续条件表达式，而且fallthrough必须放在case块末尾，可使用break语句阻止。
switch z := 20; z { default: 	fmt.Println(&amp;#34;default&amp;#34;) case 20: 	z &#43;= 10 	fmt.Println(z) 	fallthrough //必须是case语句块的最后一条语句 case 21: 	z &#43;= 88 	fmt.Println(z) } // 30 118  switch z := 20; z { case 20: 	z &#43;= 10 	fmt.Println(z) 	fallthrough //必须是case语句块的最后一条语句 case 21: 	z &#43;= 88 	fmt.Println(z) default: 	fmt.Println(&amp;#34;default&amp;#34;) } // 结果仍然是30 118 其中default语句不会执行 被省略条件表达式的switch，其表达式的默认值为true。这种情况，可以用来替换if语句
switch z1 := 5; { case z1 &amp;gt; 5: 	fmt.Println(&amp;#34;z1&amp;gt;5&amp;#34;) case z1 &amp;gt; 0 &amp;amp;&amp;amp; z1 &amp;lt;= 5: 	fmt.Println(&amp;#34;z1&amp;gt;0 &amp;amp;&amp;amp; z1&amp;lt;=5&amp;#34;) case z1 &amp;lt;= 0: 	fmt.Println(&amp;#34;z1&amp;lt;=&amp;#34;) default: 	fmt.Println(&amp;#34;Test&amp;#34;) } //z1&amp;gt;0 &amp;amp;&amp;amp; z1&amp;lt;=5 for语句 for语句，包括一般的for语句和 for range 语句。一般的for语句包括3种情况：①有初始化语句和条件判断语句的；②只有条件判断语句的；③既没有初始化语句也没有条件判断语句的。
for i := 1; i &amp;lt; 10; i&#43;&#43; { 	println(i) }  x1 := []int{12, 34, 78, 9, 22, 7, 9} //切片  for i, n := range x1 { 	println(i, &amp;#34;:&amp;#34;, n) } for x &amp;lt; 5 { 	println(x) 	x&#43;&#43; } for { 	println(x) 	x-- 	if x == 0 { 	break 	} } 初始化表达式支持函数调用或定义局部变量，其中初始化语句仅被执行一次，条件表达式如果有函数调用，须确认是否会被重复执行，可能会被编译器优化掉，也可能动态结果须每次执行确认。
func TestFor() { 	for i, c := 0, count(); i &amp;lt; c; i&#43;&#43; { 	println(&amp;#34;a&amp;#34;, i) 	}  	c := 0 	for c &amp;lt; count() { 	println(&amp;#34;b&amp;#34;, c) 	c&#43;&#43; 	} }  func count() int { 	print(&amp;#34;count.&amp;#34;) 	return 3 } 可用for ...range 完成数据迭代，支持字符串、数组、数组指针、切片、字典、通道类型，返回索引、键值数据。 range目标表达式是函数调用，也仅被执行一次。
data := [3]string{&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;} for i, s := range data { 	println(i, s)  } for i := range data { 	println(i, data[i]) } for _, s := range data { 	println(s) } for range data { //清空data } fmt.Println(data) break与continue break用于switch，for，select语句终止整个语句块执行
continue仅用于for循环，终止后续逻辑，立即进入下一轮
配合标签，break和continue可在多层嵌套中指定目录层级
outer: 	for x := 0; x &amp;lt; 10; x&#43;&#43; { 	for y := 0; y &amp;lt; 10; y&#43;&#43; { 	if y &amp;gt; 2 { 	println() 	continue outer 	} 	if x &amp;gt; 2 { 	break outer 	} 	println(x, y) 	} 	} </content>
    </entry>
    
     <entry>
        <title>Go 常量</title>
        <url>https://iihui.github.io/post/go-const/</url>
        <categories>
          <category>Go</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html">  常量是一种表达式，其可以保证在编译阶段计算出表达式的值，并不需要等到运行时，从而使编译器得以知晓其值。常量值必须是编译期可确定的字符、字符串、数字或布尔值。可指定常量类型，或由编译器通过初始值推断。
 特别说明 Go中常量可以是任意基本类型，也包括具名的基本类型(例如time.Duration)。但是许多常量并不从属某一具体类型。编译器将这些从属类型待定的常量表示成某些值，这些值比基本类型的数字精度更高，且算术精度高于原生的机器精度，可以认为它们的精度至少达到256位。
从属类型待定的常量共有6种，分别是：①无类型布尔；②无类型整数；③无类型文字符号(例如&#39;a&#39;)；④无类型浮点数；⑤无类型复数；⑥无类型字符串。
借助推迟确定从属类型，无类型常量不仅能够暂时维持更高的精度，与类型已确定的常量相比，还能写进更多的表达式无需类型转换。
在Go中只有常量才可以是无类型的。如果将无类型的常量声明为变量或者在类型明确的变量赋值的右方出现无类型的常量，则常量会被隐式转换为该变量的类型：
var f float64=3&#43;0i //无类型复数-&amp;gt;float64 f=2 //无类型整数-&amp;gt;float64 f=1e123 //无类型浮点数-&amp;gt;float64 f=&amp;#39;a&amp;#39; //无类型文字符号-&amp;gt;float64 不论隐式转换还是显式转换，常量从一种类型转换为另一种类型，都要求目标类型能够表示原值，实数和复数允许舍入取整。
const (  x =0xdeadbeef //无类型整数，值为3735928559  a = uint32(x) //unit32,值为3735928559没有超出范围  b = float32(x)//float32,值为3735928559  c = int32(x) //编译错误，溢出  d = float64(1e309) //编译错误，溢出  f = uint(-1) //编译错误，溢出，unit无法容纳-1  ) 变量声明时（包括简短声明）中，假如没有显式指定类型，无类型常量会隐式转换为该变量的默认类型。对于bool型来说为false，对于整型、浮点、复数来说为0，字符串为“”，引用类型为nil，复合类型为其基础类型的零值。
i:=0 //无类型整数，隐式int(0） r:=&amp;#39;\000&amp;#39; //无类型文字常量，隐式rune(&amp;#39;\000&amp;#39;)，这个要记住 f:=0.0 //无类型浮点数，隐式float64(0.0) c:=0i //无类型整数，隐式complex128(0i)  注意事项 常量必须是编译期可确定的字符、字符串、数字或布尔值。可指定常量类型，或由编译器通过初始化值推导，不支持C/C&#43;&#43;的数字类型后缀。
定义常量的时候必须初始化，否则编译错误。不同于未使用的局部变量，不使用的常量不会引起编译错误。
const x = 123 fmt.Println(x) const y = 1.23 { 	const x = &amp;#34;abc&amp;#34; 	fmt.Println(x) } 对于常量操作数，所有数学运算、逻辑运算和比较运算的结果依然是常量。常量的类型转换结果和某些内置函数的返回值，例如len,cap,real,imag,complex,unsafe.Sizeof同样是常量，因此可以将这些函数作用于常量用于常量的初始化。
在常量组中，如果不指定类型和初始化值，则与上一行非空常量右值（表达式文本）相同
const ( 	x uint16 = 120 	y 	s = &amp;#34;abc&amp;#34; 	z ) fmt.Println(x, y, s, z) //120,120,abc,abc 数字常量在预处理阶段直接展开，作为指令数据使用，不分配内存，因此无法获取地址
package main  const y = 0x200  func main() { 	println(y) 	//println(&amp;amp;y) // 错误，不能获取地址，这与C&#43;&#43;有很大的区别 } const t = y //同样无法获取t的地址 const x = 100 //x没有明确指定类型，也就是前面说的待定类型 const y byte = x //直接展开x，相当于const y byte = 100 如果显式指定类型，必须确定常量左右值类型一致，需要时可做显式转换，右值不能超出常量类型取值范围，否则会引起溢出错误。
const ( 	t1, t2 int = 99, -999 	t3 byte = byte(t1) //t1 指定为int型，需显式转换为byte类型，注意于上一个例子的区别 	//t4 = uint8(t2) // 常量-999,超出了unit8的范围，会报溢出错误 ) 常量值可以是某些编译器能计算出结果的表达式，如 unsafe.Sizeof、len、cap，不能是运行时才能计算出结果的表达式。因此len，cap等内置函数用于定义常量时，不能作用于变量。
const ( 	ptrSize = unsafe.Sizeof(uintptr(0)) //8 	strSize = len(&amp;#34;hello world!&amp;#34;) //12 	)  </content>
    </entry>
    
     <entry>
        <title>Go 基本类型</title>
        <url>https://iihui.github.io/post/go-type/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html"> Go语言中定义了清晰完备的预定义基本类型（共21类），使得开发跨平台应用时无须过多考虑符号和长度差异，具体如下表：
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-12-21 下午2.36.532.jpg)
 整型数据   十进制整数，使用0-9的数字表示且不以0开头。
  八进制整数，以0开头，0-7的数字表示。
  十六进制整数，以0X或者是0x开头0-9|A-F|a-f组成。
a,b,c:=100,0144,0x64 fmt.Println(a,b,c) //100 100 100 //打印的时候默认是10进制 fmt.Printf(&amp;#34;0b%b, %#o,%#x\n&amp;#34;,a,a,a) //0b1100100, 0144,0x64 //%#b可以打印二进制，但是为了区分在前面条件0b fmt.Printf(&amp;#34;0b%#b,0b%b&amp;#34;,a,a) fmt.Println(math.MinInt8,math.MaxInt8) //-128,127   标准库strconv可在不同进制（字符串）间转换。
x,_:=strconv.ParseInt(&amp;#34;1100100&amp;#34;,2,32) //解释给定字符，2表示字符串是的基数是2，即以2进制表示， //32表示给出的结果至少要适应32位，返回值的类型为int64 y,_:=strconv.ParseInt(&amp;#34;0144&amp;#34;,8,32) //字符串是8进制 z,_:=strconv.ParseInt(&amp;#34;64&amp;#34;,16,32) //字符串是16进制  fmt.Println(x,y,z) //100 100 100  fmt.Println(strconv.FormatInt(x,2)) //1100100,转换为2进制表示 fmt.Println(strconv.FormatInt(x,8)) //0144，转换为8进制表示 fmt.Println(strconv.FormatInt(x,16)) //64，转换为16进制表示   默认整数类型是int，不同类型之间的运算需要进行强制类型转换。
a : = 10 b ：= byte(100) //100的默认类型是int，如果要使得b的类型为byte，那么就要用强制类型转换 c := a &#43; int(b) //a 和 b是不同的数据类型，因此要转换成一致的数据类型    浮点型 浮点数由整数部分、小数点和小数部分组成，整数部分和小数部分可以隐藏其中一种。也可以使用科学计数法表示（把一个数表示成$a$（$1\le a \lt 10，n$为整数）与10的幂相乘的形式，这种记数法叫做科学记数法）。
     72.40 072.40 和 72.40一样，这里就不区分8进制与10进制，浮点数的数字就全部是10进制了 2.71823 6.67428e-11 1E6 //这个也是浮点数 .25 .12345E&#43;5  浮点数的默认类型是float64，使用时需要注意小数点的位置。float32保证7位有效数字「小数点后7位」，float64保证15位有效数字「小数点后15位」。具体细节参见IEEE-754标准。
var a float32 = 1.1234567899 //保证小数点后7位有效数字 var b float32 = 1.12345678 //保证小数点后7位有效数字 var c float32 = 1.123456781 //保证小数点后7位有效数字  fmt.Println(a, b, c) // 1.1234568 1.1234568 1.1234568 fmt.Println(a == b, b == c) //true true 因为保证7位有效数字—小数点后7位 fmt.Printf(&amp;#34;%v %v %v\n&amp;#34;, a, b, c) //1.1234568 1.1234568 1.1234568  复数类型 由一个整数或者是一个小数加上i表示，在Go中它的默认类型是complex128即64位实部分&#43;64位虚部，虚部如下所示：
 0i 011i //==11i 这里不是八进制了，和浮点数一样，数字均表示10进制 0.i 2.71825i 6.23423-11i 1E&#43;6i .25i .1234E&#43;5i   引用 特指slice，map，channel这三种预定义类型，引用类型具有更复杂的存储结构，除分配内存外，还必须初始化一系列属性，诸如指针、长度、甚至包括哈希分布，数据队列等。
内置函数new按指定类型长度分配零值内存，返回指针，并不关心类型内部构造和初始化方式。而引用类型必须使用make函数创建，编译器会将make转换为目标类型专用的创建函数（指令）以确保完成全部内存分配和相关属性初始化。
m := make(map[string]int) m[&amp;#34;a&amp;#34;] = 1 fmt.Println(m) //map[a:1] s := make([]int, 0, 10) s = append(s, 100) fmt.Println(s) //[100] new函数也可以为引用类型分配内存，但是不完整创建。 以字典为例，它仅分配了字典本身所需的内存，并没有分配键值存储内存，也没有初始化散列桶等内部属性，因此无法正常工作
p := new(map[string]int) t := *p //t[&amp;#34;a&amp;#34;] = 100 //fmt.Println(t) //panic: assignment to entry in nil map  别名 在官方文档中，专门提到了两个别名 byte alias for unit8以及rune alias for int32
  别名类型无需转换，可直接赋值。别名的作用是为了“见型知意”
  拥有相同底层结构的就不一定是别名，就算在64位平台上int和int64结构完全一致，但是这两个也分属不同类型，这两个类型参与运算时须显式转换。
   未命名类型（8种） 在Go中 数组、切片、字典、通道类型与具体元素类型或长度属性相关，故被称为未命名类型。具有相同声明的未命名类型被称为同一类型。
  具有相同基类型的指针
  具有相同元素类型和长度的数组array
  具有相同元素类型的切片slice
  具有相同键值类型的字典map
  具有相同数据类型以及操作方向的通道channel
  具有相同字段序列（字段名、字段类型、标签以及字段顺序）的结构体struct
  具有相同签名的（参数和返回值列表，不包括参数名）的函数func，其中函数的参数顺序也属于签名的组成部分
  具有相同方法集（方法名，方法签名，不包括顺序）的接口
  容易被忽略的是结构体的标签struct tag 它属于类型组成的一部分，而不仅仅是元数据描述
var a struct { 	x int `x` 	s string `s` }  var b struct { 	x int 	s string }  b = a //这是错误的，因为一个有标签，另一个没有标签 fmt.Println(b)  指针 指针的默认值是nil，不支持加减操作和类型转换，只支持相等判断,这一点与C和C&#43;&#43;有很大区别
x := 100 p := &amp;amp;x //p&#43;&#43; //不能加 //p&#43;1 //不能加，只能比较是否相等 var p2 = p fmt.Println(p2 == p) //true 在指针的比较中，如果两个指针指向同一个地址，或都为nil则相等
 接口 接口定义了一个函数集合，但是这些方法不包括实现——它们是抽象的，接口里也不能含变量。
 自定义类型 使用关键字type 定义用户自定义类型，包括基于现有基础类型创建，或者是结构体、函数类型。与const和 var类似，多个type定义可以合并为组，可在函数或者代码块内定义局部类型
type ( 	user struct { 	name string 	age uint8 	} 	event func(string) bool ) 当自定义类型指定了基础类型时，也只表明他们具有相同的底层数据结构，两者间不存在任何关系，属于完全不同的两种类型，不能直接进行赋值操作。
除了操作符外，自定义类型不会继承基础类型的其他信息（包括方法），不能视作别名，不能隐式转换，不能直接用于比较表达式。
type X int var m X = 23  if m &amp;lt; 100 { //继承操作符 	fmt.Println(&amp;#34;Test&amp;#34;) }  类型转换 因为隐式转换带来的问题远大于它带来的好处，Go中严格按照类型进行操作。当两个变量的类型不一致的时候要做强制类型转换。
  除了常量、别名类型以及未命名类型外，Go强制要求使用显式类型转换
  Go中不支持操作符重载
  如果转换的目标类型是指针、单向通道或没有返回值的函数类型，那么必须用括号，以避免造成语法分解错误
x := 100 p := (*int)(&amp;amp;x)    </content>
    </entry>
    
     <entry>
        <title>memcpy 的实现</title>
        <url>https://iihui.github.io/post/cpp-memcpy/</url>
        <categories>
          
        </categories>
        <tags>
          <tag>C&#43;&#43;</tag>
        </tags>
        <content type="html"> 地址重叠 void *memcpy(void *dst, const void *src, size_t n); //If copying takes place between objects that overlap, the behavior is undefined.   注意注释，对于地址重叠的情况，该函数的行为是未定义的。事实上所说的陷阱也在于此，自己动手实现memcpy时就需要考虑地址重叠的情况。
  另外，标准库也提供了地址重叠时的内存拷贝函数：memmove，那么为什么还要考虑重写memcpy函数呢?
  因为memmove函数的实现效率问题，该函数把源字符串拷贝到临时buffer里，然后再从临时buffer里写到目的地址，增加了一次不必要的开销。
  自实现版本 当可能会发生重叠时，应该从后往前拷贝，类似于vector的插入时当插入点的元素大于要插入的元素个数时。
#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;string.h&amp;gt; void *Memcpy(void *dst, const void *src, size_t size);  int main(int argc, char *argv[]) {  char buf[100] = &amp;#34;abcdefghijk&amp;#34;;  // memcpy(buf&#43;2, buf, 5);  Memcpy(buf &#43; 2, buf, 5);  printf(&amp;#34;%s\n&amp;#34;, buf &#43; 2); }  void *Memcpy(void *dst, const void *src, size_t size) {  char *psrc;  char *pdst;   if (NULL == dst || NULL == src) {  return NULL;  }   if ((src &amp;lt; dst) &amp;amp;&amp;amp; (char *)src &#43; size &amp;gt; (char *)dst) // 自后向前拷贝  {  psrc = (char *)src &#43; size - 1;  pdst = (char *)dst &#43; size - 1;  while (size--) {  *pdst-- = *psrc--;  }  } else {  psrc = (char *)src;  pdst = (char *)dst;  while (size--) {  *pdst&#43;&#43; = *psrc&#43;&#43;;  }  }   return dst; }  </content>
    </entry>
    
     <entry>
        <title>基本排序算法</title>
        <url>https://iihui.github.io/post/arith-sort/</url>
        <categories>
          <category>算法</category>
        </categories>
        <tags>
          <tag>算法</tag>
        </tags>
        <content type="html"> 基本概念   排序算法的稳定性：如果待排序的数据中，存在多个关键字相同的元素，经过排序后这些相同关键字的元素之间的相对次序保持不变，则称这种排序算法是稳定的，反之则为不稳定。
  内排序：排序过程中，整个表都是放在内存中处理，排序时不涉及数据的内、外交换。
  外排序：指能够处理极大量数据的排序算法，外排序处理的数据不能一次装入内存，只能放在读写较慢的外存储器(通常是硬盘)上。外排序通常采用的是一种 排序-归并 的策略，在排序阶段，先读入能放在内存中的数据量，将其排序结果输出到一个临时文件，依此进行，将待排序数据组织为多个有序的临时文件。然后在归并阶段将这些临时文件组合为一个大的有序文件，即排序结果。
   内排序算法 一般说来，内排序算法可以分为7类，分别为：
  插入排序
  交换排序
  选择排序
  归并排序
  基数排序
  桶排序
  计数排序
   插入类排序 直接插入排序 直接插入排序，是在有序的基础上对数据元素进行直接插入，代码如下所示：
template&amp;lt;typename T&amp;gt; void innerSort&amp;lt;T&amp;gt;::insertSort(T *data, int length) {  assert(length &amp;gt;= 0);  int curItem, j;  for (int i = 1; i &amp;lt; length; &#43;&#43;i) {  curItem = data[i];  for (j = i - 1; j &amp;gt;= 0; --j) {  if (curItem &amp;lt; data[j]) {  data[j &#43; 1] = data[j];  } else {  break;  }  }  data[j &#43; 1] = curItem; //j&#43;1是最终位置  } }   最好情况为待排序序列是正序的时候，比较次数为$(n-1)$次，移动次数$2(n-1)$次，时间复杂度：$O(n)$。
  最坏情况为待排序序列是逆序的时候，比较次数 $（1&#43;2&#43;3&#43;&amp;hellip;&#43;(n-1))=\frac{n(n-1)}{2}$，移动次数 $(1&#43;2&#43;&amp;hellip;&#43;(n&#43;1))=\frac{n(n&#43;1)}{2}$，时间复杂度：$O(n^2)$。
  平均时间复杂度：$O(n^2)$。
  空间复杂度：$O(1)$。
  直接插入排序不能保证一趟之后有一个元素在其最终的位置。
  直接插入是稳定的排序算法。
   折半插入排序 折半插入排序，在查找插入位置的时候使用二分查找，代码如下：
template&amp;lt;typename T&amp;gt; void innerSort&amp;lt;T&amp;gt;::binInsertSort(T *data, int length) {  assert(length &amp;gt;= 0);  int start, mid, end, curItem;  for (int i = 1; i &amp;lt; length; &#43;&#43;i) {  start = 0;  end = i - 1;  curItem = data[i];  while (start &amp;lt;= end) {  mid = start &#43; (end - start) / 2; //尽可能地避免溢出  if (data[mid] == curItem) {  end = mid; //end&#43;1便是插入位置  break;  } else if (data[mid] &amp;lt; curItem) {  start = mid &#43; 1;  } else {  end = mid - 1;  }  }  //最终的插入位置为end&#43;1,因此需要将end&#43;1所在的元素移开  for (int j = i - 1; j &amp;gt;= end &#43; 1; --j) {  data[j &#43; 1] = data[j];  }  //放到最终的插入位置 end&#43;1  data[end &#43; 1] = curItem;  } }   注意后面的第二个for循环中j &amp;gt;= end &#43; 1，因为最终位置是end&#43;1。
  从时间上看，折半插入排序只是减少了关键字间的比较次数，而元素的移动次数不变，因为找到位置之后还是要将元素全部移动，因此平均时间复杂度为$O(n^2)$。
  空间复杂度：$O(1)$，折半插入排序算法不稳定的的内排序算法，例如1，1，1，1进行折半插入排序时。
   Shell排序 Shell排序，又称为缩小增量排序方法。其基本思想是：把记录按下标的某个增量 $d$ 分组，对每组记录采用直接插入排序方法进行排序，随着增量逐渐缩小，所分成的组所包含的记录越来越多，到增量的值减少到$1$时，整个数据合成为一组，构成一组有序记录，则完成排序。
  先取一个正整数 $d_1(d_1 \lt n)$，把全部记录分成 $d_1$ 个组，所有距离为 $d_1$ 的倍数的记录看成一组，然后在各组内进行插入排序。
  然后取 $d_2(d_2 \lt d_1)$重复上述分组和排序操作；直到取 $d_i = 1(i \ge 1)$ 位置，即所有记录成为一个组，最后对这个组进行插入排序。一般选$d_1$约为$\frac{n}{2}$，$d_2$为$\frac{d_1}{2}$， $d_3$ 为 $\frac{d_2}{2}$ ，&amp;hellip;， $d_i = 1$。
  template&amp;lt;typename T&amp;gt; void innerSort&amp;lt;T&amp;gt;::shellSort(T *data, int length) {  assert(length &amp;gt;= 0);  for (int step = length / 2; step &amp;gt; 0; step /= 2) {  assistShellSort(data, length, step);  } }  template&amp;lt;typename T&amp;gt; void innerSort&amp;lt;T&amp;gt;::assistShellSort(T *data, int length, int step) {  assert(length &amp;gt;= 1 &amp;amp;&amp;amp; step &amp;gt;= 0);  int j, curItem;  for (int i = step; i &amp;lt; length; &#43;&#43;i) {  curItem = data[i];  for (j = i - step; j &amp;gt;= 0; j -= step) {  if (data[j] &amp;gt; curItem) {  data[j &#43; step] = data[j];  } else {  break;  }  }  data[j &#43; step] = curItem; //j&#43;step是最终的位置  } }   Shell排序的每趟排序，都会使得整个序列变得更加有序，等整个序列基本有序了，再来一趟直接插入排序，这样会使排序效率更高。
  Shell排序不能保证一趟之后有一个元素在其最终的位置。
  Shell排序是不稳定的排序算法，例如2,2,1(d=2,1)。
  分析Shell排序是一个复杂的问题，它的时间复杂度是增量序列的函数，到现在为止还未得到数学上的解决。
   交换类排序 大数沉底冒泡 大数沉底的冒泡排序的基本流程如下：
  比较相邻的元素，如果第一个比第二个大，就交换他们两个。
  对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对，当交换到最后的时候，最后的一个元素将会是最大的数。
  除了已经找到的元素，针对所有剩下的元素重复以上的步骤。
  持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
  //大数沉底的冒泡排序 template&amp;lt;typename T&amp;gt; void innerSort&amp;lt;T&amp;gt;::bubbleSort(T *data, int length) {  assert(length &amp;gt;= 0);  bool flag; //标识本趟是否有交换  for (int i = 1; i &amp;lt; length; &#43;&#43;i) {  flag = false; //赋值为false表示还没有数据交换  for (int j = 0; j &amp;lt; length - i; &#43;&#43;j) {  if (data[j] &amp;gt; data[j &#43; 1]) {  swap(data[j], data[j &#43; 1]);  flag = true; //本论循环中有数据元素进行交换  }  }  if (!flag) {  break; //本次循环已经没有数据元素进行交换，说明已经排好序  }  } }  小数沉底冒泡 如果要将原序列排序成逆序，则只要将小数沉底即可，即每次比较的时候当前元素比下一个元素小的时候将将其交换到后面。
void smallBubbleSort(int *data, int n) //小数下沉，最后得到逆序 {  bool flag = false;   for (int i = 1; i &amp;lt; n; &#43;&#43;i) {  flag = false;  for (int j = 0; j &amp;lt; n - i; &#43;&#43;j) {  if (data[j] &amp;lt; data[j &#43; 1]) {  std::swap(data[j], data[j &#43; 1]);  flag = true;  }  }   if (!flag)  break;  } }   最坏情况：待排序序列逆序，时间复杂度为$O(n^2)$。
  最好情况：待排序序列有序，时间复杂度为$O(n)$。
  平均时间复杂度为：$O(n^2)$。
  空间复杂度为$O(1)$。
  每次都能保证一个元素在最终位置。
  冒泡排序是稳定的排序算法。
   快速排序 快速排序: 它采用了一种分治的策略，将原问题分解为若干个规模更小但结构与原问题相似的子问题,然后递归地解这些子问题。最后将这些子问题的解组合为原问题的解。快速排序算法的步骤为：
  首先，在数据集之中，选择一个元素作为基准（pivot）, 基准的选择一般有3种
  随机选择数据元素作为基准元素
  选择中间的那个数据元素作为基准元素
  选择待排序序列的第一个元素作为基准元素
    其次，所有小于基准的元素，都移到基准的左边；所有大于基准的元素，都移到基准的右边。
  最后，基准左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。
  假设数据集为{85, 24, 63, 45, 17, 31, 96, 50}，怎么对其进行排序呢？下面采用每次选择中间的那个元素作为基准元素：
  第一步，选择中间的元素45作为基准pivot。
  第二步，按照顺序将每个元素和pivot进行比较，形成两个子集，一个小于pivot，一个大于pivot：{24，17，31}，45，{85，63，96，50}。
  第三步，对两个子集不断重复第一步和第二步，直到所有子集只剩下一个元素。17，{24，31}，45，{50}，63，{85，96}。17，24，{31}，45，50，63，85，{96}。最后得到：17，24，31，45，50，63，85，96。
  第二种方式是每次选择第一个元素作为基准的算法：
void quickHelp(int *data, int start, int end) {  if (start &amp;lt; end) {  auto pivot = adjustByFirst(data, start, end);  quickHelp(data, start, pivot - 1);  quickHelp(data, pivot &#43; 1, end);  } }  int adjustByFirst(int *data, int start, int end) {  int cur = data[start];  int i = start, j = end;  while (i &amp;lt; j) {  while (i &amp;lt; j &amp;amp;&amp;amp; data[j] &amp;gt;= cur) j--;  if (i &amp;lt; j) {  data[i] = data[j];  i&#43;&#43;:  }  while (i &amp;lt; j &amp;amp;&amp;amp; data[j] &amp;lt; cur) j--;  if (i &amp;lt; j) {  data[j] = data[i];  j--:  }  }  data[i] = cur;  return i; } 借助于栈，可以将上面的递归算法改为非递归算法：
struct Region {  int start;  int high; }; void noncurQuickSort(int *data, int length) {  Region cur, left, right;  Region stack[MAXSIZE];  int index;  int top = -1;  cur.start = 0;  cur.high = length - 1;   stack[top&#43;&#43;] = cur;   while (top != -1) {  cur = stack[top--];  index = partition(data, length, cur.start, cur.high); //调用随机选择基准的函数   if (index &amp;gt; cur.start) {  left.start = cur.start;  left.high = index - 1;  stack[&#43;&#43;top] = left;  }  if (index &amp;lt; cur.high) {  right.start = index &#43; 1;  right.high = cur.high;  stack[&#43;&#43;top] = right;  }  } } 第三个种方式是随机选择一个元素作为基准进行调整算法：
template&amp;lt;typename T&amp;gt; void innerSort&amp;lt;T&amp;gt;::quickSort(T *data, int length) {  quickSort(data, 0, length - 1); }  template&amp;lt;typename T&amp;gt; void innerSort&amp;lt;T&amp;gt;::quickSort(T *data, int start, int end) {  if (start &amp;gt;= 0 &amp;amp;&amp;amp; start &amp;lt; end) {  int pivot = getPivot(data, start, end);  if (pivot &amp;gt; start) {  quickSort(data, start, pivot - 1);  }   if (end &amp;gt; pivot) {  quickSort(data, pivot &#43; 1, end);  }  } }  template&amp;lt;typename T&amp;gt; int innerSort&amp;lt;T&amp;gt;::getPivot(T *data, int start, int end) {  assert(start &amp;gt;= 0 &amp;amp;&amp;amp; start &amp;lt; end);   int index = random(start, end);  int small = start - 1;  swap(data[index], data[end]);   for (int i = start; i &amp;lt; end; &#43;&#43;i) {  if (data[i] &amp;lt; data[end]) {  &#43;&#43;small;  if (small != i) {  swap(data[small], data[i]);  }  }  }  &#43;&#43;small;  swap(data[small], data[end]);  return small; }  //http://notes.maxwi.com/2016/04/10/cpp-random/ //https://www.cnblogs.com/byhj/p/4149467.html template&amp;lt;typename T&amp;gt; int innerSort&amp;lt;T&amp;gt;::random(int start, int end) { // static std::default_random_engine e; // static std::uniform_int_distribution&amp;lt;unsigned&amp;gt; u(start, end); // int result = u(e);  srand(time(0));  int result = std::rand() % (end - start &#43; 1) &#43; start;  return result; } 上面这种方法应该注意后面是small&#43;&#43;之后再交换，想象一下全部有序就能理解了😂。
  快速排序最好情况下的时间复杂度为$O(nlog_2n)$。
  最坏情况下的时间复杂度为$O(n^2)$。
  平均时间复杂度为$O(nlog_2n)$,就平均而言快速排序是所有排序算法中效果最好的, 这是快排的名字的由来。
  待排序序列越接近无序，算法效率越高，个人理解应该是无序的时候基点两边平衡的比较好，所以效率比较高,这是针对于以第一个元素为pivot的情况。
  待排序序列越接近有序，算法效率越低（快速排序反而蜕化为冒泡排序？）。
  快速排序的趟数和初始序列相关。
  是不稳定的排序算法2，2，1 。
  空间复杂度为$O(log_2n)$。
   选择类排序 简单选择排序 简单选择排序：每一趟在$n-i(i=1,2,&amp;hellip;,n-1)$个数据元素中$R[i],R[i&#43;1],&amp;hellip;,R[n-1]$中选择最小的数据元素作为有序序列中第$i$个数据元素。
template&amp;lt;typename T&amp;gt; void innerSort&amp;lt;T&amp;gt;::selectSort(T *data, int length) {  assert(length &amp;gt;= 0);  int index;  //从0开始便于index的取值，因为数组下标是从0开始的  for (int i = 0; i &amp;lt; length - 1; &#43;&#43;i) {  index = i;  for (int j = i &#43; 1; j &amp;lt; length; &#43;&#43;j) {  if (data[index] &amp;gt; data[j]) {  index = j;  }  }  if (index != i) {  std::swap(data[index], data[i]);  }  } }   是不稳定的排序算法，例如2，2，1。
  时间复杂度为$O(n^2)$。
  空间复杂度为$O(1)$。
   堆排序 可以把堆看成一棵完全二叉树，满足：任何一个非叶子节点的值都不大于(或不小于）其左右孩子节点的值，若父亲大孩子小，则这样的堆叫做大顶堆，若父亲小孩子大，则这样的堆叫做小顶堆。
根据堆的定义，代表堆的这棵完全二叉树的根节点的值是最大的或者最小的，因此将一个无序的序列调整为一个堆，就可以找出这个序列的最大（最小）值，然后将找出的这个值交换到序列的最后（或最前），这样有序序列元素增加1个，无序序列中元素减少1个，对新的无序序列重复这样的操作就可以实现排序。
template&amp;lt;typename T&amp;gt; void innerSort&amp;lt;T&amp;gt;::heapSort(T *data, int length) {  assert(length &amp;gt;= 0);  //首先从(length-2)/2开始调整，让他成为大顶堆  //当数组下标是从0开始的时候i的初始值就为(length-2)/2，下标为1开始时为(length-1)/2  for (int i = (length - 2) / 2; i &amp;gt;= 0; --i) {  assistHeapSort(data, i, length - 1);  }   for (int j = length - 1; j &amp;gt;= 1; --j) {  std::swap(data[0], data[j]);  assistHeapSort(data, 0, j - 1);  } }  //构建大顶堆,堆顶元素data[start] template&amp;lt;typename T&amp;gt; void innerSort&amp;lt;T&amp;gt;::assistHeapSort(T *data, int start, int end) {  assert(start &amp;lt;= end &amp;amp;&amp;amp; start &amp;gt;= 0);  int parent = start, child = 2 * start &#43; 1;  while (child &amp;lt;= end) {  //注意控制条件是child &amp;lt; end，不越界  if (child &amp;lt; end &amp;amp;&amp;amp; data[child] &amp;lt; data[child &#43; 1]) {  child&#43;&#43;;  }   if (data[parent] &amp;lt; data[child]) {  std::swap(data[parent], data[child]);  }  parent = child;  child = 2 * parent &#43; 1;  } }   平均时间复杂度为$O(nlog_2(n))$。
  最坏情况下的时间复杂度也为$O(nlog_2(n))$。
  其空间复杂度为$O(1)$,空间复杂度是指占用内存大小，每次调用完调整堆的的函数后，所占用的那一个空间都会被释放，不想快速排序那样未排完之前是不会释放辅助空间的。
  适用于记录数较多的情况。
  是不稳定排序方法，例如使用2,2,1构造小顶堆时。
   归并排序 二路归并排序：将两个有序的子序列合并成一个新的有序子序列。归并的思想：将序列看成是$n$个有序子序列，每个序列的长度为$1$,然后两两归并，得到$⌈\frac{n}{2}⌉$个长度为$2$,的有序子序列，然后两两归并&amp;hellip;，如此重复，直到得到一个长度为 $n$ 的有序子序列。
void mergeSort(int *data, int length) {  assert(length &amp;gt;= 0 || data != nullptr);   auto *copy = new int[length];   /* for (int i = 0; i &amp;lt; length; &#43;&#43;i) { copy[i] = data[i]; }*/   mergeSort(data, copy, 0, length - 1);  delete[] copy; }  void mergeSort(int *data, int *copy, int start, int end) {  if (start == end) {  copy[start] = data[start];  return;  }  int length = (end - start) / 2;  mergeSort(data, copy, start, start &#43; length);  mergeSort(data, copy, start &#43; length &#43; 1, end);   int i = start, j = start &#43; length &#43; 1, k = start;   while (i &amp;lt;= start &#43; length &amp;amp;&amp;amp; j &amp;lt;= end) {  if (data[i] &amp;lt; data[j])  copy[k&#43;&#43;] = data[i&#43;&#43;];  else  copy[k&#43;&#43;] = data[j&#43;&#43;];  }   while (i &amp;lt;= start &#43; length)  copy[k&#43;&#43;] = data[i&#43;&#43;];   while (j &amp;lt;= end)  copy[k&#43;&#43;] = data[j&#43;&#43;];   for (i = start; i &amp;lt;= end; &#43;&#43;i) {  data[i] = copy[i];  } } template&amp;lt;typename T&amp;gt; void innerSort&amp;lt;T&amp;gt;::mergeSort(T *data, int length) {  assert(length &amp;gt;= 0);  int *assist = new int[length];  memcpy(assist, data, length * sizeof(int));  assistMergeSort(data, assist, 0, length - 1);  delete[] assist; }  template&amp;lt;typename T&amp;gt; void innerSort&amp;lt;T&amp;gt;::assistMergeSort(T *data, T *assist, int start, int end) {  if (start &amp;lt; end) {  int mid = start &#43; (end - start) / 2;  assistMergeSort(data, assist, start, mid);  assistMergeSort(data, assist, mid &#43; 1, end);   int i = start, j = mid &#43; 1, k = start;   while (i &amp;lt;= mid &amp;amp;&amp;amp; j &amp;lt;= end) {  if (data[i] &amp;lt;= data[j]) {  assist[k&#43;&#43;] = data[i&#43;&#43;];  } else {  assist[k&#43;&#43;] = data[j&#43;&#43;];  }  }  while (i &amp;lt;= mid) {  assist[k&#43;&#43;] = data[i&#43;&#43;];  }  while (j &amp;lt;= end) {  assist[k&#43;&#43;] = data[j&#43;&#43;];  }   for (int l = start; l &amp;lt;= end; &#43;&#43;l) {  data[l] = assist[l];  }  } }   排序时间代价不依赖于待排序数组的初始情况。
  在最好，最坏，平均时间复杂度都为$O(nlog_2n)$ 。
  空间复杂度为$O(n)
  稳定的排序方法。
  在平均情况下还是快速排序最快（常数因子更小）。
   比较排序的最优下界 比较排序算法小结 计数排序 计数排序是一种稳定的线性时间排序算法。计数排序使用一个额外的数组count，其中第i个元素是待排序数组A中值等于i的元素的个数。
然后根据数组count来将A中的元素排到正确的位置。当输入的元素是n个0到k之间的整数时，它的运行时间是$Θ(n &#43; k)$。
计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组count的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量内存。
template&amp;lt;typename T&amp;gt; void innerSort&amp;lt;T&amp;gt;::countSort(T *data, int length) {  assert(length &amp;gt;= 0);  int min = data[0], max = data[0];   int *assistArr = new int[length]{0};  int inc = 0;   //先找出最大值和最小值  for (int i = 0; i &amp;lt; length; &#43;&#43;i) {  assert(data[i] &amp;gt;= 0);  if (data[i] &amp;gt; max) {  max = data[i];  }   if (data[i] &amp;lt; min) {  min = data[i];  }  }  if (min &amp;lt; 0) {  inc = abs(min);  }  for (int i = 0; i &amp;lt; length; &#43;&#43;i) {  data[i] &#43;= inc;  }  int countLength = (max &#43; inc &#43; 1);  int *countArr = new int[countLength]{0};   for (int i = 0; i &amp;lt; length; &#43;&#43;i) {  countArr[data[i]]&#43;&#43;;  }   //注意是计数数组的上界限  for (int j = 1; j &amp;lt; countLength; &#43;&#43;j) {  countArr[j] &#43;= countArr[j - 1];  }   for (int k = length - 1; k &amp;gt;= 0; --k) {  assistArr[--countArr[data[k]]] = data[k];  }   for (int i = 0; i &amp;lt; length; &#43;&#43;i) {  data[i] = assistArr[i] - inc;  }  delete[] assistArr;  delete[] countArr; } 桶排序 桶排序(Bucket Sort)的基本思路是：
  将待排序元素划分到不同的桶。先扫描一遍序列求出最大值$max$和最小值$min$，设桶的个数为$k$，则把区间$[min, max]$均匀划分成$k$个区间，每个区间就是一个桶。将序列中的元素分配到各自的桶。
  对每个桶内的元素进行排序。可以选择任意一种排序算法。
  将各个桶中的元素合并成一个大的有序序列。
  复杂度分析：
  假设数据是均匀分布的，则每个桶的元素平均个数为$\frac{n}{k}$。
  假设选择用快速排序对每个桶内的元素进行排序，那么每次排序的时间复杂度为$O(\frac{n}{k}log(\frac{n}{k}))$。
  $O(n)&#43;O(m)O(\frac{n}{k}log(\frac{n}{k}))=O(n&#43;nlog(\frac{n}{k}))=O(n&#43;nlogn-nlogk)$为总的时间复杂度。当$k$接近于 $n$时，桶排序的时间复杂度就可以近似认为是$O(n)$ , 此时近似为计数排序。即桶越多，时间效率就越高，而桶越多，空间就越大。
   基数排序 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。
基数排序法会使用到桶，先进先出的队列，通过将要比较的位（个位、十位、百位…），将要排序的元素分配至$0 \to 9$ 个桶中，借以达到排序的作用，在某些时候，基数排序法的效率高于其它的比较性排序算法。
void radixSort(int *data, int length) {  int max = getMax(data, length); //找出待排序数组中最大的那个数  int radix = 10;   for (int exp = 1; exp &amp;lt;= max; exp *= 10) {  bucketSort(data, length, exp, radix);  } }  void bucketSort(int *data, int length, int exp, int radix) {  auto *count = new int[radix]{0};  auto *result = new int[length];   for (int i = 0; i &amp;lt; length; &#43;&#43;i) {  count[(data[i] / exp) % radix]&#43;&#43;; //(data[i] / exp) 获取当前位的数值  }   for (int j = 1; j &amp;lt; radix; &#43;&#43;j) {  count[j] &#43;= count[j - 1];  }   for (int i = length - 1; i &amp;gt;= 0; --i) {  result[--count[(data[i] / exp) % radix]] = data[i];  }   for (int i = 0; i &amp;lt; length; &#43;&#43;i) {  data[i] = result[i];  }  delete[] result;  delete[] count; }   是稳定的排序方法。
  时间复杂度：设数组长度为$n$,基数为$r$,关键字位数为$d$,则每趟分配的时间为$O(n)$，每趟收集的时间复杂度为$O(n)$，工序$d$趟分配与收集，所以时间复杂度为$O(d(2n))$,即$O(d \times n)$。
  空间复杂度为$O(rn)$。
   外排序算法 所谓外排序，顾名思义，即排序涉及到内存外面的排序。因为当要处理的数据量很大，而不能一次装入内存时，此时只能放在读写较慢的外存储器（通常是硬盘）上。外排序通常采用的是一种排序-归并的策略。
  在排序阶段，先读入能放在内存中的数据量，将其排序输出到一个临时文件，依此进行，将待排序数据组织为多个有序的临时文件；
  在归并阶段将这些临时文件组合为一个大的有序文件，即排序结果。
  例子1 假定现在有20个数据的文件A：{5，11， 0， 18， 4， 14， 9， 7 6， 8， 12， 17 ，16 ，13 ，19 ，10， 2， 1， 3， 15}，但内存一次只能装4个数据，所以，可以每趟先选择4个数据进行排序，然后将排好序的5路数据进行归并，具体步骤如下：
  首先把大文件$A$，按顺序分割为$a_1，a_2，a_3，a_4，a_5$等5个小文件，每个小文件4个数据。
  $a_1$文件为：5,11, 0,18。
  $a_2$文件为：4,14,9,7。
  $a_3$文件为：6, 8, 12, 17。
  $a_4$文件为：16,13, 19,10。
  $a_5$文件为：2,1,3,15然后依次对5个小文件分别进行排序。
  $a_1$文件完成排序后：0,5,11,18。
  $a_2$文件完成排序后：4,7,9,14。
  $a_3$文件完成排序后：6,8,12,17。
  $a_4$文件完成排序后：10,13,16,19。
  $a_5$文件完成排序后：1,2,3,15。
  最后进行5路归并，完成排序：0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19。
   例子2 要对900MB的数据进行排序，但机器上只有100MB的可用内存时，外部归并排序按如下方法操作：
  读入100MB的数据至内存中，用某种常规排序（如：快速排序、堆排序、归并排序等）在内存中完成排序。
  将排序完成的数据写入磁盘（临时文件）。
  重复步骤1和步骤2直到所有的数据都存入了不同的100MB的块（临时文件）中。本例中，900MB数据，100MB内存，故产生了9个临时文件。
  读入每个临时文件（顺串）的前10MB($10=\frac{100}{9&#43;1}$)，在进行多路归并的时候，这里有9路，然后输出缓冲算一个，所以要将内存资源分给10个部分)的数据放入内存中的输入缓冲区（总计90MB），最后的10MB作为输出缓冲区。（实践中，将输入缓冲适当调小，而适当增大输出缓冲区能获得比较好的效果）
  执行9路归并算法，将结果输出到输出缓冲区。一旦输出缓冲区满，将缓冲区中的数据写到目标文件，清空缓冲区。一旦9个输入缓冲区的一个变空，就从这个缓冲区关联的文件中读入下一个10MB数据，除非这个文件已读完。这是外部归并排序能在主存外完成排序的关键步骤。因为归并算法对每一个大块只是顺序地做一轮访问，每个大块不用完全载入主存。
   置换选择 为了增加每一个有序的临时文件的长度，可以采用置换选择排序——它可以产生大于内存有序序列。具体方法是在内存中使用一个最小堆进行排序，设这个最小堆的大小为M，算法描述如下：
  初始时将输入文件读入内存，建立最小堆。
  将堆顶元素输出至输出缓冲区，然后读入下一个记录。
    2.1 若该元素的关键码值不小于刚输出的关键码值，将其作为堆顶元素并调整堆，使之满足堆的性质。
  2.2 若该元素的关键码值小于刚输出的关键码值，将新元素放入堆底位置，将堆的大小减1。
   重复第2步，直至堆大小变为0。
  此时一个有序序列已经产生，此时将输入缓冲区中剩下的所有元素建立最小堆，开始生成下一个有序序列。
   </content>
    </entry>
    
     <entry>
        <title></title>
        <url>https://iihui.github.io/post/ios-profile/</url>
        <categories>
          
        </categories>
        <tags>
          
        </tags>
        <content type="html"> iPhone XS Max iOS 13.7 Total pre-main time: 1.9 seconds (100.0%)  dylib loading time: 538.45 milliseconds (28.3%)  rebase/binding time: 397.03 milliseconds (20.8%)  ObjC setup time: 482.18 milliseconds (25.3%)  initializer time: 483.96 milliseconds (25.4%)  slowest intializers :  libSystem.B.dylib : 9.05 milliseconds (0.4%)  MobileRTC : 87.87 milliseconds (4.6%)  BizConfSDK : 73.70 milliseconds (3.8%)  IpCall : 70.74 milliseconds (3.7%)  CMBMobileST : 162.20 milliseconds (8.5%)   total time: 3.4 seconds (100.0%)  total images loaded: 556 (534 from dyld shared cache)  total segments mapped: 77, into 64676 pages  total images loading time: 2.0 seconds (58.7%)  total load time in ObjC: 482.18 milliseconds (13.9%)  total debugger pause time: 1.4 seconds (43.1%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 1,108,451  total rebase fixups time: 114.17 milliseconds (3.3%)  total binding fixups: 120,557  total binding fixups time: 261.86 milliseconds (7.5%)  total weak binding fixups time: 80.24 milliseconds (2.3%)  total redo shared cached bindings time: 59.25 milliseconds (1.7%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 483.96 milliseconds (14.0%)  libSystem.B.dylib : 9.05 milliseconds (0.2%)  libBacktraceRecording.dylib : 7.90 milliseconds (0.2%)  libMTLCapture.dylib : 25.22 milliseconds (0.7%)  AgoraCore : 6.57 milliseconds (0.1%)  AgoraRtcKit : 17.58 milliseconds (0.5%)  AgoraRtmKit : 6.52 milliseconds (0.1%)  MobileRTC : 87.87 milliseconds (2.5%)  BizConfSDK : 73.70 milliseconds (2.1%)  IpCall : 70.74 milliseconds (2.0%)  JMSDK : 13.78 milliseconds (0.3%)  WebRTC : 4.23 milliseconds (0.1%)  CMBMobileST : 162.20 milliseconds (4.7%) total symbol trie searches: 501802 total symbol table binary searches: 0 total images defining weak symbols: 57 total images using weak symbols: 141 去除招乎代码之后 Total pre-main time: 762.07 milliseconds (100.0%)  dylib loading time: 134.11 milliseconds (17.5%)  rebase/binding time: 249.01 milliseconds (32.6%)  ObjC setup time: 154.58 milliseconds (20.2%)  initializer time: 224.36 milliseconds (29.4%)  slowest intializers :  libSystem.B.dylib : 6.34 milliseconds (0.8%)  libMainThreadChecker.dylib : 36.11 milliseconds (4.7%)  libMTLCapture.dylib : 21.32 milliseconds (2.7%)  CMBMobileST : 221.18 milliseconds (29.0%)   total time: 2.2 seconds (100.0%)  total images loaded: 451 (443 from dyld shared cache)  total segments mapped: 29, into 760 pages  total images loading time: 1.5 seconds (71.1%)  total load time in ObjC: 154.58 milliseconds (6.9%)  total debugger pause time: 1.4 seconds (65.1%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 376,693  total rebase fixups time: 31.87 milliseconds (1.4%)  total binding fixups: 68,566  total binding fixups time: 180.99 milliseconds (8.0%)  total weak binding fixups time: 54.56 milliseconds (2.4%)  total redo shared cached bindings time: 18.42 milliseconds (0.8%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 224.36 milliseconds (10.0%)  libSystem.B.dylib : 6.34 milliseconds (0.2%)  libBacktraceRecording.dylib : 7.72 milliseconds (0.3%)  libMainThreadChecker.dylib : 36.11 milliseconds (1.6%)  libMTLCapture.dylib : 21.32 milliseconds (0.9%)  CMBMobileST : 221.18 milliseconds (9.8%) total symbol trie searches: 384738 total symbol table binary searches: 0 total images defining weak symbols: 49 total images using weak symbols: 117 Total pre-main time: 1.1 seconds (100.0%)  dylib loading time: 162.00 milliseconds (14.3%)  rebase/binding time: 446.00 milliseconds (39.6%)  ObjC setup time: 262.91 milliseconds (23.3%)  initializer time: 254.93 milliseconds (22.6%)  slowest intializers :  libSystem.B.dylib : 13.37 milliseconds (1.1%)  libMainThreadChecker.dylib : 35.57 milliseconds (3.1%)  libMTLCapture.dylib : 29.51 milliseconds (2.6%)  CMBMobileST : 225.28 milliseconds (20.0%)   total time: 2.7 seconds (100.0%)  total images loaded: 451 (443 from dyld shared cache)  total segments mapped: 29, into 760 pages  total images loading time: 1.7 seconds (63.4%)  total load time in ObjC: 262.91 milliseconds (9.5%)  total debugger pause time: 1.5 seconds (57.6%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 376,693  total rebase fixups time: 34.03 milliseconds (1.2%)  total binding fixups: 68,566  total binding fixups time: 395.23 milliseconds (14.3%)  total weak binding fixups time: 58.50 milliseconds (2.1%)  total redo shared cached bindings time: 41.77 milliseconds (1.5%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 254.93 milliseconds (9.2%)  libSystem.B.dylib : 13.37 milliseconds (0.4%)  libBacktraceRecording.dylib : 7.63 milliseconds (0.2%)  libMainThreadChecker.dylib : 35.57 milliseconds (1.2%)  libMTLCapture.dylib : 29.51 milliseconds (1.0%)  CMBMobileST : 225.28 milliseconds (8.1%) total symbol trie searches: 384738 total symbol table binary searches: 0 total images defining weak symbols: 49 total images using weak symbols: 117 iPhone XS iOS 13.3.1 Total pre-main time: 1.9 seconds (100.0%)  dylib loading time: 827.84 milliseconds (42.8%)  rebase/binding time: 428.34 milliseconds (22.1%)  ObjC setup time: 296.91 milliseconds (15.3%)  initializer time: 376.98 milliseconds (19.5%)  slowest intializers :  libSystem.B.dylib : 10.29 milliseconds (0.5%)  MobileRTC : 69.22 milliseconds (3.5%)  BizConfSDK : 54.21 milliseconds (2.8%)  IpCall : 62.84 milliseconds (3.2%)  CMBMobileST : 109.94 milliseconds (5.6%)   total time: 3.3 seconds (100.0%)  total images loaded: 552 (530 from dyld shared cache)  total segments mapped: 77, into 64659 pages  total images loading time: 2.1 seconds (65.1%)  total load time in ObjC: 296.91 milliseconds (8.8%)  total debugger pause time: 1.3 seconds (40.4%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 1,108,451  total rebase fixups time: 99.35 milliseconds (2.9%)  total binding fixups: 120,475  total binding fixups time: 312.01 milliseconds (9.3%)  total weak binding fixups time: 79.09 milliseconds (2.3%)  total redo shared cached bindings time: 62.11 milliseconds (1.8%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 376.98 milliseconds (11.2%)  libSystem.B.dylib : 10.29 milliseconds (0.3%)  libBacktraceRecording.dylib : 7.35 milliseconds (0.2%)  libMTLCapture.dylib : 18.50 milliseconds (0.5%)  AgoraRtcKit : 30.24 milliseconds (0.9%)  AgoraRtmKit : 4.47 milliseconds (0.1%)  MobileRTC : 69.22 milliseconds (2.0%)  BizConfSDK : 54.21 milliseconds (1.6%)  IpCall : 62.84 milliseconds (1.8%)  JMSDK : 12.02 milliseconds (0.3%)  CMBMobileST : 109.94 milliseconds (3.2%) total symbol trie searches: 492104 total symbol table binary searches: 0 total images defining weak symbols: 56 total images using weak symbols: 140 iPhone 8 Plus iOS 14.7.1 Total pre-main time: 3.1 seconds (100.0%)  dylib loading time: 928.47 milliseconds (29.2%)  rebase/binding time: 1.7 seconds (53.8%)  ObjC setup time: 247.29 milliseconds (7.7%)  initializer time: 289.48 milliseconds (9.1%)  slowest intializers :  libSystem.B.dylib : 7.36 milliseconds (0.2%)  IpCall : 64.62 milliseconds (2.0%)  CMBMobileST : 93.64 milliseconds (2.9%)   total time: 11.1 seconds (100.0%)  total images loaded: 627 (607 from dyld shared cache)  total segments mapped: 71, into 64391 pages  total images loading time: 3.6 seconds (33.0%)  total load time in ObjC: 247.29 milliseconds (2.2%)  total debugger pause time: 2.7 seconds (24.6%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 1,124,101  total rebase fixups time: 1.7 seconds (15.3%)  total binding fixups: 1,888,598  total binding fixups time: 5.1 seconds (46.7%)  total weak binding fixups time: 6.43 milliseconds (0.0%)  total redo shared cached bindings time: 5.2 seconds (46.7%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 289.48 milliseconds (2.6%)  libSystem.B.dylib : 7.36 milliseconds (0.0%)  AgoraRtcKit : 19.41 milliseconds (0.1%)  MobileRTC : 61.02 milliseconds (0.5%)  GameController : 13.42 milliseconds (0.1%)  IpCall : 64.62 milliseconds (0.5%)  JMSDK : 12.75 milliseconds (0.1%)  CMBMobileST : 93.64 milliseconds (0.8%) total symbol trie searches: 2030698 total symbol table binary searches: 0 total images defining weak symbols: 90 total images using weak symbols: 179 iPhone X iOS 14.7.1 Total pre-main time: 935.41 milliseconds (100.0%)  dylib loading time: 458.72 milliseconds (49.0%)  rebase/binding time: 97.91 milliseconds (10.4%)  ObjC setup time: 84.45 milliseconds (9.0%)  initializer time: 294.32 milliseconds (31.4%)  slowest intializers :  libSystem.B.dylib : 6.90 milliseconds (0.7%)  libMTLCapture.dylib : 21.15 milliseconds (2.2%)  MobileRTC : 60.97 milliseconds (6.5%)  IpCall : 61.20 milliseconds (6.5%)  CMBMobileST : 89.33 milliseconds (9.5%)   total time: 4.6 seconds (100.0%)  total images loaded: 628 (607 from dyld shared cache)  total segments mapped: 75, into 64695 pages  total images loading time: 3.5 seconds (76.8%)  total load time in ObjC: 84.45 milliseconds (1.8%)  total debugger pause time: 3.1 seconds (67.0%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 1,140,366  total rebase fixups time: 97.52 milliseconds (2.0%)  total binding fixups: 1,889,469  total binding fixups time: 598.00 milliseconds (12.8%)  total weak binding fixups time: 5.03 milliseconds (0.1%)  total redo shared cached bindings time: 602.64 milliseconds (12.9%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 294.32 milliseconds (6.3%)  libSystem.B.dylib : 6.90 milliseconds (0.1%)  libBacktraceRecording.dylib : 7.36 milliseconds (0.1%)  libMTLCapture.dylib : 21.15 milliseconds (0.4%)  AgoraRtcKit : 16.22 milliseconds (0.3%)  AgoraRtmKit : 5.81 milliseconds (0.1%)  MobileRTC : 60.97 milliseconds (1.3%)  GameController : 5.65 milliseconds (0.1%)  IpCall : 61.20 milliseconds (1.3%)  JMSDK : 14.22 milliseconds (0.3%)  CMBMobileST : 89.33 milliseconds (1.9%) total symbol trie searches: 2033030 total symbol table binary searches: 0 total images defining weak symbols: 90 total images using weak symbols: 180 iPhone 11 iOS 15.1 ![image-20211209180145847](/Users/hui/Library/Application Support/typora-user-images/image-20211209180145847.png)
![image-20211209180202670](/Users/hui/Library/Application Support/typora-user-images/image-20211209180202670.png)
iPhone 8 iOS 12.1.2 Total pre-main time: 1.2 seconds (100.0%)  dylib loading time: 620.01 milliseconds (50.7%)  rebase/binding time: 142.79 milliseconds (11.6%)  ObjC setup time: 94.36 milliseconds (7.7%)  initializer time: 364.76 milliseconds (29.8%)  slowest intializers :  libSystem.B.dylib : 7.52 milliseconds (0.6%)  libMTLInterpose.dylib : 64.92 milliseconds (5.3%)  MobileRTC : 83.75 milliseconds (6.8%)  CMBMobileST : 146.68 milliseconds (12.0%)   total time: 2.4 seconds (100.0%)  total images loaded: 482 (435 from dyld shared cache)  total segments mapped: 149, into 67977 pages with 2916 pages pre-fetched  total images loading time: 1.4 seconds (57.3%)  total load time in ObjC: 94.36 milliseconds (3.8%)  total debugger pause time: 789.25 milliseconds (32.1%)  total dtrace DOF registration time: 0.13 milliseconds (0.0%)  total rebase fixups: 1,165,608  total rebase fixups time: 152.83 milliseconds (6.2%)  total binding fixups: 642,808  total binding fixups time: 429.44 milliseconds (17.4%)  total weak binding fixups time: 6.51 milliseconds (0.2%)  total redo shared cached bindings time: 445.98 milliseconds (18.1%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 364.76 milliseconds (14.8%)  libSystem.B.dylib : 7.52 milliseconds (0.3%)  libBacktraceRecording.dylib : 4.45 milliseconds (0.1%)  libMTLInterpose.dylib : 64.92 milliseconds (2.6%)  AgoraRtcKit : 21.12 milliseconds (0.8%)  AgoraRtmKit : 5.58 milliseconds (0.2%)  MobileRTC : 83.75 milliseconds (3.4%)  IpCall : 8.61 milliseconds (0.3%)  JMSDK : 16.15 milliseconds (0.6%)  WebRTC : 5.53 milliseconds (0.2%)  libswiftCore.dylib : 3.14 milliseconds (0.1%)  CMBMobileST : 146.68 milliseconds (5.9%) total symbol trie searches: 1422556 total symbol table binary searches: 0 total images defining weak symbols: 42 total images using weak symbols: 120 iPhone XR 12.4.1 Total pre-main time: 907.16 milliseconds (100.0%)  dylib loading time: 354.54 milliseconds (39.0%)  rebase/binding time: 210.20 milliseconds (23.1%)  ObjC setup time: 68.38 milliseconds (7.5%)  initializer time: 273.73 milliseconds (30.1%)  slowest intializers :  libSystem.B.dylib : 7.32 milliseconds (0.8%)  libMTLInterpose.dylib : 48.32 milliseconds (5.3%)  MobileRTC : 63.79 milliseconds (7.0%)  CMBMobileST : 103.82 milliseconds (11.4%)   total time: 2.2 seconds (100.0%)  total images loaded: 481 (457 from dyld shared cache)  total segments mapped: 80, into 65065 pages with 2776 pages pre-fetched  total images loading time: 1.6 seconds (73.1%)  total load time in ObjC: 68.38 milliseconds (3.0%)  total debugger pause time: 1.3 seconds (57.5%)  total dtrace DOF registration time: 0.29 milliseconds (0.0%)  total rebase fixups: 1,108,438  total rebase fixups time: 135.43 milliseconds (5.9%)  total binding fixups: 123,894  total binding fixups time: 79.60 milliseconds (3.5%)  total weak binding fixups time: 51.71 milliseconds (2.2%)  total redo shared cached bindings time: 56.54 milliseconds (2.4%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 273.73 milliseconds (12.0%)  libSystem.B.dylib : 7.32 milliseconds (0.3%)  libBacktraceRecording.dylib : 3.14 milliseconds (0.1%)  libMTLInterpose.dylib : 48.32 milliseconds (2.1%)  AgoraRtcKit : 16.51 milliseconds (0.7%)  AgoraRtmKit : 13.00 milliseconds (0.5%)  MobileRTC : 63.79 milliseconds (2.8%)  BizConfSDK : 2.84 milliseconds (0.1%)  IpCall : 5.40 milliseconds (0.2%)  JMSDK : 15.33 milliseconds (0.6%)  WebRTC : 5.88 milliseconds (0.2%)  CMBMobileST : 103.82 milliseconds (4.5%) total symbol trie searches: 380826 total symbol table binary searches: 0 total images defining weak symbols: 46 total images using weak symbols: 120 iPhone7 iOS 11.3 剥离前的冷启动 Total pre-main time: 1.7 seconds (100.0%)  dylib loading time: 900.42 milliseconds (50.8%)  rebase/binding time: 137.06 milliseconds (7.7%)  ObjC setup time: 131.64 milliseconds (7.4%)  initializer time: 601.68 milliseconds (33.9%)  slowest intializers :  libSystem.B.dylib : 17.65 milliseconds (0.9%)  libMTLInterpose.dylib : 66.05 milliseconds (3.7%)  AgoraRtcKit : 92.29 milliseconds (5.2%)  MobileRTC : 117.61 milliseconds (6.6%)  CMBMobile : 201.28 milliseconds (11.3%)   total time: 3.0 seconds (100.0%)  total images loaded: 472 (423 from dyld shared cache)  total segments mapped: 156, into 68104 pages with 2936 pages pre-fetched  total images loading time: 1.7 seconds (57.5%)  total load time in ObjC: 131.64 milliseconds (4.2%)  total debugger pause time: 868.18 milliseconds (28.2%)  total dtrace DOF registration time: 0.15 milliseconds (0.0%)  total rebase fixups: 1,155,778  total rebase fixups time: 128.26 milliseconds (4.1%)  total binding fixups: 649,585  total binding fixups time: 436.17 milliseconds (14.1%)  total weak binding fixups time: 7.71 milliseconds (0.2%)  total redo shared cached bindings time: 435.08 milliseconds (14.1%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 601.68 milliseconds (19.5%)  libSystem.B.dylib : 17.65 milliseconds (0.5%)  libBacktraceRecording.dylib : 15.31 milliseconds (0.4%)  libMainThreadChecker.dylib : 26.22 milliseconds (0.8%)  libViewDebuggerSupport.dylib : 8.99 milliseconds (0.2%)  libMTLInterpose.dylib : 66.05 milliseconds (2.1%)  AgoraRtcKit : 92.29 milliseconds (3.0%)  AgoraRtmKit : 13.18 milliseconds (0.4%)  MobileRTC : 117.61 milliseconds (3.8%)  BizConfSDK : 4.51 milliseconds (0.1%)  IpCall : 9.52 milliseconds (0.3%)  JMSDK : 20.20 milliseconds (0.6%)  libswiftCore.dylib : 4.20 milliseconds (0.1%)  WebRTC : 7.93 milliseconds (0.2%)  CMBMobile : 201.28 milliseconds (6.5%) total symbol trie searches: 1449736 total symbol table binary searches: 0 total images defining weak symbols: 55 total images using weak symbols: 124 剥离后的冷启动 Total pre-main time: 847.49 milliseconds (100.0%)  dylib loading time: 397.96 milliseconds (46.9%)  rebase/binding time: 53.20 milliseconds (6.2%)  ObjC setup time: 52.83 milliseconds (6.2%)  initializer time: 343.40 milliseconds (40.5%)  slowest intializers :  libSystem.B.dylib : 7.56 milliseconds (0.8%)  libMTLInterpose.dylib : 35.99 milliseconds (4.2%)  libswiftCore.dylib : 44.73 milliseconds (5.2%)  CMBMobileST : 241.90 milliseconds (28.5%)   total time: 1.4 seconds (100.0%)  total images loaded: 353 (319 from dyld shared cache)  total segments mapped: 102, into 4093 pages with 248 pages pre-fetched  total images loading time: 799.64 milliseconds (53.3%)  total load time in ObjC: 52.83 milliseconds (3.5%)  total debugger pause time: 401.68 milliseconds (26.8%)  total dtrace DOF registration time: 0.08 milliseconds (0.0%)  total rebase fixups: 444,245  total rebase fixups time: 48.30 milliseconds (3.2%)  total binding fixups: 460,857  total binding fixups time: 250.14 milliseconds (16.6%)  total weak binding fixups time: 4.33 milliseconds (0.2%)  total redo shared cached bindings time: 249.59 milliseconds (16.6%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 343.40 milliseconds (22.9%)  libSystem.B.dylib : 7.56 milliseconds (0.5%)  libBacktraceRecording.dylib : 8.58 milliseconds (0.5%)  libMainThreadChecker.dylib : 12.44 milliseconds (0.8%)  libMTLInterpose.dylib : 35.99 milliseconds (2.4%)  libswiftCore.dylib : 44.73 milliseconds (2.9%)  CMBMobileST : 241.90 milliseconds (16.1%) total symbol trie searches: 1166429 total symbol table binary searches: 0 total images defining weak symbols: 40 total images using weak symbols: 90 剥离后的热启动 Total pre-main time: 558.13 milliseconds (100.0%)  dylib loading time: 287.89 milliseconds (51.5%)  rebase/binding time: 35.51 milliseconds (6.3%)  ObjC setup time: 24.60 milliseconds (4.4%)  initializer time: 210.05 milliseconds (37.6%)  slowest intializers :  libSystem.B.dylib : 5.56 milliseconds (0.9%)  libMainThreadChecker.dylib : 12.68 milliseconds (2.2%)  libMTLInterpose.dylib : 27.95 milliseconds (5.0%)  CMBMobileST : 194.84 milliseconds (34.9%)   total time: 1.0 seconds (100.0%)  total images loaded: 353 (319 from dyld shared cache)  total segments mapped: 102, into 4093 pages with 248 pages pre-fetched  total images loading time: 641.42 milliseconds (58.3%)  total load time in ObjC: 24.60 milliseconds (2.2%)  total debugger pause time: 353.53 milliseconds (32.1%)  total dtrace DOF registration time: 0.06 milliseconds (0.0%)  total rebase fixups: 444,247  total rebase fixups time: 31.00 milliseconds (2.8%)  total binding fixups: 460,857  total binding fixups time: 188.33 milliseconds (17.1%)  total weak binding fixups time: 4.05 milliseconds (0.3%)  total redo shared cached bindings time: 187.88 milliseconds (17.0%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 210.05 milliseconds (19.1%)  libSystem.B.dylib : 5.56 milliseconds (0.5%)  libBacktraceRecording.dylib : 3.83 milliseconds (0.3%)  libMainThreadChecker.dylib : 12.68 milliseconds (1.1%)  libMTLInterpose.dylib : 27.95 milliseconds (2.5%)  libswiftCore.dylib : 1.31 milliseconds (0.1%)  CMBMobileST : 194.84 milliseconds (17.7%) total symbol trie searches: 1166434 total symbol table binary searches: 0 total images defining weak symbols: 40 total images using weak symbols: 90 剥离后的冷启动 Total pre-main time: 686.16 milliseconds (100.0%)  dylib loading time: 332.92 milliseconds (48.5%)  rebase/binding time: 39.67 milliseconds (5.7%)  ObjC setup time: 22.46 milliseconds (3.2%)  initializer time: 291.02 milliseconds (42.4%)  slowest intializers :  libSystem.B.dylib : 5.59 milliseconds (0.8%)  libMTLInterpose.dylib : 46.33 milliseconds (6.7%)  CMBMobileST : 230.69 milliseconds (33.6%)   total time: 1.3 seconds (100.0%)  total images loaded: 353 (319 from dyld shared cache)  total segments mapped: 102, into 4093 pages with 248 pages pre-fetched  total images loading time: 710.04 milliseconds (52.7%)  total load time in ObjC: 22.46 milliseconds (1.6%)  total debugger pause time: 377.11 milliseconds (28.0%)  total dtrace DOF registration time: 0.06 milliseconds (0.0%)  total rebase fixups: 444,247  total rebase fixups time: 35.48 milliseconds (2.6%)  total binding fixups: 460,857  total binding fixups time: 282.40 milliseconds (20.9%)  total weak binding fixups time: 3.69 milliseconds (0.2%)  total redo shared cached bindings time: 281.91 milliseconds (20.9%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 291.02 milliseconds (21.6%)  libSystem.B.dylib : 5.59 milliseconds (0.4%)  libBacktraceRecording.dylib : 6.88 milliseconds (0.5%)  libMainThreadChecker.dylib : 9.88 milliseconds (0.7%)  libMTLInterpose.dylib : 46.33 milliseconds (3.4%)  CMBMobileST : 230.69 milliseconds (17.1%) total symbol trie searches: 1166420 total symbol table binary searches: 0 total images defining weak symbols: 40 total images using weak symbols: 90 二进制重排前 测试手机为iPhone XS Max iOS版本为13.7，Xcode版本为 13.2.1，macOS版本为12.0.1。测试手机关机重启，Xcode关闭重启并清理缓存，测试4次，每次时间如下所示：
Total pre-main time: 1.6 seconds (100.0%)  dylib loading time: 522.40 milliseconds (31.4%)  rebase/binding time: 409.12 milliseconds (24.6%)  ObjC setup time: 261.59 milliseconds (15.7%)  initializer time: 468.08 milliseconds (28.1%)  slowest intializers :  libSystem.B.dylib : 12.01 milliseconds (0.7%)  MobileRTC : 94.61 milliseconds (5.6%)  BizConfSDK : 70.24 milliseconds (4.2%)  IpCall : 65.15 milliseconds (3.9%)  CMBMobileST : 107.68 milliseconds (6.4%)   total time: 3.3 seconds (100.0%)  total images loaded: 557 (534 from dyld shared cache)  total segments mapped: 81, into 64755 pages  total images loading time: 2.1 seconds (64.3%)  total load time in ObjC: 261.59 milliseconds (7.8%)  total debugger pause time: 1.6 seconds (48.8%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 1,113,280  total rebase fixups time: 122.58 milliseconds (3.6%)  total binding fixups: 121,271  total binding fixups time: 267.59 milliseconds (7.9%)  total weak binding fixups time: 73.89 milliseconds (2.2%)  total redo shared cached bindings time: 54.95 milliseconds (1.6%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 468.08 milliseconds (13.9%)  libSystem.B.dylib : 12.01 milliseconds (0.3%)  libBacktraceRecording.dylib : 7.75 milliseconds (0.2%)  libMainThreadChecker.dylib : 29.87 milliseconds (0.8%)  libMTLCapture.dylib : 31.91 milliseconds (0.9%)  AgoraRtcKit : 26.64 milliseconds (0.7%)  AgoraRtmKit : 7.92 milliseconds (0.2%)  MobileRTC : 94.61 milliseconds (2.8%)  BizConfSDK : 70.24 milliseconds (2.0%)  IpCall : 65.15 milliseconds (1.9%)  JMSDK : 13.66 milliseconds (0.4%)  WebRTC : 3.97 milliseconds (0.1%)  CMBMobileST : 107.68 milliseconds (3.2%) total symbol trie searches: 503818 total symbol table binary searches: 0 total images defining weak symbols: 57 total images using weak symbols: 141 Total pre-main time: 1.7 seconds (100.0%)  dylib loading time: 582.38 milliseconds (32.8%)  rebase/binding time: 434.03 milliseconds (24.4%)  ObjC setup time: 276.75 milliseconds (15.6%)  initializer time: 479.27 milliseconds (27.0%)  slowest intializers :  libSystem.B.dylib : 6.68 milliseconds (0.3%)  MobileRTC : 91.04 milliseconds (5.1%)  BizConfSDK : 54.77 milliseconds (3.0%)  IpCall : 60.78 milliseconds (3.4%)  CMBMobileST : 145.16 milliseconds (8.1%)   total time: 3.3 seconds (100.0%)  total images loaded: 557 (534 from dyld shared cache)  total segments mapped: 81, into 64755 pages  total images loading time: 2.0 seconds (63.1%)  total load time in ObjC: 276.75 milliseconds (8.3%)  total debugger pause time: 1.5 seconds (45.6%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 1,113,280  total rebase fixups time: 105.52 milliseconds (3.1%)  total binding fixups: 121,271  total binding fixups time: 282.01 milliseconds (8.4%)  total weak binding fixups time: 78.67 milliseconds (2.3%)  total redo shared cached bindings time: 32.17 milliseconds (0.9%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 479.27 milliseconds (14.4%)  libSystem.B.dylib : 6.68 milliseconds (0.2%)  libBacktraceRecording.dylib : 7.56 milliseconds (0.2%)  libMainThreadChecker.dylib : 30.00 milliseconds (0.9%)  libMTLCapture.dylib : 23.62 milliseconds (0.7%)  AgoraCore : 3.49 milliseconds (0.1%)  AgoraRtcKit : 29.97 milliseconds (0.9%)  AgoraRtmKit : 6.86 milliseconds (0.2%)  MobileRTC : 91.04 milliseconds (2.7%)  BizConfSDK : 54.77 milliseconds (1.6%)  IpCall : 60.78 milliseconds (1.8%)  JMSDK : 20.45 milliseconds (0.6%)  WebRTC : 5.51 milliseconds (0.1%)  CMBMobileST : 145.16 milliseconds (4.3%) total symbol trie searches: 503818 total symbol table binary searches: 0 total images defining weak symbols: 57 total images using weak symbols: 141 Total pre-main time: 1.5 seconds (100.0%)  dylib loading time: 517.37 milliseconds (33.4%)  rebase/binding time: 414.25 milliseconds (26.7%)  ObjC setup time: 185.96 milliseconds (12.0%)  initializer time: 428.16 milliseconds (27.6%)  slowest intializers :  libSystem.B.dylib : 8.82 milliseconds (0.5%)  libMTLCapture.dylib : 37.44 milliseconds (2.4%)  MobileRTC : 69.42 milliseconds (4.4%)  BizConfSDK : 58.93 milliseconds (3.8%)  IpCall : 54.33 milliseconds (3.5%)  CMBMobileST : 128.59 milliseconds (8.3%)   total time: 3.1 seconds (100.0%)  total images loaded: 557 (534 from dyld shared cache)  total segments mapped: 81, into 64755 pages  total images loading time: 2.0 seconds (65.9%)  total load time in ObjC: 185.96 milliseconds (5.8%)  total debugger pause time: 1.5 seconds (49.6%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 1,113,280  total rebase fixups time: 97.50 milliseconds (3.0%)  total binding fixups: 121,271  total binding fixups time: 303.48 milliseconds (9.5%)  total weak binding fixups time: 63.10 milliseconds (1.9%)  total redo shared cached bindings time: 49.83 milliseconds (1.5%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 428.16 milliseconds (13.5%)  libSystem.B.dylib : 8.82 milliseconds (0.2%)  libBacktraceRecording.dylib : 7.39 milliseconds (0.2%)  libMainThreadChecker.dylib : 29.58 milliseconds (0.9%)  libMTLCapture.dylib : 37.44 milliseconds (1.1%)  AgoraRtcKit : 15.06 milliseconds (0.4%)  AgoraRtmKit : 5.38 milliseconds (0.1%)  MobileRTC : 69.42 milliseconds (2.1%)  BizConfSDK : 58.93 milliseconds (1.8%)  IpCall : 54.33 milliseconds (1.7%)  JMSDK : 11.94 milliseconds (0.3%)  WebRTC : 3.76 milliseconds (0.1%)  CMBMobileST : 128.59 milliseconds (4.0%) total symbol trie searches: 503818 total symbol table binary searches: 0 total images defining weak symbols: 57 total images using weak symbols: 141 Total pre-main time: 1.6 seconds (100.0%)  dylib loading time: 508.85 milliseconds (31.0%)  rebase/binding time: 483.35 milliseconds (29.4%)  ObjC setup time: 249.26 milliseconds (15.2%)  initializer time: 397.63 milliseconds (24.2%)  slowest intializers :  libSystem.B.dylib : 9.90 milliseconds (0.6%)  MobileRTC : 58.59 milliseconds (3.5%)  BizConfSDK : 52.78 milliseconds (3.2%)  IpCall : 57.41 milliseconds (3.5%)  CMBMobileST : 126.32 milliseconds (7.7%)   total time: 3.2 seconds (100.0%)  total images loaded: 557 (534 from dyld shared cache)  total segments mapped: 81, into 64755 pages  total images loading time: 2.0 seconds (63.9%)  total load time in ObjC: 249.26 milliseconds (7.7%)  total debugger pause time: 1.5 seconds (48.2%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 1,113,280  total rebase fixups time: 120.97 milliseconds (3.7%)  total binding fixups: 121,271  total binding fixups time: 322.41 milliseconds (9.9%)  total weak binding fixups time: 74.53 milliseconds (2.3%)  total redo shared cached bindings time: 34.57 milliseconds (1.0%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 397.63 milliseconds (12.2%)  libSystem.B.dylib : 9.90 milliseconds (0.3%)  libBacktraceRecording.dylib : 7.75 milliseconds (0.2%)  libMainThreadChecker.dylib : 29.54 milliseconds (0.9%)  libMTLCapture.dylib : 23.28 milliseconds (0.7%)  AgoraRtcKit : 26.13 milliseconds (0.8%)  AgoraRtmKit : 6.21 milliseconds (0.1%)  MobileRTC : 58.59 milliseconds (1.8%)  BizConfSDK : 52.78 milliseconds (1.6%)  IpCall : 57.41 milliseconds (1.7%)  JMSDK : 11.99 milliseconds (0.3%)  WebRTC : 3.79 milliseconds (0.1%)  CMBMobileST : 126.32 milliseconds (3.9%) total symbol trie searches: 503818 total symbol table binary searches: 0 total images defining weak symbols: 57 total images using weak symbols: 141 测试手机为iPhone XS Max iOS版本为13.7，Xcode版本为 13.2.1，macOS版本为12.0.1。测试手机关机重启，Xcode关闭（Command&#43;Q）重启不清理缓存，测试4次，每次时间如下所示：
Total pre-main time: 1.5 seconds (100.0%)  dylib loading time: 494.80 milliseconds (31.0%)  rebase/binding time: 489.70 milliseconds (30.7%)  ObjC setup time: 222.29 milliseconds (13.9%)  initializer time: 387.28 milliseconds (24.2%)  slowest intializers :  libSystem.B.dylib : 6.90 milliseconds (0.4%)  MobileRTC : 67.72 milliseconds (4.2%)  BizConfSDK : 52.53 milliseconds (3.2%)  IpCall : 52.61 milliseconds (3.3%)  CMBMobileST : 103.05 milliseconds (6.4%)   total time: 3.2 seconds (100.0%)  total images loaded: 557 (534 from dyld shared cache)  total segments mapped: 81, into 64755 pages  total images loading time: 2.0 seconds (64.8%)  total load time in ObjC: 222.29 milliseconds (6.9%)  total debugger pause time: 1.5 seconds (49.4%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 1,113,280  total rebase fixups time: 84.47 milliseconds (2.6%)  total binding fixups: 121,271  total binding fixups time: 347.98 milliseconds (10.8%)  total weak binding fixups time: 87.95 milliseconds (2.7%)  total redo shared cached bindings time: 30.70 milliseconds (0.9%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 387.28 milliseconds (12.0%)  libSystem.B.dylib : 6.90 milliseconds (0.2%)  libBacktraceRecording.dylib : 9.05 milliseconds (0.2%)  libMainThreadChecker.dylib : 30.31 milliseconds (0.9%)  libMTLCapture.dylib : 27.39 milliseconds (0.8%)  AgoraRtcKit : 18.18 milliseconds (0.5%)  AgoraRtmKit : 5.78 milliseconds (0.1%)  MobileRTC : 67.72 milliseconds (2.1%)  BizConfSDK : 52.53 milliseconds (1.6%)  IpCall : 52.61 milliseconds (1.6%)  JMSDK : 12.21 milliseconds (0.3%)  WebRTC : 4.00 milliseconds (0.1%)  CMBMobileST : 103.05 milliseconds (3.2%) total symbol trie searches: 503818 total symbol table binary searches: 0 total images defining weak symbols: 57 total images using weak symbols: 141 Total pre-main time: 1.3 seconds (100.0%)  dylib loading time: 499.62 milliseconds (36.2%)  rebase/binding time: 330.78 milliseconds (24.0%)  ObjC setup time: 154.90 milliseconds (11.2%)  initializer time: 391.26 milliseconds (28.4%)  slowest intializers :  libSystem.B.dylib : 6.89 milliseconds (0.5%)  libMainThreadChecker.dylib : 29.28 milliseconds (2.1%)  MobileRTC : 70.59 milliseconds (5.1%)  BizConfSDK : 61.52 milliseconds (4.4%)  IpCall : 58.95 milliseconds (4.2%)  CMBMobileST : 101.66 milliseconds (7.3%)   total time: 2.9 seconds (100.0%)  total images loaded: 557 (534 from dyld shared cache)  total segments mapped: 81, into 64755 pages  total images loading time: 2.0 seconds (69.7%)  total load time in ObjC: 154.90 milliseconds (5.2%)  total debugger pause time: 1.5 seconds (52.8%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 1,113,280  total rebase fixups time: 79.70 milliseconds (2.6%)  total binding fixups: 121,271  total binding fixups time: 204.05 milliseconds (6.8%)  total weak binding fixups time: 67.79 milliseconds (2.2%)  total redo shared cached bindings time: 20.77 milliseconds (0.7%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 391.26 milliseconds (13.2%)  libSystem.B.dylib : 6.89 milliseconds (0.2%)  libBacktraceRecording.dylib : 6.99 milliseconds (0.2%)  libMainThreadChecker.dylib : 29.28 milliseconds (0.9%)  libMTLCapture.dylib : 21.65 milliseconds (0.7%)  AgoraRtcKit : 15.12 milliseconds (0.5%)  AgoraRtmKit : 4.96 milliseconds (0.1%)  MobileRTC : 70.59 milliseconds (2.3%)  BizConfSDK : 61.52 milliseconds (2.0%)  IpCall : 58.95 milliseconds (1.9%)  JMSDK : 12.63 milliseconds (0.4%)  WebRTC : 3.91 milliseconds (0.1%)  CMBMobileST : 101.66 milliseconds (3.4%) total symbol trie searches: 503818 total symbol table binary searches: 0 total images defining weak symbols: 57 total images using weak symbols: 141 Total pre-main time: 1.5 seconds (100.0%)  dylib loading time: 650.76 milliseconds (41.5%)  rebase/binding time: 322.68 milliseconds (20.6%)  ObjC setup time: 161.69 milliseconds (10.3%)  initializer time: 429.87 milliseconds (27.4%)  slowest intializers :  libSystem.B.dylib : 7.05 milliseconds (0.4%)  MobileRTC : 73.32 milliseconds (4.6%)  BizConfSDK : 55.98 milliseconds (3.5%)  IpCall : 65.51 milliseconds (4.1%)  CMBMobileST : 126.28 milliseconds (8.0%)   total time: 3.2 seconds (100.0%)  total images loaded: 557 (534 from dyld shared cache)  total segments mapped: 81, into 64755 pages  total images loading time: 2.3 seconds (71.2%)  total load time in ObjC: 161.69 milliseconds (4.9%)  total debugger pause time: 1.6 seconds (51.2%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 1,113,280  total rebase fixups time: 121.16 milliseconds (3.7%)  total binding fixups: 121,271  total binding fixups time: 152.63 milliseconds (4.6%)  total weak binding fixups time: 76.33 milliseconds (2.3%)  total redo shared cached bindings time: 27.45 milliseconds (0.8%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 429.87 milliseconds (13.1%)  libSystem.B.dylib : 7.05 milliseconds (0.2%)  libBacktraceRecording.dylib : 7.45 milliseconds (0.2%)  libMainThreadChecker.dylib : 28.79 milliseconds (0.8%)  libMTLCapture.dylib : 29.62 milliseconds (0.9%)  AgoraRtcKit : 17.95 milliseconds (0.5%)  AgoraRtmKit : 6.66 milliseconds (0.2%)  MobileRTC : 73.32 milliseconds (2.2%)  BizConfSDK : 55.98 milliseconds (1.7%)  IpCall : 65.51 milliseconds (2.0%)  JMSDK : 12.61 milliseconds (0.3%)  WebRTC : 3.94 milliseconds (0.1%)  CMBMobileST : 126.28 milliseconds (3.8%) total symbol trie searches: 503818 total symbol table binary searches: 0 total images defining weak symbols: 57 total images using weak symbols: 141 Total pre-main time: 1.6 seconds (100.0%)  dylib loading time: 598.76 milliseconds (36.0%)  rebase/binding time: 375.43 milliseconds (22.6%)  ObjC setup time: 212.66 milliseconds (12.8%)  initializer time: 472.13 milliseconds (28.4%)  slowest intializers :  libSystem.B.dylib : 6.64 milliseconds (0.4%)  MobileRTC : 84.73 milliseconds (5.1%)  BizConfSDK : 83.80 milliseconds (5.0%)  IpCall : 77.78 milliseconds (4.6%)  CMBMobileST : 135.47 milliseconds (8.1%)   total time: 3.2 seconds (100.0%)  total images loaded: 555 (533 from dyld shared cache)  total segments mapped: 77, into 64478 pages  total images loading time: 2.1 seconds (66.0%)  total load time in ObjC: 212.66 milliseconds (6.6%)  total debugger pause time: 1.5 seconds (47.3%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 1,113,280  total rebase fixups time: 124.96 milliseconds (3.8%)  total binding fixups: 102,477  total binding fixups time: 199.10 milliseconds (6.2%)  total weak binding fixups time: 80.84 milliseconds (2.5%)  total redo shared cached bindings time: 29.47 milliseconds (0.9%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 472.13 milliseconds (14.7%)  libSystem.B.dylib : 6.64 milliseconds (0.2%)  libBacktraceRecording.dylib : 7.39 milliseconds (0.2%)  libMainThreadChecker.dylib : 28.50 milliseconds (0.8%)  AgoraRtcKit : 26.91 milliseconds (0.8%)  AgoraRtmKit : 6.15 milliseconds (0.1%)  MobileRTC : 84.73 milliseconds (2.6%)  BizConfSDK : 83.80 milliseconds (2.6%)  IpCall : 77.78 milliseconds (2.4%)  JMSDK : 16.33 milliseconds (0.5%)  WebRTC : 4.49 milliseconds (0.1%)  CMBMobileST : 135.47 milliseconds (4.2%) total symbol trie searches: 484852 total symbol table binary searches: 0 total images defining weak symbols: 56 total images using weak symbols: 139 二进制重排后 Total pre-main time: 1.3 seconds (100.0%)  dylib loading time: 533.67 milliseconds (39.5%)  rebase/binding time: 244.70 milliseconds (18.1%)  ObjC setup time: 118.40 milliseconds (8.7%)  initializer time: 453.29 milliseconds (33.5%)  slowest intializers :  libSystem.B.dylib : 6.59 milliseconds (0.4%)  libMainThreadChecker.dylib : 27.66 milliseconds (2.0%)  MobileRTC : 62.09 milliseconds (4.5%)  BizConfSDK : 60.51 milliseconds (4.4%)  IpCall : 60.66 milliseconds (4.4%)  CMBMobileST : 174.32 milliseconds (12.9%)   total time: 2.9 seconds (100.0%)  total images loaded: 557 (534 from dyld shared cache)  total segments mapped: 81, into 64755 pages  total images loading time: 2.1 seconds (71.7%)  total load time in ObjC: 118.40 milliseconds (3.9%)  total debugger pause time: 1.6 seconds (53.9%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 1,113,803  total rebase fixups time: 84.88 milliseconds (2.8%)  total binding fixups: 121,283  total binding fixups time: 110.99 milliseconds (3.7%)  total weak binding fixups time: 74.69 milliseconds (2.5%)  total redo shared cached bindings time: 25.87 milliseconds (0.8%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 453.29 milliseconds (15.1%)  libSystem.B.dylib : 6.59 milliseconds (0.2%)  libBacktraceRecording.dylib : 6.28 milliseconds (0.2%)  libMainThreadChecker.dylib : 27.66 milliseconds (0.9%)  libMTLCapture.dylib : 23.48 milliseconds (0.7%)  AgoraRtcKit : 16.04 milliseconds (0.5%)  AgoraRtmKit : 5.19 milliseconds (0.1%)  MobileRTC : 62.09 milliseconds (2.0%)  BizConfSDK : 60.51 milliseconds (2.0%)  IpCall : 60.66 milliseconds (2.0%)  JMSDK : 12.54 milliseconds (0.4%)  WebRTC : 3.88 milliseconds (0.1%)  CMBMobileST : 174.32 milliseconds (5.8%) total symbol trie searches: 503902 total symbol table binary searches: 0 total images defining weak symbols: 57 total images using weak symbols: 141 Total pre-main time: 1.2 seconds (100.0%)  dylib loading time: 547.90 milliseconds (43.0%)  rebase/binding time: 221.05 milliseconds (17.3%)  ObjC setup time: 73.44 milliseconds (5.7%)  initializer time: 430.19 milliseconds (33.8%)  slowest intializers :  libSystem.B.dylib : 5.88 milliseconds (0.4%)  libMainThreadChecker.dylib : 27.48 milliseconds (2.1%)  libMTLCapture.dylib : 27.02 milliseconds (2.1%)  MobileRTC : 56.87 milliseconds (4.4%)  BizConfSDK : 65.07 milliseconds (5.1%)  IpCall : 59.02 milliseconds (4.6%)  CMBMobileST : 154.11 milliseconds (12.1%)   total time: 2.7 seconds (100.0%)  total images loaded: 557 (534 from dyld shared cache)  total segments mapped: 81, into 64755 pages  total images loading time: 2.0 seconds (72.9%)  total load time in ObjC: 73.44 milliseconds (2.6%)  total debugger pause time: 1.4 seconds (53.1%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 1,113,803  total rebase fixups time: 81.83 milliseconds (2.9%)  total binding fixups: 121,283  total binding fixups time: 94.73 milliseconds (3.4%)  total weak binding fixups time: 64.70 milliseconds (2.3%)  total redo shared cached bindings time: 20.22 milliseconds (0.7%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 430.19 milliseconds (15.6%)  libSystem.B.dylib : 5.88 milliseconds (0.2%)  libBacktraceRecording.dylib : 5.67 milliseconds (0.2%)  libMainThreadChecker.dylib : 27.48 milliseconds (0.9%)  libMTLCapture.dylib : 27.02 milliseconds (0.9%)  AgoraRtcKit : 14.61 milliseconds (0.5%)  AgoraRtmKit : 6.19 milliseconds (0.2%)  MobileRTC : 56.87 milliseconds (2.0%)  BizConfSDK : 65.07 milliseconds (2.3%)  IpCall : 59.02 milliseconds (2.1%)  JMSDK : 14.98 milliseconds (0.5%)  WebRTC : 5.03 milliseconds (0.1%)  CMBMobileST : 154.11 milliseconds (5.5%) total symbol trie searches: 503902 total symbol table binary searches: 0 total images defining weak symbols: 57 total images using weak symbols: 141 Total pre-main time: 1.4 seconds (100.0%)  dylib loading time: 540.41 milliseconds (36.8%)  rebase/binding time: 318.35 milliseconds (21.7%)  ObjC setup time: 152.68 milliseconds (10.4%)  initializer time: 455.29 milliseconds (31.0%)  slowest intializers :  libSystem.B.dylib : 6.78 milliseconds (0.4%)  MobileRTC : 61.52 milliseconds (4.1%)  BizConfSDK : 62.35 milliseconds (4.2%)  IpCall : 57.71 milliseconds (3.9%)  CMBMobileST : 174.93 milliseconds (11.9%)   total time: 3.0 seconds (100.0%)  total images loaded: 557 (534 from dyld shared cache)  total segments mapped: 81, into 64755 pages  total images loading time: 2.0 seconds (68.4%)  total load time in ObjC: 152.68 milliseconds (5.0%)  total debugger pause time: 1.5 seconds (50.5%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 1,113,803  total rebase fixups time: 120.37 milliseconds (3.9%)  total binding fixups: 121,283  total binding fixups time: 151.01 milliseconds (4.9%)  total weak binding fixups time: 75.20 milliseconds (2.4%)  total redo shared cached bindings time: 28.23 milliseconds (0.9%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 455.29 milliseconds (15.0%)  libSystem.B.dylib : 6.78 milliseconds (0.2%)  libBacktraceRecording.dylib : 6.91 milliseconds (0.2%)  libMainThreadChecker.dylib : 28.52 milliseconds (0.9%)  libMTLCapture.dylib : 23.62 milliseconds (0.7%)  AgoraRtcKit : 15.54 milliseconds (0.5%)  AgoraRtmKit : 5.05 milliseconds (0.1%)  MobileRTC : 61.52 milliseconds (2.0%)  BizConfSDK : 62.35 milliseconds (2.0%)  IpCall : 57.71 milliseconds (1.9%)  JMSDK : 13.86 milliseconds (0.4%)  WebRTC : 4.13 milliseconds (0.1%)  CMBMobileST : 174.93 milliseconds (5.7%) total symbol trie searches: 503902 total symbol table binary searches: 0 total images defining weak symbols: 57 total images using weak symbols: 141 Total pre-main time: 1.4 seconds (100.0%)  dylib loading time: 554.53 milliseconds (37.5%)  rebase/binding time: 291.86 milliseconds (19.7%)  ObjC setup time: 172.99 milliseconds (11.7%)  initializer time: 458.99 milliseconds (31.0%)  slowest intializers :  libSystem.B.dylib : 6.95 milliseconds (0.4%)  MobileRTC : 62.21 milliseconds (4.2%)  BizConfSDK : 60.06 milliseconds (4.0%)  IpCall : 60.50 milliseconds (4.0%)  CMBMobileST : 171.19 milliseconds (11.5%)   total time: 3.1 seconds (100.0%)  total images loaded: 557 (534 from dyld shared cache)  total segments mapped: 81, into 64755 pages  total images loading time: 2.1 seconds (69.8%)  total load time in ObjC: 172.99 milliseconds (5.5%)  total debugger pause time: 1.6 seconds (52.1%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 1,113,803  total rebase fixups time: 85.30 milliseconds (2.7%)  total binding fixups: 121,283  total binding fixups time: 153.31 milliseconds (4.8%)  total weak binding fixups time: 74.32 milliseconds (2.3%)  total redo shared cached bindings time: 21.08 milliseconds (0.6%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 458.99 milliseconds (14.6%)  libSystem.B.dylib : 6.95 milliseconds (0.2%)  libBacktraceRecording.dylib : 7.37 milliseconds (0.2%)  libMainThreadChecker.dylib : 28.78 milliseconds (0.9%)  libMTLCapture.dylib : 27.68 milliseconds (0.8%)  AgoraRtcKit : 17.13 milliseconds (0.5%)  AgoraRtmKit : 5.18 milliseconds (0.1%)  MobileRTC : 62.21 milliseconds (1.9%)  BizConfSDK : 60.06 milliseconds (1.9%)  IpCall : 60.50 milliseconds (1.9%)  JMSDK : 12.48 milliseconds (0.3%)  WebRTC : 3.90 milliseconds (0.1%)  CMBMobileST : 171.19 milliseconds (5.4%) total symbol trie searches: 503902 total symbol table binary searches: 0 total images defining weak symbols: 57 total images using weak symbols: 141 </content>
    </entry>
    
     <entry>
        <title></title>
        <url>https://iihui.github.io/post/ios-time2/</url>
        <categories>
          
        </categories>
        <tags>
          
        </tags>
        <content type="html"> iPhone XR iOS 12.4.1 生产5.13.5 Total pre-main time: 988.59 milliseconds (100.0%)  dylib loading time: 398.75 milliseconds (40.3%)  rebase/binding time: 193.73 milliseconds (19.5%)  ObjC setup time: 90.53 milliseconds (9.1%)  initializer time: 305.29 milliseconds (30.8%)  slowest intializers :  libSystem.B.dylib : 7.61 milliseconds (0.7%)  libMainThreadChecker.dylib : 22.48 milliseconds (2.2%)  libMTLInterpose.dylib : 46.70 milliseconds (4.7%)  MobileRTC : 63.41 milliseconds (6.4%)  CMBMobile : 105.77 milliseconds (10.6%)   total time: 2.7 seconds (100.0%)  total images loaded: 483 (457 from dyld shared cache)  total segments mapped: 87, into 65168 pages with 2784 pages pre-fetched  total images loading time: 2.0 seconds (75.5%)  total load time in ObjC: 90.53 milliseconds (3.3%)  total debugger pause time: 1.6 seconds (60.8%)  total dtrace DOF registration time: 0.27 milliseconds (0.0%)  total rebase fixups: 1,098,748  total rebase fixups time: 116.72 milliseconds (4.3%)  total binding fixups: 123,358  total binding fixups time: 88.70 milliseconds (3.2%)  total weak binding fixups time: 60.65 milliseconds (2.2%)  total redo shared cached bindings time: 72.34 milliseconds (2.6%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 305.29 milliseconds (11.2%)  libSystem.B.dylib : 7.61 milliseconds (0.2%)  libBacktraceRecording.dylib : 8.13 milliseconds (0.3%)  libMainThreadChecker.dylib : 22.48 milliseconds (0.8%)  libMTLInterpose.dylib : 46.70 milliseconds (1.7%)  AgoraRtcKit : 17.19 milliseconds (0.6%)  AgoraRtmKit : 14.06 milliseconds (0.5%)  MobileRTC : 63.41 milliseconds (2.3%)  BizConfSDK : 2.73 milliseconds (0.1%)  IpCall : 5.94 milliseconds (0.2%)  JMSDK : 16.04 milliseconds (0.5%)  WebRTC : 5.83 milliseconds (0.2%)  CMBMobile : 105.77 milliseconds (3.8%) total symbol trie searches: 382888 total symbol table binary searches: 0 total images defining weak symbols: 46 total images using weak symbols: 120 Total pre-main time: 1.0 seconds (100.0%)  dylib loading time: 400.48 milliseconds (38.8%)  rebase/binding time: 209.42 milliseconds (20.2%)  ObjC setup time: 95.44 milliseconds (9.2%)  initializer time: 326.30 milliseconds (31.6%)  slowest intializers :  libSystem.B.dylib : 7.46 milliseconds (0.7%)  libMainThreadChecker.dylib : 21.81 milliseconds (2.1%)  libMTLInterpose.dylib : 68.67 milliseconds (6.6%)  AgoraRtcKit : 24.55 milliseconds (2.3%)  MobileRTC : 64.76 milliseconds (6.2%)  CMBMobile : 104.31 milliseconds (10.1%)   total time: 2.7 seconds (100.0%)  total images loaded: 483 (457 from dyld shared cache)  total segments mapped: 87, into 65168 pages with 2784 pages pre-fetched  total images loading time: 1.9 seconds (73.6%)  total load time in ObjC: 95.44 milliseconds (3.5%)  total debugger pause time: 1.5 seconds (58.8%)  total dtrace DOF registration time: 0.29 milliseconds (0.0%)  total rebase fixups: 1,098,748  total rebase fixups time: 130.44 milliseconds (4.8%)  total binding fixups: 123,358  total binding fixups time: 99.69 milliseconds (3.6%)  total weak binding fixups time: 62.08 milliseconds (2.2%)  total redo shared cached bindings time: 82.80 milliseconds (3.0%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 326.30 milliseconds (12.0%)  libSystem.B.dylib : 7.46 milliseconds (0.2%)  libBacktraceRecording.dylib : 8.28 milliseconds (0.3%)  libMainThreadChecker.dylib : 21.81 milliseconds (0.8%)  libMTLInterpose.dylib : 68.67 milliseconds (2.5%)  AgoraRtcKit : 24.55 milliseconds (0.9%)  AgoraRtmKit : 6.72 milliseconds (0.2%)  MobileRTC : 64.76 milliseconds (2.3%)  BizConfSDK : 2.84 milliseconds (0.1%)  IpCall : 5.97 milliseconds (0.2%)  JMSDK : 16.03 milliseconds (0.5%)  WebRTC : 5.85 milliseconds (0.2%)  CMBMobile : 104.31 milliseconds (3.8%) total symbol trie searches: 382888 total symbol table binary searches: 0 total images defining weak symbols: 46 total images using weak symbols: 120 Total pre-main time: 1.0 seconds (100.0%)  dylib loading time: 407.35 milliseconds (39.6%)  rebase/binding time: 211.82 milliseconds (20.6%)  ObjC setup time: 86.36 milliseconds (8.4%)  initializer time: 320.28 milliseconds (31.2%)  slowest intializers :  libSystem.B.dylib : 6.67 milliseconds (0.6%)  libMainThreadChecker.dylib : 21.57 milliseconds (2.1%)  libMTLInterpose.dylib : 67.25 milliseconds (6.5%)  AgoraRtcKit : 24.17 milliseconds (2.3%)  MobileRTC : 63.08 milliseconds (6.1%)  CMBMobile : 105.10 milliseconds (10.2%)   total time: 2.7 seconds (100.0%)  total images loaded: 483 (457 from dyld shared cache)  total segments mapped: 87, into 65168 pages with 2784 pages pre-fetched  total images loading time: 2.0 seconds (74.5%)  total load time in ObjC: 86.36 milliseconds (3.1%)  total debugger pause time: 1.6 seconds (59.6%)  total dtrace DOF registration time: 0.29 milliseconds (0.0%)  total rebase fixups: 1,098,748  total rebase fixups time: 131.29 milliseconds (4.8%)  total binding fixups: 123,358  total binding fixups time: 95.50 milliseconds (3.5%)  total weak binding fixups time: 58.38 milliseconds (2.1%)  total redo shared cached bindings time: 73.36 milliseconds (2.6%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 320.28 milliseconds (11.7%)  libSystem.B.dylib : 6.67 milliseconds (0.2%)  libBacktraceRecording.dylib : 7.99 milliseconds (0.2%)  libMainThreadChecker.dylib : 21.57 milliseconds (0.7%)  libMTLInterpose.dylib : 67.25 milliseconds (2.4%)  AgoraRtcKit : 24.17 milliseconds (0.8%)  AgoraRtmKit : 6.31 milliseconds (0.2%)  MobileRTC : 63.08 milliseconds (2.3%)  BizConfSDK : 2.82 milliseconds (0.1%)  IpCall : 5.93 milliseconds (0.2%)  JMSDK : 15.81 milliseconds (0.5%)  WebRTC : 5.85 milliseconds (0.2%)  CMBMobile : 105.10 milliseconds (3.8%) total symbol trie searches: 382888 total symbol table binary searches: 0 total images defining weak symbols: 46 total images using weak symbols: 120 Total pre-main time: 980.65 milliseconds (100.0%)  dylib loading time: 402.82 milliseconds (41.0%)  rebase/binding time: 176.97 milliseconds (18.0%)  ObjC setup time: 69.85 milliseconds (7.1%)  initializer time: 330.73 milliseconds (33.7%)  slowest intializers :  libSystem.B.dylib : 6.99 milliseconds (0.7%)  libMainThreadChecker.dylib : 21.53 milliseconds (2.1%)  libMTLInterpose.dylib : 78.58 milliseconds (8.0%)  AgoraRtcKit : 24.38 milliseconds (2.4%)  MobileRTC : 64.43 milliseconds (6.5%)  CMBMobile : 106.34 milliseconds (10.8%)   total time: 2.6 seconds (100.0%)  total images loaded: 483 (457 from dyld shared cache)  total segments mapped: 87, into 65168 pages with 2784 pages pre-fetched  total images loading time: 2.0 seconds (75.7%)  total load time in ObjC: 69.85 milliseconds (2.6%)  total debugger pause time: 1.6 seconds (60.5%)  total dtrace DOF registration time: 0.26 milliseconds (0.0%)  total rebase fixups: 1,098,748  total rebase fixups time: 103.25 milliseconds (3.9%)  total binding fixups: 123,358  total binding fixups time: 84.53 milliseconds (3.1%)  total weak binding fixups time: 53.99 milliseconds (2.0%)  total redo shared cached bindings time: 64.81 milliseconds (2.4%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 330.73 milliseconds (12.4%)  libSystem.B.dylib : 6.99 milliseconds (0.2%)  libBacktraceRecording.dylib : 3.06 milliseconds (0.1%)  libMainThreadChecker.dylib : 21.53 milliseconds (0.8%)  libMTLInterpose.dylib : 78.58 milliseconds (2.9%)  AgoraRtcKit : 24.38 milliseconds (0.9%)  AgoraRtmKit : 6.46 milliseconds (0.2%)  MobileRTC : 64.43 milliseconds (2.4%)  BizConfSDK : 2.71 milliseconds (0.1%)  IpCall : 5.66 milliseconds (0.2%)  JMSDK : 15.40 milliseconds (0.5%)  WebRTC : 5.58 milliseconds (0.2%)  CMBMobile : 106.34 milliseconds (4.0%) total symbol trie searches: 382888 total symbol table binary searches: 0 total images defining weak symbols: 46 total images using weak symbols: 120 平均时间为$\frac{2.7 &#43; 2.7 &#43; 2.7 &#43; 2.6}{4}=2.675$
生产5.15.0 Total pre-main time: 998.66 milliseconds (100.0%)  dylib loading time: 377.08 milliseconds (37.7%)  rebase/binding time: 190.83 milliseconds (19.1%)  ObjC setup time: 89.32 milliseconds (8.9%)  initializer time: 341.15 milliseconds (34.1%)  slowest intializers :  libSystem.B.dylib : 7.43 milliseconds (0.7%)  libMainThreadChecker.dylib : 21.45 milliseconds (2.1%)  libMTLInterpose.dylib : 87.04 milliseconds (8.7%)  MobileRTC : 64.61 milliseconds (6.4%)  CMBMobile : 101.19 milliseconds (10.1%)   total time: 2.4 seconds (100.0%)  total images loaded: 482 (457 from dyld shared cache)  total segments mapped: 83, into 65140 pages with 2776 pages pre-fetched  total images loading time: 1.7 seconds (72.3%)  total load time in ObjC: 89.32 milliseconds (3.6%)  total debugger pause time: 1.3 seconds (56.7%)  total dtrace DOF registration time: 0.26 milliseconds (0.0%)  total rebase fixups: 1,100,134  total rebase fixups time: 109.98 milliseconds (4.5%)  total binding fixups: 123,420  total binding fixups time: 82.80 milliseconds (3.4%)  total weak binding fixups time: 48.23 milliseconds (1.9%)  total redo shared cached bindings time: 50.18 milliseconds (2.0%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 341.15 milliseconds (14.0%)  libSystem.B.dylib : 7.43 milliseconds (0.3%)  libBacktraceRecording.dylib : 8.16 milliseconds (0.3%)  libMainThreadChecker.dylib : 21.45 milliseconds (0.8%)  libMTLInterpose.dylib : 87.04 milliseconds (3.5%)  AgoraRtcKit : 17.86 milliseconds (0.7%)  AgoraRtcCryptoLoader : 7.27 milliseconds (0.2%)  AgoraRtmKit : 6.70 milliseconds (0.2%)  MobileRTC : 64.61 milliseconds (2.6%)  BizConfSDK : 2.83 milliseconds (0.1%)  IpCall : 5.53 milliseconds (0.2%)  JMSDK : 15.62 milliseconds (0.6%)  WebRTC : 6.06 milliseconds (0.2%)  CMBMobile : 101.19 milliseconds (4.1%) total symbol trie searches: 382644 total symbol table binary searches: 0 total images defining weak symbols: 46 total images using weak symbols: 120 Total pre-main time: 979.67 milliseconds (100.0%)  dylib loading time: 389.13 milliseconds (39.7%)  rebase/binding time: 183.88 milliseconds (18.7%)  ObjC setup time: 94.66 milliseconds (9.6%)  initializer time: 311.69 milliseconds (31.8%)  slowest intializers :  libSystem.B.dylib : 6.61 milliseconds (0.6%)  libMainThreadChecker.dylib : 21.54 milliseconds (2.1%)  libMTLInterpose.dylib : 62.83 milliseconds (6.4%)  AgoraRtcKit : 23.62 milliseconds (2.4%)  MobileRTC : 63.52 milliseconds (6.4%)  CMBMobile : 98.84 milliseconds (10.0%)   total time: 2.1 seconds (100.0%)  total images loaded: 482 (457 from dyld shared cache)  total segments mapped: 83, into 65140 pages with 2776 pages pre-fetched  total images loading time: 1.4 seconds (68.5%)  total load time in ObjC: 94.66 milliseconds (4.4%)  total debugger pause time: 1.0 seconds (50.0%)  total dtrace DOF registration time: 0.28 milliseconds (0.0%)  total rebase fixups: 1,100,134  total rebase fixups time: 103.16 milliseconds (4.8%)  total binding fixups: 123,420  total binding fixups time: 94.30 milliseconds (4.4%)  total weak binding fixups time: 58.66 milliseconds (2.7%)  total redo shared cached bindings time: 72.25 milliseconds (3.4%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 311.69 milliseconds (14.7%)  libSystem.B.dylib : 6.61 milliseconds (0.3%)  libBacktraceRecording.dylib : 8.45 milliseconds (0.4%)  libMainThreadChecker.dylib : 21.54 milliseconds (1.0%)  libMTLInterpose.dylib : 62.83 milliseconds (2.9%)  AgoraRtcKit : 23.62 milliseconds (1.1%)  AgoraRtmKit : 6.42 milliseconds (0.3%)  MobileRTC : 63.52 milliseconds (3.0%)  BizConfSDK : 2.37 milliseconds (0.1%)  IpCall : 5.50 milliseconds (0.2%)  JMSDK : 15.23 milliseconds (0.7%)  WebRTC : 5.49 milliseconds (0.2%)  CMBMobile : 98.84 milliseconds (4.6%) total symbol trie searches: 382644 total symbol table binary searches: 0 total images defining weak symbols: 46 total images using weak symbols: 120 Total pre-main time: 975.95 milliseconds (100.0%)  dylib loading time: 379.60 milliseconds (38.8%)  rebase/binding time: 189.22 milliseconds (19.3%)  ObjC setup time: 90.73 milliseconds (9.2%)  initializer time: 316.10 milliseconds (32.3%)  slowest intializers :  libSystem.B.dylib : 6.75 milliseconds (0.6%)  libMainThreadChecker.dylib : 21.55 milliseconds (2.2%)  libMTLInterpose.dylib : 65.58 milliseconds (6.7%)  AgoraRtcKit : 24.17 milliseconds (2.4%)  MobileRTC : 63.31 milliseconds (6.4%)  CMBMobile : 99.15 milliseconds (10.1%)   total time: 2.0 seconds (100.0%)  total images loaded: 482 (457 from dyld shared cache)  total segments mapped: 83, into 65140 pages with 2776 pages pre-fetched  total images loading time: 1.4 seconds (67.9%)  total load time in ObjC: 90.73 milliseconds (4.3%)  total debugger pause time: 1.0 seconds (49.7%)  total dtrace DOF registration time: 0.29 milliseconds (0.0%)  total rebase fixups: 1,100,134  total rebase fixups time: 124.21 milliseconds (5.9%)  total binding fixups: 123,420  total binding fixups time: 84.90 milliseconds (4.0%)  total weak binding fixups time: 53.41 milliseconds (2.5%)  total redo shared cached bindings time: 73.32 milliseconds (3.5%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 316.10 milliseconds (15.1%)  libSystem.B.dylib : 6.75 milliseconds (0.3%)  libBacktraceRecording.dylib : 8.05 milliseconds (0.3%)  libMainThreadChecker.dylib : 21.55 milliseconds (1.0%)  libMTLInterpose.dylib : 65.58 milliseconds (3.1%)  AgoraRtcKit : 24.17 milliseconds (1.1%)  AgoraRtmKit : 6.76 milliseconds (0.3%)  MobileRTC : 63.31 milliseconds (3.0%)  BizConfSDK : 2.67 milliseconds (0.1%)  IpCall : 5.65 milliseconds (0.2%)  JMSDK : 15.10 milliseconds (0.7%)  WebRTC : 5.84 milliseconds (0.2%)  CMBMobile : 99.15 milliseconds (4.7%) total symbol trie searches: 382644 total symbol table binary searches: 0 total images defining weak symbols: 46 total images using weak symbols: 120 Total pre-main time: 938.42 milliseconds (100.0%)  dylib loading time: 387.22 milliseconds (41.2%)  rebase/binding time: 173.66 milliseconds (18.5%)  ObjC setup time: 66.84 milliseconds (7.1%)  initializer time: 310.41 milliseconds (33.0%)  slowest intializers :  libSystem.B.dylib : 7.08 milliseconds (0.7%)  libMainThreadChecker.dylib : 21.29 milliseconds (2.2%)  libMTLInterpose.dylib : 63.90 milliseconds (6.8%)  AgoraRtcKit : 24.36 milliseconds (2.5%)  MobileRTC : 65.02 milliseconds (6.9%)  CMBMobile : 98.40 milliseconds (10.4%)   total time: 2.4 seconds (100.0%)  total images loaded: 482 (457 from dyld shared cache)  total segments mapped: 83, into 65140 pages with 2776 pages pre-fetched  total images loading time: 1.8 seconds (74.6%)  total load time in ObjC: 66.84 milliseconds (2.7%)  total debugger pause time: 1.4 seconds (58.6%)  total dtrace DOF registration time: 0.27 milliseconds (0.0%)  total rebase fixups: 1,100,134  total rebase fixups time: 95.45 milliseconds (3.9%)  total binding fixups: 123,420  total binding fixups time: 94.01 milliseconds (3.8%)  total weak binding fixups time: 48.90 milliseconds (2.0%)  total redo shared cached bindings time: 64.71 milliseconds (2.6%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 310.41 milliseconds (12.7%)  libSystem.B.dylib : 7.08 milliseconds (0.2%)  libBacktraceRecording.dylib : 3.19 milliseconds (0.1%)  libMainThreadChecker.dylib : 21.29 milliseconds (0.8%)  libMTLInterpose.dylib : 63.90 milliseconds (2.6%)  AgoraRtcKit : 24.36 milliseconds (1.0%)  AgoraRtmKit : 6.64 milliseconds (0.2%)  MobileRTC : 65.02 milliseconds (2.6%)  BizConfSDK : 2.80 milliseconds (0.1%)  IpCall : 5.62 milliseconds (0.2%)  JMSDK : 16.70 milliseconds (0.6%)  WebRTC : 5.38 milliseconds (0.2%)  CMBMobile : 98.40 milliseconds (4.0%) total symbol trie searches: 382644 total symbol table binary searches: 0 total images defining weak symbols: 46 total images using weak symbols: 120 平均时间为$\frac{2.4 &#43; 2.1 &#43; 2.0 &#43; 2.4}{4}=2.225$
对比 减少的平均时间为： $2.675 - 2.225 = 0.45$
iPhone XS Max iOS 13.7 生产5.13.5 Total pre-main time: 1.7 seconds (100.0%)  dylib loading time: 538.86 milliseconds (30.3%)  rebase/binding time: 386.41 milliseconds (21.7%)  ObjC setup time: 299.19 milliseconds (16.8%)  initializer time: 552.60 milliseconds (31.0%)  slowest intializers :  libSystem.B.dylib : 10.53 milliseconds (0.5%)  libMainThreadChecker.dylib : 39.12 milliseconds (2.2%)  MobileRTC : 152.32 milliseconds (8.5%)  BizConfSDK : 63.59 milliseconds (3.5%)  IpCall : 61.52 milliseconds (3.4%)  CMBMobile : 131.41 milliseconds (7.3%)   total time: 3.4 seconds (100.0%)  total images loaded: 558 (534 from dyld shared cache)  total segments mapped: 85, into 64783 pages  total images loading time: 2.1 seconds (63.3%)  total load time in ObjC: 299.19 milliseconds (8.6%)  total debugger pause time: 1.6 seconds (47.6%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 1,098,748  total rebase fixups time: 79.97 milliseconds (2.3%)  total binding fixups: 120,035  total binding fixups time: 254.60 milliseconds (7.3%)  total weak binding fixups time: 76.79 milliseconds (2.2%)  total redo shared cached bindings time: 24.96 milliseconds (0.7%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 552.60 milliseconds (16.0%)  libSystem.B.dylib : 10.53 milliseconds (0.3%)  libBacktraceRecording.dylib : 7.90 milliseconds (0.2%)  libMainThreadChecker.dylib : 39.12 milliseconds (1.1%)  libMTLCapture.dylib : 32.83 milliseconds (0.9%)  AgoraRtcKit : 31.18 milliseconds (0.9%)  AgoraRtmKit : 9.97 milliseconds (0.2%)  MobileRTC : 152.32 milliseconds (4.4%)  BizConfSDK : 63.59 milliseconds (1.8%)  IpCall : 61.52 milliseconds (1.7%)  JMSDK : 12.56 milliseconds (0.3%)  WebRTC : 4.45 milliseconds (0.1%)  CMBMobile : 131.41 milliseconds (3.8%) total symbol trie searches: 503950 total symbol table binary searches: 0 total images defining weak symbols: 57 total images using weak symbols: 141 Total pre-main time: 2.3 seconds (100.0%)  dylib loading time: 747.96 milliseconds (31.2%)  rebase/binding time: 618.27 milliseconds (25.8%)  ObjC setup time: 373.84 milliseconds (15.6%)  initializer time: 656.13 milliseconds (27.3%)  slowest intializers :  libSystem.B.dylib : 8.10 milliseconds (0.3%)  libMTLCapture.dylib : 55.58 milliseconds (2.3%)  MobileRTC : 156.67 milliseconds (6.5%)  BizConfSDK : 60.21 milliseconds (2.5%)  IpCall : 63.94 milliseconds (2.6%)  CMBMobile : 192.94 milliseconds (8.0%)   total time: 4.0 seconds (100.0%)  total images loaded: 558 (534 from dyld shared cache)  total segments mapped: 85, into 64783 pages  total images loading time: 2.3 seconds (58.2%)  total load time in ObjC: 373.84 milliseconds (9.1%)  total debugger pause time: 1.6 seconds (39.9%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 1,098,748  total rebase fixups time: 202.48 milliseconds (4.9%)  total binding fixups: 120,035  total binding fixups time: 384.18 milliseconds (9.3%)  total weak binding fixups time: 89.98 milliseconds (2.2%)  total redo shared cached bindings time: 58.38 milliseconds (1.4%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 656.13 milliseconds (16.0%)  libSystem.B.dylib : 8.10 milliseconds (0.1%)  libBacktraceRecording.dylib : 8.00 milliseconds (0.1%)  libMainThreadChecker.dylib : 40.82 milliseconds (0.9%)  libMTLCapture.dylib : 55.58 milliseconds (1.3%)  AgoraRtcKit : 34.51 milliseconds (0.8%)  AgoraRtmKit : 8.66 milliseconds (0.2%)  MobileRTC : 156.67 milliseconds (3.8%)  BizConfSDK : 60.21 milliseconds (1.4%)  IpCall : 63.94 milliseconds (1.5%)  JMSDK : 29.88 milliseconds (0.7%)  WebRTC : 14.61 milliseconds (0.3%)  CMBMobile : 192.94 milliseconds (4.7%) total symbol trie searches: 503950 total symbol table binary searches: 0 total images defining weak symbols: 57 total images using weak symbols: 141 Total pre-main time: 1.5 seconds (100.0%)  dylib loading time: 608.31 milliseconds (38.7%)  rebase/binding time: 352.50 milliseconds (22.4%)  ObjC setup time: 194.75 milliseconds (12.3%)  initializer time: 415.46 milliseconds (26.4%)  slowest intializers :  libSystem.B.dylib : 10.21 milliseconds (0.6%)  libMainThreadChecker.dylib : 39.52 milliseconds (2.5%)  libMTLCapture.dylib : 37.90 milliseconds (2.4%)  MobileRTC : 66.16 milliseconds (4.2%)  BizConfSDK : 58.92 milliseconds (3.7%)  IpCall : 63.56 milliseconds (4.0%)  CMBMobile : 98.79 milliseconds (6.2%)   total time: 3.3 seconds (100.0%)  total images loaded: 558 (534 from dyld shared cache)  total segments mapped: 85, into 64783 pages  total images loading time: 2.3 seconds (69.4%)  total load time in ObjC: 194.75 milliseconds (5.8%)  total debugger pause time: 1.6 seconds (51.1%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 1,098,748  total rebase fixups time: 81.83 milliseconds (2.4%)  total binding fixups: 120,035  total binding fixups time: 243.88 milliseconds (7.3%)  total weak binding fixups time: 77.43 milliseconds (2.3%)  total redo shared cached bindings time: 50.65 milliseconds (1.5%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 415.46 milliseconds (12.5%)  libSystem.B.dylib : 10.21 milliseconds (0.3%)  libBacktraceRecording.dylib : 7.89 milliseconds (0.2%)  libMainThreadChecker.dylib : 39.52 milliseconds (1.1%)  libMTLCapture.dylib : 37.90 milliseconds (1.1%)  AgoraRtcKit : 15.02 milliseconds (0.4%)  AgoraRtmKit : 5.78 milliseconds (0.1%)  MobileRTC : 66.16 milliseconds (1.9%)  BizConfSDK : 58.92 milliseconds (1.7%)  IpCall : 63.56 milliseconds (1.9%)  JMSDK : 15.42 milliseconds (0.4%)  WebRTC : 5.25 milliseconds (0.1%)  CMBMobile : 98.79 milliseconds (2.9%) total symbol trie searches: 503950 total symbol table binary searches: 0 total images defining weak symbols: 57 total images using weak symbols: 141 Total pre-main time: 1.6 seconds (100.0%)  dylib loading time: 583.22 milliseconds (35.5%)  rebase/binding time: 367.29 milliseconds (22.4%)  ObjC setup time: 241.65 milliseconds (14.7%)  initializer time: 447.02 milliseconds (27.2%)  slowest intializers :  libSystem.B.dylib : 7.51 milliseconds (0.4%)  libMainThreadChecker.dylib : 40.62 milliseconds (2.4%)  MobileRTC : 86.49 milliseconds (5.2%)  BizConfSDK : 63.20 milliseconds (3.8%)  IpCall : 67.52 milliseconds (4.1%)  CMBMobile : 102.96 milliseconds (6.2%)   total time: 3.4 seconds (100.0%)  total images loaded: 557 (534 from dyld shared cache)  total segments mapped: 81, into 64755 pages  total images loading time: 2.3 seconds (68.2%)  total load time in ObjC: 241.65 milliseconds (7.0%)  total debugger pause time: 1.7 seconds (51.2%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 1,100,134  total rebase fixups time: 84.65 milliseconds (2.4%)  total binding fixups: 120,097  total binding fixups time: 242.86 milliseconds (7.0%)  total weak binding fixups time: 80.28 milliseconds (2.3%)  total redo shared cached bindings time: 40.51 milliseconds (1.1%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 447.02 milliseconds (12.9%)  libSystem.B.dylib : 7.51 milliseconds (0.2%)  libBacktraceRecording.dylib : 7.84 milliseconds (0.2%)  libMainThreadChecker.dylib : 40.62 milliseconds (1.1%)  libMTLCapture.dylib : 30.38 milliseconds (0.8%)  AgoraRtcKit : 20.38 milliseconds (0.5%)  AgoraRtmKit : 6.56 milliseconds (0.1%)  MobileRTC : 86.49 milliseconds (2.5%)  BizConfSDK : 63.20 milliseconds (1.8%)  IpCall : 67.52 milliseconds (1.9%)  JMSDK : 15.31 milliseconds (0.4%)  WebRTC : 5.14 milliseconds (0.1%)  CMBMobile : 102.96 milliseconds (2.9%) total symbol trie searches: 503716 total symbol table binary searches: 0 total images defining weak symbols: 57 total images using weak symbols: 141 平均时间为$\frac{3.4 &#43; 4.0 &#43; 3.3 &#43; 3.3}{4}=3.5$
生产 5.15.0 Total pre-main time: 1.7 seconds (100.0%)  dylib loading time: 610.90 milliseconds (35.6%)  rebase/binding time: 421.77 milliseconds (24.6%)  ObjC setup time: 251.74 milliseconds (14.6%)  initializer time: 429.44 milliseconds (25.0%)  slowest intializers :  libSystem.B.dylib : 9.62 milliseconds (0.5%)  libMainThreadChecker.dylib : 39.94 milliseconds (2.3%)  MobileRTC : 72.81 milliseconds (4.2%)  BizConfSDK : 62.33 milliseconds (3.6%)  IpCall : 55.15 milliseconds (3.2%)  CMBMobile : 116.89 milliseconds (6.8%)   total time: 2.8 seconds (100.0%)  total images loaded: 557 (534 from dyld shared cache)  total segments mapped: 81, into 64755 pages  total images loading time: 1.7 seconds (60.8%)  total load time in ObjC: 251.74 milliseconds (8.7%)  total debugger pause time: 1.1 seconds (39.5%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 1,100,134  total rebase fixups time: 133.16 milliseconds (4.6%)  total binding fixups: 120,097  total binding fixups time: 227.59 milliseconds (7.9%)  total weak binding fixups time: 83.02 milliseconds (2.8%)  total redo shared cached bindings time: 22.02 milliseconds (0.7%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 429.44 milliseconds (14.9%)  libSystem.B.dylib : 9.62 milliseconds (0.3%)  libBacktraceRecording.dylib : 7.84 milliseconds (0.2%)  libMainThreadChecker.dylib : 39.94 milliseconds (1.3%)  libMTLCapture.dylib : 26.46 milliseconds (0.9%)  AgoraCore : 4.00 milliseconds (0.1%)  AgoraRtcKit : 16.55 milliseconds (0.5%)  AgoraRtmKit : 5.86 milliseconds (0.2%)  MobileRTC : 72.81 milliseconds (2.5%)  BizConfSDK : 62.33 milliseconds (2.1%)  IpCall : 55.15 milliseconds (1.9%)  JMSDK : 12.39 milliseconds (0.4%)  WebRTC : 4.03 milliseconds (0.1%)  CMBMobile : 116.89 milliseconds (4.0%) total symbol trie searches: 503716 total symbol table binary searches: 0 total images defining weak symbols: 57 total images using weak symbols: 141 Total pre-main time: 1.9 seconds (100.0%)  dylib loading time: 587.96 milliseconds (30.3%)  rebase/binding time: 512.29 milliseconds (26.4%)  ObjC setup time: 358.45 milliseconds (18.5%)  initializer time: 475.87 milliseconds (24.5%)  slowest intializers :  libSystem.B.dylib : 10.61 milliseconds (0.5%)  libMainThreadChecker.dylib : 38.87 milliseconds (2.0%)  libMTLCapture.dylib : 40.14 milliseconds (2.0%)  MobileRTC : 71.93 milliseconds (3.7%)  BizConfSDK : 59.30 milliseconds (3.0%)  IpCall : 62.98 milliseconds (3.2%)  CMBMobile : 125.07 milliseconds (6.4%)   total time: 3.6 seconds (100.0%)  total images loaded: 557 (534 from dyld shared cache)  total segments mapped: 81, into 64755 pages  total images loading time: 2.2 seconds (61.7%)  total load time in ObjC: 358.45 milliseconds (9.8%)  total debugger pause time: 1.6 seconds (45.6%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 1,100,134  total rebase fixups time: 137.06 milliseconds (3.7%)  total binding fixups: 120,097  total binding fixups time: 344.98 milliseconds (9.4%)  total weak binding fixups time: 78.39 milliseconds (2.1%)  total redo shared cached bindings time: 48.13 milliseconds (1.3%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 475.87 milliseconds (13.0%)  libSystem.B.dylib : 10.61 milliseconds (0.2%)  libBacktraceRecording.dylib : 7.84 milliseconds (0.2%)  libMainThreadChecker.dylib : 38.87 milliseconds (1.0%)  libMTLCapture.dylib : 40.14 milliseconds (1.1%)  AgoraRtcKit : 17.49 milliseconds (0.4%)  AgoraRtmKit : 17.02 milliseconds (0.4%)  MobileRTC : 71.93 milliseconds (1.9%)  BizConfSDK : 59.30 milliseconds (1.6%)  IpCall : 62.98 milliseconds (1.7%)  JMSDK : 17.47 milliseconds (0.4%)  WebRTC : 15.85 milliseconds (0.4%)  CMBMobile : 125.07 milliseconds (3.4%) total symbol trie searches: 503716 total symbol table binary searches: 0 total images defining weak symbols: 57 total images using weak symbols: 141 Total pre-main time: 1.5 seconds (100.0%)  dylib loading time: 553.58 milliseconds (36.1%)  rebase/binding time: 335.97 milliseconds (21.9%)  ObjC setup time: 183.34 milliseconds (11.9%)  initializer time: 459.07 milliseconds (29.9%)  slowest intializers :  libSystem.B.dylib : 7.34 milliseconds (0.4%)  libMainThreadChecker.dylib : 40.71 milliseconds (2.6%)  MobileRTC : 78.70 milliseconds (5.1%)  BizConfSDK : 62.17 milliseconds (4.0%)  IpCall : 58.73 milliseconds (3.8%)  CMBMobile : 136.18 milliseconds (8.8%)   total time: 3.2 seconds (100.0%)  total images loaded: 557 (534 from dyld shared cache)  total segments mapped: 81, into 64755 pages  total images loading time: 2.2 seconds (68.9%)  total load time in ObjC: 183.34 milliseconds (5.6%)  total debugger pause time: 1.6 seconds (51.7%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 1,100,646  total rebase fixups time: 79.73 milliseconds (2.4%)  total binding fixups: 120,109  total binding fixups time: 203.13 milliseconds (6.3%)  total weak binding fixups time: 76.69 milliseconds (2.3%)  total redo shared cached bindings time: 23.59 milliseconds (0.7%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 459.07 milliseconds (14.2%)  libSystem.B.dylib : 7.34 milliseconds (0.2%)  libBacktraceRecording.dylib : 7.86 milliseconds (0.2%)  libMainThreadChecker.dylib : 40.71 milliseconds (1.2%)  libMTLCapture.dylib : 24.64 milliseconds (0.7%)  AgoraRtcKit : 19.54 milliseconds (0.6%)  AgoraRtmKit : 7.21 milliseconds (0.2%)  MobileRTC : 78.70 milliseconds (2.4%)  BizConfSDK : 62.17 milliseconds (1.9%)  IpCall : 58.73 milliseconds (1.8%)  JMSDK : 12.57 milliseconds (0.3%)  WebRTC : 3.95 milliseconds (0.1%)  CMBMobile : 136.18 milliseconds (4.2%) total symbol trie searches: 503800 total symbol table binary searches: 0 total images defining weak symbols: 57 total images using weak symbols: 141 Total pre-main time: 1.5 seconds (100.0%)  dylib loading time: 581.62 milliseconds (37.2%)  rebase/binding time: 333.46 milliseconds (21.3%)  ObjC setup time: 225.84 milliseconds (14.4%)  initializer time: 421.27 milliseconds (26.9%)  slowest intializers :  libSystem.B.dylib : 7.83 milliseconds (0.5%)  libMainThreadChecker.dylib : 40.75 milliseconds (2.6%)  MobileRTC : 71.13 milliseconds (4.5%)  BizConfSDK : 65.07 milliseconds (4.1%)  IpCall : 60.22 milliseconds (3.8%)  CMBMobile : 97.62 milliseconds (6.2%)   total time: 2.7 seconds (100.0%)  total images loaded: 557 (534 from dyld shared cache)  total segments mapped: 81, into 64755 pages  total images loading time: 1.7 seconds (64.0%)  total load time in ObjC: 225.84 milliseconds (8.1%)  total debugger pause time: 1.2 seconds (43.2%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 1,100,134  total rebase fixups time: 81.05 milliseconds (2.9%)  total binding fixups: 120,097  total binding fixups time: 193.15 milliseconds (6.9%)  total weak binding fixups time: 80.13 milliseconds (2.8%)  total redo shared cached bindings time: 20.88 milliseconds (0.7%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 421.27 milliseconds (15.1%)  libSystem.B.dylib : 7.83 milliseconds (0.2%)  libBacktraceRecording.dylib : 7.84 milliseconds (0.2%)  libMainThreadChecker.dylib : 40.75 milliseconds (1.4%)  libMTLCapture.dylib : 30.70 milliseconds (1.1%)  AgoraRtcKit : 17.91 milliseconds (0.6%)  AgoraRtmKit : 5.47 milliseconds (0.1%)  MobileRTC : 71.13 milliseconds (2.5%)  BizConfSDK : 65.07 milliseconds (2.3%)  IpCall : 60.22 milliseconds (2.1%)  JMSDK : 13.56 milliseconds (0.4%)  WebRTC : 3.95 milliseconds (0.1%)  CMBMobile : 97.62 milliseconds (3.5%) total symbol trie searches: 503716 total symbol table binary searches: 0 total images defining weak symbols: 57 total images using weak symbols: 141 平均时间为$\frac{2.8 &#43; 3.6 &#43; 3.2 &#43; 2.7}{4}=3.075$
对比 减少的平均时间为： $3.5 - 3.075 = 0.425$
</content>
    </entry>
    
     <entry>
        <title></title>
        <url>https://iihui.github.io/post/ios-time3/</url>
        <categories>
          
        </categories>
        <tags>
          
        </tags>
        <content type="html"> iPhone XR iOS 12.4.1 招乎5.13.5 5.13.5启动时间viewDidAppear为:1.226625919342041秒 5.13.5启动时间viewDidAppear为:1.2704359292984009秒 5.13.5启动时间viewDidAppear为:1.3160110712051392秒 5.13.5启动时间viewDidAppear为:1.1432379484176636秒 5.13.5启动时间viewDidAppear为:1.396178960800171秒 5.13.5启动时间viewDidAppear为:1.7251869440078735秒 平均时间为$(1.2266 &#43; 1.2704&#43; 1.3160 &#43; 1.1432 &#43; 1.3961 &#43; 1.7251)/6 = 1.346233$
招乎5.15.1 5.15.1启动时间viewDidAppear为:1.0555500984191895秒 5.15.1启动时间viewDidAppear为:0.5557539463043213秒 5.15.1启动时间viewDidAppear为:0.5732530355453491秒 5.15.1启动时间viewDidAppear为:0.6849340200424194秒 5.15.1启动时间viewDidAppear为:0.8058780431747437秒 5.15.1启动时间viewDidAppear为:0.5669820308685303秒 平均时间为(1.0555 &#43; 0.5557&#43; 0.5732 &#43; 0.6849 &#43; 0.8058 &#43; 0.56698)/6 = 0.70701
平均减少时间 平均减少时间为：$(1.346233 - 0.70701) = 0.639223$
iPhone XS Max iOS 13.7 招乎5.13.5 5.13.5启动时间viewDidAppear为:3.4725890159606934秒 5.13.5启动时间viewDidAppear为:5.468455076217651秒 5.13.5启动时间viewDidAppear为:3.571161985397339秒 5.13.5启动时间viewDidAppear为:3.682090997695923秒 5.13.5启动时间viewDidAppear为:2.239575982093811秒 平均时间为: $(3.4725&#43;5.4684&#43;3.5711&#43;3.6820&#43;2.2395)/5 = 3.686699$
招乎5.15.1 5.15.1启动时间viewDidAppear为:4.324195981025696秒 5.15.1启动时间viewDidAppear为:2.09130597114563秒 5.15.1启动时间viewDidAppear为:1.827226996421814秒 5.15.1启动时间viewDidAppear为:2.4541349411010742秒 5.15.1启动时间viewDidAppear为:2.442926049232483秒 平均时间为: $(4.3241 &#43; 2.0913 &#43; 1.82722&#43; 2.4541 &#43; 2.4429)/5 = 2.627924$
平均减少时间 平均减少时间为：$(3.686699 - 2.627924) = 1.0587$
iPhone 11 iOS 15.1 招乎5.13.5 启动时间viewDidAppear为:2.2245479822158813秒 启动时间viewDidAppear为:2.2333680391311646秒 启动时间viewDidAppear为:2.1755470037460327秒 启动时间viewDidAppear为:2.305835008621216秒 平均时间为$(2.2245&#43;2.2333&#43;2.17554&#43;2.3058)/4 = 2.234785$
招乎5.15.1 启动时间viewDidAppear为:1.6123250722885132秒 启动时间viewDidAppear为:1.6050660610198975秒 启动时间viewDidAppear为:1.6825041055679321秒 启动时间viewDidAppear为:1.5587329864501953秒 平均时间为$(1.6123&#43;1.6050&#43;1.6825&#43;1.5587)/4 = 1.614625$
平均减少时间 平均减少时间为:$(2.234785 - 1.614625) = 0.62016$
</content>
    </entry>
    
</search>