<search>
    
     <entry>
        <title>Hugo Next 主题</title>
        <url>https://iihui.github.io/post/hugo-next/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>hugo</tag><tag>next</tag>
        </tags>
        <content type="html">  从兰陵子处下载了Next主题，修改了主题目录下的config.toml配置文件(配置文件路径为themes/next/config.toml)。但发现有很多地方还是需要修改才能满足自己的需求，对前端了解较少，以此为记。
 修改主题 首先从这里下载Next主题,并将其放入themes目录下，然后在与themes同级的全局配置文件config.toml文件中添加：
Theme = &amp;#34;next&amp;#34; 添加代码高亮 插入Golang、Swift和Objective-C代码段时发现并不能正常高亮，查资料发现是Next主题默认不支持这几种语言的语法高亮，因此需要在themes/next/layouts/partials/head.html文件中的&amp;lt;/head&amp;gt;前添加如下代码：
 &amp;lt;link href=&amp;#34;https://cdn.bootcss.com/highlight.js/9.12.0/styles/monokai-sublime.min.css&amp;#34; rel=&amp;#34;stylesheet&amp;#34;&amp;gt;  &amp;lt;script src=&amp;#34;https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt;  &amp;lt;script src=&amp;#34;https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/go.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt;  &amp;lt;script src=&amp;#34;https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/swift.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt;  &amp;lt;script src=&amp;#34;https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/yaml.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt;  &amp;lt;script src=&amp;#34;https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/kotlin.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt;  &amp;lt;script&amp;gt;hljs.initHighlightingOnLoad();&amp;lt;/script&amp;gt; 添加底部声明 默认情况下底部声明以及微信打赏码是没有的。为了显示底部声明以及微信打赏码这些，首先必须修改themes/next/layouts/partials/widgets/weixin.html文件，添加创作共享声明和微信打赏：
&amp;lt;div class=&amp;#34;post-nav&amp;#34;&amp;gt;  &amp;lt;div style=&amp;#34;border: 1px dashed #e0e0e0; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;&amp;#34;&amp;gt;  &amp;lt;div style=&amp;#34;float:left;margin-top:0px;&amp;#34;&amp;gt;  &amp;lt;img src=&amp;#34;https://i.loli.net/2018/12/16/5c15cbd7f2b61.jpg&amp;#34; width=&amp;#34;128px&amp;#34; height=&amp;#34;128px&amp;#34;/&amp;gt;  &amp;lt;div style=&amp;#34;text-align:center;&amp;#34;&amp;gt;谢谢支持!&amp;lt;/div&amp;gt;  &amp;lt;/div&amp;gt;  &amp;lt;div&amp;gt;  &amp;lt;p style=&amp;#34;margin-top:10px;&amp;#34;&amp;gt;  标题：{{ .Title }}  &amp;lt;br /&amp;gt;作者：阿呆&amp;lt;a target=&amp;#34;_blank&amp;#34; href=&amp;#34;/&amp;#34;&amp;gt;{{ .Site.Author.name }}&amp;lt;/a&amp;gt;  &amp;lt;br /&amp;gt;地址：{{ .Permalink }}  &amp;lt;br /&amp;gt;声明：自由转载-非商用-保持署名（创作共享3.0许可证）  &amp;lt;/p&amp;gt;  &amp;lt;/div&amp;gt;  &amp;lt;/div&amp;gt;  &amp;lt;div class=&amp;#34;clear&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; 然后在themes/next/layouts/_default/single.html中添加 {{ partial &amp;quot;widgets/weixin.html&amp;quot; .}}，如下图所示：
经过上面的两个步骤，就可以添加创作共享和微信打赏，效果如下：
删除文章列表之间的横线 Next主题默认首页文章列表之间有条横线，看着觉得挺别扭的，找了一下资料，发现可以在themes/next/static/css/main.css文件中将.posts-expand .post-eof中的height设为0：
.posts-expand .post-eof {  display: block;  margin: 50px auto 10px;  width: 100%;  height: 0px;  background: #ccc;  text-align: center; } 修改文章列表信息 首页展示的文章列表中，每篇文章的信息展示如下图所示： 但是我想改成下面这样：
首先在themes/next/i18n/zh.yaml中做如下修改：
- id: Time  translation: 创建 - id: TimeUpdated  translation: 更新 - id: View  translation: 字数 - id: ReadMore  translation: 阅读全文 - id: ViewTime  translation: 时长 - id: ReadingTime  translation: &amp;#34;{{ .ReadingTime }} 分钟&amp;#34; - id: NumberOfText  translation: &amp;#34;{{ .WordCount }}字&amp;#34; 然后在themes/next/layouts/partials/post/readtime.html中做如下修改：
&amp;lt;span&amp;gt; &amp;amp;nbsp; | &amp;amp;nbsp; &amp;lt;span class=&amp;#34;post-meta-item-icon&amp;#34;&amp;gt;  &amp;lt;i class=&amp;#34;fa fa-file-word-o&amp;#34;&amp;gt;&amp;lt;/i&amp;gt; &amp;lt;/span&amp;gt; &amp;lt;span class=&amp;#34;post-meta-item-text&amp;#34;&amp;gt;{{ i18n &amp;#34;View&amp;#34; }}{{ i18n &amp;#34;Colon&amp;#34;}}&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;#34;leancloud-visitors-count&amp;#34;&amp;gt;{{ i18n &amp;#34;ReadingCount&amp;#34; .}}&amp;lt;/span&amp;gt; &amp;amp;nbsp; | &amp;amp;nbsp; &amp;lt;span class=&amp;#34;post-meta-item-icon&amp;#34;&amp;gt;  &amp;lt;i class=&amp;#34;fa fa-coffee&amp;#34;&amp;gt;&amp;lt;/i&amp;gt; &amp;lt;/span&amp;gt; &amp;lt;span class=&amp;#34;post-meta-item-text&amp;#34;&amp;gt;{{ i18n &amp;#34;ViewTime&amp;#34; }}{{ i18n &amp;#34;Colon&amp;#34;}}&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;#34;leancloud-visitors-count&amp;#34;&amp;gt;{{ i18n &amp;#34;ReadingTime&amp;#34; .}}&amp;lt;/span&amp;gt; &amp;lt;/span&amp;gt; 修改左侧菜单栏的顺序 左侧菜单栏的顺序，需要通过修改themes/next/config.toml文件中Menu.Main中的权重值weight来调整顺序：
[[Menu.Main]]  Name = &amp;#34;首页&amp;#34;  Pre = &amp;#34;home&amp;#34;  URL = &amp;#34;/&amp;#34;  Weight = 1  [[Menu.Main]]  Name = &amp;#34;标签&amp;#34;  Pre = &amp;#34;tag&amp;#34;  URL = &amp;#34;/tags/&amp;#34;  Weight = 2  [[Menu.Main]]  Name = &amp;#34;归档&amp;#34;  Pre = &amp;#34;archive&amp;#34;  URL = &amp;#34;/post/&amp;#34;  Weight = 3  [[Menu.Main]]  Name = &amp;#34;美食&amp;#34;  Pre = &amp;#34;fire&amp;#34; #tint  URL = &amp;#34;/categories/美食/&amp;#34;  Weight = 4  [[Menu.Main]]  Name = &amp;#34;后期&amp;#34;  Pre = &amp;#34;edit&amp;#34;  URL = &amp;#34;/categories/后期/&amp;#34;  Weight = 5  [[Menu.Main]]  Name = &amp;#34;旅行&amp;#34;  Pre = &amp;#34;leaf&amp;#34;  URL = &amp;#34;/categories/旅行/&amp;#34;  Weight = 6  [[Menu.Main]]  Name = &amp;#34;关于&amp;#34;  Pre = &amp;#34;user&amp;#34;  URL = &amp;#34;/about/&amp;#34;  Weight = 7 文章左侧展示目录 如果需要在文章左侧展示目录，需要在markdown文章开头添加toc = true：
--- title: Hugo next 主题问题 date: 2020-02-07 11:27:41 tags: [hugo,tool] categories: [code] toc: true --- 首页展示文章数目更改 修改首页展示的文章数目可以在themes/next/config.toml中设置Paginate字段值：
首页摘要字数更改 首页摘要的字数设置必须在与themes同级的config.toml文件中设置才会生效：
summaryLength = 100 #放在同themes同级的config.toml上才有效 设置文章置顶 想要把文章置顶，需要在markdown文章头部设置权重weight的值，如下所示：
--- title: 陈小厨作品集 date: 2020-02-03 13:28:05 tags: [美食] categories: [美食] weight: 1 toc: true --- 修改了权重值，效果如下：
从H1开始显示文章目录 不知道从什么时候开始Hugo从h2生成目录，为了设置从h1开始生成目录，需要设置全局的config.toml(即跟themes同级的config.toml)，如下所示：
[markup]  [markup.tableOfContents]  endLevel = 4  startLevel = 1  使用KaTex渲染公式 因为Markdown中的下划线和latex公式里的下划线冲突，导致Hugo中latex公式里的下标总是渲染不出来，如下图所示，看着很不舒服：
使用Katex来渲染公式可以达到正常的效果：
首先进入themes/next/layouts/partials目录，新建一个名为katex.html文件：
然后在katex.html中添加如下内容：
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;!-- CSS File --&amp;gt;  &amp;lt;head&amp;gt;  &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt;  &amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css&amp;#34; integrity=&amp;#34;sha384-D&#43;9gmBxUQogRLqvARvNLmA9hS2x//eK1FhVb9PiU86gmcrBrJAQT8okdJ4LMp2uv&amp;#34; crossorigin=&amp;#34;anonymous&amp;#34;&amp;gt;   &amp;lt;!-- JS Fle --&amp;gt;  &amp;lt;script defer src=&amp;#34;https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js&amp;#34; integrity=&amp;#34;sha384-483A6DwYfKeDa0Q52fJmxFXkcPCFfnXMoXblOkJ4JcA8zATN6Tm78UNL72AKk&#43;0O&amp;#34; crossorigin=&amp;#34;anonymous&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt;  &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 然后在themes/next/layouts/partials/header.html文件中添加如下代码：
{{ if .Params.katex}}{{ partial &amp;#34;katex.html&amp;#34; . }}{{ end }} 最后在需要渲染公式的markdown文章头部，添加katex: true：
--- title: 线性表 date: 2018-04-25T20:52:42&#43;08:00 tags: [算法] categories: [算法] toc: true katex: true --- 就可以达到如下的效果：
参考资料
 字体颜色生效 升级了Hugo版本之后，发现之前在笔记中插入的字体颜色tag都已经失效。查了相关资料，发现这是因为之前Hugo使用Blackfriday来渲染Markdown文件。从0.60版本开始，默认的 Markdown渲染器已经改成了Goldmark，而Goldmark渲染器默认不会渲染HTML tags。
为了修复这个问题，有两种不同的解决方案。第一种是把Markdown渲染引擎改回为Blackfriday。即在全局设置文件config.toml中添加：
[markup]  defaultMarkdownHandler = &amp;#34;blackfriday&amp;#34; 第二种是依然使用Goldmark来渲染，但是修改它的默认行为，即在全局设置文件config.toml中添加：
[markup]  defaultMarkdownHandler = &amp;#34;goldmark&amp;#34;  [markup.goldmark]  [markup.goldmark.renderer]  unsafe = true 参考资料
 添加代码粘贴按钮 参考资料 参考资料 参考资料 参考资料
</content>
    </entry>
    
     <entry>
        <title>一些问题的解决方案</title>
        <url>https://iihui.github.io/post/ios-solutions/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  在开发过程中，会遇到各种问题，有时候某个问题当时已经找到了解决方案，但过了一段时间又可能会忘记。这篇文章记录一些问题的解决方案，以便后续查找。
 强制竖屏 最近在使用其它SDK，业务方要求打开其中的某个页面时强制竖屏，但发现按对方要求传了相应参数，依然未生效，仍然能够横竖屏切换。解决方案是首先在工程info.plist中添加Require Full Screen项，并将其值置为YES，然后在需要强制竖屏的ViewController中添加如下代码：
class ViewController: UIViewController {  override func viewDidLoad() {  super.viewDidLoad()  UIDevice.current.setValue(UIInterfaceOrientation.portrait.rawValue, forKey: &amp;#34;orientation&amp;#34;)  }   override var supportedInterfaceOrientations: UIInterfaceOrientationMask {  return .portrait  }   override var shouldAutorotate: Bool {  return true  } } keyWindow变化 系统升级到iOS 14.5.1后，发现使用UIApplication.shared.keyWindow获取到的rootViewController为nil。排查发现，在创建并使用新window后导致keyWindow发生了变化。为了防止这种变化，在显示新的window前，先保存原来的keyWindow，等释放新建的window后再还原keyWindow：
func show() {  if self.showTimes == 0 {  // iOS 14.5.1上如果不记录keyWindow，调用self.dismissVC()后会导致dismiss后keyWindow发生变化  // 从而导致取topMost时为nil，路由不能正常push或present  self.keyWindow = UIApplication.shared.keyWindow  let window = UIWindow(frame: UIScreen.main.bounds)  window.windowLevel = UIWindow.Level.normal  window.safeRootViewController = self  window.isHidden = false  window.backgroundColor = UIColor.clear  self.newWindow = window  // 防止多次点击  self.showTimes &#43;= 1  } }  @IBAction func cancelAction(_ sender: Any) {  self.dismissVC()  // 恢复keyWindow，以解决iOS 14.5.1 keyWindow发生变化的情况  self.keyWindow?.makeKeyAndVisible() } UIAlertView deprecated 测试KSCrash组件时使用XCode 12.3新建了一个工程，写了相关代码之后出现：UIAlertView is deprecated and unavailable for UIScene based applications, please use UIAlertController错误，参照Stack Overflow上的回答，解决了报错问题。
解决这个问题的核心是要删除UIScene相关代码，让工程恢复到旧的window架构。这个过程主要分为四步，首先需要删除工程中的SceneDelegate.swift文件：
然后在AppDelegate.swift文件中删除UIScene中相关的代码，即application(_ application: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession, options: UIScene.ConnectionOptions)和 application(_ application: UIApplication, didDiscardSceneSessions sceneSessions: Set&amp;lt;UISceneSession&amp;gt;)两个函数：
func application(_ application: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession, options: UIScene.ConnectionOptions) -&amp;gt; UISceneConfiguration {  // Called when a new scene session is being created.  // Use this method to select a configuration to create the new scene with.  return UISceneConfiguration(name: &amp;#34;Default Configuration&amp;#34;, sessionRole: connectingSceneSession.role) }  func application(_ application: UIApplication, didDiscardSceneSessions sceneSessions: Set&amp;lt;UISceneSession&amp;gt;) {  // Called when the user discards a scene session.  // If any sessions were discarded while the application was not running, this will be called shortly after application:didFinishLaunchingWithOptions.  // Use this method to release any resources that were specific to the discarded scenes, as they will not return. } 接着在AppDelegate.swift中添加属性var window: UIWindow?，补回原本在SceneDelegate.swift文件中声明的var window: UIWindow?的属性：
class AppDelegate: UIResponder, UIApplicationDelegate {  var window: UIWindow?   func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&amp;gt; Bool {  CrashReporterService.shared.startReporter()  return true  }  } 最后在工程的Info.plist文件中删除Application Scene Manifest这一行，重新编译即可。如果编译依然报错，需要清除工程的缓存（使用Shift&#43;Command&#43;K快捷键即可），然后再编译：
禁用边缘返回手势 对于以push方式打开的页面，该页面默认自动拥有系统提供的「边缘返回」手势。如果要禁止系统的「边缘返回」手势，可以为UIViewController写一个如下的扩展方法：
// 参考自https://juejin.cn/post/6860656306630590477 extension UIViewController {  // 禁止系统的边缘返回手势  func popGestureForbid() {  if let gestures = self.navigationController?.interactivePopGestureRecognizer?.view?.gestureRecognizers {  gestures.forEach({ $0.isEnabled = false })  }  } } UIWebView特殊字符 如果使用UIWebView加载的html文件中包含\n，&#39;等特殊字符时，不做任何处理直接加载的话，将会出现白屏，此时没有任何提示。因此，加载这种含有特殊字符的html文件时要特殊处理:
class HTMLUtils {  static func escapsedHTML(html: String) -&amp;gt; String{  var result = html  if !result.isEmpty {  result = result.replacingOccurrences(of: &amp;#34;\\&amp;#34;, with: &amp;#34;\\\\&amp;#34;)  result = result.replacingOccurrences(of: &amp;#34;\&amp;#34;&amp;#34;, with: &amp;#34;\\\&amp;#34;&amp;#34;)  result = result.replacingOccurrences(of: &amp;#34;&amp;#39;&amp;#34;, with: &amp;#34;\\&amp;#39;&amp;#34;)  result = result.replacingOccurrences(of: &amp;#34;\r&amp;#34;, with: &amp;#34;\\r&amp;#34;)  result = result.replacingOccurrences(of: &amp;#34;\n&amp;#34;, with: &amp;#34;\\n&amp;#34;)  }  return result  } } 允许http请求 自iOS 9.0开始，苹果默认要求App访问的url均为https。为了能在项目中支持http，需在项目中的Info.plist文件中将App Transport Security Settings下的Allow Arbitrary Loads设置为YES。如果没有这两项的话，则需先在Info.plist文件中添加:
仿导航栏添加阴影 // 设置阴影颜色 navBGView.layer.shadowColor = UIColor.lightGray.cgColor // 设置阴影偏移范围 navBGView.layer.shadowOffset = CGSize(width: 0, height: 1.8) // 设置阴影颜色的透明度 navBGView.layer.shadowOpacity = 0.2 // 设置阴影的半径 navBGView.layer.shadowRadius = 2.5 // 设置阴影路径 navBGView.layer.shadowPath = UIBezierPath.init(rect: navBGView.bounds).cgPath 可以在UINavigationController中添加扩展方法来隐藏或显示自定义的阴影。下面代码定义了两个扩展方法，其中showShadow方法用于显示阴影，hideShadow方法用于隐藏阴影：
public extension UINavigationController {  func showShadow(){  self.navigationBar.layer.shadowColor = UIColor.black.cgColor  self.navigationBar.layer.shadowOffset = CGSize(width: 0, height: 2.5)  self.navigationBar.layer.shadowOpacity = 0.15  self.navigationBar.layer.shadowRadius = 4.0  }   func hideShadow(){  self.navigationBar.layer.shadowOffset = CGSize(width: 0, height: 0)  self.navigationBar.layer.shadowColor = UIColor.white.cgColor  self.navigationBar.layer.shadowOpacity = 0.0  } } 参考资料
导航栏顶部黑屏 帮助中心中文版和英文版在iOS 15以上的系统表现不一致，发现是Top Bar设置不一致导致的：
毫秒级时间戳距当前时间 最近有个需求要将毫秒级的时间戳转换为xx天前，xx小时前，xx分钟前以及xx秒前。下面代码将距离当前时间小于60秒转换为几秒前，小于60分钟转换为xx分钟前，小于24小时，转换为xx小时前，小于10天前转换为xx天前，否则显示xxxx年xx月xx日：
/// 将毫秒级别的时间戳转换为约定的格式，0～60秒显示几秒前，1～60分显示xx分钟前，1～24小时显示xx小时前，1～10天显示xx天前，否则显示yyyy-MM-dd /// - Parameter timeStamp: 毫秒级别时间戳字符串 /// - Returns: 转换后的字符串 private func convertTime(timeStamp: String) -&amp;gt; String {  let currentTimeSeconds = Date().timeIntervalSince1970  if let timeDouble = Double(timeStamp) {  let timeStampSeconds = TimeInterval(timeDouble / 1000)  let reduceTime: TimeInterval = currentTimeSeconds - timeStampSeconds  // 时间差小于60秒  if reduceTime &amp;lt; 60 {  return &amp;#34;几秒前&amp;#34;  }  // 时间差大于一分钟小于60分钟内  let minutes = Int(reduceTime / 60)  if minutes &amp;lt; 60 {  return &amp;#34;\(minutes)分钟前&amp;#34;  }  // 时间差小于24小时  let hours = Int(reduceTime / 3600)  if hours &amp;lt; 24 {  return &amp;#34;\(hours)小时前&amp;#34;  }  // 时间差小于10 天  let days = Int(reduceTime / 3600 / 24)  if days &amp;lt; 10 {  return &amp;#34;\(days)天前&amp;#34;  }  let date = NSDate(timeIntervalSince1970: timeStampSeconds)  let dateFormat = DateFormatter()  dateFormat.dateFormat = &amp;#34;yyyy-MM-dd&amp;#34;  return dateFormat.string(from: date as Date)  } else {  return &amp;#34;未知时间&amp;#34;  } } GIF显示 显示gif动画有两种方式：第一种是使用UIWebView，另一种是使用UIImageView。但如果使用UIWebView显示gif的话，动画是不可以暂停的：
class ViewController: UIViewController {  override func viewDidLoad() {  super.viewDidLoad()  guard let path = Bundle.main.path(forResource: &amp;#34;demo&amp;#34;, ofType: &amp;#34;gif&amp;#34;) else {  return  }  let url = URL(fileURLWithPath: path)   do {  let gifData = try Data(contentsOf: url)  let webView = UIWebView()  webView.frame = CGRect(x: 0, y: 100, width: self.view.frame.width, height: 600)  webView.scalesPageToFit = true  webView.load(gifData, mimeType: &amp;#34;image/gif&amp;#34;, textEncodingName: String(), baseURL: NSURL() as URL)  self.view.addSubview(webView)  } catch {  debugPrint(error.localizedDescription)  }  } } 使用UIImageView播放gif首先需要从给定的gif文件中获取图片数组，然后获取gif文件的播放时长。最后将获取到的图片数组和时长赋值给UIImageView的animationImages和animationDuration实例属性：
class ViewController: UIViewController {  override func viewDidLoad() {  super.viewDidLoad()   let imageView = UIImageView()  imageView.frame = CGRect(x: 0, y: 100, width: self.view.frame.width, height: 600)  self.view.addSubview(imageView)   guard let path = Bundle.main.path(forResource: &amp;#34;demo&amp;#34;, ofType: &amp;#34;gif&amp;#34;) else {  return  }  let url = URL(fileURLWithPath: path)   do {  let gifData = try Data(contentsOf: url)  guard let imageSource = CGImageSourceCreateWithData(gifData as CFData, nil) else {  return  }  let imageCount = CGImageSourceGetCount(imageSource)   var images = [UIImage]()  var gifDuration: TimeInterval = 0  for index in 0 ..&amp;lt; imageCount {  guard let cgImage = CGImageSourceCreateImageAtIndex(imageSource, index, nil) else {  return  }  let image = UIImage(cgImage: cgImage)  images.append(image)  if index == 0 {  imageView.image = image  }   var tmpProperty: NSDictionary?  if let tmp = CGImageSourceCopyPropertiesAtIndex(imageSource, index, nil) {  tmpProperty = tmp as NSDictionary  if let property = tmpProperty {  guard let gifDic = property[kCGImagePropertyGIFDelayTime] as? NSDictionary else {  continue  }   guard let imageDuration = gifDic[kCGImagePropertyGIFDelayTime] as? NSNumber else {  continue  }  gifDuration &#43;= imageDuration.doubleValue  }  }  }   imageView.animationImages = images  imageView.animationDuration = gifDuration  imageView.animationRepeatCount = 10  imageView.startAnimating()  } catch {  debugPrint(error.localizedDescription)  }  } } 参考资料
视频编码 近期出现了在iPhone上拍摄的视频，同步到Android设备后播放不了的问题。直觉猜测应该是iPhone上拍摄视频所使用的编码不兼容Android。经过沟通，播放视频是用H5嵌入的，因为手边没有视频播放源码和可测的Android设备，为了验证猜测，尝试着先改变iPhone录制视频时的编码方式，然后写一段播放视频的H5代码，用Chrome浏览器进行测试。
if self.captureSession.canAddOutput(self.captureMovieFileOutput) {  self.captureSession.addOutput(self.captureMovieFileOutput)  if let outPutConnection = self.captureMovieFileOutput.connection(withMediaType:AVMediaTypeVideo){  let out = self.captureMovieFileOutput.outputSettings(for: outPutConnection)  } } 上面的代码便能看到视频录制时的编码方式，对比iOS 11.3，iOS 12.0以及iOS 12.01后发现输出的编码格式从avc1变成了hcv1：
因为上面代码使用的是默认编码格式，通过上面的对比发现视频的默认编码格式是会随着iOS版本发生变化的。因此需要显式指定视频的输出编码格式，即设置[AVVideoCodecKey:AVVideoCodecH264]：
if self.captureSession.canAddOutput(self.captureMovieFileOutput) {  self.captureSession.addOutput(self.captureMovieFileOutput)  if let outPutConnection = self.captureMovieFileOutput.connection(withMediaType:AVMediaTypeVideo){  if #available(iOS 10.0, *){  let outputSettings = [AVVideoCodecKey:AVVideoCodecH264]  self.captureMovieFileOutput.setOutputSettings(outputSettings, for: outPutConnection)  //let out = self.captureMovieFileOutput.outputSettings(for: outPutConnection)  }  } } 为了测试改变编码前后生成的视频文件能否在Chrome浏览器中播放，需要编写对应的html代码以播放测试视频，将视频文件放在同级目录，然后更改如下代码中的视频文件名即可：
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt;  &amp;lt;meta charset=&amp;#34;utf-8&amp;#34; /&amp;gt;  &amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34;&amp;gt;  &amp;lt;title&amp;gt;Page Title&amp;lt;/title&amp;gt;  &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1&amp;#34;&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt;  &amp;lt;video  id=&amp;#34;video&amp;#34;  src=&amp;#34;video13.mp4&amp;#34;  controls = &amp;#34;true&amp;#34;  poster=&amp;#34;images.jpg&amp;#34; //视频封面  preload=&amp;#34;auto&amp;#34;  webkit-playsinline=&amp;#34;true&amp;#34; //这个属性是ios 10中设置可以  让视频在小窗内播放，也就是不是全屏播放  playsinline=&amp;#34;true&amp;#34; //iOS微信浏览器支持小窗内播放  x-webkit-airplay=&amp;#34;allow&amp;#34;  x5-video-player-type=&amp;#34;h5&amp;#34; //启用H5播放器,是wechat安卓版特性  x5-video-player-fullscreen=&amp;#34;true&amp;#34; //全屏设置，  设置为 true 是防止横屏  x5-video-orientation=&amp;#34;portraint&amp;#34; //播放器支付的方向， landscape横屏，portraint竖屏，默认值为竖屏  &amp;lt;/video&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 使用上面这段代码在明确指定编码之前摄制的视频不可播放，修改编码之后可以播放摄制的视频。后续找到Android测试机发现显式指定编码之前摄制的视频也是不可播放，显式指定编码格式之后可以正常播放摄制的视频。
启动图片 最近App改版，启动页也要随之需要修改，但是修改lanuchScreen.storyboard中的图片和样式后，发现部分手机并未立即生效。解决这个问题，主要有三个步骤。首先，启动页用到的图片资源，不要放入到*.xcassets中，应该直接放到工程目录下：
如果启动页的图片资源需要替换，那应该将图片重命名，不要使用上次的名字。因为如果使用上次的名字，启动的时候还是会读之前的缓存图片：
最后需要删除libraryPath目录下SplashBoard/Snapshots的文件夹，即缓存文件夹libraryPath.appendingPathComponent(&amp;quot;SplashBoard&amp;quot;).appendingPathComponent(&amp;quot;Snapshots&amp;quot;)：
let path = libraryPath.appendingPathComponent(&amp;#34;SplashBoard&amp;#34;).appendingPathComponent(&amp;#34;Snapshots&amp;#34;) do {  if FileManager.default.fileExists(atPath: path.path){  try FileManager.default.removeItem(at: path)  }  } catch let error {  printDebug(msg: error.localizedDescription) } 图片裁剪为圆形 图片的圆形处理需求包括：➀将图片裁剪为圆形图。➁将图片裁剪为带外围圆圈的圆形图。两种都可以使用UIBezierPath来实现，下面第一段代码直接裁剪为圆形，第二段是将图片裁剪为带外围圆圈的圆形图：
/// 将图片裁剪为圆形图 /// - Returns:生成新的图片 func circleImage() -&amp;gt; UIImage? {  UIGraphicsBeginImageContextWithOptions(self.size, false, 0)  let imgPath = UIBezierPath(ovalIn: CGRect(x: 0, y: 0, width: self.size.width, height: self.size.height))  imgPath.addClip()  self.draw(at: CGPoint(x: 0, y: 0))  let newImg = UIGraphicsGetImageFromCurrentImageContext()  UIGraphicsEndImageContext()  return newImg }  /// 将图片裁剪为带外围⭕️的圆形图 /// - Parameters: /// - rail: 外围圆的宽度 /// - color: 外围圆的颜色 /// - Returns: 生成新的图片 func circleImageWidthRail(rail: CGFloat, color: UIColor) -&amp;gt; UIImage? {  let size = CGSize(width: self.size.width &#43; 2 * rail, height: self.size.height &#43; 2 * rail)  UIGraphicsBeginImageContextWithOptions(size, false, 0)  let path = UIBezierPath(ovalIn: CGRect(x: 0, y: 0, width: size.width, height: size.height))  color.set()  path.fill()  let imgPath = UIBezierPath(ovalIn: CGRect(x: rail, y: rail, width: self.size.width, height: self.size.height))  imgPath.addClip()  self.draw(at: CGPoint(x: rail, y: rail))  let newImg = UIGraphicsGetImageFromCurrentImageContext()  UIGraphicsEndImageContext()  return newImg } 参考资料
 局域网无线调试设备 如果Mac和iOS设备在同一局域网中，可以通过网络连接进行调试。首先在Xcode菜单栏进入到Window --&amp;gt; Devices and Simulators：
然后选中Devices找到对应的真机，鼠标左键单击以选中真机，然后在右上角勾选Connect via network，如下图所示：
勾选Connect via network后，编译安装时选择上面选中并设置的设备。若出现Xcode will continue when xxx is connected，则需要在上面的真机上右键选择Connect via IP Address...，再输入真机的IP地址：
Device Locked 如果手机已经连接上了，并且已经设置信任，但编译安装时Xcode还是出现如下提示：
Xcode &amp;#34;Device Locked&amp;#34; When iPhone is unlocked 那么需要在Xcode的菜单栏Window--&amp;gt;Devices and Simulators，然后选中对应的设备，右键选择Unpair Device，此时手机会弹出重新信任的提示，再点一次信任即可。
open url 自iOS 10开始UIApplication.shared.openURL被废弃了，需要使用open func open(_ url: URL, options: [UIApplication.OpenExternalURLOptionsKey : Any] = [:], completionHandler completion: ((Bool) -&amp;gt; Void)? = nil)。
上面的options有个参数是universalLinksOnly。如果包含universalLinksOnly选项，则只有在配置了某个应用程序打开URL时，URL才会打开。例如要打开YouTube视频，您必须安装YouTube应用。
UIApplication.shared.open(url, options: [:], completionHandler: nil) 选项说明
安全下标 extension Collection {  /// Returns the element at the specified index if it is within bounds, otherwise nil.  subscript (safe index: Index) -&amp;gt; Element? {  return indices.contains(index) ? self[index] : nil  } } 隐藏TabBar 如果在UIViewController实例中设置hidesBottomBarWhenPushed = true后，如果push到这个界面，则UITabBarController底部的tabbar将会隐藏。
在待打开的页面设置了hidesBottomBarWhenPushed = true后，使用push方式打开这个新界面之后，再使用替换window.rootViewController的方式打开另一个新的界面。但如果将替换window.rootViewController打开的新界面关闭掉，再回到push打开的界面后，底部tabbar又会出现。此时，可以使用如下代码隐藏底部的tabbar：
private func hideTabBar() {  if self.rootViewController is RootTabBarController,  let navigationController = (self.rootViewController as? RootTabBarController)?.selectedViewController as? UINavigationController,  navigationController.viewControllers.count &amp;gt; 1,  let topViewController = navigationController.topViewController {  navigationController.popViewController(animated: false)  navigationController.pushViewController(topViewController, animated: false)  } } 上面的解决问题的思路是将原来push的界面先pop掉，然后利用已经设置的hidesBottomBarWhenPushed = true属性，再重新push一次之前的界面，就可以把底部的tabbar隐藏。
如果是在viewWillAppear里面手动将tabbar隐藏，而在viewWillDisapper中将tabbar显示。这样不仅会影响整体的逻辑，而且还会出现肉眼可见的黑边：
override func viewWillAppear(_ animated: Bool) {  super.viewWillAppear(animated)  self.tabBarController?.tabBar.isHidden = true  self.tabBarController?.tabBar.isTranslucent = true }  override func viewWillDisappear(_ animated: Bool) {  super.viewWillDisappear(animated)  self.tabBarController?.tabBar.isHidden = false  self.tabBarController?.tabBar.isTranslucent = false } 强制浅色模式 自iOS 13开始，一旦使用了系统的组件和颜色，如果用户切换到了深色模式，则这些组件的颜色会随着发生变化，而此时某些使用了自定义颜色的组件对应的颜色不会改变，将会变得不统一，看起来很奇怪。
一个简单的方式是强制App为浅色模式，使得即使用户开启了深色模式后，App还是之前的浅色模式。如果要强制App为浅色模式，需在项目的Info.plist文件中将User Interface Style这一项设置为Light：
字典合并 第一个字典先提供一些默认值，对于相同的key如果第二个字典中存在相应的value，则第一个字典的value将会被第二个字典的value覆盖掉:
/// 默认字段 var defaultInfo: [String: Any] = [  &amp;#34;sys_id&amp;#34;: sysID,  &amp;#34;type&amp;#34;: action.rawValue,  &amp;#34;ystId&amp;#34;: activeUser.pid,  &amp;#34;deviceId&amp;#34;: deviceID,  &amp;#34;platform&amp;#34;: platform,  &amp;#34;pubVer&amp;#34;: pubVersion,  &amp;#34;buildVer&amp;#34;: buildVersion,  &amp;#34;deviceModel&amp;#34;: deviceModel,  &amp;#34;serverTime&amp;#34;: logTime,  &amp;#34;deviceTime&amp;#34;: deviceTimeStr,  &amp;#34;startTime&amp;#34;: logTime,  &amp;#34;endTime&amp;#34;: logTime,  &amp;#34;networkType&amp;#34;: networkInfo._networkType,  &amp;#34;networkName&amp;#34;: networkInfo._networkName,  &amp;#34;ip&amp;#34;: networkInfo.ip,  &amp;#34;inuseId&amp;#34;: inuseID,  &amp;#34;gpsLng&amp;#34;: gps.lng,  &amp;#34;gpsLat&amp;#34;: gps.lat, ] if let _args = args {  // 注意是用defaultInfo 去merge 字典_args  defaultInfo.merge(_args, uniquingKeysWith: { $1 }) } 数组分片 extension Array {  // 数组分片  func chunked(by distance: Int) -&amp;gt; [[Element]] {  return stride(from: 0, to: count, by: distance).map {  Array(self[$0 ..&amp;lt; Swift.min($0 &#43; distance, count)])  }  } } WKWebView自动播放 因为WKWebView中设置的mediaPlaybackAllowsAirPlay和mediaPlaybackRequiresUserAction已经被废弃了，所以需要替换如下新API:
let wkConfig = WKWebViewConfiguration() wkConfig.userContentController = WKUserContentController() // 修改默认设置，允许页面内播放 wkConfig.allowsInlineMediaPlayback = true // 支持内嵌视频自动播放 //wkConfig.mediaPlaybackAllowsAirPlay = true //wkConfig.mediaPlaybackRequiresUserAction = false wkConfig.allowsAirPlayForMediaPlayback = true wkConfig.mediaTypesRequiringUserActionForPlayback = [] self.webView.scrollView.addObserver(self, forKeyPath: &amp;#34;contentSize&amp;#34;, options: .new, context: nil)  }  override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) {  if let key = keyPath, key == &amp;#34;contentSize&amp;#34;{  let fittingSize = self.webView.sizeThatFits(CGSize.zero)  self.webView.frame = CGRect(x: 0, y: noteTitleTextField.frame.height, width: fittingSize.width, height: fittingSize.height)  }  } func getLocalImage(_ userID: String?, isGetBigImg: Bool? = false) -&amp;gt; UIImage? {  guard let id = userID else { return nil }  return getImageFromPhotoNameAndPhotoType(id, isGetBigImg: isGetBigImg ?? fals } func isLoaded(_ userID: String) -&amp;gt; Bool {  lock.lock()  let isContains = hasLoadSmallPhotoDataSouceIndex.contains(userID)  lock.unlock()  return isContains } func load(_ userID: String) {  lock.lock()  hasLoadSmallPhotoDataSouceIndex.add(userID)  lock.unlock() } */ 主屏交互 自2015年苹果发布3D Touch时，iPhone 6s之后全部机型都支持该功能。3D Touch的主屏交互是在手机的桌面用力的按压应用图标，能够唤起快捷操作按钮。要实现主屏交互，首先要在info.plist文件中添加UIApplicationShortcutItem：
然后在application(_ application: UIApplication, performActionFor shortcutItem: UIApplicationShortcutItem, completionHandler: @escaping (Bool) -&amp;gt; Void)中添加处理逻辑：
func application(_ application: UIApplication, performActionFor shortcutItem: UIApplicationShortcutItem, completionHandler: @escaping (Bool) -&amp;gt; Void) { 	let type = shortcutItem.type  switch type {  //...  } } 3DTouch
多线程读写测试 /// 多线程读写测试，因为目前没有下沉，而且不能跑模拟器，所以写在这里测试 static func testMultiThreadReadAndWrite(){  let group = DispatchGroup()  let models:[MoConfigItemModel] = [MoConfigItemModel(),MoConfigItemModel()]  for _ in 0..&amp;lt;2000 {  let delaySet = TimeInterval(arc4random() % 10);  group.enter()  DispatchQueue.global().asyncAfter(deadline: .now() &#43; delaySet) {  self.lightAppConfigItems = models  group.leave()  }  let delaySetNil = TimeInterval(arc4random() % 10);  group.enter()  DispatchQueue.global().asyncAfter(deadline: .now() &#43; delaySetNil) {  self.lightAppConfigItems.append(MoConfigItemModel())  group.leave()  }  let delayGet = TimeInterval(arc4random() % 10)  group.enter()  DispatchQueue.global().asyncAfter(deadline: .now() &#43; delayGet) {  let _ = self.allConfigItems  group.leave()  }  }  let success = group.wait(timeout: .now() &#43; 12)  if success == .success {  DPrint(&amp;#34;testMultiThreadReadAndWrite Success&amp;#34; )  } } 数组去重 public extension Array where Element: Hashable {  func removeDuplicated() -&amp;gt; [Element] {  var tmpDict = [Element: Bool]()  return filter {  tmpDict.updateValue(true, forKey: $0) == nil  }  }  mutating func removeDuplicate() {  self = self.removeDuplicated()  } } 判断页面是否正显示 let isShowing = (self.isViewLoaded &amp;amp;&amp;amp; self.view.window != nil) SearchController导航栏空白 有个业务搜索使用UISearchController，但在已经点击搜索框时，再跳转到某些页面时发现页面导航栏上方有一大块空白，发现在跳转前设置self.searchController.hidesNavigationBarDuringPresentation = false，然后在界面恢复时将searchController.hidesNavigationBarDuringPresentation设置为true，也就是恢复成默认状态，可解决该问题：
public override func viewWillAppear(_ animated: Bool) {  super.viewWillAppear(animated)  // 页面重新出现的时候要将hidesNavigationBarDuringPresentation设置为true，恢复为默认状态  self.searchController.hidesNavigationBarDuringPresentation = true } 参考资料
SearchController横竖屏切换 使用UISearchController发现从竖屏到横屏时searchBar宽度显示不全，没有自动拉伸。尝试了在viewWillTransition中改变searchBar的宽度可以解决这个问题：
public override func viewWillTransition(to size: CGSize, with coordinator: UIViewControllerTransitionCoordinator) {  coordinator.animate(alongsideTransition: { [weak self] _ in  // 解决从竖屏到横屏时searchBar显示不全的问题  self?.searchController.searchBar.frame.size.width = size.width  }, completion: nil) } 参考资料 参考资料
SignaturePlugin 后台接口有时需要对接口的query参数进行签名。因此在使用Moya进行请求时，有必要定义一个对query参数进行签名的插件，即在请求发送前进行拦截：
public struct FigureSignaturePlugin: PluginType {  public func prepare(_ request: URLRequest, target: TargetType) -&amp;gt; URLRequest {  guard let target = target as? MoTargetType, target.needsFigureSignature else {  return request  }  var request = request  switch target.task {  case .requestParameters(let parameters, _),  .downloadParameters(let parameters, _, _):  if let params = parameters as? [String: String],  let sign = params.figureSignature(with: ConfigInterfaceKey) {  request.addValue(sign, forHTTPHeaderField: &amp;#34;sign&amp;#34;)  }  default:  break  }  return request  }   public init() {  // 保证外部可用  } }  public protocol MoTargetType: TargetType {  /// 是否需要签名，签名由`FigureSignaturePlugin`插件完成。  /// 确保发送请求的Provider中添加了此插件。  var needsFigureSignature: Bool { get } }  public extension Dictionary where Key == String, Value == String {   /// 计算queries中参数签名，首先将queries按照key排列排序，然后按照key1value1key2value2...的方式拼接成字符串  /// 接着对拼接后的字符串key1value1key2value2...进行urlEncode，最后对urlEncode后的字符串做SM3HMAC  /// - Parameters:  /// - queries: 待签名参数字典  func figureSignature(with key: String) -&amp;gt; String? {  var keysJointValues: String = &amp;#34;&amp;#34;  // 先按照key的排序  let keys = self.keys.sorted()   // 一定要注意顺序  for key in keys where self[key] != nil {  keysJointValues &#43;= (key &#43; self[key]!)  }   if !keysJointValues.isEmpty, let urlEncodedStr = keysJointValues.urlEncoded, let signature = urlEncodedStr.sm3HMACToData(key: key)?.base64EncodedString() {  return signature  }  return nil  } } Moya同步请求 最近替换老代码时发现有不少地方使用了NSURLConnection.sendSynchronousRequest发送同步请求。但Moya中没有天然支持同步请求，需要自定义扩展来支持同步请求，下面的方法是借助泛型和信号量进行同步：
/// 同步网络请求 https://github.com/Moya/Moya/issues/1562 public extension MoyaProvider {  @discardableResult  func synchronousRequest&amp;lt;T: Decodable&amp;gt;(_ target: Target) throws -&amp;gt; T {  return try synchronousRequest(target).map(T.self)  }   @discardableResult  func synchronousRequest(_ target: Target) throws -&amp;gt; Moya.Response {  let semaphore = DispatchSemaphore(value: 0)  var response: Moya.Response? = nil  var error: Error? = nil  // 如果在主线程则会阻塞，因此指定callbackQueue: .global(qos: .background)  request(target, callbackQueue: .global(qos: .background)) { result in  defer {  semaphore.signal()  }  switch result {  case .success(let res):  response = res  case .failure(let err):  error = err  }  }  semaphore.wait()   guard error == nil else {  throw error!  }  return response!  } } 参考资料
ResponseObject 服务端返回的JSON格式的第一层一般是code,message,traceId，data。其中data中是真正的model，因为接口返回具有通用性，可以使用泛型来实现：
/// 服务端返回的数据模型，使用泛型实现 struct ResponseObject&amp;lt;T:Codable&amp;gt;: Codable {  var code: Int  var message: String  var dataModel: T?   enum CodingKeys: String, CodingKey {  case code = &amp;#34;code&amp;#34;  case message = &amp;#34;message&amp;#34;  case dataModel = &amp;#34;data&amp;#34;  } }  /// wifi信息 struct WifiInfoModel: Codable {  var bssid: String  var ssid: String  enum CodingKeys: String, CodingKey {  case bssid = &amp;#34;bssid&amp;#34;  case ssid = &amp;#34;ssid&amp;#34;  } }  /// 请求wifi信息 func requestWifiInfo(success: @escaping (ResponseObject&amp;lt;WifiInfoModel&amp;gt;) -&amp;gt; Void, failure: @escaping (String) -&amp;gt; Void) {  provider.request(.getWifiInfo) { result in  switch result {  case .success(let response):  do {  let model = try JSONDecoder().decode(ResponseObject&amp;lt;WifiInfoModel&amp;gt;.self, from: response.data)  if model.dataModel != nil {  success(model)  } else {  failure(model.message)  }  } catch {  failure(error.localizedDescription)  }  case .failure(let error):  failure(error.localizedDescription)  }  } } 参考资料 参考资料
JSONEncoding /// 将字典转换JSON数组，并设置请求的Content-Type为application/json; charset=utf-8 public struct JsonArrayEncoding: Moya.ParameterEncoding {  public static var `default`: JsonArrayEncoding { return JsonArrayEncoding() }   /// 将字典转换JSON数组，并设置请求的Content-Type为application/json; charset=utf-8  /// - Parameters:  /// - urlRequest: URLRequestConvertible  /// - parameters: 待转换为数组JSON的字典  /// - Throws: 若字典无法转换为JSON则会抛异常  /// - Returns: URLRequest  public func encode(_ urlRequest: URLRequestConvertible, with parameters: Parameters?) throws -&amp;gt; URLRequest {  var request = try urlRequest.asURLRequest()  if let dict = parameters {  // 将字典转换JSON数组  let json = try JSONSerialization.data(withJSONObject: [dict], options: JSONSerialization.WritingOptions.prettyPrinted)  request.setValue(&amp;#34;application/json; charset=utf-8&amp;#34;, forHTTPHeaderField: &amp;#34;Content-Type&amp;#34;)  request.httpBody = json  }  return request  }  } /// 将字典中key为[contentKey」的字段取出来，转换为JSON对象，并设置请求的Content-Type为application/json; charset=utf-8 public struct JsonContenTypeEncoding: Moya.ParameterEncoding {  public static var `default`: JsonContenTypeEncoding { return JsonContenTypeEncoding() }   /// 将字典中key为[contentKey」的字段取出来，转换为JSON对象，并设置请求的Content-Type为application/json; charset=utf-8  /// - Parameters:  /// - urlRequest: URLRequestConvertible  /// - parameters: 待转换的带contentKey字典  /// - Throws: 若字典中带contentKey的值无法转换为JSON对象则会抛异常  /// - Returns: URLRequest  public func encode(_ urlRequest: URLRequestConvertible, with parameters: Parameters?) throws -&amp;gt; URLRequest {  var request = try urlRequest.asURLRequest()  if let dict = parameters, let any = dict[&amp;#34;contentKey&amp;#34;] {  // 将字典中contentKey对应的值转换为JSON  let json = try JSONSerialization.data(withJSONObject: any, options: JSONSerialization.WritingOptions.prettyPrinted)  request.setValue(&amp;#34;application/json; charset=utf-8&amp;#34;, forHTTPHeaderField: &amp;#34;Content-Type&amp;#34;)  request.httpBody = json  }  return request  } } 资料
Result
启动时间统计 如果想要统计App的启动时间，则需要在Schema编辑时增加环境变量DYLD_PRINT_STATISTICS，并将其值设置为1。如果想要查看更详细的信息，需要添加环境变量DYLD_PRINT_STATISTICS_DETAILS，并将其值设置为1：
参考资料
跑马灯效果 /// 跑马灯移动的四个方向, 如果有需要可以自己扩展 public enum MovingDirectionType {  case left  case right  case bottom  case top } /// 速度类型 public enum SpeedType {  /// 长文字慢, 短文字快  case special  /// 不根据文字长短, 都是匀速  case normal }  /// 必选协议做到循环播放 public protocol XTMovingViewProtocol {  func drawMarqueeView(drawMarqueeView: XTMovingView, animationDidStopFinished: Bool) -&amp;gt; Void }  public class XTMovingView: UIView, CAAnimationDelegate {  /// 速度  public var speed: Float = 1.0  /// 宽  public var width: Float = 0.0  /// 高  public var height: Float = 0.0  /// 动画视图宽  public var animationViewWidth: Float = 0.0  /// 动画视图高  public var animationViewHeight: Float = 0.0  /// 是否停止  public var stop: Bool = true  /// 方向  public var moveType: MovingDirectionType = .left  /// 速度类型  public var speedType: SpeedType = .special  /// 内容  public var contentView = UIView()  /// 动画视图  public var animationView = UIView()  /// 协议  public var delegate: XTMovingViewProtocol?   required init?(coder: NSCoder) {  fatalError(&amp;#34;init(coder:) has not been implemented&amp;#34;)  }   public override init(frame: CGRect) {  super.init(frame: frame)  width = Float(frame.size.width)  height = Float(frame.size.height)  speed = 1  self.layer.masksToBounds = true  moveType = .left  animationView = UIView(frame: CGRect())  self.addSubview(animationView)  }   /// 添加Content视图  public func addContentView(v: UIView) -&amp;gt; Void {  contentView.removeFromSuperview()  v.frame = v.bounds  contentView = v  animationView.frame = v.bounds  animationView.addSubview(contentView)  /// 内部空间W  animationViewWidth = Float(animationView.frame.size.width)  /// 内部空间H  animationViewHeight = Float(animationView.frame.size.height)  }   /// 开始动画  public func startAnimation() -&amp;gt; Void {  animationView.layer.removeAnimation(forKey: &amp;#34;animationViewPosition&amp;#34;)  stop = false  /// 右边的中心  let pointRightCenter = CGPoint(x: Int(width &#43; animationViewWidth / 2), y: Int(animationViewHeight) / 2)  /// 左边的中心  let pointLeftCenter = CGPoint(x: -Int(animationViewWidth / 2), y: Int(animationViewHeight) / 2)  /// 下中心  let pointBottomCenter = CGPoint(x: Int(animationViewWidth / 2), y: Int(animationViewHeight) / 2 &#43; Int(height))  /// 上中心  let pointUpCenter = CGPoint(x: Int(animationViewWidth) / 2, y: -Int(animationViewHeight) / 2)  var fromPoint = CGPoint()  var toPoint = CGPoint()  switch moveType {  case .left:  fromPoint = pointRightCenter  toPoint = pointLeftCenter  case .right:  fromPoint = pointLeftCenter  toPoint = pointRightCenter  case .bottom:  fromPoint = pointBottomCenter  toPoint = pointUpCenter  case .top:  fromPoint = pointUpCenter  toPoint = pointBottomCenter  }   animationView.center = fromPoint  let movePath = UIBezierPath()  movePath.move(to: fromPoint)  movePath.addLine(to: toPoint)   let moveAnimation = CAKeyframeAnimation(keyPath: &amp;#34;position&amp;#34;)  moveAnimation.path = movePath.cgPath  moveAnimation.repeatCount = .infinity  moveAnimation.isRemovedOnCompletion = false   if self.speedType == .special {  moveAnimation.duration = CFTimeInterval(animationViewWidth / 30 * (1 / speed))  }   if self.speedType == .normal {  moveAnimation.duration = CFTimeInterval(2 * (1 / speed))  }   moveAnimation.delegate = self  animationView.layer.add(moveAnimation, forKey: &amp;#34;animationViewPosition&amp;#34;)  }   /// 停止动画  public func stopAnimation() -&amp;gt; Void {  stop = true  animationView.layer.removeAnimation(forKey: &amp;#34;animationViewPosition&amp;#34;)  }   public func animationDidStop(_ anim: CAAnimation, finished flag: Bool) {  delegate?.drawMarqueeView(drawMarqueeView: self, animationDidStopFinished: flag)  if flag &amp;amp;&amp;amp; !stop {  self.startAnimation()  }  }   /// 暂停  public func pauseAnimation() -&amp;gt; Void {  let layer = animationView.layer  let pausedTime = layer.convertTime(CACurrentMediaTime(), from: nil)  layer.speed = 0  layer.timeOffset = pausedTime  }   /// 重启  public func resumeAnimation() -&amp;gt; Void {  let layer = animationView.layer  let pausedTime = layer.timeOffset  layer.speed = 1  layer.timeOffset = 0  layer.beginTime = 0  let timeSincePause = layer .convertTime(CACurrentMediaTime(), from: nil) - pausedTime  layer.beginTime = timeSincePause  } }  public extension NSString {  func calculateWidthWithAttributeText(dic: Dictionary&amp;lt;NSAttributedString.Key, Any&amp;gt;) -&amp;gt; Double {  let rect = self.boundingRect(with: CGSize(width: 10000, height: 20), options: NSStringDrawingOptions.usesLineFragmentOrigin.union(NSStringDrawingOptions.usesFontLeading).union(NSStringDrawingOptions.usesDeviceMetrics), attributes: dic, context: nil)  return Double(ceil(rect.size.width))  } } public protocol JXMarqueeViewCopyable {  /// 如果视图里面有圆角、阴影等，仅通过NSKeyedArchiver、NSKeyedUnarchiver相关方法，会丢失对应信息。所以，这种特殊情况需要自定义返回。  /// 重新拷贝一份目标视图。不能返回视图自己，需要重新创建一个实例。  /// 第一种方案，实现required init?(coder aDecoder: NSCoder) 初始化器，返回一个新实例。参考CustomCopyView  /// 第二种方案，重载func copyMarqueeView() -&amp;gt; UIView方法，返回一个新实例。参考CustomCopyView  ///  /// - Returns: new view  func copyMarqueeView() -&amp;gt; UIView }  extension UIView: JXMarqueeViewCopyable {  @objc open func copyMarqueeView() -&amp;gt; UIView {  //UIView是没有遵从拷贝协议的。可以通过UIView支持NSCoding协议，间接来复制一个视图  let archivedData = NSKeyedArchiver.archivedData(withRootObject: self)  let copyView = NSKeyedUnarchiver.unarchiveObject(with: archivedData) as! UIView  return copyView  } }  public enum JXMarqueeType {  case left  case right  case reverse }  public class JXMarqueeView: UIView {  public var marqueeType: JXMarqueeType = .left  public var contentMargin: CGFloat = 12 //两个视图之间的间隔  public var frameInterval: Int = 1 //多少帧回调一次，一帧时间1/60秒  public var pointsPerFrame: CGFloat = 0.5 //每次回调移动多少点  public var contentView: UIView? {  didSet {  self.setNeedsLayout()  }  }  public var contentViewFrameConfigWhenCantMarquee: ((UIView)-&amp;gt;())? //当contentView的内容宽度没有超过显示宽度，无需开启跑马灯效果。这个时候contentView的size，默认是调用sizeToFit之后的尺寸。如果想要特殊配置，比如让contentView的size等于JXMarqueeView，就需要在该闭包自定义配置。  private let containerView = UIView()  private var marqueeDisplayLink: CADisplayLink?  private var isReversing = false   override open func willMove(toSuperview newSuperview: UIView?) {  //当视图将被移除父视图的时候，newSuperview就为nil。在这个时候，停止掉CADisplayLink，断开循环引用，视图就可以被正确释放掉了。  if newSuperview == nil {  self.stopMarquee()  }  }   public init() {  super.init(frame: CGRect.zero)   self.initializeViews()  }   override public init(frame: CGRect) {  super.init(frame: frame)   self.initializeViews()  }   required public init?(coder aDecoder: NSCoder) {  super.init(coder: aDecoder)   self.initializeViews()  }   func initializeViews() {  self.backgroundColor = UIColor.clear  self.clipsToBounds = true   containerView.backgroundColor = UIColor.clear  self.addSubview(containerView)  }   override open func layoutSubviews() {  super.layoutSubviews()   guard let validContentView = contentView else {  return  }  containerView.subviews.forEach {$0.removeFromSuperview() }   //对于复杂的视图，需要自己重写contentView的sizeThatFits方法，返回正确的size  validContentView.sizeToFit()  containerView.addSubview(validContentView)   if marqueeType == .reverse {  containerView.frame = CGRect(x: 0, y: 0, width: validContentView.bounds.size.width, height: self.bounds.size.height)  }else {  containerView.frame = CGRect(x: 0, y: 0, width: validContentView.bounds.size.width*2 &#43; contentMargin, height: self.bounds.size.height)  }   if validContentView.bounds.size.width &amp;gt; self.bounds.size.width {  validContentView.frame = CGRect(x: 0, y: 0, width: validContentView.bounds.size.width, height: self.bounds.size.height)  if marqueeType != .reverse {  let otherContentView = validContentView.copyMarqueeView()  otherContentView.frame = CGRect(x: validContentView.bounds.size.width &#43; contentMargin, y: 0, width: validContentView.bounds.size.width, height: self.bounds.size.height)  containerView.addSubview(otherContentView)  }  self.startMarquee()  }else {  if contentViewFrameConfigWhenCantMarquee != nil {  contentViewFrameConfigWhenCantMarquee!(validContentView)  }else {  validContentView.frame = CGRect(x: 0, y: 0, width: validContentView.bounds.size.width, height: self.bounds.size.height)  self.stopMarquee()  }  }  }   //如果你的contentView的内容在初始化的时候，无法确定。需要通过网络等延迟获取，那么在内容赋值之后，在调用该方法即可。  public func reloadData() {  self.setNeedsLayout()  }   fileprivate func startMarquee() {  self.stopMarquee()   if marqueeType == .right {  var frame = self.containerView.frame  frame.origin.x = self.bounds.size.width - frame.size.width  self.containerView.frame = frame  }   self.marqueeDisplayLink = CADisplayLink.init(target: self, selector: #selector(processMarquee))  self.marqueeDisplayLink?.frameInterval = self.frameInterval  self.marqueeDisplayLink?.add(to: RunLoop.main, forMode: RunLoop.Mode.common)  }   fileprivate func stopMarquee() {  self.marqueeDisplayLink?.invalidate()  self.marqueeDisplayLink = nil  }   @objc fileprivate func processMarquee() {  var frame = self.containerView.frame   switch marqueeType {  case .left:  let targetX = -(self.contentView!.bounds.size.width &#43; self.contentMargin)  if frame.origin.x &amp;lt;= targetX {  frame.origin.x = 0  self.containerView.frame = frame  }else {  frame.origin.x -= pointsPerFrame  if frame.origin.x &amp;lt; targetX {  frame.origin.x = targetX  }  self.containerView.frame = frame  }  case .right:  let targetX = self.bounds.size.width - self.contentView!.bounds.size.width  if frame.origin.x &amp;gt;= targetX {  frame.origin.x = self.bounds.size.width - self.containerView.bounds.size.width  self.containerView.frame = frame  }else {  frame.origin.x &#43;= pointsPerFrame  if frame.origin.x &amp;gt; targetX {  frame.origin.x = targetX  }  self.containerView.frame = frame  }  case .reverse:  if isReversing {  let targetX: CGFloat = 0  if frame.origin.x &amp;gt; targetX {  frame.origin.x = 0  self.containerView.frame = frame  isReversing = false  }else {  frame.origin.x &#43;= pointsPerFrame  if frame.origin.x &amp;gt; 0 {  frame.origin.x = 0  isReversing = false  }  self.containerView.frame = frame  }  }else {  let targetX = self.bounds.size.width - self.containerView.bounds.size.width  if frame.origin.x &amp;lt;= targetX {  isReversing = true  }else {  frame.origin.x -= pointsPerFrame  if frame.origin.x &amp;lt; targetX {  frame.origin.x = targetX  isReversing = true  }  self.containerView.frame = frame  }  }  }   }  } JXMarqueeView源码
微信H5支付跳转回App 使用H5调起微信支付，完成支付或者取消支付后默认是回到Safari浏览器，如果想要回到支付前的App，需要利用redirect_url和URL Schema。
class PayAssist {  /// 微信支付url前缀  private let wxPayPrefix = &amp;#34;https://wx.tenpay.com/cgi-bin/mmpayweb-bin/checkmweb?&amp;#34;  private let redirectPrefix = &amp;#34;redirect_url=&amp;#34;   /// Reference from https://juejin.cn/post/6844904038908035085 &amp;amp; https://www.cnblogs.com/panchanggui/p/11693714.html  func callAsFunction(request: URLRequest) -&amp;gt; URLRequest? {  guard let urlStr = request.url?.absoluteString.removingPercentEncoding else {  return nil  }  // prevent secondary replacement  if urlStr.hasPrefix(wxPayPrefix), !isContainPayScheme(urlStr: urlStr) {  var finalUrlStr = &amp;#34;&amp;#34;  var newScheme = &amp;#34;&amp;#34;  let startIndex = urlStr.index(urlStr.startIndex, offsetBy: wxPayPrefix.count)  var strArr = String(urlStr[startIndex..&amp;lt;urlStr.endIndex]).components(separatedBy: &amp;#34;&amp;amp;&amp;#34;)  for (index, str) in strArr.enumerated() {  if str.hasPrefix(redirectPrefix), let payUrl = str.components(separatedBy: redirectPrefix).last, let scheme = findScheme(urlStr: payUrl) {  // remember original redirect_url to use when refreshing  strArr[index] = redirectPrefix &#43; scheme  PayAssistModel.paySchemesAndUrlDict[scheme] = payUrl  newScheme = scheme  break  }  }  finalUrlStr = wxPayPrefix &#43; strArr.joined(separator: &amp;#34;&amp;amp;&amp;#34;)   guard !newScheme.isEmpty,let url = URL(string: finalUrlStr) else {  return nil  }   // construct new request and add Referer  var newRequest: URLRequest = URLRequest(url: url)  newRequest.httpMethod = &amp;#34;Get&amp;#34;  newRequest.setValue(newScheme, forHTTPHeaderField: &amp;#34;Referer&amp;#34;)  return newRequest  }  return nil  }   /// 查找当前url是否包含支持的支付系统的域名，支持则返回对应的scheme，格式为&amp;#34;xxx://&amp;#34;  private func findScheme(urlStr: String) -&amp;gt; String? {  for scheme in MoEnvConfig.current.paySchemes {  if urlStr.contains(scheme.replacingOccurrences(of: &amp;#34;://&amp;#34;, with: &amp;#34;&amp;#34;)) {  return scheme  }  }  return nil  }   /// 是否包含支持的支付系统的scheme  private func isContainPayScheme(urlStr: String) -&amp;gt; Bool {  for scheme in MoEnvConfig.current.paySchemes {  if urlStr.contains(redirectPrefix &#43; scheme) {  return true  }  }  return false  } }  navigation bar黑色 将XCode升级到13.0 并且iOS系统升级到15.0之后发现navigation bar变成了黑色（App已经强制为浅色模式），发现对于navigation bar存在:In iOS 15, UIKit has extended the usage of the scrollEdgeAppearance, which by default produces a transparent background, to all navigation bars.。解决方案如下
if #available(iOS 13.0, *) {  let appearance = UINavigationBarAppearance()  appearance.configureWithOpaqueBackground()  appearance.backgroundColor = .white  appearance.shadowColor = .clear  self.navigationController?.navigationBar.standardAppearance = appearance  self.navigationController?.navigationBar.scrollEdgeAppearance = appearance } 参考资料 参考资料 参考资料
tabbar黑色 将XCode升级到13.0 并且iOS系统升级到15.0之后发现Tabbar变成了黑色（App已经强制为浅色模式），感觉tabbar应该也应该是上面的原因导致的。解决方案如下：
if #available(iOS 15.0, *) {  let appearance = UITabBarAppearance()  appearance.configureWithOpaqueBackground()  appearance.backgroundColor = .white  appearance.shadowColor = .clear  self.tabBar.standardAppearance = appearance  self.tabBar.scrollEdgeAppearance = appearance } 还有一个更简单的解决方案，就是直接将tabbar的背景色设置为白色，即self.tabBar.backgroundColor = .white也能解决问题。
toolBar黑色 let toolAppearance = UIToolbarAppearance() toolAppearance.configureWithOpaqueBackground() UIToolbar.appearance().standardAppearance = toolAppearance UIToolbar.appearance().scrollEdgeAppearance = toolAppearance UIToolbar.appearance().backgroundColor = .white sectionHeaderTopPadding 将XCode升级到13.0 并且iOS系统升级到15.0之后发现，tableView中设置的header高度比实际的高度要高，此时需要将tableView的sectionHeaderTopPadding属性设置为0：
if #available(iOS 15.0, *) {  self.tableView.sectionHeaderTopPadding = 0 } 如果对每个tableView都重新设置一遍tableView.sectionHeaderTopPadding = 0未免太繁琐。实际上可以设置全局生效，代码如下所示：
UITableView.appearance().sectionHeaderTopPadding = 0 参考资料
decode数组 定义结构体使用Codable协议时，对应model中有codable数组时，发现使用JSONSerialization.data(withJSONObject: $0, options: .fragmentsAllowed)获取到的data无法转换为model。这是因为使用默认的encode方法时发生了异常，例如定义的结构体中有[ArdPosModel]数组：
/// 兼岗信息 var ardPosInfos: [ArdPosModel]? 但使用默认的encode方法后，存储到数据库中后ardPosInfos增加了一对括号。如果再使用默认的decode方法则会报错：
(  {  groupId = 0000000000;  orgId = 100001;  pathId = &amp;#34;&amp;#34;;  pathName = &amp;#34;\U62db\U5546\U94f6\U884c&amp;#34;;  position = &amp;#34;\U603b\U5de5&amp;#34;;  userId = 009060;  userName = &amp;#34;\U5f20\U5f66\U6625&amp;#34;;  userOrd = 0;  } ) 一种可行的解决方案是自定义encode方法，然后在对ardPosInfos序列化的时候转成字符串，然后在对ardPosInfos进行decode的时候特殊处理：
let encoder = JSONEncoder() encoder.outputFormatting = .prettyPrinted if let infos = ardPosInfos, !infos.isEmpty, let data = try? encoder.encode(infos), let str = String(data: data, encoding: String.Encoding.utf8) {  try container.encodeIfPresent(str, forKey: .ardPosInfos) } if let infos = try? container.decode(Array&amp;lt;ArdPosModel&amp;gt;.self, forKey: .ardPosInfos) {  ardPosInfos = infos } else {  if let infosStr = try? container.decode(String.self, forKey: .ardPosInfos), let data = infosStr.data(using: .utf8), let infos = try? JSONDecoder().decode([ArdPosModel].se from: data) {  ardPosInfos = infos  } } 参考资料
多关键字Decode 最近后台接口改造，新接口和旧接口一起在用，虽然返回的JSON结构是一样的，但是字段名字有一些差别。例如，新接口使用userId，而就接口使用UserID或者userID。Swift中默认的Decode需要完全匹配关键字才能反序列化，下面是多关键字解决方案：
public struct AnyKey: CodingKey {  public var stringValue: String  public var intValue: Int?  public init(stringValue: String) {  self.stringValue = stringValue  }   public init?(intValue: Int) {  self.stringValue = String(intValue)  self.intValue = intValue  } }  public extension KeyedDecodingContainer where K == AnyKey {  func decode&amp;lt;T&amp;gt;(_ type: T.Type, forMappedKey key: String, in keyMap: [String: [String]]) throws -&amp;gt; T where T: Decodable {  for key in keyMap[key] ?? [] {  if let value = try? decode(T.self, forKey: AnyKey(stringValue: key)) {  return value  }  }  return try decode(T.self, forKey: AnyKey(stringValue: key))  } } public init(from decoder: Decoder) throws {  let keyMap = [  CodingKeys.userId.rawValue: [&amp;#34;userId&amp;#34;, &amp;#34;UserID&amp;#34;, &amp;#34;userID&amp;#34;],  CodingKeys.userName.rawValue: [&amp;#34;userName&amp;#34;, &amp;#34;UserName&amp;#34;],  CodingKeys.namePinYin.rawValue: [&amp;#34;namePinyin&amp;#34;],  ]  let container = try decoder.container(keyedBy: AnyKey.self)  func decode&amp;lt;Value&amp;gt;(_ key: String) throws -&amp;gt; Value where Value: Decodable {  return try container.decode(Value.self, forMappedKey: key, in: keyMap)  }  userId = (try? decode(CodingKeys.userId.rawValue)) ?? &amp;#34;&amp;#34;  userName = (try? decode(CodingKeys.userName.rawValue)) ?? &amp;#34;&amp;#34;  namePinYin = try? decode(CodingKeys.namePinYin.rawValue) } struct Foo: Decodable {  let contentIDs: [String]   enum CodingKeys: String, CodingKey, CaseIterable {  case contentIds, Ids, IDs  }   init(from decoder: Decoder) throws {  let container = try decoder.container(keyedBy: CodingKeys.self)  if let key = container.allKeys.filter({ CodingKeys.allCases.contains($0) }).first, let ids = try container.decodeIfPresent([String].self, forKey: key) {  self.contentIDs = ids  } else {  self.contentIDs = []  }  } } 参考资料
Bool Encode 使用默认encode方法序列化Bool类型时，最终是以integer类型存储至sqlite表中，其中false以0存储，true以1存储。但如果再使用Bool类型去decode则会报类型错误，应该使用int类型，然后根据得到的值转换为Bool类型：
public init(from decoder: Decoder) throws {  let keyMap = [  CodingKeys.hasChild.rawValue: [&amp;#34;hasChild&amp;#34;],  ]  let container = try decoder.container(keyedBy: AnyKey.self)  func decode&amp;lt;Value&amp;gt;(_ key: String) throws -&amp;gt; Value where Value: Decodable {  return try container.decode(Value.self, forMappedKey: key, in: keyMap)  }   // 特殊处理hasChild  if let hasChild: Bool = try? decode(CodingKeys.hasChild.rawValue) {  self.hasChild = hasChild  } else {  let tmp: Int = try decode(CodingKeys.hasChild.rawValue)  hasChild = (tmp == 1 ? true : false)  } } wireshark 在macOS中使用wireshark需要调整系统的安全策略，即需要关闭SIP系统完整性保护。对于intel和m1芯片来说，关闭sip系统完整性保护的方法不一样，具体可以参考macwk提供的方法。如果不关闭完整性保护，使用rvictl -s xxx-xxx命令时，会提示如下错误：
Starting device xxx-xxx [FAILED] 一旦关闭sip系统完整性保护后，再执行rvictl -s xxx-xxx后，显示Starting device xxx-xxx [SUCCEEDED] with interface rvi0表示成功。如果依然报错，则需要在系统设置---&amp;gt;安全性与隐私界面点击启用系统扩展，然后关机即可，具体参考启动失败。
其中的xxx是手机的udid。可以在finder中查到，也可以在Xcode---&amp;gt;Window---&amp;gt;Devices选中对应的设备，然后在Identifier后面看到udid。
使用wireshark时，想查看http请求的响应时间，可以在Column Preferences中添加自定义字段 http.time，具体参考这里。
基本使用 时间曲线
URLComponents 学习资料
百度地图sdk版本 项目中引入了百度地图的SDK，如果想要查看百度地图SDK的版本，可以直接在控制台或代码中使用BMKGetMapApiVersion()函数来获取当前版本：
BMKGetMapApiVersion() (lldb) po BMKGetMapApiVersion() ▿ Optional&amp;lt;String&amp;gt;  - some : &amp;#34;4.3.0&amp;#34; 百度定位sdk版本 项目中引入了百度定位的SDK，如果想要查看百度定位SDK的版本，可以直接在控制台或代码中使用BMKLocationKitVersion()函数来获取当前版本：
BMKLocationKitVersion() (lldb) po BMKLocationKitVersion() ▿ Optional&amp;lt;String&amp;gt;  - some : &amp;#34;2.0.0&amp;#34; 高德定位sdk版本 项目中引入了高德定位的SDK，如果想要查看高德定位SDK的版本，可以直接在控制台或代码中使用AMapLocationVersion变量来获取当前版本：
AMapLocationVersion (lldb) po AMapLocationVersion &amp;#34;2.6.8&amp;#34; 显示Product目录 老工程使用XCode 13.1打开后发现左侧导航栏的product目录消失了。此时需要到Xcode菜单栏中的Product--&amp;gt;Show Build Folder in Finder才能打开Product目录，如下图所示：
Failed import bridging header 在工程中执行单元测试代码时出现Failed to import bridging header &#39;/Users/xxx/Downloads/xxx/xxx/Common/xxx-Bridging-Header.h&#39;错误：
Failed to import bridging header &amp;#39;/Users/xxx/Downloads/xxx/xxx/Common/xxx-Bridging-Header.h&amp;#39; 点击工程设置，再点击右上角的Info，再在Configuration下Debug或Release找到对应的Tests，发现右侧的值为None。为了解决报错，只需要将其值改为待测试的Pod Target即可：
runJavaScriptAlertPanelWithMessage 今天测试H5的时候出现了闪退，报错信息为webView:runJavaScriptAlertPanelWithMessage:initiatedByFrame:completionHandler:] was not called。出现这个错误的原因是当前显示的页面不是WebView所在的页面（可能是被其他页面遮挡了），然后又去让WebViewController执行回调，也可能是WebView所在的页面被释放掉了。
webView:runJavaScriptAlertPanelWithMessage:initiatedByFrame:completionHandler:] was not called Could not find specified service 解决方案
Permission to debug com.cnn.iphone was denied https://stackoverflow.com/questions/28039524/instruments-stopped-working-on-iphone-apps/65785028#65785028
signed with a development identity Recovery Suggestion: The app must be signed with a development identity (e.g. iOS Developer). https://stackoverflow.com/questions/18905450/cant-launch-my-app-in-instruments-at-least-one-target-failed-to-launch/19258211#19258211
The certificate for this server is invalid 最近有个业务系统使用UIWebView打开时出现了白屏。经过排查发现该证书没有过期，但是域名和证书不匹配，导致出现如下所示报错：
&amp;#34;The certificate for this server is invalid. You might be connecting to a server that is pretending to be “wi.cloud.cmbchina.com” which could put your confidential information at risk.&amp;#34; 临时的解决方案是使用私有API放开这种证书有问题的域名：
@interface NSURLRequest (MoURLRequestCertificate) &#43; (BOOL)allowsAnyHTTPSCertificateForHost:(NSString*)host; &#43; (void)setAllowsAnyHTTPSCertificate:(BOOL)allow forHost:(NSString*)host; @end @implementation NSURLRequest &#43; (BOOL)allowsAnyHTTPSCertificateForHost:(NSString*)host {  return true; } 参考资料
KingFisher erminated due to memory issue 在UITableView中使用KingFisher加载图片时，若对应的url为gif图片，滑动的时候可能出现内存问题，导致App异常退出。
debug时Xcode会提示Message from debugger: Terminated due to memory issue。此时解决方案有两种，第一种是在调用kf.setImage时在options参数中增加onlyLoadFirstFrame参数。那么此时只会加载gif的第一帧，自然也不会导致内存溢出：
setImage(with: source, placeholder: defaultImage, options: [.onlyLoadFirstFrame]) 第二种解决方案是使用KingFisher提供的AnimatedImageView。此时，当url是普通的图片时会正常显示，若是gif则会自动显示动画。但千万要注意需要把runLoopMode = .default，否则滚动的时候依然会有内存问题：
self.dkImageView.autoPlayAnimatedImage = true self.dkImageView.needsPrescaling = true self.dkImageView.backgroundDecode = true self.dkImageView.framePreloadCount = 1 self.dkImageView.runLoopMode = .default self.dkImageView.repeatCount = .once  override func prepareForReuse() {  super.prepareForReuse()  self.headerImageView.kf.cancelDownloadTask()  self.headerImageView.stopAnimating()  self.dkImageView.kf.cancelDownloadTask()  self.dkImageView.stopAnimating() } 二进制重排 如果想要获取二进制重排需要的order文件，可以直接引用AppOrderFiles组件：
pod &amp;#39;AppOrderFiles&amp;#39; 然后在Podfile文件中添加如下代码，完成必要的设置：
post_install do |installer|  installer.pods_project.targets.each do |target|  target.build_configurations.each do |config|  config.build_settings[&amp;#39;OTHER_CFLAGS&amp;#39;] = &amp;#39;-fsanitize-coverage=func,trace-pc-guard&amp;#39;  config.build_settings[&amp;#39;OTHER_SWIFT_FLAGS&amp;#39;] = &amp;#39;-sanitize-coverage=func -sanitize=undefined&amp;#39;  end  end end 最后在代码中添加以获取重排文件，重新编译安装后，再导出安装包数据，在tmp文件下找到app.order:
AppOrderFiles() { path in  debugPrint(path ?? &amp;#34;&amp;#34;) } AppOrderFiles
Library not loaded 如果项目之前没有报错，在某次编译时突然出现Library not loaded @rpath/libswiftAssetsLibrary.dylib错误，则需要清空工程缓存，重新编译。
dyld: Library not loaded: @rpath/libswiftAssetsLibrary.dylib  Referenced from: /var/containers/Bundle/Application/C219593F-9265-4F99-8947-AFBD4A430AAC/xxx.app/xxx  Reason: image not found dyld: Library not loaded: /System/Library/Frameworks/Network.framework/Network  Referenced from: /var/containers/Bundle/Application/712C7509-626F-4B42-83F3-EA3537A6D9A1/xxx.app/xxx  Reason: image not found 参考资料
443 Operation timed out 在安装
解决方案
ValidHexNumber /// 校验给定字符串是否为16进制字符串 /// - Parameter iv: iv字符串 /// - Returns: 是否合法的16进制字符串 private func isValidHexNumber(iv: String) -&amp;gt; Bool {  let chars = CharacterSet(charactersIn: &amp;#34;0123456789ABCDEF&amp;#34;).inverted  guard iv.uppercased().rangeOfCharacter(from: chars) == nil else {  return false  }  return true } private func isValidHexNumber(iv: String) -&amp;gt; Bool {  return iv.allSatisfy(\.isHexDigit) } 当前页面是否正显示 如果要判断当前页面是否正在显示，可以使用如下两种方式，代码如下所示：
/// 判断当前页面是否正在显示 private func isDisplaying() -&amp;gt;Bool {  // 参考自https://programmersought.com/article/99624367116/  return (self.isViewLoaded &amp;amp;&amp;amp; self.view.window != nil) } private func isDisplaying() -&amp;gt;Bool {  // 参考自https://stackoverflow.com/questions/2777438/how-to-tell-if-uiviewcontrollers-view-is-visible  return self.viewIfLoaded?.window != nil } duplicate symbols for architecture arm64 duplicate symbol &amp;#39;_OBJC_CLASS_$_CMBSMDLL&amp;#39; in:  /Users/xxx/Downloads/xxx/Pods/LC10_AiLabFaceRecognitionCloud/Encrypt/lib-china-sm-iphoneos.a(SMDLL.o)  /Users/xxx/Downloads/xxx/Pods/LC10_01_MPGMK/SDK/MPGMK.framework/MPGMK(SMDLL.o) duplicate symbol &amp;#39;_OBJC_METACLASS_$_CMBSMDLL&amp;#39; in:  /Users/xxx/Downloads/xxx/Pods/LC10_AiLabFaceRecognitionCloud/Encrypt/lib-china-sm-iphoneos.a(CMBSMDLL.o)  /Users/xxx/Downloads/xxx/Pods/LC10_01_MPGMK/SDK/MPGMK.framework/MPGMK(SMDLL.o) ld: 2 duplicate symbols for architecture arm64 clang: error: linker command failed with exit code 1 (use -v to see invocation) 将Other Linker Flags设置中的-force_load去掉。
参考资料
取消刷新时的动画 使用reloadRows(at: [indexPath], with: .none)对tableView某个单元格刷新时，即使第2个参数已经设置为.none，仍然有明显的刷新效果，为了取消这种动画效果，需要使用performWithoutAnimation：
UIView.performWithoutAnimation {  self.tableView.reloadRows(at: [indexPath], with: .none) } 如果在reloadData数据时有动画，但想要一种更丝滑的方式加载，即去除动画效果（Used when loading more data into UITableView for a smooth &amp;quot;infinite scroll&amp;quot; feel），可以尝试使用如下代码：
/// 流畅版reloadData，避免闪烁和动画 func reloadDataSmoothly() {  UIView.setAnimationsEnabled(false)  CATransaction.begin()  CATransaction.setCompletionBlock {  UIView.setAnimationsEnabled(true)  }  reloadData()  beginUpdates()  endUpdates()  CATransaction.commit() } 参考资料
清除WK缓存和Cookie private func clearAllCookies() {  URLCache.shared.removeAllCachedResponses()  HTTPCookieStorage.shared.cookies?.forEach(HTTPCookieStorage.shared.deleteCookie)  let types = Set([WKWebsiteDataTypeDiskCache,  WKWebsiteDataTypeMemoryCache,  WKWebsiteDataTypeOfflineWebApplicationCache,  WKWebsiteDataTypeCookies,  WKWebsiteDataTypeSessionStorage,  WKWebsiteDataTypeLocalStorage,  WKWebsiteDataTypeWebSQLDatabases,  WKWebsiteDataTypeIndexedDBDatabases])  WKWebsiteDataStore.default().fetchDataRecords(ofTypes: types) { (records) in  WKWebsiteDataStore.default().removeData(ofTypes: types, for: records) {  debugPrint(&amp;#34;WK domain cleaned cache&amp;#34;)  }  } } 如果要按照域名来清除WKWebView的缓存和Cookie，可以使用如下代码：
public extension WKWebView {   static func cleanCache(url: URL) {   HTTPCookieStorage.shared.cookies?.forEach({ (cookie) in  guard let url = url.host else {  return  }  // domain前面带.表示子域发送http请求时会自动带上  if cookie.domain == url || cookie.domain == &amp;#34;.&amp;#34; &#43; url {  HTTPCookieStorage.shared.deleteCookie(cookie)  }  })   let types = Set([WKWebsiteDataTypeDiskCache,  WKWebsiteDataTypeMemoryCache,  WKWebsiteDataTypeOfflineWebApplicationCache,  WKWebsiteDataTypeCookies,  WKWebsiteDataTypeSessionStorage,  WKWebsiteDataTypeLocalStorage,  WKWebsiteDataTypeWebSQLDatabases,  WKWebsiteDataTypeIndexedDBDatabases])  WKWebsiteDataStore.default().fetchDataRecords(ofTypes: types) { (records) in  let tmpRecord = records.filter({ url.host?.hasSuffix($0.displayName) ?? false })  WKWebsiteDataStore.default().removeData(ofTypes: types, for: tmpRecord) {  debugPrint(&amp;#34;WK domain cleaned cache&amp;#34;)  }  }  URLCache.shared.removeCachedResponse(for: URLRequest(url: url))  } } url中文编码 /// url中文转码，其中#不转码 var urlChineseEncoding: String? {  var charSet = CharacterSet.urlQueryAllowed  charSet.insert(charactersIn: &amp;#34;#&amp;#34;)  return self.addingPercentEncoding(withAllowedCharacters: charSet) } 参考资料
failed to parse error: expression failed to parse: error: Couldn&amp;#39;t realize type of self. AppCode 使用AppCode编译工程时，一直报错
点击Debug Log Settings后添加如下的设置：
#com.jetbrains.cidr.execution.deviceSupport #com.jetbrains.cidr.execution.debugger 接着重新编译，直到报错信息出来，然后再在工具栏点击Help--&amp;gt;Show Log in Finder，打开日志文件idea.log。发现有如下所示报错：
FINE - #c.j.c.e.debugger - LLDBFrontend: E0505 14:41:25.368477 338892288 TCPClient.cpp:103] ERROR, no such host as localhost 原因是hosts文件中缺少127.0.0.1 localhost，只要添加这一条即可：
127.0.0.1 localhost 互斥单选 如果要实现UITableView中的cell互斥单选，并且至少有一个cell被选中时，可以使用如下代码实现：
 override func setSelected(_ selected: Bool, animated: Bool) {  super.setSelected(selected, animated: animated)  if selected {  self.checkImgView.image = UIImage(named: checekedImgName)  } else {  self.checkImgView.image = UIImage(named: uncheckedImgName)  }  } iOS simulator 如果在模拟器上编译代码时出现Could not find module for target &#39;x86_64-apple-ios-simulator&#39;，那就是编译架构没有选择x86_64:
参考资料
didFailProvisionalLoadForFrame ST环境App出现帧框加载已中断的提示，复现步骤为编译安装ST包，但网络切到外网。拿到的报错信息如下所示：
2022-07-14 14:35:36.725525&#43;0800 CMBMobileST[83366:5125532] [Process] 0x113199c18 - [pageProxyID=18, webPageID=19, PID=83370] WebPageProxy::didFailProvisionalLoadForFrame: frameID=3, domain=WebKitErrorDomain, code=102, isMainFrame=1 调试发现是热点轻应用导致的报错，按照网上的资料，说是四种情况会出现这个，分别是：
 url未添加scheme 使用webview打开本地文件时未正确设置contentType 服务端未正确响应 重定向导致  前面两种情况可以排除，通过排查其他应用，基本也可以排除第3种情况，怀疑是第4种情况。使用下面代码临时规避：
let err = (error as NSError) switch (err.code, err.domain) { case (NSURLErrorCancelled, _), (102, &amp;#34;WebKitErrorDomain&amp;#34;):  printDebug(msg: err.localizedDescription) default:  FlashAlertView(message: error.localizedDescription, delegate: nil).show() } 参考资料
TLS10 is not accepted 使用IntelliJ IDEA连接Microsoft SQL Server时会提示The server selected protocol version TLS10 is not accepted by client preferences [TLS13, TLS12]：
[08S01] The driver could not establish a secure connection to SQL Server by using Secure Sockets Layer (SSL) encryption. Error: &amp;#34;The server selected protocol version TLS10 is not accepted by client preferences [TLS13, TLS12]&amp;#34;. ClientConnectionId:a8fbe132-f476-412f-ad23-4f53516c5007 The server selected protocol version TLS10 is not accepted by client preferences [TLS13, TLS12]. 查资料发现，这是因为IDEA版本升级后，自带的jdk版本也升级了，所以需要删除自带的jdk对应的java.security中的对应内容。java.security对应的路径为/Applications/IntelliJ IDEA.app/Contents/jbr/Contents/Home/conf/security/java.security，大约在731行注释即可：
# jdk.tls.disabledAlgorithms=SSLv3, TLSv1, TLSv1.1, RC4, DES, MD5withRSA, \  DH keySize &amp;lt; 1024, EC keySize &amp;lt; 224, 3DES_EDE_CBC, anon, NULL, \ iOS 14&#43;以上无法安装企业App 最近自动化部署改造，将待安装的ipa文件挪到其它位置，使用iOS 14以上系统验证的时候发现无法安装，但没有任何提示。测试发现，ipa的链接能够正常下载，也能够单独安装。后来服务端排查发现，虽然plist文件是放在https服务器的，但是ipa却存放在http的域名下，因此无法正常安装。
  plist文件必须是放在https服务器
  主要是对于ipa是否要放在https服务器，两种办法: 如果是域名访问ipa,必须是https服务器。如果是ip访问ipa，https和http服务器都是可以的。
参考资料
  xcframework 生成xcframework的工程设置了最低支持的版本，如果在不支持的版本的真机上编译时，会出现如下启动闪退，只需要将最低支持版本调整一下即可：
Thread 3 Crashed: 0 dyld 0x000000010a9a47d0 __abort_with_payload &#43; 8 1 dyld 0x000000010a9a3d80 abort_with_payload_wrapper_internal &#43; 104 2 dyld 0x000000010a9a3db4 fcntl &#43; 0 3 dyld 0x000000010a960b40 dyld::fastBindLazySymbol&#43; 19264 (ImageLoader**, unsigned long) &#43; 0 4 dyld 0x000000010a960c6c dyld::fastBindLazySymbol&#43; 19564 (ImageLoader**, unsigned long) &#43; 300 5 libdyld.dylib 0x00000001837d8738 _dyld_fast_stub_entry&#43; 18232 (void*, long) &#43; 80 6 libdyld.dylib 0x00000001837d7240 dyld_stub_binder &#43; 60 7 CMBMobileST 0x00000001063a5064 &#43;[MPSM3 dataDigestFromMsg:] &#43; 108 8 CMBMobileST 0x00000001063a4f5c &#43;[MPSM3 stringDigestFromMsg:] &#43; 36 Stored properties cannot be marked potentially unavailable with &amp;lsquo;@available&amp;rsquo; 如果不想大改代码，临时的解决方案如下：
#if compiler(&amp;lt;5.7) #endif 参考资料
does not contain bitcode. You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE), obtain an updated library from the vendor, or disable bitcode for this target 在设置中将对应的framework的设置中Enable Bitcode改为No即可：
error build: &amp;#39;/Users/xxx/Library/Developer/Xcode/DerivedData/xxx-fjdqujfoagssicejpisepgndqmsf/Build/Products/Debug-iphoneos/xxx/xxx.framework/xxx(xxx-dummy.o)&amp;#39; does not contain bitcode. You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE), obtain an updated library from the vendor, or disable bitcode for this target. file &amp;#39;/Users/xxx/Library/Developer/Xcode/DerivedData/xxx-fjdqujfoagssicejpisepgndqmsf/Build/Products/Debug-iphoneos/xxx/xxx.framework/xxx&amp;#39; for architecture arm64 Signing for &amp;ldquo;xxx&amp;rdquo; requires a development team. Select a development team in the Signing &amp;amp; Capabilities editor. (in target &amp;lsquo;xxx&amp;rsquo; from project &amp;lsquo;Pods&amp;rsquo; post_install do |installer|  installer.generated_projects.each do |project|  project.targets.each do |target|  target.build_configurations.each do |config|  config.build_settings[&amp;#34;DEVELOPMENT_TEAM&amp;#34;] = &amp;#34; Your Team ID &amp;#34;  end  end  end end 参考资料
</content>
    </entry>
    
     <entry>
        <title>ruby</title>
        <url>https://iihui.github.io/post/ruby/</url>
        <categories>
          <category>ruby</category>
        </categories>
        <tags>
          <tag>ruby</tag>
        </tags>
        <content type="html"> Ruby有时会让人感觉出奇地像英语。Ruby只是数百种编程语言中的一种，但它很特别，因为对许多程序员来说，它感觉很像一种自然语言，同时又具有计算机所要求的清晰性。如果运行下面的代码，将会打印Hello, world!字符串十次。
10.times do print &amp;#34;Hello, world!&amp;#34; end 在irb中，上面代码运行后除了会打印十次Hello, world!，还会紧跟着=&amp;gt; 10，这表明10.times do print &amp;quot;Hello, world!&amp;quot; end作为表达式的结果为10。这是因为Ruby中所有代码行都是由有返回值的表达式组成的。
print &amp;#34;test&amp;#34; test =&amp;gt; nil 在irb中上面的代码执行后会打印test，并且后面紧跟着=&amp;gt; nil。这是因为print除了打印，不会返回任何值，所以print &amp;quot;test&amp;quot;作为表达式的返回值为nil。
与许多其它编程语言不同，Ruby的行尾不需要分号（尽管使用分号也无妨）。对于有经验的程序员来说，一开始可能需要一点时间来适应，但对于新程序员来说，这个特性使Ruby更容易学习。
puts和print的区别 puts和print的区别：puts输出内容后自动将光标移动到下一行。在下面的代码中，print输出内容后不会换行，所以使用puts输出时world将紧接着hello，然后换行，最后输出test：
print(&amp;#34;hello &amp;#34;) puts(&amp;#34;world&amp;#34;) puts(&amp;#34;test&amp;#34;)  # hello world # test Basic Variables  局部变量：局部变量以小写字母或下划线开头，由字母、下划线和/或数字组成。x、string、abc、var1、start_value 和 firstName都是有效的局部变量名。但是请注意，Ruby约定在组合多个单词的局部变量名称时使用下划线而不是驼峰式大小写。例如，一般使用first_name而不是firstName。 实例变量：用于在单个对象中存储信息的实例变量始终以单个@符号开头，其后包含与局部变量相同的字符集，例如@age和@last_name。虽然局部变量不能以大写字母开头，但实例变量可以在@符号之后的第一个位置有一个（尽管它可能在这个位置没有数字）。但通常@符号后面的字符是小写字母。 类变量：存储每个类层次结构的信息（同样，在这个阶段不要担心语义），遵循与实例变量相同的规则，除了它们以两个@@符号开头——例如，@@running_total。 全局变量可以通过它们的前导美元符号来识别——例如，$population。美元符号后面的段不遵循局部变量命名约定，全局变量$:, $1, $/,$stdin,$LOAD_PATH都是合法的。只要它以美元符号开头，它就是一个全局变量。至于非字母数字标识符，你可能会看到的唯一此类标识符是预定义的，因此无需担心哪些标点符号是合法的，哪些不是。  Ruby有许多预先定义的关键字。包括def（用于方法定义）、class（用于类定义）、if（条件执行）和__FILE__（当前正在执行的文件的名称），大约有40个，它们通常是比较简短的标识符。
在Ruby中，方法的名称遵循与局部变量相同的规则和惯例（除了它们可以以?、!或=结尾，其意义将在后面解释）。在某些情况下，无法通过观察一个表达式来判断看到的是一个局部变量还是一个方法名——这是故意的。
Data, Expressions, and Flow Control 计算机程序几乎所有的时间都在操作数据或等待数据从其它地方送达。当输入文字、短语和数字，听音乐，看视频时计算机进行计算，作出决定，并向我们传递信息。要编写计算机程序，必须先了解数据及其操作的基本知识。
Numbers and Expressions 编程时，表达式是数据（例如数字或字符串）、运算符（例如&#43;或-）和变量的组合。当计算机理解这些表达式时，会产生某种形式的结果。下面这些都是表达式：
5 1 &#43; 2 &amp;#34;a&amp;#34; &#43; &amp;#34;b&amp;#34; &#43; &amp;#34;c&amp;#34; 100 - 5 * (2 - 1) x &#43; y 变量是占位符或对对象的引用，包括数字、文本或创建的任何类型的对象。可以随心所欲地命名变量，只是有一些限制。变量名称必须是一个单元（中间不能有空格）；必须以字母或下划线开头；必须只包含字母、数字或下划线；并且区分大小写。
   变量名 是否有效     x 是   Y2 是   _x 是   7x 否，字母开头   this_is_a_test 是   this is a test 否，包含空格   this&amp;rsquo;is@a&amp;rsquo;test! 否，包含特殊字符‘，@，！   this-is-a-test 否，包含特殊字符-    由于变量是值和数据的占位符，因此它们也可以用表达式的结果赋值（例如x = 2 - 1）并用于表达式本身（例如 x - y &#43; 2）。
没有逻辑的程序仅仅是一个计算器。计算机不只是对数据进行单一操作，还使用逻辑来决定不同的行动方案。逻辑的一个基本形式是在表达式中使用比较运算符来做决定:
age = 10 puts &amp;#34;You&amp;#39;re too young to use this system&amp;#34; if age &amp;lt; 18  age = 24 puts &amp;#34;You&amp;#39;re NOT a teenager&amp;#34; unless age &amp;gt; 12 &amp;amp;&amp;amp; age &amp;lt; 20 Ruby提供了另一个更方便的between?方法，如果对象介于或等于两个提供的值，则返回真或假。例如，在处理整数时，age.between?(13, 19)相当于age &amp;gt;= 13 &amp;amp;&amp;amp; age &amp;lt;= 19：
age = 18 puts &amp;#34;You&amp;#39;re a teenager&amp;#34; if age.between?(12, 20) Looping Through Numbers with Blocks and Iterators 在下面的代码中，首先取了5，然后调用times方法（这个方法对于所有的数字类型都适用）。不是向这个方法传递数据，而是向它传递代码：do和end之间的代码。然后，times方法将会连续使用该代码五次，产生前面的五行输出：
5.times do puts &amp;#34;Test&amp;#34; end 另一种写法是用花括号代替do和end。尽管鼓励do和end用于多行代码块，但花括号使代码在单行上更易于阅读。因此，下面的代码的执行后结果完全相同：
5.times { puts &amp;#34;Test&amp;#34;} 也就说，对于单行代码建议使用花括号，但对较长的代码块将使用do和end。这是一个很好的习惯，几乎所有专业的Ruby开发者都遵循这种风格。
在Ruby中，创建循环的一种机制称为迭代器。迭代器是逐个遍历项目列表的东西。还有其他迭代器可用于数字，例如：
1.upto(5) { ...code to loop here... }  10.downto(5) { ...code to loop here... }  0.step(50, 5) { ...code to loop here... } 不明显的是如何知道每一步迭代中的数字，以便可以在循环的代码块中使用它。如果想打印出当前的迭代次数怎么办？如何使用这些迭代器开发计数程序？值得庆幸的是，刚刚解释的所有迭代器都会自动将迭代的状态作为参数传递给循环代码，然后可以将其检索到变量中并使用，如下所示：
1.upto(5) do |number|  puts number end 需要注意的是，有些方法会执行代码块并传递数据，然后可以将数据捕获到变量中。在上面的例子中，对整数可用的upto方法将每次迭代的值传递到代码块中，我们将其&amp;quot;captured&amp;quot;到变量number中。
Floating Point Numbers 默认情况下，Ruby将任何没有为小数点的数字视为整数。当使用10 / 3 时，实际上是要求Ruby将两个整数相除，而Ruby会给出一个整数作为结果。因此，下面的代码运行后的结果为3，而不是3.333：
puts 10 / 3 如果将代码做一些小小的改动：
puts 10 / 3.0 puts 10.0 / 3 puts 10.0 / 3.0 则输出的结果将会是3.3333333333333335。上面的代码Ruby处理Float类型的数字对象，并返回一个Float，并提供期望的精度级别。
在某些情况下，无法控制传入的数字，但仍希望将它们视为浮点数。考虑一种情况，用户输入两个要除的数字，而这些数字需要一个精确的答案：
x = 10 y = 3 puts x / y 上面代码中两个输入数字都是整数，所以结果是一个整数。幸运的是，整数有一种特殊的方法可以即时将它们转换为浮点数，只需像下面这样重写代码即可：
x = 10 y = 3 puts x.to_f / y 相似地，浮点数也可以转换为整数类型，只要使用to_i方法即可：
puts(5.7.to_i) puts(5.7.to_int) Constants 考虑一些永远不会改变的值——例如pi的值。这些不变的值称为常量，在Ruby中可以用以大写字母开头的变量名来表示：
Pi = 3.141592 如果尝试改变Pi的值，虽然是可以的，但编译器会产生警告already initialized constant Pi。Ruby让我们可以完全控制常量的值（可以改变常量的值），但编译器会发出明确的警告信息。将来，Ruby可能会对常量实施更严格的控制，因此请尊重这种使用方式，并尽量不要在程序中给常量重新赋值。
Text and Strings 字符串是任意长度的文本字符（包括数字、字母、空格和符号）的集合。 Ruby中的所有字符串都是String类型对象，可以通过调用字符串的类方法class并打印结果来查看：
puts &amp;#34;Hello world&amp;#34;.class # String 如同数字类型，字符串也可以使用操作符：
x = &amp;#34;Test&amp;#34; y = &amp;#34;String&amp;#34; puts &amp;#34;Success!&amp;#34; if x &#43; y == &amp;#34;TestString&amp;#34; 使用双引号仅适用单行字符串，但如果字符串文本想跨越多行，请尝试以下操作：
x = %q{This is a test of the multi line capabilities} puts x 在上面的例子中，多行字符串以%q{ }包裹。实际上花括号是非必须的，可以使用&amp;lt;和&amp;gt;，（和），或者简单地使用你选择的其它两个定界符，例如！和！。下面这段代码将以完全相同的方式工作：
x = %q!This is a test of the multi line capabilities! puts x 如果使用感叹号作为分隔符，那么字符串文本中的任何感叹号都会导致字符串提前结束，Ruby会认为剩余的字符串文本是错误的，所以应该谨慎地选择分隔符：
x = %q!This is a test of the multi line! capabilities! puts x // Uncaught exception: undefined method `capabilities!&amp;#39; for main:Object 构建多行字符串字面量的另一种方法是使用here文档或heredoc，这是在许多其它编程语言中发现的概念。它的工作方式与前面的示例类似，不同之处在于分隔符可以是多个字符。下面是一个例子：
x = &amp;lt;&amp;lt;END_MY_STRING_PLEASE This is the string And a second line END_MY_STRING_PLEASE puts x 在上面的例子中，&amp;lt;&amp;lt;标记字符串字面量的开头，然后使用END_MY_STRING_PLEASE作为字符串常量的分隔符。字符串真正的内容从下一个新行开始，分隔符在最后一行再次重复时表示字符串字面量结束。
当比较字符串时，实际上比较的是字符串中字符对应的数字（ASCII码）。如前所述，字符在计算机内存中存储为数字，每个字母和符号都有一个值，称为ASCII值：
puts &amp;#34;Success!&amp;#34; if &amp;#34;Test&amp;#34; &#43; &amp;#34;String&amp;#34; == &amp;#34;TestString&amp;#34; puts &amp;#34;abc&amp;#34; * 5 puts &amp;#34;x&amp;#34; &amp;gt; &amp;#34;y&amp;#34;  Success! abcabcabcabcabc false 可以通过字符的ord方法获取ASCII值。相应地，也可以通过chr函数将ASCII值转换为字符：
puts &amp;#34;x&amp;#34;.ord #Integer puts 120.chr #String 插值是指将表达式的结果插入字符串常量的过程。在字符串中进行插值的方法是将表达式放在#{ }符号内。下面是一个简单的例子：
x = 10 y = 20 puts &amp;#34;#{x}&#43; #{y}= #{x &#43; y}&amp;#34; # 10 &#43; 20 = 30 puts &amp;#34;100 * 5 = #{100 * 5}&amp;#34; # 100 * 5 = 500 x = &amp;#34;cat&amp;#34; puts &amp;#34;The #{x}in the hat&amp;#34; # The cat in the hat puts &amp;#34;It&amp;#39;s a #{&amp;#34;bad &amp;#34; * 5}world&amp;#34; # It&amp;#39;s a bad bad bad bad bad world Regular Expressions 正则表达式本质上是一个搜索查询，不要与表达式混淆。如果想要替换字符串的某些字符，可以使用sub方法，但是sub只替换第一次出现的字符。如果要做全局替换，则需要使用gsub方法：
puts &amp;#34;foobar&amp;#34;.sub(&amp;#39;bar&amp;#39;, &amp;#39;foo&amp;#39;) # foofoo puts &amp;#34;this is a test&amp;#34;.gsub(&amp;#39;i&amp;#39;, &amp;#39;&amp;#39;) # ths s a test 如果先要替换开头的两个字符，可以使用如下方式：
x = &amp;#34;This is a test&amp;#34; puts x.sub(/^../, &amp;#39;Hello&amp;#39;) 上面的代码中，sub方法的第一个参数不是字符串，而是一个正则表达式。在正则表达式中^是一个锚点，意味着正则表达式将从字符串中任何行的开头开始匹配。其中的.代表任何字符。也就是说，/^../意味着「紧随一行开始之后的任何两个字符」。因此，This is a test的Th被替换为Hello。相应地，下面的代码替换行字符串最后两个字符为Hello：
x = &amp;#34;This is a test&amp;#34; puts x.sub(/..$/, &amp;#39;Hello&amp;#39;)  # This is a teHello  x = &amp;lt;&amp;lt;TEST this is a test dddd TEST puts x.sub(/..$/, &amp;#39;Hello&amp;#39;)  # this is a tesHello # dddd 如果想锚定一个字符串的绝对开始或结束，你可以分别使用\A和\Z（都是大写），而^和$则只是锚定一个字符串中的行的开始和结束:
x = &amp;lt;&amp;lt;TEST This is a test dd TEST puts x.sub(/..\Z/, &amp;#39;Hello&amp;#39;)  #This is a test # Hello  x = &amp;lt;&amp;lt;TEST This is a test dd TEST puts x.sub(/\A../, &amp;#39;NA&amp;#39;)  # NAis is a test # dd 如果想遍历一个字符串，并能访问其中的每一部分，怎么办呢？scan就是我们要找的迭代器方法。在下面的代码中，scan方法扫描字符串以查找与传递给它的正则表达式匹配的任何内容：
&amp;#34;xyz&amp;#34;.scan(/./) { |letter| puts letter } 在上面的代码中，我们提供了一次查找单个字符的正则表达式。这就是在输出中分别得到x、y和z的原因。每个字母都被输入到块中，赋值给letter，然后打印到屏幕上。
&amp;#34;This is a test&amp;#34;.scan(/../) { |x| puts x } 在上面的代码中，一次扫描两个字符，最后的打印结果如下所示：
Th is  i s a te st 实际上，上面扫描的结果中是包含空格的，如果想要只包含数字和字母，可以使用如下方式：
&amp;#34;This is a test&amp;#34;.scan(/\w\w/) { |x| puts x } 上面的\w表示任何数字和字母字符以及下划线。在正则表达式中，有一些用反斜杠表示的特殊字符，它们具有特殊的含义，如下表所示：
参考上表，可以很轻松地从字符串中提取所有数字：
&amp;#34;The car costs $1000 and the cat costs $10&amp;#34;.scan(/\d&#43;/) do |x|  puts x end # 1000 # 10 在上面\d后面跟着的&#43;被称为修饰器，它表示尽可能多地匹配，并且至少匹配一个。如果不添加&#43;，则只会匹配一个数字：
&amp;#34;The car costs $1000 and the cat costs $10&amp;#34;.scan(/\d/) do |x|  puts x end  # 1 # 0 # 0 # 0 # 1 # 0 还有其它类型的修饰符：
在正则表达式中，有一个重要的方面是字符类，它允许匹配一组特定的字符。例如，可以扫描字符串中的所有元音字符：
&amp;#34;This is a test&amp;#34;.scan(/[aeiou]/) { |x| puts x } # i # i # a # e 也可以在方括号内指定字符范围：
&amp;#34;This is a test&amp;#34;.scan(/[a-m]/) { |x| puts x } # h # i # i # a # e 进行替换并从字符串中提取某些文本很有用，但有时只想检查某个字符串是否与选择的模式匹配。如果字符串包含任何元音，你可能希望快速确定：
puts &amp;#34;String has vowels&amp;#34; if &amp;#34;This is a test&amp;#34; =~ /[aeiou]/ 在上面的代码中=~是匹配运算符，如果字符串与运算符后面的正则表达式匹配，则表达式会返回第一个匹配项的位置（在上面这种情况下返回的是2——逻辑上为true，因此满足if条件）。当然，也可以做相反的事情：
puts &amp;#34;String contains no digits&amp;#34; unless &amp;#34;This is a test&amp;#34; =~ /[0-9]/ 上面的代码的意思是除非0到9的数字范围与测试字符串匹配，否则告诉用户字符串中没有数字。也可以使用String类提供的称为match的方法。=~根据正则表达式是否匹配字符串，返回第一个匹配项的位置或nil，而match提供了更多的功能。
puts &amp;#34;String has vowels&amp;#34; if &amp;#34;This is a test&amp;#34;.match(/[aeiou]/) 在正则表达式中，如果用括号（）括住表达式的一部分，则与正则表达式的该部分匹配的数据将与其余部分分开使用。match允许访问此数据：
x = &amp;#34;This is a test&amp;#34;.match(/(\w&#43;) (\w&#43;)/) puts x[0] puts x[1]  This is This is 字符串的match方法返回一个MatchData对象，它可以像数组一样被访问。第一个元素（x[0]）包含由整个正则表达式匹配的数据。然而，每个连续的元素都包含被正则表达式的每个匹配组所匹配的数据。在这个例子中，第一个（\w&#43;）匹配的是This，第二个（\w&#43;）匹配的是is。
Arrays and Lists 在数组中，每个元素都用逗号与其相邻元素隔开，方括号用于表示数组字面量。每个元素都可以使用索引访问，索引也是从0开始，如果索引越界不会发生闪退现象，而是取到空nil：
x = [1, 2, 3, 4] puts x[2] # 3 puts x[4] # nil 数组不需要设置预定义条目或手动分配元素，可以像下面这样创建一个空数组。此时可以使用&amp;lt;&amp;lt;往数组最后添加新的元素，或者使用push方法：
x = [] x &amp;lt;&amp;lt; &amp;#34;test&amp;#34; puts x x.push(&amp;#34;hello&amp;#34;) puts x  test test hello 也可以从数组中一个个移除元素。Ruby中的数组可以充当栈，遵循「后进先出」原则，其中的元素被推送到数组的末尾并从末尾弹出（弹出是从数组末尾检索和删除元素的过程）:
x = [] x &amp;lt;&amp;lt; &amp;#34;Word&amp;#34; x &amp;lt;&amp;lt; &amp;#34;Play&amp;#34; x &amp;lt;&amp;lt; &amp;#34;Fun&amp;#34; puts x.pop # 影响原数组 puts x.pop puts x.length  Fun Play 1 如果数组中的元素都是字符串，可以使用join方法将所有元素连接起来：
x = [&amp;#34;Word&amp;#34;, &amp;#34;Play&amp;#34;, &amp;#34;Fun&amp;#34;] puts x.join, x.join(&amp;#34;,&amp;#34;)  WordPlayFun Word,Play,Fun 也可以使用split方法将字符串分隔成数组：
puts &amp;#34;Short sentence. Another. No more.&amp;#34;.split(/\./).inspect 因为在正则表达式中.表示任意字符，所以需要使用\.来表示点（加上反斜杠来对其进行转义）。而inspect方法对Ruby中几乎所有的内置类都是通用的，它提供了对象的文本表示。
puts &amp;#34;Words with lots of spaces&amp;#34;.split(/\s&#43;/).inspect  [&amp;#34;Words&amp;#34;, &amp;#34;with&amp;#34;, &amp;#34;lots&amp;#34;, &amp;#34;of&amp;#34;, &amp;#34;spaces&amp;#34;] p也很重要，它是inspect的替代方法。前面的例子也可以这样写：
p &amp;#34;Words with lots of spaces&amp;#34;.split(/\s&#43;/)  [&amp;#34;Words&amp;#34;, &amp;#34;with&amp;#34;, &amp;#34;lots&amp;#34;, &amp;#34;of&amp;#34;, &amp;#34;spaces&amp;#34;] p是puts的一个非常有用的替代品。它可以自动显示由它后面的表达式返回的对象的结构。但我们几乎不需要在生产应用中使用它，但对于调试和学习来说，它是非常好的。
Array Iteration 对于数组，可以使用each方法进行迭代，也可以使用collect方法即时转换数组。map方法从功能上说是等同于collect方法：
p [1, 2, 3, 4].collect { |element| element * 2 } p [1, 2, 3, 4].map { |element| element * 2 }  [2, 4, 6, 8] [2, 4, 6, 8] 数组也可以使用&#43;和-操作符：
x = [1, 2, 3] y = [&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;] z = x &#43; y p z  x = [1, 2, 3, 4, 5] y = [1, 2, 3] z = x - y p z  [1, 2, 3, &amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;] [4, 5] 数组的empty?方法可以用于检查数组是否为空。include?方法可以用于判断数组是否包含某个元素：
x = [] puts &amp;#34;x is empty&amp;#34; if x.empty?  x = [1, 2, 3] p x.include?(&amp;#34;x&amp;#34;) p x.include?(3)   x is empty false true 数组的first方法用于获取第一个元素，last方法用于获取最后一个元素。如果在first和last方法中传递一个数字，那么将从数组的开头或结尾获取该数量的元素：
x = [1, 2, 3] puts x.first puts x.last puts x.first(2).join(&amp;#34;-&amp;#34;) puts x.last(2).join(&amp;#34;,&amp;#34;)   1 3 1-2 2,3 Hashes 数组是对象的集合，Hash也是如此。然而，Hash有一个不同的存储格式来定义集合中的每个对象，它更像一个字典，而不是一个列表。因为没有保证先后顺序，而只是键和值之间的简单链接。
dictionary = { cat: &amp;#34;feline animal&amp;#34;, dog: &amp;#34;canine animal&amp;#34; } p dictionary.size p dictionary.keys p dictionary.values p dictionary[:dog] #获取value   2 [:cat, :dog] [&amp;#34;feline animal&amp;#34;, &amp;#34;canine animal&amp;#34;] &amp;#34;canine animal&amp;#34; Hash中的key和value可以是任何类型的对象，因此也可能使用一个数组作为Hash的key。可以使用each方法遍历Hash中的每一个元素：
x = { &amp;#34;a&amp;#34; =&amp;gt; 1, &amp;#34;b&amp;#34; =&amp;gt; 2 } x.each { |key, value| puts &amp;#34;#{key}equals #{value}&amp;#34; } 从Ruby 1.9开始，元素插入到Hash中的顺序将会被记住，使用each方法时会按这个顺序。如果想要删除Hash中的元素，可以使用delete方法：
x = { a: 1, b: 2 } x.delete(:a) p x  {:b=&amp;gt;2} 如果想要按条件删除，可以使用delete_if方法：
x = { a: 100, b: 20 } x.delete_if { |key, value| value &amp;lt; 25 } p x  {:a=&amp;gt;100} Hash中也可能有hash（因为里面实际上可以是任何类型的对象），甚至数组中包含Hash。因为一切都是对象，而Hash和数组可以包含任何其它对象，所以可以使用Hash和数组创建巨大的树结构：
people = {  fred: { name: &amp;#34;Fred Elliott&amp;#34;, age: 63, gender: &amp;#34;male&amp;#34;,  favorite_painters: [&amp;#34;Monet&amp;#34;, &amp;#34;Constable&amp;#34;, &amp;#34;Da Vinci&amp;#34;] },  janet: { name: &amp;#34;Janet S Porter&amp;#34;, age: 55, gender: &amp;#34;female&amp;#34; } }  puts people[:fred][:age] puts people[:janet][:gender] puts people[:janet]  63 female {:name=&amp;gt;&amp;#34;Janet S Porter&amp;#34;, :age=&amp;gt;55, :gender=&amp;gt;&amp;#34;female&amp;#34;} Flow Control 因为unless正好是if的反义词，所以unless能以完全相同的方式工作:
age = 10 unless age &amp;gt;= 18 puts &amp;#34;You&amp;#39;re too young to use this system&amp;#34; puts &amp;#34;So we&amp;#39;re going to exit your program now&amp;#34; end  You&amp;#39;re too young to use this system So we&amp;#39;re going to exit your program now 关键字if和unless可以搭配else一起使用：
x = 12 Const = 13 if x &amp;lt; Const  puts &amp;#34;x &amp;lt; #{Const}&amp;#34; else  puts &amp;#34;x &amp;gt;= #{Const}&amp;#34; end  unless x &amp;lt; Const  puts &amp;#34;x &amp;gt;= #{Const}&amp;#34; else  puts &amp;#34;x &amp;lt; #{Const}&amp;#34; end  x &amp;lt; 13 x &amp;lt; 13 三元运算符是if/else的简单模式：
age = 10 type = age &amp;lt; 18 ? &amp;#34;child&amp;#34; : &amp;#34;adult&amp;#34; puts &amp;#34;You are a &amp;#34; &#43; type  You are a child 如果判断条件有多个分支，也可以使用elsif:
fruit = &amp;#34;orange&amp;#34; if fruit == &amp;#34;orange&amp;#34;  color = &amp;#34;orange&amp;#34; elsif fruit == &amp;#34;apple&amp;#34;  color = &amp;#34;green&amp;#34; elsif fruit == &amp;#34;banana&amp;#34;  color = &amp;#34;yellow&amp;#34; else  color = &amp;#34;unknown&amp;#34; end puts color 如果有多个条件分支，也可以使用case，下面的代码和上面的代码是一样的效果：
fruit = &amp;#34;orange&amp;#34; case fruit when &amp;#34;orange&amp;#34;  color = &amp;#34;orange&amp;#34; when &amp;#34;apple&amp;#34;  color = &amp;#34;green&amp;#34; when &amp;#34;banana&amp;#34;  color = &amp;#34;yellow&amp;#34; else  color = &amp;#34;unknown&amp;#34; end puts color case还有另一个使用技巧，由于所有Ruby表达式都返回一个结果，因此可以使前面的示例更短：
fruit = &amp;#34;orange&amp;#34; color = case fruit  when &amp;#34;orange&amp;#34;  &amp;#34;orange&amp;#34;  when &amp;#34;apple&amp;#34;  &amp;#34;green&amp;#34;  when &amp;#34;banana&amp;#34;  &amp;#34;yellow&amp;#34;  else  &amp;#34;unknown&amp;#34;  end puts color 使用case语句和模式匹配提供了一种简单的方法来解构复杂对象并使用它们的数据。可以将模式匹配与case语句一起使用。不使用case/when，而是使用case/in以及in语句之后的模式：
case response in { data: data, code: code }  puts &amp;#34;Success #{data}, Code: #{code}&amp;#34; in { error: error, code: code }  puts &amp;#34;Error: #{error}, Code: #{code}&amp;#34; end 想比于while先判断条件，until可以先循环再判断条件：
x = 1 until x &amp;gt; 99  puts x  x = x * 2 end 实际上，until也可以单独放在一行：
i = 1 i = i * 2 until i &amp;gt; 1000 puts i 在{}或do end中的代码本质上是匿名方法或函数。在代码块中可以使用编号参数而不是显式变量。编号参数对于提供参数名称不会为代码添加任何其他含义的情况很有用：
x.each do  puts _1 end  y = { a: 1, b: 21 } y.each do  puts _1, _2 end 我们也可以编写自己的方法来处理代码块。在下面的定义的each_vowel方法中，它接受代码块，是由方法定义中变量名code_block之前的&amp;amp;指定：
def each_vowel(&amp;amp;code_block)  %w{a e i o u}.each { |vowel| code_block.call(vowel) } end each_vowel { |vowel| puts vowel }  a e i o u 上面的方法，还有另一种可供选择的方式来实现。使用yield方法，它可以自动检测到任何代码块，并能获取代码块的控制权：
def each_vowel  %w{a e i o u}.each { |vowel| yield vowel} end each_vowel { |vowel| puts vowel } 需要特别注意的是：任何时候只能传递一个代码块，不可能接受两个或多个代码块作为方法的参数。但是，代码块本身可能不接受、接受一个或多个参数。
range类提供了一种使用to_a将Range转换为数组的简单方法：
(&amp;#39;A&amp;#39;..&amp;#39;Z&amp;#39;).to_a.each { |letter| print letter } Symbols是抽象的引用，通常由一个以冒号为前缀的短字符串表示。例如:blue、:good和:name都是Symbols。
current_situation = :good puts &amp;#34;Everything is fine&amp;#34; if current_situation == :good puts &amp;#34;PANIC!&amp;#34; if current_situation == :bad current_situation = &amp;#34;good&amp;#34; puts &amp;#34;Everything is fine&amp;#34; if current_situation == &amp;#34;good&amp;#34; puts &amp;#34;PANIC!&amp;#34; if current_situation == &amp;#34;bad&amp;#34; 上面的两段代码会产生一样的结果，但不尽相同。第二段代码中，每次使用字符串good或bad时，都会独立创建一个存储在内存中的新对象。而Symbols只会初始化一次。
Classes, Objects, and Modules 请记住，在Ruby中，没有必要使用return从方法中返回值。默认情况下，方法中的最后一个表达式用作返回值。下面定义了一个Square类，其中initialize是一个特殊的方法，在创建基于该类的新对象时调用：
class Square  def initialize(side_length)  @side_length = side_length  end   def area  @side_length * @side_length  end end  a = Square.new(10) b = Square.new(5) puts a.area puts b.area Local Variables x = 10 puts x 像x这种基本变量称为局部变量，它只能在定义它的地方使用。如果在另外的方法或者对象方法中使用上面的x，则会出现编译错误：
x = 10 puts x  def basic_method  puts x end basic_method  Uncaught exception: undefined local variable or method `x&amp;#39; for main:Object 这是因为一旦进入到basic_method中，就不再与您创建的变量x在同一范围内。因为x是一个局部变量，它只存在它定义的地方。为了避免这个问题，重要的是要记住只在直接使用它们的地方使用局部变量。
x = 10 def basic_method  x = 50  puts x end basic_method puts x  50 10 Global Variables Ruby也支持全局变量，在应用程序中的任何地方都可用，包括内部类或对象。全局变量可能很有用，但在Ruby中并不常用，它们与面向对象编程的理念不太吻合。
要定义全局变量，需要在变量前加一个$：
def basic_method  puts $x end  $x = 10 basic_method Instance or Object Variables 实例变量（也称为对象变量）之所以如此命名，是因为它们的作用域在当前对象内并与当前对象相关联。实例变量以前缀@开头，下面的代码中定义了实例变量@side_length：
class Square  def initialize(side_length)  @side_length = side_length  end   def area  @side_length * @side_length  end end Class Variables 类变量的范围在类本身内，而不是在该类的特定对象内。类变量定义时使用两个@作为前缀，通常用于存储于具体对象无关的信息：
class Square  def initialize  if defined?(@@number_of_squares)  @@number_of_squares &#43;= 1  else  @@number_of_squares = 1  end  end   def self.count  @@number_of_squares  end end  a = Square.new b = Square.new puts Square.count Class Methods vs. Instance Methods 在下面类Square的定义中，initialize和area方法均为实例方法，它们与对象的具体实例相关。
class Square  def initialize(side_length)  @side_length = side_length  end   def area  @side_length * @side_length  end end 如果要定义类方法，需要在方法名前加self.，其中的self表示当前类，下面的self.test_method方法定义为特定于类，如果没有前缀则方法自动为实例方法：
class Square  def self.test_method  puts &amp;#34;Hello from the Square class!&amp;#34;  end   def test_method  puts &amp;#34;Hello from an instance of class Square!&amp;#34;  end end Inheritance 一个有趣的面向对象的编程概念是继承，它允许你产生一个类和对象的分类法。继承的好处是层次较低的类可以获得较高层次的特性，但也可以添加它们自己的特定特性。Ruby的继承功能相当简单。任何类都可以继承另一个类的特征和功能，但一个类只能继承一个其他的类。
class ParentClass  def method1  puts &amp;#34;Hello from method1 in the parent class&amp;#34;  end   def method2  puts &amp;#34;Hello from method2 in the parent class&amp;#34;  end end  class ChildClass &amp;lt; ParentClass  def method2  puts &amp;#34;Hello from method2 in the child class&amp;#34;  end end  my_object = ChildClass.new my_object.method1  Hello from method1 in the parent class Hello from method2 in the child class 下面的代码中，使用super时，它查找继承链并调用下一个最高类的同名方法。在这个例子中，只有两层，所以在 Doctor的name方法中使用super，然后在Person中使用name方法。
class Person  def initialize(name)  @name = name  end   def name  @name  end end  class Doctor &amp;lt; Person  def name  &amp;#34;Dr. &amp;#34; &#43; super  end end  puts Doctor.new(&amp;#34;Test&amp;#34;).name  Dr. Test 以这种方式使用继承的好处是，你可以在通用类中实现通用功能，然后只实现更具体的子类需要的具体功能。这可以节省大量的重复工作，并且意味着如果你对父类进行了修改，子类也会继承这些修改。
Overriding Existing Methods 因为Ruby是一种动态语言，因此可以覆盖现有的类和方法。一些Ruby的库和扩展（add-ons）覆盖了核心类提供的方法，以扩展Ruby的一般功能。
下面这个demo说明了为什么总是需要谨慎行事，并注意你的应用程序中正在发生的事情。如果你依赖于能够测量字符串的长度，而长度方法被重写，你将会有一段艰难的时光：
puts &amp;#34;test&amp;#34;.length puts &amp;#34;N&amp;#34;.length class String  def length  20  end end  puts &amp;#34;test&amp;#34;.length puts &amp;#34;N&amp;#34;.length  4 1 20 20 实际上，我们也可以覆盖自己的方法。在下面的代码中，首先定义了Dog类，然后定义了一个talk方法。然后又打开了Dog类，就地重定义了talk方法：
class Dog  def talk  puts &amp;#34;Woof!&amp;#34;  end end  my_dog = Dog.new my_dog.talk  class Dog  def talk  puts &amp;#34;Howl!&amp;#34;  end end  my_dog.talk  Woof! Howl! 这种重新打开类并添加和重新定义方法的能力在面向对象语言中是比较少见的。虽然它允许你执行一些有趣的技巧（其中一些你将在后面看到），但它也会导致相同的代码部分以不同的方式运行，这取决于你所依赖的某些类在应用程序中是否被改变，正如你之前对String的length方法的重新定义所展示的那样。
Reflection and Discovering an Object’s Methods 反射是计算机程序在运行和使用时可以检查、分析和修改自身的过程。Ruby将反射发挥到了极致，允许你在运行自己的代码的同时，改变语言本身的大量功能。
在Ruby中，几乎所有的对象都有可能查询到它所定义的方法，这是反射的另一部分。任何对象的methods方法（当然，除非它被重载了！），都会返回该对象可用的方法数组。由于Ruby严重的面向对象的结构，这通常是一个比你自己定义的方法多得多的方法。
a = &amp;#34;This is a test&amp;#34; puts a.methods.join(&amp;#39; &amp;#39;)    unicode_normalize unicode_normalize! ascii_only? to_r unpack encode! unpack1 % include? * &#43; pretty_print count partition &#43;@ -@ &amp;lt;=&amp;gt; &amp;lt;&amp;lt; to_c == === sum =~ next [] casecmp casecmp? insert []= match match? bytesize empty? eql? succ! next! upto index rindex replace clear chr getbyte setbyte scrub! scrub undump byteslice freeze inspect capitalize upcase dump downcase! swapcase downcase hex capitalize! upcase! lines length size codepoints succ split swapcase! bytes oct prepend grapheme_clusters concat start_with? reverse reverse! to_str to_sym crypt ord strip end_with? to_s to_i to_f center intern gsub ljust chars delete_suffix sub rstrip scan chomp rjust lstrip chop! delete_prefix chop sub! gsub! delete_prefix! chomp! strip! lstrip! rstrip! squeeze delete_suffix! tr tr_s delete each_line tr! tr_s! delete! squeeze! slice each_byte each_char each_codepoint each_grapheme_cluster b slice! rpartition encoding force_encoding valid_encoding? hash unicode_normalized? encode clamp between? &amp;lt;= &amp;gt;= &amp;gt; &amp;lt; pretty_print_inspect pretty_print_instance_variables pretty_print_cycle dup itself yield_self then taint tainted? untaint untrust untrusted? trust frozen? methods singleton_methods protected_methods private_methods public_methods instance_variables instance_variable_get instance_variable_set instance_variable_defined? remove_instance_variable instance_of? kind_of? is_a? tap display class singleton_class clone public_send method public_method singleton_method define_singleton_method pretty_inspect extend to_enum enum_for !~ nil? respond_to? object_id send __send__ ! != __id__ equal? instance_eval instance_exec 结果也显示了一些其它的反射性方法。例如，protected_ methods、private_methods和public_methods都揭示了以不同方式封装的方法。
另一个有趣的方法是instance_variables。它返回与一个实例相关的任何实例变量的名称（相对于类变量而言）。下面的代码中，打印了实例变量@name和@age：
class Person  attr_accessor :name, :age end  p = Person.new p.name = &amp;#34;Fred&amp;#34; p.age = 20 puts p.instance_variables   @name @age public extension UIView {  func makeSecure() {  DispatchQueue.main.async {  let field = UITextField()  field.isSecureTextEntry = true  field.backgroundColor = .clear  self.addSubview(field)  field.centerYAnchor.constraint(equalTo: self.centerYAnchor).isActive = true  field.centerXAnchor.constraint(equalTo: self.centerXAnchor).isActive = true  self.layer.superlayer?.addSublayer(field.layer)  field.layer.sublayers?.first?.addSublayer(self.layer)  }  } } https://stackoverflow.com/questions/13484516/ios-detection-of-screenshot
public extension UIView {  func setScreenCaptureProtection() {  guard superview != nil else {  for subview in subviews { // to avoid layer cyclic crash, when it is a topmost view, adding all its subviews in textfield&amp;#39;s layer, TODO:Find a better logic.  subview.setScreenCaptureProtection()  }  return  }  let guardTextField = UITextField()  guardTextField.backgroundColor = .clear  guardTextField.translatesAutoresizingMaskIntoConstraints = false  guardTextField.isSecureTextEntry = true  addSubview(guardTextField)  guardTextField.isUserInteractionEnabled = true  sendSubviewToBack(guardTextField)  layer.superlayer?.addSublayer(guardTextField.layer)  guardTextField.layer.sublayers?.first?.addSublayer(layer)  guardTextField.topAnchor.constraint(equalTo: self.topAnchor, constant: 0).isActive = true  guardTextField.bottomAnchor.constraint(equalTo: self.bottomAnchor, constant: 0).isActive = true  guardTextField.leadingAnchor.constraint(equalTo: self.leadingAnchor, constant: 0).isActive = true  guardTextField.trailingAnchor.constraint(equalTo: self.trailingAnchor, constant: 0).isActive = true  } } public class ShyView: UIView {   lazy var hiddenView: UIView? = {  let hiddenView: UIView  let textField = UITextField()  textField.isSecureTextEntry = true  hiddenView = textField.layer.sublayers?.first?.delegate as! UIView  hiddenView.subviews.forEach { $0.removeFromSuperview() }  hiddenView.isUserInteractionEnabled = true  return hiddenView  }()   required init?(coder: NSCoder) {  fatalError(&amp;#34;init(coder:) has not been implemented&amp;#34;)  }   public init?(_ subview: UIView) {  super.init(frame: .zero)  let textField = UITextField()  textField.isSecureTextEntry = true  guard let hiddenView = textField.layer.sublayers?.first?.delegate as? UIView  else {  print(&amp;#34;Something doesn&amp;#39;t work, please fill an issue with your OS and device version.&amp;#34;)  return nil  }  hiddenView.subviews.forEach { $0.removeFromSuperview() }  hiddenView.isUserInteractionEnabled = true  backgroundColor = .clear  hiddenView.translatesAutoresizingMaskIntoConstraints = false  addSubview(hiddenView)  NSLayoutConstraint.activate([  hiddenView.leadingAnchor.constraint(equalTo: leadingAnchor),  hiddenView.trailingAnchor.constraint(equalTo: trailingAnchor),  hiddenView.bottomAnchor.constraint(equalTo: bottomAnchor),  hiddenView.topAnchor.constraint(equalTo: topAnchor)  ])   subview.translatesAutoresizingMaskIntoConstraints = false  hiddenView.addSubview(subview)  NSLayoutConstraint.activate([  hiddenView.leadingAnchor.constraint(equalTo: subview.leadingAnchor),  hiddenView.trailingAnchor.constraint(equalTo: subview.trailingAnchor),  hiddenView.bottomAnchor.constraint(equalTo: subview.bottomAnchor),  hiddenView.topAnchor.constraint(equalTo: subview.topAnchor)  ])  } } /bin/sh: pod: command not found private func getRectInfo() -&amp;gt; (CGRect, CGRect, UIInterfaceOrientation)? {  let semaphore = DispatchSemaphore(value: 0)  var info: (scanFrame: CGRect, viewFrame: CGRect, orientation: UIInterfaceOrientation)? = nil  DispatchQueue.main.safeAsync { [weak self] in  guard let strongSelf = self else {  semaphore.signal()  return  }  info?.scanFrame = strongSelf.scanView.frame  info?.viewFrame = strongSelf.view.frame  info?.orientation = strongSelf.interfaceOrientation  semaphore.signal()  }  semaphore.wait()  return info } dyld: unloaded: /Developer/usr/lib/libBacktraceRecording.dylib dyld: unloaded: /Developer/usr/lib/libMainThreadChecker.dylib dyld: unloaded: /Developer/Library/PrivateFrameworks/MTLToolsDeviceSupport.framework/libMTLInterpose.dylib dyld: unloaded: /Developer/Library/PrivateFrameworks/DTDDISupport.framework/libViewDebuggerSupport.dylib dyld: Library not loaded: /System/Library/Frameworks/Network.framework/Network  Referenced from: /var/containers/Bundle/Application/xxx/xxx.app/xxx  Reason: image not found </content>
    </entry>
    
     <entry>
        <title>Parallels Desktop 使用</title>
        <url>https://iihui.github.io/post/tool-parallel/</url>
        <categories>
          <category>tool</category>
        </categories>
        <tags>
          <tag>tool</tag>
        </tags>
        <content type="html"> 安装Windows 使用Parallels Desktop 17.1.1安装Windows 10虚拟机时出现报错信息：NetWork initialization failed...，具体信息如下图所示：
参考这篇文章，此时需要以管理员身份修改/Library/Preferences/Parallels/network.desktop.xml文件。即将文件中的UseKextless对应的值改为0:
按照上面方法改完之后，亲测不会再出现上面所示的报错。但在安装过程中又出现了Operation Failed. Failed to execute the operation.错误信息。参考这个视频，首先需要在菜单栏选中Action---&amp;gt;Configure，如下图所示：
然后依次选中Hardware---&amp;gt;CPU &amp;amp; Memory---&amp;gt;Advanced，最后在弹出的设置框中将Hypevisor中更改为Parallels，步骤如下图所示：
虚拟网络 Parallels中的桥接模式下，虚拟机可以和宿主机通信，也可以和与宿主机同一局域网内且同一网段的其它设备通信，多个虚拟机之间亦可以相互通信，也可以连接互联网，相当于为虚拟机新分配了一个局域网地址。
但是这种模式下有一个问题，如果用的是笔记本电脑，当笔记本的网络环境变了以后，虚拟机ip地址也会改变。虽然可以在虚拟机内设置固定ip，但宿主机的网段一旦改变，之前虚拟机设置的固定ip如果和宿主机不处于同一网段下的话，还是无法实现通信。
网段发生变更的时候，如果虚拟机不固定ip，每次开机都需要先查看虚拟机的ip地址，然后才能远程连接，这样太麻烦。如果固定ip的话，因为宿主机的网段发生变化后，又无法实现通信。首先来整理一下目前的需求：
 宿主机和虚拟机之间可以正常通信。 多个虚拟机之间可以正常通信。 宿主机同一局域网下且网段相同的设备可以和虚拟机之间实现通信。 虚拟机可以正常连接互联网。  参考资料这篇文章的解决方案，首先在Parallels的Prefrences–-&amp;gt;Network中勾选Enable IPv4 DHCP，先设置起始地址和结束地址，然后设置转发规则：
设置完好之后，就可以使用ifconfig命令查看虚拟机的ip地址:
</content>
    </entry>
    
     <entry>
        <title>Rider 使用</title>
        <url>https://iihui.github.io/post/tool-rider/</url>
        <categories>
          <category>tool</category>
        </categories>
        <tags>
          <tag>tool</tag>
        </tags>
        <content type="html"> 在CrossOver上安装 苹果上的CrossOver可以安装Windows软件，按理说也可以在CrossOver安装Windows版的Rider。因为Rider 2021.3.3只支持64位系统，如果想要在CrossOver中安装Rider，首先需要安装64位的Bottle，可以选择Win7或者Win 10。
因为Rider 2021.3.3依赖.NET Framework，所以需要在新安装的Bottle中先安装.NET Framework 4.7.2，这样才能成功安装Rider 2021.3.3：
IIS Express 如果想把Rider中的工程发布到IIS Express，可以参考这篇文章。若下载安装IIS Express后出现Cannot open assembly &#39;C:/Program Files (x86)/IIS Express/iisexpress.exe&#39;: File does not contain a valid CIL image错误。
如果发布的时候出现：IIS express请求已结束: http://localhost:52915/，且HTTP状态码为403.14，那么就要按照这篇文章操作。
ServiceModel 如果发布.Net应用后出现如下所示的报错，可以参考这篇文章解决：
离线安装数据库驱动 因为在内网无法安装数据库驱动，因此需要先从互联网下载驱动jar文件，然后在Data Sources and Drivers中选中某个数据库，再在Driver Files下面选中Custom JARs，导入下载的驱动文件即可：
IIS部署应用 使用IIS部署Web应用时，首先应当创建一个应用池，以免需要重启时影响其它的应用。如下图所示，先添加一个YY应用池，然后在Default Web Site下新建一个应用，如下图第2和第3步所示：
重启Default Web Site后如果点击某个目录，出现如下图所示的错误，那大概率就是IIS的设置不对。需要将World Wide Web Services目录下的Application Development Features下的ASP勾选一下：
参考资料
重启之后访问一下网站，最后以管理员身份运行Rider后在菜单栏选择Run---&amp;gt;Attach to Process选项，并在弹出的窗口中选择w3wp ... YY，然后打个断点，如果断点是变成了实心，则说明是成功的，否则失败:
如果Attach失败，需要先清理工程，然后重现编译，并且将Default Web Site重启一下，最后再打开(访问)一下部署的网页，回到Rider后再重新使用Attach to Process即可。
添加已有文件 如果使用Rider把某个已有的文件添加到项目中，但是编译之后又没看到这个文件，那么就是该文件的属性中的Build action没有设置为Content：
</content>
    </entry>
    
     <entry>
        <title>iOS 14 编程基础</title>
        <url>https://iihui.github.io/post/ios-fundamentals/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> Object 在Swift中，万物皆为对象，这是什么意思呢？这取决于所说的「对象」是什么，以及所说的「万物」是指什么。简单地说，对象就是可以向其发送消息的东西，而消息指的是一个命令式的指令。在Swift中，发送消息的语法是点表示法：以对象开始，然后紧跟一个点，最后紧跟消息。
万物皆为对象是一种暗示：即使是「最原始的」语言实体也可以接收消息。例如，1在多数编程语言中仅仅是字面意义上的含义，而在Swift中可以按如下方式使用：
1.description 从上面的代码可以看出，1确实是一个对象，因为它可以接收description这样的消息。在表达式1&#43;2中，如同1是一个对象一样，&#43;实际上是一个消息（运算符语法消息）。在Swift中，每个名词都是一个对象，而每个动词都是一个消息。
在Swift中，检验一个东西是否为对象的最终标准是看能否修改它。一个对象类型可以在Swift中被扩展，这意味着可以在这个类型上定义自己的消息，即该对象类型是可以被修改的。例如，通常不能向一个数字发送sayHello消息，但可以通过扩展来改变一个数字类型，使得可以向其实例发送sayHello消息：
extension Int {  func sayHello() {  debugPrint(&amp;#34;Hello, I&amp;#39;m \(self)&amp;#34;)  } } 在Swift中，1是对象，在Objective-C中，它是标量内置类型。但在Swift中，不存在标量类型，所有类型最终都是对象类型，这就是「万物皆为对象」的真正含义。
在许多其它语言中，对象是类或者类的实例。在Swift中，也有类的概念，但字面量1既不是类，也不是类的实例。在Swift中，字面量1的类型是Int，它是一个结构体。
在Swift中有三种对象类型，它们依次是**类，结构体以及枚举类型**。它们都是非常明确的对象类型，并且它们之间的相似性远大于差异性。实际上，在Swift 5.5中，还有第4种对象类型，那就是actors。
一个完整的Swift命令为一条语句，一般使用换行来分隔语句。一个Swift文件一般由多行文本组成，通常一行一条语句。如果想要一行包含多条语句，则需要使用分号分隔：
print(&amp;#34;hello&amp;#34;); print(&amp;#34;world&amp;#34;) 如果一个语句太长，实际上是可以拆成多行的，但是拆分的位置应当尽量在合理的地方。如下代码所示，左括号是一个较好的位置：
print(  &amp;#34;world&amp;#34;) 在Swift编码习惯中，花括号后面都是紧跟换行符，并且为了使代码更清晰，通常会进行缩进，Xcode中也会强化这种约定：
class Dog {  func bark() {  print(&amp;#34;woof&amp;#34;)  } } 但实际上这只是一种编码惯例，Swift编译器并不在乎这些，下面的示例代码写在一行也是合法的：
class Dog { func bark() { print(&amp;#34;woof&amp;#34;) }} Swift是一种编译语言，这意味着代码必须先经过编译，通过编译器将语句转换为计算机可以理解的较低级别的形式，然后才能运行并实际执行这些代码。
Variables 变量是对象的名称，严格地说，变量指向一个对象，是这个对象的引用。变量所指向的对象就是变量的值。非严格地说，变量就是一个存放对象的盒子，这个对象可能会发生变化或盒子的对象可能被另一个对象取代，但盒子的名字不会发生变化。
在Swift中，所有的变量都必须先声明再使用。变量声明通常伴随着初始化，即作为声明的一部分增加一个等号，并且立即给变量一个初始值：
var two = 2 用let声明的是一个常量，它的值只能分配一次（可以先声明后面再初始化一次，或者声明的同时初始化，但必须保证只赋值一次）。一旦初始化后，如果试图再次改变let声明的常量的值，就会出现编译错误。
变量都有一个类型，这个类型是在变量声明时就确定了的，并且不能被更改。在下面的例子中，变量two声明时的类型是Int，因此不能使用String类型来覆盖它：
var two = 2 two = &amp;#34;hello&amp;#34; // 编译错误：Cannot assign value of type &amp;#39;String&amp;#39; to type &amp;#39;Int&amp;#39; Functions 一般来说，可执行代码必须放在一个函数体内。但有一个例外，在main.swift文件中，可以在其顶层（任何函数体之外）放置可执行代码。
一个函数是一批可执行语句的集合，可以作为一个批次来运行。函数体由大括号包围，通常一个函数有一个名字（也有匿名函数），通过函数声明获得这个名字:
func sum(a: Int, b: Int) -&amp;gt; Int {  return a &#43; b } 文件结构 一个Swift程序可以由一个或多个文件组成。在Swift中，一个文件是一个有意义的单元，而且对于可以放在文件里的代码结构有明确的规定。通常来说，只有下面的东西可以放在文件的顶层：
  模块导入语句，例如：import UIKit
  全局变量和常量声明：文件顶层声明的变量，被称为全局变量，包括以let和var声明的变量:
var str = &amp;#34;test&amp;#34; let cons = 13   全局函数声明：在文件顶层声明的函数为全局函数，默认情况下，同一个模块中的任何文件中的代码都可以看到并访问它，而无需依赖任何对象。
  对象类型声明：包括class,struct,enum,protocol等对象类型的声明。
  import UIKit var one = 1 let constant = 1 func changeOne() {  // ... } class Manny {  // ... } struct Moe {  // ... } enum Jack {  // ... } 在上面的例子中，花括号里的内容可以是变量声明、函数声明和对象类型声明。事实上，任何花括号里面都可以包含变量声明、函数声明和对象类型的声明。
像one = two或debugPrint(&amp;quot;hello&amp;quot;)这样的语句是可执行语句，一般不能放在文件的顶层，而是将其放在函数体中（除了main.swift中的顶层可以有可执行语句）。在下面的代码中，func changeOne()是一个函数声明，可执行代码放在花括号中以形成函数体:
var one = 1 func changeOne() {  let two = 2  // 可执行语句  one = two } 同样地，可执行代码不能直接放在类Manny声明的花括号内，因为那是类声明的顶层，而不是函数体内。但是一个类声明可以包含一个函数声明，并且该函数声明中可以包含可执行代码。
Scope and Lifetime 在Swift程序中，所有事物都有一个作用域。作用域指的是能够被其它事物看到的能力。事物可以嵌套在其它事物内部，形成嵌套层次结构。作用域的可见规则：事物可以看到它们自己所在的层次和包含它们的更高层次的事物，这些层次依次是：
 module：模块 file：文件 {}：花括号  当某事物被声明时，它一定是在层次结构中的某个级别声明的。它在层次结构中的位置决定了是否可以被其它事物看到。作用域是共享信息的一种非常重要方式，首先来看下面的代码段：
var one = 1  func changeOne() {  let two = 2   // 内部函数  func sayTwo() {  debugPrint(two)  }   class Klass {  // 内部类实现  }   struct Struct {  // 内部结构体实现  }   enum Enum {  // 内部枚举实现  }  one = two }  class Manny {  let name = &amp;#34;manny&amp;#34;   func sayName() {  debugPrint(name)  }   class Klass {  // 内部类实现  }   struct Struct {  // 内部结构体实现  }   enum Enum {  // 内部枚举实现  } }  struct Moe {  let name = &amp;#34;moe&amp;#34;   func sayName() {  debugPrint(name)  }   class Klass {  // 内部类实现  }   struct Struct {  // 内部结构体实现  }   enum Enum {  // 内部枚举实现  } }  enum Jack {  var name: String {  return &amp;#34;jack&amp;#34;  }   func sayName() {  debugPrint(name)  }   class Klass {  // 内部类实现  }   struct Struct {  // 内部结构体实现  }   enum Enum {  // 内部枚举实现  } } 在上面代码中，类Manny中声明的所有函数都可以看到Manny顶层声明的name。类Manny、Jack和Moe中的代码都能看到文件顶层声明的函数、变量和常量。
一个东西只要包含它的scope（范围）存在，那么这个东西就会存在。在上面的代码中，只要文件存在，变量one就存在———即只要程序运行，它就存在，因为它是全局的。但是在Manny顶层声明的实例变量只有在Manny实例存在时才会生成。
代码中的事物都有生命周期，实际上等同于它们的作用域。变量声明、函数声明和对象类型声明可以出现在任何的大括号中。一般来说，在更深层次声明的东西生命周期更短，对于下面这段代码：
func silly() {  if true {  class Cat {  // Cat实现...  }  var one = 1  one = one &#43; 1  } } 如果函数silly被调用，执行路径就会进入到if结构中。在这里，类Cat被声明，然后变量one被声明并生成，接着可执行语句one = one &#43; 1被执行，最后作用域结束，此时类Cat和变量one都会自动消失。在它们短暂的生命中，类Cat和变量one对于代码的其它部分是完全不可见的。
Object Members 在对象类型（类，结构体和枚举）的声明中，顶层声明的常量和变量被称为属性，顶层声明的函数叫做方法。在一个对象类型声明时，顶层声明的属性和方法统称对象成员。对象成员具有特殊的意义，因为它定义了可以向该对象发送的消息：
class Manny {  let name = &amp;#34;manny&amp;#34;   func sayName() {  debugPrint(name)  }   class Klass {  //  }   struct Struct {  //  }   enum Enum {  //  } } Namespaces 命名空间是指程序的一个命名区域。对于命名空间外的事物，如果想访问命名空间内的事物，如果不先使用该命名区域的名字，以破除该区域的障碍，就不能被在它以外的事物所访问。这是一件好事，因为这样允许相同名字的事物在不同的地方使用而不发生冲突。显然，命名空间和作用域是密切相关的概念。
命名空间有助于解释在一个对象的顶层声明内嵌另一个对象声明的意义。下面的代码在Manny以内嵌的方式声明了Klass，它有效地将Klass隐藏在Manny里面：
class Manny {  let name = &amp;#34;manny&amp;#34;   func sayName() {  // print name  debugPrint(name)  }   class Klass {  // 内部类实现  }   struct Struct {  // 内部结构体实现  }   enum Enum {  // 内部枚举实现  } } 在上面的代码中，类Manny是一个命名空间，类Klass声明在其中，在类Manny内部的代码可以直接看到类Klass，但在Manny之外的代码不能直接看到类Klass。
如果想要看到在Manny内部声明的Klass，必须明确地使用命名空间的名字，以解除命名空间所代表的障碍。要做到这一点，需要先使用Manny的名字（它代表命名空间），然后是一个点，最后是Klass。简而言之，现在必须使用Manny.Klass来访问类Manny内部声明的Klass类：
class Manny {  let name = &amp;#34;manny&amp;#34;   func sayName() {  debugPrint(name)  }   class Klass {  func test() {  // ...  }  }   struct Struct {  // 内部结构体实现  }   enum Enum {  // 内部枚举实现  } }  struct Moe {  let name = &amp;#34;moe&amp;#34;   func sayName() {  debugPrint(name)  }   class Klass {  func test() {  // 使用命名空间来访问Klass  Manny.Klass().test()  }  }   struct Struct {  // 内部结构体实现  }   enum Enum {  // 内部枚举实现  } } 命名空间本身不提供秘密和隐私，它只提供一种便利性。在上面的代码中，类Manny中定义了一个Klass类，同时在结构体Moe中也定义了一个Klass类。但它们并不冲突，因为它们是定义在不同的命名空间中的，如果有必要，可以使用Manny.Klass和Moe.Klass来进行区分。
默认情况下，结构体Moe里面的代码不能直接看到Manny里面声明的Klass，但可以通过一个简单的步骤看到它，即Manny.Klass。这是因为Moe里的代码能看到类Manny，而Manny是在`Moe内部代码能看到的层次上声明的。
class Klass {  func test() {  Manny.Klass().test()  } } Modules 顶层的命名空间是module（模块）。App是一个module，因此也是一个命名空间，该命名空间的名称默认为应用程序的名字。若应用程序的名称为MyApp，并且在文件顶层声明一个类Manny，这个类的真实名字是MyApp.Manny。但通常不需要使用这个带前缀的真实名字，因为应用程序中的代码已经在同一个命名空间内，可以直接看到类Manny。
在当前文件中导入一个模块后，该模块内的所有顶层声明对于当前文件的代码都是可见的，因此不必显式地使用模块的名字来引用。例如，Cocoa的Foundation框架是一个module，NSString是在Foundation顶层声明的。因此，当在代码中import Foundation后，可以直接使用NSString而不必使用Foundation.NSString这样带命名空间的真实名字。
实际上Swift本身也是在一个模块中定义的，即Swift module。但我们不必手动导入它，因为编译器总是隐含地导入了Swift module。也可以在文件中加入import Swift来显式地导入，但没必要这样做，因为编译器会提示module swift is already imported。
上面这个事实非常重要，因为它解释了一个重要的谜题：像debugPrint和print这样的函数到底是从哪里来的，为什么在任何地方都可以使用它们。debugPrint和print实际上是在Swift module顶层声明的一个函数，因为编译器已经隐含地导入了Swift模块，所以我们的代码可以直接看到Swift module所有的顶层声明，当然也包括debugPrint和print。
因此，debugPrint函数如同当前文件的其它顶层函数一样，也变成了一个普通的顶层函数，它对我们的代码来说是全局的。因此，可以直接使用它而不需要指定命名空间，也可以在使用的时候明确指定它的命名空间，即使用Swift.debugPrint(&amp;quot;hello&amp;quot;)，但通常不这样做，因为这样很冗余。
但是，你自己应用程序模块会掩盖导入的任何其它模块。也就是说，如果声明一个与导入模块中同名的东西，就会失去直接使用导入的东西而不用指定命名空间的神奇能力。假如在代码中声明一个同名的debugPrint函数，那么编译器将会自动隐藏Swift module中的debugPrint函数，即自定义代码中声明的debugPrint函数具有更高的优先级，为了调用Swift的debugPrint函数，现在必须明确地使用有命名空间，即Swift.debugPrint。
Swift.debugPrint(&amp;#34;test&amp;#34;) Instances 对象类型（类、结构和枚举）有一个重要的共同特点：它们可以被实例化。实际上，声明一个对象类型时，只是定义了一个类型，实例化是为了生成该类型的实例。
class Dog {  func bark() {  debugPrint(&amp;#34;woof&amp;#34;)  } } 上面的代码只是声明了Dog类型，即描述了如果有一只狗，它应该是什么样的，实际上还没有任何Dog对象。为了得到一个真正的Dog，必须制造一只，而制造一只真正的Dog对象过程就是实例化Dog的过程。
在Swift中，实例的生成可以通过使用对象类型的名称作为函数名并调用该函数来实现（被称为初始化器）。当在一个对象类型的名称上加上圆括号时，就是在向该对象类型发送一种非常特殊的信息———实例化你自己（生成一个该类型的实例）。
let fido = Dog() 上面这段代码做了两件事，首先是实例化了Dog，得到了一个Dog实例。同时还把这个实例放到了一个名叫fido的盒子中（声明了一个变量，并通过把Dog的实例分配给它来初始化这个变量，现在fido是一个Dog的实例）。
现在有一个Dog的实例，可以向它发送instance messages（实例消息），实例消息包括实例属性和实例方法。在对象类型的声明中，属性和方法默认是实例属性和实例方法，不能把它们作为该对象类型的消息来使用。如果想要发送实例消息，就必须先生成一个实例：
let fido = Dog() fido.bark() 如果想要发送类型消息，则需要声明为static或class函数，或者声明static或class属性。下面代码中声明了static和class属性和方法：
class Test {  /// static属性  static var test = &amp;#34;test&amp;#34;  /// class属性，不能为存储属性  class var name: String {  return &amp;#34;name&amp;#34;  }   /// static方法  static func testFunc() {  //  }   /// class 方法  class func nameFunc() {  //  }  } 在上面代码中用class声明name属性时只能为计算属性，不能声明为存储属性，否则会出现编译错误：Class stored properties not supported in classes; did you mean &#39;static&#39;?。
即使没有实例这样的东西，对象类型本身也是一个对象，因为可以向对象类型发送消息（Manny.Klass就是一个很好的例子）。为什么会需要实例呢？这主要与实例属性的性质有关，实例属性的值是针对特定实例定义的，这就是实例真正有用和强大的地方。
class Dog {  var name = &amp;#34;&amp;#34;   func bark() {  debugPrint(&amp;#34;woof&amp;#34;)  } } 对于上面的声明，可以生成多个Dog实例，每一个Dog实例都有自己的name值。但多个实例的行为是相似的，它们都可以调用bark方法。
let dog1 = Dog() dog1.name = &amp;#34;Fido&amp;#34; var dog2 = Dog() dog2.name = &amp;#34;Rover&amp;#34;  print(dog1.name) // &amp;#34;Fido&amp;#34; print(dog2.name) // &amp;#34;Rover&amp;#34;  dog2 = dog1 print(dog2.name) // &amp;#34;Fido&amp;#34; 一个实例**不仅对其属性的值负责，而且对其属性的生命周期负责**。假设创建了一个Dog实例，并为它的name属性赋值为Fido。只要不将属性name的值替换为其它值，并且此实例一直存在，这个实例就会使字符串Fido保持活跃状态。
也就是说一个实例既是代码又是数据。实例的代码指的是它的类型声明，与该类型的所有实例共享。但数据只属于实例，只要实例持续存在，数据就可以持续存在，实例在每个时刻都有一个状态，即实例属性值完整集合。
一个类的声明实际上定义了一个命名空间。这个命名空间**要求其它对象使用额外的点标记来引用该空间内的内容**。命名空间本身并没有关闭任何可见性的大门，但访问权限private关键字可以。
The Keyword self 一个实例是一个对象，而对象是消息的接收者。因此，一个实例需要一种向自己发送消息的方法，通过使用关键字self来实现，self关键字可以用在预期有适当类型实例的地方：
class Dog {  var name = &amp;#34;name&amp;#34;  var whatADogSays = &amp;#34;woof&amp;#34;   func bark() {  debugPrint(self.whatADogSays)  }   func speak() {  self.bark()  } } 上面代码中self仅出现在实例方法中，当在一个实例代码中使用self时，它指的是当前这个实例，也就是此时代码正在运行的那个。如果表达式self.name出现在Dog实例方法中，它意味着当前Dog实例的name属性。
在实例方法中使用self关键字是可选的，即是可以省略的。如果省略了信息接收者，而要发送的信息又可以发送给self，那么编译器默认会把self作为信息的接收者。作为一个编码风格问题，明确地使用self或许是一个好习惯，因为省略self的代码更难阅读和理解。而且在有些情况下，必须显式使用self。
Privacy 命名空间本身并未关闭任何可见性的大门，但这种可见性屏障有时是十分需要的。因为并非所有由实例存储的数据都是为了被另一个实例改变，甚至有时要求对其它实例是不可见的。
也不是每个实例的方法都想要被其它实例调用。基于对象的编程语言通常都需要一种方法来赋予其对象成员以隐私——一种使其它对象更难看到这些属性和方法的方式。
class Dog {  var name = &amp;#34;name&amp;#34;  var whatADogSays = &amp;#34;woof&amp;#34;   func bark() {  debugPrint(self.whatADogSays)  }   func speak() {  debugPrint(self.whatADogSays)  } } 在上面的声明中，其它对象都可以更改实例属性whatADogSays。并且bark和speak方法都使用该属性，一旦改变属性whatADogSays的值，则bark和speak使用的值也会跟着变化。为了避免whatADogSays被随意更改，可以将其用private限定只能方法能够修改，不能被实例直接修改。
一个类声明定义了一个命名空间。这个命名空间要求其他对象使用额外的点符号来引用命名空间内的内容，命名空间本身并不会关闭任何可见性之门。private关键字可以关闭这些可见性大门。
在上面的代码中，其它的实例也能够访问和修改属性whatADogSays。因为方法bark和speak都能修改属性whatADogSays的值。当使用一个Dog实例调用bark时，它却说meow，这似乎有点不可取：
let fido = Dog() fido.whatADogSays = &amp;#34;meow&amp;#34; fido.bark() // meow 此时，我们可能想到把属性whatADogSays声明为常量，这样就没人可以修改它了。但这个带来了两个问题。第一，假设想要Dog实例本身可以修改属性whatADogSays，此时需要将其声明为var，否则连实例本身也不能修改。
另外，假设不希望任何其它对象知道这只Dog在说什么，除非通过调用bark和speak。即使使用let声明，其他对象仍然可以读取whatADogSays的值。为了解决这个问题，Swift提供了private关键字：
class Dog {  var name = &amp;#34;&amp;#34;  private  var whatADogSays = &amp;#34;woof&amp;#34;   func bark() {  print(self.whatADogSays)  }   func speak() {  print(self.whatADogSays)  } } 现在whatADogSays是私有属性，它不能被其他类型的对象看到。Dog实例可以访问whatADogSays，但Cat实例中使用Dog实例时，不能访问属性whatADogSays：
class Cat {  func tryToChangeWhatADogSays() {  let fido = Dog()  fido.whatADogSays = &amp;#34;meow&amp;#34; // compile error   } } Reserved Words 某些术语，如class和func和var和let和if以及private和import，在Swift中是保留的关键字。这意味着不能将它们用作标识符——例如作为类、函数或变量的名字。如果尝试这样做，将会出现编译错误。如果需要强制将保留字成作为标识符，需要反引号(`)将其括起来，下面这个代码看起来非常混乱，但是是合法的：
class `func` {  func `if`() {  let `class` = 1  } } 实例不是凭空产生的，必须实例化一个类型才能获得这个类型的一个实例。通常说来，程序中很大一部分操作是实例化类型。当然，你会希望这些实例持续存在，因此将每个新创建的实例分配给一个变量，以保存、命名并赋予它生命周期。该实例将根据引用它的变量的生命周期持续存在。
functions 没有什么比声明和调用函数更能说明Swift的语法特点了。下面是一个简单有效的函数声明，它期望有两个Int入参值，然后把它们加在一起：
func sum(_ x: Int, _ y: Int) -&amp;gt; Int {  let result = x &#43; y  return result } 函数声明的语法是非常严格和明确的，除非完全理解它，否则也就无法使用Swift。把第一行拆分成几个部分，这样就可以单独地标记它们：
func sum ①  (_ x:Int, _ y:Int) ②③  -&amp;gt; Int { ④⑤  let result = x &#43; y ⑥  return result ⑦ }   函数定义以关键字func开始，后面跟着函数名，上面示例中函数名是sum。函数名是函数调用必须使用的名称，即为了运行函数中所包含的代码必须使用函数名。
  函数名后面紧跟着参数列表，参数列表至少由一对圆括号组成。如果定义的函数需要参数，它们以逗号隔开列在圆括号内。每个参数都有严格的格式：外部参数名，空格，内部参数名，冒号，参数类型。
  上面的函数在参数名前有一个下划线和空格，下划线表示调用该函数时可以省略外部参数名。
  如果函数有返回值，在圆括号后面紧跟的将会是箭头运算符-&amp;gt;，在其后跟着的是函数返回类型。
  用花括号把函数体（实际的可执行代码）括起来。
  在花括号里面，参数已经生效，其类型在参数列表中已经被指定。
  如果函数要返回一个值，它需要在函数体中使用关键字return，其后紧跟着返回值。该值的类型必须与先前在函数声明时的返回值类型相匹配。
  参数 上面定义的sum函数有两个参数：第一个是Int类型，名字是x，第二个也是Int类型，名字为y。事实上，参数x和y的定义只是为了让参数值在函数体中使用。
函数体中的代码不会运行，除非其它地方的代码调用此函数并为其参数传递指定类型的值。如果调用这个函数的时候没有传递参数，或者提供的值都不是Int，编译器将报错。
参数声明的意思大概是：我们正在声明x和y，以便在函数中使用它们。这些变量是函数的局部变量（或称为内部变量），只有在当前函数体中才可以看到它们，函数外便无法再使用，它们与可能在其他函数或更高层次范围内使用的任何其它同名的x和y均不同。
返回值 在函数体中的关键字return其实做了两件事，首先是返回其后跟着的值，其次是结束当前函数的执行。虽然return语句之后可以包含其它代码，但这些代码不会被执行，并且会产生编译警告。
在Swift 5.1前，在有返回值的函数体中即使只有一条语句也必须显式使用return语句。但从Swift 5.1开始，有返回值的函数体中如果只有一条语句时可以省略return关键字，这个特性主要是方便SwiftUI。
在函数声明花括号前的那一部分可以看成是一种契约，即约定当前函数的输入和输出是怎么样的。根据这个契约，该函数期望有一定数量的入参，每个参数都有特定的类型，并产生一定类型的结果。因此，在函数调用时必须遵守这个契约。
花括号内的函数体将函数参数作为局部变量使用，关键字return后面的返回值类型必须与函数声明时的返回类型一致，否则会出现编译错误。
如果想要忽略函数的返回值，可以将函数调用的返回值分配给_（没有名称的变量）来消除编译器警告。例如，上面的sum调用可以如下使用：
_ = sum(4,5) 如果被调用的函数是自定义的，可以在函数声明的时候使用@discardableResult来标记，以消除编译警告：
@discardableResult func sum(_ x: Int, _ y: Int) -&amp;gt; Int {  let result = x &#43; y  return result } 空返回值和参数 函数定义时没有规定一定需要返回值，如果一个函数定义时没有返回值，下面3种写法都是可行的，但是推荐使用第三种写法，即去掉Void或者()：
func say1(_ s: String) -&amp;gt; Void {  debugPrint(s) }  func say2(_ s: String) -&amp;gt; () {  debugPrint(s) }  func say3(_ s: String) {  debugPrint(s) } 若一个函数没有返回值，那么它的函数体中就不需要包含return语句。如果包含了return语句，那么它只能由return这个词单独组成，其目的纯粹是在当前位置上结束函数的执行。
函数定义时也没有规定一定需要参数。如果函数没有参数则参数列表为空，但此时也不能省略参数列表括号并且在函数调用时也不能省略括号（实际上有一种特殊情况可以省略函数调用时的圆括号）。
func greet() -&amp;gt; String {  return &amp;#34;howdy&amp;#34; } 因此，函数声明的时候可以同时没有参数和返回值：
func greet1() -&amp;gt; Void {  print(&amp;#34;howdy&amp;#34;) }  func greet2() -&amp;gt; () {  print(&amp;#34;howdy&amp;#34;) }  func greet3() {  print(&amp;#34;howdy&amp;#34;) } 函数签名 如果函数声明的时候忽略外部和内部参数名，可以通过输入和输出类型来完全描述一个函数的特征。为此，把参数类型写在参数列表括号里，后面是箭头运算符和输出类型：
(Int, Int) -&amp;gt; Int 上面是一个合法的表达式，表示接收两个Int类型参数并返回一个Int类型函数的签名。这个签名描述了所有具有这种顺序和数量的参数、类型、并返回这种类型的结果的函数。一个函数的签名实际上就是它的类型&amp;mdash;函数的类型。
一个函数的签名必须包括参数列表（不带内外参数名，只有参数类型）和返回类型，其中的参数列表和返回值都可以为空。一个不带参数和没有返回值的函数签名可以写成()-&amp;gt; Void或()-&amp;gt;()：
func newTest(completion: @escaping () -&amp;gt; ()) {  completion() }  func newTest2(completion: @escaping () -&amp;gt; Void) {  completion() } 外部参数名 一个函数可以外化其参数名称，在调用函数的时候使用这个参数名称，这个名称被称为外部参数名或外部参数标签。外部参数名称也是函数名称的一部分，并且必须作为参数的标签出现在对该函数的调用中。外部参数标签有如下作用：
  它阐明了每个参数的目的，一个参数标签（外部参数）可以提供一个线索，说明该参数如何影响该函数。
  它将一个函数与另一个函数区分开来：两个在圆括号前具有相同名称和相同签名的函数，但具有不同的外部参数名称，是两个不同的函数「这个有待考证😂」。
  外部参数标签有助于Swift与Objective-C和Cocoa对接，在这两个地方，方法的参数几乎都有外部名称。
  外部参数名在Swift中非常常见，以至于有一条规则：默认情况下，所有参数名都会自动外部化，即使用内部名称作为其外部名称。如果想改变这种默认行为，有两种方式：
  如果想要参数的外部名称和内部名称不同，需要在内部名称前加一个外部名称并以空格分隔开，调用的时候就可以使用此外部参数名。
  如果需要去除一个参数的外部名称，则需要在内部名称前加上下划线和一个空格，此表示不使用外部参数，调用该函数时可以省略该参数名。
func echoString(_ s: String, times: Int) -&amp;gt; String {  var result = &amp;#34;&amp;#34;  for _ in 1...times {  result &#43;= s  }  return result } 上面的函数中，第一个参数只有内部名称，第二个参数既有内部名称也有外部名称，并且他们的名称相同，即times。
  外部名称的存在**并不意味着调用可以使用与声明不同的参数顺序**。下面的echo(string:times:)需要一个String参数和一个Int参数，必须按此顺序调用：
func echo(string s: String, times n: Int) -&amp;gt; String {  var result = &amp;#34;&amp;#34;  for _ in 1...n {  result &#43;= s  }  return result } 函数重载 在Swift中函数重载是合法的，这意味着两个函数具有相同的名字（包括相同的外部参数名称），但有着不同的函数签名是可以共存的。需要注意的是，两个基本名称（函数名）相同但外部参数名称不同的函数并不构成重载，它们是两个名称不同的函数「有些地方说这也是一种重载，个人看来也是合理的」。
重载之所以有效是因为Swift进行严格的类型区分。Swift可以在函数声明和函数调用时把重载函数区分出来。因此，Swift清楚地知道say(&amp;quot;what&amp;quot;)和say(1)是不同的。
需要注意的是重载也适用于函数的返回类型。两个具有相同名称和参数的函数可以有不同的返回类型。但调用时的上下文必须明确，即必须清楚调用者期望的返回类型，否则编译器会报错。下面两个重载函数是可以并存的：
func say() -&amp;gt; String {  return &amp;#34;one&amp;#34; }  func say() -&amp;gt; Int {  return 1 } 如果在调用的时候直接使用let result = say()会发生编译错误，因为编译器还不知道要调用哪个函数。因此，如果有返回类型重载的函数调用时必须明确指定返回类型：
let result: String = say() let test: Int = say() 上下文本身可能会消除歧义。假设有另一个没有重载的函数，它需要一个字符串参数，那么就可以直接使用giveMeAString(say())：
func giveMeAString(_ s: String) {  print(&amp;#34;thanks!&amp;#34;) } giveMeAString(say()) let result = say() &#43; &amp;#34;two&amp;#34; 在say() &#43; &amp;quot;two&amp;quot;中，因为只有字符串才能和字符串相加，所以此时say()只能返回字符串。也可以在函数调用时使用方法名和关键字as以及所需方法的签名来明确区分重载。这个语法看起来有点奇怪，因为**整个表达式必须用两对圆括号括起来，其中第一对圆括号表示类型转换，最后的一对圆括号表明这是一个函数调用**:
let result = (say as () -&amp;gt; String)() 默认值 参数可以有默认值（缺省值），这意味着对于**有默认值的参数调用者可以完全省略该参数，不提供任何值**。如果有默认值的参数在调用时省略该参数，表示使用默认值。如果要在函数声明中指定一个缺省值，只需在参数类型后面追加上=和缺省值即可：
class Dog {  func say(_ s: String, times: Int = 1) {  for _ in 1 ... times {  debugPrint(s)  }  } } 实际上，上面的say相当于两个函数。其中一个只有一个未标记的参数func say(_ s: String)，并且在函数体中times=1；另一个既有未标记的参数也有一个times参数func say(_ s: String, times: Int)。
可变参数 在函数中同类型的参数个数是可变的，即调用者可以根据需要提供该参数类型的多个值，用逗号隔开。实际上，函数体将以数组形式接收这些值。要在函数声明中表明一个参数是可变的，只需要在类型后面加上三个点：
func sayStrings(_ arrayOfStrings: String ...) {  for s in arrayOfStrings {  debugPrint(s)  } } sayStrings(&amp;#34;34&amp;#34;,&amp;#34;456&amp;#34;,&amp;#34;678&amp;#34;,&amp;#34;9899&amp;#34;) 其它参数可以跟在可变参数后面，但它必须有一个外部标签来标识可变参数在调用中的结束位置。全局的print和debugPrint函数第一个参数实际上是可变的，所以可以一次打印多个值。debugPrint函数中还有一些默认参数，这些参数确定了输出的细节：默认的分隔符(输出多个值时的分隔符号)是一个空格，默认的终止符是一个换行符，可以在调用的时候改变其中之一或全部：
public func print(_ items: Any..., separator: String = &amp;#34; &amp;#34;, terminator: String = &amp;#34;\n&amp;#34;) public func debugPrint(_ items: Any..., separator: String = &amp;#34; &amp;#34;, terminator: String = &amp;#34;\n&amp;#34;) 在Swift 5.3之前，一个函数至多可以声明一个可变参数，但从Swift 5.4开始这个限制被移除了,一个函数可以有多个可变参数。下面的testVariadicParameters有4个可变参数。因为每个可变参数在函数内部都以数组的形式接受的，所以打印出来也是数组形式：
func testVariadicParameters(first: String..., second: String..., third: Int..., forth: [String]...) {  debugPrint(first)  debugPrint(second)  debugPrint(third)  debugPrint(forth) }  testVariadicParameters(first: &amp;#34;1&amp;#34;, &amp;#34;2&amp;#34;, &amp;#34;3&amp;#34;, second: &amp;#34;name&amp;#34;, &amp;#34;This&amp;#34;, &amp;#34;true&amp;#34;, third: 1, 2, 45, 89, forth: [&amp;#34;TT&amp;#34;], [&amp;#34;KK&amp;#34;])  [&amp;#34;1&amp;#34;, &amp;#34;2&amp;#34;, &amp;#34;3&amp;#34;] [&amp;#34;name&amp;#34;, &amp;#34;This&amp;#34;, &amp;#34;true&amp;#34;] [1, 2, 45, 89] [[&amp;#34;TT&amp;#34;], [&amp;#34;KK&amp;#34;]] 如果第2个可变参数没有和第一个可变参数相邻，那么可以不需要外部参数名：
func sayStrings(_ array: String..., other: String, _ array2: String...) {  for s in array {  print(s)  }  print(other)  for s in array2 {  print(s)  } } sayStrings(&amp;#34;Manny&amp;#34;, &amp;#34;Moe&amp;#34;, &amp;#34;Jack&amp;#34;, other: &amp;#34;Matt&amp;#34;, &amp;#34;Groucho&amp;#34;, &amp;#34;Harpo&amp;#34;, &amp;#34;Chico&amp;#34;) 不幸的是，Swift语言中存在一个漏洞：无法将数组转换为以逗号分隔的参数列表（类似于Ruby中的 splatting）。如果使用的是某种类型的数组，那么不能在需要该类型的可变参数的地方使用它。
忽略的参数 如同外部参数一样，如果**内部参数名称为下划线，则说明该内部参数名称会被忽略**。即使省略了内部参数，函数调用者也必须提供实参，但它在函数体中没有内部名字。在下面的例子中，内部参数名字已经省略，也就是说无法使用这个参数，因此使用外部参数名会出现编译错误：
func say(_ s: String, test times: Int, loudly _: Bool) {  debugPrint(s)  debugPrint(times)  debugPrint(loudly) // Cannot find &amp;#39;loudly&amp;#39; in scope  debugPrint(test) // Cannot find &amp;#39;test&amp;#39; in scope }  say(&amp;#34;test&amp;#34;, test:12, loudly: false) 可修改参数 在函数内的参数，本质上是一个局部变量。默认情况下（不声明为inout时）函数参数是用let隐式声明的常量。因为函数内的参数是常量，所以不能对它进行赋值操作：
func say(_ s: String, times: Int, loudly: Bool) {  loudly = true // compile error  } 如果在函数体内需要对参数进行赋值，你可能想到的一种方式是声明一个同名的变量，然后将参数的值赋值给刚定义的变量，这样就可以改变值：
func say(_ s: String, times: Int, loudly: Bool) {  var loudly = loudly  loudly = true // local var } 但上面只是改变新定义的本地loudly变量，不会改变传进来入参loudly的值。如果想要改变函数传进来实参的值，需要按如下方式进行：
  参数的类型必须声明为inout，关键字inout放在类型前面。
  调用函数时，传入的实参必须是用var声明的，而不能是let声明，因为只有用var声明的变量才能被改变。
  调用函数时，传入的必须是实参的地址，而不是实参本身，即需要在变量名前加&amp;amp;符号。
  func say(_ s: String, times: Int, loudly: inout Bool) {  loudly = true } var loudly = false say(&amp;#34;test&amp;#34;, times: 1, loudly: &amp;amp;loudly) 当调用带有inout参数的函数时，始终设置其地址作为参数传递给该参数的变量，即使该函数没有对该参数进行任何更改。
有一种常见的情况是，在函数体中可以修改参数的值而不必把它声明为inout。当参数是一个类的实例时，可以直接修改实例的值，这是类的一个特殊功能，与其他两种对象类型（枚举和结构体）不同。
class Dog {  var name = &amp;#34;&amp;#34; }  func changeName(of d: Dog, to newName: String) {  d.name = newName }  let d = Dog() d.name = &amp;#34;Fido&amp;#34;  debugPrint(d.name) // &amp;#34;Fido&amp;#34; changeName(of: d, to: &amp;#34;Rover&amp;#34;) debugPrint(d.name) // &amp;#34;Rover&amp;#34; 在上面的例子中changeName函数的第一个参数并没有声明为inout，但在函数体中确实改变了Dog的实例d的属性。虽然传入的实参是用let声明的，但也能改变类实例的属性name，这说明**类的实例本身是可变的**。
从技术上讲，我们说类是引用类型，而其他类型的对象则是值类型。当把一个结构体的实例作为参数传递给一个函数时，实际上是得到了该结构体实例的一个副本。但是，当把一个类的实例作为参数传递给一个函数时，传递的是该类实例本身的引用。
class A {  var name = &amp;#34;A&amp;#34; } struct B {  var name = &amp;#34;B&amp;#34; }  var a: A = A() {  didSet {  debugPrint(oldValue)  } }  var b: B = B() {  didSet {  debugPrint(oldValue)  } }  a.name = &amp;#34;aaa&amp;#34; b.name = &amp;#34;bbb&amp;#34; // Command.B(name: &amp;#34;B&amp;#34;) 上面代码改变类的实例a的name属性时didSet没有调用，而改变结构体的实例b的属性name时，didSet调用了，说明生成了一个结构体实例副本。
使用可修改参数调用OC 当使用Cocoa时，可能会遇到该模式的变化。Cocoa API是用C和Objective-C编写的，因此可能会看到一些神秘的类型，例如UnsafeMutablePointer，而不是Swift中的inout。然而，作为调用者的角度来看，这是同一件事：你将准备一个var变量并传递其地址。
例如，UIColor的RGBA成分的问题，它由四个成分：红色、绿色、蓝色和alpha值。给定UIColor的函数返回该颜色的成分，需要一次返回四个值——这是Objective-C无法做到的。UIColor方法getRed(_:green:blue:alpha:)返回一个布尔值，以说明是否提取成功：
func getRed(_ red: UnsafeMutablePointer&amp;lt;CGFloat&amp;gt;, green: UnsafeMutablePointer&amp;lt;CGFloat&amp;gt;, blue: UnsafeMutablePointer&amp;lt;CGFloat&amp;gt;, alpha: UnsafeMutablePointer&amp;lt;CGFloat&amp;gt;) -&amp;gt; Bool let c = UIColor.purple var r : CGFloat = 0 var g : CGFloat = 0 var b : CGFloat = 0 var a : CGFloat = 0 c.getRed(&amp;amp;r, green: &amp;amp;g, blue: &amp;amp;b, alpha: &amp;amp;a) // now r, g, b, a are 0.5, 0.0, 0.5, 1.0 被可修改参数的OC调用 有时Cocoa想要使用UnsafeMutablePointer参数调用Swift函数，用到的技术是赋值UnsafeMutablePointer的指针属性。
func popoverPresentationController(_ popoverPresentationController: UIPopoverPresentationController, willRepositionPopoverTo rect: UnsafeMutablePointer&amp;lt;CGRect&amp;gt;, in view: AutoreleasingUnsafeMutablePointer&amp;lt;UIView&amp;gt;) {  view.pointee = self.button2  rect.pointee = self.button2.bounds } 内部函数 函数可以在任何地方声明，在函数体中声明函数也是合法的。声明在函数内的函数称为本地函数（内部函数），它可以被在同一范围内本地函数声明后的同级代码所调用，但在其它地方完全不可见。
对于那些唯一目的是协助另一个函数的函数来说，内部函数是一种优雅的架构。如果只有函数A需要调用函数B，那么函数B还不如打包在函数A里面。
func checkPair(_ p1: Piece, and p2: Piece) -&amp;gt; Path? {  // ...  func addPathIfValid(_ midpt1: Point, _ midpt2: Point) {  // ...  }  for y in -1 ... _yct {  addPathIfValid((p1.x, y), (p2.x, y))  }  for x in -1 ... _xct {  addPathIfValid((x, p1.y), (x, p2.y))  }  // ... } 内部函数实际上是一个局部变量，其类型是函数类型。因此，一个**局部函数不能与同一作用域中的局部变量同名，并且两个局部函数也不能在同一作用域中同名**。
递归 在函数中调用自己的函数被称为递归函数。递归可能会产生无限循环，所以需要在递归函数中写出正确的终止逻辑，防止无限递归下去，导致内存占用过高，手机发烫：
func countDownFrom(_ ix: Int) {  debugPrint(ix)  if ix &amp;gt; 0 { // stopper  countDownFrom(ix - 1) // recurse  } }  countDownFrom(5) // 5, 4, 3, 2, 1, 0 函数作为值 在Swift中函数是一等公民，这意味着任何使用值的地方都可以使用函数。一个函数可以被赋值给一个变量，也可以作为一个函数调用的参数被传递，也可以作为函数返回值。
Swift是强类型的语言，当**函数作为值传递的，必须类型相匹配，函数的签名就是它的类型**。为了使函数类型更简洁，可以使用typealias给一个函数类型起个别名，这个名字可以是描述性的：
typealias VoidVoidFunction = () -&amp;gt; Void  func doTest(test: VoidVoidFunction) {  test() }  doTest {  debugPrint(&amp;#34;doTest 1&amp;#34;) }  doTest() {  debugPrint(&amp;#34;doTest 2&amp;#34;) } 使用一个函数作为值的主要目的是**可以在不确定函数具体是什么的情况下调用该函数**。下面示例代码是一个极简单的例子，只是为了展示函数作为值使用的结构和语法：
func doThis(_ f: () -&amp;gt; Void) {  f() } 上面doThis函数通过f()来调用它接受的函数参数。所以doThis仅是一个调用另一个函数的简单函数。但它这样做时事先并不知道要调用什么函数，这就是函数作为一等公民的力量。在声明了doThis这个函数后，需要把一个函数作为参数传给它才能调用：
typealias VoidVoidFunction = () -&amp;gt; Void func dothis(_ f: VoidVoidFunction) {  f() }  func doThis(_ f: () -&amp;gt; Void) {  f() }  func whatToDo() {  debugPrint(&amp;#34;I did it&amp;#34;) }  doThis(whatToDo) //I did it 为了使函数类型更清晰，可以利用Swift的类型别名特性为函数类型命名。该名称可以是描述性的，并且避免了可能令人困惑的箭头运算符符号：
typealias VoidVoidFunction = () -&amp;gt; ()  func dothis(_ f: VoidVoidFunction) {  f() } 匿名函数 在下面的代码中，声明函数whatToAnimate和whatToDoLater只是为了在UIView.animate中传递函数参数。其实并不一定需要whatToAnimate和whatToDoLater这两个函数名字，因为他们只是在代码最后一行使用了，之后便没有再使用：
func whatToAnimate() {  debugPrint(&amp;#34;animations&amp;#34;) }  func whatToDoLater(finished: Bool) {  debugPrint(&amp;#34;finished: \(finished)&amp;#34;) }  UIView.animate(withDuration: 0.4, animations: whatToAnimate, completion: whatToDoLater) //open class func animate(withDuration duration: TimeInterval, animations: @escaping () -&amp;gt; Void, completion: ((Bool) -&amp;gt; Void)? = nil) 如果在UIView.animate(withDuration:animations:completion:)调用时只传递函数体，不专门声明一个函数，并将其名字传递进去，将会更简洁。
一个*无名的函数体被称为匿名函数*，在Swift中匿名函数是合法并且十分常见。要形成一个匿名函数，需要做两件事。首先，需要创建一个函数体，即一对花括号(此时无需加func xxx)。接着，如果有必要，将函数的参数列表和返回类型作为花括号内的第一件事来表达，然后是关键字in：
{ () -&amp;gt; () in  debugPrint(&amp;#34;animations&amp;#34;) }  { (finished: Bool) -&amp;gt; () in  debugPrint(&amp;#34;finished: \(finished)&amp;#34;) } 匿名函数缩写 省略返回类型和箭头 匿名函数在Swift中很常见，也非常重要，所以Swift提供了一些书写匿名函数的便捷方式。如果编译器已经知道匿名函数的返回值，则可以省略箭头操作符和返回值类型：
UIView.animate(withDuration: 0.4, animations: { () in // 省略了箭头操作符和返回值类型  debugPrint(&amp;#34;animations&amp;#34;) }, completion: { (finished: Bool) in // 省略了箭头操作符和返回值类型  debugPrint(&amp;#34;finished: \(finished)&amp;#34;) })  func testName(count: Int, test: (Int) -&amp;gt; String) {  debugPrint(test(count)) }  testName(count: 3) { (count: Int) in // 省略了箭头操作符和返回值类型  return &amp;#34;test:\(count)&amp;#34; }  debugPrint({ (count: Int) in // 省略了箭头操作符和返回值类型  return &amp;#34;\(count)&amp;#34; }(13)) // 13  func doThis(completion: @escaping () -&amp;gt; String) {  completion() }  doThis() { () in // 省略了箭头操作符和返回值类型  return &amp;#34;doThis&amp;#34; } 偶尔编译器也会无法推断出匿名函数的返回类型，并且会出现编译错误。如果发生这种情况，就不能使用这种省略箭头操作符和返回值的便捷方式，而应该提供一个具有明确返回类型的in表达式。
省略in关键字 如果一个匿名函数没有参数，并且箭头操作符和返回类型（一起的）可以省略，那么关键字in也可以省略。在下面代码中传递给animations的匿名函数省略了返回类型和in关键字:
UIView.animate(withDuration: 0.4, animations: { // 没有参数省略了箭头操作符和返回值类型以及 in  debugPrint(&amp;#34;animations&amp;#34;) }, completion: { (finished: Bool) in  debugPrint(&amp;#34;finished: \(finished)&amp;#34;) })  func doThis(completion: @escaping () -&amp;gt; String) {  completion() }  doThis() { () // 无参数，有返回值 省略了关键关键字in  return &amp;#34;doThis&amp;#34; } 省略参数类型 如果匿名函数有参数，并且*编译器已经知道参数的类型，则匿名函数中参数的类型可以省略*。下面代码中传递给completion的匿名函数省略了参数类型，即Bool：
UIView.animate(withDuration: 0.4, animations: {  debugPrint(&amp;#34;animations&amp;#34;) }, completion: { (finished) in // 省略了参数类型  debugPrint(&amp;#34;finished: \(finished)&amp;#34;) })  func testName(count: Int, test: (Int) -&amp;gt; String) {  debugPrint(test(count)) }  testName(count: 2) { (count) in // 省略了参数类型和返回值类型  return &amp;#34;test:\(count)&amp;#34; }  debugPrint({ (count) in // 省略了参数类型和返回值类型  return &amp;#34;\(count)&amp;#34; }(13)) // 13 省略参数列表圆括号 如果*匿名函数的参数类型可以省略，那么参数列表的圆括号也可以省略*。下面代码中传递给completion的匿名函数，既省略了参数类型也省略了圆括号：
UIView.animate(withDuration: 0.4, animations: {  debugPrint(&amp;#34;animations&amp;#34;) }, completion: { finished in // 省略了参数类型和参数列表圆括号以及返回值类型  debugPrint(&amp;#34;finished: \(finished)&amp;#34;) })  func testName(count: Int, test: (Int) -&amp;gt; String) {  debugPrint(test(count)) }  testName(count: 2) { count in // 省略了参数类型和参数列表圆括号以及返回值类型  return &amp;#34;test:\(count)&amp;#34; }  debugPrint({ count in // 省略了参数类型和参数列表圆括号以及返回值类型  return &amp;#34;\(count)&amp;#34; }(13)) // 13 有参数列表省略in表达式 如果*匿名函数的返回类型可以省略，并且编译器已经知道参数的类型*，也可以省略in表达式。在匿名函数体中可以直接引用参数，$0表示第一个参数，$1表示第二个参数，依此类推：
UIView.animate(withDuration: 0.4, animations: {  debugPrint(&amp;#34;animations&amp;#34;) }, completion: {  debugPrint(&amp;#34;finished: \($0)&amp;#34;) })  func testName(count: Int, test: (Int) -&amp;gt; String) {  debugPrint(test(count)) }  testName(count: 2) {  return &amp;#34;test:\($0)&amp;#34; }  debugPrint({  return &amp;#34;\($0)&amp;#34; }(13)) // 13 省略参数名 如果匿名函数不需要引用参数，则可以在in表达式的参数列表中*用下划线代替其名称，表示在匿名函数中不使用该参数*。下面的代码中，传递给completion的匿名函数，使用下划线代替了参数名：
UIView.animate(withDuration: 0.4, animations: {  debugPrint(&amp;#34;animations&amp;#34;) }, completion: { _ in // *  debugPrint(&amp;#34;finished!&amp;#34;) }) 如果一个匿名函数有参数，可以省略in表达式，使用$0,$1...来使用参数。或者可以保留in表达式，给参数命名，或者用下划线忽略它们。但不能省略in表达式而不使用参数的魔法名称$0,$1，一旦这样做了，代码将无法通过编译。
省略函数标签 如果匿名函数是函数调用中传递的最后一个参数。可以*在最后一个参数之前用右括号来关闭函数调用，然后只放匿名函数体，不放任何标签*，这就是尾部闭包语法：
UIView.animate(withDuration: 0.4, animations: {  debugPrint(&amp;#34;animations&amp;#34;) }) { _ in  debugPrint(&amp;#34;finished!&amp;#34;) } 在上面代码中，因为completion:是方法中的最后一个参数，因此可以在调用的括号外传递匿名函数，使用不带标签的尾部闭包语法。但是，实际上animate函数中接受两个函数参数，animations也是匿名函数，但它依然在括号里。
从Swift 5.3开始，多个匿名函数参数可以使用尾部闭包语法。当这样做时，第一个匿名函数不需要标签，但其余的函数都需要它们的标签：
UIView.animate(withDuration: 0.4) {  debugPrint(&amp;#34;animations&amp;#34;) } completion: { _ in  debugPrint(&amp;#34;finished!&amp;#34;) } 省略函数调用圆括号 如果使用了尾部闭包，并且如果所调用的函数*除了传递给它的函数之外没有其他函数参数*，可以从调用中省略圆括号。这是**唯一可以从函数调用中省略圆括号的情况**：
func doThis(_ f: () -&amp;gt; Void) {  f() }  doThis { // 省略调用圆括号  debugPrint(&amp;#34;Howdy&amp;#34;) }  func doThis(name: String, _ f: () -&amp;gt; Void) {  f() }  doThis(name: &amp;#34;trr&amp;#34;) { // 省略调用圆括号  debugPrint(&amp;#34;Howdy&amp;#34;) } 省略return关键字 如果匿名函数体恰好只由一个语句组成，并且该语句包含返回一个带有关键字return的值，实际上关键字return是可以省略的：
func greeting() -&amp;gt; String {  return &amp;#34;Howdy&amp;#34; }  func performAndPrint(_ f: () -&amp;gt; String) {  let s = f()  print(s)  }  performAndPrint {  greeting() // meaning: return greeting() } 在编写匿名函数时，会经常发现自己已经利用了所有允许的省略写法。此外，有时会通过将整个匿名函数与函数调用放在一行中来缩短代码行数。因此，涉及匿名函数的Swift代码可以非常紧凑：
let arr = [2, 4, 6, 8] let arr2 = arr.map {$0*2} Define and Call 在Swift中，常见的模式是定义一个匿名函数并调用它。如下代码所示，花括号定义了一个匿名函数体，圆括号表示调用该匿名函数，此结构称为定义和调用（define-and-call）：
{ // ... code goes here }() 有一个常见Cocoa情况，创建和配置NSMutableParagraphStyle，然后将其作为参数调用NSMutableAttributedString的方法addAttribute(_:value:range:)，代码如下所示：
let para = NSMutableParagraphStyle() para.headIndent = 10 para.firstLineHeadIndent = 10 // ... more configuration of para ...  content.addAttribute(// content is an NSMutableAttributedString  .paragraphStyle,  value: para,  range: NSRange(location: 0, length: 1)) 但是上面的代码看起来很丑。实际上para是在调用addAttribute(_:value:range:)时将它作为value:参数传递进去的，因此在调用时创建和配置会更好。这听起来像是使用一个匿名函数的场景，除了value:参数不是一个函数，而是一个NSMutableParagraphStyle对象：
content.addAttribute(  .paragraphStyle, value: {  let para = NSMutableParagraphStyle()  para.headIndent = 10  para.firstLineHeadIndent = 10 // ... more configuration of para ... return para  }(), range: NSRange(location: 0, length: 1)) Closures Swift的**函数都是闭包，这意味函数体内可以捕获函数外的外部变量的引用**。这是什么意思呢，在下面这段代码中，函数bark可以看到在其函数体外声明的变量和函数：
class Dog {  var whatThisDogSays = &amp;#34;woof&amp;#34;  func bark() {  print(self.whatThisDogSays)  } }  对于上面的bark函数来说，whatThisDogSays是一个外部变量，因为它是在bark函数体之外声明的，但*它的作用域仍在bark函数体内*，因此bark函数内部的代码可以看到它。 函数体内的代码引用了外部变量whatThisDogSays。  到目前为止还挺好，但是我们知道函数bark可以作为值传递。实际上，它可以从一种环境传播到另一种环境。当它发生时，对whatThisDogSays的引用会发生什么？让我们来了解一下：
func doThis(_ f: () -&amp;gt; ()) {  f() }  let d = Dog() d.whatThisDogSays = &amp;#34;arf&amp;#34; let barkFunction = d.bark doThis(barkFunction) // arf 上面的结果看起来是正常的，但是我们没有直接调用d.dark，而是创建了一个Dog的实例，并把它的bark函数作为值传给函数doThis函数。在函数doThis中，bark函数被调用。
whatThisDogSays是Dog的实例属性，在函数doThis中并没有whatThisDogSays属性。事实上，在doThis函数中也没有Dog的实例。然而，调用f()仍然能正常。函数d.bark，当它被传递的时候，显然是把变量whatThisDogSays一起传递的。
当我们创建了Dog的实例d和变量barkFunction，更改d的属性会改变barkFunction的输出，怎么会这样？显然当d.bark赋值给barkFunction后，实例d和barkFunction都持有对同一个Dog实例的引用。这是因为*我们赋值给barkFunction的d.bark引用了self，也就是Dog实例*。当我们说函数是一个闭包并且它捕获在其主体中引用的外部变量时，这就是我们的意思。
How Closures Improve Code 可以使用函数是闭包这一事实来使你的代码更通用，从而更有用。为了说明函数是闭包的作用，使用之前的一个函数示例，它接受绘图指令并执行它们以生成图像：
func imageOfSize(_ size: CGSize, _ whatToDraw: () -&amp;gt; ()) -&amp;gt; UIImage {  UIGraphicsBeginImageContextWithOptions(size, false, 0)  whatToDraw()  let result = UIGraphicsGetImageFromCurrentImageContext()!  UIGraphicsEndImageContext()  return result } 可以以尾闭包的方式调用上面的函数：
let image = imageOfSize(CGSize(width: 45, height: 20)) {  let p = UIBezierPath(roundedRect: CGRect(x: 0, y: 0, width: 45, height: 20), cornerRadius: 8)  p.stroke() } 但上面包含了重复代码，即CGSize(width:45, height:20)重复了两次：
let sz = CGSize(width: 45, height: 20) let image = imageOfSize(sz) {  let p = UIBezierPath(roundedRect: CGRect(origin: CGPoint.zero, size: sz), cornerRadius: 8)  p.stroke() } 在上面的代码中，常量sz是在比匿名函数更高层次声明的，因此在匿名函数中能够看见和引用它。但需要注意的是，匿名函数只是一个函数体，如果imageOfSize不调用，匿名函数就不会被执行。
当函数体内部的表达式CGRect(origin:CGPoint.zero, size:sz)中引用sz时，因为函数体是一个闭包，我们现在捕获了它的值。当函数imageOfSize调用whatToDraw时，whatToDraw变成了一个函数，函数体内引用了变量sz，这是没有问题，尽管在imageOfSize附近没有sz。
到目前为止，我们一直在硬编码所需圆角矩形的大小。不过，想象一下，创建各种大小的圆角矩形图像是我们经常做的事情。将这段代码打包成一个函数是有意义的，其中sz不是一个固定值，而是一个入参，然后该函数将返回图像：
func makeRoundedRectangle(_ sz: CGSize) -&amp;gt; UIImage {  let image = imageOfSize(sz) {  let p = UIBezierPath(roundedRect: CGRect(origin: CGPoint.zero, size: sz), cornerRadius: 8)  p.stroke()  }  return image } 在上面的makeRoundedRectangle函数中，参数sz不再是硬编码值，事先我们并不知道它将会是什么。当调用makeRoundedRectangle时，sz将会有一个值，并且匿名函数会捕获sz，所以当imageOfSize调用匿名函数时，该匿名函数内部的sz将具有传递给makeRoundedRectangle的值。
上面的代码变得非常紧凑。要调用makeRoundedRectangle，先提供size，返回图像。我们可以一次完成调用、获取图像并显示该图像：
self.iv.image = makeRoundedRectangle(CGSize(width:45, height:20)) Function Returning Function 实际上可以更进一步，相比于返回一个图像，函数可以返回一个生成指定大小圆角矩形图片的函数。函数可以用作值，我们已经将一个函数作为参数传递给另一个函数。
函数也可以返回函数，现在我们将从函数调用中接收一个函数作为其结果，也就是返回一个生成指定大小圆角矩形图片的函数：
func makeRoundedRectangleMaker(_ sz: CGSize) -&amp;gt; () -&amp;gt; UIImage { ①  func f() -&amp;gt; UIImage { ②  let im = imageOfSize(sz) {  let p = UIBezierPath(roundedRect: CGRect(origin: CGPoint.zero, size: sz), cornerRadius: 8)  p.stroke()  }  return im  }  return f ③ }   函数makeRoundedRectangleMaker的类型（签名）到底是什么？它是(CGSize) -&amp;gt; () -&amp;gt; UIImage。该表达式有两个箭头运算符，需要注意的是每个箭头运算符之后的所有内容都是一个返回值类型。因此上面的函数接受一个参数CGSize，并且返回一个签名为() -&amp;gt; UIImage的函数。
  在函数makeRoundedRectangleMaker体内第一步是定义一个内部函数，这个内部函数没有入参，返回一个UIImage，我们将这个函数命名为f。这个函数的工作方式既简单又熟悉：它调用imageOfSize，传递给它一个匿名函数，该函数生成一个圆角矩形的图像，然后返回该图像。
  最后，返回内部函数f。也就是履行了之前的约定：将返回一个不带参数并返回一个UIImage的函数。
  但也许你仍然张着嘴盯着makeRoundedRectangleMaker，想知道怎么使用它，如果你这样做会得到什么。让我们尝试一下：
let maker = makeRoundedRectangleMaker(CGSize(width:45, height:20)) 该代码运行后的变量maker的是什么？它是一个函数：一个不带参数的函数，当它被调用时，它会生成一个大小为(45,20)的圆角矩形的图像。可以通过调用maker来证实这一点：
let maker = makeRoundedRectangleMaker(CGSize(width:45, height:20)) self.iv.image = maker() 我们再次将注意力转向makeRoundedRectangleMaker函数的实现，编写makeRoundedRectangleMaker不是为了告诉你一个函数可以产生一个函数。编写它是为了说明闭包，让我们思考一下environment是如何被捕获的。
函数f没有参数。然而，在f的函数体中两次引用了sz。在函数f内部可以看到sz，即外部函数makeRoundedRectangleMaker的参数。函数f在makeRoundedRectangleMaker被调用时捕获了sz，并在f返回并赋值给maker时保留该引用：
let maker = makeRoundedRectangleMaker(CGSize(width:45, height:20)) 这就是为什么maker现在是一个函数，当它被调用时，创建和返回了特定大小的图片，生成图像大小值已被纳入到maker中。另一方面，makeRoundedRectangleMaker是一个工厂函数，用于创建类似于maker的系列函数，每个函数都生成一个特定大小的图像。这是一个戏剧性的例子，说明了闭包的力量。
实际上，可以以更快捷的方式重写makeRoundedRectangleMaker，在makeRoundedRectangleMaker中，没有必要创建im变量，可以直接返回imageOfSize：
func makeRoundedRectangleMaker(_ sz: CGSize) -&amp;gt; () -&amp;gt; UIImage {  func f() -&amp;gt; UIImage {  return imageOfSize(sz) {  let p = UIBezierPath(roundedRect: CGRect(origin: CGPoint.zero, size: sz), cornerRadius: 8)  p.stroke()  }  }  return f } 实际上也没有必要生成和返回f，可以直接返回匿名函数：
func makeRoundedRectangleMaker(_ sz: CGSize) -&amp;gt; () -&amp;gt; UIImage {  return {  imageOfSize(sz) {  let p = UIBezierPath(roundedRect: CGRect(origin: CGPoint.zero, size: sz), cornerRadius: 8)  p.stroke()  }  } } 但是我们的匿名函数除了一个return语句，没有其他语句。imageOfSize中的匿名函数由多个语句组成，但imageOfSize调用本身仍然只是一个Swift语句。我们可以省略关键字return（我们也可以省略剩余的return，但我不想这样做）。
Closure Setting a Captured Variable 闭包通过其捕捉环境的能力所获得的力量甚至比到目前为止所展示的还要大。如果闭包能够捕获一个自身外部变量的引用，并且该变量是可设置的，则闭包可以设置该变量：
func pass100(_ f: (Int) -&amp;gt; ()) {  f(100) }  var x = 0 print(x) // 0 func setX(newX: Int) {  x = newX }  pass100(setX) print(x) // 100 在上面的代码中，因为传入到pass100中的函数setX包含了x，不仅包含它，而且能够捕获它，并且修改了x的值。函数pass100函数能够像直接调用setX一样轻松地设置x。
Closure Preserving Captured Environment 当一个闭包捕获它所在的环境，即使其它什么都不做，它也会保留该环境。这是一个让你大吃一惊的例子：一个修改函数的函数：
func countAdder(_ f: @escaping () -&amp;gt; ()) -&amp;gt; () -&amp;gt; () {  var ct = 0  return {  ct = ct &#43; 1  print(&amp;#34;count is \(ct)&amp;#34;)  f()  } } 上面的函数countAdder接受一个函数参数（使用@escaping标记），并且返回一个函数。它返回的函数调用它接收的函数参数，并做了额外工作：它增加一个变量并报告结果。所以现在试着猜测当我们运行这段代码时会发生什么：
func greet() {  print(&amp;#34;howdy&amp;#34;) }  let countedGreet = countAdder(greet) countedGreet() // count is 1  countedGreet() // count is 2  countedGreet() // count is 3 函数countAdder返回一个新函数，我们将其命名为countedGreet。然后调用countedGreet 函数三次。以下是控制台中打印的内容：
count is 1 howdy count is 2 howdy count is 3 howdy 显然，countAdder已经为传递给它的函数添加了报告调用次数的能力。维持这个计数的变量到底在哪里？在countAdder中，ct是一个局部变量，它并未声明在匿名函数内部，这是故意的。如果它是在匿名函数中声明的，那么每次调用countedGreet时ct将被设置为0。
相反ct声明在匿名函数外，ct被初始化为0一次，然后被匿名函数捕获。这个变量作为countedGreet环境的一部分被保存下来&amp;ndash;它在countedGreet之外的某个神秘的环境保护世界中，所以每次countedGreet被调用时它都能被递增。
Escaping Closures 如果作为值传递的函数将被保存供以后执行，而不是直接调用，那么它是一个随时间推移捕获并保存其环境的闭包。这样的闭包被称为逃逸闭包(escaping closure)。
在某些场景下，函数的类型必须标记为escaping。编译器会检测违反这个规则的情况，所以如果你觉得对于是否需要加escaping有所疑惑，不用担心，只要让编译器检查并添加就可以了。
下面函数是合法的，因为**它接受一个函数作为参数，并且在函数体内直接调用了这个函数**：
func funcCaller(f: () -&amp;gt; ()) {  f() } 而下面这个函数也是合法的，即使它返回一个稍后执行的函数，因为**它也是在函数内部创建了那个匿名函数**。它返回的函数是一个逃逸闭包，但函数返回值的类型不必标记为@escaping：
func funcMaker() -&amp;gt; () -&amp;gt; () {  return {  print(&amp;#34;hello world&amp;#34;)  } } 但是，下面的函数是非法的。它接受了一个函数参数，并且立即返回了这个函数供后续执行：
func funcPasser(f: () -&amp;gt; ()) -&amp;gt; () -&amp;gt; () { // compile error  return f } 解决的方案是将函数参数标记为@escaping，编译器也会提醒我们需要这样做：
func funcPasser(f: @escaping () -&amp;gt; ()) -&amp;gt; () -&amp;gt; () {  return f } 逃逸闭包的第二个特点是当在函数体内引用self的属性或方法时，编译器会坚持需要明确地使用self。那是因为这样的引用捕获了self，编译器希望通过使用self来承认这个事实：
let f1 = funcPasser {  print(view.bounds) // compile error, because self.view is implied } let f2 = funcPasser {  print(self.view.bounds) // ok } Capture Lists 有时，可能希望一个函数引用自身外部的变量，只是为了获取其值，但不捕获该变量。Swift提供了一种巧妙的语法来做到这一点，但这种方式**仅限于函数是匿名函数时**。在匿名函数体的开头，放置方括号，其中包含对外部环境中变量的引用的逗号分隔列表，这称为捕获列表。
如果你有一个捕获列表，你必须在它后面加上关键字in。如果已经存在in表达式，则捕获列表位于任何参数名称之前。
捕获列表就好像这些值已作为参数而不是通过闭包捕获传递给匿名函数一样。它的行为就像是用let声明的参数一样，如下所示：
var x1 = 0 let f1: () -&amp;gt; () = {  print(x1) } f1() // 0  x1 = 1  f1() // 1 在上面的函数中，由于捕获到了变量的值，那么打印的值分别是0和1。而在下面的代码中，因为添加了捕获列表，下面的代码执行后两次打印的值均为0:
var x1 = 0 let f1: () -&amp;gt; () = { [x] in  print(x) } f1() // 0  x1 = 1  f1() // 0 因为使用了捕获列表，f在声明时已经将变量x的值捕获为0。实际上，x的行为类似于传递给f的普通参数，它是一个常量。另一种理解方式是，如果f尝试设置x的值，编译器会报错：“无法设置x值，因为x是不可变的捕获。”
对捕获列表中的值重命名也是合法的。捕获列表可以使用[y=x1]来重命名捕获的值，这种方式好像将x1作为参数传递给匿名函数，但现在该参数的名称为y。当原始名称有问题时，或者当要传入的值是需要在赋值的时候被计算时，这种方式很有用：
self.undoer.registerUndo(withTarget: self) { [oldCenter = self.center] myself in  myself.setCenterUndoably(oldCenter) } 作为参数传递给registerUndo的匿名函数是一个逃逸函数。捕获列表声明了一个常量oldCenter并将其值设置为self.center。因此，self.center的值在调用registerUndo时就立即进行求值，而不是稍后在调用匿名函数本身时进行求值（此时 self.center的值可能已更改）。
let f2 = funcPasser {  print(self.view.bounds) } 捕获列表的另一个用途是解决在逃逸闭包中需要明确使用self关键字的要求。下面的代码中，需要明确地使用self，因为这是一个逃逸闭包。但是很多人不喜欢明确地使用self，如果这个匿名函数多次隐含地使用self，则可能需要多次明确地使用self。
从Swift 5.3开始，有一个风格上选择方案：如果你把self放在捕获列表中，这会满足编译器的要求，并且不必将self写为函数体中的隐式目标：
let f2 = funcPasser { [self] in  print(view.bounds) // ok  } curried function 当一个函数返回一个带参数的函数，那么它被称为curried函数（以计算机科学家Haskell Curry命名）。下面是一个简单的curried函数：
func makeRoundedRectangleMaker(_ sz: CGSize) -&amp;gt; (CGFloat) -&amp;gt; UIImage {  return { r in  imageOfSize(sz) {  let p = UIBezierPath(roundedRect: CGRect(origin: CGPoint.zero, size: sz), cornerRadius: r)  p.stroke()  }  } } Function References and Selectors 如果想通过名字引用一个函数（或传递给另外一个函数作为参数），通常可以使用函数的bare name（裸名）。函数的bare name指的是函数的名字（只包括函数名字不包含其它）。下面代码中whatToAnimate和whatToDoLater都是函数的bare name：
func whatToAnimate() {  debugPrint(&amp;#34;animations&amp;#34;) }  func whatToDoLater(finished: Bool) {  debugPrint(&amp;#34;finished: \(finished)&amp;#34;) }  UIView.animate(withDuration: 0.4, animations: whatToAnimate, completion: whatToDoLater) 在上面的代码中whatToAnimate和whatToDoLater也是函数的引用。它只由函数的名字组成，也就是func关键字后，参数列表括号前的那个函数名。没有圆括号表明这是一个引用，而不是一个调用。
在没有歧义的情况下，使用bare name作为函数的引用是合法的。上面的代码中，在这个特定的上下文中只有一个叫whatToDoLater的函数，因此能在一个参数类型已知的函数调用中使用bare name作为参数。
我们既可以将函数作为参数传递，也可以将函数赋值给一个变量或者常量。下面的代码中，定义了两个相同名字的函数，一个接受参数，一个不接受参数，直接使用bark可能会产生歧义：
class Dog {  func bark() {  debugPrint(&amp;#34;woof&amp;#34;)  }   func bark(_ loudly: Bool) {  if loudly {  debugPrint(&amp;#34;WOOF&amp;#34;)  } else {  bark()  }  }   func test() {  let barkFunction = bark // compile error   } } 上面的代码将会出现编译错误，因为同时存在两个名为bark的函数，此时编译器不清楚到底要引用哪个。为了解决这个问题，Swift提供了一种表示法，它可以更精确地引用函数，标注包含两个部分：
  full name:此处翻译为全名，对于有参数的函数的全名包括函数的名字，一对圆括号，以及外部参数列表，其中**外部参数列表使用冒号(没有逗号或空格)**。如果外部参数被suppressed（即定义的时候使用下划线），则使用下划线代替。对于没有参数的函数的全名就是它的bare name。
  签名: 一个函数的签名可以用关键字as作用到其bare name或full name上。
  例如，函数func say(_ s:String, times:Int) {...}可以使用全名say(_:times:)来标注，也可使用bare name和签名:say as (String, Int) -&amp;gt; ()来标注。
在上面的代码中，如果使用let barkFunction = bark(_:) 编译器就不会报错，因为已经指定了函数bark为接受一个参数的那个。
但如果要引用无参数的bark函数，因为无参的那个函数的裸名和全名均为bark（不包括圆括号，无参数的函数加上圆括号就是函数调用了），直接使用仍然会报错，因为编译器无法区分要引用哪个函数，此时应该使用as和函数签名：
class Dog {  func bark() {  debugPrint(&amp;#34;woof&amp;#34;)  }   func bark(_ loudly: Bool) {  if loudly {  debugPrint(&amp;#34;WOOF&amp;#34;)  } else {  bark()  }  }   func test() {  let barkFunction = bark as () -&amp;gt; () // 使用函数签名  } } 下面的代码中，定义了三个bark函数，其中有两个都接受一个参数，并且外部参数名都被省略了。如果此时使用let barkFunction = bark(_:)仍然会出现编译错误，因为编译器无法确定要调用哪个bark，因为此时有两个带参数的bark，它们的fullname均为bark(_:)：
class Dog {  func bark() {  //  }   func bark(_ loudly: Bool) {  //  }   func bark(_ times: Int) {  //  }   func test() {  let barkFunction = bark(_:) // compile error  } } 此时需要使用as和函数签名才能确定到底要使用哪个bark，即let barkFunction = bark as (Int) -&amp;gt; ()转换为接受Int的那个bark，编译才不会报错。或者直接指定barkFunction为(Int) -&amp;gt; ()类型。
Function Reference Scope 在前面的代码中，在使用函数引用时，没有必要告知编译器函数是在哪定义的，这是因为函数定义和函数引用在同一个作用域内。也就是说，如果可以在不提供进一步信息的情况下调用该函数，就可以在不提供进一步信息的情况下形成函数引用。
函数引用可以提供关于函数在哪定义的进一步信息，而且有时必须这样做。这可以通过在函数引用前**加一个实例或类，然后后面紧接着点操作符来实现**。有些情况下，编译器会强制要求使用self来引用一个函数：
class Dog {  func bark() {  debugPrint(&amp;#34;bark&amp;#34;)  }   func bark(_ loudly: Bool) {  if loudly {  debugPrint(&amp;#34;WOOF&amp;#34;)  } else {  debugPrint(&amp;#34;woof&amp;#34;)  }  }   func test() {  let f = {  // 使用了self  return self.bark(_:) // self required here  }  // f是一个函数，无参数，但是返回一个函数  let tmpBark = f() // 执行函数，得到一个新的函数  tmpBark(false)  } }  let tmpDog = Dog() tmpDog.test() // woof 如果要形成对另一个类型实例方法的函数引用，可以有两个方法。如果当前有一个该类型的实例，可以**使用点操作符实现对该实例的引用**：
class Cat {  func purr() {  debugPrint(&amp;#34;purr&amp;#34;)  } }  class Dog {  let cat = Cat()   func test() {  let purrFunction = cat.purr  purrFunction()  } } class Test {  static var test = &amp;#34;test&amp;#34;   static func testFunc() {  //  }   class var name: String {  return &amp;#34;name&amp;#34;  }   class func nameFunc() {  //  }   func testNew() {  debugPrint(&amp;#34;testNew&amp;#34;)  } }  let test = Test() let test1 = test.testNew test1() 另一种可能的方式是使用**类型和点操作符来获取函数的引用，即使函数是实例方法也是适用的**。但是下面的代码需要使用函数签名来消除歧义。
class Cat {  func purr() {  debugPrint(&amp;#34;purr&amp;#34;)  } }  class Dog {  func bark() {  debugPrint(&amp;#34;bark&amp;#34;)  }   func test() {  let barkFunction = Dog.bark // legal but not necessary   let purrFunction = Cat.purr  } } 如果使用类型和点操作符来获取函数引用，并且需要借助函数签名来消除函数引用的歧义时，那么函数签名必须是描述实例方法的柯里化静态/类版本(the signature must describe the curried static/class version of the instance method)：
class Cat {  func purr() {  debugPrint(&amp;#34;purr&amp;#34;)  }   func purr(_ loudly: Bool) {  debugPrint(&amp;#34;loudly \(loudly)&amp;#34;)  } }  class Dog {  func test() {  let cat = Cat()  let purrFunc = Cat.purr as (Cat) -&amp;gt; () -&amp;gt; Void // 柯里版本，参数为类型，返回一个函数  debugPrint(purrFunc)  let tmpFunc = purrFunc(cat)  tmpFunc() // 调用purr方法  } } Selectors 在Objective-C中selector是一种方法引用。在iOS编程中，可能会调用一个Cocoa方法，这个方法需要一个selector作为它的某个参数。通常，此参数将命名为selector:或action:。
通常这样的Cocoa方法也需要提供一个target（一个对象的引用）。运行时可以将selector变成一个消息，并将该消息发送给这个target以调用该方法。
为了形成selector，需要构建一个代表方法的Objective-C字符串。这种方式是十分危险的，如果错误地构建了这个代表方法的字符串，那么向target发送消息时，因为target没有这样的方法，运行时将发现target不能处理这个消息，此时应用程序会crash，并向控制台打印unrecognized selector。
class ViewController: UIViewController {   @IBOutlet var button: UIButton!   func viewDidLoad() {   super.viewDidLoad()  // prepare to crash  self.button.addTarget(self, action: &amp;#34;buttonPressed&amp;#34;, for: .touchUpInside)  }   @objc func buttonPressed(_ sender: Any) {  debugPrint(&amp;#34;buttonPressed&amp;#34;)  }  } 在上面的代码中self.button是界面上的一个按钮，通过调用addTarget(action:for:)来设置按钮的响应事件，使得当按钮点击时可以调用buttonPressed方法。
但是，上面的方法字符串是错误的，因为buttonPressed不是Objective-C的方法字符串，正确的方法名称字符串应该是buttonPressed:，这样会导致按钮点击的时候发生崩溃。
如果不知道形成selector字符串的规则，或者即使知道，但输入时不注意犯了一个小错误，都可能导致出现unrecognized selector崩溃。人在输入时是很容易犯错，因此unrecognized selector崩溃历来在iOS程序员中极为常见。
Swift编译器在这方面并不容易出错，它提供了一种方法，即通过#selector(...)语法可以生成一个Objective-C的selector，括号里面的是函数的引用：
class ViewController: UIViewController {   @IBOutlet var button: UIButton!   func viewDidLoad() {  super.viewDidLoad()  self.button.addTargett(self, action: #selector(buttonPressed), for: .touchUpInside)  }   @objc func buttonPressed(_ sender: Any) {  debugPrint(&amp;#34;buttonPressed&amp;#34;)  }  } 上面的代码中使用#selector(...)时，编译器会做两件事情：
  编译器会检查函数引用是否合法，如果不合法则会出现编译错误。同时会检查这个函数是否暴露给Objective-C。为一个Objective-C看不到的方法形成一个selector是没有意义的，因为如果Objective-C试图调用这样一个方法，应用程序会崩溃。在Swift为了确保对Objective-C是可见的，该方法需要标记为@objc。
  如果使用#selector的代码能够编译，将保证将传递给此参数的实际选择器是正确的。手动写方法字符串可能会形成错误的选择器，但编译器不会，它所产生的selector不可能与方法不匹配，也不可能出现unrecognized selector崩溃。
  尽管十分少见，但在某些情况下，可能需要手动创建一个选择器。要做到这一点可以使用一个方法字符串，或者可以用字符串作为参数来实例化Selector类型：
Selector(&amp;#34;woohoo:&amp;#34;) 使用#selector(...)语法，仍然*可能通过向错误的target发送action信息而发送崩溃*。在前面的例子中，如果把addTarget调用的第一个参数self改为self.button，将会在运行时以unrecognized selector崩溃。因为buttonPressed方法是在ViewController中声明的，而不是在UIButton类型中声明的。
Variables and Simple Types 变量是一个命名的shoebox，其包含的值必须是单一定义好的类型。每个变量都必须明确且正式地声明。要将值放入shoebox中，使变量名称引用该值，你可以将值赋值给变量。这个变量名成为对该值的引用。
一个变量不仅给它所指对象一个名字，它还根据声明的位置赋予其所指对象特定的范围（可见性）和生命周期。变量的作用域和生命周期分为三个层次：全局变量，属性，局部变量。
全局变量声明在Swift文件顶部，它的生命周期和所在的文件一样长。一个全局变量默认（默认是internal访问权限）在它声明所在module任何地方都是可见的，这就是全局的意思。它对同一文件中的所有代码都是可见的，因为它处于最高级别。
此外，默认情况下全局变量对于**同一模块中任何其他文件中的所有代码也都是可见的**，因为同一模块中的Swift文件可以自动看到彼此，所以也可以看到彼此顶层声明的全局变量：
// File1: let globalVariable = &amp;#34;global&amp;#34;  class Dog {  func debugPrintGlobal() {  debugPrint(globalVariable)  } }  // File2:  class Cat {  func debugPrintGlobal() {  debugPrint(globalVariable)  } } 属性是在对象类型声明（枚举、结构或类）的顶层声明的变量。有两种类型的属性，一种的是实例属性，另一种是类属性（或称为静态属性）。如果属性声明时未加static或class关键字，就是实例属性。实例属性的值对于每个实例都可以是不同的，它的生命周期和实例的生命周期相同。
如果一个属性在声明的时候加上static或者class，那就是类属性（或称为静态属性），它的生命周期和该对象类型的生命周期相同。
属性只能通过对象才能看到，对象的方法能够直接看到属性，在方法内部可以使用self.x这种方式访问实例属性。默认情况下，实例属性对于其它代码也是可见的，前提是要有这个实例的引用。同样地，默认情况下，一个静态/类属性对其他可以看到这个对象类型的代码也是可见的：
// File1:  class Dog {  static let staticProperty = &amp;#34;staticProperty&amp;#34;  let instanceProperty = &amp;#34;instanceProperty&amp;#34;   func debugPrintInstanceProperty() {  debugPrint(self.instanceProperty)  }  }  // File2:  class Cat {  func debugPrintDogStaticProperty() {  debugPrint(Dog.staticProperty)  }   func debugPrintDogInstanceProperty() {  let dog = Dog()  debugPrint(dog.instanceProperty)  }  } 局部变量是指声明在花括号内部的变量，它的生命周期与包含它的花括号一样长。当程序执行到局部变量声明的范围时，局部变量才会真正生成，当程序执行离开这个范围时，局部变量就会自动消失。
有时，局部变量也被称为自动变量，以表示它们会自动出现和消失。一个局部变量只能被同一作用域中的后续代码看到（也包括同一作用域中后续更深层次的作用域）。
Variable Declaration 变量声明时使用关键字let或者var。使用let声明的是常量，常量的意思是*当第一次被赋值之后就不再允许被改变*。使用var声明的变量是真正可变的，它的值可以通过后续赋值来改变。
在Swift中**变量声明时没有强制初始化，即使用let声明也一样**。对于let x : Int这样的声明是完全合法的。可以后面再给这个变量分配一个初始值，因为这个特殊的变量是一个常量，所以一旦有了初始值，那么这个初始值将是它以后的唯一值，不能再被改变。
声明一个变量而没有给定类型是不合法的，变量必须从一开始就具有类型，并且永远不能更改该类型。用var声明的变量可以通过后续赋值改变其值，但新值必须符合变量的固定类型。
显式声明类型 在声明中的变量名称之后，添加一个冒号和类型的名称，就是显式类型声明：
var x : Int 隐式声明类型 如果将变量初始化为声明的一部分，并且没有提供明确的类型，Swift会根据它被初始化的值来推断其类型。
var x = 1 // and now x is an Int 完全可以一次性显式声明变量的类型并为其分配初始值：
var x : Int = 1 在上面的代码中，显式的类型声明是多余的，因为类型可以从初始值推断出来。有些情况，即使在有初始值的情况下声明一个类型不是多余的：
let value : Float = 2.0 //字面量2.0默认是Double类型 有时，除非明确地告诉编译器，否则编译器完全不知道初始值的类型：
var opts = [.autoreverse, .repeat] // compile error: Reference to member &amp;#39;autoreverse&amp;#39; cannot be resolved without a contextual type let opts : UIView.AnimationOptions = [.autoreverse, .repeat] 即使编译器可以从变量的初始值正确推断出变量的类型，这种推断也是需要时间的。可以通过为变量声明提供显式类型来减少编译时间。
正如之前所说的，即使变量是常量，也不必在声明变量时对其进行初始化。下面这样写是合法的：
let x : Int 现在x是一个空shoebox——没有初始值的Int变量。可以稍后为该变量分配一个初始值。由于这个特定的变量是一个常量，从赋值那刻起，该初始值将是它的唯一值，之后不能被改变。
对于属性来说，先声明后初始化是很常见的，因为属性的初始化可以通过对象类型的初始化函数来实现。但对于局部变量来说，通常是声明的时候同时初始化。
当局部变量遇到需要conditional initialization时，也可以先声明后初始化。这是因为，有时在进行某种条件测试之前，并不知道某个变量的初始值。因为变量只能被声明一次，所以它必须提前声明，之后再进行初始化：
let timed: Bool if val == 1 {  timed = true } else {  timed = false } 如果一个变量的地址被当作参数传递给一个函数时，这个变量必须在传递之前先声明并且在传递之前已经被初始化，也就是说即使初始化值是假的占位符也必须先给一个初始值，否则会出现编译错误：
var r: CGFloat = 0 var g: CGFloat = 0 var b: CGFloat = 0 var a: CGFloat = 0 c.getRed(&amp;amp;r, green: &amp;amp;g, blue: &amp;amp;b, alpha: &amp;amp;a) 在上面的代码中，4个CGFloat当传入到getRed中后，它们的值会被改变。而给定的初始值只是暂时的占位符，以满足编译器的要求。
需要注意的是：传入到函数的普通参数，也必须先初始化，否则编译器会报错：
func oneParameter(test: String) {  debugPrint(test) }  var tt1:String  oneParameter(test: tt1) // Variable &amp;#39;tt1&amp;#39; used before being initialized   var tt2:String = &amp;#34;name&amp;#34;  oneParameter(test: tt2) 对于传入到函数中以inout修饰的形参对应的实参，必须使用var声明，并且必须先初始化：
func testMain(test: inout String) {  test = &amp;#34;name&amp;#34;  debugPrint(test) }  var newTest :String testMain(test: &amp;amp;newTest) // Variable &amp;#39;newTest&amp;#39; passed by reference before being initialized   var newTest1 :String = &amp;#34;name&amp;#34; testMain(test: &amp;amp;newTest1) 极少数情况下，会遇到这样一种情况：调用一个立即返回一个值的Cocoa方法，然后在传递给这个方法的函数参数中又要使用这个返回值。Cocoa有一个UIApplication实例方法是下面这样声明的：
func beginBackgroundTask(expirationHandler handler: (() -&amp;gt; Void)? = nil) -&amp;gt; UIBackgroundTaskIdentifier 上面的beginBackgroundTask(expirationHandler:)返回一个UIBackgroundTaskIdentifier对象，然后会在expirationHandler函数中使用这个对象。Swift的安全规则不允许在一条语句中声明变量，同时又在声明语句中的匿名函数中使用它：
let bti = UIApplication.shared.beginBackgroundTask {  UIApplication.shared.endBackgroundTask(bti) } // error: variable used within its own initial value 因此，需要提前声明变量。在上面的代码中，如果只是提前声明变量，依然会有问题，编译时会报variable captured by a closure before being initialized：
var bti: UIBackgroundTaskIdentifier bti = UIApplication.shared.beginBackgroundTask {  UIApplication.shared.endBackgroundTask(bti) } // error: variable captured by a closure before being initialized 一种解决方案是提前声明变量，并且声明时给变量一个假的初始值作为占位符。如下所示，给了变量bti一个假的初始值.invalid用来占位：
var bti: UIBackgroundTaskIdentifier = .invalid bti = UIApplication.shared.beginBackgroundTask {  UIApplication.shared.endBackgroundTask(bti) } 这里真正的问题是beginBackgroundTask相当古老了。更现代的方法可能会将返回值直接传递给函数参数。Cocoa的UIAction初始化程序init(title:handler:)就是一个很好的例子：
let myAction = UIAction(title: &amp;#34;Hello&amp;#34;) { action in  print(action) } 在上面的代码中，action就是myAction，因此匿名函数体中可以直接引用action，而不使用myAction（使用myAction是非法的）。（这种方法还可以防止可能的循环引用）。
Computed Variable Initialization 有时需要先执行一些代码去才能获得变量的初始值，一个简洁的解决方案是定义和调用匿名函数来进行初始化，这种方式称为define-and-call initializer。下面代码中定义了一个匿名函数并立即执行来初始化常量timed：
let val = 0 let timed: Bool = {  if val == 1 {  return true  } else {  return false  } }() 当一个实例属性也需要执行一些代码去获得初始值时，也可以使用define-and-call initializer方法进行初始化。下面的cellBackgroundImage属性需要用到多次，但初始化时需要执行一些其它代码，因此通过定义和调用一个匿名函数来初始化这个属性：
class RootViewController: UITableViewController {  let cellBackgroundImage: UIImage = {  return imageOfSize(CGSize(width: 320, height: 44)) {  // ... drawing goes here ...  }  }() } 你可能会好奇，与其使用define-and-call initializer，为什么不直接定义一个实例方法来初始化实例属性。因为定义一个实例方法来初始化实例属性是非法的，会出现编译错误：
class RootViewController: UITableViewController {  let cellBackgroundImage: UIImage = self.makeTheImage() // compile error    func makeTheImage() -&amp;gt; UIImage {  return imageOfSize(CGSize(width: 320, height: 44)) {  // ... drawing goes here ...  }  }  } 这是因为**实例属性声明初始化时，实例尚未生成**。因此，不能在属性声明的初始化器中引用自己。定义和调用匿名函数是合法的，但需要注意的是定义和调用匿名函数仍然不能在函数体中引用self，否则也会出现编译错误，如果需要在函数体中使用self，需要将属性声明为lazy。
Computed Variables 除了正常的存储变量，Swift中的变量还可以是计算的。这意味着变量不是一个简单值，而是包含计算函数。计算变量中包括setter和getter函数，setter函数在变量被赋值自动调用，getter函数在变量被引用时被自动调用:
var now: String { // ①  get { // ②   return Date().description // ③  }  set { // ④  debugPrint(newValue) // ⑤  } }  变量必须使用var声明（不能使用let），同时类型必须显式声明，类型后面紧跟花括号。 其中的getter函数被称为get。getter函数没有正式的函数声明，get这个词后面紧跟着函数体。 其中的getter函数必须返回一个与该变量类型相同的值。从Swift 5.1开始，当getter只有一个单一语句时，省略关键字return是合法的。 其中的setter函数被称为set。setter函数也没有正式的函数声明，set这个词后面紧跟着函数体。 其中setter函数的行为就像接受一个参数的函数。默认情况下，该参数以newValue这个名字进入setter函数体中。  这里有一些代码说明了计算变量的使用。对待它与任何其它变量没有任何不同。如果要赋值给变量，能够直接赋值给它；如果要使用变量，能够直接使用它。但是，在幕后都是调用了setter和getter函数。
now = &amp;#34;Howdy&amp;#34; // Howdy print(now) // 2022-08-07 04:03:21 &#43;0000  上面代码中赋值给now时，set将被自动调用，参数就是将要赋值的值。在上面的代码就是Howdy，该值作为 newValue到达set函数。 获取now的值时，get将被自动调用。  对于set函数来说，默认的参数可以不是newValue。如果需要指定一个不同的名称，把新名字放在set后面的括号里就可以，下面就是用新名字val代替默认的newValue：
var nowTest: String = &amp;#34;first&amp;#34; // 需要先初始化，否则报错 var now: String {  get {  &amp;#34;test&amp;#34;  }  set(val) {  nowTest = val  } } 如果setter函数省略，那么这个计算变量就成为了一个只读变量，等同于一个let常量，一旦试图去改变这个变量的值就会出现编译错误。即使只有一个get函数，计算变量声明的时候也必须使用var。
计算变量必须有一个getter函数。如果计算变量中没有setter函数，get这个词和它后面的花括号可以省略。下面是一个合法的只读计算变量的声明：
var now: String {  Date().description } Computed Properties 在实际的编程中，对于计算变量的使用场景几乎都是实例属性。当一个值在每次需要的时候都可以很容易地计算时，将其表达为一个只读的计算变量往往更简单，实际上这是对一个较长表达式的速记法：
var mp: MPMusicPlayerController {  MPMusicPlayerController.systemMusicPlayer } var nowPlayingItem: MPMediaItem? {  self.mp.nowPlayingItem } 一个计算变量的getter函数可以封装多行代码，其实质是把一个方法变成了一个属性。下面的例子是从xml文件中提取作者信息，本可以将其声明为方法func authorOfItem() -&amp;gt; String?，但方法表达了一个过程，而计算属性则能更直观地描述：
var authorOfItem: String? {  guard let authorNodes = self.extensionElements(withXMLNamespace: &amp;#34;http://www.tidbits.com/dummy&amp;#34;, elementName: &amp;#34;app_author_name&amp;#34;) else {  return nil  }  guard let authorNode = authorNodes.last as? FPExtensionNode else {  return nil  }  return authorNode.stringValue } 一个计算变量可以位于一个或多个存储变量的前面，充当这些存储变量的设置和获取时的守门员。通常，一个计算变量由一个私有的存储变量来支持：
private var _pp: Int = 0 var pp: Int {  get {  self._pp  }  set {  self._pp = max(min(newValue, 5), 0)  } } 一个实例的计算属性getter函数或setter函数可以引用其他实例成员。这很重要，因为一般来说，存储属性的初始化器不能这样做。对于一个计算的属性来说，它是合法的，因为getter和setter函数是在实例实际存在之前不会被调用。
Property Wrappers 如果我们有几个存储立面的计算属性有效地做了同样的事情，那么我们最终会有大量的重复代码。想象一下，像上一节中那样，用一个钳制的setter实现多个Int属性。如果能把这些共同的功能移到一个地方就更好了。我们可以用一个属性包装器来实现。
一个属性包装器被声明为一个标有@propertyWrapper属性的类型，并且必须有一个wrappedValue的计算属性。下面是一个实现&amp;quot;钳制&amp;quot;模式的属性包装器。
@propertyWrapper struct Clamped {  private var _i: Int = 0  var wrappedValue: Int {  get {  self._i  }  set {   self._i = Swift.max(Swift.min(newValue, 5), 0)  }  } } 结果是我们可以声明一个用自定义属性标记的计算属性，该属性的名称与该结构 (@Clamped) 相同，没有getter或setter：
@Clamped var p 上面的属性p不需要被初始化，因为它是一个计算属性，它也不需要getter或setter，实际上它都不需要类型声明，因为因为Clamped结构的WrappedValue计算属性提供了类型。
Setter Observers 计算变量并不经常需要作为一个存储变量的立面。这是因为Swift有另一个功能，可以让你在存储变量的setter中注入setter observers功能。setter observers是在设置存储变量之前和之后调用的函数，可以有一个willSet函数，或一个didSet函数，或两者均有：
var s = &amp;#34;whatever&amp;#34; { // ①  willSet { // ②  debugPrint(newValue) // ③  }  didSet { // ④  debugPrint(oldValue) // ⑤  // self.s = &amp;#34;something else&amp;#34;  } }   变量必须使用var声明，不能使用let声明，并且可以被赋予一个初始值。
  如果willSet函数存在的话，就是单词willSet后面紧跟着函数体。当其他代码设置该变量时，在该变量实际收到其新值之前willSet函数被调用。
  默认情况下，willSet函数接受即将设置的新值，这个新值的名字是newValue。也可以通过在willSet后面的括号里写一个不同的名字来自定义接受到的新值名字。旧值仍然在存储变量中，willSet函数中依然可以访问旧值。
  如果在willSet中将存储变量设置为不同的值时，不会生效：
var newStr: String = &amp;#34;new&amp;#34; {  willSet {  debugPrint(newValue)  newStr = &amp;#34;test&amp;#34;  } }  newStr = &amp;#34;name&amp;#34; debugPrint(newStr) // name // name   如果didSet函数存在的话，就是didSet这个词后面紧跟着函数体。当其他代码设置该变量时，在该变量实际收到其新值之后被调用。
  默认情况下，didSet函数接收旧的值，名字为oldValue，此时新值已经完成替换。可以通过在didSet后面的括号里写一个不同的名字来自定义接受到的旧值名字。
var now1: String = &amp;#34;now1&amp;#34; {  willSet(val) {  debugPrint(now1)  debugPrint(val)  }  didSet(val) {  debugPrint(val)  debugPrint(now1)  } }  debugPrint(now1 = &amp;#34;133&amp;#34;) //&amp;#34;now1&amp;#34; //&amp;#34;133&amp;#34; //&amp;#34;now1&amp;#34; //&amp;#34;133&amp;#34;   新的值已经在存储的变量中，didSet函数中可以访问新值。此外，在didSet函数中将存储变量设置为不同的值也是合法的，但不会再调用Setter Observers。
var newStr: String = &amp;#34;new&amp;#34; {  willSet {  debugPrint(newValue)  newStr = &amp;#34;test&amp;#34;  }  didSet {  newStr = &amp;#34;dddd&amp;#34;  } }  newStr = &amp;#34;name&amp;#34; debugPrint(newStr) // name // dddd   需要特别注意的是，当**存储变量初始化时或didSet函数中再次改变存储变量的值时，不会调用setter observers函数**，否则会产生无限循环。
在实际的iOS编程中，你可能想要可见的接口反应你的对象的状态。一个setter观察器是一种简单而强大的方式，可以使接口与一个属性同步。
在下面这个例子中，我们有一个视图类的实例属性，决定了视图应该被旋转多少。每次这个属性发生变化时，我们都会改变界面来反映它，即设置self.transform使视图被旋转相应的角度：
var angle: CGFloat = 0 {  didSet { // modify interface to match   self.transform = CGAffineTransform(rotationAngle: self.angle)  } } 计算变量或者属性不能有setter observers，因为它已经有了setter函数，任何在设置过程中需要发生的额外事情都可以直接写入setter函数中。但一个被属性包装器包裹的计算变量可以有setter observers。
Lazy Initialization 如果一个存储变量声明的时候分配了一个初始值，并且它使用了Lazy Initialization（懒初始化），那么在运行代码访问该变量的值之前，初始值实际上还不会有。在Swift中，有三种类型的变量可以被懒初始化Lazy Initialization。
  全局变量。全局变量是自动Lazy Initialization的，一个全局变量的初始化在其他代码首次引用该全局变量时才会发生，这种初始化只会执行一次，同时又是线程安全的。
  静态属性。静态属性也是自动的Lazy Initialization的，它的行为和全局变量完全一样，而且原因也基本相同。所以在Swift中类属性不能再加lazy关键字。
  实例属性默认不是lazy的，但可以在声明的时候显式加上关键字lazy。此时，这个属性必须使用var来声明而不能用let。如果没有任何代码获取属性的值，属性的初始化器可能永远不会执行。
  从Swift 5.5开始，局部变量可以使用lazy var声明了。
  如果您的代码从不引用延迟初始化的变量，则其初始化器永远不会运行；显然，如果初始值的生成成本可能很高，那么这很有用，因此你希望避免生成它，除非确实需要它。
如果对一个懒惰初始化变量的第一个引用重新设置了该变量，怎么办？对于全局变量或静态属性，初始值会被计算，然后立即被新设置的值所取代。下面的代码执行后，控制台打印了firstStatic和secondStatic：
struct Assist {  var value: String   init(value: String) {  self.value = value  debugPrint(self.value)  } }  class NewTest {  static var staticTest = Assist(value: &amp;#34;firstStatic&amp;#34;)  func changeTest() {  self.test = Assist(value: &amp;#34;secondTime&amp;#34;)  } } NewTest.staticTest = Assist(value: &amp;#34;secondStatic&amp;#34;) // firstStatic // secondStatic 但是对于懒加载的实例属性或局部变量的初始化器将永远不会赋初始值，如果该变量在被获取之前被重新设置。下面的代码执行后，控制台只打印了一个secondTime：
struct Assist {  var value: String   init(value: String) {  self.value = value  debugPrint(self.value)  } }  class NewTest {  lazy var test = Assist(value: &amp;#34;firstTime&amp;#34;)  func changeTest() {  self.test = Assist(value: &amp;#34;secondTime&amp;#34;)  } } NewTest().changeTest() // secondTime Singleton Lazy Initialization常用于实现单例。单例是一种设计模式，所有的代码都能够访问某个类的单一共享实例。下面代码就是一个简单的单例实现：
class MyClass {  static let shared = MyClass()  private init() {  //  } } 在其它代码第一次使用MyClass.shared前，单例都不会被创建。只要单例创建成功后，无论其它代码多少次使用MyClass.shared，返回的实例总是同一个实例(如果这是一个计算的只读属性，其getter调用MyClass()并返回该实例，则不会返回同一个实例)。
通常，我们希望实例属性是Lazy Initialization的。因为实例属性初始值的生成所花费的代价可能是昂贵的，所以除非确实需要用到的时候，一般会避免提前生成。但还有另一个原因更重要，懒初始化可以做普通初始化器不能做的事情。
最重要的是懒初始化可以访问实例本身，而正常的初始化器是不能这样做的，因为在正常初始化器需要运行的时候，实例尚未生成。在下面的代码中，如果arrow属性不声明为lazy，将会出现编译错误：
class MyView: UIView {  lazy var arrow = self.arrowImage() // legal  func arrowImage() -&amp;gt; UIImage {  // ... big image-generating code goes here ...  } } 一个常见的场景是定义和调用匿名函数来初始化一个lazy的实例属性。一旦加上lazy，那么在这个匿名函数中是可以引用实例本身的：
class MyView: UIView {  lazy var prog: UIProgressView = {  let p = UIProgressView(progressViewStyle: .default)  p.alpha = 0.7  p.trackTintColor = UIColor.clear  p.progressTintColor = UIColor.black  p.frame = CGRect(x: 0, y: 0, width: self.view.bounds.size.width, height: 20) // legal   p.progress = 1.0  return p  }() } 因为不能将lazy加在let声明的属性上，所以不要让一个lazy的实例属性成为只读的。与自动lazy的全局变量和静态变量不同，标记为lazy的实例属性是线程不安全的。当在多线程环境中使用时，lazy的实例属性可能会导致多次初始化，甚至闪退。
没有lazy let实例属性，因此不能轻易地将lazy实例属性设置为只读。这是不幸的，因为有一些常见的情况会从这样的功能中受益。
假设我们想用一个helper属性来武装self，该属性持有一个Helper类的实例，需要一个对self的引用。我们还想让这个Helper实例在self的整个生命周期内持续存在。我们可以通过让helper成为一个let属性并在其声明中初始化它来执行这一规则。
但是我们不能把self传递给Helper的初始化器，因为我们不能在属性声明中引用self。我们可以通过声明helper属性为lazy来解决这个问题。但问题是，我们必须使用var来声明helper，也就是说这个helper是可能被其他代码改变。当然，我们会尽量不让它发生，但问题是，lazy var这样的表达方式无法执行所需的策略。
Built-In Simple Types 每一个变量和每一个字面量都必须有一个类型。Swift内置的简单类型有Bool,Numbers，String，Character，Range，Tuple等。
与许多计算机语言不同，Swift中没有任何其它东西能被隐含地转换为Bool。例如，在C语言中，布尔值实际上是一个数字，0代表false，非0代表true。而在Swift中，只有false是false，true为true。
一个常见的情况：一个存储在某个var变量中的Bool，我们想反转它的值。即如果它是false的就变成true，如果它是true就变成false。
v.isUserInteractionEnabled = !v.isUserInteractionEnabled 上面的方式很麻烦，也容易忘记加取非符号!。有一个更简单的方法，即在Bool变量上调用toggle方法。上面的代码可以直接使用v.isUserInteractionEnabled.toggle()来实现。
v.isUserInteractionEnabled.toggle() 主要的数字类型是Int和Double，我们一般会使用这些类型。其它数字类型的存在主要是为了与C和Objective-C API兼容。
Int对象类型（一个结构体类型）表示Int.min和Int.max之间的一个整数。最小和最大限制的实际值取决于应用程序运行的平台和架构，它们并不是绝对的。
表示一个Int值最简单的方法是作为一个数字字头。一个没有小数点的数字默认为Int。内部下划线也是合法的这对长数字的可读性很有用。前导零是合法的，这对于在代码中填充和对齐数值很有用。
var x = 1000_000_000 var y = 00001 可以用二进制、八进制或十六进制的数字来写Int。要做到这一点，需要分别以0b、0o或0x开始。例如，0x10是十六进制表示，代表十进制的16。
负数以二进制补码格式存储。可以写一个看起来像底层存储的二进制字面量，但要使用它，必须通过Int(bitPattern:)初始化器。
在Swift中Double是一个结构体类型，表示一个精度约为15位小数的浮点数（使用64位存储）。含有小数点的数字默认为Double类型，并且Double类型的内部下划线和前导零是合法的。
Double字面量不能以小数点开头（与C和Objective-C不同）。如果要表示的值介于0和1之间，则以0开头。Double有静态属性Double.infinity和Double.pi，也有一个实例属性isZero。
可以使用科学计数法写Double字面量，字母e之后的所有内容都是10的指数。如果小数位为零，则可以省略小数点。例如，3e2 是300。
可以用十六进制数字写一个Double字面量。要这样做，以0x开头。也可以在使用指数法（同样，可以省略小数点，字母p后面的所有内容都是2的指数。 例如，0x10p2是十进制64。
Numeric coercion 强制转换是指从一种类型转换为另一种类型。Swift并没有显式的类型强制转换，但它使用实例化能够完成同样的效果。Swift的数字类型提供了初始化器，这些初始化器将另一个数字类型实例作为参数：
let i = 10 //an Int let x = Double(i) debugPrint(x) // 10.0, a Double let y = 3.8 //a Double let j = Int(y) debugPrint(j) // 3, an Int 当数值被赋值给变量或作为参数传递给函数时，Swift只对字面数字量进行隐式强制转换。下面这段代码是合法的，虽然10默认是Int类型，但因为它是字面数字量，因此能够隐式地转换为Double类型：
let d : Double = 10 但下面这段代码是不合法的，编译器会报错。因为所赋值的是一个不同类型的变量，而不是字面数字。问题的根源是i为Int实例，d是一个Double实例，二者不能自动进行隐式转换：
let i = 10 let d : Double = i 解决方案是在赋值或传递变量时进行显式强制：
let i = 10 let d : Double = Double(i) 当数字值被算术运算合并时，同样的规则也适用。Swift只对字面数字量进行隐式强制转换。例如，一个Int字面量与一个Double字面量运算时，Int字面量会隐式地转换为Double：
let x = 10/3.0 debugPrint(x) // 3.33333333333333 但是，如果想在算术运算中组合它们，则必须显式强制转换不同数字类型的变量，以保证它们是相同的类型。如下所示，因为i和n是不同类型的变量，会出现编译错误：
let i = 10 let n = 3.0 let x = i / n // compile error:Binary operator &amp;#39;/&amp;#39; cannot be applied to operands of type &amp;#39;Int&amp;#39; and &amp;#39;Double&amp;#39; 解决方案是将变量i的类型强制转换为Double：
let i = 10 let n = 3.0 let x = Double(i) / nn 这些规则是Swift强类型的结果。对于现代计算机语言来说，它们构成了对数值非常不寻常的处理，而且可能会在短时间内把你逼疯。
到目前为止，所举的例子很容易解决，但如果算术表达式较长，事情就会变得更加复杂，而且这个问题会因为其它数字类型的存在而变得更加复杂，这些数字类型是与Cocoa兼容所需要的。
如果只是在某个孤立的、抽象的世界中使用Swift，可能可以单独使用Int和Double完成所有必要的算术运算。但是，如果是在进行iOS编程，就会遇到Cocoa，它里面充满了其它的数字类型，而Swift有与每一种类型相匹配的类型。
除了Int，还有各种大小的有符号整数类型——Int8、Int16、Int32、Int64。加上无符号整数类型UInt以及 UInt8、UInt16、UInt32和UInt64。除了Double，还有低精度Float（32位存储，大约6或7个小数位精度）、更低精度的Float16、扩展精度Float80 和来自Core Graphics框架CGFloat。
在试图与C语言API对接时，也可能遇到C语言的数字类型。就Swift而言，这些类型只是类型别名，也就是说，它们是另一种类型的替代名称：CDouble（对应C语言的double）只是Double的另一个名字，CLong（C语言的long）是Int等等。
在各种Cocoa框架中会出现许多其它的数字类型的别名，例如，TimeInterval（Objective-C的NSTimeInterval）只是Double的一个类型别名。
let percentage = pt.x / s.bounds.size.width 不能在变量赋值、传递或组合时使用不同数值类型的值，必须将这些值显式强制为正确的类型。但现在事实证明，有时被Cocoa淹没了许多类型的数值。Cocoa通常会给你一个既不是Int也不是Double的数值——你不一定会意识到这一点，直到编译器阻止你因为某种类型不匹配而终止编译。然后，必须弄清楚哪个类型错误了，并将所有内容强制为同一类型。
这是一个应用程序中的一个典型示例。界面中的一个滑块是一个UISlider，它的minimumValue和maximumValue是Floats。在下面这段代码中s是UISlider，g是UIGestureRecognizer，我们尝试使用手势识别器将滑块的“拇指”移动到用户在滑块内点击的任何位置：
let pt = g.location(in:s) let percentage = pt.x / s.bounds.size.width let delta = percentage * (s.maximumValue - s.minimumValue) // compile error 上面代码发生编译错误，是因为pt.x的类型是CGFloat，s.bounds.size.width也是CGFloat，因此percentage的类型也是CGFloat，但是maximumValue和minimumValue是Float。所以percentage和(s.maximumValue - s.minimumValue)是不同类型。在Swift中Float和CGFloat是不同类型，必须显式强制转换：
let delta = Float(percentage) * (s.maximumValue - s.minimumValue) CGFloat是一个特殊的例子。它根据架构的位数（32位或64位）解析为Float或Double的大小。但这种区分已经不那么重要了，因为现在32位架构已经很少了，而且无论如何它都能有效地处理Doubles。
从Swift 5.5开始，Double和CGFloat是可以互换的。你可以在他们被期望的地方互换，而不需要强制转换，这使iOS程序员减少了相当多的不便。
var cfg : CGFloat = 1 var d1 : Double = 2 cfg = d1 // legal d1 = cfg &#43; d1 // legal let x2 = cfg &#43; d1 // x is inferred as Double 不是所有的数值型的能够强制转换为另一个类型。例如，Int8.max是127，如果尝试将&amp;gt;=128的字面量赋值给Int8是不合法的：
let tx: Int8 = 128 // Integer literal &amp;#39;128&amp;#39; overflows when stored into &amp;#39;Int8&amp;#39; 上面的例子中因为128是一个字面量，所以编译器能够判断溢出了。但进行类型强制转换时，编译器无法事先判断出来，所以在运行时才会报错：
let i : Int16 = 128 let i1 = Int8(i) // Swift/Integers.swift:3564: Fatal error: Not enough bits to represent the passed value 对于上面的情况，解决方案是调用一个可失败的初始化器。下面的代码虽然不会发生崩溃，但是需要测试转换是否成功：
let i : Int16 = 128 let i1 = Int8(exactly: i)  if let i = i1 {  debugPrint(i1) } 另外一种解决方案是使用clamping初始化器，这个初始化器总是会成功的，因为超出范围的值被迫落入范围内：
let i : Int16 = 128 let i1 = Int8(clamping: i)  debugPrint(i1) //127 当浮点类型（例如Double）被强制转换为整数类型时，小数点后的内容会先被丢弃，然后再尝试强制转换。Int8(127.9) 成功，因为127在界限内。
Arithmetic operations 从技术上讲，如果整数是无符号的，移位运算符执行逻辑移位，如果整数是有符号的，则执行算术移位。整数溢出或下溢——例如，两个Int值的和超过Int.max——是运行时错误（应用程序将崩溃）：
let i = Int.max - 2 let j = i &#43; 12/2 // crash 在某些情况下，我们可能想要强制此类操作成功，因此提供了特殊的上溢/下溢方法。这些方法返回一个元组，下面代码中over打印的值为true：
let i = Int.max - 2 let (j, over) = i.addingReportingOverflow(12/2) debugPrint(over) 上面的代码执行后，j的值变成了Int.min&#43;3，因为该值已从Int.max环绕到Int.min。如果不关心是否存在上溢/下溢，可以使用特殊的算术运算符来抑制错误：&amp;amp;&#43;、&amp;amp;-、&amp;amp;*。
经常希望将现有变量的值与另一个值进行算术组合，并将结果存储在同一个变量中。为此，您需要将变量声明为var：
var i = 1 i = i &#43; 7 实际上有个更简单的写法，提供了一次执行算术运算和赋值的运算符：
var i = 1 i &#43;= 7 速记（复合）赋值算术运算符有&#43;=, -=, *=, /=, %=, &amp;amp;=,|=, ^=, &amp;lt;&amp;lt;=, &amp;gt;&amp;gt;=。
Comparison 对于两个不同类型的整数，虽然他们不能在不能在算术运算中组合它们，但可以比较不同整数类型的值：
let i1: Int = 1 let i2: UInt8 = 2 let ok = i &amp;lt; i2 // true  let ok2 = i1 == i2 // false debugPrint(ok2) //false 由于计算机存储数字的方式，Double值的相等比较可能不会在您期望的地方成功。举一个经典的例子，将0.1加十次与0.1乘以10的结果不同：
let f2 = 0.1 var sum = 0.0 for _ in 0..&amp;lt;10 {  sum &#43;= f2 } let product = f2 * 10 let ok3 = sum == product // false debugPrint(ok3) //false 解决这类问题并不容易。通常的方法是检查两个值是否足够接近，但这引出了什么构成足够接近的问题。一个有用的公式是:
let ok = sum &amp;gt;= product.nextDown &amp;amp;&amp;amp; sum &amp;lt;= product.nextUp // true String 在Swift中，字符串String是结构体类型。表示字符串值的最简单方法是使用字面量，使用双引号分隔：
let greeting = &amp;#34;hello&amp;#34; Swift中的字符串是完全现代的，它使用Unicode编码，可以在字符串字面量中直接包含任何字符（如表情符号）。如果知道一个字符的Unicode码点，并且不嫌麻烦，可以使用\u{...}，需要注意的是在花括号的内容至多为八位十六进制数字：
let leftTripleArrow = &amp;#34;\u{21DA}&amp;#34; 该字符串中的反斜杠是转义字符。它的意思是，“我不是一个真正的反斜杠，表示下一个字符会得到特殊待遇。”各种不可打印和不明确的字符作为转义字符输入，最重要的是以下字符：
 \n：一个Unix换行符。 \t：制表符。 \&amp;quot;：引号（转义以表明这不是字符串文字的结尾）。 \\：反斜杠（因为单独的反斜杠是转义字符而转义）。  转义的引号和反斜线会很快使你的字符串字面意义变得难看和难以辨认。这个问题尤其出现在正则表达式模式等情况下。例如，模式\b\d\d\b（一个由两个数字组成的词）必须写成&amp;quot;\\b\d\d\b&amp;quot;。但是你可以在引号和反斜杠之前省略转义字符，用一个或多个哈希字符（#）包围你的字面，下面这些都是相同的字符串：
let pattold = &amp;#34;\\b\\d\\d\\b&amp;#34; let pattnew = #&amp;#34;\b\d\d\b&amp;#34;# // same thing let pattnew2 = ##&amp;#34;\b\d\d\b&amp;#34;## // same thing 这称为原始字符串字面量。缺点是，如果想在原始字符串字面量使用反斜杠作为转义字符，则必须在其后面使用与用于包围文字的相同数量的#字符。字符串#&amp;quot;hello\nthere&amp;quot;#不包含换行符(\n)，但#&amp;quot;hello\#nthere&amp;quot;#包含。
可以将包含换行符的字符串字面量输入为多行（而不是包含\n字符的单行表达式）。这称为多行字符串字面量。规则是：
 多行字符串文字必须在开始和结束处用三重双引号 (&amp;quot;&amp;quot;&amp;quot;) 分隔。 任何字符都不能跟在同一行的开头分隔符后面。 除了空格之外，其他任何字符都不能与结束分隔符出现在同一行。 关闭分隔符之前的最后一个隐式换行符会被忽略。 结束分隔符的缩进决定了文本行的缩进，它必须至少缩进到结束分隔符（完全空行除外）。  func ff() {  let s = &amp;#34;&amp;#34;&amp;#34; Line 1 Line 2 Line 3 &amp;#34;&amp;#34;&amp;#34; // ... } // &amp;#34;Line 1 \n Line 2 \nLine 3 &amp;#34; Range Range对象类型是一个结构体，代表一对端点。形成Range字面量的操作符有两个，提供一个开始值和一个结束值，在它们之间有一个Range操作符：
  ...闭range操作符：a...b意味着a到b的一切，包括b。
  ..&amp;lt;半开range操作符：a..&amp;lt;b意味着a到b的一切，但不包括b。
  在Range操作符两边添加空格是合法的，例如1...3或1 ... 3都是合法的。一个Range的端点的类型通常是某种数字，最常见的是整型。
如果结束值是一个负数，它必须用括号括起来或在操作符前面加上空格。let r = -1000 ... -1和let r = (-1000...-1)都是可以的。Range的常用场景是for ... in语句:
debugPrint(-1000...-1) // compile error: Ambiguous missing whitespace between unary and binary operators debugPrint(-1000 ... -1) debugPrint(1 ... 1000) for ix in 1...3 {  debugPrint(ix) // 1, then 2, then 3  } 在Swift中，没有反向的Range，即Range的起始值不能大于结束值。一旦出现这种情况，编译器不会报错，但运行的时候会发生崩溃。在实际的编程上，可以使用Range的reversed()方法来实现相同的效果：
for i in 1 ... -1 {  debugPrint(i) // 运行时发生崩溃 }  for ix in (1...3).reversed() {  debugPrint(ix) // 3，2，1 } 在实际编程中，可以使用Range的contains(_:)实例方法来测试一个值是否在给定的范围内。例如，可以测试某个数字是否在某个范围内：
let ix = 2 // ... an Int ... if (1...3).contains(ix) {  // ... } 如果只是想测试Range中是否包含某个数字，Range的端点数值可以为Double类型。下面的代码中，测试变量d是否在(0.1...0.9)中是可行的：
let d = 0.3 // ... a Double ... if (0.1...0.9).contains(d) {  debugPrint(&amp;#34;contains \(d)&amp;#34;) } // &amp;#34;contains 0.3&amp;#34; Range的另一个常见用途是对一个序列进行索引。下面是获取一个字符串的第二、第三和第四个字符的一种方法。如果把字符串转换为一个字符数组，可以用一个Int Range作为该数组的索引：
let s = &amp;#34;hello&amp;#34; let arr = Array(s) let result = arr[1...3] let s2 = String(result) // &amp;#34;ell&amp;#34; debugPrint(arr) // [&amp;#34;h&amp;#34;, &amp;#34;e&amp;#34;, &amp;#34;l&amp;#34;, &amp;#34;l&amp;#34;, &amp;#34;o&amp;#34;] debugPrint(s2) // &amp;#34;ell&amp;#34; 字符串本身是一个字符序列，所以可以使用Range来直接索引字符串，但是它必须是一个String.Index的Range，但是很难获取：
let s = &amp;#34;hello&amp;#34; let ix1 = s.index(s.startIndex, offsetBy:1) let ix2 = s.index(ix1, offsetBy: 2) let s2 = s[ix1...ix2] // &amp;#34;ell&amp;#34; 可以在Range字面常量上省略一个端点，形成一个部分Range。有三种部分Range表达式，对应于三种类型的Range结构，分别是省略前端点的的..&amp;lt;,省略前端点的...以及省略后端点的...:
let str = &amp;#34;hello&amp;#34; let range1 = str.startIndex..&amp;lt;str.endIndex // Range let range2 = ..&amp;lt;str.endIndex // PartialRangeUpTo let range3 = ...str.index(before: str.endIndex) // PartialRangeUpThrough let range4 = str.startIndex... // PartialRangeFrom  debugPrint(str) debugPrint(str[range1]) debugPrint(str[range2]) debugPrint(str[range3]) debugPrint(str[range4])  &amp;#34;hello&amp;#34; &amp;#34;hello&amp;#34; &amp;#34;hello&amp;#34; &amp;#34;hello&amp;#34; &amp;#34;hello&amp;#34; 如果需要将一个部分Range转换为一个Range，可以调用relative(to:)方法。但一般来说，不需要这样做，因为部分Range可以用在任何需要使用Range的地方：
let s = &amp;#34;hello&amp;#34; let ix2 = s.index(before: s.endIndex) let s2 = s[..&amp;lt;ix2] // &amp;#34;hell&amp;#34; debugPrint(s2) // &amp;#34;hell&amp;#34; debugPrint(s[s.startIndex..&amp;lt;s.endIndex]) //&amp;#34;hello&amp;#34; debugPrint((..&amp;lt;s.endIndex).relative(to: s) == s.startIndex ..&amp;lt; s.endIndex) // true 元组 元组是一个由多个值组成的轻量级自定义有序集合。作为一种类型，它的表达方式是用圆括号包围所含数值的类型，用逗号隔开。下面是一个元组变量的声明，其类型是一个Int和一个String：
var pair : (Int, String) 元组字面值也是以同样的方式表达，用圆括号包含值，每个值以逗号隔开。但这些值的类型也可以由编译器推断出来，无需显式声明：
var pair1 : (Int, String) = (1, &amp;#34;Two&amp;#34;) var pair2 = (1, &amp;#34;Two&amp;#34;) 元组是Swift语言特有的，与Cocoa和Objective-C不兼容。元组是解决一个函数只能返回一个值这个问题的好方法。元组是一个特殊的值，但在它里面包含了多个值，所以可以使用元组作为一个函数的返回类型以返回多个值。
元组也提供了很多便利性，可以一次同时赋值多个不同类型的变量，也可以一次同时声明和初始化多个不同类型的变量，如下所示：
let ix: Int let s: String (ix, s) = (1, &amp;#34;Two&amp;#34;) let (ix, s) = (1, &amp;#34;Two&amp;#34;) var (ix1, s1) = (12, &amp;#34;name&amp;#34;) 如果要将元组中的值赋给某些变量，但又要忽略元组中的某个值的时候，可以在对应位置使用下划线。下面的代码就是只取元组中的第二个值：
let pair = (1, &amp;#34;Two&amp;#34;) let (_, s) = pair // now s is &amp;#34;Two 使用元组可以不借助临时变量来交换两个变量的值，同时也是安全的。使用元组来交换两个变量时，只需要交换元组中变量的位置即可：
var s1 = &amp;#34;hello&amp;#34; var s2 = &amp;#34;world&amp;#34; (s1, s2) = (s2, s1) // now s1 is &amp;#34;world&amp;#34; and s2 is &amp;#34;hello&amp;#34; 访问元组中的值有两种方式。第一种是使用索引来访问元组中的值。例如，上面的pair元组中的第一个值可以使用pair.0来访问，第二个可以使用pair.1来访问。
var pair = (1, &amp;#34;Two&amp;#34;) pair.0 = 2 // now pair is (2, &amp;#34;Two&amp;#34;) 第二种方式是使用标签来访问元组中的值。但在元组声明的时候就需要先加上标签。元组的标签和函数的参数一样，必须作为类型声明的一部分出现：
let pair : (first:Int, second:String) = (1, &amp;#34;Two&amp;#34;) 上面的例子也可以使用let pair = (first:1, second:&amp;quot;Two&amp;quot;)这种简单的方式声明。之后便能使用标签来访问元组中的值（此时仍然可以通过索引访问）：
var pair = (first:1, second:&amp;#34;Two&amp;#34;) let x = pair.first // 1 pair.first = 2 let y = pair.0 // 2 在序列中使用enumerated方法既可以遍历元素也可以获得对应的索引。在下面的代码中，第一个for in中使用元组获取索引和元素，第二个for in中通过offset和element来获取：
let s = &amp;#34;hello&amp;#34; for (index, c) in s.enumerated() {  debugPrint(&amp;#34;character \(index)is \(c)&amp;#34;) }  //character 0 is h //character 1 is e //character 2 is l //character 3 is l //character 4 is o  for t in s.enumerated() {  debugPrint(&amp;#34;character \(t.offset)is \(t.element)&amp;#34;) }  //character 0 is h //character 1 is e //character 2 is l //character 3 is l //character 4 is o 需要特别注意的是，可以将一个没有标签的元组赋值给一个有标签的对应元组。相反，也可以将一个有标签的元组赋值给一个没有标签的元组，下面代码都是可行的：
var pair = (1, &amp;#34;Two&amp;#34;) var pairWithNames : (first:Int, second:String) = pair let ix = pairWithNames.first // 1 pair = pairWithNames 但是，如果两个元组包含的相同的类型，但声明的标签不同，则不能相互赋值。如下所示，虽然pair1和pair2的类型相同，但标签不同，会出现编译错误：
var pair1 = (first: 1, second: &amp;#34;test&amp;#34;) debugPrint(pair1.first, pair1.0, pair1.second, pair1.1) var pair2 = (test1: 1, test2: &amp;#34;test2&amp;#34;) debugPrint(pair1.first, pair1.0, pair1.second, pair1.1) pair1 = pair2 // Cannot assign value of type &amp;#39;(test1: Int, test2: String)&amp;#39; to type &amp;#39;(first: Int, second: String)&amp;#39; 可以在函数中传递元组，也可以在一个函数中返回一个没有标签的元组，即使这个函数声明的返回值是带标签的元组，如下所示：
func tupleMaker() -&amp;gt; (first: Int, second: String) {  return (1, &amp;#34;Two&amp;#34;) // no labels here }  let tuple = tupleMaker() debugPrint(tuple.first, tuple.second, tuple.0, tuple.1) // 1 &amp;#34;Two&amp;#34; 1 &amp;#34;Two&amp;#34; 可选类型 可选的对象类型（实质上是一个枚举）包裹着另一个对象，这个被包裹的对象的类型可以为任何类型。可以使用Optional声明或者赋值一个可选变量：
var stringMaybe = Optional(&amp;#34;howdy&amp;#34;) debugPrint(stringMaybe) stringMaybe = Optional(&amp;#34;fareWell&amp;#34;) debugPrint(stringMaybe) var stringMaybe1: String? = Optional(&amp;#34;test&amp;#34;) debugPrint(stringMaybe1) stringMaybe1 = &amp;#34;name&amp;#34; debugPrint(stringMaybe1)  //Optional(&amp;#34;howdy&amp;#34;) //Optional(&amp;#34;fareWell&amp;#34;) //Optional(&amp;#34;test&amp;#34;) //Optional(&amp;#34;name&amp;#34;) 声明可选值，通常不使用Optional初始化器，而是将某种类型的值分配或传递给一个已经声明成Optional的引用。在上面代码中，一旦stringMaybe被类型化为一个包裹着String的Optional，那么直接向其赋一个String是合法的，赋值的字符串被自动包装成一个Optional。
从形式上看，Optional是一个泛型，所以包裹一个字符串的Optional是一个Optional&amp;lt;String&amp;gt;。实际上，不必这样写，Swift语言支持用语法糖来表达一个Optional类型：被包装类型的名称后面跟一个问号即可。
var stringMaybe : String? 如果期望是一个Optional包装的某种类型，可以传递一个包装类型的值来代替。这是因为参数传递就像赋值一样：一个未被包裹的值会被隐含地包裹起来。如果一个函数期望一个包裹着字符串的Optional参数，可以直接传递一个字符串参数，它将自动地转换成Optional：
func optionalExpecter(_ s: String?) { // ... here, s will be an Optional wrapping a String ...   debugPrint(s) } optionalExpecter(&amp;#34;howdy&amp;#34;) // console debugPrints: Optional(&amp;#34;howdy&amp;#34;) 如果期望的是一个非Optional的类型，实际上却传递了一个Optional的类型，那么编译器将会报错。下面的代码会出现编译错误：
func realStringExpecter(_ s: String) {  // } let stringMaybe: String? = &amp;#34;howdy&amp;#34; realStringExpecter(stringMaybe) // compile error: Value of optional type &amp;#39;String?&amp;#39; must be unwrapped to a value of type &amp;#39;String&amp;#39; 在与nil以外的东西进行相等比较时，Optional得到了特殊的待遇：真正被比较的是被包裹的值，而不是Optional本身被比较：
let s: String? = &amp;#34;Howdy&amp;#34; if s == &amp;#34;Howdy&amp;#34; { // ... they _are_ equal!  debugPrint(true) } 上面的例子中，Swift不会将Optional本身与&amp;quot;Howdy&amp;quot;进行比较，而是自动地（安全地）将其包装值（如果有）与&amp;quot;Howdy&amp;quot;进行比较。如果包裹的值是&amp;quot;Howdy&amp;quot;，则比较成功。如果被包装的值不是&amp;quot;Howdy&amp;quot;，则比较失败。如果没有被包装的值（也就是为nil），那么比较也会安全地失败。
能够使用==操作符，则被包裹的类型必须遵循Equatable协议。如果没有遵守这个协议，编译器会阻止一个Optional类型使用==进行比较。
对象类型 Swift中有三种对象（object）类型，它们分别是enum,struct,class。对象类型的作用域取决于它声明所在的位置，可能出现的位置有三种：
  顶层声明：声明在文件顶部，默认情况下对于同一个module中的所有文件都是可见的。
  另一个类型中内嵌：在另一个类型的声明中内嵌声明一个类型是很有用的，相当于给这个内嵌类型一个命名空间。
  函数体中：在函数体中声明的对象类型的生命周期只存在于包含它的花括号内，这样的声明是合法的，但使用场景较少。
  对于任何对象类型声明时都可以在其花括号内包含以下五个方面的内容：
 初始化器：初始化器是一个函数，以一种特殊的方式声明和调用，以生成对象实例。 属性：在对象类型声明的顶层声明的变量是一个属性。 方法：在对象类型声明的顶层声明的函数是一个方法。 下标：下标是一种特殊的方法，通过在实例引用或类型名称后面加上方括号来调用。 内嵌类型：一个对象类型声明可以包含另一个对象类型声明（内嵌类型）。  初始化器 初始化器是一个用于产生对象实例的函数。严格地说，初始化器是一个静态方法，因为它是被对象类型调用的。它是通过特殊的语法来调用的：类型的名字后面直接加上括号。当一个初始化器被调用时，一个新的实例被创建并作为结果返回：
class Dog {  // } let dog = Dog() 上面的代码中Dog()调用了一个初始化器，尽管Dog类没有声明任何初始化器，但并没有编译错误。这是因为，如果没有自定义初始化器，则编译器会自动生成一个无参数的初始化器。
除了使用编译器自动生成的初始化器，也可以编写自己的初始化器。初始化器是一种特殊的函数，有特殊的声明语法，不需要使用func关键字、箭头符号以及返回值类型。
自定义初始化器的声明使用关键字init和一个参数列表，然后紧跟函数体。一个对象类型可以有多个初始化器，以其参数（个数和类型）来区分：
class Dog {  var name = &amp;#34;&amp;#34;  var license = 0   init(name: String) {  self.name = name  }   init(license: Int) {  self.license = license  }   init(name: String, license: Int) {  self.name = name  self.license = license  } } 上面自定义了三个初始化器，即提供了三种方式创建Dog实例。现在已经不能使用没有初始化参数的初始化器了，因为一旦有自定义的初始化器，编译器就不会再自动生成无参的初始化器了：
let fido = Dog(name: &amp;#34;Fido&amp;#34;) let rover = Dog(license: 1234) let spot = Dog(name: &amp;#34;Spot&amp;#34;, license: 1357) 也可以显式声明无参的自定义初始化器，以避免使用没有参数的初始化器时编译报错。下面的代码中声明了无参的初始化器init():
class Dog {  var name = &amp;#34;&amp;#34;  var license = 0  init() {  //  }   init(name: String) {  self.name = name  }   init(license: Int) {  self.license = license  }   init(name: String, license: Int) {  self.name = name  self.license = license  } } 当实例生成时，如果实例属性还没有初始值，则编译器会报错。因此，一个属性可以作为其声明的一部分被初始化，或被其中的每个初始化器初始化。
Swift编译器强制要求所有的实例属性都要正确地初始化，这是Swift的一个重要特征。相比之下，Objective-C的实例属性可以不初始化，而且经常会这样，导致可能出现奇怪的错误。
因为在初始化器中设置一个实例属性也算作初始化，所以即使实例属性是用let声明的常量，也是合法的。下面的代码将name和license都声明为常量属性，在初始化器中再初始化也是合法的：
class Dog {  let name: String  let license: Int   init(name: String, license: Int) {  self.name = name  self.license = license  } } 有时，在初始化过程中，暂时不能初始化一个实例属性为有意义的值。也许这个属性的初始值要在这个实例出现后的某个时间点才能得到。这种情况与所有实例属性在其声明中或通过初始化器进行初始化的要求相冲突。可以通过分配一个默认的初始值来规避这个问题，但此时无法向你自己的代码传达这样一个事实：这个默认值不是真实有效的值。
一个常见的解决方案是将实例属性声明为一个Optional类型的var。Optional类型有一个值nil，表示没有提供真实有效的值，并且一个Optional var会自动初始化为nil。
因此，代码中可以用nil来测试这个Optional的实例属性，如果它是nil，就暂时不要使用这个属性。该属性会在某个时候被赋予真实有效的值，这个值是被包裹在Optional中的。
一个初始化器可以引用一个已经初始化的实例属性，也可以引用一个未初始化的实例属性，以便初始化它。除了这种情况，在所有实例属性被初始化之前，初始化器不得显式或隐式地引用自己。这条规则保证了实例在使用之前已经完全形成。
代理初始化器 在初始化器中，如果调用了另一个初始化器，那这个初始化器被称为代理初始化器。代理初始化器调用的其它初始化器必须已经将所有的存储属性初始化，否则会出现编译错误。
代理初始化器似乎是过早使用self调用函数的一个反例，但事实并不是这样，它使用self调用函数是为了初始化储存属性。而且代理初始化器在调用其它初始化器之前不能使用self，即使是给存储属性赋初值也不行。
struct Digit {   var number: Int  var meaningOfLife: Bool   init(number: Int) {  self.number = number  self.meaningOfLife = false  }   init() { // this is a delegating initializer  self.meaningOfLife = false //&amp;#39;self&amp;#39; used before &amp;#39;self.init&amp;#39; call or assignment to &amp;#39;self&amp;#39;  self.init(number: 42)  self.meaningOfLife = true  }  } 在代理初始化器中，不能再对let常量属性赋值，因为调用其它初始化器时已经将常量属性赋了初始值，如果再次对其赋值会出现编译错误。因为在代理初始化器中可以调用其它初始化器，千万不要形成递归调用，下面代码就会产生递归引用：
struct Digit { // do not do this!   var number: Int = 100   init(value: Int) {  self.init(number: value)  }   init(number: Int) {  self.init(value: number  }  } 可失败的初始化器 一个初始化器可以返回一个可选的新实例，如果返回nil表示初始化失败，这种初始化器被称为可失败的初始化器。声明可失败的初始化器很简单，只要在init后面添加一个?即可:
class Dog {   let name: String  let license: Int   init?(name: String, license: Int) {  if name.isEmpty {  return nil // 返回nil  }  if license &amp;lt;= 0 {  return nil  }  self.name = name  self.license = license  } } 属性 实例属性在声明的同时可以进行初始化，但**初始化某个实例属性时不能获取其它实例属性或调用一个实例方法，因为此时实例尚未生成**。下面代码会产生编译错误：
class Moi {  let first = &amp;#34;Matt&amp;#34;  let last = &amp;#34;Neuburg&amp;#34;  let whole = self.first &#43; &amp;#34; &amp;#34; &#43; self.last // compile error: Cannot find &amp;#39;self&amp;#39; in scope } 解决上面的编译报错有三种方法，第一种是把whole声明为计算属性而非存储属性，因为**计算属性是在实例初始化完成之后才会被调用的**：
class Moi {  let first = &amp;#34;Matt&amp;#34;  let last = &amp;#34;Neuburg&amp;#34;   var whole: String {  self.first &#43; &amp;#34; &amp;#34; &#43; self.last  } } 第二种方法是把whole声明为lazy的var变量。同计算变量一样，lazy变量也是要等实例初始化完成之后才会被调用：
class Moi {  let first = &amp;#34;Matt&amp;#34;  let last = &amp;#34;Neuburg&amp;#34;  lazy var whole = self.first &#43; &amp;#34; &amp;#34; &#43; self.last  } 第三种方法就是使用匿名函数的define-and-call进行初始化。因为要在匿名函数中使用self，所以也需要把实例属性声明为lazy：
class Moi {  let first = &amp;#34;Matt&amp;#34;  let last = &amp;#34;Neuburg&amp;#34;  lazy var whole: String = {  var s = self.first  s.append(&amp;#34; &amp;#34;)  s.append(self.last)  return s  }()  } 不像实例属性，静态属性可以在初始化的时候引用其他静态属性，因为静态属性初始化器本身就是lazy的。下面的代码不会出现编译错误：
struct Greeting {  static let friendly = &amp;#34;hello there&amp;#34;  static let hostile = &amp;#34;go away&amp;#34;  static let ambivalent = friendly &#43; &amp;#34; but &amp;#34; &#43; hostile }  debugPrint(Greeting.ambivalent) 上面的代码中，静态属性进行初始化的时候省略了self，这是因为它隐含地包含了self。对于静态属性来说，它的self表示类型本身。实际上在静态属性初始化时，如果要引用其它静态属性，前面加上自身的类型会有更好的可读性：
struct Greeting {  static let friendly = &amp;#34;hello there&amp;#34;  static let hostile = &amp;#34;go away&amp;#34;  static let ambivalent = Greeting.friendly &#43; &amp;#34; but &amp;#34; &#43; Greeting.hostile } 需要特别注意的是，在声明静态计算变量时，如果使用匿名函数的define-and-call初始化，不能在匿名函数中使用self（认为这是一个系统bug）：
struct Greeting {  static let friendly = &amp;#34;hello there&amp;#34;  static let hostile = &amp;#34;go away&amp;#34;  static var ambivalent: String = {  self.friendly &#43; &amp;#34; but &amp;#34; &#43; self.hostile // compile error: Cannot find &amp;#39;self&amp;#39; in scope  }() } struct Greeting {  static let friendly = &amp;#34;hello there&amp;#34;  static let hostile = &amp;#34;go away&amp;#34;  static var ambivalent: String = {  friendly &#43; &amp;#34; but &amp;#34; &#43; hostile // 省略self才不会报错  }() } 方法 在静态/类成员和实例成员之间存在着一种隔阂，尽管它们被声明在同一个对象类型中，但属于不同的世界。一个静态/类方法不能引用实例，因为静态方法中没有实例。因此，一个静态/类方法不能直接引用任何实例属性或调用任何实例方法。另一方面，一个实例方法可以引用类型，因此可以访问静态/类的属性，能调用静态/类方法。
class MyClass {  var s = &amp;#34;&amp;#34;   func store(_ s: String) {  self.s = s  debugPrint(&amp;#34;MyClass test&amp;#34;)  }  }  let m = MyClass() let f = MyClass.store(m) // what just happened!? f(&amp;#34;s&amp;#34;) debugPrint(m.s) 实际上，实例方法也是一种静态/类方法。在上面的代码中，尽管store是一个实例方法，但可以通过类型来调用，只需把一个实例参数传进去。
下标 下标是一种方法，它通过将包含参数的方括号直接附加到一个对象的引用上来调用。可以把这个功能用于任何你喜欢的地方，但它特别适用于这样的情况：一个对象类型，其元素可以通过键或索引来访问。
声明下标方法有点像普通函数的声明又有点像计算属性的声明。它可以接受参数，当下标方法被调用时，参数可以出现在方括号中。一个下标就像一个计算属性，它的调用就像对一个属性的引用：你可以获取它的值，也可以向它赋值：
struct Digit {   var number: Int   init(_ n: Int) {  self.number = n  }   subscript(ix: Int) -&amp;gt; Int { // ① ②  get { // ③  let s = String(self.number)  return Int(String(s[s.index(s.startIndex, offsetBy: ix)]))!  }  }  }   关键字sbuscript后面紧跟参数列表，说明方括号内要出现哪些参数。默认情况下，参数名不会被外化。如果要外化参数名，需要在内部参数前外化。
  然后是传出（调用getter函数时）或传入（调用setter函数时）值的类型。
  最后是花括号，其内容与计算属性的内容完全一样。可以用get和花括号表示getter函数，用set和花括号表示setter函数。setter函数可以被省略，在这种情况下，get这个词和它的花括号可以被省略。如果getter函数只由一条语句组成，可以省略关键字return。setter函数接收的新值是newValue，但可以通过在set这个词后面的小括号里提供一个不同的名字来实现自定义名字。
  下面代码调用了subscript中的getter的方法。在Digit实例后面跟着方括号，方括号里面有Int参数：
var d = Digit(1234) let a Digit = d[1] 下面的代码中Digit类型中包含了subscript下标方法，并且下标方法中也包含了setter，可以使用d[0] = 2这样的语句来访问下标的setter：
struct Digit {   var number: Int   init(_ n: Int) {  self.number = n  }   subscript(ix: Int) -&amp;gt; Int {  get {  let s = String(self.number)  return Int(String(s[s.index(s.startIndex, offsetBy: ix)]))!  }  set {  var s = String(self.number)  let i = s.index(s.startIndex, offsetBy: ix)  s.replaceSubrange(i...i, with: String(newValue))  self.number = Int(s)!  }  } } 一种类型中可以声明多个subscript方法，以参数个数和类型进行区分。从Swift 5.1开始，subscript方法可以是静态的。从Swift 5.2开始，subscript方法可以有默认参数:
struct NewDigit {   var number: Int   init(_ n: Int) {  self.number = n  }   subscript(ix: Int) -&amp;gt; Int {  get {  let s = String(self.number)  return Int(String(s[s.index(s.startIndex, offsetBy: ix)]))!  }  set {  var s = String(self.number)  let i = s.index(s.startIndex, offsetBy: ix)  s.replaceSubrange(i...i, with: String(newValue))  self.number = Int(s)!  }  }   static subscript(index: String) -&amp;gt; Int {  debugPrint(index)  return 0  }   subscript(index: Double = 0) -&amp;gt; Int {  debugPrint(index)  return 0  } } 需要注意的是对于下标的重载来说，如果均没有使用外部参数，并且只是内部参数名不同，参数的个数、类型以及顺序都相同的话，会出现编译错误，这是因为没有外部参数时仅使用方括号调用：
subscript(ix: Int) -&amp;gt; Int {  get {  let s = String(self.number)  return Int(String(s[s.index(s.startIndex, offsetBy: ix)]))!  }  set {  var s = String(self.number)  let i = s.index(s.startIndex, offsetBy: ix)  s.replaceSubrange(i...i, with: String(newValue))  self.number = Int(s)!  } } subscript(newIndex: Int) -&amp;gt; Int {  debugPrint(newIndex)  return 0 } 如果只是外部参数不同，内部参数个数和类型都相同，则不会出现编译错误，因为编译器会认为这是不同的subscript方法：
class Dog {  var name: String  let license: Int  init?(name: String, license: Int) {  if name.isEmpty {  return nil // 返回nil  }  if license &amp;lt;= 0 {  return nil  }  self.name = name  self.license = license  }  subscript(at index: Int) -&amp;gt; String {  get {  return self.name  }  set {  self.name = newValue  }  }  subscript(for index: Int) -&amp;gt; String {  get {  return self.name  }  set {  self.name = newValue  }  } } let dog = Dog(name: &amp;#34;test&amp;#34;, license: 1345) dog?[at: 123] dog?[for: 134] 内嵌类型 一个类型声明在另一个类型里面，就会形成内嵌类型。嵌套的对象类型与其它对象类型没有什么不同，但是从外部引用内嵌类型的规则发生了变化，外部的对象类型作为一个命名空间，必须明确地被引用才能访问嵌套的对象类型。
class Dog {  struct Noise {  static var noise = &amp;#34;woof&amp;#34;  }   func bark() {  debugPrint(Dog.Noise.noise)  } } // 访问静态属性 Dog.Noise.noise = &amp;#34;arf&amp;#34; 在上面的代码中，结构体Noise定义在类Dog中，它并不是自由的，而是明确地与Dog类相关联，属于Dog中的类型。不同的命名空间允许有相同的Noise类型存在，而不会产生冲突。
在Swift的内置类型中，经常使用命名空间来解决类型冲突。例如，String结构体是包含Index结构体的几个结构体之一，但它们并没有名字冲突。
嵌套的内部类型不能直接访问其外部类型的实例成员，但是能直接访问其静态/类成员。在下面的代码中，Noise类型不能直接访问Dog类型的实例方法bark，但是能直接访问它的静态属性sound:
class Dog {   static let sound = &amp;#34;ruff&amp;#34;   struct Noise {   static var noise = &amp;#34;woof&amp;#34;   func barkTheDog() {  bark() // compile error: Instance member &amp;#39;bark&amp;#39; of type &amp;#39;Dog&amp;#39; cannot be used on instance of nested type &amp;#39;Dog.Noise&amp;#39;  }   var othernoise = sound // fine  }   func bark() {  debugPrint(Dog.Noise.noise)  }  } 在上面的代码中，内嵌类型Noise能直接访问静态属性sound，而不需要使用Dog.sound，因为外层定义的静态属性sound，对于内嵌类型来说是全局的。
枚举 枚举是一种对象类型，其实例代表不同的预定义值，可以将这些预定义值看作是一个已知可能性的列表，枚举是表达一组常量的Swift方式。枚举声明包含case语句，一个case是一个可选值的名称，一个枚举实例准确地代表一种选择：
enum Filter {  case albums  case playlists  case podcasts  case books } 上面定义的枚举Filter没有初始化器，实际上可以自定义枚举类型的初始化器。但有一个默认的初始化器，可能在大多数时候都会使用它&amp;ndash;枚举的名称后面加上点号和其中一个case。
在使用enum声明枚举类型时，可以添加一个类型声明，但这种类型只限于数值型和字符串。如果增加的类型是数值型，每个case都有默认值，默认值从0开始：
enum PepBoy: Int {  case manny  case moe  case jack } 在上面的代码中，.manny的默认值是0，.moe的值是1，以此类推。如果类型是字符串，在定义的时候如果不设置case对应的字符串，则默认值是每个case对应的名字。下面的代码中，.albums的默认值是&amp;quot;albums&amp;quot;，.playlists的值是&amp;quot;playlists&amp;quot;，依此类推：
enum Filter: String {  case albums  case playlists  case podcasts  case books } rawValue 如果在声明带类型的枚举时，不想使用默认值，可以为每个case赋值。case所携带的值称为raw value。一个有类型声明的枚举隐含地遵循了RawRepresentable协议，这意味着它有一个init(rawValue:)初始化器和一个rawValue属性。
enum Normal: Double {  case fahrenheit = 98.6  case centigrade = 37 }  enum PepBoy: Int {  case manny = 1  case moe // 2 implicitly: 默认为2  case jack = 4 }  enum Filter: String {  case albums = &amp;#34;Albums&amp;#34;  case playlists = &amp;#34;Playlists&amp;#34;  case podcasts = &amp;#34;Podcasts&amp;#34;  case books = &amp;#34;Audiobooks&amp;#34; } 带类型的枚举声明时，每个case的raw value必须保证是唯一的，否则会出现编译错误。因此，可以使用raw value实例化一个枚举，但使用init(rawValue:)时也可能失败，因为传入的raw value可能与case不匹配，所以它实际上是可失败的init?(rawValue:)。
Associated Values 上面说的raw value对于每个case来说都是固定的，在枚举类型声明的时候就已经确定了。有一种方法可以构造一个case，使得其常量值可以在实例创建时才被设置，此时设置的值被称为associated value。
声明带associated value的枚举类型时，不能为整个枚举类型声明任何原始值类型。而是在有需要的case上附加一个看起来像元组的表达式，即包含一个可能标记的类型列表的括号。与rawValue不同，associated value无类型上的限制：
enum MyError {  case number(Int)  case message(String)  case fatal } 上面代码的含义是：在实例化的时候，一个.number case的MyError实例必须被设置一个Int值，一个.message case的MyError实例必须被设置一个String值，而一个.fatal case的MyError实例不用设置任何值。
let err1 : MyError = .number(4) let num = 4 let err2 : MyError = .number(num) 如同在枚举实例被期望的地方使用点和枚举case一样，当引用一个类型的静态/类成员的值是该类型的一个实例时，可以做同样的事情。例如，UIColor有许多由UIColor实例生成的类属性，所以可以在预期有UIColor的地方省略UIColor：
p.trackTintColor = .red // instead of UIColor.red 类似地，假设有一个带有静态常量的结构体Thing，其值是Thing的实例。那么在声明Thing变量或者常量时可以使用点操作符来引用该静态常量：
struct Thing: RawRepresentable {  let rawValue: Int  static let one: Thing = Thing(rawValue: 1)  static let two: Thing = Thing(rawValue: 2) }  let thing1: Thing = .one let thing2: Thing = .two 同样地，当一个类型有一个静态/类方法产生该类型的实例时，在期望有一个该类型的实例时的地方，可以省略类型名，初始化器也是这样的方法。
struct Dog {  let name: String   static func same(text: String) -&amp;gt; Dog {  return Dog(name: text)  } }  func dogExpecter(_ dog: Dog) {  debugPrint(dog.name) }  dogExpecter(.init(name: &amp;#34;Fido&amp;#34;)) dogExpecter(.same(text: &amp;#34;Foo&amp;#34;)) 实际上，一个Optional只是有两个case的枚举：.none和.some。如果它是.none，表示没有相关的值，相当于nil。如果它是.some，它就会携带包装好的值作为其关联值。
如果一个case的associated value类型有标签，标签必须在初始化的时候使用。在下面的代码中，case fetal有标签，需要在初始化时使用：
enum MyError2 {  case number(Int)  case message(String)  case fatal(n: Int, s: String) }  let err: MyError2 = .fatal(n: -12, s: &amp;#34;Oh the horror&amp;#34;) 默认情况==操作符不能直接用于比较带有associated value的枚举，否则会出现编译错误。下面代码中，因为直接比较两个枚举值，将出现编译错误：
enum MyError2 {  case number(Int)  case message(String)  case fatal(n: Int, s: String) }  let err: MyError2 = .fatal(n: -12, s: &amp;#34;Oh the horror&amp;#34;)  // operator &amp;#39;==&amp;#39; cannot be applied to operands of type &amp;#39;MyError2&amp;#39; and &amp;#39;(Int, String) -&amp;gt; MyError2&amp;#39; if err == MyError2.fatal { // compile error  // } 如果声明带associated value枚举时显式地遵循Equatable协议，==操作符就能正常工作了。但前提是所有associated value类型本身都是遵循Equatable，否则也会出现编译错误：
enum MyError: Equatable {  case number(Int)  case message(String)  case fatal }  let error: MyError = .fatal  if error == .fatal {  debugPrint(true) } Enum Case Iteration 如果声明的枚举类型遵循了CaseIterable协议，那么它就会有一个allCases静态属性，这个属性包含了该枚举的所有case值：
enum Filter: String, CaseIterable {   case albums = &amp;#34;Albums&amp;#34;   case playlists = &amp;#34;Playlists&amp;#34;   case podcasts = &amp;#34;Podcasts&amp;#34;   case books = &amp;#34;Audiobooks&amp;#34; }  debugPrint(Filter.allCases) // [Command.Filter.albums, Command.Filter.playlists, Command.Filter.podcasts, Command.Filter.books] Enum Initializers 一个显式枚举初始化器必须做默认初始化所做的事情：它必须返回枚举的一个case。要做到这一点，需要将self设置为该case。在下面的代码中，声明了枚举初始化器，以便它可以用一个数字参数进行初始化：
enum Filter: String, CaseIterable {   case albums = &amp;#34;Albums&amp;#34;   case playlists = &amp;#34;Playlists&amp;#34;   case podcasts = &amp;#34;Podcasts&amp;#34;   case books = &amp;#34;Audiobooks&amp;#34;   init?(_ ix: Int) {  if !Filter.allCases.indices.contains(ix) {  return nil  }  self = Filter.allCases[ix]  } } 现在有三种方式可以创建一个Filter实例。第一种是使用Filter类型&#43;点操作符，第二种是使用rawValue，第三种方式是使用上面自定义的初始化器：
let type1 = Filter.albums let type2 = Filter(rawValue: &amp;#34;Playlists&amp;#34;)! let type3 = Filter(2) // .podcasts debugPrint(Filter.allCases) // [Command.Filter.albums, Command.Filter.playlists, Command.Filter.podcasts, Command.Filter.books] debugPrint(type1, type2, type3) // Command.Filter.albums Command.Filter.playlists Optional(Command.Filter.podcasts) 一个枚举类型可以有多个初始化器，枚举初始化器可以通过调用self.init(...)委托其他初始化器来完成初始化。唯一的要求是某个时刻，self必须设置为某个case。下面代码新增了一个可失败的初始化器，在其中调用了另一个初始化器：
enum Filter: String, CaseIterable {   case albums = &amp;#34;Albums&amp;#34;   case playlists = &amp;#34;Playlists&amp;#34;   case podcasts = &amp;#34;Podcasts&amp;#34;   case books = &amp;#34;Audiobooks&amp;#34;   init?(_ ix: Int) {  if !Filter.allCases.indices.contains(ix) {  return nil  }  self = Filter.allCases[ix]  }   init?(_ rawValue: String) {  self.init(rawValue: rawValue)  }  } 在上面的代码中，改进了Filter枚举，以便它可以用一个字符串的原始值进行初始化，而不必在调用中使用rawValue：。因此，声明了一个带有字符串参数可失败的初始化器，该参数委托给内置的可失败的rawValue:初始化器。
Enum Properties 枚举类型既可以有实例属性也可以有静态属性，但实例属性只能是计算属性不能是存储属性，计算实例属性可以根据self的值变化而变化：
enum Filter: String {   case albums = &amp;#34;Albums&amp;#34;   case playlists = &amp;#34;Playlists&amp;#34;   case podcasts = &amp;#34;Podcasts&amp;#34;   case books = &amp;#34;Audiobooks&amp;#34;   var query: MPMediaQuery {  switch self {  case .albums:  return .albums()  case .playlists:  return .playlists()  case .podcasts:  return .podcasts()  case .books:  return .audiobooks()  }  } } 如果一个枚举实例计算属性有setter方法，则其他代码可以赋值这个属性，但是更改这个计算属性的枚举实例本身必须是var而不是let声明的，否则会出现编译错误：
enum Silly {  case one  var sillyProperty: String {  get {  &amp;#34;Howdy&amp;#34;  }  set {  //   }  // do nothing  } }  var silly = Silly.one silly.sillyProperty = &amp;#34;silly&amp;#34; 枚举类型的静态属性可以是一个property wrapper，但实例计算属性不能，因为枚举类型的实例属性必须都是计算属性。
method 枚举类型既可以有实例方法也可以有静态方法。下面代码中声明的枚举类型Shape定义了一个实例方法addShape，它根据self的值完成对应的操作：
enum Shape {  case rectangle  case ellipse  case diamond   func addShape(to p: CGMutablePath, in r: CGRect) -&amp;gt; () {  switch self {  case .rectangle:  p.addRect(r)  case .ellipse:  p.addEllipse(in: r)  case .diamond:  p.move(to: CGPoint(x: r.minX, y: r.midY))  p.addLine(to: CGPoint(x: r.midX, y: r.minY))  p.addLine(to: CGPoint(x: r.maxX, y: r.midY))  p.addLine(to: CGPoint(x: r.midX, y: r.maxY)) p.closeSubpath()  }  } } 在前面说过subscript可以是静态方法，因此可以定义一个静态的subscript来获取遵循CaseIterable协议的某个case，代码如下所示：
enum Filter: String, CaseIterable {   case albums = &amp;#34;Albums&amp;#34;   case playlists = &amp;#34;Playlists&amp;#34;   case podcasts = &amp;#34;Podcasts&amp;#34;   case books = &amp;#34;Audiobooks&amp;#34;   static subscript(ix: Int) -&amp;gt; Filter {  guard ix &amp;gt;= 0 &amp;amp;&amp;amp; ix &amp;lt; Filter.allCases.count else {  return .albums  }  return Filter.allCases[ix]  } }  debugPrint(Filter[2]) 如果枚举实例方法想要修改枚举实例本身，则声明的时候要标记为mutating，因为它也是一种值类型。例如，一个枚举实例方法可能会赋值给self的一个实例属性，即使这是一个计算属性，这种赋值也是非法的，除非该方法被标记为mutating。调用mutating方法的实例变量必须声明为var。
在一个mutating枚举实例方法中，可以改变自身，方法是将另一个实例分配给self。下面的代码在advance方法中改变了自身：
enum Filter: String, CaseIterable {   case albums = &amp;#34;Albums&amp;#34;   case playlists = &amp;#34;Playlists&amp;#34;   case podcasts = &amp;#34;Podcasts&amp;#34;   case books = &amp;#34;Audiobooks&amp;#34;   static subscript(ix: Int) -&amp;gt; Filter {  guard ix &amp;gt;= 0 &amp;amp;&amp;amp; ix &amp;lt; Filter.allCases.count else {  return .albums  }  return Filter.allCases[ix]  }   mutating func advance() {  let cases = Filter.allCases  var ix = cases.firstIndex(of: self)!  ix = (ix &#43; 1) % cases.count  self = cases[ix]   } } 结构体 结构体是Swift对象类型中的佼佼者。枚举由固定的case集合组成，是一种缩小的、专门的对象。在另一个极端，类往往会被证明是多余的，它有一些结构体所缺乏的功能，但如果不需要这些功能，结构体可能是更好的选择。
在Swift标头中声明的200多种对象类型中，可能有一半是类，有几十个是枚举，其余的都是结构体。String是一个结构体，Int是结构体，Range是结构体，Array也是一个结构体。
init 如果结构体没有存储属性或者全部的存储属性在声明的时候已经有默认值，则会自动生成一个无参的初始化器init()。下面的代码中，编译器会为Digit自动生成一个无参初始化器Digit()：
struct Digit {  var number = 42 } 一旦在代码中增加了新的初始化器，编译器将不会自动生成无参的初始化器。在下面的代码中，已经在Digit增加一个有参的初始化器，则无参的初始化器Digit()将会失效：
struct Digit {  var number = 42  init(number: Int) {  self.number = number  } } 此时，如果想要使用Digit()进行初始化，会出现编译报错。需要手动声明一个无参的初始化器，才能通过编译：
struct Digit {  var number = 42   init() {  //  }   init(number: Int) {  self.number = number  } } 有存储属性且没有显式初始化器的结构体会自动获得一个从其实例属性派生的隐式初始化器，这称为memberwise initializer(成员式初始化器)：
struct Test {  var number = 42  var name: String  let age: Int  let greeting = &amp;#34;Hello&amp;#34; } 上面的代码是合法，虽然看起来没有履行在声明或者初始化器中初始化所有储存属性的契约。但实际上，因为没有自定义的初始化器，这个结构体会自动生成一个ˇ initializer(成员式初始化器)，在这个memberwise initializer初始化了所有未初始化的属性：
struct Test {  var number = 42  var name: String  let age: Int  let greeting = &amp;#34;Hello&amp;#34; }  let t1 = Test(number: 42, name: &amp;#34;matt&amp;#34;, age: 65) let t2 = Test(name: &amp;#34;matt&amp;#34;, age: 65) 上面自动生成的memberwise initializer包含了number,name,age，不包括greeting。这是因为greeting是使用let声明的，在声明的时候已经初始化了。
因为number使用var声明，并且在声明的同时已经被初始化了，因此从Swift 5.1后在调用memberwise initializer时可以省略这种用var声明并且同时已经初始化属性：
let t2 = Test(name: &amp;#34;matt&amp;#34;, age: 65) 如果在结构体声明的时候，有自定义的初始化器或者属性声明为private(使用let声明并且已经初始化的属性除外)，则编译器不会自动生成的memberwise initializer。
结构体中声明的存储属性必须全部初始化，不管是声明的时候初始化还是在所有的初始化器中初始化。如果一个结构体有多个初始化器，则可以在初始化器中通过self.init()调用其他初始化器。
Properties 结构体可以有实例属性或者静态属性，二者都可以声明为存储或者计算属性。如果代码中想重新设置一个结构体实例属性的值，则该实例变量必须使用var声明，否则会出现编译错误：
var d = Test(name: &amp;#34;ddd&amp;#34;,age: 34) d.name = &amp;#34;new test&amp;#34; method 结构体可以有实例方法和静态方法，包括subscript(下标)，如果一个实例方法想要设置结构体中某个属性的值，那么这个方法一定要声明为mutating，并且调用这个方法的实例也必须使用var声明，否则会出现编译错误：
struct Digit {   private var number: Int   init(_ n: Int) {  self.number = n  }   mutating func changeNumberTo(_ n: Int) {  self.number = n  }  }  var d = Digit(123) d.changeNumberTo(42) subscript下标或者计算属性的set方法默认认为是mutating，不必显式地声明为mutating。但是如果在它们的set方法中要设置其他属性的值，必须显式地声明为mutating。声明为mutating的方法中可以使用该类型的另一个实例设置self的方式来改变自身。
Struct as Namespace 经常使用退化的结构体作为常量的便利命名空间，之所以称为退化的，是因为结构体中全部为静态成员，并不打算使用这种对象类型来制造任何其它实例。
UserDefaults是一种字典，每个值可以通过一个键来访问。这些键通常是字符串，一个常见的错误是使用键时拼错了键的名字，虽然在编译时不会报错，但代码将不能正常工作。
更好的方法是将这些键体现为常量字符串，并使用字符串的名称，如果错误地输入了一个名称，编译器会报错。带有静态成员的结构是定义常量字符串并将其名称集中到一个命名空间的好方法。
struct Default {  static let rows = &amp;#34;rows&amp;#34;  static let columns = &amp;#34;columns&amp;#34;  static let hazyStripy = &amp;#34;hazyStripy&amp;#34; } 现在就可以使用，Default中的静态成员作为UserDefaults的键来引用，例如使用Default.rows可以就代表rows字符串。
Classes 虽然类和结构体有些相似，但类和结构体还是有一些关键区别：
  类是引用类型，类的实例有两个显著的特征，而这些特征对于结构体或枚举的实例来说是截然不同的。
  类的实例是原地是可变的。即使一个类的实例的引用是用let声明的，也可以通过这个引用来改变一个实例属性的值。类的实例方法从来不需要被标记为可变的（也不能被标记）。
  当一个给定的类的实例被分配给多个变量或作为参数传递给一个函数时，你会得到对一个相同对象的多个引用。
    一个类可以有一个父类，它继承其父类的成员，类的继承层次可以形成一个分层的树结构。而结构体不能继承。
  在Objective-C中，类是唯一的对象类型。一些内置的Swift结构类型可以神奇地与Objective-C的类类型衔接，但自定义结构类型却没有这种魔力。因此，在用Swift进行iOS编程时，声明类而不是结构的一个原因是作为一种与Objective-C和Cocoa的互换形式。
Value Types and Reference Types 在Swift中，结构体和枚举类型都是值类型，类是引用类型。值类型不能就地可变，而类的实例能够就地可变。在下面的例子中，因为结构体是值类型，所以更改结构体实例的属性时，要将结构体实例用var声明，而不能用let声明：
struct Digit {  var number: Int   init(_ n: Int) {  self.number = n  } }  var d = Digit(23) d.number = 45 实际上，当改变一个值类型的实例时，是在用一个不同的实例替换该实例。为了证明这一点，可以添加一个setter观察器。在下面的代码中，虽然改变的只是属性number的值，但是didSet依然调用了，这说明该实例被替换了：
struct Digit {  var number: Int   init(_ n: Int) {  self.number = n  } }  var d: Digit = Digit(234) {  didSet {  debugPrint(&amp;#34;d was set&amp;#34;)  } }  d.number = 456 // &amp;#34;d was set&amp;#34; 下面代码会出现编译错误，能够解释如果值类型的实例引用是用let关键字声明的，那么就不能对该实例进行就地改变：
let d = Digit(123) // Digit is a struct d.number = 42 // compile error 但类不是值类型，它们是引用类型。对一个类实例的引用不一定要用var来声明，即使是使用let声明的，也可以通过该引用更改其var属性的值：
class Dog {  var name: String = &amp;#34;Fido&amp;#34; }  let rover = Dog() rover.name = &amp;#34;Rover&amp;#34; // fine 在上面代码的最后一行，rover所指向的类实例被就地改变了。没有涉及到对rover的隐式赋值，所以let声明无力阻止这种变化。当属性被设置时，Dog变量上的setter observer 没有被调用：
class Dog {  var name: String = &amp;#34;Fido&amp;#34; }  var rover: Dog = Dog() { // Dog is a class  didSet {  debugPrint(&amp;#34;rover did set rover&amp;#34;)  } } rover.name = &amp;#34;Rover&amp;#34; // nothing in console 上面的didSet观察器的代码没有执行，说明没有生成新的实例。如果显式地重新设置rover，就会调用setter观察器，但是它不会仅仅因为我们改变了已经被rover指向的狗的实例的一个属性而被调用。
值类型和引用类型之间的区别也可以在一个函数调用的参数中看到。当接收一个值类型的实例作为参数进入一个函数体时，如果试图赋值给它的实例属性，编译器将会报错：
func digitChanger(_ d: Digit) { // Digit is a struct  d.number = 42 // compile error } 因为Digit是结构体，上面的代码会报错Cannot assign to property: &#39;d&#39; is a &#39;let&#39; constant，因为函数参数默认是用let隐式声明的。但Dog是引用类型，可以就地改变，所以下面的代码不会报错：
func dogChanger(_ d: Dog) { // Dog is a class  d.name = &amp;#34;Rover&amp;#34; } Mutating Captured Self struct Digit {   var number: Int   init(_ n: Int) {  self.number = n  }   mutating func changeNumberTo(_ n: Int) {  self.number = n  }   func otherFunction(_ f: () -&amp;gt; ()) {  //  }   mutating func callAnotherFunction() {   otherFunction {  self.changeNumberTo(345)  }  } } 上面的代码是否合法取决于otherFunction是否将它的函数参数声明为@escaping（逃逸闭包）。如果它声明了escaping逃逸的，编译器会报Escaping closure captures mutating &#39;self&#39; parameter：
func otherFunction(_ f: @escaping ()-&amp;gt;()) {  // } 现在otherFunction是逃逸的，这意味着存在威胁：可能在以后的某个时间点改变捕获的self。Digit是一个结构体，所以这将涉及到用一个不同的Digit实例来替换捕获的self。如果Digit是一个类，就不会出现这样的问题，因为捕获的self可以被就地改变。
类引用是指针 在引用类型中，在对实例的引用和实例本身之间有一个隐蔽的层次。引用实际上持有一个指向实例的指针，这意味着当一个类的实例被分配给一个变量或作为一个函数的参数或作为一个函数的结果传递时，可能会出现对同一个对象的多个引用，而结构体和枚举则不是这样的。
在枚举或者结构体实例被赋值或者传递时，本质上是被赋值或者被传递的是该实例的副本。而类实例被赋值或传递时是实例本身，下面的代码能说明这种区别：
var d1 = Digit(123) // Digit is a struct debugPrint(d.number) // 123 var d2 = d // assignment!  d2.number = 42 debugPrint(d1.number) // 123 在下面的代码中，改变了类实例rov的name属性，因为Dog是引用类型，这种改变也会影响到fido，因为它们指向同一个对象：
var fido = Dog() // Dog is a class debugPrint(fido.name) // Fido var rov = fido // assignment! rov.name = &amp;#34;Rover&amp;#34; debugPrint(fido.name) // Rover 在基于对象的编程世界中，产生对同一实例的多个引用的能力是非常重要的，因为在这个世界中，对象会持续存在，并且可以有与之一起持续存在的属性。
如果对象A和对象B都是长期存在的，如果它们都有一个属性为Dog类型，并且Dog是一个类。如果它们都指向同一个Dog实例，那么对象A或对象B都可以改变它们指向的Dog实例，而这种改变将会同时影响A和B。因此，对于类来说，你可能正抓着一个对象，却发现它已经被别人改变了，如果这种情况意外发生，会使你的程序进入无效状态。
因此，应该尽可能地选择一个值类型（如结构体）而不是“引用”类型（类）。结构实例不在引用之间共享，因此不必担心实例被其他突然改变。结构体的存储和内存管理也要简单得多，并且值类型也更容易推理。Swift语言本身会帮助你，在许多Cocoa Foundation的引用类型面前强加值类型。Objective-C的NSDate和NSData是类，但Swift会引导使用结构类型Date和Data来代替。
类实例的传递非常有效，因为所传递的只是一个指针。无论一个类的实例有多大、多复杂，无论它有多少包含大量数据的属性，传递实例都是非常快速和高效的。
一个类的API可以拒绝对该类进行原地改变。Cocoa的NSString、NSArray、NSDictionary、NSDate、NSIndexSet、NSParagraphStyle等等都是这样的，因为它们在设计上是不可变的。
两个对象可以持有对同一个NSArray的引用而不用担心它在他们背后被改变，这不是因为它是一个值类型，而是因为它是不可变的。实际上，这种架构结合了值类型的易用性和引用类型的指针效率。
subclass and superclass 在Swift中，一个类可能会有多个子类，但一个类至多有一个直接父类。在Cocoa中，实际上只有一个root class&amp;ndash;NSObject，它首先体现了一个类成为一个类所必需的所有功能，而所有其它类在某种程度上都是这个基类的子类。
在类的声明前面加上final关键字可以防止其他类来继承。子类化不仅可以继承父类的方法，也可以自定义方法。下面定义的Dog不仅继承了walk()方法，而且自定义了bark()方法:
class Quadruped {  func walk() {  debugPrint(&amp;#34;walk walk walk&amp;#34;)  } }  class Dog: Quadruped {  func bark() {  debugPrint(&amp;#34;woof&amp;#34;)  } }  let fido = Dog() fido.walk() fido.bark() 无论方法是在类中自定义的，还是从父类中继承的，都有同样的效果。下面代码中Dog继承了Quadruped的walk方法，调用的时候没有差别：
class Quadruped {  func walk() {  debugPrint(&amp;#34;walk walk walk&amp;#34;)  } }  class Dog: Quadruped {  func bark() {  debugPrint(&amp;#34;woof&amp;#34;)  }   func walkAndBark() {  self.walk()  self.bark()  } }  let fido = Dog() fido.walk() fido.bark() fido.walkAndBark() 在Swift中允许对从父类继承的方法进行重定义（也被称为覆写，重写），需要在重定义的方法前添加override关键字。下面代码对Dog继承了Quadruped的walk方法进行了重写：
class Quadruped {  func walk() {  debugPrint(&amp;#34;walk walk walk&amp;#34;)  } }  class Dog: Quadruped {  func bark() {  debugPrint(&amp;#34;woof&amp;#34;)  }   func walkAndBark() {  self.walk()  self.bark()  }   override func walk() {  debugPrint(&amp;#34;dog walk&amp;#34;)  } }  class NoisyDog: Dog {  override func bark() {  debugPrint(&amp;#34;woof woof woof&amp;#34;)  } } 一个与父类同名的方法不一定是override，在Swift中两个同名的函数是通过签名来区别的。只有当子类重新定义它从父类继承的同一个方法时才存在覆盖的情况：相同的名称，包括外部参数名称，以及相同的签名。
但是，override一个方法并不需要和被覆盖的父类方法有完全相同的签名。在覆盖一个方法时，参数的类型可以用父类来代替。下面的代码中，Kitten是Cat的子类，因此代码是合法的：
class Cat {  // }  class Kitten: Cat {  // }  class Dog {  func barkAt(cat: Kitten) {  //  } }  class NoisyDog: Dog {  override func barkAt(cat: Cat) {  //  } } 在override时用一个Optional父类的参数也是合法的。即在NoisyDog中覆盖barkAt时，参数cat的类型可以是Cat或者Cat?：
class NoisyDog: Dog {  override func barkAt(cat: Cat?) {  //  } } 此外，在override时，一个参数可以用对应的Optional来覆盖。在下面的代码中，Dog中定义的方法barkAt参数类型为Cat，而在NoisyDog中override时参数为Cat?也是合法的：
class Dog {  func barkAt(cat: Cat) {  //  } }  class NoisyDog: Dog {  override func barkAt(cat: Cat?) {  //  } } 而一个Optional的参数可以用其父类的Optional来覆盖。下面的代码中，使用override时Kitten?类型可以使用Cat?：
class Dog {  func barkAt(cat: Kitten?) {  //  } }  class NoisyDog: Dog {  override func barkAt(cat: Cat?) {  //  } } 一个下标函数是一个方法。如果一个父类声明了一个下标，子类可以声明一个具有相同签名的下标，只要它用override关键字来指定它。为了调用父类的下标实现，子类可以在关键字super后面使用方括号（例如：super[3]）。
class initializers 由于类的继承性，类实例的初始化比结构或枚举实例的初始化要复杂得多。初始化器的主要任务是确保所有的属性都有一个初始值。初始化器可能还有其他任务要执行，这些任务对这个实例的初始状态和完整性至关重要。
然而，一个类可能有一个父类，它可能有自己的属性和初始化器。因此，必须以某种方式确保当一个子类被初始化时，其父类的属性被初始化，除了子类本身的任务外，其初始化器的任务也被按部就班地执行。
类的初始化分为两类：Designated initializer和Convenience initializer。类的初始化器默认为Designated initializer。Designated initializer初始化器必须保证所有的存储属性都被初始化。它不能委托给同一个类中的另一个初始化器，一个指定的初始化器使用self.init(...)是非法的。
一个有任何存储属性的类，如果没有作为其声明的一部分被初始化，必须至少有一个明确的指定初始化器。一个没有存储属性的类，或者所有存储属性都作为声明的一部分被初始化的类，如果没有显式指定的初始化器，就有一个隐式的指定初始化器init()。
如果类的初始化器在声明的时候使用关键字convenience标记，那么它就是Convenience initializer。一个便利初始化器是一个委托初始化器，它必须包含self.init(...)，它必须调用同一个类中的指定初始化器。或者如果它调用同一个类中的另一个便利初始化器，便利初始化器链必须以调用同一个类中的指定初始化器结束。
下面定义的类class没有存储属性，并且未自定义初始化器，此时此编译器自动生成了一个无参的init()，因此使用Dog()不会出现编译错误：
class Dog {  // } let dog = Dog() 如果类的所有存储属性在声明的时候都有初始值，并且如果未自定义任何初始化器，编译器也会生成一个无参初始化器init()：
class Dog {  var name = &amp;#34;Fido&amp;#34; }  let dog = Dog() 在下面的例子中，虽然所有的存储属性都已经在声明的时候初始化了，但是已经有一个自定义的Designated initializer，那么就不会生成无参的初始化器init():
class Dog {  var name = &amp;#34;Fido&amp;#34;  init(name: String) {  self.name = name  } }  let dog = Dog() //compile error 在下面的例子中，所有的存储属性都有默认值，并且自定义了一个Convenience initializer，但无任何Designated initializer。此时，仍然会自动生成一个无参的init():
class Dog {  var name = &amp;#34;Fido&amp;#34;  convenience init(name: String) {  self.init() //默认的无参初始化器  self.name = name  } }  let dog1 = Dog(name: &amp;#34;Rover&amp;#34;) let dog2 = Dog() 也就是说，当一个类中无Designated initializer，但存在有参的Convenience initializer时，编译器会自动生成一个无参的init()。同时还要注意的是，不能再声明一个无参的便利初始化器convenience init()，否则将会出现编译错误:
class Dog {  var name = &amp;#34;Fido&amp;#34;  // Invalid redeclaration of synthesized &amp;#39;init()&amp;#39;  convenience init() {  //   } } 如果类的存储属性在声明的时候并未全部初始化，并且如果有自定义的Designated initializer。那么,在所有自定义的初始器中必须将所有存储属性都初始化：
class Dog {  var name: String  var license: Int   init(name: String, license: Int) {  self.name = name  self.license = license  } }  let dog = Dog(name: &amp;#34;Rover&amp;#34;, license: 42) 类的Designated initializer和Convenience initializer有较大的区别：
  一个指定的初始化器中除非为了初始化一个属性（或获取一个已经被初始化的属性的值），否则在这个类的所有属性都被初始化之前不能隐式或显式地使用self。
  一个便利初始化器是一个委托初始化器，所以在它直接或间接地调用一个指定初始化器之前，在其中不能出于任何目的使用self（也不能设置一个常量属性）。
  class Dog {  var name: String  var license: Int   init(name: String, license: Int) {  self.name = name  self.license = license  }   convenience init(license: Int) {  self.init(name: &amp;#34;Fido&amp;#34;, license: license)  }   convenience init() {  self.init(license: 1)  } }  let dog = Dog() 上面明确了Designated initializer和Convenience initializer的区别，在子类的初始化时，也有一些需要注意的地方：
  如果一个子类不需要自定义的初始化器，那么它的初始化器都继承自它的父类。此时子类是否有隐藏的无参初始化器init()，取决于它的父类是否有init()。
  如果一个子类尚无自定义的初始化器，则它可以声明Convenience initializer。子类的便利初始化器的工作方式与父类便利初始化器的工作方式完全一样。因为子类继承了父类的指定初始化器，便利初始化器必须通过使用self.init(...)来调用初始化器。
  class Dog {  var name: String  var license: Int   init(name: String, license: Int) {  self.name = name  self.license = license  }   convenience init(license: Int) {  self.init(name: &amp;#34;Fido&amp;#34;, license: license)  }   convenience init() {  self.init(license: 1)  }  }  class MyDog: Dog {  convenience init() {  self.init(license: 1)  // super.init(name: &amp;#34;test&amp;#34;, license: 1) // compile error  } }  如果一个子类声明了任何自己的Designated initializer，那么将不会继承任何来自父类的初始化器。并且在子类自定义的每个Designated initializer都必须调用一个父类的Designated initializer（通过使用super.init(...)实现）。  class Dog {  var name: String  var license: Int   init(name: String, license: Int) {  self.name = name  self.license = license  }   convenience init(license: Int) {  self.init(name: &amp;#34;Fido&amp;#34;, license: license)  }   convenience init() {  self.init(license: 1)  }  }  class MyDog: Dog {  init(name: String) {  // self.init(license: 1) // compile error  super.init(name: name, license: 1)  } }  let dog = Dog() 子类的Designated initializer中，必须按如下顺序进行初始化：
  必须确保自己的所有的属性都被初始化。
  接着必须调用super.init()。
  最后才能使用self继承自父类的实例方法或属性。
  class MyDog: Dog {  init(name: String) {  // self.name = &amp;#34;test&amp;#34; // compile error  super.init(name: &amp;#34;name&amp;#34;, license: 1)  } } 如果一个子类既有Designated initializer又有Convenience initializer。那么在便利初始化器中必须使用self.init()来直接或者间接调用Designated initializer。
子类也可以重写父类的初始化器。一个初始化器的参数与父类的方便初始化器相匹配时，子类的初始化器可以是指定的初始化器或便利初始化器，并且不被标记为override。
class Dog {  var name: String  var license: Int   init(name: String, license: Int) {  self.name = name  self.license = license  }   convenience init(license: Int) {  self.init(name: &amp;#34;Fido&amp;#34;, license: license)  }   convenience init() {  self.init(license: 1)  }  }  class MyDog: Dog {  init(license: Int) {  super.init(name: &amp;#34;name&amp;#34;, license: 1)  }  // 或者  //convenience init(license: Int) {  // self.init(license: 1)  //} } 子类的初始化器参数与父类的指定初始化器相匹配时，子类的初始化器可以是指定的初始化器或方便初始化器，并且必须标记为override。并且override的指定初始化器必须通过super.init(...)调用父类的指定初始化器。
如果一个子类override父类所有的指定初始化器，那么子类将继承父类所有的便利初始化器(这是一个例外，因为一个子类有任何指定的初始化器，则不继承初始化器)。
下面的代码是合法的，因为类NoiseDog继承了Dog的所有初始化器。但是不能使用let nd3=NoiseDog()，因为Dog里没有init()。
class Dog {  var name: String  var license: Int   init(name: String, license: Int) {  self.name = name  self.license = license  }   convenience init(license: Int) {  self.init(name: &amp;#34;Fido&amp;#34;, license: license)  }  }  class NoisyDog: Dog { }  let nd1 = NoisyDog(name: &amp;#34;Fido&amp;#34;, license: 1) let nd2 = NoisyDog(license: 2) 在下面的代码中，因为NoiseDog没有指定初始化器，只有便利初始化器，所以它继承了Dog的所有初始化器。因此，在便利初始化器中调用self.init(name: &amp;quot;Fido&amp;quot;, license: license)也是合法的：
class Dog {  var name: String  var license: Int   init(name: String, license: Int) {  self.name = name  self.license = license  }   convenience init(license: Int) {  self.init(name: &amp;#34;Fido&amp;#34;, license: license)  } }  class NoisyDog: Dog {  convenience init(name: String) {  self.init(name: name, license: 1)  } } 在下面的代码中，因为NoisyDog声明了指定初始化器，因此不再继承父类Dog的所有初始化器。如果调用父类的指定初始化器需要使用super：
class Dog {  var name: String  var license: Int   init(name: String, license: Int) {  self.name = name  self.license = license  }   convenience init(license: Int) {  self.init(name: &amp;#34;Fido&amp;#34;, license: license)  } }  class NoisyDog: Dog {  init(name: String) {  super.init(name: name, license: 1)  } } 在下面的例子中，因为NoiseDog已经覆写父类Dog的所有designated initializers，所以它继承了父类的convenience initializers，所以它能调用NoisyDog(license:2)：
class Dog {  var name: String  var license: Int   init(name: String, license: Int) {  self.name = name  self.license = license  }   convenience init(license: Int) {  self.init(name: &amp;#34;Fido&amp;#34;, license: license)  }  }  class NoisyDog: Dog {  override init(name: String, license: Int) {  super.init(name: name, license: license)  } } let nd1 = NoisyDog(name:&amp;#34;Rover&amp;#34;, license:1) let nd2 = NoisyDog(license:2) 一个类的初始化器前面可以有一个关键字required，这意味着一个子类不能缺少这个初始化器。这又意味着，如果一个子类实现了指定初始化器，从而阻断了继承，它必须覆写这个初始化器，并标记为required。在下面的例子中，如果NoisyDog中的初始化器required init(name: String)缺少关键字required将会出现编译错误。
class Dog {  var name: String  required init(name: String) {  self.name = name  } }  class NoisyDog: Dog {  var obedient = false  init(obedient: Bool) {  self.obedient = obedient  super.init(name: &amp;#34;Fido&amp;#34;)  }   required init(name: String) {  super.init(name: name)  } } 在上面的代码中，虽然在NoisyDog中已经覆写了init(name: String)，但并未标记为override，而是标记了为了required，这是因为&#39;override&#39; is implied when overriding a required initializer。并且required保证了向下传递。
class deinitializer 类的Deinitializer是用关键字deinit声明的函数，后面是包含函数主体的花括号。不能手动调用这个函数，当这个类的一个实例不存在时，它将会自动被调用。如果一个类有一个父类，子类的deinit会在父类的deinit之前被调用。
只有类有deinit方法，struct和enum没有deinit方法，这是因为类是一种引用类型。我们的想法是，你可能想进行一些清理。类的deinit的另一个好用途是记录到控制台，向你自己证明你的实例是以良好的秩序消失的。在deinit过程中，属性观察者不被调用。
class properties 子类可以覆写继承父类的属性，此时必须保持和父类属性同名以及同类型，而且必须使用override标记。覆写的属性不能为存储属性，更具体地说：
  如果父类的属性是可写的（一个存储属性或者有setter的计算属性），子类的覆写可以包括为这个属性添加设置器观察者。
  或者子类覆写可以是计算属性。（1）如果父类的属性是存储的，那么子类使用计算属性来覆写时，一定要同时有getter和setter。（2）如果父类的属性是计算的，那么子类覆写的计算属性，至少需要getter（如果父类的计算属性有setter那么子类重写的方法必须有setter；如果父类的计算属性没有setter，那么子类可以添加一个）。
  覆写属性的函数可以通过super关键字对继承的属性进行读写。
Static/Class Members 一个类可以有静态成员，标记为static，就像一个结构或枚举。它也可以有类成员，标记为class。静态成员和类成员都可以被子类所继承。
静态方法和类方法的主要区别在于，静态方法不能被重写，就好像静态方法是class final的同义词一样。下面的代码会编译报错，并提示Cannot override static method：
class Dog {  static func whatDogsSay() -&amp;gt; String {  return &amp;#34;woof&amp;#34;  }   func bark() {  debugPrint(Dog.whatDogsSay())  } }  class NoisyDog: Dog {  override static func whatDogsSay() -&amp;gt; String {  return &amp;#34;noisy&amp;#34;  } } 在上面的代码中，任何继承Dog的子类都会继承它的静态方法whatDogsSay，但是不能包含任何具有相同签名的静态方法或者类方法。但如果在Dog中使用class来声明whatDogsSay，则可以在子类中override：
class Dog {  class func whatDogsSay() -&amp;gt; String {  return &amp;#34;woof&amp;#34;  }   func bark() {  debugPrint(Dog.whatDogsSay())  } }  class NoisyDog: Dog {  override static func whatDogsSay() -&amp;gt; String {  return &amp;#34;noisy&amp;#34;  } }  // 或者 class Dog {  class func whatDogsSay() -&amp;gt; String {  return &amp;#34;woof&amp;#34;  }   func bark() {  debugPrint(Dog.whatDogsSay())  } }  class NoisyDog: Dog {  override class func whatDogsSay() -&amp;gt; String {  return &amp;#34;noisy&amp;#34;  } } 静态属性和类属性的区别类似于静态方法和类方法的区别。但有一个额外的、相当戏剧性的限定：静态属性可以被存储，但类属性必须是一个计算的属性。
class Dog {  static var whatDogsSay = &amp;#34;woof&amp;#34;  func bark() {  debugPrint(Dog.whatDogsSay)  } } 上面定义的Dog有静态的存储属性，但是它不能被任何子类所override。如果要能被子类覆写，那么必须使用class来声明，并且必须声明为计算属性：
class Dog {  class var whatDogsSay: String {  return &amp;#34;woof&amp;#34;  }   func bark() {  debugPrint(Dog.whatDogsSay)  } }  class NoisyDog: Dog {  override static var whatDogsSay: String {  return &amp;#34;WOOF&amp;#34;  } } 多态 替换原则：声明类的引用时指定某种类型，但实际的对象可能是该类型的一个子类。在下面的代码中，dog虽然声明为Dog类型，但是赋值给它的是Dog的子类NoisyDog的实例：
class Dog {  // }  class NoisyDog: Dog {  // }  let dog: Dog = NoisyDog() 内部身份规则：一个对象的实际类型是其内部性质的问题，与该对象如何被提及无关。也就是说，当一个消息被发送时，重要的不是该消息的接收者是如何通过这个或那个引用被输入的，而是该接收者实际上是什么类型。在下面的代码中虽然tellToBark函数期望的类型为Dog，但实际传递的是NoisyDog类型实例，因此调用bark方法时，调用的是NoisyDog的bark方法：
class Dog {  func bark() {  debugPrint(&amp;#34;woof&amp;#34;)  } }  class NoisyDog: Dog {  override func bark() {  for _ in 1...3 {  super.bark()  }  } }  func tellToBark(_ d: Dog) {  d.bark() }  var nd = NoisyDog() tellToBark(nd) // woof woof woof 关键词self的含义是多态性的另一个重要体现。self的含义取决于实际实例的类型，即使self这个词出现在父的代码中。在下面代码中，在Dog中的speak方法中使用self调用了bark方法，因为NoiseDog继承自Dog，所以也继承了speak方法，又因为它覆写了bark，所以speak中调用的bark变成了NosieDog中的bark方法：
class Dog {  func bark() {  debugPrint(&amp;#34;woof&amp;#34;)  }   func speak() {  self.bark()  } }  class NoisyDog: Dog {  override func bark() {  for _ in 1...3 {  super.bark()  }  } } let nd = NoisyDog() nd.speak() // woof woof woof 多态对于可选类型也是适用的。假设有一个Optional类型的引用，包裹着Dog。你已经知道可以给它赋值Dog的实例，也可以赋值NoisyDog的实例：
var dog : Dog? dog = Dog() dog = NoisyDog() dog = Optional(NoisyDog()) 多态性很酷，但从总体上看，它也是比较慢的，因为它需要动态调度，这意味着编译器不能进行某些优化，而且运行时必须考虑给类实例的信息意味着什么。可以通过声明一个类或一个类成员为final或private来减少对动态调度的需求。或者使用一个结构，结构不需要动态调度。
Casting Swift是一种严格类型的语言，允许向对象引用发送的消息取决于引用的类型。但是，多态性的内部身份原则说，一个对象可能有一个不同于其引用的声明类型的实际类型。在下面的代码中，在tellToHush中调用beQuit是非法的，会出现Value of type &#39;Dog&#39; has no member &#39;beQuiet&#39;报错信息：
class Dog {  func bark() {  debugPrint(&amp;#34;woof&amp;#34;)  } }  class NoisyDog: Dog {  override func bark() {  super.bark()  }   func beQuiet() {  self.bark()  } }  func tellToHush(_ d: Dog) {  d.beQuiet() // compile error  } 上面的代码编译报错是因为Dog类型中没有beQuiet方法，该方法是子类NoisyDog特有的。而当将NoisyDog实例传给tellToHush时，实际上可以使用beQuiet方法：
func tellToHush(_ d: Dog) {  let d = d as! NoisyDog // crash   d.beQuiet() } 在上面的例子中，相当于告诉编译器，对象d可能是NoiseDog类型的，但是使用as!可能会发生崩溃，因为d不一定是NoiseDog类型。也可以先使用关键字is来判断是否为NoiseDog类型，然后使用as!; 或者使用as?进行转换，或者使用if let ：
func tellToHush(_ d: Dog) {  if d is NoisyDog {  let d = d as! NoisyDog  d.beQuiet()  } }  func tellToHush(_ d: Dog) {  let d = d as? NoisyDog // an Optional wrapping a NoisyDog   if d != nil {  d!.beQuiet()  } }  func tellToHush(_ d: Dog) {  let d = d as? NoisyDog // an Optional wrapping a NoisyDog   d?.beQuiet() }  func tellToHush(_ d: Dog) {  (d as? NoisyDog)?.beQuiet() }  func tellToHush(_ d: Dog) {  if let d = d as? NoisyDog {  d.beQuiet()  } } 对于is, as!和as?操作符来说，它们对于Optional类型的工作方式与==比较操作符相同：会自动解包Optional对象，然后进行比较：
func test() {  let dog: Dog? = NoisyDog()  if dog is NoisyDog {  debugPrint(&amp;#34;true&amp;#34;)  } } 在上面的例子中，is关键字首先检查dog是否为nil，如果dog不为nil，则检查dog包裹的类型是否为NoiseDog。
可以对一个optional类型使用as!操作符。当as!操作符左边是一个optional类型时，Swift会先解包，然后再进行转换，下面这段代码是有效的：
let dog1: Dog? = NoisyDog() let dog2 = dog1 as! NoisyDog dog2.beQuiet() 但是上面的代码是不安全的，如果dog1为nil或者执行Dog类型的实例，则dog1 as! NoisyDog转换失败而发生崩溃，使用as?会更安全：
let dog1: Dog? = NoisyDog() let dog2 = dog1 as? NoisyDog dog2?.beQuiet() 在上面的代码中，as?首先会检查dog1是为nil，如果为nil则dog2的结果为nil。如果dog1不为nil，但不是NoisyDog的实例，则转换失败，dog2为nil，否则转换成功，dog2为NoisyDog?。
使用强制转换的另一种方式是当Swift和Objective-C两种类型等效时进行值交换。例如，可以将Swift String 转换为Cocoa NSString，反之亦然。这不是因为一个是另一个的子类，而是因为它们是相互桥接的；在非常真实的意义上，它们是同一种类型。当从String转换为NSString时，不是向下转换，并且所做的事情并不危险，因此使用as运算符，没有感叹号或问号。
一般来说，要从Swift类型过渡到桥接的Objective-C类型，需要显式转换（字符串文字常量除外。在下面的代码中，Swift的String类型和Objective-C的NSString等价，Int和NSNumber等价：
let s : NSString = &amp;#34;howdy&amp;#34; // string literal to NSString let s2 = &amp;#34;howdy&amp;#34; let s3 : NSString = s2 as NSString // String to NSString let i : NSNumber = 1 as NSNumber // Int to NSNumber 上面的这种代码是相当人为的。在现实生活中，不会经常进行强制转换，因为Cocoa API会以Swift类型的形式呈现给出来。这是合法的，没有强制转换：
let name = &amp;#34;MyNib&amp;#34; // Swift String  let vc = ViewController(nibName:name, bundle:nil) 类UIViewController来自于Cocoa，它的NibName属性是Objective-C的NSString类型，而不是Swift字符串。但不必通过强制转换来帮助Swift String name过桥，因为在Swift世界中，nibName:被输入为一个Swift String（实际上是一个可选字符串）：
 public init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) 在下面的代码中，不必通过强制转换来帮助Swift String类型的s桥接，因为set(_:forKey:)的第一个参数为Swift的Any类型（实际上是一个Optional包装的Any）：
let ud = UserDefaults.standard let s = &amp;#34;howdy&amp;#34; ud.set(s, forKey: &amp;#34;greeting&amp;#34;) 反过来说，你有可能从Objective-C收到一个值，而Swift并不了解这个值的真正底层类型。在这种情况下，你可能希望显式转换为底层类型：
let ud = UserDefaults.standard let test = ud.object(forKey:&amp;#34;greeting&amp;#34;) as! String 当调用ud.object(forKey:)时，Swift并不知道真正的底层类型信息，因为结果是一个Any（实际上是一个包裹Any的Optional）。但是我们知道这个特定的调用应该产生一个字符串&amp;ndash;因为那是一开始就输入的东西。所以我们可以把这个值强行转换为一个字符串&amp;ndash;而且它还能工作。然而，如果ud.object(forKey: &amp;quot;greeting&amp;quot;)不是一个字符串（或者它是nil），就会发生崩溃。如果你不确定你的立场，为了安全起见，使用is或as?。
Type References 有时我们获取到了一个实例，此时并知道这个实例的类型，可能只是出于调试目的将其类型记录到控制台，或者可能需要使用类型作为值。此时，可以使用全局函数type(of:)：
let dogTest: Dog = NoisyDog() debugPrint(type(of: dogTest)) // xxx.NoisyDog 对于一个实例来说，能够引用它自己的类型尤为重要。通常，这是为了向该类型发送消息。例如，假设一个实例想要向它的类发送一个类消息。在前面的例子中，Dog实例方法通过向Dog类型发送消息来获取Dog类属性，实际上就是使用Dog这个词：
class Dog {   class var whatDogsSay: String {  return &amp;#34;woof&amp;#34;  }   func bark() {  debugPrint(Dog.whatDogsSay)  } } 表达式Dog.whatDogsSay看起来笨拙并且不灵活，它在一个类型当中，按理说应该知道它是什么。可以使用关键字Self（首字母大写大）来引用当前类型——self的类型:
class Dog {   class var whatDogsSay: String {  return &amp;#34;woof&amp;#34;  }   func bark() {  debugPrint(Self.whatDogsSay)  } } 在代码中使用Self而不是具体的类型名字，不仅是因为更简单，而且它更强大，因为Self和self一样，也遵循多态性。在下面的代码中，当NoisyDog类型的实例调用bark时，它的Self就是NoisyDog。因此，取到的whatDogsSay就是&amp;quot;woof woof woof&amp;quot;。
class NoisyDog: Dog {  override class var whatDogsSay: String {  return &amp;#34;woof woof woof&amp;#34;  } }  let dogTest: Dog = NoisyDog() debugPrint(type(of: dogTest)) // xxx.NoisyDog debugPrint(dogTest.bark()) // &amp;#34;woof woof woof&amp;#34; Self是Swift 5.1引入的，在那之前只能使用type(of:self)。多态Self的另一个重要用途是作为返回类型。为了说明为什么这很有价值，将介绍工厂方法的概念。
class NewDog {  var name: String   init(name: String) {  self.name = name  }  class func makeAndName() -&amp;gt; NewDog {  let d = Self(name: &amp;#34;Fido&amp;#34;) // compile error   return d  } } 上面的代码会发生编译错误，这是因为编译器怀疑init(name:)初始化器对于NewDog的每个可能的子类型实现。为了让它放心，我们必须使用required关键字声明该初始化器：
class NewDog {  var name: String   required init(name: String) {  self.name = name  }   class func makeAndName() -&amp;gt; NewDog {  let d = Self(name: &amp;#34;Fido&amp;#34;) // compile error  return d  } }  class NewNoisyDog: NewDog {  // } required声明可以让编译器放心: NewDog的每个子类都必须继承或重新实现init(name:)，所以在一个可能指向Dog或Dog的某个子类的类型引用上调用init(name:)信息是合法的。
let newDog1 = NewDog.makeAndName() // d is a Dog named Fido let newDog2 = NewNoisyDog.makeAndName() // d2 is a NoisyDog named Fido 但是上面的代码还有外一个问题，尽管newDog2事实上是NewNoisyDog，但是makeAndName返回的是NewDog。实际上我们要声明这个方法返回一个与最初发送makeAndName消息的类相同类型的实例。换句话说，我们需要一个多态的类型声明，可以使用Self:
class NewDog {  var name: String   required init(name: String) {  self.name = name  }   class func makeAndName() -&amp;gt; Self {  let d = Self(name: &amp;#34;Fido&amp;#34;) // compile error  return d  } }  class NewNoisyDog: NewDog {  // }  let newDog1 = NewDog.makeAndName() // d is a Dog named Fido let newDog2 = NewNoisyDog.makeAndName() // d2 is a NoisyDog named Fido  debugPrint(type(of: newDog2)) Self类型作为返回类型时表示这是运行时任何类型的实例，因此当NewNoisyDog调用NewNoisyDog.makeAndName()得到的是NewNoisyDog实例。Self也可以用户实例方法的声明中。因此，可以编写工厂方法的实例方法版本。
class NewDog {  var name: String   required init(name: String) {  self.name = name  }   class func makeAndName() -&amp;gt; Self {  let d = Self(name: &amp;#34;Fido&amp;#34;) // compile error  return d  }   func havePuppy(name: String) -&amp;gt; Self {  return Self(name: name)  } }  class NewNoisyDog: NewDog {  // }  let newDog1 = NewDog.makeAndName() // d is a Dog named Fido let newDog2 = NewNoisyDog.makeAndName() // d2 is a NoisyDog named Fido  debugPrint(type(of: newDog2))  let newDog11 = newDog1.havePuppy(name: &amp;#34;test1&amp;#34;) let newDog22 = newDog2.havePuppy(name: &amp;#34;test2&amp;#34;)  debugPrint(type(of: newDog11)) debugPrint(type(of: newDog22)) 在某些情况下，可能希望将对象类型视为值，那是合法的。对象类型本身就是一种对象，这就是Swift所说的元类型。因此对象类型可以分配给变量或作为参数传递：
  声明一个对象的类型是可以接受的。如在声明一个变量或参数的类型时&amp;ndash;使用点状符号与类型的名称和关键字Type。
  使用一个对象类型作为一个值。比如当把一个类型分配给一个变量或作为一个参数传递时，把对象交给type(of:)，或者用类型的名称和关键字self来点注。(在后一种情况下，类型的名称可能是Self，在这种情况下，可以使用Self.self)。
  func dogTypeExpecter(_ whatType: NewDog.Type) {  debugPrint(whatType) }  dogTypeExpecter(NewDog.self) let dog = NewDog(name: &amp;#34;test&amp;#34;) dogTypeExpecter(type(of: dog)) dogTypeExpecter(NewNoisyDog.self) 为了更实际地说明问题，将把Dog工厂方法重写为一个全局工厂函数，它将接受一个Dog类型作为参数，并从该类型创建一个实例。可以使用一个类型的变量引用（元类型）来实例化该类型，但不能只是在一个变量引用上加上括号，必须使用init方法：
func dogMakerAndNamer(_ whatType: NewDog.Type) -&amp;gt; NewDog {  let d = whatType(name: &amp;#34;Fido&amp;#34;) // compile error: Initializing from a metatype value must reference &amp;#39;init&amp;#39; explicitly  return d }  func dogMakerAndNamer(_ whatType: NewDog.Type) -&amp;gt; NewDog {  let d = whatType.init(name: &amp;#34;Fido&amp;#34;)  return d }  let d11 = dogMakerAndNamer(NewDog.self) // d11 is a Dog named Fido  let d12 = dogMakerAndNamer(NewNoisyDog.self) // d12 is a NoisyDog named Fido 不幸的是，即使底层的真正类型是NewNoisyDog，全局工厂函数dogMakerAndNamer返回的也是一个NewDog对象。因为是全局函数，这里不能使用Self来解决这个问题，但是可以使用泛型。
 type(of:)应用于一个对象：对象的多态（内部）类型，与引用的类型无关。 Self：在方法主体中，或者在方法声明中指定返回类型时，这个类型或这个实例的类型，多态性。 .Type：附加在类型声明中的一个类型上，以指定该类型本身（或一个子类型）被期望。 .self：发送给一个类型以生成一个元类型，适合于传递一个类型（.Type）被期望的地方。  Comparing Types 类型引用之间可以相互比较。在==比较符的右边，可以用.self来表示一个类型的名称。而在is关键字的右边，可以用.Type来表示一个类型的名称。区别在于：==操作符测试的是绝对相同的类型，而is则允许子类型。
func dogTypeExpecter(_ whatType: NewDog.Type) {  debugPrint(whatType)  let equality = whatType == NewDog.self  let typology = whatType is NewDog.Type  debugPrint(equality,typology) }  dogTypeExpecter(NewDog.self) // true,true let dog = NewDog(name: &amp;#34;test&amp;#34;) dogTypeExpecter(type(of: dog)) // true,true dogTypeExpecter(NewNoisyDog.self) // false, true 在上面的例子中，whatType放在比较操作符的左边，它可能被type(of:)替换，或者.self替换。同时==操作符右边的NewDog.self也可能被whatType和type(of:)替换。但是is关键字的右边不能出现whatType和type(of:)。
debugPrint(type(of: dog) == NewDog.self, type(of: dog) == NewNoisyDog.self) // true,false available属性 有个类涉及到的属性只能在iOS 13.0以上系统使用，为了将该类定义为其它类的属性，必须加上available和lazy：
@available(iOS 13.0, *) class HapticManager { } class VibrationService {  @available(iOS 13.0, *)  private(set) lazy var hapticManager = HapticManager() } xcframework xcodebuild clean archive -workspace CMBMPGMK.xcworkspace -scheme CMBMPGMK -configuration release -sdk iphoneos -destination &amp;#39;generic/platform=iOS&amp;#39; -archivePath &amp;#39;./build/iphonedevice.xcarchive&amp;#39; SKIP_INSTALL=NO BUILD_LIBRARIES_FOR_DISTRIBUTION=YES   xcodebuild clean archive -workspace CMBMPGMK.xcworkspace -scheme CMBMPGMK -configuration release -sdk iphonesimulator -destination &amp;#39;generic/platform=iOS Simulator&amp;#39; -archivePath &amp;#39;./build/iphonesimulator.xcarchive&amp;#39; SKIP_INSTALL=NO BUILD_LIBRARIES_FOR_DISTRIBUTION=YES   xcodebuild -create-xcframework -framework ./iphonesimulator.xcarchive/Products/Library/Frameworks/CMBMPGMK.framework -framework ./iphonedevice.xcarchive/Products/Library/Frameworks/CMBMPGMK.framework -output CMBMPGMK.xcframework  静态库 BUILD_LIBRARIES_FOR_DISTRIBUTION=YES 头文件放到public，以及要将头文件放出来 bitcode=no exclude simulator arm64  </content>
    </entry>
    
     <entry>
        <title>Swift协议</title>
        <url>https://iihui.github.io/post/ios-protocol/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  2015年苹果声称Swift是第一个面向协议的编程语言。从它的名字来看，很可能会认为面向协议编程都是关于协议的，但这是不正确的。面向协议的编程所涉及的不仅仅是协议，它实际上是一种新的方式，不仅是编写应用程序，而且是我们如何思考应用程序的设计。
 协议使用protocol关键字来定义，其定义语法类似于class,struct,enum等类型。下面代码定义了BaseProtocol协议，它只包含一个baseFunc方法：
protocol BaseProtocol {  func baseFunc() } 协议中的属性 定义协议时可以要求adopting协议的类型提供特定名字和特定类型的属性，但对于adopting协议的类型定义的是计算属性还是存储属性并没有要求。下面定义的FullNameProtocol协议包含了两个属性：
protocol FullNameProtocol {  var firstName: String { get set }  var lastName: String { get set } } 上面定义的两个属性firstName和lastName，都是读写属性。如果想要定义只读属性，则只需声明get，去掉set关键字即可：
protocol ReadOnlyProtocol {  var readOnly: String { get } } 协议中也可以定义静态属性，只需要在属性名的最前面添加static关键字。下面定义的StaticProtocol协议中添加了一个静态只读属性staticProperty:
protocol StaticProtocol {  static var staticProperty: String { get } } 协议中的方法 在协议定义时可以要求adopting协议的类型提供特定的方法。在协议中定义方法和在class,struct中声明方法有点相似，但不需要花括号和函数体：
protocol FullNameProtocol {  func getFullName() -&amp;gt; String } 可选属性或方法 如果要定义一个属性或者方法是可选实现的，首先需要在协议定义前添加@objc关键字，并且在可选的属性或方法前添加@objc optional:
@objc protocol Phone {  var phoneNumber: String { get set }  @objc optional var emailAdress: String { get set }  func dialNumber()  @objc optional func getEmail() -&amp;gt; String } 协议继承 定义协议时可以从一个或多个协议中继承定义的属性和方法，即协议支持多继承，在继承的同时也可以添加自定义的属性和方法。下面代码是协议继承的一个简单例子：
protocol FullName {  var firstName: String { get set }  var lastName: String { get set }   func getFullName() -&amp;gt; String }  protocol Person: FullName {  var age: Int { set get } }  struct student: Person {  var firstName = &amp;#34;firstName&amp;#34;   var lastName = &amp;#34;lastName&amp;#34;   var age = 0  func getFullName() -&amp;gt; String {  return &amp;#34;\(firstName)\(lastName)&amp;#34;  } }  protocol A {  var name: String { get } } protocol B {  var age: Int { get } }  protocol C: A, B {  var hook: String { get } } 协议组合 面向协议编程中有个重要的概念protocol composition（协议组合）。协议组合允许一个类型adopting多个协议，这是相对于类继承的最大优势，因为Swift中的类类型只允许单继承。
struct MyStruct: ProtocolOne, ProtocolTwo, ProtocolThree {  // 实现结构体的定义 } 协议组合允许我们将需求分解成许多较小的组件，而不是从一个协议或单一的父类中继承所有的属性或方法。这使得类型族在宽度上而不是在高度上增长，意味着可以避免创建臃肿的类型（这些类型可能包含一些不需要的属性和方法）。
像类型一样使用协议 尽管协议中没有任何具体实现，但在Swift中，协议仍然被认为是一种成熟的类型，并且大多可以像其他类型一样使用。这意味着，可以将协议作为函数的参数或返回类型，还可以把它们作为变量、常量和集合的类型。
protocol FullName {  var firstName: String { get set }  var lastName: String { get set }   func getFullName() -&amp;gt; String }  protocol Person: FullName {  var age: Int { set get }  var birthDate: Date { get set }  var profession: String { get }  init(firstName: String, lastName: String, birthDate: Date) }  func updatePerson(person: Person) -&amp;gt; Person {  var newPerson: Person  // 在这里更新newPerson  return newPerson } var personArray = [Person]() var personDict = [String: Person]() 协议的多态性 多态这个词来自希腊语的词根poly（意为许多）和morphe（意为形式）。在编程语言中，多态性是指多种类型的单一接口。多态性让我们通过单一的统一接口与多种类型进行交互。在面向对象的编程世界中，单一的统一接口通常来自父类，而在面向协议的编程世界中，这个单一的接口的通常跟协议相关。
struct Student: Person {  var firstName = &amp;#34;&amp;#34;  var lastName = &amp;#34;&amp;#34;  var age = 0  var birthDate: Date  var profession: String = &amp;#34;&amp;#34;   init(firstName: String, lastName: String, birthDate: Date) {  self.firstName = firstName  self.lastName = lastName  self.birthDate = birthDate  }   func getFullName() -&amp;gt; String {  return &amp;#34;\(firstName)\(lastName)&amp;#34;  } }  struct FootballPlayer: Person {  var firstName: String  var lastName: String  var age: Int = 0  var birthDate: Date  var profession: String = &amp;#34;&amp;#34;   init(firstName: String, lastName: String, birthDate: Date) {  self.firstName = firstName  self.lastName = lastName  self.birthDate = birthDate  }   func getFullName() -&amp;gt; String {  return &amp;#34;\(firstName)\(lastName)&amp;#34;  } }  func test() {  var myPerson: Person  myPerson = Student(firstName: &amp;#34;Jon&amp;#34;, lastName: &amp;#34;Hoffman&amp;#34;, birthDate: Date())  myPerson = FootballPlayer(firstName: &amp;#34;Dan&amp;#34;, lastName: &amp;#34;Marino&amp;#34;, birthDate: Date()) } 协议中的关联类型 当定义一个协议时，有时定义一个或多个关联类型是很有用的。关联类型是一个类型占位符，可以在协议中使用它来代替一个类型。实际用于关联类型的类型在协议被实现之前是不被定义的。
关联类型的意思是说：暂时不知道要使用的确切类型。当一个类型采用这个协议时，它才定义实际的类型。关联类型的定义需要使用associatedtype关键字。
假设要为一个队列定义一个协议，我们希望实现该协议的类型能够定义队列包含的实例类型。下面定义的Queue协议有一个关联类型QueueType，在协议中的两个方法都使用了这个关联类型：
protocol Queue {  associatedtype QueueType  mutating func addItem(item: QueueType)  mutating func getItem() -&amp;gt; QueueType?  func count() -&amp;gt; Int } 任何实现Queue协议的类型必须为QueueType占位符指定一个实际的类型，并且必须确保在协议中使用QueueType占位符的地方只使用这个实际的类型：
struct IntQueue: Queue {  var items = [Int]()   mutating func addItem(item: Int) {  items.append(item)  }   mutating func getItem() -&amp;gt; Int? {  if !items.isEmpty() {  return items.remove(at: 0)  } else {  return nil  }  }   func count() -&amp;gt; Int {  return items.count  } } 协议设计 下面定义的RobotMovment协议中有5个方法，每个采用RobotMovment协议的类型都必须全部实现这5个的方法：
protocol RobotMovement {  func forward(speedPercent: Double)  func reverse(speedPercent: Double)  func left(speedPercent: Double)  func right(speedPercent: Double)  func stop() } 如果机器人在二维空间行走，则上面的5个方法已经足够使用。但如果机器人要到三维空间飞行，则需要定义向上和向下的方法：
protocol RobotMovementThreeDimensions: RobotMovement {  func up(speedPercent: Double)  func down(speedPercent: Double) } Protocols 协议是一种表达与其它不相关类型之间共性的方式。例如，由于Bee和Bird都可以飞行，因此Bee对象和Bird对象可能具有共同的特征。因此，定义飞行者Flier类型可能是有用的。问题是在什么意义上，Bee和Bird都可以是飞行者？
一种可能的实现方式是使用类继承。如果Bee和Bird都是类，Flier可能是Bee和Bird的父类。然而，Flier不能成为Bee和Bird的父类可能有其它原因。例如，Bee是一种昆虫，而Bird则不是，但是它们都有飞行的能力。我们需要一个以某种方式跨越类的层次结构，将两个关系较远的类联系在一起。
此外，如果Bee和Bird不是两个类怎么办？在Swift中，这是可能的，因为重要且强大的对象可以是结构而不是类。因为结构体不能继承，所以没有父结构体和子结构体。Bee结构体和Bird结构体如何都是Fliers？
Swift通过使用协议解决了这个问题。协议在Swift中是非常重要，Swift头文件中定义了60多个协议。此外，Objective-C也有协议，Cocoa也大量使用协议。Swift的协议与Objective-C的协议大致对应，并且可以互换。
协议也是对象类型，但是不能实例化一个协议类型。协议声明只是一个轻量级的属性和方法列表，其中的属性没有值，方法没有代码。一个&amp;quot;真正的&amp;quot;对象类型可以正式声明它属于一个协议类型，这被称为adopting协议。一个adopting协议的对象类型承诺要实现协议中列出的属性和方法。
假设成为一名飞行者仅包括实现飞行方法。那么一个Flier协议可以指定必须有一个fly方法。因此，它列出了没有函数体的fly方法，如下所示:
protocol Flier {  func fly() } enum,struct,class甚至另外一个协议都可以adopting当前协议。只需在声明中的名称后的冒号后列出协议即可，如果采用者是具有父类的类，则协议位于父类规范后的逗号之后。
protocol Flier {  func fly() }  struct Bird: Flier {  func fly() {  debugPrint(&amp;#34;fly&amp;#34;)  } } 也许你此时想知道：那又怎样？如果想让一只鸟知道如何飞行，为什么不直接给鸟一种飞行方法而不采用任何协议呢？协议有什么区别？答案与类型有关，协议是一种类型。因此，在声明变量或函数参数的类型时，可以使用Flier作为类型：
func tellToFly(_ f: Flier) {  f.fly() } 因此，协议给了另一种表达类型和子类型概念的方式，多态性也适用。根据替换原则，这里的Flier可以是任何对象类型的实例，只要它adopting了flier协议。它可能是一只鸟，也可能是其它任何东西。如果类型采用了Flier协议，它就可以被传递到期望有Flier的地方。
此外，Flier必须有一个fly方法，这是adopting Flier协议意义所在。一个有fly方法的对象并不能自动成为Flier。仅仅实现协议中的方法的要求还不够，对象类型必须正式采用该协议，这段代码是不会被编译的:
struct Bee {  func fly() {  //  } }  let b = Bee() tellToFly(b) // compile error 虽然Bee能够发送fly消息。但是tellToFly不接受Bee参数，因为它需要一个Flier参数。从形式来讲，Bee不是Flier。要使Bee成为Flier，需要正式声明Bee采用Flier了协议。下面这段代码是可以通过编译的：
struct Bee: Flier {  func fly() {  debugPrint(&amp;#34;Bee fly&amp;#34;)  } }  let b = Bee() tellToFly(b) Adopting a Library Protocol 在Swift标准库中有各种协议，其中CustomStringConvertible协议要求实现一个description字符串属性。如果遵循CustomStringConvertible协议，当这种类型的实例被用于字符串插值或打印（在控制台中使用po命令，或在字符串初始化器init(descripbing:)）时，它的description属性值会被自动用来表示它。
enum Filter: String, CustomStringConvertible {   case albums = &amp;#34;Albums&amp;#34;   case playlists = &amp;#34;Playlists&amp;#34;   case podcasts = &amp;#34;Podcasts&amp;#34;   case books = &amp;#34;Audiobooks&amp;#34;   var description: String {  return self.rawValue  }  }  let filterType = Filter.albums debugPrint(&amp;#34;It is \(filterType)&amp;#34;) // It is Albums debugPrint(filterType) // Albums debugPrint(Filter.albums) debugPrint(String(describing: Filter.books)) 请注意，一个类型可以采用多个协议（协议组合）。例如，内置的Double类型采用了CustomStringConvertible、Hashable、Strideable等几个内置协议。声明采用多个协议的格式如下：
struct MyType: CustomStringConvertible, TextOutputStreamable, Strideable {  // ... } 当声明的类型是一个协议类型时，在采用的协议类型和它的真实类型之间进行转换。给定一个同时被Bird和Bee采用的协议Flier，可以使用is操作符来测试一个特定的Flier是否为Bird类型：
func isBird(_ f: Flier) -&amp;gt; Bool {  return f is Bird } 同样地，as和as?可以用来将一个被声明为协议类型的对象转换到它的实际类型。能够这样做很重要，因为采用协议的实际对象通常能够接收协议不能接收的消息。例如，一个Bird作为Filier时可以调用fly，但只能作为Bird时才能调用getWorm方法：
struct Bird: Flier {  func fly() {  debugPrint(&amp;#34;fly&amp;#34;)  }   func getWorm() {  //  } }  func tellGetWorm(f: Flier) {  (f as? Bird)?.getWorm() } Declaring a Protocol 协议声明只能在文件的顶层进行。要声明协议，需要使用关键字protocol，后跟协议名称（应该以大写字母开头，因为这是一种类型），然后是花括号，它可能包含以下任何一项的声明：
  属性：协议中的属性声明由var（不能使用let）、属性名称、冒号、类型名称和包含get或get set花括号组成。其中get或get set不能被省略。
  在只有get的情况下，采用者对该属性的实现可以是只读或者可写的。而在有get set情况下，它必须是可写的，采用者不得将get set属性实现为只读的计算属性或常量（let）存储属性。
protocol A {  let str: String //Protocols cannot require properties to be immutable; declare read-only properties by using &amp;#39;var&amp;#39; with a &amp;#39;{ get }&amp;#39; specifier }  protocol B {  let str: String { get } //&amp;#39;let&amp;#39; declarations cannot be computed properties. Replace &amp;#39;let&amp;#39; with &amp;#39;var&amp;#39; }   要声明一个静态/类属性，在它前面加上关键字static。如果采用者是类类型可以自由地将其作为一个class的计算属性来实现。如果采用者是结构体，只能使用static关键字：
struct B: A {  static var name: String = &amp;#34;&amp;#34; }  struct C: A {  static var name: String = &amp;#34;&amp;#34; }  class D: A {  // class var name: String = &amp;#34;&amp;#34; //Class stored properties not supported in classes; did you mean &amp;#39;static&amp;#39;?  private static var _name = &amp;#34;&amp;#34;  class var name: String {  get {  return _name  }  set {  self._name = newValue  }  } }  D.name = &amp;#34;test&amp;#34; debugPrint(D.name)     方法：协议中的方法声明是没有函数体的函数声明，既没有花括号，也没有代码。任何函数类型都是合法的，包括 init和subscript方法。
  在协议中声明下标的语法与在对象类型中声明下标的语法相同，只是花括号中包含get或get set。
protocol A {  subscript(ix: Int) -&amp;gt; String { get } }  struct B: A {  subscript(ix: Int) -&amp;gt; String {  return &amp;#34;&amp;#34;  } }   要声明静态/类方法，请在其前面加上关键字static。如果采用者为类类型，那么可以自由地将其实现为class方法。
protocol A {  static subscript(ix: Int) -&amp;gt; String { get } }  struct B: A {  static subscript(ix: Int) -&amp;gt; String {  return &amp;#34;B&amp;#34;  } }  class C: A {  // 实现为class方法  class subscript(ix: Int) -&amp;gt; String {  return &amp;#34;C&amp;#34;  } } protocol A {  static subscript(ix: Int) -&amp;gt; String { get set } }  struct B: A {  static subscript(ix: Int) -&amp;gt; String {  get {  return &amp;#34;B&amp;#34;  }  set {  //  }  } }  class C: A {  // 实现为class方法  class subscript(ix: Int) -&amp;gt; String {  get {  return &amp;#34;B&amp;#34;  }  set {  //  }  } }   如果要允许枚举或结构体采用者声明方法mutating，必须在协议中声明它是mutating的。如果协议缺少mutating，采用者不能添加mutating，但如果协议具有mutating，采用者可以省略mutating。
protocol A {  func change(name: String) -&amp;gt; Void }  struct B: A {  var name: String  // Type &amp;#39;B&amp;#39; does not conform to protocol &amp;#39;A&amp;#39;  mutating func change(name: String) {  self.name = name  } } protocol A {  mutating func change(name: String) -&amp;gt; Void }  struct B: A {  var name: String   mutating func change(name: String) {  self.name = name  } } protocol A {  mutating func change(name: String) -&amp;gt; Void }  struct B: A {  var name: String   func change(name: String) {  //self.name = name  } }     一个协议本身可以继承多个协议，声明协议时在名称后面加一个冒号，然后用逗号分隔它所采用的协议列表。实际上，这提供了一种方法来创建整个类型的二级层次结构，Swift的头文件就大量使用了这一点。
protocol A {  func test1() -&amp;gt; Void }  protocol B {  func test2() -&amp;gt; Void }  protocol C: A, B {  func test3() -&amp;gt; Void } Protocol Composition 如果协议的唯一目的是通过采用所有其它协议，而不添加任何新要求，则可以通过即时指定协议组合来避免正式声明协议。为此，请使用&amp;amp;连接协议名称，这称为协议组合：
func f(_ x: CustomStringConvertible &amp;amp; CustomDebugStringConvertible) {  // } 一个类型也可以被指定为一个类类型和一个或多个协议的组合。下面的代码中ViewController中声明的变量v的类型就是类UIView和协议MyViewProtocol的组合:
protocol MyViewProtocol {  func doSomethingReallyCool() }  class ViewController: UIViewController {  var v: (UIView &amp;amp; MyViewProtocol)?   func test() {  self.v?.doSomethingReallyCool() // a MyViewProtocol requirement   self.v?.backgroundColor = .red // a UIView property   } } 如果要赋值变量给ViewController的属性v，这个实例必须是UIView类型（或者它的子类型）并且adopting协议MyViewProtocol。
Class Protocols 协议声明可以在冒号后包含类名，这将能够采用此协议的类型限制为该类或其子类。所以还有一种更简单的方式实现上面的效果，就是在MyViewProtocol声明的时候，限定adopting协议的具体类型。如下所示只要在MyViewProtocol声明的时候加上冒号和类型：
protocol MyViewProtocol: UIView {  func doSomethingReallyCool() } 上面的代码的意思是MyViewProtocol协议只能被UIView或它的子类所采用。如果要限定一个协议只能被类类型所采用，可以将其限定类型设置为AnyObject：
protocol MyClassProtocol : AnyObject {  // ... } 在限定类型时一种可选的方式是在协议定义的花括号前使用where关键字：
protocol MyClassProtocol where Self: AnyObject {  // ... } Optional Protocol Members 在Objective-C中协议的成员可以声明为可选的，这意味着该成员不是必须要实现的。Swift中也可以声明可选的协议类型，但该特性是为了兼容Objective-C，实际上是由Objective-C实现的，它根本就不是 Swift 的特性。
因此，关于可选协议成员的一切都必须显式地暴露给Objective-C。协议声明必须用@objc属性标记，可选成员的声明必须用关键字@objc optional标记：
@objc protocol Flier {  @objc optional var song: String { get }  @objc optional func sing() } 在上面的代码中，在Flier协议中声明了可选的属性song，Swift通过将其获取的值包装在一个Optional中来解决这个问题。如果Flier采用者不实现该属性，则结果为nil：
class Bird: Flier {  func sing() {  //  } }  let flier: Flier = Bird() let song = flier.song // song is an Optional wrapping a String 这是一种罕见的情况，在这种情况下，可以得到一个双重包装的可选属性。如果可选属性 song 的值本身就是一个 String?，那么从 Flier 中获取它的值将产生一个 String??。
对于在协议中声明的读写可选属性，有一个奇怪的限制，就是不能去重新设置它的值。如下所示，重新设置flier的song属性时会报错：
@objc protocol Flier {  @objc optional var song: String { get set }  @objc optional func sing() }  class Bird: Flier {  var song: String = &amp;#34;bird name&amp;#34;   func sing() {  //  } }  let flier: Flier = Bird() let song = flier.song // song is an Optional wrapping a String flier.song = &amp;#34;test&amp;#34; // Cannot assign to property: &amp;#39;flier&amp;#39; is immutable 报错的信息是Cannot assign to property: &#39;flier&#39; is immutable，而这完全不合逻辑，因为flier指向的是一个类实例，这显然是语言中的一个错误，一种解决方法是使用关键路径：
@objc protocol Flier {  @objc optional var song: String { get set }  @objc optional func sing() }  class Bird: Flier {  var song: String = &amp;#34;bird name&amp;#34;   func sing() {  //  } }  var flier: Flier = Bird() let song = flier.song // song is an Optional wrapping a String //flier.song = &amp;#34;test&amp;#34; // Cannot assign to property: &amp;#39;flier&amp;#39; is immutable flier[keyPath: \.song] = &amp;#34;test&amp;#34; 在上面的代码中Flier协议中也定义了一个可选sing方法，所以调用它之前需要使用？。如果采用Flier协议的类型没有实现sing方法，那么下面的调用不会发生任何事情：
flier.sing?() 如果可选协议中的可选方法有返回值，那么调用时得到的值也是可选的：
@objc protocol Flier {  @objc optional var song: String { get set }  @objc optional func sing() -&amp;gt; String }  class Bird: Flier {  var song: String = &amp;#34;bird name&amp;#34;   func sing() -&amp;gt; String {  return &amp;#34;sing&amp;#34;  } }  let singe = flier.sing?() //Optional(&amp;#34;sing&amp;#34;) 如果在协议中声明init方法，如果采用协议的是类类型，那么该类和它的子类必须实现该初始化器，并且必须标记为required，否则会出现编译错误nitializer requirement &#39;init()&#39; can only be satisfied by a &#39;required&#39; initializer in non-final class &#39;Bird&#39;：
protocol Flier {  init() }  class Bird: Flier {  required init() {  debugPrint(&amp;#34;required init&amp;#34;)  } } 上面代码中Bird没有被标记为final，它的init必须标记为required。这意味着实现任何指定初始化器的任何 Bird 子类（因此失去初始化器继承）必须实现required初始化器并将其标记为required的。如果类Bird标记为final时，实现Flier协议中的init方法则不再需要关键字required：
protocol Flier {  init() }  final class Bird: Flier {  init() {  debugPrint(&amp;#34;required init&amp;#34;)  } } 这个事实会产生一个奇怪而烦人的特性。假设将内置的Cocoa类UIViewController子类化，下面代码是你极有可能做的事情：
class ViewController: UIViewController {  init() {  super.init(nibName: &amp;#34;ViewController&amp;#34;, bundle: nil) // compile error   } } 上面的代码会出现编译错误required initializer init(coder:)。这是因为UIViewController采用了NSCoding协议，这个协议中有一个required的init(coder:)。UIViewController子类必须继承 init(coder:)或必须显式实现它并将其标记为required。
上面的代码中已经实现了自己的指定初始化程序——因此切断了初始化程序继承。因此它必须实现 init(coder:)并将其标记为required。
class ViewController: UIViewController {  init() {  super.init(nibName: &amp;#34;ViewController&amp;#34;, bundle: nil) // compile error  }   required init?(coder: NSCoder) {  fatalError(&amp;#34;init(coder:) has not been implemented&amp;#34;)  } } 上面的代码可以通过编译，但如果真的被调用了，就会发生崩溃。不仅是UIViewController，其它的很多内置的Cocoa 类都采用NSCoding协议。如果将这些类中的任何一个进行子类化并实现自定义的初始化程序，都将遇到此问题。
Expressible by Literal Swift的美妙之处是它的许多功能都在Swift头文件中公开，字面量就是一个很好的例子。可以用5来表示一个值为5的Int，而不是通过Int(5)来正式初始化Int，这不是因为魔法。
这是因为Int采用了ExpressibleByIntegerLiteral协议。不仅是Int字面量，所有的字面量都是这样工作的。以下协议在Swift头文件中声明：
ExpressibleByNilLiteral  ExpressibleByBooleanLiteral  ExpressibleByIntegerLiteral  ExpressibleByFloatLiteral  ExpressibleByStringLiteral  ExpressibleByExtendedGraphemeClusterLiteral  ExpressibleByUnicodeScalarLiteral  ExpressibleByArrayLiteral  ExpressibleByDictionaryLiteral 可以在自定义的类型中采用字面量协议，这意味了字面量可以出现在需要对象类型实例的地方。下面的代码中声明了一个Nest结构体，它采用了ExpressibleByIntegerLiteral协议，因此在需要使用Nest实例的地方可以使用字面量：
struct Nest: ExpressibleByIntegerLiteral {  var eggCount: Int = 0   init() {  //  }   init(integerLiteral val: Int) {  self.eggCount = val  } }  func reportEggs(_ nest: Nest) {  print(&amp;#34;this nest contains \(nest.eggCount)eggs&amp;#34;) }  reportEggs(4) // this nest contains 4 eggs Generics 泛型是一种类型占位符，以后将会把实际的类型放入其中。特别是，在有些情况下，某个相同的类型将在多个地方使用，而不需要精确指定是什么类型。
之前我们定义了如下的全局函数，该函数声明的返回的类型是Dog，如果在调用的时候传入了Dog的子类，那么返回的依然是父类Dog实例：
func dogMakerAndNamer(_ whatType: Dog.Type) -&amp;gt; Dog {  let d = WhatType.init(name: &amp;#34;Fido&amp;#34;)  return d } 实际上我们希望在箭头运算符后的返回类型与参数类型相同，泛型可以达到这个目的。在下面的代码中，泛型函数指定WhatType始终是相同的类型（要求是Dog或Dog子类），而不必确切指定它是什么类型：
func dogMakerAndNamer&amp;lt;WhatType: Dog&amp;gt;(_: WhatType.Type) -&amp;gt; WhatType {  let d = WhatType.init(name: &amp;#34;Fido&amp;#34;)  return d }	因为Swift是一种强类型语言，为了调用函数dogMakerAndNamer，编译器需要知道WhatType的真实类型。但事实上，它是通过调用时传入的类型才知道真实的类型：
class Dog {  required init(name: String) {  //  } }  class NoisyDog: Dog {  required init(name: String) {  super.init(name: name)  } }  let dog = dogMakerAndNamer(NoisyDog.self) 在上面方法调用中，传递了NoisyDog.self作为参数，这就是告诉编译器WhatType的实际类型，实际上编译器现相当于在整个泛型中将NoisyDog替换为WhatType，该替换过程称为解析（或专门化）泛型。：
func dogMakerAndNamer(_: NoisyDog.Type) -&amp;gt; NoisyDog {  let d = NoisyDog.init(name: &amp;#34;Fido&amp;#34;)  return d } Optional 任何类型的值都可以被包裹在一个Optional中，这是因为Optional是一个泛型。下面是一个Optional的工作原理：
Optional是一种枚举类型，它有两个值.none和.some。如果一个Optional是.some，它就有一个关联值——被这个Optional包裹的值。但是这个关联值的类型是什么呢？
一方面，我们可以认为是任何类型，毕竟，这就是为什么任何东西都可以被Optional包裹起来。另一方面，任何特定的Optional都只能包装一个特定的已知类型的值，这听起来就像一个泛型。Swift头中的Optional枚举的声明如下所示：
@frozen public enum Optional&amp;lt;Wrapped&amp;gt; : ExpressibleByNilLiteral {   case none   case some(Wrapped)   public init(_ some: Wrapped)   @inlinable public func map&amp;lt;U&amp;gt;(_ transform: (Wrapped) throws -&amp;gt; U) rethrows -&amp;gt; U?   @inlinable public func flatMap&amp;lt;U&amp;gt;(_ transform: (Wrapped) throws -&amp;gt; U?) rethrows -&amp;gt; U?   public init(nilLiteral: ())   @inlinable public var unsafelyUnwrapped: Wrapped { get } } 上面声明中尖括号里的Wrapped是一个占位符，枚举声明的其余部分将继续使用这个占位符。除了.none这种情况，还有一种情况.some，它有一个相关的值&amp;ndash;Wrapped类型。
还有一个初始化器，它需要一个参数&amp;ndash;Wrapped类型的。因此，我们被初始化的类型(不管是什么类型)都是Wrapped类型，因此是与.some情况相关的类型。
let s = Optional(&amp;#34;howdy&amp;#34;) 对于上面的代码首先调用初始化器init(_ some: Wrapped)，所以&amp;quot;howdy&amp;quot;在这里作为一个Wrapped实例被提供的，并将这个泛型解析为String。编译器现在知道，在这个特定的Optional&amp;lt;Wrapped&amp;gt;中，Wrapped是String，这个特定的Optional的声明在编译器看起来如下所示：
enum Optional&amp;lt;String&amp;gt; {  case none  case some(String)  init(_ some: String) // ... } 上面代码中，实际上s的类型为Optional&amp;lt;String&amp;gt;，可以使用let s: Optional&amp;lt;String&amp;gt; = &amp;quot;howdy&amp;quot;来达到同样的效果。
Generic Declarations 下面列出了可以在Swift中以某种形式声明泛型的地方：
  泛型协议使用Self。在协议声明时，使用关键词Self可以将协议变成一个泛型协议。Self在这里是一个占位符，意味着采用者的类型。下面是一个Flier协议，它声明了一个接受Self参数的方法：
protocol Flier {  func flockTogetherWith(_ f: Self) } 这意味着，如果Bird对象类型采用Flier协议，那么实现flockTogetherWith时需要将其参数声明为Bird。
  泛型协议使用关联类型。协议定义时可以使用associatedtype关键字来声明关联类型，这可以将协议转换为泛型协议，关联类型名此时也是一个占位符：
protocol Flier {  associatedtype Other  func flockTogetherWith(_ f: Other)  func mateWith(_ f: Other) } 采用该协议的类型将指定占位符所代表的真正类型：
struct Bird: Flier {  func flockTogetherWith(_ f: Bird) {  //  }   func mateWith(_ f: Bird) {  //  } } 上面Bird结构体采用了Flier协议并将flockTogetherWith的参数声明为Bird类型。对于这个特定的采用者来说，因为Flier协议中定义的所有方法的参数类型都使用占位类型Other，因此Bird必须将mateWith方法的参数也声明为Bird类型。
  泛型函数。一个函数声明可以为它的任何参数、返回类型使用通用占位符类型。占位符名称在函数名称后面的尖括号中声明：
func takeAndReturnSameThing&amp;lt;T&amp;gt;(_ t: T) -&amp;gt; T {  debugPrint(T.self)  return t } 调用者可以在函数声明中出现占位符的某个地方使用一个特定的类型，以解析占位符的具体类型：let t = takeAndReturnSameThing(&amp;quot;howdy&amp;quot;)。在这里，调用中使用的参数&amp;quot;howdy&amp;quot;的类型将T解析为String。因此takeAndReturnSameThing的调用后也将返回一个String类型。
  泛型对象类型。一个对象类型声明可以在其花括号内的任何地方使用一个通用占位符类型。占位符名称在对象类型名称后面的尖括号中声明。
struct HolderOfTwoSameThings&amp;lt;T&amp;gt; {  var firstThing: T  var secondThing: T   init(thingOne: T, thingTwo: T) {  self.firstThing = thingOne  self.secondThing = thingTwo  } } 使用这个对象类型的用户将在对象类型声明中出现占位符的某个地方使用一个特定的类型，以解决占位符的问题。let holder = HolderOfTwoSameThings(thingOne:&amp;quot;howdy&amp;quot;, thingTwo:&amp;quot;getLost&amp;quot;)。在初始化器调用中使用的thingOne的参数&amp;quot;howdy&amp;quot;的类型将T解析为String。因此thingTwo也必须是一个String，并且属性firstThing和secondThing也是Strings。
  在泛型声明时尖括号内可以声明多个占位符以代表不同的类型，使用逗号分隔。下面定义的flockTwoTogether方法有两个占位符类型：
func flockTwoTogether&amp;lt;T, U&amp;gt;(_ f1: T, _ f2: U) {  // } 在泛型代码中，泛型占位符代表解析类型的类型引用，可以使用类型引用比较：
func takeAndReturnSameThing&amp;lt;T&amp;gt;(_ t: T) -&amp;gt; T {  // String.Type 是元类型，而T.self是元类型的值，参考自https://juejin.cn/post/6844903725199261710  if T.self is String.Type {  debugPrint(&amp;#34;T is String&amp;#34;)  }  return t } Contradictory Resolution Is Impossible 泛型在编译时就能排除与自身相矛盾的解析，这是泛型最重要的特性之一。由于Swift是强类型的，矛盾的解析是不可能的。泛型占位符必须在整个泛型中得到一致的解析，否则会编译报错。
func dogMakerAndNamer&amp;lt;WhatType: Dog&amp;gt;(_: WhatType.Type) -&amp;gt; WhatType {  let d = WhatType.init(name: &amp;#34;Fido&amp;#34;)  return d }  let d : NoisyDog = dogMakerAndNamer(Dog.self) // compile error 对于上面的代码let d : NoisyDog = dogMakerAndNamer(Dog.self)传入了参数Dog.self时WhatType会解析成类型Dog，但d声明为NoisyDog类型，会导致类型不一致，出现编译错误。
protocol Flier {  associatedtype Other  func flockTogetherWith(_ f: Other)  func mateWith(_ f: Other) } 相似的，如果采用上面Flier协议的类型在实现flockTogetherWith和mateWith方法中，使用不一致的类型时会出现编译错误Type &#39;Bird&#39; does not conform to protocol &#39;Flier&#39;：
struct Bird: Flier {  func flockTogetherWith(_ f: String) {  //  }   func mateWith(_ f: Int) {  //  } } Type Constraints 泛型声明可以限制可用于解析占位符的类型，这称为类型约束。最简单的类型约束形式是在占位符第一次出现时在它的名称后面放一个冒号和一个类型名称，冒号后的类型名可以是类名或协议名：
 如果是类名，则将泛型的具体类型限定为这个类或子类的名称。 如果是协议名，则协议名称表示该类型必须是该协议的采用者。  protocol Flier {  func fly() }  protocol Flocker {   associatedtype Other: Flier   func flockTogetherWith(f: Other) }  struct Bird: Flocker, Flier {   func fly() {  //  }   func flockTogetherWith(f: Bird) {  //  } } 上面定义的Flocker协议中的关联类型Other必须采用Flier协议。Bird是Flier的采用者，因此它也可以采用Flocker，同时指定其flockTogetherWith实现中的参数类型为Bird。
对于上面的代码，不使用关联类型，还有一种方法可以实现同样的效果。但是，还是有区别的，因为此时要求Flocker的采用者将flockTogetherWith的参数指定为Flier。然后在实现Flocker时就不得不将flockTogetherWith的类型声明为Flier：
protocol Flier {  func fly() }  protocol Flocker {  func flockTogetherWith(f: Flier) }  struct Bird: Flocker, Flier {  func fly() {  //  }   func flockTogetherWith(f: Flier) {  //  } } 而最上面定义的关联类型要求采用Flocker的类型在实现flockTogetherWith时参数f的类型也应该是采用Flocker协议的类型。
对于泛型函数或泛型对象，类型约束出现在尖括号中。前面声明的全局函数func dogMakerAndNamer就是一个例子。因为Dog是一个类，因此约束说明WhatType必须是Dog或Dog子类。下面是另一个例子，使用协议作为约束：
func flockTwoTogether&amp;lt;T: Flier&amp;gt;(_ f1: T, _ f2: T) {  // } 在这个例子中，Flier是一个协议，所以约束条件表明T必须是一个Flier的采用者。假如Bird和Insect都采用Flier，那么flockTwoTogether函数可以用两个Bird参数或两个Insect参数来调用，但不能一个是Bird另一个是Insect，因为T只是一个占位符(不是两个)，表示一个Flier采用者类型。但也不能用两个字符串参数调用flockTwoTogether，因为字符串不是Flier。
占位符上的类型约束经常被用来向编译器保证一些消息可以被发送到占位符类型的实例上。比方说，想实现一个函数myMin，从同一类型的列表中返回最小值:
func myMin&amp;lt;T:Comparable&amp;gt;(_ things: T...) -&amp;gt; T {  var minimum = things.first!   for item in things.dropFirst() {  if item &amp;lt; minimum {  minimum = item  }  }  return minimum } Explicit Specialization 到目前为止，在泛型示例中，占位符的类型主要是通过类型推断来解析的（隐式解析）。但还有另一种解析的方法：可以手动解析类型，这称为显式解析。在某些情况下，显式解析是强制性的，即若无法通过推理解析占位符类型。显示解析有两种形式：
  以占位符声明的泛型协议。协议的采用者可以通过将关联类型定义为某种类型的别名手动解析关联类型：
protocol Flier {  associatedtype Other }  struct Bird: Flier {  typealias Other = String }   泛型对象类型。使用泛型对象类型的用户可以使用与声明泛型时相同的尖括号语法手动解析占位符类型，类型名称在尖括号中：
class Dog&amp;lt;T&amp;gt; {  var name: T? } let d = Dog&amp;lt;String&amp;gt;()   不能手动显式解析泛型函数。一种解决方案是让泛型函数采用解析泛型的类型参数。这就是之前的dogMakerAndNamer示例中所做的:
func dogMakerAndNamer&amp;lt;WhatType: Dog&amp;gt;(_: WhatType.Type) -&amp;gt; WhatType {  let d = WhatType.init(name: &amp;#34;Fido&amp;#34;)  return d } dogMakerAndNamer的参数从未在函数体内使用，这就是它没有名称（只有下划线）的原因。但是，它确实用于解析泛型。
另一种方法是首先不使用泛型函数。相反，先声明一个泛型对象类型，包装一个使用泛型类型占位符的非泛型函数。泛型类型可以显式特化，解析函数中的占位符：
protocol Flier {  init() }  struct Bird: Flier {  init() {  //  } }  struct FlierMaker&amp;lt;T: Flier&amp;gt; {  static func makeFlier() -&amp;gt; T {  return T()  } } let f = FlierMaker&amp;lt;Bird&amp;gt;.makeFlier() // returns a Bird 当一个类是泛型时，可以对它进行子类化，前提是解析了泛型。可以通过匹配的泛型子类或显式解析父类泛型来执行此操作。下面是一个泛型的Dog：
class Dog&amp;lt;T&amp;gt; {  func speak(_ what: T) {  //  } } 可以将其子类化为泛型，其占位符与父类的占位符匹配：
class Dog&amp;lt;T&amp;gt; {  func speak(_ what: T) {  //  } }  class NoisyDog&amp;lt;T&amp;gt;: Dog&amp;lt;T&amp;gt; {  // } 这是合法的，因为NoisyDog占位符T的解析的同时将解析Dog占位符T。替代方法是子类化一个显式解析的Dog:
class NoisyDog: Dog&amp;lt;String&amp;gt; {  // } 在这种情况下，子类中的方法覆盖可以使用特化类型，而父类使用泛型：
class NoisyDog: Dog&amp;lt;String&amp;gt; {  override func speak(_ what: String) {  //  } } Generic Invariance 通常，专用于子类型的泛型类型相对于专用于父类型的相同泛型类型而言不是多态的。假设我们有一个简单的通用Wrapper结构以及一个Cat类及其CalicoCat子类：
class Cat {  // }  class CalicoCat: Cat {  // } 那么你不能赋值一个专门用于CalicoCat的Wrapper给一个专门用于Cat的Wrapper，下面将会出现编译错误：
let w : Wrapper&amp;lt;Cat&amp;gt; = Wrapper&amp;lt;CalicoCat&amp;gt;() // compile error 上面的代码看起来多态已经失效，但实际上不是这样的。因为Wrapper&amp;lt;Cat&amp;gt;和Wrapper&amp;lt;CalicoCat&amp;gt;两种类型不是父类和子类的关系。
相反，如果这种赋值是可行的话，我们会说这些类型是共变的，这意味着占位符的特殊化之间的多态关系被应用于泛型类型本身。某些Swift内置的泛型类型是共变的，Optional就是一个明显的例子。但是，令人沮丧的是，共变性并不是一个通用的语言特性，没有办法指定你的泛型类型应该是共变性的。
一个变通方法是将泛型占位符限制在一个协议上，并让你的类型采用该协议：
protocol Meower {  func meow() }  struct Wrapper&amp;lt;T: Meower&amp;gt; {  let meower: T }  class Cat: Meower {  func meow() {  debugPrint(&amp;#34;meow&amp;#34;)  } }  class CalicoCat: Cat {  // } 现在可以使用合法地使用let w : Wrapper&amp;lt;Cat&amp;gt; = Wrapper(meower:CalicoCat())这样的表达式，而不会出现编译错误。
Associated Type Chains 当一个泛型占位符限制为一个带有关联类型的泛型协议时，可以使用点符号来推断相关的类型：占位符的名称，一个点，和关联类型的名称。
protocol Fighter {  associatedtype Enemy: Fighter }  struct Soldier: Fighter {  typealias Enemy = Archer }  struct Archer: Fighter {  typealias Enemy = Soldier } 现在可以使用点操作符推断相关类型：
struct Camp&amp;lt;T: Fighter&amp;gt; {  var spy: T.Enemy? } 这就意味着，对于某个特定的Camp，如果T被解析为Soldier，那么T.Enemy就是Archer；如果T被解析为Archer，那么T.Enemy就是Soldier。
如果此时尝试赋值给spy给一个错误的类型，那么就会出现编译错误：Cannot assign value of type &#39;Soldier&#39; to type &#39;Soldier.Enemy?&#39; (aka &#39;Optional&amp;lt;Archer&amp;gt;&#39;)：
var c = Camp&amp;lt;Soldier&amp;gt;()  c.spy = Soldier() // compile error 一个泛型协议可能有个关联类型限制为一个有关联类型的协议。因此，可能出现长的关联类型链：
protocol Wieldable { }  struct Sword: Wieldable { }  struct Bow: Wieldable { }  protocol Fighter {  associatedtype Enemy: Fighter  associatedtype Weapon: Wieldable }  struct Soldier: Fighter {   typealias Weapon = Sword   typealias Enemy = Archer }  struct Archer: Fighter {   typealias Weapon = Bow   typealias Enemy = Soldier } </content>
    </entry>
    
     <entry>
        <title>KingFisher 使用</title>
        <url>https://iihui.github.io/post/ios-kingfisher/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  最近App联系人头像改成了url的形式，不再使用带大堆信息的post请求。因为头像涉及到缓存和更新机制，因此需要使用KingFisher组件。
 设置图片 如果想要设置UIImageView的图片，则可以使用KingFisher的扩展方法xxx.kf.setIamge。在这个方法中可以设置默认显示的图片，也可以设置是否缓存图片，获取图片下载的进度，还可以增加回调，函数原型如下所示：
// MARK:Setting Image   /// Sets an image to the image view with a `Source`.  ///  /// - Parameters:  /// - source: The `Source` object defines data information from network or a data provider.  /// - placeholder: A placeholder to show while retrieving the image from the given `resource`.  /// - options: An options set to define image setting behaviors. See `KingfisherOptionsInfo` for more.  /// - progressBlock: Called when the image downloading progress gets updated. If the response does not contain an  /// `expectedContentLength`, this block will not be called.  /// - completionHandler: Called when the image retrieved and set finished.  /// - Returns: A task represents the image downloading.  ///  /// - Note:  /// This is the easiest way to use Kingfisher to boost the image setting process from a source. Since all parameters  /// have a default value except the `source`, you can set an image from a certain URL to an image view like this:  ///  /// ```  /// // Set image from a network source.  /// let url = URL(string: &amp;#34;https://example.com/image.png&amp;#34;)!  /// imageView.kf.setImage(with: .network(url))  ///  /// // Or set image from a data provider.  /// let provider = LocalFileImageDataProvider(fileURL: fileURL)  /// imageView.kf.setImage(with: .provider(provider))  /// ```  ///  /// For both `.network` and `.provider` source, there are corresponding view extension methods. So the code  /// above is equivalent to:  ///  /// ```  /// imageView.kf.setImage(with: url)  /// imageView.kf.setImage(with: provider)  /// ```  ///  /// Internally, this method will use `KingfisherManager` to get the source.  /// Since this method will perform UI changes, you must call it from the main thread.  /// Both `progressBlock` and `completionHandler` will be also executed in the main thread.  ///  @discardableResult  public func setImage(  with source: Source?,  placeholder: Placeholder? = nil,  options: KingfisherOptionsInfo? = nil,  progressBlock: DownloadProgressBlock? = nil,  completionHandler: ((Result&amp;lt;RetrieveImageResult, KingfisherError&amp;gt;) -&amp;gt; Void)? = nil) -&amp;gt; DownloadTask?  {  let options = KingfisherParsedOptionsInfo(KingfisherManager.shared.defaultOptions &#43; (options ?? .empty))  return setImage(with: source, placeholder: placeholder, parsedOptions: options, progressBlock: progressBlock, completionHandler: completionHandler)  } 同时缓存图片 因为扩展方法setImage会改变UIImageView的图片，即是操作UI的，因此需要在主线程中进行。一般情况需要缓存已经下载好的图片，下次直接从缓存中取。如下定义的方法既设置了默认图片，也缓存了取到的图片：
private func setImage(imageView: UIImageView, urlStr: String, defaultImageName: String) {  let defaultImage = UIImage(named: defaultImageName)  guard let url = URL(string: urlStr) else {  DispatchQueue.main.safeAsync {  imageView.image = defaultImage  }  return  }  let resource = ImageResource(downloadURL: url, cacheKey: url.absoluteString)  DispatchQueue.main.safeAsync {  imageView.kf.setImage(with: resource, placeholder: defaultImage, options: [.diskCacheExpiration(.never)])  } } cell复用 在UITableViewCell或者UICollectionViewCell中使用kf.setIamge时，可能图片请求还没返回就已经滑了多屏，也就是说cell开始复用了，解决这个问题是在即将复用的时候取消网络请求：
override func prepareForReuse() {  super.prepareForReuse()  self.imgView.kf.cancelDownloadTask() } 鉴权信息 有时候服务端为了防盗，需要请求方提供一些鉴权信息，此时需要使用KingFisher提供的AnyModifier，在request中增加需要的信息即可：
private func setImage(imageView: UIImageView, urlStr: String, defaultImageName: String) {  let defaultImage = UIImage(named: defaultImageName)  guard let url = URL(string: urlStr) else {  DispatchQueue.main.safeAsync {  imageView.image = defaultImage  }  return  }  let modifier = AnyModifier { request in  var r = request  r.setValue(&amp;#34;abc&amp;#34;, forHTTPHeaderField: &amp;#34;Access-Token&amp;#34;)  return r  }  let resource = ImageResource(downloadURL: url, cacheKey: url.absoluteString)  DispatchQueue.main.safeAsync {  imageView.kf.setImage(with: resource, placeholder: defaultImage, options: [.requestModifier(modifier), .diskCacheExpiration(.never)])  } } 获取图片 综合获取 使用KingfisherManager.shared.retrieveImage可以获取图片。获取规则：先从缓存中获取，如果缓存中没有对应的图片，则走网络获取图片，从网络获取到图片之后将会缓存该图片：
private func getImage(urlStr: String, completion: @escaping (UIImage?) -&amp;gt; Void) {  guard let url = URL(string: urlStr) else {  completion(nil)  return  }  let resource = ImageResource(downloadURL: url, cacheKey: url.absoluteString)  KingfisherManager.shared.retrieveImage(with: resource) { result in  switch result {  case .success(let value):  completion(value.image)  case .failure(let error):  debugPrint(error.localizedDescription)  completion(nil)  }  } } 缓存中获取 也可以直接从缓存中获取图片，而不走网络；如果是默认缓存，则只要调用ImageCache.default.retrieveImage方法，并传入先前的cacheKey：
private func getImageFromCache(cacheKey: String, completion: @escaping (UIImage?) -&amp;gt; Void) {  ImageCache.default.retrieveImage(forKey: cacheKey) { result in  switch result {  case .success(let value):  completion(value.image)  case .failure(let error):  debugPrint(error.localizedDescription)  completion(nil)  }  } } 网络获取 也可以直接从网络中获取图片，而不从缓存中获取。只要调用ImageDownloader.default的downloadImage方法：
private func getImageFromNetwork(urlStr:String, completion: @escaping (UIImage?) -&amp;gt; Void) {  guard let url = URL(string: urlStr) else {  completion(nil)  return  }  ImageDownloader.default.downloadImage(with: url ) { result in  switch result {  case .success(let value):  completion(value.image)  case .failure(let error):  debugPrint(error.localizedDescription)  completion(nil)  }  } } 如果服务端为了防盗，需要请求方提供一些鉴权信息，此时需要使用KingFisher提供的AnyModifier，在request中增加需要的信息即可：
private func getImageFromNetwork(urlStr: String, completion: @escaping (UIImage?) -&amp;gt; Void) {  guard let url = URL(string: urlStr) else {  completion(nil)  return  }  let modifier = AnyModifier { request in  var r = request  r.setValue(&amp;#34;abc&amp;#34;, forHTTPHeaderField: &amp;#34;Access-Token&amp;#34;)  return r  }  ImageDownloader.default.downloadImage(with: url, options: [.requestModifier(modifier)]) { result in  switch result {  case .success(let value):  completion(value.image)  case .failure(let error):  debugPrint(error.localizedDescription)  completion(nil)  }  } } 预先取图片 如果预先知道待显示的图片，则可以预先获取图片，使用ImagePrefetcher可以批量获取，如下所示，可以在回调中查看哪些图片已经获取到，传入的参数既可以是URL数组，也可以是ImageResource数组:
private func preFetchImage(urlStrings: [String]) {  let urls = urlStrings.compactMap({ URL(string: $0) })  let prefetcher = ImagePrefetcher(urls: urls) {  skippedResources, failedResources, completedResources in  debugPrint(&amp;#34;These resources are prefetched: \(completedResources)&amp;#34;)  }  prefetcher.start() }  private func preFetchImages(urlStrings: [String]) {  let resources = urlStrings.compactMap({ URL(string: $0) }).compactMap({ ImageResource(downloadURL: $0, cacheKey: $0.absoluteString) })  let prefetcher = ImagePrefetcher(resources: resources) {  skippedResources, failedResources, completedResources in  debugPrint(&amp;#34;These resources are prefetched: \(completedResources)&amp;#34;)  }  prefetcher.start() } 缓存设置 KingFisher提供了缓存图片张数和存储大小的设置接口，在设置的时候区分了内存和磁盘缓存。内存中图片张数由countLimit确定，存储大小由totalCostLimt确定。磁盘缓存中只能设置存储大小，由sizeLimit确定。
内存缓存设置 下面的代码设置内存缓存最多300张图片，占用内存大小最多为300M。默认情况下内存中的图片五分钟后过期，在下面的设置中设置为不过期。
// 限制内存最多300张图片 ImageCache.default.memoryStorage.config.countLimit = 300 // 限制内存大小为300M ImageCache.default.memoryStorage.config.totalCostLimit = 300 * 1024 * 1024 // 内存中图片过期时间设置 ImageCache.default.memoryStorage.config.expiration = .never 磁盘缓存设置 磁盘缓存和内存缓存有一些区别，大小是由sizeLimit确定，默认情况下磁盘缓存中的图片一星期后过期，在下面的设置中设置为不过期：
// 限制磁盘缓存大小为300M ImageCache.default.diskStorage.config.sizeLimit = 300 * 1024 * 1024 // 磁盘缓存中图片过期时间设置 ImageCache.default.diskStorage.config.expiration = .never 手动保存 默认情况下，KingFisher提供的视图的扩展方法和KingfisherManager会在取图片的时候自动缓存，也可以手动缓存图片，如下所示即可以只保存在磁盘中，也可以同时缓存在内存和磁盘中：
private func storeImage(data: Data, cacheKey: String) {  ImageCache.default.storeToDisk(data, forKey: cacheKey)  if let image = UIImage(data: data) {  ImageCache.default.store(image, forKey: cacheKey)  } } 如果有图片的原始数据，也可以传递给KingFisher，这样可以帮助KingFisher确定图片应该以哪种方式保存，如下所示：
private func storeImage(data: Data, cacheKey: String) {  ImageCache.default.storeToDisk(data, forKey: cacheKey)  if let image = UIImage(data: data) {  ImageCache.default.store(image, original: data, forKey: cacheKey)  } } 手动删除 除了手动保存，也提供了手动删除缓存的方法，直接调用removeImage(forKey: cacheKey)即可根据cacheKey删除缓存：
ImageCache.default.default.removeImage(forKey: cacheKey) 也可以进行选择性的全部删除，即可以选择删除所有内存或者磁盘的缓存，或者选择只删除已经过期的内存或者磁盘中的缓存，如下所示：
private func clean() {  // 清理内存缓存  ImageCache.default.clearMemoryCache()  // 清理磁盘缓存  ImageCache.default.clearDiskCache()  // 清理内存和磁盘缓存  ImageCache.default.clearCache()  // 清理内存过期缓存  ImageCache.default.cleanExpiredMemoryCache()  // 清理磁盘过期缓存  ImageCache.default.cleanExpiredDiskCache()  // 清理内存和磁盘过期缓存  ImageCache.default.cleanExpiredCache() } 参考资料
扩展缓存和默认图片 使用KingFisher时，有时既需要设置缓存又需要默认图片，但每次都去定义ImageResource，稍微有点烦复，下面是在UIImageView中扩展出一个满足该需求的函数：
extension UIImageView {  /// 使用KingFisher设置imageView的图片  /// - Parameters:  /// - urlStr: 图片url  /// - defaultImageName: 默认图片名字，若没有可以传空字符串  func setImage(urlStr: String, defaultImageName: String) {  let defaultImage = defaultImageName.isEmpty ? nil : UIImage(named: defaultImageName)  guard let url = URL(string: urlStr) else {  if let image = defaultImage {  self.image = image  }  return  }  let source = ImageResource(downloadURL: url, cacheKey: url.absoluteString)  self.kf.setImage(with: source, placeholder: defaultImage)  } } </content>
    </entry>
    
     <entry>
        <title>使用Leaks内存检测</title>
        <url>https://iihui.github.io/post/ios-leaks/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  最近有用户反馈App出现了闪退现象，但后台并未发现有崩溃日志上传，猜测发生了内存溢出，导致App直接被系统杀掉而没有崩溃日志产生。为了验证此猜测，需要使用XCode的Leaks工具，这篇文章简单介绍使用Leaks的步骤。
 Setting 首先在XCode的菜单栏中找到Product，然后查看子菜单中的Profile是否为灰色如下图所示，若Profile为灰色，则表示该功能不能使用，需要做一些额外的设置。
设置Profile，首先需要单击选中当前target，然后在弹出框中选择Edit Scheme... 才可以修改Profile，让其变成可用，点击如下图所示箭头：
接着选中Profile，在Build Configuration一栏的右侧选中Debug，并在Executable一栏选中要调试的App，最后点击close即可完成设置，如下图所示：
Instruments 设置完成后，便可在菜单栏的Product目录下看到Profile变成可用的白色，此时选中Profile便可唤出Instrucments面板，然后再选中Leaks:
Allocations 上一步选中Leaks后，会打开Leaks面板，点击左上角的红色圆圈按钮就可以进行内存检测。在下图上半部分选中Allocations这一行，即可查看内存分配情况：
Leaks 如果在运行过程中，面板中上半部分的Leaks栏中出现红色x，则说明有内存泄漏。此时，鼠标点击Leaks这一行，便可看到内存泄漏的具体信息：
调用栈信息 默认情况下，Leaks显示的是Leaks by Backtrace。如果要定位内存泄漏代码，则需要先选择Call Tree，设置如下图所示：
然后选择底部的Call Tree，在弹窗中再选中Invert Call Tree和Hide System Libraries，即可显示出具体内存泄漏的代码：
假如还是不能显示内存泄漏的代码，则需要在Build Setting中搜索debug，然后在Debug Information Format中的debug或release行选中DWAARF with dSYM File，如下图所示：
下面三个图中第一个是没有设置DWARF with dSYM File的结果，即不能显示具体的调用信息；第二和第三个是设置了DWARF with dSYM File后的结果，能显示具体的调用信息，如果要查看某个时间段的内存泄漏，需要按住鼠标左键，然后拖动使得要查看的内存泄漏的x在范围内：
内存引用 如果想要查看内存泄漏引用图，则需要将Call Tree选项改为Cycles &amp;amp; Roots，但不是所有的都可以查看，效果如下图所示：
参考资料
</content>
    </entry>
    
     <entry>
        <title>视图</title>
        <url>https://iihui.github.io/post/ios-views/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  视图view的层次结构是其组织的主要模式。一个视图可以有多个子视图，但只能有一个直接父视图。若一个视图被从界面中被移除，则它的子视图也会被移除；若一个视图被隐藏，则它的子视图都会被隐藏；如果一个视图被移动，它的子视图也都会随之移动。也就是说，一个视图的变化会作用到它的子视图中。
 UIView是UIResponder的子类，即它不仅是用户能看到的界面，也是用户交互所用界面。也就是说视图的层次结构也是响应者链的基础，但它与响应者链不完全相同。
一个视图的创建可能来自nib，也可能来自代码。不能绝对地说哪种方式更好一些，这取决于个人需求和程序的整体架构。
window 和 root View 视图层级结构的最顶层是window。window为UIWindow或UIWindow子类的实例，其中UIWindow也是UIView的一个子类。
在App启动时会创建和显示一个window，否则只会看到一片黑色。从iOS 13开始，App可在iPad上支持多个window；如果你的App在iPad上不支持多window或在iPhone上运行，则只有一个window，即the main window。
一个可见的window构成了所有其他可见view的背景，也是所有可见视图的父视图。一个view如果是可见的，那么它一定是某个可见window的子视图。
在实际编程中，一般不会手动或者直接用子视图来填充window，因为window和它所包含的视图之间的连接是根视图控制器，即其rootViewController属性。
一旦一个ViewController被实例化，并且赋值给window的rootViewController属性，则此ViewController的主视图（即view属性），将会填充整个window，这个主视图也将是window的唯一直接子视图。其他所有可见的视图在一定深度上都是rootViewController主视图的某个子视图。
window scene architecture 从iOS 13开始App的window默认由UIWindowScene来提供，这与iOS 12及之前的版本相比，是架构上最大的变化：
  在iOS 12及以前，是基于window的架构，window是AppDelegate的一个属性。如果项目是在XCode 10或者之前创建的，则默认使用这种老架构。
  在iOS 13及以后，是基于scene的架构，window是SceneDelegate的一个属性。如果项目是在XCode 11或之后创建的，则默认使用的是这种新架构。
  使用老window架构的App，如果在iOS 13及以后的版本中运行时，它会被赋予一个UIWindowScene，但是它不知道这个事实，并且功能不受影响，仍然运行在老架构上。但是，新window架构的App不能运行在iOS 12及以前的系统。
如果需要新架构的App支持iOS 12以之前的系统，则需要将SceneDelegate的window属性复制到AppDelegate类中。然后在AppDelegate类中将所有涉及UISceneSession的方法标记为@available(iOS 13.0, *)。最后在SceneDelegate类前将整个类标记为@available(iOS 13.0, *)即可。
进行如上的改动后，如果App运行在iOS 13及以后的系统中，则使用的是新架构，并且SceneDelegate持有window。如果在iOS 12及以前的系统中，则使用的是旧架构，AppDelegate持有window。
如果想要在XCode 11以上创建的工程使用旧window架构，则需要先删除所有UISceneSession和SceneDelegate相关的代码，然后在info.plist中删除Application Scene Manifest入口，最后在AppDelegate中手动添加var window: UIWindow?即可。
App Launches 在启动时，应用程序如何初始化window，以及该window如何被填充和显示？如果应用使用main storyboard，window的初始化和显示都会自动完成。但是，「自动」并不意味着「通过魔术」。
应用的启动时的程序是直接和确定的，我们的代码可以在其中起作用。知道一个应用程序是如何启动的是非常有用的，尤其是当配置错误，应用程序的启动出现问题时，就可以找出原因了。
App启动时最终包括一次UIApplicationMain函数的调用。与OC不同，一个典型的Swift项目不会在代码中明确地进行这一调用，都是自动完成调用的。UIApplicationMain函数的调用创建了一些最重要的初始实例；如果你的应用程序使用main storyboard，则这些实例包括window和它的根视图控制器。
UIApplicationMain的处理是如何进行的，取决于你的应用程序是使用旧的window架构还是新的window架构，它们将会是两种完全不同的启动过程。
新架构 以下是UIApplicationMain如何在iOS 13及更高版本上启动支持window scene的应用程序:
  UIAppplicationMain首先实例化UIApplication，并保留这个实例，将其作为共享的实例，可以在代码中可以使用UIApplication.shared来访问。接着根据@UIApplicationMain或@main来实例化AppDelegate，并保留这个实例，使得它在应用程序中的整个生命周期中都存在，可以使用UIApplication.shared.delegate来访问。
  接着UIApplicationMain会调用AppDelegate的application(_:didFinishLaunchingWithOptions:)方法，在这个方法中可以插入我们自己的代码。
  然后UIAppplicationMain创建UISceneSession和UIWindowScene以及UIWindwScene代理类UIWindowSceneDelegate的实例。   UIAppplicationMain查看初始scene是否使用了storyboard，即查看info.plist中Application Scene Manifest字典下的Scene Configuration是否有Storyboard Name。若有，则对storybaord中指定的初始viewController进行实例化。
  如果scene使用了storyboard，UIAppplicationMain则会实例化一个UIWindow并将这个实例赋值给SceneDelegate的window属性。
  如果scene使用了storyboard，则将storyboard中那个已经实例化的初始ViewController赋值给上一步已经实例化window的rootViewController属性。此时，初始ViewController的view变成了Window的唯一子视图。
  UIApplicationMain通过调用UIWindow实例方法makeKeyAndVisible，使你的应用程序的界面出现。
  scene的(_:willConnectTo:options:)被调用，在这个方法中也可以插入自己的代码。
  如果App启动时未使用storyboard，也就是说在老的架构中Info.plist中没有Main storyboard file base name条目。而在新的架构中，这意味着在Application Scene Manifest字典的Application Scene Configuration下没有Storyboard Name条目。
此时需要在代码中完成有storyboard的情况下自动完成的所有事情。在旧的架构下，需要在app delegate的application(_:didFinishLaunchingWithOptions:)中做这些事情。
而在新的架构下，需要在SceneDelegate中的scene（_:willConnectTo:options:）方法做下面这些事情:
  创建一个UIWindow的实例，并且将其赋值给SceneDelegate的window属性。通过调用UIWindow的初始化方法init(windowScene:)使得window和window scene来建立连接。
  初始化一个视图控制器，并根据需要对其进行设置。
  将上一步实例化的视图控制器赋值给window的rootViewController属性。
  调用window的makeKeyAndVisible进行显示。
  引用window 一旦app运行，有多种方法引用window：➊从视图中引用；➋从SceneDelegate中引用；➌从application中引用。
view 如果一个视图在界面中，则该视图能通过自己的window属性引用到包含它的window。你的代码可能会在一个有main view的视图控制器中运行，此时self.view.window是引用window的最佳方式。
也可以使用UIView的window属性来询问它是否最终被嵌入到window中。如果未嵌入到window中，则它的window属性为nil。一个window属性为nil的视图是对用户不可见的。
sceneDelegate 或appDelegate SceneDelegate实例保存了window的引用，可以通过window属性来访问。即使用sceneDelegate.window来访问。但访问sceneDelegate需要先使用let sceneDelegate = UIApplication.shared.connectedScenes.first?.delegate as? SceneDelegate来获取。
如果使用的是旧window架构，则需要使用AppDelegate来访问，即 UIApplication.shared.delegate?.window。
application 共享的application实例也保存了window的引用，可以通过其window属性来访问，即let w = UIApplication.shared.windows.first!。
subview and superview 在以前，一个视图恰好拥有自己的矩形区域，即任何不属于该视图的子视图的视图都不能出现在该视图的里面。因为当该视图重新绘制其矩形区域时，它会擦除其他视图的重叠部分。视图的子视图的任何部分都不能出现在它的外面，因为该视图对它自己的矩形区域负责，而不是其他。
从macOS 10.5开始，Apple为视图绘制引入了一个全新的架构，完全解除了上面的所说的那些限制。在iOS中，一个子视图的部分或全部可以出现在它的父视图之外，一个视图可以与另一个视图重叠，可以部分或全部画在它的前面，而不成为它的子视图。
如下图所示，有3个不同背景色的视图，每个视图和其他视图都有重叠。仅从视觉效果上是无法了解视图的层次结构的：
一个视图在视图层次结构中的位置是非常重要的。首先，视图的层次结构决定了视图的绘制顺序。同一父视图的同级子视图有明确的绘制顺序：较早的同级子视图画在较晚的同级子视图之前，所以如果它们重叠，较早的子视图会出现在较晚的子视图后面。同样地，一个父视图被画在它的子视图之前，所以如果子视图与它们的父视图重叠，父视图就会出现在它们后面。
如果是在storyboard中创建的视图或者nib，则视图的层级结构可以通过菜单栏的Editor--&amp;gt;Arrange下面的子选项来改变：
  如果一个视图从它的父视图中移除，则它的所有子视图也会被移除
  一个视图的透明度会被它的子视图所继承。
  视图可以选择性地限制其子视图的绘制，使其在视图之外的任何部分都不被显示，这就是所谓的剪裁，可以通过视图的clipsToBounds属性来设置。
  在内存管理的意义上，父视图拥有它的子视图，就像一个数组拥有它的元素一样：它保留它的子视图，并且当一个子视图从这个视图的子视图集合中移除时，或者当父级视图本身不存在时，才会释放该子视图。
  如果一个视图的大小改变了，它的子视图也可能会自动调整大小。
  每个视图均有superview和subviews属性，使用这两个属性可以追踪视图的层次结构。使用视图的isDescendant(of:)方法可以判断一个视图是否是另一个视图的子视图（任意深度）。
如果想要引用特定的某个视图，可能需要为视图事先安排一个标记，可以是outlet；也可以为视图事先设置tag属性值，然后通过调用viewWithTag(_:)来获取该特定的视图。
视图的添加、删除和移动等都有相应的事件，这些事件的响应需要子类化。然后通过覆盖如下的方法便可以看到对应的调用：
willRemoveSubview(_:) didAddSubview(_:) willMove(toSuperview:) didMoveToSuperview willMove(toWindow:) didMoveToWindow 如果addSubview(_:)被调用，则视图将放在父视图的所有子视图的最后边「即最上边」，也就是最后才绘制，这意味着它将出现在最前面。
视图的子视图是有索引的，从0开始。可以在给定的索引或特定视图的下面（后面）或上面（前面）插入一个子视图；也可以通过索引交换两个同级视图；还可以将一个子视图一直移动到其同级的前面或后面。
insertSubview(_:at:) insertSubview(_:belowSubview:) insertSubview(_:aboveSubview:) exchangeSubview(at:withSubviewAt:) bringSubviewToFront(_:) sendSubviewToBack(_:) 但是，没有提供一次性删除一个视图的所有子视图的方法。一个视图的子视图数组是内部子视图列表的一个不可变的副本。因此，需要使用for循环来删除所有子视图：
myView.subviews.forEach {$0.removeFromSuperview()} color 视图可以通过其backgroundColor属性设置一个背景色，如果backgroundColor属性值为nil，则视图的背景色为透明。backgroundColor即是UIColor的实例，通常使用red,blue,green和alpha（其值为0~1）来定义：
v.backgroundColor = UIColor(red: 0, green: 0.1, blue: 0.1, alpha: 1) 自iOS 13开始出现了深色模式，为了适配需要使用动态颜色，即使用UIColor的初始化函数init(dynamicProvider:)来进行适配，下面是创建一个自定义的动态颜色：
v1.backgroundColor = UIColor { tc in  switch tc.userInterfaceStyle {  case .dark:  return UIColor(red: 0.3, green: 0.4, blue: 0.4, alpha: 1)  case .light:  return UIColor(red: 0, green: 0.1, blue: 0.1, alpha: 1)  } } 从iOS 13开始，系统提供了许多预置的动态颜色，其中大部分的名称都是以.system开头的，比如.systemYellow，其它的则是描述其作用的语义名称，比如.label。
现在可以在资产目录中设计一个自定义命名的颜色。当创建一个新的颜色集时，属性检查器中的 「外观」弹出菜单显示为「任意」、「暗色」，并且有两个颜色色块，一个用于深色模式，另一个用于其它一切；依次选择每个色块并在属性检查器中设计颜色：
上面自定义命名的颜色，就是动态的。比方说，我们在资产目录中的颜色集被称为myDarkColor，那么可以使用如下方式使用:
v.backgroundColor = UIColor(named: &amp;#34;myDarkColor&amp;#34;) 当你选择一个视图时，资产目录中的自定义命名颜色也会出现在库中和属性检查器中的颜色弹出菜单中，如下图所示：
可见性和透明度 视图的可见性和不透明度与3个属性相关，它们分别是isHidden，alpha和isOpaque，下面开始逐个介绍。
isHidden 视图可以通过将isHidden属性设置为true而变得不可见，并通过将其设置为false 而再次变成可见，因为隐藏视图并不会导致该视图从其层级结构中删除。被隐藏的视图（通常）不会收到触摸事件，所以对用户来说，就如同该视图不存在一样。
alpha 一个视图可以通过其alpha属性使其部分或完全透明。alpha属性的取值可以在0～1.0，1.0表示完全不透明，0.0表示完全透明。alpha属性既能影响视图的背景色也会影响其内容的透明度。
如果一个视图中显示了一个图像，并且有一个背景颜色，而它的alpha值小于1.0，那么背景颜色就会渗入到这个图像中。
如果一个父视图的alpha值为0.5，则它的所有子视图的alpha都将小于0.5，因为无论这些子视图的alpha属性值是多少，都是相对于父视图的0.5来进行绘制的。
一个完全透明（或非常接近完全透明）的视图就像一个isHidden为true的视图：它和它的子视图都是不可见的，而且（通常）不能被触摸到。
颜色也有一个alpha属性，这个值对于视图也有影响。一个视图的alpha值可以是1.0，但仍然可能有一个透明的背景色，因为它的背景颜色的alpha值可能小于1.0。
isOpaque isOpaque属性不同于isHidden和alpha，改变isOpaque属性值对视图的外观没有影响，只是对视图系统的绘制提示。
如果一个视图完全由不透明的物质填充并且它的alpha属性设置为1.0，那么视图就是完全不透明的，此时如果将视图的isOpaque属性设置为true，就可以更有效地进行绘制（对性能的拖累更小），否则应当将isOpaque设置为false。
当设置isHidden和alpha的值时，isOpaque属性值并不会跟着变化。isOpaque属性值的设置完全取决你自己，它的默认值为true。
Frame 每个view都有frame属性（是一个由CGRect表示的矩形，表示在父视图的坐标系统中的位置。默认情况下，父视图的坐标系将以左上角为原点，X坐标向右正向增长，Y坐标向下正向增长。
设置视图的frame值既可以重新改变视图的位置，也可以调整视图的大小，或者同时改变位置和大小。UIView的指定初始化方法是init(frame:)，可以通过这种方式指定视图的frame。若视图的frame属性值为CGRect.zero的话，则视图是不可见。
如果一个视图有一个你希望它采用的标准尺寸，特别是相对于它的内容（例如UIButton相对于它的标题）而言，除了改变frame，还可以调用其sizeToFit方法。
如果一个视图使用nib进行初始化，那么不会调用其init(frame:)，调用的为init(coder:)方法。
Bounds and Center Bounds 如下图所示，假设有一个父视图和子视图，子视图需要有10个point的镶边，首先想到的是设置子视图的frame，但该怎么设置？
CGRect有个insetBy(dx:dy:)方法可以从一个矩形中衍生出另一个矩形并嵌入。但是应该从哪个矩形中嵌入呢？不是从父视图的frame，因为frame代表一个视图在其父视图中的位置，并且是父视图的坐标系中的位置。
应当找一个用来描述在其自身坐标中与父视图矩形相关的CGRect，因为这是子视图的frame所要表达的坐标。描述视图在其自身坐标中的矩形CGRect是视图的bounds属性。
let v1 = UIView(frame:CGRect(113, 111, 132, 194)) v1.backgroundColor = UIColor(red: 1, green: 0.4, blue: 1, alpha: 1) let v2 = UIView(frame:v1.bounds.insetBy(dx: 10, dy: 10)) v2.backgroundColor = UIColor(red: 0.5, green: 1, blue: 0, alpha: 1) self.view.addSubview(v1) v1.addSubview(v2) 如果改变一个视图的bounds的size，那么它的frame也会发生变化。视图的frame的变化是围绕其center来的&amp;mdash;中心点不变。下面的代码只出现一个矩形，子视图完全覆盖父视图：
let v1 = UIView(frame:CGRect(113, 111, 132, 194)) v1.backgroundColor = UIColor(red: 1, green: 0.4, blue: 1, alpha: 1) let v2 = UIView(frame:v1.bounds.insetBy(dx: 10, dy: 10)) v2.backgroundColor = UIColor(red: 0.5, green: 1, blue: 0, alpha: 1) self.view.addSubview(v1) v1.addSubview(v2) v2.bounds.size.height &#43;= 20 v2.bounds.size.width &#43;= 20 如果改变一个视图的bounds原点，就会移动其内部坐标系的原点。当创建一个UIView时，它的边界坐标系的原点(0.0,0.0)就在它的左上方。因为一个子视图是相对于它的父视图的坐标系定位的，所以父视图的边界原点的改变也会改变子视图的显示位置，如下代码会导致父视图的大小和位置没有发生任何变化，但是子视图已经向左上角移动了：
let v1 = UIView(frame:CGRect(113, 111, 132, 194)) v1.backgroundColor = UIColor(red: 1, green: 0.4, blue: 1, alpha: 1) let v2 = UIView(frame:v1.bounds.insetBy(dx: 10, dy: 10)) v2.backgroundColor = UIColor(red: 0.5, green: 1, blue: 0, alpha: 1) self.view.addSubview(v1) v1.addSubview(v2) v1.bounds.origin.x &#43;= 10 v1.bounds.origin.y &#43;= 10 center 同样地，若改变一个视图的frame属性的size值，也会改变其bounds属性的size值。但是，改变bounds的size大小时，不会改变其center属性。
center代表子视图在父视图坐标系中的位置，确切地说，它表示子视图的bounds center在父视图中的位置：
let c = CGPoint(theView.bounds.midX, theView.bounds.midY) 改变视图的bounds不会改变的它的center，相应地改变视图的center不会改变bounds。即视图的center和bounds是相互独立的。bounds用于描述视图的大小，center用于描述视图在父视图中的位置。
实际上视图的frame属性是bounds和center的简便形式。当改变视图的frame属性时，bounds和center也会随之发生变化，当改变bounds和center时，视图的frame也会随之发生改变。尽管如此，调整一个视图在父视图中的可靠方式是使用bounds和center属性。
每个视图都有自己的坐标系统（使用bounds来表达），并且一个视图坐标系统的与它的父视图的坐标系统有一个明确的关系，即center属性。因此，可以在同一窗口中的任何两个视图的坐标之间进行转换：
open func convert(_ point: CGPoint, to view: UIView?) -&amp;gt; CGPoint open func convert(_ point: CGPoint, from view: UIView?) -&amp;gt; CGPoint open func convert(_ rect: CGRect, to view: UIView?) -&amp;gt; CGRect open func convert(_ rect: CGRect, from view: UIView?) -&amp;gt; CGRect 在convert方法中，第一个参数既可以是CGPoint也可以是CGRect，第二个参数是UIView，如果第二个参数为nil，则会认为是window。下面的例子是将v2放到v1的中心：
v2.center = v1.convert(v1.center, from:v1.superview) 另外一种更常见的方式是将子视图的中心放在父视图bounds的中心位置，如下所示：
v2.center = CGPoint(v1.bounds.midX,v1.bounds.midY) transform transform 视图的transform属性可以改变视图的绘制方式，显示大小，位置和方向，但不会改变bounds和center属性。transform属性值是一个CGAffineTransform结构体，代表代表3×3变换矩阵9个值中的6个（另外3个值是常数，所以没有必要在结构中表示它们）：
public struct CGAffineTransform {   public var a: CGFloat   public var b: CGFloat   public var c: CGFloat   public var d: CGFloat   public var tx: CGFloat   public var ty: CGFloat   public init()   public init(a: CGFloat, b: CGFloat, c: CGFloat, d: CGFloat, tx: CGFloat, ty: CGFloat) } 默认情况下，一个视图的变换矩阵是CGAffineTransform.identity，即同一变换，它没有可见的效果，所以你不知道它的存在。任何变换都是围绕视图的中心进行的，这个中心点一定是保持不变的。
let v1 = UIView(frame:CGRect(113, 111, 132, 194)) v1.backgroundColor = UIColor(red: 1, green: 0.4, blue: 1, alpha: 1) let v2 = UIView(frame:v1.bounds.insetBy(dx: 10, dy: 10)) v2.backgroundColor = UIColor(red: 0.5, green: 1, blue: 0, alpha: 1) self.view.addSubview(v1) v1.addSubview(v2) v1.transform = CGAffineTransform(rotationAngle: 45 * .pi/180) print(v1.frame) transform3D 从iOS 13开始，视图有一个新的transform3D属性。这个属性其实是底层layer的transform属性，现在通过视图暴露出来了。
Window坐标和屏幕座标 设备的屏幕没有frame，但有bounds。window没有父视图，但是它的frame是自动和设备屏幕的bounds相匹配的。window一般一开始就填满屏幕，并且通常会继续填满屏幕，因此大多数情况下，窗口坐标就是屏幕坐标。
在iOS 7及之前，屏幕坐标是不变的，transform属性是应用旋转能力的核心：因为window的frame和bounds被锁定在屏幕上，应用的界面通过对根视图应用旋转变换来补偿设备方向的变化，从而使其原点移动到用户现在看到的视图的左上方。
但iOS 8引入了一个重大变化：当应用程序旋转以补偿设备的旋转时，屏幕（以及随之而来的窗口）是旋转的。当应用程序的界面旋转时，故事中的任何视图&amp;ndash;无论是窗口、根视图还是其任何子视图&amp;ndash;都没有收到旋转变换。取而代之的是屏幕边界尺寸的换位（以及窗口边界和根视图边界尺寸的相应换位）：在纵向方向上，尺寸是高过宽，但在横向方向上，尺寸是宽过高。
Trait Collections 由于视图所处的大环境具有动态性质。如果有一个描述环境的对象，它可以通过视图控制器和视图的层次结构向下传播，同时也可以提醒该层次结构中的每个元素环境已经改变，是非常有用的。实际上，这是通过trait collection来管理的。
trait collection源于屏幕（即UIScreen），并通过window和视图控制器一路向下，直到每个单独的子视图。所有相关的类（UIScreen、UIViewController和UIPresentationController以及UIView）都实现了UITraitEnvironment协议，它提供了traitCollection属性和traitCollectionDidChange方法。
traitCollection是UITraitCollection类型，属于值类型，它带有相当数量的描述环境的属性。例如，displayScale能告诉你屏幕分辨率，userInterfaceIdiom说明设备类型&amp;ndash;iPhone或iPad，它还能报告诸如设备的强制触摸能力和显示色域等等。
当app运行时，如果traitCollection的任何属性发生变化，traitCollectionDidChange(_:)消息就会在UITraitEnvironments的层次结构中传播，旧的特性集合（如果有的话）被作为参数提供，新的特性集合可以作为self.traitCollection被检索。
如果要实现traitCollectionDidChange(_:)方法，首先应该调用super的方法，对于一个初学者来说，很容易忘记调用对应的super方法：
override func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) {  super.traitCollectionDidChange(previousTraitCollection) } 我们也可以构造自己的traitCollection，但不能直接设置任何traitCollection的属性值。可以通过init方法构造一个traitCollection，但是初始化器每次只能确定一个属性。如果想进一步增加属性值，可以通过调用init(traitsFrom:)初始化器，将一个traitCollection数组传入以组合成新的traitCollection，如下所示：
let tcdisp = UITraitCollection(displayScale: UIScreen.main.scale) let tcphone = UITraitCollection(userInterfaceIdiom: .phone) let tc1 = UITraitCollection(traitsFrom: [tcdisp, tcphone]) 初始化器init(traitsFrom:)中数组的工作方式与继承类似——进行有序的交叉。如果两个traitCollection被合并，并且它们都设置了相同的属性，那么获胜者是出现在数组后面或继承层次结构中更远的traitCollection。如果一个设置了一个属性，而另一个没有，那么设置该属性的那个就获胜。如果你创建了一个traitCollection，如果traitCollection在继承层次中，任何未指定的属性的值都将被继承。
如果需要比较traitCollection，可以调用containsTraits(in:)方法。如果参数traitCollection的每个属性的值与待比较的traitCollection中的属性值相匹配，则返回true。
对于UIViews来说，主要关注的traitCollection属性是是interface style和size class，所以接下来将会介绍这两者。
Interface Style 使用trait collection中的属性值userInterfaceStyle来报告大环境是light模式还是dark模式。如果界面上使用的颜色是动态颜色，切换userInterfaceStyle时，则界面会自动更改颜色。
然而，在某些情况下，你可能会手动管理一些颜色，你会想知道什么时候userInterfaceStyle发生了变化，这样就可以改变颜色作为回应。
假如我们要把资产目录中一个自定义的动态颜色应用到视图的borader上。这实际上是在视图的layer上完成的，要求我们使用该颜色的cgColor属性:
self.otherView.layer.borderWidth = 4 self.otherView.layer.borderColor = UIColor(named: &amp;#34;myDarkColor&amp;#34;)?.cgColor 上面代码的问题是，无论是layer上还是颜色的cgColor都不知道任何关于trait collection的信息。所以这就需要我们监听trait collection的变化，并在知道userInterfaceStyle发生变化后再次使用我们的动态颜色。多亏了trait collection的hasDifferentColorAppearance方法，可以避免做不必要的工作：
override func traitCollectionDidChange(_ prevtc: UITraitCollection?) {  super.traitCollectionDidChange(prevtc)  if prevtc?.hasDifferentColorAppearance(comparedTo: traitCollection) ?? true {  otherView.layer.borderColor = UIColor(named: &amp;#34;myDarkColor&amp;#34;)?.cgColor  } } 请注意，在上面的代码中不必知道userInterfaceStyle目前到底取什么值，只需要把动态颜色的cgColor取出来使用即可。这是因为从asset目录中UIColor(named: &amp;quot;myDarkColor&amp;quot;)访问动态颜色的行为是在先访问一个全局值UITraitCollection.current的情况下发生的。
在traitCollectionDidChange方法中和其他各种运行时正在绘制或执行布局的地方，这个值为我们自动设置，因此我们的动态颜色会在userInterfaceStyle变动时正确的取到，同时cgColor也能取到正确的值。在UITraitCollection.current没有被自动设置的情况下，我们可以自由地手动设置它，确保涉及动态颜色的后续操作将在正确的环境中进行。
同时，trait collection也是理解一个动态颜色到底是什么颜色的关键。.systemYellow是什么颜色？这取决于trait collection。所以要想知道动态颜色目前到底是怎么值，必须提供一个trait collection。这很容易，因为你可以创建一个trait collection，之后再调用 resolvedColor即可:
let yellow = UIColor.systemYellow let light = UITraitCollection(userInterfaceStyle: .light) let dark = UITraitCollection(userInterfaceStyle: .dark) let yellowLight = yellow.resolvedColor(with: light) // 1 0.8 0 1 let yellowDark = yellow.resolvedColor(with: dark) // 1 0.839216 0.0392157 1 除了userInterfaceStyle之外，trait collection还有一个userInterfaceLevel属性，它的取值为.base或.elevated。这个属性会影响到动态背景颜色，通常只有主界面前面的有限区域会受到影响。每个Alert都有一个.elevated界面级别，即使Alert后面的主界面没有。
Size Classes 关于应用程序旋转和类似旋转，最重要的事实不是旋转本身，而是应用程序的尺寸比例的变化。想象一下，root view的一个子视图，当设备处于纵向时位于屏幕的右下方。如果根视图的边界宽度和边界高度被改变，那么这个子视图就会在边界高度之外，从而离开屏幕&amp;ndash;除非你的应用程序以某种方式对这种变化做出反应，重新定位它（这样的反应被称为布局，这个主题将占据本章的大部分篇幅）。
环境的维度特征体现在一对size classes中，这对尺寸亦是trait collection属性值:horizontalSizeClass和verticalSizeClass：
上面的这两个属性都是UIUserInterfaceSizeClsass类型，取值为.regular和.compact。当应用程序的窗口占据整个屏幕时，这一对size classes有如下含义：
 在iPad上运行时，水平和垂直尺寸类都是.regular。 在iPhone上以portrait方向运行时，水平尺寸类是.compact，而垂直尺寸类是.regular。 在大的iPhone上以landscape方向运行时，水平尺寸类是.regular，而垂直尺寸类是.compact。大的手机是指iPhone 6/7/8 Plus, iPhone XR, iPhone XS Max, iPhone 11, and iPhone 11 Pro Max 在小的iPhone上以landscape方向运行时，水平和垂直尺寸类都是.regular。  从上面的情况来看，通过traitCollectionDidChange去监听size classes的变化，并不能知道界面是否已经旋转。size classes并不区分纵向的iPad和横向的iPad。它们区分的是最重要的极端情况：如果horizontal size class从.regular变成.compact，App会突然变得又高又窄，你可能想通过改变界面的某种方式来进行补偿。然而，根据我的经验，你通常不会为了监听size classes的变化而重写traitCollectionDidChange方法。相反，size classes是为了需要应对其他事件而监听。
Overriding Trait Collections 在某些情况下，隔断部分的UITraitEnvironment，并且谎报trait collection的内容是很有用的。因为，我们可能想让层次结构的一部分相信我们是在一个横向的iPhone上，而实际上我们是在一个纵向的iPhone上，或者你的应用程序的某些区域不应该对明暗模式之间的变化做出反应。
你不能仅仅通过设置视图的trait collection来直接将trait collection插入继承层次中，因为traitCollection不是一个可设置的属性。但是，在UIViewController中，你可以通过:
override func overrideTraitCollection(forChild childViewController: UIViewController) -&amp;gt; UITraitCollection? {  // } 来注入你自己的trait collection。同样的UIPresentationController也有一个类似的方法。
对于user interface style,UIViewController和UIView有一个更简单的方式，即使用override var overrideUserInterfaceStyle: UIUserInterfaceStyle。其中overrideUserInterfaceStyle是一个UIUserInterfaceStyle实例，默认值是.unspecified，含义为interface style应该是按层次结构向下传递的。但是你一旦将它设置为.light或.dark，就会阻止从层次结构中的那一点开始，将原本只继承trait collection的userInterfaceStyle属性，替代成自定义设置。
layout 当一个父视图的边界原点改变时，子视图会随着移动。但是，当父视图的尺寸改变时，子视图会发生什么变化呢？
实际上是什么也没发生变化，子视图的边界和中心没有改变，父视图的边界原点也没有移动，所以子视图保持在相对于其父视图左上方的相同位置。在现实生活中，这通常不是你想要的结果。你会希望子视图在其超视图的尺寸发生变化时能被调整大小和重新定位，这就是所谓的布局。
以下是父视图可能被动态调整大小的方式：
  你的应用程序可能会通过旋转自己来补偿用户将设备旋转90度，使其顶部移动到屏幕的新顶部，以匹配其新的方向&amp;ndash;因此，其边界的宽度和高度值会被移位。
  一个iPhone应用程序可能会在不同长宽比的屏幕上启动：例如，iPhone SE的屏幕比后来的iPhone型号的屏幕相对较短，应用程序的界面可能需要适应这种差异。
  一个通用的应用程序可能在iPad或iPhone上启动。应用程序的界面可能需要适应它所运行的屏幕的大小。
  从nib实例化的视图，如视图控制器的主视图或表视图单元，可能会被调整大小以适应它所处的界面。
  视图可能会对其周围视图的变化做出反应。例如，当一个导航栏被动态地显示或隐藏时，其余的界面可能会缩小或增长来补偿，以填补可用空间。
  用户可能会在iPad上改变你的应用程序窗口的宽度，作为iPad多任务界面的一部分。
  在上述任何一种情况下以及其他情况下，可能都需要进行布局。视图的子视图如果尺寸发生了变化，就需要移位、改变尺寸、重新分布，或者以其他方式进行补偿，以便界面看起来还不错，并保持可用。
布局通常有3种基本的方式：
  手动布局：每当父视图被调整大小时，它就会发送layoutSubviews消息。所以，要手动布局子视图，请提供你自己的子类并重写layoutSubviews。很明显，这可能会带来很多工作，但这意味着你可以做任何你喜欢的事情。
  自动调整大小：自动调整大小是自动执行布局的最古老的方式。当它的上层视图被调整大小时，子视图将按照它自己的autoresizingMask属性值所规定的规则进行响应，该属性描述了子视图和它的上层视图之间的大小调整关系。
  自动布局：自动布局依赖于视图的约束。约束是一个成熟的对象，它的数值描述了一个视图的尺寸或位置的某些方面，通常是就其他视图而言的。它比autoresizingMask更复杂，描述性更强。多个约束可以适用于单个视图，它们可以描述任何两个视图之间的关系（不仅仅是一个子视图和它的上层视图）。自动布局是在layoutSubviews的幕后实现的。实际上，约束允许你在没有代码的情况下编写复杂的layoutSubviews功能。
  你的布局策略可以使用上面3种的任何组合。需要手动布局的情况很少，但如果你需要，你可以实现它。自动调整大小是默认的。自动布局是自动调整大小的替代选择。但在现实生活中，很可能你的所有视图都会选择加入自动布局，因为它非常强大，最适合帮助你的界面适应很大的屏幕尺寸范围。视图的默认布局行为取决于它的创建方式：
  如果是从代码中创建的视图，默认情况下使用自动调整大小，而不是自动布局。如果你想让这样的视图使用自动布局，你必须故意抑制它对自动调整大小的使用。
  所有新的.storyboard和.xib文件都选择加入自动布局。他们的视图已经准备好自动布局。但如果你愿意，nib编辑器中的视图仍然可以使用自动调整大小。
  Autoresizing 自动调整大小是在概念上指定一个子视图 &amp;ldquo;弹簧和支杆&amp;quot;的问题。弹簧可以膨胀和收缩；支杆则不能。弹簧和支杆可以在内部或外部、水平或垂直地分配。有了两个内部弹簧或支杆，你就可以指定视图是否可以以及如何调整大小；有了四个外部弹簧或支杆，你就可以指定视图是否可以以及如何重新定位。
  一个子视图在其上层视图中居中，并保持居中，但随着上层视图的调整而调整自己的大小。它在外部有四个支柱，内部有两个弹簧。
  一个子视图在它的超视图中居中，并保持居中，而且不会随着父视图的调整而调整自己的大小。它在外部有四个弹簧，内部有两个支柱。
  一个OK按钮要停留在其超级视图的右下方。它内部有两个支柱，外部有两个来自其右侧和底部的支柱，外部有两个来自其顶部和左侧的弹簧。
  一个文本字段要保持在其超视图的顶部。它将随着超视图的扩大而扩大。它的外部有三根支柱，底部有一个弹簧；内部有一个垂直支柱和一个水平弹簧。
  在代码中，弹簧和支杆的组合是通过视图的autoresizingMask属性来设置的，它是一个位掩码（UIView.AutoresizingMask），这样你就可以组合选项。选项代表弹簧，没有指定的都是strut。默认是空集，显然是指所有的struts&amp;ndash;但当然不可能真的是所有的struts，因为如果父视图被调整大小，就需要改变一些东西，所以实际上空的autoresizingMask与.flexibleRightMargin和.flexibleBottomMargin一样，意味着视图被struts钉在左上方。
在debug的时候，当你把一个UIView打印到控制台时，它的autoresizingMask会用autoresize这个词和一个弹簧的列表来报告。外部弹簧是LM、RM、TM和BM；内部弹簧是W和H。autoresize = LM&#43;TM意味着有来自左侧和顶部的外部弹簧；autoresize = W&#43;BM意味着有一个内部水平弹簧和一个来自底部的弹簧。
Autolayout and Constraints 在单独的视图层面，自动布局是一种可选的技术。可以在同一界面的不同区域使用自动调整大小和自动布局；一个同级视图可以使用自动布局，而另一个同级视图不使用；一个父视图可以使用自动布局，而其部分或全部子视图不使用。
但是，自动布局是通过父视图链来实现的，如果一个视图使用了自动布局，那么它的所有父视图也会使用自动布局。如果（几乎可以肯定的是）这些视图中的一个是视图控制器的主视图，那么该视图控制器就会收到自动布局相关的事件。
view Controllers 视图控制器是UIViewController的一个实例，实际上，它将是一个UIViewController子类的实例；UIViewController被设计成可以被子类化。你可以编写你自己的UIViewController子类；也可以使用一个内置的子类，如UINavigationController或UITabBarController；或者你可以对一个内置的子类进行子类化，如UITableViewController。
视图控制器管理着一个视图以及该视图的子视图，它们的子视图等等。处于该层次结构顶端的单一超级视图是视图控制器的主视图，或者简单说是它的视图，即视图控制器的view属性指向它。视图控制器的主视图没有明确的指针指向管理它的视图控制器，但视图控制器是一个UIResponder，在响应者链中就在其视图之上，所以它是其视图的下一个响应者。
为了让视图控制器发挥作用，它的视图必须以某种方式进入可见界面。视图控制器通常负责这个工作，但通常不是其视图的视图控制器，而是某个视图已经进入界面的视图控制器。在许多情况下，这将自动发生（我会在下一节中更多地谈论这个问题），但你可以参与这个过程，对于某些视图控制器，你可能必须自己做这项工作。一个来了的视图最终也可能会离开，负责将一个视图放入界面的视图控制器通常也会负责将其删除。
视图控制器通常会在视图出现或消失时提供界面的动画。内置的视图控制器子类，以及召唤或移除视图控制器及其视图的内置方法，都有内置的动画。我们都很熟悉轻击某个东西使新的界面从屏幕一侧滑入，然后再轻击一个返回按钮使该界面再次滑出。谁负责让视图控制器的视图进入界面，谁就负责提供动画。
最强大的视图控制器是顶层的视图控制器。这可能是一个全屏呈现的视图控制器，我将在本章后面解释。但大多数时候，它将是你的应用程序的根视图控制器。这是管理根视图的视图控制器，根视图位于整个视图层次结构的顶端，是窗口的唯一直接子视图，作为应用程序其他界面的超级视图。根视图控制器之所以能达到这个崇高的位置，是因为UIApplicationMain或者你的代码把它放在那里，把它实例化并分配给了窗口的rootViewController属性。窗口的反应是采用视图控制器的主视图，给它一个正确的框架（必要时调整其大小），并使其成为自己的子视图。
</content>
    </entry>
    
     <entry>
        <title>Swift 5.3 新特性</title>
        <url>https://iihui.github.io/post/swift-5.3/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  Swift 5.3引入了很多新特性，包括多尾闭包、多模式catch、枚举比较、闭包中self省略以及Swift Package Manager等一些重要改变。
 多尾闭包 以前 在Swift 5.3前尾闭包提供了精简写法，但仅限于函数最后一个参数为函数闭包。而当函数有多个函数闭包参数时，如果该函数类型参数不为最后一个参数时，不能使用精简写法。如下所示，既有在圆括号内的闭包，又有在圆括号外的闭包：
// 写法 1（传统写法） UIView.animate(withDuration: 0.25, animations: {  // animation code }, completion: { completed in  // completion code })  // 写法 2（单尾闭包精简写法） UIView.animate(withDuration: 0.25, animations: {  // animation code }) { completed in  // completion code } 现在 而在Swift 5.3中，同一个函数的多尾闭包有了新的精简模式。在第一闭包之后可以使用标签的方式来使用尾闭包。这种新的写法把最后的连续几个闭包参数都算作是尾闭包，这些闭包都可以放在圆括号外面。
UIView.animate(withDuration: 0.3) {  self.view.alpha = 0 } completion: { _ in  self.view.removeFromSuperview() } 但是，这些尾闭包中第一个闭包被强制省略标签。苹果的解释是：如果允许第一个尾闭包加上标签，那么开发者需要考虑是加好还是不加好，这会导致代码风格不一致，那么干脆禁了吧。也就是除了第一个尾闭包需要省略标签之外，其余的尾闭包都需有标签。
参考资料
多模式catch语句 以前 在Swift 5.3之前，捕获同一类型Error只能有一个catch，然后再使用switch语句区分同一类型Error中具体的哪种错误，如下所示：
enum TaskError: Error {  case someRecoverableError  case someFailure(msg: String)  case anotherFailure(msg: String) }  func performTask() throws -&amp;gt; String {  throw TaskError.someFailure(msg: &amp;#34;some Failure&amp;#34;) }  func recover() {  // }  do {  try performTask() } catch let error as TaskError {  switch error {  case .someFailure(let msg), .anotherFailure(let msg):  debugPrint(msg)  case .someRecoverableError:  recover()  } } 现在 Swift 5.3可以使用多个catch块捕获同一类型不同类错误，这个特性使得代码具有更好的可读性，并且能够有效减少代码行数：
do {  try performTask() } catch TaskError.someRecoverableError {  recover() } catch TaskError.someFailure(let msg), TaskError.anotherFailure(let msg) {  debugPrint(msg) }  enum TemperatureError: Error {  case tooCold, tooHot }  func getReactorTemperature() -&amp;gt; Int {  90 }  func checkReactorOperational() throws -&amp;gt; String {  let temp = getReactorTemperature()   if temp &amp;lt; 10 {  throw TemperatureError.tooCold  } else if temp &amp;gt; 90 {  throw TemperatureError.tooHot  } else {  return &amp;#34;OK&amp;#34;  } }  do {  let result = try checkReactorOperational()  print(&amp;#34;结果: \(result)&amp;#34;) } catch TemperatureError.tooHot, TemperatureError.tooCold {  // 捕获多个异常  debugPrint(&amp;#34;关闭反应堆&amp;#34;) } catch {  debugPrint(&amp;#34;未知错误&amp;#34;) } 枚举Comparable 之前 在Swift 5.3之前，如果需要比较enum，则需要enum遵循Comparable协议，并且需要实现&amp;lt;和minimum方法，但是这种代码极难维护，因为如果添加一个枚举值，则需要更新&amp;lt;和minimum方法，才能比较enum，否则会报错：
enum Volume: Comparable {  case low  case medium  case high   private static func minium(_ lhs: Self, _ rhs: Self) -&amp;gt; Self {  switch (lhs, rhs) {  case (.low, _), (_, .low):  return .low  case (.medium, _), (_, .medium):  return .medium  case (.high, _), (_, .high):  return .high  }  }   private static func &amp;lt; (_ lhs: Self, _ rhs: Self) -&amp;gt; Bool {  return (lhs != rhs) &amp;amp;&amp;amp; (lhs == self.minium(lhs, rhs))  } } 可以使用扩展的方式解决上面的比较问题，即在扩展中添加一个容易比较的计算属性值，在实现静态方法&amp;lt;时，使用自定义的comparableValue即可：
private var comparableValue: Int {  switch self {  case .low:  return 0  case .medium:  return 1  case .high:  return 2  } }  private static func &amp;lt; (_ lhs: Self, _ rhs: Self) -&amp;gt; Bool {  return lhs.comparableValue &amp;lt; rhs.comparableValue } 现在 在Swift 5.3中，只要enum没有关联值或者只有一个Comparable的关联值，则会自动实现实现&amp;lt;和minimum方法，定义的enum直接可以进行比较：
enum Size: Comparable {  case small(Int)  case medium  case large(Int) }  let sizes: [Size] = [.medium, .small(4), .large(5), .large(1), .small(1)] debugPrint(sizes.sorted()) //[__lldb_expr_13.Size.small(1), __lldb_expr_13.Size.small(4), __lldb_expr_13.Size.medium, __lldb_expr_13.Size.large(1), __lldb_expr_13.Size.large(5)] self的省略 之前 在Swift 5.3之前，在闭包中对当前对象的属性或方法的引用，都要明确添加self，即便闭包不会产生循环引用时，也必须要添加：
struct SomeStruct {  var x = 0   func doSomething(task: @escaping () -&amp;gt; Void) {  task()  }   func test() {  doSomething {  // 闭包中使用属性，需要显式添加self  debugPrint(self.x)  }  } } 现在 而在Swift 5.3中，在闭包中对当前对象的属性或方法的引用没有这样的限制，可以去除self，直接使用属性和方法，如下所示：
struct SomeStruct {  var x = 0   func doSomething(task: @escaping () -&amp;gt; Void) {  task()  }   func test() {  doSomething {  debugPrint(x)  }  } } 还有一种新的方法在捕获列表中使用self，只需在捕获列表中加入[self]。这样就可以避免在闭包中反复使用self，如下所示：
class SomeClass {  var x = 0   func doSomething(task: @escaping () -&amp;gt; Void) {  task()  }   func newTest() {  doSomething { [self] in  x &#43;= 1  x = x * 5  }  } } 但是对于在逃逸闭包中，为了防止循环引用时添加的[weak self]，在Swift 5.3中仍然不能省略，依旧需要添加[weak self]。
参考资料
main 直到Swift 5.3之前，开发一个Swift程序需要在main.swft文件中定义程序启动点。现在，能够用@main和静态func main()方法来标记一个结构或基类（在任何文件中），当程序启动时，它将被自动被调用：
@main struct TerminalApp {  static func main() {  debugPrint(&amp;#34;Hello Swift 5.3&amp;#34;)  } } 但使用@main时，如果main.swift文件已经存在，就不应该使用它。因为@main应该在基类或结构体中使用，而且只应该定义一次。
where 在Swift 5.3中可以在具有泛型和扩展的函数中使用where子句。如下所示sorted方法中要求Element遵循Comparable协议：
struct Stack&amp;lt;Element&amp;gt; {  private var array = [Element]()  mutating func push(_ item: Element) {  array.append(item)  }   mutating func pop() -&amp;gt; Element? {  array.popLast()  } }  extension Stack {  // where   func sorted() -&amp;gt; [Element] where Element: Comparable {  array.sorted()  } } didSet 在Swift 5.3中，didSet发生了一些变化：
  如果didSet中没有使用到oldValue，则不会调用get方法，这意味着节省了内存和CPU的开销。这种方式称为simple didset。
  如果存在simple didset，但没有will set，则允许修改在原地发生「allow modifications to happen in-place.」
  参考资料
Float16 因为在图像处理和机器学习领域，经常会使用Float16。所以Swift 5.3中标准库添加了Float16类型，Float16是一个半精度，即16位的浮点值类型。
debugPrint(Float16.pi) //3.14 debugPrint(Float32.pi) //3.1415925 </content>
    </entry>
    
     <entry>
        <title>Swift 5.2 新特性</title>
        <url>https://iihui.github.io/post/swift-5.2/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  Swift 5.2于2020.03.24发布，新增了许多新的特性，专注于改善开发体验并增加了一些新功能，新功能大部分以增强函数式编程风格为导向。
 KeyPath 在Swift 5.2中允许使用key path表达式替代key path函数。下面的代码中，使用了cars.filter(\.isElectric)来代替key path函数：
let cars: [Car] = [Car(brand: &amp;#34;Tesla&amp;#34;, isElectric: true), Car(brand: &amp;#34;Ford&amp;#34;, isElectric: false)] let electricCars1 = cars.filter { $0.isElectric } let electricCars2 = cars.filter { $0[keyPath: \Car.isElectric] } let electricCars3 = cars.filter(\.isElectric) 实例调用函数 这个新功能允许拥有名为callAsFunction方法的实例直接调用该方法，即实例可以像函数一样被调用。如下所示的代码中base2Pow(x: 3)调用的就是callAsFunction(x: Double)这个函数：
struct MyPow {  let base: Double   func callAsFunction(x: Double) -&amp;gt; Double {  return pow(base, x)  } }  let base2Pow = MyPow(base: 2) debugPrint(base2Pow(x: 3)) // 直接使用实例调用方法 在Swift中，任何拥有callAsFunction方法的对象都可以像一个函数一样被调用，这样的对象被称为可调用的。实际上callAsFunction方法的调用有3种，如下所示：
struct WannabeFunction {  func callAsFunction() {  debugPrint(&amp;#34;Hi there&amp;#34;)  } }  let wan = WannabeFunction() wan() wan.callAsFunction() WannabeFunction.callAsFunction(wan)() 实际上callAsFunction()方法遵从所有Swift函数规则，它也可以被声明在类的扩展中。下面的代码便是在WannabeFunction结构体的扩展中定义一个callAsFunction：
struct WannabeFunction {  // }  extension WannabeFunction {  func callAsFunction() {  debugPrint(&amp;#34;Hi there&amp;#34;)  } }  let wan = WannabeFunction() wan() wan.callAsFunction() WannabeFunction.callAsFunction(wan)() 在对象类型中定义的callAsFunction()方法既可以重载，也可以作为函数参数进行传递。下面的代码中重载了6个callAsFunction方法：
struct WannabeFunction {  func callAsFunction() {  debugPrint(#function)  }   // Argument label overloading  func callAsFunction(x: Int) {  debugPrint(#function, x)  }   func callAsFunction(y: Int) {  debugPrint(#function, y)  }   // Argument type overloading  func callAsFunction(x: String) {  debugPrint(#function, x)  }   // Generic type constraint overloading  func callAsFunction&amp;lt;T&amp;gt;(value: T) where T: Numeric {  debugPrint(#function, value)  }   func callAsFunction&amp;lt;T&amp;gt;(value: T) where T: StringProtocol {  debugPrint(#function, value)  } }  let wan = WannabeFunction() wan() // callAsFunction() wan(x: 1) // callAsFunction(x:) 1 wan(y: 2) // callAsFunction(y:) 2 wan(value: 3) // callAsFunction(value:) 3 wan(value: &amp;#34;str&amp;#34;) // callAsFunction(value:) str wan([1, 2, 3]) // ❌ Error: Type of expression is ambiguous without more context let fo = wan.callAsFunction(y:) fo(10)  //&amp;#34;callAsFunction()&amp;#34; //&amp;#34;callAsFunction(x:)&amp;#34; 1 //&amp;#34;callAsFunction(y:)&amp;#34; 2 //&amp;#34;callAsFunction(value:)&amp;#34; 3 //&amp;#34;callAsFunction(value:)&amp;#34; &amp;#34;str&amp;#34; //&amp;#34;callAsFunction(y:)&amp;#34; 10 如果没有可调用语法，引用和传递泛型函数是不可能的。如果试图引用一个泛型函数，就会出现编译错误，下面的代码会出现Cannot explicitly specialize a generic function编译错误：
func bar&amp;lt;T&amp;gt;(_ x: T) {  debugPrint(x) }  let f = bar&amp;lt;Int&amp;gt;() // Cannot explicitly specialize a generic function： 不能显式地特化泛型函数 但使用callAsFunction()方法就可以实现，在下面代码中f被赋值为{ print($0) }，然后Bar的实例f1可以通过语法糖来调用f：
struct Bar&amp;lt;T&amp;gt; {  var f: (T) -&amp;gt; Void   func callAsFunction(_ x: T) {  f(x)  } }  let f1 = Bar&amp;lt;Int&amp;gt; {  debugPrint($0) } f1(1)  let bar = Bar&amp;lt;Int&amp;gt;() {  debugPrint($0) }  bar(2) 如果对于每个输入，两个函数产生相同的输出，则被认为是相等的。鉴于某些类别是无限的，实现这一目标的唯一可能的方法是将函数包装成一个名义类型(nominal type)。
下面的例子展示了如何通过将一个函数包装成一个名义类型来为它添加可识别、可散列和可等价的一致性。callAsFuntion()方法允许我们使用类似函数的语法来调用包装器：
struct Function&amp;lt;Input, Output&amp;gt;: Identifiable {  let id: UUID  let f: (Input) -&amp;gt; Output   init(id: UUID = UUID(), f: @escaping (Input) -&amp;gt; Output) {  self.id = id  self.f = f  }   func callAsFunction(_ input: Input) -&amp;gt; Output {  f(input)  } }  extension Function: Equatable {  static func == (lhs: Function&amp;lt;Input, Output&amp;gt;, rhs: Function&amp;lt;Input, Output&amp;gt;) -&amp;gt; Bool {  lhs.id == rhs.id  } }  extension Function: Hashable {  func hash(into hasher: inout Hasher) {  hasher.combine(id)  } } Partial application和 bound closures可以使用可调用语法来建模。Partial application是一种函数式编程技术，意味着将一些参数绑定到一个函数上，而不对其进行完全评估：
func add(_ x: Int) -&amp;gt; (_ y: Int) -&amp;gt; Int {  { y in x &#43; y } }  let addTwo = add(2) print(addTwo(3)) // 5 上面的Partial application可以使用使用callAsFunction来进行替换。如下所示，定义一个sum结构体来代替上面的方法：
struct Sum {  var x: Int  func callAsFunction(_ y: Int) -&amp;gt; Int { x &#43; y } }  // 2. let addTwo = Sum(x: 2) print(addTwo(3)) // 5 对于经常忘记写[weak self]这种问题，有人提出了auto-weak delegate模式。这个模式也可以使用callAsFunction提高可读性：
class Delegate&amp;lt;Input, Output&amp;gt; {  init() {}   private var block: ((Input) -&amp;gt; Output?)?  func delegate&amp;lt;T: AnyObject&amp;gt;(on target: T, block: ((T, Input) -&amp;gt; Output)?) {  self.block = { [weak target] input in  guard let target = target else { return nil }  return block?(target, input)  }  }   func call(_ input: Input) -&amp;gt; Output? {  return block?(input)  }   func callAsFunction(_ input: Input) -&amp;gt; Output? {  return call(input)  } }  class DataLoader {  let onLoad = Delegate&amp;lt;(), Void&amp;gt;()  func loadData() {  onLoad(())  } }  class ViewController: UIViewController {  let loader = DataLoader()   override func viewDidLoad() {  super.viewDidLoad()  loader.loadData()  loader.onLoad.delegate(on: self) { (self, _) in  self.setupLoadedUI()  }  }   func setupLoadedUI() {} } 参考资料
下标默认值 在Swift 5.2中定义下标的时候，可以带默认值参数。在下面的例子中，在下标越界的情况下，返回一个默认值：
struct Building {  var floors: [String]   subscript(index: Int, default default: String = &amp;#34;Unknown&amp;#34;) -&amp;gt; String {  if index &amp;gt;= 0, index &amp;lt; floors.count {  return floors[index]  } else {  return `default`  }  } }  let building = Building(floors: [&amp;#34;Ground Floor&amp;#34;, &amp;#34;1st&amp;#34;, &amp;#34;2nd&amp;#34;, &amp;#34;3rd&amp;#34;]) Lazy filtering 在Swift 5.2前使用lazy filtering时，运算顺序从右到左。在Swift 5.2后运算顺序变成了从左到右。下面的代码在Swift 5.2前的输出为1，2，3，4，5，到Swift 5.2后则为2，4，如下所示：
let numbers1 = [1, 2, 3, 4, 5].lazy.filter { $0 % 2 == 0 }.filter { print($0); return true }  _ = numbers1.count // 2  // 4 </content>
    </entry>
    
     <entry>
        <title>Xcode编译报错问题</title>
        <url>https://iihui.github.io/post/ios-compiler/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> xxx-Swift.h未找到 如果报xxx-Swift.h未找到，则需要检查设置中的Swift Compiler - General下的Objective-C Generated Interface Header Name是否有对应的文件：
iOS 14.5.1编译报错 使用XCode 12.4在iOS 14.5.1的真机上编译时，打断点调试时，不能正常打印出成员变量的值，出现如下的报错信息：
查阅网上的资料，应该在设置Build Setting时将Debug的Optimization Level设置为None，如下所示：
但是上述方法对于在XCode 12.4中调试iOS 14.5.1真机却不生效。但新建一个demo工程，却可以正常调试，设置如下：
XCode 12.5 报错 使用XCode 12.5编译项目报Showing Recent Messages Application extensions and any libraries they link to must be built with the APPLICATION_EXTENSION_API_ONLY build setting set to YES.。需要将报错的Target的编译设置中的Require Only App-Extensions-Safe API置为YES即可：
</content>
    </entry>
    
     <entry>
        <title>Swift 基础</title>
        <url>https://iihui.github.io/post/swift-base/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> 语句 一个Swift文件包含多行文本。换行对于Swift来说是有意义的，代表一条语句的结束，因此Swift中一般一行只写一条语句。如果需要在一行中写多条语句，则需要分号隔开，但不推荐这样做。
print(&amp;#34;hello&amp;#34;) print(&amp;#34;world&amp;#34;) print(&amp;#34;hello&amp;#34;); print(&amp;#34;world&amp;#34;) 常量和变量 Swift的常量或者变量使用前必须先声明，使用let来声明常量，使用var来声明变量。常量赋初值后就不能再改变，如果尝试改变其值，则会报错。变量的值可以任意变化，随时修改。
显式声明 有两种方式声明变量，即显式和隐式，显式和隐式说的是声明常量或变量的时候是否明确指明类型。在变量声明时明确指定变量的类型则为显式变量声明，声明格式为var name: type = value：
var firstNumber: Int = 5 let firstNum: Int = 6 隐式声明 在变量声明时不指明变量的类型，而是由编译器推断出相应的类型，则为隐式声明。大部分情况下Swift足够智能，可以通过初始化值来推断出相应的类型：
var firstNumber = 5 let firstNum = 100 可选类型 当一个变量或者常量可能不存在值时，应该使用可选类型来声明。一个可选类型表示一个变量可能有值也可能没有值。可选类型可能不包含值，所以在访问前需要判断是否为nil。
var optionStr: String? optionStr = &amp;#34;Any Test&amp;#34;  if let str = optionStr {  debugPrint(str) }  if var str = optionStr {  str &#43;= &amp;#34;closure&amp;#34;  debugPrint(str) } 数组 声明 数组要求其中元素类型一致。数组声明的时候可以不指定类型，由编译器推断出类型。也可以在声明的时候指明类型，示例代码如下所示：
let arrayOne = [12, 34, 667] var arrayTwo = [Int]() var arrayThree: [Int] = [] let testMo = Array(repeating: &amp;#34;12&amp;#34;, count: 12) var testMo1 = Array([&amp;#34;1&amp;#34;,&amp;#34;23&amp;#34;,&amp;#34;45&amp;#34;,&amp;#34;90&amp;#34;,&amp;#34;test&amp;#34;,&amp;#34;mp&amp;#34;,&amp;#34;Y&amp;#34;]) 特殊数组 在Swift中，关键字Any可以代表任何类型的实例，包括函数类型。因此，在数组的定义时，使用Any可以保存不同类型数据元素：
var myArray: [Any] = [1,&amp;#34;Two&amp;#34;] 访问元素 数组元素的访问，包括以下标的形式访问数组中的任意一个元素。还可以以first来访问第一个元素，使用last属性来访问最后一个元素：
let arrayOne = [12, 34, 667] debugPrint(arrayOne[0], arrayOne[1], arrayOne[2])  var multiArray = [[1, 2], [3, 4], [5, 6]] let arr = multiArray[0] let value = multiArray[0][1] debugPrint(arr, value, arr.first, arr.last, multiArray.first, multiArray.last) 使用shuffle()或者shuffled()可以对数组进行重新洗牌，新生成一个随机序列。但调用shuffle()会改变原数组的顺序：
debugPrint(array, array.shuffled(), array.shuffled(), array) //[12, 34, 5, 89, 0, 1] [5, 1, 0, 89, 12, 34] [12, 34, 5, 89, 0, 1] [12, 34, 5, 89, 0, 1] array.shuffle() debugPrint(array) //[34, 0, 5, 12, 89, 1] 数组切片 数组切片是指以range的方式取数组中元素。下面的代码使用range的方式，以numbers[1 ... 3] = [100, 200, 400]方式整体改变数组中某些元素：
var numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] numbers[1 ... 3] = [100, 200, 400] debugPrint(numbers) diff var scores1 = [100, 81, 95, 98, 99, 65, 87]  var scores2 = [100, 98, 95, 91, 83, 88, 72]  let diff = scores2.difference(from: scores1) let newArr = scores1.applying(diff) ?? []  debugPrint(newArr) //[100, 98, 95, 91, 83, 88, 72] 字典 字典有时被称为哈希表，保存键和值之间的配对集合。key可以是任何符合Hashable协议的元素，而value可以是任何类型。与数组不同，字典的内容不是按顺序存储的。
声明 字典的声明与数组的声明一样，包括初始化隐式声明和指明类型两种。初始化隐式声明即通过编译器确定key和value类型：
let countries = [&amp;#34;US&amp;#34;: &amp;#34;UnitedStates&amp;#34;, &amp;#34;IN&amp;#34;: &amp;#34;India&amp;#34;, &amp;#34;UK&amp;#34;: &amp;#34;UnitedKingdom&amp;#34;] var dic1 = [String: String]() var dic2 = [Int: String]() var dic3 = [String: AnyObject]() var dic4: [String: String] = [:] var dic5: [Int: String] = [:] var dict1 = Dictionary&amp;lt;String, Any&amp;gt;() 更新或添加 字典中已有值的更新或添加可以通过赋值或者调用updateValue函数来改变key对应的value，如果key在字典中不存在，则更新不生效：
var countries = [&amp;#34;US&amp;#34;: &amp;#34;UnitedStates&amp;#34;, &amp;#34;IN&amp;#34;: &amp;#34;India&amp;#34;, &amp;#34;UK&amp;#34;: &amp;#34;UnitedKingdom&amp;#34;] countries.updateValue(&amp;#34;test&amp;#34;, forKey: &amp;#34;US&amp;#34;) debugPrint(countries) countries[&amp;#34;US&amp;#34;] = &amp;#34;MoTest&amp;#34; debugPrint(countries) 移除值 字典中已有值的移除可以通过重新赋值为nil或者调用removeValue函数来移除。如果key在字典中不存在，则移除不生效：
var countries = [&amp;#34;US&amp;#34;: &amp;#34;UnitedStates&amp;#34;, &amp;#34;IN&amp;#34;: &amp;#34;India&amp;#34;, &amp;#34;UK&amp;#34;: &amp;#34;UnitedKingdom&amp;#34;] countries[&amp;#34;US&amp;#34;] = nil countries.removeValue(forKey: &amp;#34;UK&amp;#34;) debugPrint(countries) 集合 在Swift中的集合是非有序集合，并且集合中每个元素都是唯一的，不可重复的。如果使用for循环来遍历集合，得到的顺序是随机的。
声明 字典的声明与数组的声明一样，包括初始化隐式声明和指明类型两种。初始化隐式声明即通过编译器确定集合类型：
var mySet1 = Set&amp;lt;String&amp;gt;() var mySet2 = Set([&amp;#34;one&amp;#34;, &amp;#34;two&amp;#34;, &amp;#34;three&amp;#34;]) 插入 mySet1.insert(&amp;#34;test&amp;#34;) mySet2.insert(&amp;#34;name&amp;#34;) 移除 mySet1.remove(&amp;#34;test&amp;#34;) mySet2.remove(&amp;#34;name&amp;#34;) 过滤 在集合或者枚举类型中，通过需要使用过滤功能，这包括在集合中使用where子句，for case， if case和filter函数等。
where for number in 1...30 where number % 3 == 0 {  debugPrint(number) } for case var worldSeriesWinners = [(&amp;#34;Red Sox&amp;#34;, 2004),  (&amp;#34;White Sox&amp;#34;, 2005),  (&amp;#34;Cardinals&amp;#34;, 2006),  (&amp;#34;Red Sox&amp;#34;, 2007),  (&amp;#34;Phillies&amp;#34;, 2008),  (&amp;#34;Yankees&amp;#34;, 2009),  (&amp;#34;Giants&amp;#34;, 2010),  (&amp;#34;Cardinals&amp;#34;, 2011),  (&amp;#34;Giants&amp;#34;, 2012),  (&amp;#34;Red Sox&amp;#34;, 2013),  (&amp;#34;Giants&amp;#34;, 2014), (&amp;#34;Royals&amp;#34;, 2015)]  for case (&amp;#34;Red Sox&amp;#34;, let year) in worldSeriesWinners {  debugPrint(year) } let myNumbers: [Int?] = [1, 2, nil, 4, 5, nil, 6] for case .some(let num) in myNumbers {  debugPrint(num) } let myNumbers2: [Int?] = [1, 2, nil, 4, 5, nil, 6] for case let num? in myNumbers2 where num &amp;lt; 3 {  debugPrint(num) } if case enum Identifier {  case Name(String)  case Number(Int)  case NoIdentifier }  var playerIdentifier = Identifier.Number(2) if case .Number(let num) = playerIdentifier {  debugPrint(&amp;#34;Player&amp;#39;s number is \(num)&amp;#34;) }  if case .Number(let num) = playerIdentifier, num == 2 {  debugPrint(&amp;#34;Player is either XanderBogarts or Derek Jeter&amp;#34;) } 协议 声明 协议中既可以声明方法，也可以声明属性。如下所示声明了CalorieCountProtocol协议，协议中既包含了方法也有属性：
protocol CalorieCountProtocol {  var calories: Int { get }   func description() -&amp;gt; String } 下面类Burger实现了CalorieCountProtocol协议。虽然协议里面声明的是变量，但实现协议的时候使用了常量，这是因为协议定义的时候只需要实现get方法即可，并未要求set方法：
class Burger: CalorieCountProtocol {  let calories = 800   func description() -&amp;gt; String {  return &amp;#34;This burger has \(calories)calories&amp;#34;  } } 协议的实现既可以在定义的时候，也可以在扩展中实现，下面代码在Sauce枚举扩展中实现CalorieCountProtocol协议，如下所示：
enum Sauce {  case chili   case tomato }  extension Sauce: CalorieCountProtocol {  var calories: Int {  switch self {  case .chili:   return 20   case .tomato:   return 15  }  }   func description() -&amp;gt; String {  return &amp;#34;This sauce has \(calories)calories&amp;#34;  } } 协议数组 在数组中要求其中的所有元素都是相同的，有了协议之后。只要符合相同协议的类型实例都可以放进这个协议数组中，如下所示：
let burger = Burger()  let sauce = Sauce.tomato  let foodArray: [CalorieCountProtocol] = [burger, sauce]  debugPrint(foodArray.reduce(0) { $0 &#43; $1.calories }) 协议继承 面向协议的编程过程中，需要使用协议继承、协议组合，协议扩展。协议继承是指一个协议可以继承一个或者多个协议。如下所示，Person协议继承了Name,Age,Hair，而协议Dog继承了Name, Age, Fur：
protocol Name {  var firstName: String { get set }  var lastName: String { get set } }  protocol Age {  var age: Double { get set } }  protocol Fur {  var furColor: UIColor { get set } }  protocol Hair {  var hairColor: UIColor { get set } }  protocol Person: Name, Age, Hair {  var height: Double { get set } }  protocol Dog: Name, Age, Fur {  var breed: String { get set } } 协议组合 协议组合是指允许类型实现多个协议，这是面向协议的设计相对于面向对象的设计所具有的众多优势之一，因为对象只能有一个父类。
protocol Name {  var firstName: String { get set }  var lastName: String { get set } }  protocol Age {  var age: Double { get set } }  protocol Fur {  var furColor: UIColor { get set } }  protocol Hair {  var hairColor: UIColor { get set } }  protocol Persion: Name, Age, Hair {  var height: Double { get set } }  protocol Dog: Name, Age, Fur {  var breed: String { get set } }  protocol Occupation {  var occupationName: String { get set }  var yearlySalary: Double { get set }  var experienceYears: Double { get set } }  struct Programmer: Persion, Occupation {  var firstName: String  var lastName: String  var age: Double  var hairColor: UIColor  var height: Double  var occupationName: String  var yearlySalary: Double  var experienceYears: Double } 协议中的where 在对协议进行过滤时，可以使用where：
for (index, animal) in animals.enumerated() where animal is SeaAnimal {  print(&amp;#34;Only Sea Animal: \(index)&amp;#34;) } 泛型 泛型函数 定义泛型函数时，可以同时添加多种泛型占位符，习惯上使用T或者E作为泛型占位符，如下所示：
func testGeneric&amp;lt;T, E&amp;gt;(a: T, b: E) {  // Statements } 使用泛型函数来交换变量的值：
func swapGeneric&amp;lt;T&amp;gt;(a: inout T, b: inout T) {  let tmp = a  a = b  b = tmp }  var a = 56 var b = 66  swapGeneric(a: &amp;amp;a, b: &amp;amp;b) 定义泛型函数时，可以指定其遵循某种协议或者属于某种类型。有多个泛型占位符，可以部分指定遵循某种协议或者属于某种类型，也可以全部指定：
func testGenericComparable&amp;lt;T: Comparable&amp;gt;(a: T, b: T) -&amp;gt; Bool {  a == b }  func testFunction&amp;lt;T: MyClass, E: MyProtocol&amp;gt;(a: T, b: E) {  // Statements } 泛型类型 不仅可以使用class定义泛型类，也可以在使用struct、enum时定义泛型类型：
class List&amp;lt;T&amp;gt; {  var items = [T]() }  var stringList = List&amp;lt;String&amp;gt;() var doubleList = List&amp;lt;Double&amp;gt;()  struct GenericStruct&amp;lt;T&amp;gt; {  // }  enum GenericEnum&amp;lt;T&amp;gt; {  // } 有条件扩展泛型 可以有条件地对泛型进行扩展，下面对List添加扩展，并要求其遵循Numeric协议：
extension List where T: Numeric {  func sum() -&amp;gt; T {  items.reduce(0, &#43;)  } } 有条件添加函数 从Swift 5.3中开始可以在泛型类型或者泛型类型扩展中，有条件添加方法：
extension List {  func sum() -&amp;gt; T where T: Numeric {  items.reduce(0, &#43;)  }   func sorted() -&amp;gt; [T] where T: Comparable {  items.sorted()  } } Conditional conformance Conditional conformance允许泛型占位符遵循某种协议才遵循某种协议，如下所示：
extension List: Equatable where T: Equatable {  static func == (l1: List, l2: List) -&amp;gt; Bool {  if l1.items.count != l2.items.count {  return false  }  for (e1, e2) in zip(l1.items, l2.items) {  if e1 != e2 { return false }  }  return true  } } 泛型下标 在Swift 4前，如果要使用泛型下标，必须要在类或者结构体层面定义。从Swift 4开始，可以创建泛型下标，下标的返回类型或其参数都可以是泛型：
subscript&amp;lt;T: Hashable&amp;gt;(item: T) -&amp;gt; Int {  return item.hashValue } subscript&amp;lt;T&amp;gt;(key: String) -&amp;gt; T? {  return dictionary[key] as? T } Associated types 关联类型声明一个占位名称，可以在协议中代替类型使用，在协议被实现时，实际的类型才可以确定。在创建泛型函数和泛型类型也使用相似的语法：
protocol QueueProtocol {  associatedtype QueueType  mutating func add(item: QueueType)  mutating func getItem() -&amp;gt; QueueType?  func count() -&amp;gt; Int } class IntQueue: QueueProtocol {  var items = [Int]()  func add(item: Int) {  items.append(item)  }   func getItem() -&amp;gt; Int? {  return items.count &amp;gt; 0 ? items.remove(at: 0) : nil  }   func count() -&amp;gt; Int {  return items.count  } } 关联类型也可以和泛型关联：即在协议中使用关联类型，然后在定义泛型时实现刚刚定义的协议。在下面的定义中，泛型GenericQueue实现了QueueProtocol协议：
class GenericQueue&amp;lt;T&amp;gt;: QueueProtocol {  var items = [T]()   func add(item: T) {  items.append(item)  }   func getItem() -&amp;gt; T? {  return items.count &amp;gt; 0 ? items.remove(at: 0) : nil  }   func count() -&amp;gt; Int {  return items.count  } }  var intQ2 = GenericQueue&amp;lt;Int&amp;gt;() intQ2.add(item: 2) intQ2.add(item: 4) print(intQ2.getItem()!) intQ2.add(item: 6) 协议中使用关联类型时，也可以使用类型约束。当协议被实现时，为关联类型定义的类型必须继承于该类或符合类型约束所定义的协议，下面定义了一个带有类型约束的关联类型：
associatedtype QueueType: Hashable 错误处理 错误定义 enum PlayerNumberError: Error {  case NumberTooHigh(description: String)  case NumberTooLow(description: String)  case NumberAlreadyAssigned  case NumberDoesNotExist } 抛出错误 需要抛出错误时，需在方法定义中添加throws关键字。意思是告诉任何调用该方法的调用者，这个方法可能抛出错误，而且这个错误必须处理：
typealias BaseballPlayer = (firstName: String, lastName: String, number: Int)  mutating func addPlayer(player: BaseballPlayer) throws {  guard player.number &amp;lt; maxNumber else {  throw PlayerNumberError.NumberTooHigh(description: &amp;#34;Max number is \(maxNumber)&amp;#34;)  }   guard player.number &amp;gt; minNumber else {  throw PlayerNumberError.NumberTooLow(description: &amp;#34;Min number is \(minNumber)&amp;#34;)  }   guard players[player.number] == nil else {  throw PlayerNumberError.NumberAlreadyAssigned  }   players[player.number] = player } 如果确定错误不会抛出，可以使用try!，try!会切断错误的传播。但不建议这样使用，因为一旦有错误，则会有运行时错误。
Swift提供了try?操作。它试图执行一个可能会抛出错误的操作，并将其转换为一个可选值；因此，如果抛出错误，操作的结果将是nil，如果没有抛出错误，则是操作的结果.
if let player = try? myTeam.getPlayerByNumber(number: 34) {  print(&amp;#34;Player is \(player.firstName)\(player.lastName)&amp;#34;) } 捕获错误 do {  let player = try myTeam.getPlayerByNumber(number: 34)  print(&amp;#34;Player is \(player.firstName)\(player.lastName)&amp;#34;) } catch PlayerNumberError.NumberDoesNotExist {  print(&amp;#34;No player has that number&amp;#34;) }  do {  try myTeam.addPlayer(player: (&amp;#34;David&amp;#34;, &amp;#34;Ortiz&amp;#34;, 34)) } catch PlayerNumberError.NumberTooHigh(let description) {  print(&amp;#34;Error: \(description)&amp;#34;) } catch PlayerNumberError.NumberTooLow(let description) {  print(&amp;#34;Error: \(description)&amp;#34;) } catch PlayerNumberError.NumberAlreadyAssigned {  print(&amp;#34;Error: Number already assigned&amp;#34;) } catch {  print(&amp;#34;Error: Unknown Error&amp;#34;) } 自定义下标 默认情况下，下标在Swift中是访问集合列表或序列中的快捷方式。也可以在自定义类型中定义下标，包括类、结构体、枚举和协议类型：
class MyNames {  private var names = [&amp;#34;Jon&amp;#34;, &amp;#34;Kailey&amp;#34;, &amp;#34;Kara&amp;#34;]   subscript(index: Int) -&amp;gt; String {  get { return names[index] }  set { names[index] = newValue }  } } 只读下标 自定义的下标时，可以只定义只读的下标，有两种方式。一种是只显式声明get方法，不声明set方法；另一种是不显式声明，直接返回：
subscript(index: Int) -&amp;gt; String {  return names[index] }  subscript(index: Int) -&amp;gt; String {  return names[index] }  subscript(add index: Int) -&amp;gt; Int {  get {  return num &#43; index  } } 计算下标 在定义下标时，可以如同定义计算属性：
struct MathTable {  var num: Int  subscript(index: Int) -&amp;gt; Int {  return num * index  } }  enum Hello {  subscript(name: String) -&amp;gt; String {  return &amp;#34;Hello \(name)&amp;#34;  } } 静态下标 enum Hello {  static subscript(name: String) -&amp;gt; String {  return &amp;#34;Hello \(name)&amp;#34;  } } 额外下标参数 可以在一个类型中定义多个下标，调用的时候可以根据传过去的索引名字区分：
struct MathTable {  var num: Int  subscript(multiply index: Int) -&amp;gt; Int {  return num * index  }   subscript(add index: Int) -&amp;gt; Int {  return num &#43; index  } } var table = MathTable(num: 5) print(table[multiply: 4]) // Displays 20 because 5*4=20 print(table[add: 4]) // Displays 9 because 5&#43;4=9 多维下标 一般的下标定义只有一个参数，但定义下标时可以有多个参数：
struct TicTacToe {  var board = [[&amp;#34;&amp;#34;, &amp;#34;&amp;#34;, &amp;#34;&amp;#34;], [&amp;#34;&amp;#34;, &amp;#34;&amp;#34;, &amp;#34;&amp;#34;], [&amp;#34;&amp;#34;, &amp;#34;&amp;#34;, &amp;#34;&amp;#34;]]   subscript(x: Int, y: Int) -&amp;gt; String {  get { return board[x][y] }  set { board[x][y] = newValue }  } } var board = TicTacToe()  board[1, 1] = &amp;#34;x&amp;#34;  board[0, 0] = &amp;#34;o&amp;#34; enum SayHello {  subscript(messageText message: String, messageName name: String, number: Int) -&amp;gt; [String] {  var retArray: [String] = []  for _ in 0 ..&amp;lt; number {  retArray.append(&amp;#34;\(message)\(name)&amp;#34;)  }  return retArray  } } 动态成员查询 动态成员查询可以调用一个将在运行时动态解析的属性：
@dynamicMemberLookup struct BaseballTeam {  let city: String  let nickName: String  let wins: Double  let losses: Double  let year: Int  subscript(dynamicMember key: String) -&amp;gt; String {  switch key {  case &amp;#34;fullname&amp;#34;:  return &amp;#34;\(city)\(nickName)&amp;#34;  case &amp;#34;percent&amp;#34;:  let per = wins / (wins &#43; losses)  return String(per)  default:  return &amp;#34;Unknown request&amp;#34;  }  } }  var redsox = BaseballTeam(city: &amp;#34;Boston&amp;#34;, nickName: &amp;#34;Red Sox&amp;#34;, wins: 108, losses: 54, year: 2018)  print(&amp;#34;The \(redsox.fullname)won \(redsox.percent)of their games in \(redsox.year)&amp;#34;) 闭包 闭包是独立的代码块，没有函数名的函数，可以在应用程序中传递和使用。我们可以把Int类型看作是包含integer的类型，String类型是包含字符串的类型。因此，闭包可以被认为包含代码块的类型。这意味着可以把闭包分配一个变量，将其作为参数传递给函数，也可以从函数中返回。
闭包可以捕捉和存储对任何变量或常量的引用，而这些变量或常量是在其定义的上下文中出现的。这被称为对变量或常量的closing over，在大多数情况下，Swift会为我们处理内存管理。唯一的例外是在创建强引用循环时。
简单闭包 闭包，就像一个函数，包含一些指令序列，可以接受参数和返回值，但是没有函数名。闭包可以赋值给常量和变量，因此如果需要在程序中传递闭包十分方便：
let clos1 = { () -&amp;gt; Void in  print(&amp;#34;Hello World&amp;#34;) }  let clos2 = { (name: String) -&amp;gt; Void in  print(&amp;#34;Hello \(name)&amp;#34;) }  let clos3 = { (name: String) -&amp;gt; String in  return &amp;#34;Hello \(name)&amp;#34; } 闭包的简明语法 func testFunction(num: Int, handler: () -&amp;gt; Void) {  for _ in 0 ..&amp;lt; num {  handler()  } }  testFunction(num: 5, handler: { print(&amp;#34;Hello from Shorthand closure&amp;#34;) }) func testFunction(num: Int, handler: () -&amp;gt; Void) {  for _ in 0 ..&amp;lt; num {  handler()  } }  testFunction(num: 5) {  print(&amp;#34;Hello from Shorthand closure&amp;#34;) } 数组中使用闭包 guests.map { name in  debugPrint(&amp;#34;hello \(name)&amp;#34;) }  guests.map { &amp;#34;hello \($0)&amp;#34; } let greetGuest = { (name: String) -&amp;gt; Void in  print(&amp;#34;Hello guest named \(name)&amp;#34;) }  let sayGoodbye = { (name: String) -&amp;gt; Void in  print(&amp;#34;Goodbye \(name)&amp;#34;) }  guests.map(greetGuest) guests.map(sayGoodbye) 不初始化数组 Swift 5.2为数组添加了一个不包含提前初始化的构造函数，如下所示：
let capacity = 20 let diceRolls = [Int](unsafeUninitializedCapacity: capacity) { buffer, initializedCount in  for x in 0 ..&amp;lt; capacity {  buffer[x] = Int.random(in: 1 ... 6)  }  initializedCount = capacity } 使用这种初始化器，有以下几点需要注意：
  如果initializedCount不设置，则默认为0，此时所有的设置的值都会消失。
  初始化的元素个数initializedCount不能大于数组的容量capacity；如果初始化的元素个数小于数组的容量，则剩余的元素都是随机值。
  并发和并行 自定义值类型 值和类类型 在Swift中不支持值的递归类型，而允许类的递归类型。如下所示的值类型会报Value type &#39;LinkedListValueType&#39; cannot have a stored property that recursively contains it错误：
struct LinkedListValueType {  var value: String  var next: LinkedListValueType? } 应该声明类类型的递归类型：
class LinkedListReferenceType {  var value: String  var next: LinkedListReferenceType?  init(value: String) {  self.value = value  } } 写复制 一般情况，当传递一个值类型，例如结构体，会创建一个新的副本。这意味着，如果一个大的结构体包含很多属性时，每次都要复制。为了解决这个问题，苹果在标准库中实现了写时复制。但是，自定义类型并未自动实现写复制。
private class BackendQueue&amp;lt;T&amp;gt; {  private var items = [T]()   public init() {  //  }   private init(_ items: [T]) {  self.items = items  }   public func addItem(item: T) {  items.append(item)  }   public func getItem() -&amp;gt; T? {  if items.count &amp;gt; 0 {  return items.remove(at: 0)  } else {  return nil  }  }   public func count() -&amp;gt; Int {  return items.count  }   public func copy() -&amp;gt; BackendQueue&amp;lt;T&amp;gt; {  return BackendQueue&amp;lt;T&amp;gt;(items)  } } struct Queue {  private var internalQueue = BackendQueue&amp;lt;Int&amp;gt;()   public mutating func addItem(item: Int) {  internalQueue.addItem(item: item)  }   public mutating func getItem() -&amp;gt; Int? {  return internalQueue.getItem()  }   public func count() -&amp;gt; Int {  return internalQueue.count()  } } 类 类中定义的常量和变量称为属性，定义的函数称为方法。子类会继承父类的所有的属性和方法，在子类定义的时候可以增加新的属性和方法。
class Animal {  var name: String   var sound: String   var numberOfLegs: Int   var breathesOxygen: Bool   init(name: String, sound: String, numberOfLegs: Int, breathesOxygen: Bool) {  self.name = name   self.sound = sound   self.numberOfLegs = numberOfLegs   self.breathesOxygen = breathesOxygen  }   func makeSound() {  print(sound)  } }  class Mammal: Animal {  let hasFurOrHair: Bool = true } 结构体 struct Reptile {  var name: String   var sound: String   var numberOfLegs: Int   var breathesOxygen: Bool   let hasFurOrHair: Bool = false   func makeSound() {  print(sound)  }   func description() -&amp;gt; String {  return &amp;#34;Structure: Reptile name: \(name)sound: \(sound)numberOfLegs: \(numberOfLegs)breathesOxygen: \(breathesOxygen)hasFurOrHair: \(hasFurOrHair)&amp;#34;  } } </content>
    </entry>
    
     <entry>
        <title>UISearchController</title>
        <url>https://iihui.github.io/post/ios-uisearchcontroller/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> 苹果 解决
// 先override viewDidLayoutSubviews方法 override func viewDidLayoutSubviews() {  super.viewDidLayoutSubviews()  super.setNavigationBarHidden(true, animated: false) } // 然后再push的时候关闭动画 from.navigationController?.pushViewController(vc, animated: true) </content>
    </entry>
    
     <entry>
        <title>Moya</title>
        <url>https://iihui.github.io/post/ios-moya/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  Moya是一个高度抽象的网络库，它的目标是让使用者不必关心网络请求的底层实现细节，只需要关注业务。Moya采用桥接和组合来进行封装，默认桥接了Alamofire。Moya具有很强的扩展性，可以轻松地将RxSwift、PromiseKit和ObjectMapper结合起来。
 模块介绍 Moya使用面向协议编程POP来设计网络抽象层，因此它整体的逻辑结构并没有明显的继承关系。Moya的核心代码，可以分成以下几个模块：
  Request模块包含TargetType、Endpoint、Cancellable类型。
  Provider模块是网络请求的枢纽，它将TargetType转换为Endpoint，再转换为URLRequest，最后让Alamofire做实际的网络请求。
  Response模块将Alamofire的返回的数据回调给上层，支持filter、mapJSON等方法。
  Alamofire模块通过桥接的方式将Alamofire的细节隐藏在上层，Moya和Alamofire的区别如下：
  Plguins为插件模块，默认提供了4种插件。
  Provider Provider是网络请求的枢纽，接受TargetType类型，并通过闭包调用回上层。下面是Provider的init方法定义：
/// Initializes a provider. public init(endpointClosure: @escaping EndpointClosure = MoyaProvider.defaultEndpointMapping,  requestClosure: @escaping RequestClosure = MoyaProvider.defaultRequestMapping,  stubClosure: @escaping StubClosure = MoyaProvider.neverStub,  callbackQueue: DispatchQueue? = nil,  manager: Manager = MoyaProvider&amp;lt;Target&amp;gt;.defaultAlamofireManager(),  plugins: [PluginType] = [],  trackInflights: Bool = false) {  self.endpointClosure = endpointClosure  self.requestClosure = requestClosure  self.stubClosure = stubClosure  self.manager = manager  self.plugins = plugins  self.trackInflights = trackInflights  self.callbackQueue = callbackQueue } 在init方法中，endpointClosure将TargetType转换为EndPoint，其中EndPoint是Moya网络请求的一个中间状态。requestClosure把EndPoint转换为URLRequest。Request的生成过程如下：
其中stubClosure闭包模拟服务器端假数据用于piling tests。而rackInflights表示是否需要跟踪重复的网络请求。
Request 使用Moya进行网络请求时，首先需要进行配置，以生成一个Request。按照官方文档，需要先创建一个枚举类型，并使其遵守TargetType协议，然后实现协议所规定的属性。
为什么要创建枚举来遵守协议，而不是创建类来遵守协议呢？实际上使用类或者结构体也是可行的。使用枚举的原因是Swift的枚举功能比较强大，结合switch语句，使得API管理起来非常方便。
如上图所示，endpointClosure将TargetType转换为EndPoint。endpointClosure为EndpointClosure类型，其定义如下：
public typealias EndpointClosure = (Target) -&amp;gt; Endpoint&amp;lt;Target&amp;gt; 当Provider初始化时，endpointClosure有一个默认值MoyaProvider.defaultEndpointMapping，其定义如下：
/// These functions are default mappings to `MoyaProvider`&amp;#39;s properties: endpoints, requests, manager, etc. public extension MoyaProvider {  final class func defaultEndpointMapping(for target: Target) -&amp;gt; Endpoint {  return Endpoint(  url: URL(target: target).absoluteString,  sampleResponseClosure: { .networkResponse(200, target.sampleData) },  method: target.method,  task: target.task,  httpHeaderFields: target.headers  )  }  ... } 接着requestClosure将Endpoint转换为URLRequest。requestClosure也有默认值MoyaProvider.defaultRequestMapping，这也是最后一次修改Request的机会：
final class func defaultRequestMapping(for endpoint: Endpoint, closure: RequestResultClosure) {  do {  let urlRequest = try endpoint.urlRequest()  closure(.success(urlRequest))  } catch MoyaError.requestMapping(let url) {  closure(.failure(MoyaError.requestMapping(url)))  } catch MoyaError.parameterEncoding(let error) {  closure(.failure(MoyaError.parameterEncoding(error)))  } catch {  closure(.failure(MoyaError.underlying(error, nil)))  } } 为什么在TargetType-&amp;gt;Endpoint-&amp;gt;URLRequest映射中使用闭包？这是为了平衡灵活性和易用性。对于大多数API请求，使用Moya提供的默认闭包映射就足够了，这样在大多数时候就不用担心这两个闭包的内容了，但有时会有一些额外的要求，比如在所有的API请求中增加一个额外的HTTP Header：
let endpointClosure = { (target: MyTarget) -&amp;gt; Endpoint&amp;lt;MyTarget&amp;gt; in  let defaultEndpoint = MoyaProvider.defaultEndpointMapping(for: target)  return defaultEndpoint.adding(newHTTPHeaderFields: [&amp;#34;APP_NAME&amp;#34;: &amp;#34;MY_AWESOME_APP&amp;#34;]) } open class Endpoint {  public typealias SampleResponseClosure = () -&amp;gt; EndpointSampleResponse   /// A string representation of the URL for the request.  public let url: String   /// A closure responsible for returning an `EndpointSampleResponse`.  public let sampleResponseClosure: SampleResponseClosure   /// The HTTP method for the request.  public let method: Moya.Method   /// The `Task` for the request.  public let task: Task   /// The HTTP header fields for the request.  public let httpHeaderFields: [String: String]?   public init(url: String,  sampleResponseClosure: @escaping SampleResponseClosure,  method: Moya.Method,  task: Task,  httpHeaderFields: [String: String]?) {   self.url = url  self.sampleResponseClosure = sampleResponseClosure  self.method = method  self.task = task  self.httpHeaderFields = httpHeaderFields  }   /// Convenience method for creating a new `Endpoint` with the same properties as the receiver, but with added HTTP header fields.  open func adding(newHTTPHeaderFields: [String: String]) -&amp;gt; Endpoint {  return Endpoint(url: url, sampleResponseClosure: sampleResponseClosure, method: method, task: task, httpHeaderFields: add(httpHeaderFields: newHTTPHeaderFields))  }   /// Convenience method for creating a new `Endpoint` with the same properties as the receiver, but with replaced `task` parameter.  open func replacing(task: Task) -&amp;gt; Endpoint {  return Endpoint(url: url, sampleResponseClosure: sampleResponseClosure, method: method, task: task, httpHeaderFields: httpHeaderFields)  }   fileprivate func add(httpHeaderFields headers: [String: String]?) -&amp;gt; [String: String]? {  guard let unwrappedHeaders = headers, unwrappedHeaders.isEmpty == false else {  return self.httpHeaderFields  }   var newHTTPHeaderFields = self.httpHeaderFields ?? [:]  unwrappedHeaders.forEach { key, value in  newHTTPHeaderFields[key] = value  }  return newHTTPHeaderFields  } } 为什么要引入RequestResultClosure来对外暴露底层URLRequest呢？猜测有以下几个原因：
  有些信息，比如cookies，在URLRequest创建之前是不知道的
  有很多URLRequest的属性，其中大部分是不常见的，比如allowCellularAccess，不必在Moya层封装。
  从Endpoint到URLRequest的映射是通过闭包回调来完成的，这意味着可以异步回调。
  为什么要引入Endpoint而不是直接映射到URLRequest呢？就是说，两步的闭包映射变成了一步的映射。这是为了确保：TargetType保持不变（属性都是只读），同时提供了一个对外友好的API。通过Endpoint可以很容易添加新的参数、HttpHeader等。
Stub Stub是一个与测试相关的概念，允许返回一些假数据。在Provider的初始化函数中，有一个stubClosure参数，默认值为MoyaProvider.neverStub：
 /// Initializes a provider. public init(endpointClosure: @escaping EndpointClosure = MoyaProvider.defaultEndpointMapping,  requestClosure: @escaping RequestClosure = MoyaProvider.defaultRequestMapping,  stubClosure: @escaping StubClosure = MoyaProvider.neverStub,  callbackQueue: DispatchQueue? = nil,  manager: Manager = MoyaProvider&amp;lt;Target&amp;gt;.defaultAlamofireManager(),  plugins: [PluginType] = [],  trackInflights: Bool = false) {  self.endpointClosure = endpointClosure  self.requestClosure = requestClosure  self.stubClosure = stubClosure  self.manager = manager  self.plugins = plugins  self.trackInflights = trackInflights  self.callbackQueue = callbackQueue } 而Moya的stub原理很简单：如果Provider初始化时确定了需要使用Stub，它就会返回Endpoint中的假数据。否则，Moya就会进行实际的网络请求。Moya通过StubClosure闭包来确定stub的模式：
/// Closure that decides if/how a request should be stubbed. public typealias StubClosure = (Target) -&amp;gt; Moya.StubBehavior 如上定义StubClosure返回Moya.StubBehavior，它有三种模式，其中never表示不使用Stub，其它两种表示需要返回假数据。Moya.StubBehavior的定义如下：
public enum StubBehavior {  /// Do not stub.  case never  /// Return a response immediately.  case immediate  /// Return a response after a delay.  case delayed(seconds: TimeInterval) } 如果使用Stub并且模式选择StubBehavior.immediate或StubBehavior.delayed(seconds: TimeInterval)，则返回EndPoint中定义的假数据，并关闭请求：
switch endpoint.sampleResponseClosure() { case .networkResponse(let statusCode, let data):  let response = Moya.Response(statusCode: statusCode, data: data, request: request, response: nil)  let result = validate(response)  plugins.forEach { $0.didReceive(result, target: target) }  completion(result) case .response(let customResponse, let data):  let response = Moya.Response(statusCode: customResponse.statusCode, data: data, request: request, response: customResponse)  let result = validate(response)  plugins.forEach { $0.didReceive(result, target: target) }  completion(result) case .networkError(let error):  let error = MoyaError.underlying(error, nil)  plugins.forEach { $0.didReceive(.failure(error), target: target) }  completion(.failure(error)) } 而默认的Endpoint，即defaultEndpointMapping中sampleResponseClosure的值如下所示：
final class func defaultEndpointMapping(for target: Target) -&amp;gt; Endpoint {  return Endpoint(  url: URL(target: target).absoluteString,  sampleResponseClosure: { .networkResponse(200, target.sampleData) },  method: target.method,  task: target.task,  httpHeaderFields: target.headers  ) } Moya中使用简单粗暴的stub，但效果很好。如果不使用Moya，也想返回假数据，这时需要URLProtocol，采用URLProtocol时，网络请求可以被拦截，从而将网络请求重定向到假数据。
因为NSURLConnection发起的请求也可以直接拦截。拦截NSURLSession的时候稍微复杂一点。因为URLSession的拦截规则通过URLSessionConfiguration属性确定。通常的做法是hook住URLSession的初始化方法init(configuration: URLSessionConfiguration, delegate: URLSessionDelegate?， delegateQueue: OperationQueue?)，再用URLSessionConfiguration注册所需的拦截协议。
Plugin Moya提供了一种插件机制，可以在网络请求的关键节点插入代码。从网络开始到结束全程可以插入额外代码时机如下所示：
但要注意的是插件不是类型化的，所以不要在插件中尝试进行JSON解析，并将其传递给上层。Moya共提供了4种插件：
  AccessTokenPlugin
  CredentialsPlugin
  NetworkActivityPlugin
  NetworkLoggerPlugin
  通过将插件的接口暴露给每个节点，Moya的插件功能不需要与核心代码耦合，但也给了外面足够的灵活性来插入任何你想要的代码。
Response Moya并没有具体处理Response，只是将Alamofire层返回的数据封装成Moya.Response。然后调用convertResponseToResult进一步封装成Result&amp;lt;Moya.Response, MoyaError&amp;gt;，并返回给上层：
/// A public function responsible for converting the result of a `URLRequest` to a Result&amp;lt;Moya.Response, MoyaError&amp;gt;. public func convertResponseToResult(_ response: HTTPURLResponse?, request: URLRequest?, data: Data?, error: Swift.Error?) -&amp;gt;  Result&amp;lt;Moya.Response, MoyaError&amp;gt; {  switch (response, data, error) {  case let (.some(response), data, .none):  let response = Moya.Response(statusCode: response.statusCode, data: data ?? Data(), request: request, response: response)  return .success(response)  case let (.some(response), _, .some(error)):  let response = Moya.Response(statusCode: response.statusCode, data: data ?? Data(), request: request, response: response)  let error = MoyaError.underlying(error, response)  return .failure(error)  case let (_, _, .some(error)):  let error = MoyaError.underlying(error, nil)  return .failure(error)  default:  let error = MoyaError.underlying(NSError(domain: NSURLErrorDomain, code: NSURLErrorUnknown, userInfo: nil), nil)  return .failure(error)  } } 如果进一步想将Moya.Response转换为JSON对象，可以使用Moya.Response扩展中定义的mapJSON的方法：
/// Maps data received from the signal into a JSON object. /// /// - parameter failsOnEmptyData: A Boolean value determining /// whether the mapping should fail if the data is empty. func mapJSON(failsOnEmptyData: Bool = true) throws -&amp;gt; Any {  do {  return try JSONSerialization.jsonObject(with: data, options: .allowFragments)  } catch {  if data.count &amp;lt; 1 &amp;amp;&amp;amp; !failsOnEmptyData {  return NSNull()  }  throw MoyaError.jsonMapping(self)  } } 至此Moya所做的事情就很清楚了：它提供了一个面向协议的接口，用于编写网络请求；它提供了一个灵活的闭合接口，用于定制请求；它提供了插件，用于客户端介入每个节点的网络请求；它将原始请求数据返回给上层。
Cancel API请求应该是可取消的，即在一个API请求发出去后，客户端应该能够取消刚发出的请求。Moya发出请求后将Cancellable协议类型返回：
/// Designated request-making method. Returns a `Cancellable` token to cancel the request later.  @discardableResult  open func request(_ target: Target,  callbackQueue: DispatchQueue? = .none,  progress: ProgressBlock? = .none,  completion: @escaping Completion) -&amp;gt; Cancellable {   let callbackQueue = callbackQueue ?? self.callbackQueue  return requestNormal(target, callbackQueue: callbackQueue, progress: progress, completion: completion)  }  func requestNormal(_ target: Target, callbackQueue: DispatchQueue?, progress: Moya.ProgressBlock?, completion: @escaping Moya.Completion) -&amp;gt; Cancellable {  ... } 从Cancellable的定义可以看出符合the Minimum Knowledge Principle原则，客户端不知道请求的是什么，唯一能做的就是取消请求：
public protocol Cancellable {   /// A Boolean value stating whether a request is cancelled.  var isCancelled: Bool { get }   /// Cancels the represented request.  func cancel() } 在内部实现中，使用CancellableWrapper类包装实际的Cancel动作，它返回的是实际实现协议的类型。
internal class CancellableWrapper: Cancellable {  internal var innerCancellable: Cancellable = SimpleCancellable()   var isCancelled: Bool { return innerCancellable.isCancelled }   internal func cancel() {  innerCancellable.cancel()  } } internal class SimpleCancellable: Cancellable {  var isCancelled = false  func cancel() {  isCancelled = true  } } 为什么需要CancellableWrapper来进行一层包装？因为对于没有实际发送的请求，取消动作是简单的SimpleCancellable。而对于实际的请求，cancel取消的是实际的网络请求：
cancellableToken.innerCancellable = self.performRequest(target, request: preparedRequest, callbackQueue: callbackQueue, progress: progress, completion: networkCompletion, endpoint: endpoint, stubBehavior: stubBehavior) 在取消网络请求的时候需要使用信号量，以防止两个线程同时取消网络请求，造成混乱：
/// Internal token that can be used to cancel requests public final class CancellableToken: Cancellable, CustomDebugStringConvertible {  let cancelAction: () -&amp;gt; Void  let request: Request?   public fileprivate(set) var isCancelled = false   fileprivate var lock: DispatchSemaphore = DispatchSemaphore(value: 1)   public func cancel() {  _ = lock.wait(timeout: DispatchTime.distantFuture)  defer { lock.signal() }  guard !isCancelled else { return }  isCancelled = true  cancelAction()  }   public init(action: @escaping () -&amp;gt; Void) {  self.cancelAction = action  self.request = nil  }   init(request: Request) {  self.request = request  self.cancelAction = {  request.cancel()  }  }   /// A textual representation of this instance, suitable for debugging.  public var debugDescription: String {  guard let request = self.request else {  return &amp;#34;Empty Request&amp;#34;  }  return request.debugDescription  }  } Alamofire Moya使用桥接的方式封装Alamofire的API细节，这些封装细节可以在Moya&#43;Alamofire.swift文件中查看，简单来说有两种桥接方法。一种是类型桥接，一种是协议桥接：
/// Represents an HTTP method. public typealias Method = Alamofire.HTTPMethod  /// Choice of parameter encoding. public typealias ParameterEncoding = Alamofire.ParameterEncoding public typealias JSONEncoding = Alamofire.JSONEncoding public typealias URLEncoding = Alamofire.URLEncoding public typealias PropertyListEncoding = Alamofire.PropertyListEncoding  /// Multipart form. public typealias RequestMultipartFormData = Alamofire.MultipartFormData Alamofire的外部接口是Request Type。另一方面，Moya需要在Plugin中暴露Reuqest，将其与Request协议桥接起来：
public protocol RequestType {  var request: URLRequest? { get }  func authenticate(user: String, password: String, persistence: URLCredential.Persistence) -&amp;gt; Self  func authenticate(usingCredential credential: URLCredential) -&amp;gt; Self }  internal typealias Request = Alamofire.Request extension Request: RequestType { } 对外暴露的接口就变成了如下的形式：
public extension PluginType {  func prepare(_ request: URLRequest, target: TargetType) -&amp;gt; URLRequest { return request }  func willSend(_ request: RequestType, target: TargetType) { }  func didReceive(_ result: Result&amp;lt;Moya.Response, MoyaError&amp;gt;, target: TargetType) { }  func process(_ result: Result&amp;lt;Moya.Response, MoyaError&amp;gt;, target: TargetType) -&amp;gt; Result&amp;lt;Moya.Response, MoyaError&amp;gt; { return result } } 桥接隐藏了一些细节，因此将来某一天Moya不再需要在底层依赖Alamofire时，对上层没有任何影响，这也是解耦的一种方式。
简单使用 用Moya分为几步，首先需要自定义一个枚举类型。然后遵循开闭原则，让定义的枚举分类遵循TargetType协议，然后按需实现协议中定义的各种get方法。最后创建MoyaProvider对象发起网络请求。
声明分类 Moya基于enum封装API，通过枚举不同端点的不同用法，以生成请求：
enum LCYApi {  case login(name: String, password: String) } TargetType 遵循开闭原则，使上一步定义的枚举分类遵循TargetType协议。TargetType协议定义了各个请求的url，参数和header等信息，按需实现即可，下面是TargetType的定义：
public protocol TargetType {   /// The target&amp;#39;s base `URL`.  var baseURL: URL { get }   /// The path to be appended to `baseURL` to form the full `URL`.  var path: String { get }   /// The HTTP method used in the request.  var method: Moya.Method { get }   /// Provides stub data for use in testing.  var sampleData: Data { get }   /// The type of HTTP task to be performed.  var task: Task { get }   /// A Boolean value determining whether the embedded target performs Alamofire validation. Defaults to `false`.  var validate: Bool { get }   /// The headers to be used in the request.  var headers: [String: String]? { get } } 对于上面定义的LCYpi，让其先遵循TargetType协议，实现相关的get方法，如下所示：
extension LCYApi: TargetType {  var baseURL: URL {  return NSURL.init(string: &amp;#34;http://test.com&amp;#34;)! as URL  }   var path: String {  switch self {  case .login:  return &amp;#34;/login&amp;#34;  }  }   var method: Method {  return .post  }   //这个是做单元测试模拟的数据，必须要实现，只在单元测试文件中有作用  var sampleData: Data {  return &amp;#34;&amp;#34;.data(using: String.Encoding.utf8)!  }   var task: Task {  var parmeters: [String : Any] = [:]   switch self {  case .login(let name, let password):  parmeters[&amp;#34;name&amp;#34;] = name  parameters[&amp;#34;password&amp;#34;] = password  }   return .requestParameters(parameters: parmeters, encoding: URLEncoding.default)  }   //在请求头内添加公共请求参数，也可以通过自定义closure返回endpoint，在provider中添加  var headers: [String : String]? {  return [&amp;#34;Content-type&amp;#34;: &amp;#34;application/json&amp;#34;]  } } 定义Provider对象 在Moya中，是使用Provider对象发起网络请求的，因此在网络请求之前需要将Provider对象先创建好。Moya中Provider对象在销毁的时候会取消网络请求，为了得到正确的结果，必须保证在网络请求时Provider对象不会被释放。为了避免这种情况，可以将Provider实例设置为类成员变量，或者shared实例。
let ApiProvider = MoyaProvider&amp;lt;LCYApi&amp;gt;() 发起网络请求 ApiProvider.request(LCYApi.login(name: &amp;#34;name&amp;#34;, password: &amp;#34;password&amp;#34;)) { result in  switch result {  case let .success(response):  let data = response.data  let statusCode = response.statusCode  break  case let .failure(error):  break  } } 自定义插件 日志插件 在第一部分介绍了使用Moya时可以自定义插件，下面的代码定义了日志插件，在请求发出之前把Request的信息打印出来，在请求完成前把相应的信息也打印出来：
public struct LoggerPlugin: PluginType {   public init() {  //  }   public func prepare(_ request: URLRequest, target: TargetType) -&amp;gt; URLRequest {  return request  }   public func willSend(_ request: RequestType, target: TargetType) {  guard let request = request.request else {  return  }  print(&amp;#34;🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀&amp;#34;)  print(&amp;#34;🚀 \(request.httpMethod ?? &amp;#34;&amp;lt;unknown method&amp;gt;&amp;#34;)\(request.url?.absoluteString ?? &amp;#34;nil&amp;#34;)&amp;#34;)  print(&amp;#34;🚀&amp;#34;)  for (header, value) in request.allHTTPHeaderFields ?? [:] {  print(&amp;#34;🚀 \(header): \(value)&amp;#34;)  }  if let body = request.httpBody, let content = String(data: body, encoding: .utf8) {  print(&amp;#34;🚀\n🚀\(content)&amp;#34;)  }  print(&amp;#34;🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀&amp;#34;)  }   public func process(_ result: Result&amp;lt;Moya.Response, MoyaError&amp;gt;, target: TargetType) -&amp;gt; Result&amp;lt;Moya.Response, MoyaError&amp;gt; {  defer {  print(&amp;#34;👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋&amp;#34;)  }  print(&amp;#34;👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋&amp;#34;)  switch result {  case .success(let resp):  if let response = resp.response {  print(&amp;#34;👋 \(response.statusCode)\(response.url?.absoluteString ?? &amp;#34;nil&amp;#34;)&amp;#34;)  print(&amp;#34;👋&amp;#34;)  for (header, value) in response.allHeaderFields {  print(&amp;#34;👋 \(header): \(value)&amp;#34;)  }  if let content = String(data: resp.data, encoding: .utf8) {  print(&amp;#34;👋\n👋\(content)&amp;#34;)  }  } else {  print(&amp;#34;👋 &amp;lt;Unknown Response&amp;gt;&amp;#34;)  }  case .failure(let error):  if let response = error.response?.response {  print(&amp;#34;👋 \(response.statusCode)\(response.url?.absoluteString ?? &amp;#34;nil&amp;#34;)&amp;#34;)  } else {  print(&amp;#34;👋 \(target.path)&amp;#34;)  }  print(&amp;#34;👋\n👋 &amp;lt;ERROR: \(error.localizedDescription)&amp;gt;&amp;#34;)  }  return result  } } GB2312插件 服务端有些接口返回的时候是GB2312编码的，但是工程中一般使用UTF8编码，所以在接口返回的时候需要将GB2312转换为UTF8编码：
public struct GB2312ToUTF8ConvertPlugin: PluginType {   /// Called to modify a result before completion.  public func process(_ result: Result&amp;lt;Moya.Response, MoyaError&amp;gt;, target: TargetType) -&amp;gt; Result&amp;lt;Moya.Response, MoyaError&amp;gt; {  if case let .success(resp) = result, (target as? GB2312Convertor)?.responseDataIsGB2312Data == true {  // 通讯录后台返回的是GB2312编码，要先转换成UTF8编码  if let data = resp.data.fromGB2312ToUTF8Data {  let newResp = Moya.Response(statusCode: resp.statusCode, data: data, request: resp.request, response: resp.response)  return .success(newResp)  }  return .success(resp)  }  return result  }  } 在上面的代码中使用到了responseDataIsGB2312Data == true的判断，因为不是所有的接口返回都要转换为UTF8编码的，所以定义了一个GB2312Convertor协议，协议里面有个变量用于标记是否需要转换编码：
protocol GB2312Convertor {  var responseDataIsGB2312Data: Bool { get } } 然后在实现了TargetType的枚举类型中，按需要实现GB2312Convertor即可，下面的代码中ContactsRequestAPI中的其他请求都需要将GB2312转换为UTF8编码:
extension ContactsRequestAPI: GB2312Convertor {  var responseDataIsGB2312Data: Bool {  switch self {  case .requestEnterpriseAuthInfo:  return false  default:  return true  }  } } NetworkLoggerPlugin 下面是Moya内置的插件NetworkLoggerPlugin的具体实现：
/// Logs network activity (outgoing requests and incoming responses). public final class NetworkLoggerPlugin: PluginType {  fileprivate let loggerId = &amp;#34;Moya_Logger&amp;#34;  fileprivate let dateFormatString = &amp;#34;dd/MM/yyyy HH:mm:ss&amp;#34;  fileprivate let dateFormatter = DateFormatter()  fileprivate let separator = &amp;#34;, &amp;#34;  fileprivate let terminator = &amp;#34;\n&amp;#34;  fileprivate let cURLTerminator = &amp;#34;\\\n&amp;#34;  fileprivate let output: (_ separator: String, _ terminator: String, _ items: Any...) -&amp;gt; Void  fileprivate let requestDataFormatter: ((Data) -&amp;gt; (String))?  fileprivate let responseDataFormatter: ((Data) -&amp;gt; (Data))?   /// A Boolean value determing whether response body data should be logged.  public let isVerbose: Bool  public let cURL: Bool   /// Initializes a NetworkLoggerPlugin.  public init(verbose: Bool = false, cURL: Bool = false, output: ((_ separator: String, _ terminator: String, _ items: Any...) -&amp;gt; Void)? = nil, requestDataFormatter: ((Data) -&amp;gt; (String))? = nil, responseDataFormatter: ((Data) -&amp;gt; (Data))? = nil) {  self.cURL = cURL  self.isVerbose = verbose  self.output = output ?? NetworkLoggerPlugin.reversedPrint  self.requestDataFormatter = requestDataFormatter  self.responseDataFormatter = responseDataFormatter  }   public func willSend(_ request: RequestType, target: TargetType) {  if let request = request as? CustomDebugStringConvertible, cURL {  output(separator, terminator, request.debugDescription)  return  }  outputItems(logNetworkRequest(request.request as URLRequest?))  }   public func didReceive(_ result: Result&amp;lt;Moya.Response, MoyaError&amp;gt;, target: TargetType) {  if case .success(let response) = result {  outputItems(logNetworkResponse(response.response, data: response.data, target: target))  } else {  outputItems(logNetworkResponse(nil, data: nil, target: target))  }  }   fileprivate func outputItems(_ items: [String]) {  if isVerbose {  items.forEach { output(separator, terminator, $0) }  } else {  output(separator, terminator, items)  }  } }  private extension NetworkLoggerPlugin {   var date: String {  dateFormatter.dateFormat = dateFormatString  dateFormatter.locale = Locale(identifier: &amp;#34;en_US_POSIX&amp;#34;)  return dateFormatter.string(from: Date())  }   func format(_ loggerId: String, date: String, identifier: String, message: String) -&amp;gt; String {  return &amp;#34;\(loggerId): [\(date)] \(identifier): \(message)&amp;#34;  }   func logNetworkRequest(_ request: URLRequest?) -&amp;gt; [String] {   var output = [String]()   output &#43;= [format(loggerId, date: date, identifier: &amp;#34;Request&amp;#34;, message: request?.description ?? &amp;#34;(invalid request)&amp;#34;)]   if let headers = request?.allHTTPHeaderFields {  output &#43;= [format(loggerId, date: date, identifier: &amp;#34;Request Headers&amp;#34;, message: headers.description)]  }   if let bodyStream = request?.httpBodyStream {  output &#43;= [format(loggerId, date: date, identifier: &amp;#34;Request Body Stream&amp;#34;, message: bodyStream.description)]  }   if let httpMethod = request?.httpMethod {  output &#43;= [format(loggerId, date: date, identifier: &amp;#34;HTTP Request Method&amp;#34;, message: httpMethod)]  }   if let body = request?.httpBody, let stringOutput = requestDataFormatter?(body) ?? String(data: body, encoding: .utf8), isVerbose {  output &#43;= [format(loggerId, date: date, identifier: &amp;#34;Request Body&amp;#34;, message: stringOutput)]  }   return output  }   func logNetworkResponse(_ response: HTTPURLResponse?, data: Data?, target: TargetType) -&amp;gt; [String] {  guard let response = response else {  return [format(loggerId, date: date, identifier: &amp;#34;Response&amp;#34;, message: &amp;#34;Received empty network response for \(target).&amp;#34;)]  }   var output = [String]()   output &#43;= [format(loggerId, date: date, identifier: &amp;#34;Response&amp;#34;, message: response.description)]   if let data = data, let stringData = String(data: responseDataFormatter?(data) ?? data, encoding: String.Encoding.utf8), isVerbose {  output &#43;= [stringData]  }   return output  } }  fileprivate extension NetworkLoggerPlugin {  static func reversedPrint(_ separator: String, terminator: String, items: Any...) {  for item in items {  print(item, separator: separator, terminator: terminator)  }  } }  参考资料 参考资料 参考资料
</content>
    </entry>
    
     <entry>
        <title>MDM</title>
        <url>https://iihui.github.io/post/tool-mdm/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  MDM是Moblie Device Management移动设备管理的简称，目的就是让企业能够方便的管理iPhone和Pad等移动设备。当企业大量的使用移动设备办公或涉及到一些安全限制时设备管理的作用就能明显的体现出来，通过MDM，IT人员能够在企业环境下安全地注册设备，无线配置和更新设置，监督公司政策的遵守情况，还能远程擦除或锁定被管理的设备。
 工作流程 从上图可以看出要实现MDM服务须涉及到，苹果推送服务器APNs、自己或者第三方提供的MDM服务器、受管理的设备。实际中三者之间通过HTTPS相互通信，所以推送和普通APP推送一样必须要有推送证书。没有操作的情况下，除了设备本身和APNs之间保持连接，其他都不在连接状态。各自在系统中的作用如下：
  MDM服务器：对于设备，通过它发送指令对设备进行管理，获取相关信息及操作，回应响应设备操作。对于APNs，向APNs发送一个命令，目的来唤醒设备去主动连接MDM服务器，报告其当前状态是否处于空闲（若设备空闲，MDM服务器会继续下一步操作比如开始发送指令）。
  APNs：可看作其他两者之间的信使，主要就是转发MDM服务器指令给设备，意思告诉设备开始去连接服务器啦。
  设备：首先通过Safari访问服务器安装一个配置描述文件（下文叙述）并登记注册使其成为受管理的设备，当收到APNs指令后，根据已安装的配置文件的url连接MDM服务器并报告其状态，然后接受下一步命令。比如命令DeviceInformation（查询设备信息如ModelName、BatteryLevel、WiFiMAC等），设备收到XML格式的指令后再向服务器传送其相关查询的信息，如果不需要继续发送指令，服务器关闭连接。
  另外设备和MDM服务器之间数据传输都是以XML格式形式，以PUT请求的方式进行的，所以发送指令时，服务器要把指令封装成一个XML的文件同时要实现PUT请求相关操作处理。APNs所发送的仅仅是一个与设备本身相关的标示符，没有其他命令，目的就是唤醒设备去连接MDM服务器。
需要的操作 要实现一个完整的MDM服务，需要制作APNs推送证书、设备安装的配置文件、实现https通信、实现MDM相关协议、学习MDM协议相关命令及使用、一个MDM服务器（这里不作主要叙述，因为这些相关的都是有我们后台做的）。
证书制作 这个证书就是MDM Server和APNs推送消息所需要的证书，当然和APP推送证书完全不同，虽然功能差不多。
发送指令 所以完成一次指令推送经历以下过程：
1、server 与APNs建立连接，发送数据。 2、当设备收到APNs推送消息时，主动连接server报告本身的状态空闲 3、server收到设备发来的状态信息，发出操作命令 4、设备收到命令执行，并返回数据 5、server响应，此次查询完成，连接关闭。
参考资料 苹果官方
</content>
    </entry>
    
     <entry>
        <title>iOS PWA</title>
        <url>https://iihui.github.io/post/ios-pwa/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> PWA  PWA（Progressive web apps）译为渐进式Web应用，指的是运用现代的Web API以及传统的渐进式增强策略来创建跨平台Web应用程序。PWA没有统一的定义，可以理解为使用Web技术来创建App，不用打包，不用签名，可以离线工作，如果你愿意，还可以添加到桌面上，看起来就和其他原生应用一样。
 Service Works 对于iOS来说Service Workers &#43; Web App Manifest = PWA
PWA 参考资料 参考资料 参考资料 传闻即将支持 支持
</content>
    </entry>
    
     <entry>
        <title>Programming for Beginners</title>
        <url>https://iihui.github.io/post/ios-beginner/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> Xcode界面   工具栏：用于构建和运行应用程序，以及查看运行任务的进度。
  导航区：提供对项目各个部分的快速访问，默认情况下会显示项目导航器。
  编辑器区：允许编辑源代码、用户界面和其他资源。
  检查器区：允许查看和编辑在导航器区域或编辑器区域中选择的项目的信息。
  调试区：包含调试栏、变量视图和控制台。通过键入Shift &#43; Command &#43; Y来切换调试区域。
  工具栏 下图是工具栏的截图，使用编号来标记各个部分：
 导航按钮：打开和关闭导航器区域。 停止按钮：仅在应用程序运行时它会出现在“运行”按钮旁边，表示停止当前正在运行的应用程序。 运行按钮：用于构建和运行应用程序。 方案菜单：显示构建项目的特定方案和运行应用程序的目的地。方案和目的地是不同的，方案指定用于构建和运行项目的设置。目的地为应用程序指定安装位置，可以安装在物理设备和模拟器中。 活动视图：显示正在运行的任务的进度。  下图工具栏右边的截图，使用编号来标记各个部分：
 库按钮：显示用户界面元素、代码片段和其它资源。 检查器按钮：打开和关闭检查器区域。  模拟器 安装Xcode的时候就已经安装好了iOS模拟器。可以模拟iPad和iPhone的所有屏幕尺寸和分辨率，因此可以轻松地在多个设备上测试应用程序。
如果查看Scheme菜单，可能想知道No Devices和Build的用途。单击工具栏中的Scheme菜单以查看菜单顶部的No Devices和Build部分：
No Devices部分表示目前没有任何iOS设备连接到您的计算机。如果插入iOS设备，它将出现在此部分中，将能够运行在其上开发的应用程序进行测试。
建议在实际设备上运行您的应用程序，因为模拟器无法准确反映实际iOS设备的性能特征，并且不具备实际设备具有的某些硬件功能和软件API。
Build部分只有一个菜单项Any iOS Device (arm64)。当需要将应用提交到App Store之前对其进行归档时使用此选项。
无线连接设备 将iOS设备拔出并重新插入到Mac会变得相当麻烦，可以配置Xcode通过WiFi连接到iOS设备，进行App调试。
 首先确保iOS设备已经插入到Mac电脑，并且Mac和iOS设备在同一局域网内。 在Xcode菜单栏选择Window--&amp;gt;Device and Simulators。 对于选中的设备，勾选Connect via network。  按照上面的设置，如果依然出现Xcode will continue when iPhone is connected。则可以在左侧点击选中设备，鼠标右键，然后选中Connect via IP Address...，再输入真机的IP地址，即可连接：
简单的数据类型 在Swift中，浮点数字默认属于Double类型。Double类型占用64位，Float类型占用32位。
if isRestaurantOpen {  print(&amp;#34;Restaurant is open.&amp;#34;) } 集合 var movieGenres: Set = [&amp;#34;Horror&amp;#34;, &amp;#34;Action&amp;#34;, &amp;#34;Romantic Comedy&amp;#34;] movieGenres.insert(&amp;#34;Love&amp;#34;) debugPrint(movieGenres.count, movieGenres.isEmpty)  let movieGenres2: Set = [&amp;#34;Science Fiction&amp;#34;, &amp;#34;War&amp;#34;, &amp;#34;Fantasy&amp;#34;]  movieGenres.union(movieGenres2) debugPrint(movieGenres)  movieGenres.intersection(movieGenres2) debugPrint(movieGenres)  movieGenres.subtracting(movieGenres2) debugPrint(movieGenres)  movieGenres.symmetricDifference(movieGenres2) debugPrint(movieGenres) 闭包 闭包像一个函数，包含了一系列指令，可以接受参数，也可以有返回值。但是，闭包没有名字。闭包中的指令序列被花括号({ })包围，in关键字将参数和返回类型与闭包主体分开。
闭包可以赋值给常量或变量，因此在函数中传递它们很方便。下面的闭包用于计算数值的平方，并且将自定义的闭包传递给map函数：
let myClosure = { (item: Int) in  return item * item }  var numbersArray = [2, 4, 6, 7] let mappedNumbers = numbersArray.map(myClosure) debugPrint(mappedNumbers) 上面的闭包可以进一步简化：
var numbersArray = [2, 4, 6, 7] let mappedNumbers = numbersArray.map { (item: Int) -&amp;gt; Int in  return item * item }  debugPrint(mappedNumbers) 当闭包中参数的类型已经知道的时候，可以省略类型，进行进一步简化：
var numbersArray = [2, 4, 6, 7] let mappedNumbers = numbersArray.map({ item in  item * item })  debugPrint(mappedNumbers) 当闭包是函数中的唯一参数，可以省略括号：
var numbersArray = [2, 4, 6, 7] let mappedNumbers = numbersArray.map { item in  item * item }  debugPrint(mappedNumbers)  代码组织 程序被重写和修改的频率远远超过它们被创建的频率。这意味着大多数时候开发人员将修改由其他人编写或由自己在过去某个时间编写的现有代码。由于您可能正在编写您或其他人最终将在未来修改的代码，因此您需要确保您组织代码以使其易于理解。
</content>
    </entry>
    
     <entry>
        <title>AES 实现</title>
        <url>https://iihui.github.io/post/ios-aes/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  高级加密标准(AES,Advanced Encryption Standard)，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用是最常见的对称加密算法，它是一种对称加密算法（对称加密是指加密和解密使用相同的密钥）。AES支持128，192，256位3种长度的密钥，其中AES256安全性最高，AES128性能最好。
 加密流程 算法实现 import CommonCrypto import Foundation  /// AES-128加密参考自https://stackoverflow.com/questions/37680361/aes-encryption-in-swift class AES {  private let key: Data  private let iv: Data   init?(key: String, iv: String) {  guard key.count == kCCKeySizeAES128 || key.count == kCCKeySizeAES256, let keyData = key.data(using: .utf8) else {  DPrint(&amp;#34;密钥长度不对&amp;#34;)  return nil  }   guard iv.count == kCCBlockSizeAES128, let ivData = iv.data(using: .utf8) else {  DPrint(&amp;#34;初始化向量出错&amp;#34;)  return nil  }   self.key = keyData  self.iv = ivData  }   func encrypt(string: String) -&amp;gt; Data? {  return self.crypt(data: string.data(using: .utf8), option: CCOperation(kCCEncrypt))  }   func decrypt(data: Data?) -&amp;gt; String? {  guard let decryptedData = crypt(data: data, option: CCOperation(kCCDecrypt)) else {  return nil  }  return String(bytes: decryptedData, encoding: .utf8)  }   func crypt(data: Data?, option: CCOperation) -&amp;gt; Data? {  guard let data = data else {  return nil  }   let cryptLength = [UInt8](repeating: 0, count: data.count &#43; kCCBlockSizeAES128).count  var cryptData = Data(count: cryptLength)   let keyLength = [UInt8](repeating: 0, count: kCCBlockSizeAES128).count  let options = CCOptions(kCCOptionPKCS7Padding) // kCCOptionPKCS7Padding   var bytesLength = Int(0)    let status = cryptData.withUnsafeMutableBytes { cryptBytes in  data.withUnsafeBytes { dataBytes in  iv.withUnsafeBytes { ivBytes in  key.withUnsafeBytes { keyBytes in  CCCrypt(option, CCAlgorithm(kCCAlgorithmAES), options, keyBytes, keyLength, ivBytes, dataBytes, data.count, cryptBytes, cryptLength, &amp;amp;bytesLength)  }  }  }  }   guard UInt32(status) == UInt32(kCCSuccess) else {  DPrint(&amp;#34;加密出错，错误状态为：\(status)&amp;#34;)  return nil  }   cryptData.removeSubrange(bytesLength ..&amp;lt; cryptData.count)  return cryptData  } } func DPrint&amp;lt;T&amp;gt;(_ message: T, file: String = #file, method: String = #function, line: Int = #line) {  #if DEBUG  print(&amp;#34;\((file as NSString).lastPathComponent)[\(line)], \(method): \(message)&amp;#34;)  #endif }  参考资料 参考资料
</content>
    </entry>
    
     <entry>
        <title>Cookie简介</title>
        <url>https://iihui.github.io/post/cookie/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> 简介 标准的http协议是无状态的，即服务端对于客户端的每次请求都认为它是一个新的请求，上一次的会话和下一次的会话之间没有任何联系。当用户访问服务端并进行登录后，之后的客户端请求服务端依然无法对其身份进行识别。如果将客户端与服务器之间的多次交互当做一个整体来看，服务端若想识别客户端的身份，就需要将多次交互所涉及的数据「或称为状态」保存下来。
cookie的作用就是对请求和响应的状态进行管理，服务端通过在响应体中设置cookie (状态)，客户端会将cookie(状态) 存储起来。之后客户端的每个请求都将cookie(状态)带上，这样服务端就能够对客户端的身份进行识别。
早期实现 在早期cookie还未出现之前有个最简单的办法，就是在请求的页面中插入一个token，然后在下次请求时将这个token送至服务器。这需要在页面的form表单中插入一个包含token 的隐藏域，或者将token放在URL的query字符串中来传递。这两种方法都需要手动操作，因此极易出错。而使用cookie则不同，一般情况下客户端会自动存储服务器发来的cookie，并在之后的每次请求中自动带上cookie，无需客户端进行手动处理。
基本原理 当浏览器向服务器发送请求的时候，服务器将少量数据以set-cookie消息头的方式发送给客户端。浏览器一般自动将cookie数据进行存储，当客户端再次访问服务器时，会将这些数据以cookie消息头的方式发送给服务器，服务端就可以根据cookie消息头来判别用户的身份或进行一些特别的处理并返回响应，大致流程如下图所示：
属性介绍 cookie主要是用于管理服务端和客户端直接的状态，其本质上就是一堆存储在客户端的数据，每条cookie都有对应下面几个属性。
domain 属性domain指定了该cookie所属的域名。默认情况下，domain会被设置为创建该cookie 时所在的域名。某个域下的cookie如果希望能够被它的子域具有可见性（即可以读取），应该保证这个cookie在被设置时以.开头。
path 属性path指定了cookie所属的路径。domain和path两者一起来限制了cookie 允许被哪些URL访问。当请求某个资源「URL」时只有当该URL域名能够同时与domain和path属性匹配时，浏览器才会将此cookie自动添加到该请求的cookie头部中。
属性domain的匹配是根据请求URL中的域名从后向前进行匹配。而属性path的匹配则是判断URL中的路径是否包含path：
生存期 从cookie的工作原理可以知道cookie存储在客户端，而cookie在客户端的生存期主要由属性max-age或expires决定。属性expires是http/1.0协议中的，在新的http/1.1协议之后expires已经由 max-age代替。
max-age max-age属性以秒为单位，表示将在xxx秒后失效。根据其取值的不同，浏览器会做不同的处理，具体含义如下所示：
  默认情况下cookie只是暂时存在的，只在浏览器会话期间存在，当用户关闭浏览器窗口后这些值也会随之销毁。因为生成的cookie只是临时存储于浏览器内存中，并未做持久化处理。
  若max-age为正数，表示cookie会在max-age秒之后被销毁，此时cookie会做持久化处理，存储在本地文件中。
  若max-age为负数，行为与默认情况相同。表示cookie只在浏览器会话期间存在，当用户关闭浏览器窗口后这些值也会随之销毁，生成的cookie临时存储于浏览器内存中，并未做持久化。
  若max-age为0，表示cookie将被立即销毁，符合将在xxx秒后失效的表述。
  expires expires表示一个具体的到期时间，到了这个指定的时间后，浏览器就不再保留这个 cookie。它的值是UTC格式，可以使用Date.prototype.toUTCString()进行格式转换。
max-age属性则是指定从现在开始cookie存在的秒数，比如一年的有效期为60 * 60 * 24 * 365。过了这个时间以后，浏览器就不再保留这个cookie。
如果同时指定了expires和max-age，那么max-age的值将优先生效。如果没有指定expires或 max-age属性，那么这个cookie就是会话Cookie，即它只在本次对话存在，一旦用户关闭浏览器窗口，浏览器将不再保留。
secure 包含secure选项的cookie只有在当请求是HTTPS或其他安全协议时，才能被发送至服务器。但要注意，secure选项只是限定了在安全情况下才可以传输给服务端，但还是可以查看cookie的。
同时需要注意的是，如果想在客户端即网页中通过js去设置 secure类型的cookie，必须保证网页是https协议的。在http协议的网页中无法设置secure类型的cookie。
httpOnly 属性httpOnly的意思是告诉浏览器该cookie不能通过JavaScript的 document.cookie属性访问。
参考资料
session 除了cookie还经常使用session来记录客户端状态。session是服务端使用的一种用来记录客户端状态的机制，使用上比cookie简单一些，相应的也增加了服务器的存储压力。
客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是session。客户端浏览器再次访问时只需要从该session中查找该客户的状态就可以了。
session就是通过检查服务器上的“客户明细表”来确认客户身份。session好比程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。
参考资料
参考资料
Ajax Ajax的全称是Asynchronous JavaScript and XML，译为异步的JavaScript和XML。Ajax是Web2.0的技术核心，由多种技术集合而成。使用Ajax技术时不必刷新整个页面，只需对页面的局部进行更新，可以节省网络带宽，提高页面的加载速度，从而缩短用户等待时间，改善用户体验。
传统的web应用，当提交一个表单请求给服务器，服务器接收到请求之后，返回一个全新的页面给浏览器。这种做法浪费了很多带宽，因为发送请求前和获得的新页面中有很多html代码是相同的。由于每次用户的交互都需要向服务器发送请求，应用的访问时间取决于服务器的返回时间。
而使用Ajax就不同了，因为Ajax只取回一些必须的数据，它使用SOAP、XML或者支持JSON的Web Service接口，在客户端利用JavaScript处理来自服务器的响应，这样客户端和服务器之间的数据交互就减少了，从而用户请求就得到了加速。
Ajax是多种技术的组合，包括JavaScript异步数据获取技术，就是XMLHttpRequest以及XML以及Dom，还有表现技术XHTML和CSS。Ajax的核心是XMLHttpRequest，它是支持异步请求的技术，可以发送请求给服务器，并且不阻塞用户。其实XMLHttpRequest是JavaScript的一种语法子集，是它的一套API，支持发送GET和POST请求。该API是Ajax开发的核心，也是现在web技术的核心之一。通过这些技术，我们进行无序重新加载网页就可以发送和取回数据以完成交互。
Ajax全称是Asynchronous Javascript and XML。异步在这里简单地解释就是：向服务器发送请求的时候，不必等待结果，而是可以同时做其他的事情，等有了结果我们可以再来处理这个事。如果不是这样的话，我们点完按钮，页面就会卡死在那里，其他的数据请求不会往下走，这样比等待刷新似乎更加讨厌。虽然提供异步通讯功能的组件默认情况下都是异步的，但它们也提供了同步选项，如果你好奇把那个选项改为false的话，页面就会卡死。
XML只是一种数据格式，在这件事里并不重要，在更新一行字的时候理论上说不需要这个格式，但如果我们更新很多内容，那么格式化的数据可以使我们有条理地去实现更新。现在大部分是用JSON来代替XML的，因为前者更加简洁，据说目前的解析速度也更快。多快好省，能省则省啊。
总结：只要是JS调用异步通讯组件并使用格式化的数据来更新Web页面上的内容或操作过程，那么就应该算是使用Ajax。
参考资料
NSHttpCookies 302问题 参考资料
</content>
    </entry>
    
     <entry>
        <title>Java 基础</title>
        <url>https://iihui.github.io/post/java-base/</url>
        <categories>
          <category>java</category>
        </categories>
        <tags>
          <tag>java</tag>
        </tags>
        <content type="html"> 数据类型 在Java中数据分为两大类，一类是基本数据类型primitive type，另一类是引用类型reference types。基本类型的数据所占的内存大小是固定的，在内存中存放的是数据值本身。引用类型在内存中存放的是指向该数据的地址，不是数值本身，它往往由多个基本数据组成。
基本数据类型 Java中共定义了4类8种基本类型，其中4种整型：byte,short,int,long，每种类型都是带符号的；2种浮点型：float，double；1种逻辑型:boolean；1种字符型:char。
整数有3种进制表示形式。八进制：以0开头，后跟多个0～7之间的数字。十六进制：以0x或0X开头，后跟多个0～9或者a～f之间的小写字母，或A-F之间的大写字母，字母大小写可以混输。十进制：用多个0～9之间的数字表示，如果有两位及两位以上数字，首位不能为0。
一个整数常量隐含「默认」为int型，当要将一个整数强制转换为长整数时，需要在后面添加字母l或L。一个浮点数常量隐含为double型，若在一个浮点数后面添加f或者F，可以将其强制转换为float型。
   数据类型 关键字 占用字节数 默认数值     布尔型 boolean 1 false   字节型 byte 1 0   短整型 short 2 0   整型 int 4 0   长整型 long 8 0   单精度浮点型 float 4 0.0F   双精度浮点型 double 8 0.0D   字符型 chart 2 ‘\u000&#39;    数据类型转换 由于数值型也分为不同的类型，所以数值型数据也有类型转换问题。数值型数据的类型转换分为自动类型转换和强制类型转换。
  凡是把占用位数少的数据转换为占用位数较多的数据，都使用自动类型转换，即类型转换由编译系统自动转换完成。
  把较长的数据转换较短的数据时，就要使用强制类型转换，否则会产生编译错误。
  自动类型转换 已经定义好的数值型变量，若是想以另一种数值类型表示，在以下条件同时成立时，将自动进行数据类型的转换：
  转换前的数据类型与转换后的类型兼容。
  转换后的数据类型的表示范围比转换前的类型大。转换从短到长的优先关系为byte→short→char→int→long→float→double。
  在一个表达式中若有整数类型为short或byte的数据参加运算，为了避免溢出，Java会将表达式中的short或byte类型自动转换为int。
强制类型转换 如果要将较长的数据转换为较短的数据时，就要进行强制类型转换。强制类型转换的格式为：(预转换的数据类型) 变量名。在下例中，a/b是整数相除，得到的还是整数，但赋值给g的时候，因为g的类型为浮点，所以a/b的结果会自动转换为浮点型。而在(float)a/b中，因为先将a强制转换为浮点数了，接着b会自动转换为浮点数然后再进行计算，当然最后(float)a/b计算的结果也为浮点数：
public class Convert {  public static void main(String[] args) {  int a = 155;  int b = 9;  float g,h;  g = a/b;  System.out.println(g); //17.0  h = (float) a/b;  System.out.println(h); //17.222221  } } 字符串数值转换 数值字符串转为byte，short，int，long，float，double等数据类型，或将逻辑字符串转换为相应的逻辑类型，均可以使用XXX.parseXXX()，其中XXX代表Byte,Short,Integer,Long,Float,Double,Boolean类型:
int c = Integer.parseInt(&amp;#34;123&amp;#34;); short d = Short.parseShort(&amp;#34;34&amp;#34;); long e = Long.parseLong(&amp;#34;345&amp;#34;); System.out.println(c); System.out.println(d); System.out.println(e); boolean f = Boolean.parseBoolean(&amp;#34;true&amp;#34;); System.out.println(f); 字符串可用加号&#43;进行，所以若其中某个操作数不是字符串，该操作在连接之前会自动将其转换为字符串，所以可用&#43;来实现数值到字符串的自动转换：
int myInt = 234; String myStr = &amp;#34;&amp;#34; &#43; myInt; System.out.println(myStr); String testStr = &amp;#34;test&amp;#34; &#43; 12.34; System.out.println(testStr); //test12.34 流程控制 语句 在Java中语句可以是以分号;结尾的简单语句，也可以是用一对花括号{}括起来的复合语句。复合语句也称为语句块，是指由花括号括起来的若干简单语句。复合语句定义变量的作用域，复合语句中可以嵌套复合语句，但是不允许在两个嵌套的复合语句内声明两个同名的变量。如下代码编译的时候会报错Variable &#39;dd&#39; is already defined in the scope:
System.out.println(myStr); {  int dd = 34;  System.out.println(dd);  {  int dd = 45;  System.out.println(dd);  } } 文件注释 文件注释以/**开头，以*/结尾，这种注释主要用于描述类、数据和方法。它是使用JDK提供的javadoc命令所产生的扩展名为.HTML的文件，从而为程序提供文档说明。
条件语句 if语句 在Java中，if()和else if()括号中的条件表达式的结果必须为布尔值，即true或者false，这与C或者C&#43;&#43;截然不同：
if (a &amp;gt; 122) {  System.out.println( &amp;#34;a&amp;gt;122&amp;#34;); } else if (a &amp;gt; 100) {  System.out.println( &amp;#34;100 &amp;lt; a &amp;lt;= 122&amp;#34;); } else {  System.out.println( &amp;#34;a&amp;lt;=100&amp;#34;); } switch语句 switch多分支选择语句在执行时，首先计算圆括号中表达式的值，这个值必须是整型或字符型，同时应与各个case后面的常量表达式值的类型相一致。
char op = &amp;#39;&#43;&amp;#39;; switch (op) {  case &amp;#39;&#43;&amp;#39;:  System.out.println(&amp;#39;&#43;&amp;#39;);  break;  case &amp;#39;-&amp;#39;:  System.out.println(&amp;#39;-&amp;#39;);  break;  default:  break; } switch语句的每一个case判断，在一般情况下都应该有break语句，以指明这个分支执行完后，就跳出该switch语句。在某些特定的场合下可能不需要break语句，例如，要若干判读值共享一个分支时，就可以实现由不同的判断语句流入相同的分支。
循环结构 Java中循环语句共有三种，分别为while语句，do-while语句和for语句。while语句先计算表达式的值，若表达式的值为真，则执行循环体。而do-while则是先执行一遍循环体，再判断条件表达式的值。
public static int fibonacci(int n) {  if(n == 0 || n == 1 ) {  return n;  }  int i = 0;  int j = 1;  int k = 2;  int result = 0;  while( k &amp;lt;= n) {  result = i &#43; j;  i = j;  j = result;  k&#43;&#43;;  }  return result; } 对于for循环，首先计算表达式1的值，完成必要的初始化工作；再判断条件表达式的值，若为假，则退出循环；若为真，则执行循环体，执行完循环体后再返回表达式2，计算并修改循环条件，这样一轮循环就结束了。下一轮的循环从计算并判断条件表达式开始，若表达式的值仍为真，则继续循环，否则终止。
for(表达式1; 条件表达式; 表达式2) {  //循环体 } for循环语句的三个表达式都可以为空。但若条件表达式也为空，则表示当前循环是一个无限循环，需要在循环体中使用其他跳转语句来终止循环。
public static int sum(int n) {  int sum = 0;  for (int i = 1; i &amp;lt;= n; i&#43;&#43;) {  sum &#43;= i;  }  return sum; } 数组 栈与堆内存 Java把内存分为栈内存和堆内存。在方法中定义的一些基本类型变量和对象的引用变量都在方法的栈内存中分配。堆内存用来存放由new运算符创建的对象和数组，在堆中分配的内存，由Java虚拟机的垃圾回收器来管理。
在堆中创建了一个对象或数组后，同时在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中这个变量就成为数组或对象的引用变量。引用变量实际上保存的是数组或对象在堆内存中的地址（也称为对象的句柄）以后就可以在程序中使用栈的引用变量来访问堆中的数组或对象。
一维数组 一维数组的使用要经过三个步骤：①声明数组；②创建空间；③创建数组元素并赋值。前两个步骤的语法如下所示。在声明的时候可以不给出数组的长度：
数据类型[] 数组名; 数组名 = new 数据类型[个数]; 数组用new分配内存空间的同时，每个元素都会自动赋一个默认值，整数为0，浮点为0.0，字符为&amp;quot;\0&amp;quot;，布尔型号为false，引用型为null。在声明数组时，也可以将前面的两个步骤合并为一行，格式如下：
数据类型 [] 数组名 = new 数据类型[个数] 一维数组定义时也可以分配空间和赋值，称为数组的初始化。使用这种方式时，不需要将数组的元素个数给出，编译器会根据所给的初始值个数来设置数组的长度：
数据类型 [] 数组名 = {初始值1,初始值2,...,初始值n} 无论用哪种方式定义数组，都不能在声明的时候「即在数组名前的方括号内」，都不能指定长度，否则会出现编译错误。对于一维数组，可以使用foreach语句：
public static void array() {  int[] a = new int[10];  a[3] = 45;  for (int item : a) {  System.out.println(item);  } } 二维数组 在Java中没有真正的多维数组，多维数组只是数组的数组。二维数组的声明方式与一维数组类似，内存的分配也是使用new运算符。其声明与分配内存的格式如下：
数据类型 [][] 数组名; 数组名 = new 数据类型[行数][列数];  数据类型 [][] 数组名 = new 数据类型[行数][列数];  数据类型 [][] 数组名 = {{第1行的初值},{第2行的初值}, ..., {第m行的初值}} 字符串 在Java中无论字符串常量还是字符串变量，都是用类来实现的。程序中用到的字符串都可以分为两类，一类是创建之后不会再做修改和变动的字符串变量；另一类时创建之后允许再做修改的字符串变量。
String 变量名; 变量名 = new String(&amp;#34;字符串&amp;#34;); 在上面的语句中，第一条只是声明字符串引用变量变量名，此时变量名的值为null；第二条语句则在堆内存中分配了内存，并将变量名指向了字符串的首地址。也可以使用如下的方式创建字符串变量：
String 变量名 = new String(&amp;#34;字符串&amp;#34;); String 变量名 = &amp;#34;字符串&amp;#34; 利用String类创建的字符串变量，一旦被初始化或赋值，它的值和分配的内存内容就不可再改变。如果非要改变它的值，会产生一个新的字符串：
public static void testString(){  String str1 = &amp;#34;test&amp;#34;;  str1 = &amp;#34;Good&amp;#34;; } 在上面的例子中看起来是一个简单的字符串赋值，实际上重新申请了一个新的内存空间。程序首先产生str1的一个字符串对象，并在内存中分配了一段空间，由于又发现要重新赋值，在原来的空间中已经不可能再追加新的内容，系统不得不将这个对象放弃，再重新生产新的对象，虽然str1指向的内存地址是同一个，但对象已经不再是同一个了。
字符串池 Java程序在执行时会维护一个字符串池string pool，对于一些可共享的字符串对象，会先在字符串池中查找是否有相同的字符串内容，如果有就直接返回，而不是重新创建一个新的String对象，以减少内存占用。当在程序中直接使用双引号括起来的字符串时，该字符串就会在字符串池中。
字符串判等 ==运算符用于比较两个变量本身的值，即两个对象在内存中的首地址；而equal()方法则是比较两个字符串中所包含的内容是否相同：
public static void equalString() {  String s1, s2, s3 = &amp;#34;abc&amp;#34;, s4 = &amp;#34;abc&amp;#34;;  s1 = new String(&amp;#34;abc&amp;#34;);  s2 = new String(&amp;#34;abc&amp;#34;);  System.out.println(s1 == s2); //false  System.out.println(s1.equals(s2)); //true  System.out.println(s1 == s3); //false  System.out.println(s1.equals(s3)); //true  System.out.println(s3 == s4); //true  System.out.println(s3.equals(s4)); //true } 而对于非字符串类型的变量来说，==运算符和equal()方法都是用来比较其所指向的对象在堆内存中的首地址，即是否指向同一个对象:
Test a = new Test(); Test b = new Test(); System.out.println(a == b); //false System.out.println(a.equals(b)); //false 类与对象 类是对某一类事物的描述，是抽象的，概念上的定义；而对象则是实际存在的属于该类事物的具体个体，因而也称为实例instance。
修饰符 类修饰符 一个类可以有多个修饰符，且无先后顺序之分，但abstract和final相互对立，所以不能同时应用在一个类的定义中，各个修饰符的定义如下：
   修饰符 含义     public 将一个类声明为公共类，它可以被任何对象访问   abstract 将一个类声明为抽象类，没有实现方法，需要子类提供方法的实现，所以不能创建该类的实例   final 将一个类声明为最终非继承类，不能被其他类继承   缺省 只有在相同的包中才能使用    成员变量修饰符 成员变量的修饰符有访问控制修饰符，静态修饰符，最终修饰符，过渡修饰符和易失修饰符。一个成员变量可以被两个以上的修饰符同时修饰，但有些不能同时存在，各个修饰符的含义如下所示：
   修饰符 含义     public 公共访问控制符，指定该变量为公共的，它可以被任何对象的方法访问。   private 私有访问控制符，指定该变量只允许自己类中方法访问，其他任何类（包括子类）中的方法均不能访问。   protected 保护访问控制符，指定只可以被它自己的类以及子类在同一包中的其他类访问，在子类中可以覆盖此变量。   缺省 表示在同一个包中的其他类可以访问此成员变量，而其他包中的类不能访问该成员变量。   final 最终修饰符，指定该变量的值不能改变。   static 静态修饰符，指定该变量被所有对象共享，即所有的实例都可使用该变量。   transient 过渡修饰符，指定该变量是一个系统保留，暂无特别作用的临时变量。   volatile 易失修饰符，指定该变量可以同时被几个线程控制和修改。    成员方法修饰符 在方法中定义修饰符是可选项。方法的修饰符较多，包括访问控制符、静态修饰符、抽象修饰符、最终修饰符、同步修饰符和本地修饰符：
   修饰符 含义     public 公共访问控制符，指定该方法为公共的，它可以被任何对象的方法访问。   private 私有访问控制符，指定该方法只允许自己类中方法访问，其他任何类（包括子类）中的方法均不能访问。   protected 保护访问控制符，指定该方法只可以被它自己的类以及子类在同一包中的其他类访问。   缺省 表示在同一个包中的其他类可以访问此成员方法，而其他包中的类不能访问该成员方法。   final 最终修饰符，指定该方法不能被重载。   static 静态修饰符，指定不需要实例化一个对象就可以激活的方法。   synchronized 同步修饰符，在多线程程序中，该修饰符用于在运行前，对它所属的方法加锁，以防止其他线程访问，运行结束后解锁。   native 本地修饰符，指定此方法的方法体是其他语言在程序外部编写的。    成员变量和局部变量   成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用产生，随着方法调用的结束而自动消失。
  成员变量是对象的一部分，而对象是存在于堆内存中，所以成员变量也是在堆内存中，而局部变量是存在于栈内存中的。
  成员变量如果没有被赋初值，则自动以类型的默认值赋值。而局部变量不会自动赋值，必须显式地赋值后才能使用。被final修饰但没有被static修饰的成员变量必须显式地赋值。
  对象的使用 创建新的对象之后，就可以对对象的成员进行访问。在对象名和对象成员之间用.相连，通过这种方式来引用成员，如下所示：
对象名.对象成员 参数传值 Java语言在给被调用方法的参数赋值时，只采取传值的方式。所以，基本类型数据传递的是数据的值本身；而引用类型数据传递的也是这个变量的本身，即对象的引用变量，而非对象本身。
通过方法调用，可以改变对象的内容，但对象的引用变量是不能改变的。简言之，就是当参数是基本数据类型时，是传值方式调用；而当参数是引用变量时，则是传地址方式调用。
方法重载 重载是指相同的方法名称，如果参数个数不同，或者参数个数相同，但类型不同，则方法就具有不同的功能。方法的重载中参数的类型是关键，仅仅是参数的变量名不同是不行的。也就是说，参数的列表必须不同，即或者参数个数不同，或者参数类型不同，或者参数的顺序不同。
构造方法 构造方法是一种特殊的方法，它是在对象被创建时初始化对象成员的方法，构造方法的名称必须与它所在的类名完全相同。构造方法没有返回值，但在定义构造方法时，构造方法名前不能用void来修饰，因为一个类的构造方法的返回值类型就是该类本身：
构造方法定义后，创建对象时就会自动调用它，因此构造方法不需要在程序中直接调用，而是在对象产生时自动执行。如果在构造方法前添加void，就变成了普通方法，不会再自动调用了。构造方法的特殊性在于：
  构造方法的方法名与类名相同。
  构造方法没有返回值，但不能写成void。
  构造方法的主要作用是完成类对象的初始化工作。
  构造方法一般不能显式调用，而是由new来调用。
  默认构造方法 如果在定义类的时候，没有定义任何构造函数，编译器会自动生成一个默认构造函数，它没有参数，函数体中也没任何代码。如果class前面有public修饰，则默认构造方法也是public的。
构造函数调用 构造函数可以重载，一个构造函数可以调用另一个构造函数，但是必须使用this关键字，否则编译会报错，而且this关键字必须写在构造方法内的第一行位置。
class Test {  private String str;   public Test() {  System.out.println(&amp;#34;test&amp;#34;);  }   public Test(String str) {  this(); //this调用构造函数必须放在第一行  this.str = str;  } } 静态初始化器 静态初始化器是由关键字static修饰的一对花括号{}括起来的语句组。它的作用与类的构造方法有些相似，都是用来初始化工作的，但与构造方法有几点不同：
  构造方法是对新创建的对象进行初始化，而静态初始化器是对类自身进行初始化。
  静态初始化器一般不能由程序调用，是所属类被加载入内存时由系统调用执行。
  静态初始化器只执行一次，没有方法名，返回值和参数。
  class Test {  private String str;   public Test() {  System.out.println(&amp;#34;test&amp;#34;);  }   public Test(String str) {  this();  this.str = str;  }   static {  System.out.println(&amp;#34;this is a test num&amp;#34;);  }   static {  System.out.println(&amp;#34;second&amp;#34;);  } } 在上面这个例子中，第一次使用Test类时，静态初始化器才会执行，不是在程序启动时就会执行。如果有多个静态初始化器，则它们在类的初始化时会依次执行。
继承 Java中继是通过extends关键字来标识的，不支持多继承，一个类只能有一个直接父类。所有的类都直接或者间接继承java.lang.Object，即如果没有extends关键字则类默认继承自java.lang.Object。
构造方法执行 class Person {  private String name;  private int age;   public Person() {  System.out.println(&amp;#34;person init&amp;#34;);  } }  class Student extends Person {  private String department;   public Student() {  System.out.println(&amp;#34;Student init&amp;#34;);  } } 上面的例子中，如果执行Student student = new Student();则先自动调用父类的构造方法，帮助继承父类的成员初始化做准备，随后才会执行子类的构造方法。
在执行子类的构造方法之前，如果没有用super来调用父类的特定的构造函数，则会调用父类中没有参数的构造方法。如果父类只定义了有参构造方法，而子类的构造方法中又没用super来调用父类的构造函数，则会编译报错。
方法覆盖 覆盖是指在子类中，定义名称、参数个数与类型均与父类完全相同的方法，用于重写父类里同名方法的功能。但子类不能覆盖父类中声明为final或static的方法。
在子类中覆盖父类的方法时，可以扩大父类方法的权限，但不可以缩小父类方法的权限。在下面的例子中show方法在子类的权限可以改为public，但不能改为private:
class Person {  private String name;  private int age;   public Person() {  System.out.println(&amp;#34;Person init&amp;#34;);  }   protected void show() {  System.out.println(&amp;#34;Person show&amp;#34;);  } }  class Student extends Person {  private String department;   public Student() {  System.out.println(&amp;#34;Student init&amp;#34;);  }   protected void show() {  System.out.println(&amp;#34;Student show&amp;#34;);  } } 所有已被private修饰符限定为私有的方法，以及所有包含在final类中的方法，都默认是final的，这些方法既不可能被子类继承，也不可能被覆盖。
一个成员变量若被static final两个修饰符所限定时，它实际的含义就是常量。定义一个成员变量，若只用final修饰，而不用static修饰时，则必须且只能赋值一次。
Object类 在Java中所有类都直接或者间接继承自java.lang.Object，它定义了public final Class getClass()方法，这个方法返回运行时对象所属的类:
Class obj = a.getClass(); System.out.println(obj); //class test System.out.println(obj.getName()); //Test 在上面的例子中，首先通过Object类的实例方法getClass()获取类，然后通过Class类的实例方法getName()获取类的名字。
可以通过对象运算符instanceof来测试一个指定对象是否是指定类或它的子类的实例，若是则返回true，否则返回false。
抽象类 抽象类类似于模板的作用，目的是根据它的格式来创建和修改新的类。但是不能直接由抽象类创建对象，只能通过抽象类派生出新的子类，再由子类来创建对象。也就是说，抽象类是不能用new运算符来创建实例对象。抽象类的定义格式如下所示：
abstract class 类名 {  声明成员变量;  返回值的数据类型 方法名(参数表) {  ...  }  abstract 返回值的数据类型 方法名(参数表); } 在抽象类中的方法分为两种，一种是一般的方法；另一种是抽象方法，它是以abstract关键字开头的方法，此方法只需声明放回值的数据类型，方法名称和所需的参数，但是没有方法体。也就是说，对抽象方法只需声明，而不需实现，即用;结尾，而不是用{}。
当一个方法为抽象方法时，意味着这个方法必须被子类的方法所覆盖，否则子类仍然是abstract。抽象方法声明中修饰符static和abstract不能同时使用。
抽象类中不一定包含抽象方法，但非包含抽象方法的类一定要声明为抽象类。抽象类可以有构造方法，且构造方法可以被子类的构造方法所调用，但构造方法不能被声明为抽象的。
接口 接口与抽象类非常相似，本身也具有数据成员于抽象方法，但与抽象类有很大不同：①接口的数据成员必须初始化。②接口中的方法必须全部都声明为abstract，即不能拥有一般的方法，必须全部为抽象方法。
class 类名称 implements 接口名表 {  ... } 上面是接口实现的语法，接口的实现类似于继承，使用implements关键字。一个类要实现一个接口时，应该要注意如下问题：
  如果实现某接口类不是抽象类，则在类的定义部分必须实现指定接口的所有抽象方法，即非抽象类中不能存在抽象方法。
  一个类在实现某接口的抽象方法时，必须使用完全相同的方法头。否则，只是在定义一个新方法，而不是实现已有的抽象方法。
  接口可以作为一种引用类型来使用，任何实现了该接口的类的实例都可以存储在该接口类型的变量中，通过变量可以访问类中所实现接口中的方法。
  接口的继承 接口也可以继承性。定义一个接口时可通过extends关键字声明该新接口是某个已存在的父接口的子接口，它将继承父接口的所有变量与方法。
与类的继承不同的是，一个接口可以有一个以上的父接口，它们之间用逗号分隔，形成父接口列表，新接口将继承所有父接口中的变量与方法。
虽然Java只支持类的单重继承机制，不支持类的多重继承，即一个类只能有一个直接父类。但是，他可以同时实现若干个接口，实际上就可以获得多个父类，即实现了多重继承。
内部类 内部类是定义在类中的类，主要作用是将逻辑上相关的类放到一起。而匿名类是一种特殊的内部类，它没有类名，在定义类的同时，就生成了该类的一个实例，由于不会在其他地方用到该类，所以不用取名字，因而又被称为匿名内部类。
内部类定义 定义内部类时只需要将类的定义置于一个用于封装它的类的内部即可，但不能与外部类同名，如果内部类还有内部类，则不能与任何一层内部类同名。
在封装它的类的内部使用内部类，与普通类的使用方式相同；但在外部使用内部类时，需要在内部类前冠以其所属外部类的名字才能使用。
class Group {  private int age;   public class MoStu {  String name;   public MoStu(String name) {  this.name = name;  }   public void show() {  System.out.println(&amp;#34;MoStu show&amp;#34;);  }  }   public void show() {  System.out.println(&amp;#34;Group show&amp;#34;);  MoStu stu = new MoStu(&amp;#34;test&amp;#34;);  stu.show();  } } Group group = new Group(); group.show(); Java将内部类作为一个成员，就如同成员变量或成员方法。内部类可以被声明为private或protected。在内部类中可以直接引用它的外部类成员，包括静态成员、实例成员和私有成员。
不能直接创建内部类的对象实例，必须使用外部类对象来创建内部类对象，对于上面的例子，可以使用如下方式在外部创建内部内的实例：
Group.MoStu stu = group.new MoStu(&amp;#34;outside&amp;#34;); stu.show(); 匿名内部类 匿名内部类前不能有修饰符，也不能定义构造方法，因为它没有名字，也正是这个原因，在创建对象时也不能带参数，因为默认构造函数不带参数。
class Group {  private int age;   public class MoStu {  String name;   public MoStu(String name) {  this.name = name;  }   public void show() {  System.out.println(&amp;#34;MoStu show&amp;#34;);  }  }   abstract class Person {  public abstract void eat();  }   public void show() {  System.out.println(&amp;#34;Group show&amp;#34;);  MoStu stu = new MoStu(&amp;#34;test&amp;#34;);  stu.show();   Person p = new Person() {  public void eat() {  System.out.println(&amp;#34;eat something&amp;#34;);  }  };  p.eat();   Thread t = new Thread() {  public void run() {  for (int i = 1; i &amp;lt;= 5; i&#43;&#43;) {  System.out.print(i &#43; &amp;#34; &amp;#34;);  }  }  };  t.start();  } } 包 包是Java提供的一种区分类名的机制，每个包对应一个文件夹，包中还可以再有包，称为包的等级。在源文件中可以声明类所在的包，就像保存文件时要说明文件保存在哪个文件夹中。同一包中类名不能重复，不同包中的类名可以相同。
创建包 若要创建自己的包，就必须以package语句作为Java源文件的第一条语句，指明该文件中定义的类所在的包，它的格式为：
package 包名1[.包名2][.包名3][...] 经过package声明后，在同一文件内的所有类或接口都被纳入相同的包中。编译器把包对应于文件系统的文件夹进行管理，例如：
package Test.myPackage 上面的例子指定包中的文件存储在文件夹test\myPackage中。实际上创建包就是在当前文件夹中创建一个子文件夹，语句中的.代表文件分隔符，即上面的语句创建了两个文件夹。第一个文件夹是test，第二个是myPackage，当前包中所有的类就存放在这个文件夹中。
异常 异常本质上是程序运行期间发生的事件，这个事件将中断程序的正常执行，当在Java方法内部发生异常时，这个方法就会创建一个异常对象，并把它传递给运行时环境。
Java中所说的异常都是Exception类及其子类，异常处理通过try,catch,finally,throw,throws五个关键字来实现的。
异常捕获 public void handleException() {  int[] arr = {1, 2, 3, 4};  for (int i = 0; i &amp;lt; 5; i&#43;&#43;) {  try {  System.out.println(arr[i] / i);  } catch (ArrayIndexOutOfBoundsException e) {  System.out.println(e.getLocalizedMessage());  } catch (ArithmeticException e) {  System.out.println(e.getLocalizedMessage());  } catch (Exception e) {  System.out.println(e.getLocalizedMessage());  } finally {  System.out.println(&amp;#34;finally&amp;#34;);  }  } }   异常的捕获过程中做了两个判断，第一个是try程序块中是否有异常产生；第二个是产生的异常是否和catch后面括号内预捕获的异常类型匹配。
  catch块中语句应该根据异常类型的不同而执行不同的操作，比较通用的做法是输出异常相关的信息，包括异常的名称，产生异常的方法名等。
  由于异常对象于catch块的匹配是按照catch块的先后排列顺序进行的，所以在处理异常时，应该认真设计各catch块的排列顺序。
  当在try块中语句抛出一个异常时，其后的代码都不会被执行，所以此时可以通过finally语句块来提供统一的出口。
  finally块是可以省略的，若省略，则在catch块结束后，程序跳转到try-catch块之后的语句继续运行。
  当catch块中包含System.exit(0)语句时，则不执行finally语句块，程序直接终止；而当catch块中包含return语句时，则执行完执行finally语句块，再会终止程序。
  抛出异常 所有系统定义的运行时异常都可以由系统自动抛出。而指定方法抛出异常要使用throw或者throws来明确指定方法内抛出异常。一个方法声明抛出异常有两种方式，第一种是在方法内抛出异常对象，其中的异常类对象，是一个从Throwable派生的异常类对象：
throw 异常类对象 第二种方式，在方法声明中添加throws子句，表示方法将抛出异常。带有throws子句的方法声明格式如下：
[修饰符] 返回值类型 方法名([参数列表]) throws 异常类列表 通过上面两种方式抛出的异常，在方法中可以不使用try-catch-finally来处理异常，而交由调用此方法的程序来处理。
如果一个方法抛出异常后，该方法内又没有处理异常的语句，则系统会将异常向上传递，由调用它的方法来处理这些异常，若上层调用方法中仍没有处理异常的语句，则可以再往上传递，直到传递到main方法，由JVM处理。
多线程 多线程是指在同一个进程中同时存在几个执行体，按几条不同的执行路径同时工作的情况。所以多线程编程的含义就是将一个程序分为几个可以同时并发执行的子任务。
Java中实现多线程的方法有两种，一种继承自java.lang包中的Thread类，另一种是用户在定义的自己类中实现Runnable接口。要在一个Thread子类中激活线程，必须要准备好下列两种事情：
  此类必须是继承自Thread类。
  线程所要执行的代码必须写在run方法内。但一般不直接调用run方法，而是通过线程的start方法来启动线程。
  Thread class ThreadTest extends Thread {  private String who;   public ThreadTest(String str) {  this.who = str;  }   public void run() {  for (int i = 0; i &amp;lt; 5; i&#43;&#43;) {  try {  sleep((int) (1000 * Math.random()));  } catch (InterruptedException e) {  //  }  System.out.println(who &#43; &amp;#34;正在运行!&amp;#34;);  }  } }  ThreadTest thread1 = new ThreadTest(&amp;#34; ThreadTest thread2 = new ThreadTest(&amp;#34; thread1.start(); thread2.start(); System.out.println(&amp;#34;main 方法执行结束&amp;#34;);  Mei正在运行! Mei正在运行! Hui正在运行! Mei正在运行! Mei正在运行! Hui正在运行! Mei正在运行! Hui正在运行! Hui正在运行! Hui正在运行! Runnable 上面使用继承Thread的方式来创建线程，具有局限性。因为，如果类本身已经继承了某个父类，但Java不允许多继承，所以此时需要类来实现Runnable接口。Runnable接口定义在java.lang包中，其中只提供了一个抽象方法run()的声明，从本质上说，任何实现线程的类必须实现该接口。
class ThreadTestMo implements Runnable {  private String who;   public ThreadTestMo(String str) {  who = str;  }   @Override  public void run() {  for (int i = 0; i &amp;lt; 5; i&#43;&#43;) {  try {  Thread.sleep((int) (1000 * Math.random()));  } catch (InterruptedException e) {  System.out.println(e.toString());  }  System.out.println(who &#43; &amp;#34;正在运行!&amp;#34;);  }  } } ThreadTestMo mei = new ThreadTestMo(&amp;#34;Mei&amp;#34;); ThreadTestMo hui = new ThreadTestMo(&amp;#34;Hui&amp;#34;); Thread thread1 = new Thread(mei); Thread thread2 = new Thread(hui); thread1.start(); thread2.start(); System.out.println(&amp;#34;main 方法执行结束&amp;#34;); 如果需要线程有序执行，就需要使用join方法。当某一线程调用join方法时，则其他线程会等到该线程结束后才开始执行。
public static void threadJoin() {  ThreadTestMo mei = new ThreadTestMo(&amp;#34;Mei&amp;#34;);  ThreadTestMo hui = new ThreadTestMo(&amp;#34;Hui&amp;#34;);  Thread thread1 = new Thread(mei);  Thread thread2 = new Thread(hui);  thread1.start();  try {  thread1.join();  } catch (InterruptedException e) {  System.out.println(e.toString());  }  thread2.start();  try {  thread2.join();  } catch (InterruptedException e) {  System.out.println(e.toString());  }  System.out.println(&amp;#34;测试方法运行完毕&amp;#34;); } Mei正在运行! Mei正在运行! Mei正在运行! Mei正在运行! Mei正在运行! Hui正在运行! Hui正在运行! Hui正在运行! Hui正在运行! Hui正在运行! 测试方法运行完毕 数据共享 若直接使用Thread类，在类中this即指当前线程；若使用Runnable接口，要在此类中获取当前线程，必须使用Thread.currentThread()方法。
使用Runnable接口可以轻松实现多个线程共享相同的数据，只要用同一个实现了Runnable接口的类的对象作为参数创建多个线程。
class ThreadSale implements Runnable {  private int tickets = 10;   @Override  public void run() {  while (true) {  if (tickets &amp;gt; 0) {  System.out.println(Thread.currentThread().getName() &#43; &amp;#34;售机票第&amp;#34; &#43; tickets-- &#43; &amp;#34;号&amp;#34;);  } else {  System.exit(0);  }  }  } }  public static void threadShare() {  ThreadSale sale = new ThreadSale();  Thread t1 = new Thread(sale, &amp;#34;第一号窗口&amp;#34;);  Thread t2 = new Thread(sale, &amp;#34;第二号窗口&amp;#34;);  Thread t3 = new Thread(sale, &amp;#34;第三号窗口&amp;#34;);  t1.start();  t2.start();  t3.start(); }  第二号窗口售机票第9号 第三号窗口售机票第8号 第一号窗口售机票第10号 第三号窗口售机票第6号 第二号窗口售机票第7号 第三号窗口售机票第4号 第一号窗口售机票第5号 第二号窗口售机票第3号 第三号窗口售机票第2号 第一号窗口售机票第1号 多线程同步 为了保证互斥，Java使用synchronized关键字来标识同步的资源，这里的资源可以是一种类型的数据，也就是对象，也可以是一个方法，还可以是一段代码。
synchronized (对象) {  临界代码段 }  public synchronized 返回类型 方法名() {  方法体 } synchronized的功能：首先判断对象或方法的互斥锁是否存在，若在就获得互斥锁，然后就可以执行紧随其后的临界代码段或方法体；如果对象或方法的互斥锁不在，就进入等待状态，直到获得互斥锁。当被synchronized限定的代码段执行完，就自动释放互斥锁。
线程通信 java.lang.Object类的wait(),notify()等方法为线程间的通信提供了有效手段，但wait(),notify()只能在同步代码块里调用。
   方法 功能说明     public void wait() 如果一个正在执行的同步代码(synchronized)的线程A执行了wait()调用「在对象x上」，该线程暂停执行而进入对象x的等待队列，并释放已获得的对象x的互斥锁。线程A要一直等到其他线程在对象x上调用notify或notifyAll，才能够再重新获得对象x的互斥锁后继续执行。   public void notify() 唤醒正在等待该对象互斥锁的第一个线程。   public void notifyAll() 唤醒正在等待该对象互斥锁的所有线程，优先级高的先被唤醒。    </content>
    </entry>
    
     <entry>
        <title>鼠须管配置</title>
        <url>https://iihui.github.io/post/tool-squirrel/</url>
        <categories>
          <category>tool</category>
        </categories>
        <tags>
          <tag>tool</tag>
        </tags>
        <content type="html">  鼠须管是macOS上一款高度可定制的输入法软件，它没有图形设置界面，通过修改yaml配置文件来实现设置变更。这篇文章记录折腾鼠须管0.15.1版本时遇到的一些问题和解决方案，并且只在0.15.1上验证过有效性。
 横排显示 鼠须管默认是竖排显示候选词的，为了修改为横排显示，首先在~/Library/Rime目录下创建配置文件squirrel.custom.yaml，并在其中添加如下代码，并且重新部署才可生效：
patch:  style/horizontal: true #注意style前是tab 自定义配色 鼠须管默认的候选词配色方案个人觉得不好看，可以在~/Library/Rime/squirrel.custom.yaml文件中添加一些自定义主题配色：
 preset_color_schemes:  mojave_dark:  name: &amp;#34;沙漠夜／Mojave Dark&amp;#34;  author: &amp;#34;xiehuc &amp;lt;xiehuc@gmail.com&amp;gt;&amp;#34;  horizontal: true  inline_preedit: true  candidate_format: &amp;#34;%c %@&amp;#34;  corner_radius: 5  hilited_corner_radius: 0  border_height: 6  border_width: 12  border_color_width: 0  font_face: PingFangSC  font_point: 16  label_font_point: 13  text_color: 0xdedddd  back_color: 0x3c3c3c  label_color: 0x888785  border_color: 0x3c3c3c  candidate_text_color: 0xdedddd  hilited_text_color: 0xdedddd  hilited_back_color: 0x3c3c3c  hilited_candidate_text_color: 0xefefef  # hilited_candidate_back_color: 0xcb5d00  hilited_candidate_label_color: 0xefefef  comment_text_color: 0xdedddd  clean_white:  author: &amp;#34;Chongyu Zhu &amp;lt;lembacon@gmail.com&amp;gt;, based on 搜狗「简约白」&amp;#34;  back_color: 0xeeeeee  border_height: 6  border_width: 6  candidate_format: &amp;#34;%c %@&amp;#34;  candidate_text_color: 0x000000  comment_text_color: 0x808080  corner_radius: 6  font_point: 16  hilited_candidate_back_color: 0xeeeeee  hilited_candidate_label_color: 0xa0c98915  hilited_candidate_text_color: 0xc98915  hilited_text_color: 0x000000  horizontal: true  label_color: 0x888888  label_font_point: 12  name: &amp;#34;简约白／Clean White&amp;#34;  text_color: 0x808080 接着在~/Library/Rime/squirrel.custom.yaml文件中修改style/color_scheme的值为想要设置的主题，就可以完成候选词颜色主题切换：
style:  color_scheme: mojave_dark 候选词数量 首先在~/Library/Rime目录下创建全局配置文件default.custom.yaml，并在其中添加menu/page_size和对应候选词的个数，即可修改每页候选词的数量：
patch:  menu/page_size: 9 #每页候选词的数量 输入方案 鼠须管提供了一些常见的输入方案，可以在全局配置文件~/Library/Rime/default.custom.yaml文件中设置可以激活的预选输入方案：
schema_list: #“输入选单”中激活的输入方案定义。  - schema: luna_pinyin_simp  - schema: luna_pinyin 翻页快捷键 鼠须管默认使用上下箭头来翻页候选词，这与默认输入法使用[和]翻页候选词不同。为了修改翻页快捷键，需要在~/Library/Rime/default.custom.yaml文件中添加如下快捷键：
 key_binder/bindings:  - { when: has_menu, accept: bracketleft, send: Page_Up } #使用[向上翻页  - { when: has_menu, accept: bracketright, send: Page_Down } #使用]向下翻页 参考资料
生僻字 默认情况下，对于生僻字鼠须管显示为一个带问号的方框，看着很难受。可以从这里或者这里下载花园明朝字体，安装完即可解决生僻字显示乱码问题。
默认英文模式 在鼠须管中，软件可以设置默认英文模式，只需知道软件的Bundle identifier。默认英文模式的设置需要修改~/Library/Rime/squirrel.custom.yaml文件，将其下的app_options添加对应的ascii_mode: true。而Bundle identifier需要在Applications中找到对应的软件，右键选择Show Package Contents，进入content，打开Info.plist文件，在其中找到Bundle identifier即可：
 # 以下软件默认英文模式  app_options:  com.apple.dt.Xcode:  ascii_mode: true  com.runningwithcrayons.Alfred:  ascii_mode: true  com.apple.Terminal:  ascii_mode: true  com.googlecode.iterm2:  ascii_mode: true  com.apple.finder:  ascii_mode: true  com.sublimetext.3:  ascii_mode: true Emoji 首先切换输入法到朙月拼英文简化字，接着从这里下载opencc文件夹，将其放入到~/Library/Rime/目录下。然后在~/Library/Rime/目录下创建luna_pinyin_simp.custom.yaml文件，复制如下代码到其中，重新部署即可生效。
# encoding: utf-8  patch:  switches/@next:  name: emoji_suggestion  reset: 1  states: [ &amp;#34;🈚️️\uFE0E&amp;#34;, &amp;#34;🈶️️\uFE0F&amp;#34; ]  &amp;#39;engine/filters/@before 0&amp;#39;:  simplifier@emoji_suggestion  emoji_suggestion:  opencc_config: emoji.json  option_name: emoji_suggestion  tips: all 参考资料 参考资料 参考资料
大写键中英文切换 系统默认输入法，可以设置大写键进行中英文切换，鼠须管也可以设置大写键进行中英文切换。需要在~/Library/Rime/default.custom.yaml文件中加入如下代码：
patch:  ascii_composer/good_old_caps_lock: false  ascii_composer/switch_key:  Caps_Lock: commit_code  Shift_L: noop  Shift_R: noop  Control_L: noop  Control_R: noop 切换无效 在IntelliJ系列的软件中发现设置good_old_caps_lock: false后用CapsLock切换中英文输入法不生效，反而英文变成了大写。在终端中使用如下命令，然后重新部署一下：
cd /Library/Input Methods/Squirrel.app/Contents sudo /usr/libexec/PlistBuddy -c &amp;#39;Add :TICapsLockLanguageSwitchCapable bool true&amp;#39; Info.plist 参考资料
快捷符号 快捷符号可以在中文状态下，通过直接输入/dn来调出特殊符号。需要在~/Library/Rime/目录下的luna_pinyin_simp.custom.yaml文件中，添加如下配置：
 punctuator:  import_preset: symbols  symbols:  &amp;#34;/fs&amp;#34;: [½,‰,¼,⅓,⅔,¾,⅒,½,⅓,⅔,¼,¾,⅕,⅖,⅗,⅘,⅙,⅚,⅐,⅛,⅜,⅝,⅞,⅑,⅒,⅟,↉,℀,℁,℅,℆,⅍]  &amp;#34;/dq&amp;#34;: [🌍,🌎,🌏,🌐,🌑,🌒,🌓,🌔,🌕,🌖,🌗,🌘,🌙,🌚,🌛,🌜,🌝,🌞,⭐,🌟,🌠,⛅,⚡,❄,🔥,💧,🌊]  &amp;#34;/jt&amp;#34;: [⬆,↗,➡,↘,⬇,↙,⬅,↖,↕,↔,↩,↪,⤴,⤵,🔃,🔄,🔙,🔚,🔛,🔜,🔝]  &amp;#34;/sg&amp;#34;: [🍇,🍈,🍉,🍊,🍋,🍌,🍍,🍎,🍏,🍐,🍑,🍒,🍓,🍅,🍆,🌽,🍄,🌰,🍞,🍖,🍗,🍔,🍟,🍕,🍳,🍲,🍱,🍘,🍙,🍚,🍛,🍜,🍝,🍠,🍢,🍣,🍤,🍥,🍡,🍦,🍧,🍨,🍩,🍪,🎂,🍰,🍫,🍬,🍭,🍮,🍯,🍼,🍵,🍶,🍷,🍸,🍹,🍺,🍻,🍴]  &amp;#34;/dw&amp;#34;: [🙈,🙉,🙊,🐵,🐒,🐶,🐕,🐩,🐺,🐱,😺,😸,😹,😻,😼,😽,🙀,😿,😾,🐈,🐯,🐅,🐆,🐴,🐎,🐮,🐂,🐃,🐄,🐷,🐖,🐗,🐽,🐏,🐑,🐐,🐪,🐫,🐘,🐭,🐁,🐀,🐹,🐰,🐇,🐻,🐨,🐼,🐾,🐔,🐓,🐣,🐤,🐥,🐦,🐧,🐸,🐊,🐢,🐍,🐲,🐉,🐳,🐋,🐬,🐟,🐠,🐡,🐙,🐚,🐌,🐛,🐜,🐝,🐞,🦋]  &amp;#34;/bq&amp;#34;: [😀,😁,😂,😃,😄,😅,😆,😉,😊,😋,😎,😍,😘,😗,😙,😚,😇,😐,😑,😶,😏,😣,😥,😮,😯,😪,😫,😴,😌,😛,😜,😝,😒,😓,😔,😕,😲,😷,😖,😞,😟,😤,😢,😭,😦,😧,😨,😬,😰,😱,😳,😵,😡,😠]  &amp;#34;/ss&amp;#34;: [💪,👈,👉,👆,👇,✋,👌,👍,👎,✊,👊,👋,👏,👐]  &amp;#34;/dn&amp;#34;: [⌘, ⌥, ⇧, ⌃, ⎋, ⇪, , ⌫, ⌦, ↩︎, ⏎, ↑, ↓, ←, →, ↖, ↘, ⇟, ⇞]  &amp;#34;/fh&amp;#34;: [©,®,℗,ⓘ,℠,™,℡,␡,♂,♀,☉,☊,☋,☌,☍,☑︎,☒,☜,☝,☞,☟,✎,✄,♻,⚐,⚑,⚠]  &amp;#34;/xh&amp;#34;: [＊,×,✱,★,☆,✩,✧,❋,❊,❉,❈,❅,✿,✲]  &amp;#34;/pk&amp;#34;: [♠,♥,♦,♣,♤,♡,♧,♢,🂡,🂱,🃁,🃑,🂢,🂲,🃂,🃒,🂣,🂳,🃃,🃓,🂤,🂴,🃄,🃔,🂥,🂵,🃅,🃕,🂦,🂶,🃆,🃖,🂧,🂷,🃇,🃗,🂨,🂸,🃈,🃘,🂩,🂹,🃉,🃙,🂪,🂺,🃊,🃚,🂫,🂻,🃋,🃛,🂬,🂼,🃌,🃜,🂭,🂽,🃍,🃝,🂮,🂾,🃎,🃞,🂠,🂿,🃏,🃟]  &amp;#34;/mj&amp;#34;: [🀀,🀁,🀂,🀃,🀄,🀅,🀆,🀇,🀈,🀉,🀊,🀋,🀌,🀍,🀎,🀏,🀐,🀑,🀒,🀓,🀔,🀕,🀖,🀗,🀘,🀙,🀚,🀛,🀜,🀝,🀞,🀟,🀠,🀡,🀢,🀣,🀤,🀥,🀦,🀧,🀨,🀩,🀪,🀫]  &amp;#34;/lm&amp;#34;: [ⅰ,ⅱ,ⅲ,ⅳ,ⅴ,ⅵ,ⅶ,ⅷ,ⅸ,ⅹ,ⅺ,ⅻ,ⅼ,ⅽ,ⅾ,ⅿ,Ⅰ,Ⅱ,Ⅲ,Ⅳ,Ⅴ,Ⅵ,Ⅶ,Ⅷ,Ⅸ,Ⅹ,Ⅺ,Ⅻ,Ⅼ,Ⅽ,Ⅾ,Ⅿ]  &amp;#34;/cf&amp;#34;: [&#43;,−,×,÷,±,∓,∔,⁺,⁻,⁼,⁽,⁾,ⁿ,₊,₋,₌,₍,₎,ª,º,℔,℥,ℨ,ℬ,ℊ,µ,ℌ,ℑ,℞,ℳ,℃,℉,℀,℁,℅,℆,ℾ,ℿ,⅀,ℽ,¬,∩,∪,∝,∞,ℵ,ℶ,ℷ,ℸ,ℏ,ℇ,∀,∁,∂,℮,∃,∄,∅,∆,∇,⊂,⊃,⊄,⊅,⊆,⊇,⊈,⊉,⊊,⊋,∈,∉]  &amp;#34;/jh&amp;#34;: [∊,∋,∌,∍,∧,∨,&amp;lt;,≤,≥,≦,≧,≨,≩,≪,≫,≭,≮,≯,≰,≱,≲,≳,≴,≶,≷,≸,≹,≺,≻,≼,≽,≾,≿,⊀,⊁,∎,∏,∐,∑,∕,∖,∗,∘,∙]  &amp;#34;/gh&amp;#34;: [√,∛,∜,∟,∠,∡,∢,∣,∤,∥,∦,∫,∬,∭,∮,∯,∰,∱,∲,∳,⌠,⎮,⌡,∴,∵,∶,∷,∸,∹,∺,∻,∼,∽,∾,∿,≀,≁,≂,≃,≄,≅,≆,≇,≈,≉,≊,≋,≌,≍,≎,≏,≐,≑,≒,≓,≔,≕,≖,≗,≘,≙,≚,≛,≜,≝,≞,≟,≠,≡,≢,≣,≬,⊌,⊍,⊎,⊏,⊐,⊑,⊒,⊓,⊔]  &amp;#34;/bh&amp;#34;: [㇀,㇁,㇂,㇃,㇄,㇅,㇆,㇇,㇈,㇉,㇊,㇋,㇌,㇍,㇎,㇏,㇐,㇑,㇒,㇓,㇔,㇕,㇖,㇗,㇘,㇙,㇚,㇛,㇜,㇝,㇞,㇟,㇠,㇡,㇢,㇣]  &amp;#34;/bm&amp;#34;: [⓪,①,②,③,④,⑤,⑥,⑦,⑧,⑨,⑩,⑪,⑫,⑬,⑭,⑮,⑯,⑰,⑱,⑲,⑳,⓿,❶,❷,❸,❹,❺,❻,❼,❽,❾,❿,⓫,⓬,⓭,⓮,⓯,⓰,⓱,⓲,⓳,⓴] 或者将这些特殊符号放在symbols.yaml文件中，然后在luna_pinyin_simp.custom.yaml文件中加入如下代码以载入symbols.yaml文件中特殊字符：
 #特殊符号  punctuator:  import_preset: symbols  recognizer:  import_preset: default  patterns:  punct: &amp;#34;^/([a-z]&#43;|[0-9]0?)$&amp;#34; 参考资料 参考资料
增加词库 首先从这里下载词库，然后将下载到的luna_pinyin.poetry.dict.yaml,luna_pinyin.hanyu.dict.yaml,luna_pinyin.extended.dict.yaml,luna_pinyin.cn_en.dict.yaml四个文件拷贝到~/Library/Rime/目录下，最后将luna_pinyin.custom.yaml文件中patch下的内容复制粘贴到luna_pinyin_simp.custom.yaml文件中：
 # 载入朙月拼音扩充词库  &amp;#34;translator/dictionary&amp;#34;: luna_pinyin.extended  # 改写拼写运算，使得含西文的词汇（位于 luna_pinyin.cn_en.dict.yaml 中）不影响简拼功能（注意，此功能只適用于朙月拼音系列方案，不适用于各类双拼方案）  # 本条补丁只在「小狼毫 0.9.30」、「鼠须管 0.9.25 」、「Rime-1.2」及更高的版本中起作用。  &amp;#34;speller/algebra/@before 0&amp;#34;: xform/^([b-df-np-z])$/$1_/ 由上面的代码可知，只在luna_pinyin_simp.custom.yaml文件中添加了&amp;quot;translator/dictionary&amp;quot;: luna_pinyin.extended就把所有的词库都添加进去了，而在之前拷贝了四个词典文件到~/Library/Rime/目录下，为什么只载入luna_pinyin.extended就能把其他词库都加进来？
原来在luna_pinyin_simp.custom.yaml文件中定义的字典是luna_pinyin.extended，而在luna_pinyin.extended.dict.yaml中通过import_tables将luna_pinyin,luna_pinyin.hanyu,luna_pinyin.poetry,luna_pinyin.cn_en都导入进来了：
import_tables:  - luna_pinyin  - luna_pinyin.hanyu  - luna_pinyin.poetry  - luna_pinyin.cn_en 所以，如果要添加新的词典，只要将待加入的词典放入到~/Library/Rime/目录下，然后在luna_pinyin.extended.dict.yaml的import_tables词库中添加新的词库即可：
import_tables:  - luna_pinyin  - luna_pinyin.hanyu  - luna_pinyin.poetry  - luna_pinyin.cn_en  - luna_pinyin.name  - luna_pinyin.biaoqing  - luna_pinyin.classical  - luna_pinyin.website  - luna_pinyin.chat  - luna_pinyin.net  - luna_pinyin.movie  - luna_pinyin.computer  - luna_pinyin.history  - luna_pinyin.idiom  - luna_pinyin.sougou 中英切换直接上屏 在中文输入状态的时候输入英文，按shift键后字符上屏，然后还得回车一下，可以将shift设置为直接上屏，不需要再按回车：
 ascii_composer/switch_key:  Caps_Lock: commit_code  Control_L: noop  Control_R: noop  # 按下左 shift 英文字符直接上屏，不需要再次回车，输入法保持英文状态  Shift_L: commit_code  Shift_R: noop 参考资料
升级至0.15.2 若从0.15.1升级到0.15.2版本后出现异常，可以先将luna_pinyin_simp.custom.yaml中下面代码先注释：
# 载入朙月拼音扩充词库  &amp;#34;translator/dictionary&amp;#34;: luna_pinyin.extended  # 改写拼写运算，使得含西文的词汇（位于 luna_pinyin.cn_en.dict.yaml 中）不影响简拼功能（注意，此功能只適用于朙月拼音系列方案，不适用于各类双拼方案）  # 本条补丁只在「小狼毫 0.9.30」、「鼠须管 0.9.25 」、「Rime-1.2」及更高的版本中起作用。  &amp;#34;speller/algebra/@before 0&amp;#34;: xform/^([b-df-np-z])$/$1_/ 接着将luna_pinyin.extended.dict.yaml文件中import_tables下的所有词典也都先注释，即以-开头的词典：
import_tables:  - luna_pinyin  - luna_pinyin.hanyu  - luna_pinyin.poetry  - luna_pinyin.cn_en  - luna_pinyin.name  - luna_pinyin.biaoqing  - luna_pinyin.classical  - luna_pinyin.website  - luna_pinyin.chat  - luna_pinyin.net  - luna_pinyin.movie  - luna_pinyin.computer  - luna_pinyin.history  - luna_pinyin.idiom  - luna_pinyin.sougou 然后部署，输入法正常之后将luna_pinyin_simp.custom.yaml中先前注释的代码都恢复，再次重新部署，如果依然正常，则将luna_pinyin.extended.dict.yaml文件中import_tables下面的扩展词典一个个慢慢放开。
monterry 将macOS升级到monterry后发现鼠须管输入法不见了，此时需要重新安装鼠须管，安装之后会弹出keyboard设置页面，此时点击Input Sourece,然后选择左下角的&#43;,选中Chinese,Simplified,如下图所示选中Squirrel即可：
</content>
    </entry>
    
     <entry>
        <title>UIView 使用</title>
        <url>https://iihui.github.io/post/ios-uiview/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> layoutIfNeeded与setNeedsLayout setNeedsLayout setNeedsLayout当需要调整UIView子视图布局时，需要在主线程调用此方法。此方法记录调整布局请求并立即返回「即异步执行」，等待下一个更新周期更新视图。也就是说，这个方法不会强制立即更新，而是等待下一个更新周期，才进行刷新页面。因此，可以将多个视图布局更新合并到一个update cycle，有助于提高性能。
layoutIfNeeded layoutIfNeeded方法一被调用，主线程会立即强制重新布局，它会从当前视图开始，一直到完成所有子视图的布局。如果没有待处理的布局更新，则该方法将直接退出，而不会修改布局，或调用任何与布局有关的方法。
如果要立即刷新，要先调用setNeedsLayout，把标记设为需要布局，然后马上调用layoutIfNeeded，实现布局。在视图第一次显示之前，标记肯定是需要刷新的，所以直接调用layoutIfNeeded就会进行立即更新。
参考资料
</content>
    </entry>
    
     <entry>
        <title>PromiseKit使用</title>
        <url>https://iihui.github.io/post/ios-promisekit/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  PromiseKit是简化异步编程的一种非必要方式，使用它可以提高代码的可读性和维护性，让代码更加优雅，它主要用于解决回调地狱问题。
 回调地狱 为了保证异步代码按顺序执行，通常将异步代码嵌套在回调函数中。如果异步方法过多，就会产生过多的回调，一层一层的嵌套，使得代码不清晰，难以维护。即产生所谓的回调地狱callback hell问题。下面的fetchJSON中，产生了3次回调，导致代码看起来比较费劲，可读性较差：
fetchJSON(fromURL: &amp;#34;someURL&amp;#34;) { response, results, error in  switch response {  case .success:  fetchUserData(for: results) { response, results, error in  switch response {  case .success:  loginUser(user: results) { response, _, error in  switch response {  case .success:  // finally all of the callbacks are finished  print(&amp;#34;Handle logic here&amp;#34;)  case .fail:  print(error)  }  }  case .fail:  print(error)  }  }  case .fail:  print(error)  } } promise设计模式 promise设计模式，借用生活中的「承诺」一词来描述异步编程中的回调模型。「承诺」是一种对未来的期许，它有以下两个特点：
  描述未来的一种状态或动作。
  承诺具有不确定性，可以被兑现fullfill，也可能被拒绝rejected。
  因为网络操作一般都是异步的，如果需要编写一个方法从网络获取图片，可以使用承诺模式实现这个方法。首先定义一个返回承诺对象的方法，它不直接返回Image，只有当请求到需要的图片时，这个承诺才会兑现，然后将Image传递到承诺对象中，否则承诺被拒绝（网络错误或者图片不存在）。
无论兑现还是拒绝，这个承诺对象都会标记为已解决（resolve)，已解决的承诺会被销毁。如果既不兑现，也不拒绝，则这个承诺会一直有效，即未解决。
PromiseKit链 在PromiseKit中，通过promise对象将异步任务串接起来的，一个典型的promise链如下所示：
firstly {  promise1() }.then {  promise2() }.then {  promise3() }.ensure {  // something that should happen whatever the outcome 无论承诺是否兑现，都会执行ensure }.done {  // all promises are success resolved }.catch {  // handle error here 所有被rejected的承诺都会集中在这里处理 } 其中firstly是可选的，它只能放在第一个，是为了代码能更加优雅和整齐，它的block也是返回一个Promise。
其中then是接在中间的，也是要求返回一个promise，可以有无限多个then相互连接。任何一个then都可以抛出一个error。
ensure类似于finally，不管事件是否错误，它都一定会得到执行，ensure不同于finally的是，它可以放在任何位置。
done是事件结束的标志，它是必须要有的，只有上面的事件都执行成功时，才会最终执行done。
而catch用于捕获异常，done之前的任何事件出现错误，都会直接进入catch块。
promise对象状态 在PromiseKit中promise是一个对象。它保存异步数据操作，同时提供统一的异步数据操作事件处理的接口，PromiseKit对象。
  fulfilled指的是promise对象当前处理的异步事件已经成功完成
  rejected表示promise对象当前处理的异步事件没有成功
  promise对象执行完then和catch方法后，这两个方法会返回先前的promise对象，同时根据异步操作结果改变promise对象的状态。
举个栗子 fetchJSON(fromURL: &amp;#34;someURL&amp;#34;) { response, results, error in  switch response {  case .success:  fetchUserData(for: results) { response, results, error in  switch response {  case .success:  loginUser(user: results) { response, _, error in  switch response {  case .success:  // finally all of the callbacks are finished  print(&amp;#34;Handle logic here&amp;#34;)  case .fail:  print(error)  }  }  case .fail:  print(error)  }  }  case .fail:  print(error)  } } 上面的fetchJSON方法有3个回调，按照PromiseKit链接结构可以改造成3个方法，每个方法返回promise一个对象，然后依次串接起来，如下所示：
func promiseFetchJSON() -&amp;gt; Promise&amp;lt;String: Any]&amp;gt; {  return Promise&amp;lt;String: Any]&amp;gt; { seal in  fetchJSON(fromURL: &amp;#34;someURL&amp;#34;, completion: { response, results, error in  switch response {  case .success:  seal.fulfill(results)  case .fail:  seal.reject(error)  }  })  } } promise对象初始化的时候提供了seal对象，这个对象定义了回调完成的方法。接着依次改造promiseFetchUserData和promiseLoginUser，如下所示：
func promiseFetchUserData(user: String: Any]) -&amp;gt; Promise&amp;lt;User&amp;gt; {  return Promise&amp;lt;User&amp;gt; { seal in  fetchUserData(for: user, completion: { response, results, error in  switch response {  case .success:  seal.fulfill(results)  case .fail:  seal.reject(error)  }  })  } }  func promiseLoginUser(user: User) -&amp;gt; Promise&amp;lt;Bool&amp;gt; {  return Promise&amp;lt;Bool&amp;gt; { seal in  loginUser(user: user, completion: { response, _, error in  switch response {  case .success:  seal.fulfill(true)  case .fail:  seal.reject(error)  }  })  } } 最后，套用基本调用链格式，将各个返回promise对象的异步事件串起来，形成一个完整的调用链，如下所示：
firstly {  promiseFetchJSON() }.then { json in  promiseFetchUserData(user: json) }.then { user in  promiseLoginUser(user: user) }.ensure {  // something that should happen whatever the outcome }.done { _ in  // all promises are success resolved  // handle final logic here }.catch { _ in  // handle error here } firstly firstly是可选的，它只能放在第一个，是为了代码能更加的优雅和整齐，他的block里也是返回一个一个Promise。
then then是接在中间的，可以无限多个then相互连接。顾名思义，就像我们讲故事可以不断地有然后、然后、然后&amp;hellip;then也是要求返回一个Promise对象的，也就是说，任何一个then都可以抛出一个error，中断事件。
ensure 无论chain在哪里结束，成功或者失败。ensure终将被执行，也可以使用finally来完成相同的功能，区别是finally没有返回值并且ensure可以放在任何位置。
firstly {  // ... }.then {  // ... }.done {  // ... }.ensure {  // ... }.catch {  // ... } firstly {  // ... }.done {  // ... }.catch {  // ... }.finally {  //... } finally 执行完then，或者处理完error后，还有一些操作（比如关闭活动指示器），那么就可以放到finally里面去执行。也就是说不管前面是fulfill还是reject，最终都会进入到 finally`方法里来。
done done是事件结束的标志，它是必须要有的，只有上面的事件都执行成功时，才会最终执行done。在promise链中，done不返回promise，它用于前面所有的promise都success，表示调用链无错误的运行，而then会返回promise对象：
firstly {  login() }.then { creds in  fetch(avatar: creds.user) }.done { image in  self.imageView = image } catch处理 每个promise都是一个表示单个异步任务的对象。如果任务失败，它的promise将成为rejected。产生rejected promises将跳过所有的then，执行后续所有catch。
firstly {  login() }.then { creds in  //... }.done { image in  //... }.catch {  // 整个 chain 上的错误都到了这里 } recover recover能从异常中拯救任务，可以判定某些错误就忽略，当做正常结果返回，剩下的错误继续抛出异常。
CLLocationManager.requestLocation().recover { error -&amp;gt; Promise&amp;lt;CLLocation&amp;gt; in  guard error == MyError.airplaneMode else {  throw error  }  return .value(CLLocation.savannah) }.done { location in  //… } 摘抄自
throw 如果then中需要抛出异常，一种方法是在Promise中调用reject，另一种比较简便的方法就是直接throw：
firstly {  foo() }.then { baz in  bar(baz) }.then { result in  guard !result.isBad else { throw MyError.myIssue }  //…  return doOtherThing() } 如果调用的方法可能会抛出异常，try也会让异常直达catch：
foo().then { baz in  bar(baz) }.then { result in  try doOtherThing() }.catch { error in  // if doOtherThing() throws, we end up here } get 如果想要在异步链路中取值用于其他操作，可以使用get或者tap方法，它们不会影响到原有的链路逻辑。get方法只有前面是完成状态（fulfill）时才会调用，它得到的是具体结果。
参考资料
tap 而tap方法是不管前面是完成fulfill还是失败reject，它都会被调用，同时它得到的是Result&amp;lt;T&amp;gt;。它是一个无侵入操作，不会影响事件的任何属性，只是在适当的时机做一些不影响主线的事情，适用于打点：
firstly {  foo() }.tap {  print($0) }.done {  //… }.catch {  //… } 参考自
when 多个异步操作需要同步的时候，经常会使用group.enter()和group.leave()。在PromoiseKit中使用when来进行多个异步的同步，它提供了并行执行异步方法的能力，并且只在所有异步操作都执行完之后才会执行回调。和其他的 promise链一样，when方法中任一异步操作发生错误，都会进入到下一个catch方法中。
// 并行操作 var result1: ...! var result2: ...! let group = DispatchGroup() group.enter() group.enter() operation1 {  result1 = $0  group.leave() } operation2 {  result2 = $0  group.leave() } group.notify(queue: .main) {  finish(result1, result2) } 使用when之后，简化了多个异步操作的同步，使得代码变得清晰易懂，如下所示：
firstly {  when(fulfilled: operation1(), operation2()) }.done { result1, result2 in  // ... } race race的用法与when一样，只不过when是等所有的异步操作都执行完毕后才执行then的回调。而race只要一个异步操作执行完毕就立即执行then回调，其他没有执行完毕的异步操作仍然会继续执行，而不是停止。
Guarantee Guarantee是Promise的变种、或者补充，其用法和Promise一样，大多情况下二者可以互相替换使用。与Promise状态可以是成功或者失败不同，Guarantee要确保永不失败，因此语法也更简单些，有它就不需要catch来捕获异常了。
after after是一个延迟执行的方法，它就返回了一个Guarantee对象，因为延迟执行是一定不会失败的，所以我们只需要后续接done就行了：
firstly {  after(seconds: 0.1) }.done {  // there is no way to add a `catch` because after cannot fail. } map map是指一次数据的变换，而不是一次事件。例如，我们要把从接口返回的json数据转换成对象，就可以用map，map返回的也是一个对象，但不是Promise。
then方法要求输入一个promise值并返回一个promise，而map是根据先前 promise的结果，然后返回一个新的对象或值类型。
compactMap compactMap与map类似，不过它是返回Optional。例如，我们返回nil，则整个链会产生PMKError.compactMap错误。？？
线程切换 所有then的blocks如果不特别指定，默认都是在主线程执行。PromiseKit切换线程非常的方便和直观，只需要在方法中传入on的线程即可，哪个方法需要指定线程就在那个方法的on传入对应的线程，如下所示：
firstly {  user() }.then(on: DispatchQueue.global()) { user in  URLSession.shared.dataTask(.promise, with: user.imageUrl) }.compactMap(on: DispatchQueue.global()) {  UIImage(data: $0) } 源码 入门 使用 使用 使用
</content>
    </entry>
    
     <entry>
        <title>Ruby 基础</title>
        <url>https://iihui.github.io/post/ruby-base/</url>
        <categories>
          <category>ruby</category>
        </categories>
        <tags>
          <tag>ruby</tag>
        </tags>
        <content type="html">  最近做组件的源码和二进制切换时遇到一些问题，在查资料时发现了cocoapods-imy-bin这个插件，打算以这个插件为基础进行改造，写一个适合自己业务场景的插件。但之前未接触ruby和cocoapods插件开发，这篇文章是一点学习笔记，方便后续查阅。
 调试环境 在Mac上使用RubyMine进行调试ruby程序前需要先安装debase和ruby-debug-ide。按照提示安装时一直失败，提示如下报错信息：
Failed to Install Gems. Following gems were not installed: 	/Applications/RubyMine.app/Contents/plugins/ruby/rb/gems/debase-2.3.2.gem: Error installing debase-2.3.2.gem: 	ERROR: Failed to build gem native extension. current directory: /Users/hui/.gem/ruby/2.6.0/gems/debase-2.3.2/exto /System/Library/Frameworks/Ruby.framework/Versions/2.6/usr/bin/ruby -I /System/Library/Frameworks/Ruby.framework/Versions/2.6/usr/lib/ruby/2.6.0 -r ./siteconf20210116-5397-1jtpnju.rb extconf.rb /System/Library/Frameworks/Ruby.framework/Versions/2.6/usr/lib/ruby/2.6.0/universal-darwin20/rbconfig.rb:229: warning: Insecure world writable dir /usr/local/opt in PATH, mode 040777 checking for vm_core.h... no checking for vm_core.h... no ************************************************************************** No source for ruby-2.6.3-p62 (revision 67580) provided with debase-ruby_core_source gem. Falling back to ruby-2.6.0-p0. ************************************************************************** chec... (show balloon) 查阅资料，发现解决上面报错问题有两种方案，但本质上都是安装隔离的高版本ruby，然后再在RubyMine中安装对应版本的debase以及ruby-debug-ide。
Homebrew 第一种方式是使用Homebrew安装高版本ruby，即用命令brew install ruby。如果安装过程中有如下所示的报错信息：
Error: Could not find an SDK that supports macOS 11.0. You may have have an outdated or incompatible CLT. Homebrew found the following SDKs in the CLT install:  10.14  10.15  Please update CLT or uninstall it if no updates are available. 需要先用brew update命令更新Homebrew本身。然后用brew install ruby或者brew upgrade ruby命令更新ruby。接着，在RubyMine设置中的Ruby SDK and Gems中添加新安装的ruby ：
选择New local，把新版本ruby「目录为/usr/local/Cellar/ruby/3.0.0_1/bin/ruby」加到Ruby SDK and Gems中。然后在调试前更改配置，选择新安装的ruby，如下图所示：
参考资料
RVM 另一种方案是利用rvm安装高版本的ruby，即先用curl -sSL https://get.rvm.io | bash -s stable命令安装rvm，如果看到如下信息，表明安装已经成功：
 Adding rvm PATH line to /Users/hui/.profile /Users/hui/.mkshrc /Users/hui/.bashrc /Users/hui/.zshrc.  Adding rvm loading line to /Users/hui/.profile /Users/hui/.bash_profile /Users/hui/.zlogin. Installation of RVM in /Users/hui/.rvm/ is almost complete:   * To start using RVM you need to run `source /Users/hui/.rvm/scripts/rvm`  in all your open shell windows, in rare cases you need to reopen all shell windows. Thanks for installing RVM 🙏 Please consider donating to our open collective to help us maintain RVM.  👉 Donate: https://opencollective.com/rvm/donate 如果在安装过程中出现curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused这样的错误信息，则说明DNS解析被污染，导致DNS解析过程无法通过域名取得正确的IP地址。
这就需要先到ipaddress上查询raw.githubusercontent.com对应的IP地址。然后借助SwitchHosts修改host文件中raw.githubusercontent.com对应的IP地址，使得请求raw.githubusercontent.com时，直接去请求相应的IP地址，而不再走DNS解析过程。具体操作看这里。
接着根据提示，使用source ~/.rvm/scripts/rvm命令「具体路径根据提示」启用rvm。然后使用rvm install &amp;quot;ruby-2.7.2&amp;quot;命令安装高版本ruby。
安装成功后，使用rvm use 2.7.2命令启用新安装的ruby。因为，用gem安装的工具都处于gem的管理之下，而gem是ruby标准库的一部分，所以切换了ruby版本之后，对应的gem也就随之切换了。那么之前使用gem安装的包，例如cocoapods,xcpretty等都会随之切换，所以之前安装的工具都需要重新安装。
接着在RubyMine中添加ruby 2.7.2，路径为~/.rvm/rubies/ruby-2.7.2/bin/ruby，如下图所示：
接着，点击调试按钮，按照提示安装debase和ruby-debug-ide，如下所示，等待安装完毕，就可以打断点调试ruby程序了：
参考资料
插件调试 准备源码 为了调试cocopods和cocoapods-imy-bin插件，首先需要下载相应的源码。先创建一个目录bundle「名字可以随意」，然后在该目录下使用下面命令获取CocoaPods仓库中tag为1.10.1版本的源码：
git clone -b 1.10.1 https://github.com/CocoaPods/CocoaPods.git 接着在相同目录下，使用下面的命令获取cocoapods-imy-bin插件tag为0.3.1.3的源码：
git clone -b 0.3.1.3 https://github.com/MeetYouDevs/cocoapods-imy-bin.git 接着在同级目下创建Gemfile文件，内容如下所示。在Gemfile文件中，source是下载的源，gem xxx默认是从源仓库下载，当指定path表示指向本地源码：
source &amp;#39;https://rubygems.org&amp;#39;  gem &amp;#39;cocoapods&amp;#39; , :path =&amp;gt; &amp;#34;./CocoaPods&amp;#34; gem &amp;#39;cocoapods-imy-bin&amp;#39; , :path =&amp;gt; &amp;#34;./cocoapods-imy-bin&amp;#34;  group :debug do  gem &amp;#39;ruby-debug-ide&amp;#39;  gem &amp;#39;debase&amp;#39; end 安装依赖 在调试某个gem库的时候，为了不影响已经安装的依赖，在安装依赖的时候，最好是安装到当前文件夹下的执行目录中。对于ruby的依赖包管理工具bundle，如果配置了config文件，就可以在配置文件中声明安装目录。因此，在同级下创建.bundle目录，再在.bundle目录下创建文件config，内容如下：
BUNDLE_PATH: &amp;#34;vendor/bundle&amp;#34; 最后回到Gemfile所在目录，执行bundle install，将会把Gemfile文件中所声明的依赖安装到vendor/bundle目录下。
参考资料
开始调试 使用RubyMine打开Gemfile所在的父目录bundle。然后点击添加配置，在Gem name中输入cocoapods-imy-bin，在Executable name中输入pod，在Arguments中输入bin init。接着，再在bundle目录下创建demo目录，然后在demo创建Podfile，接着在Working directory中选择demo目录，如下所示：
如果在调试的时候，遇到如下类似的报错信息，则说明需要重新安装对应的依赖，使用gem install xxx安装即可。
Uncaught exception: can&amp;#39;t find gem cocoapods (&amp;gt;= 0.a) with executable pod 参考资料 参考资料 参考资料
创建新插件 参考资料 参考资料
双私有源方案 双私有源的方案是将二进制的包上传到服务器中，同时产生一份二进制的podspec，将其发布到二进制私有源中。
在执行pod install后，Cocoapods在解析依赖的过程中，根据podfile.lock指定的版本，构建Specification对象「定义在cocoapod-core中用来描述podspec对象」。
在分析依赖的过程中，会生成一个叫resolver_specs_by_target的hash，包含podfile中配置的所有target以及对应target下所有的pod库信息。整个过程比较复杂，流程结束之后整个依赖关系就确定了。内部会根据前面生成的Milinilo图遍历，将所有的target依赖的pod库构建为ResolverSpecification对象。
通过hook resolver_specs_by_target，遍历所有的podspec，找到做了二进制标记的pod库，对其进行重组，来进行二进制的切换。
# &amp;gt;= 1.4.0 才有 resolver_specs_by_target 以及 ResolverSpecification  # &amp;gt;= 1.5.0 ResolverSpecification 才有 source，供 install 或者其他操作时，输入 source 变更  #  if Pod.match_version?(&amp;#39;~&amp;gt; 1.4&amp;#39;)  old_resolver_specs_by_target = instance_method(:resolver_specs_by_target)  define_method(:resolver_specs_by_target) do  specs_by_target = old_resolver_specs_by_target.bind(self).call   sources_manager = Config.instance.sources_manager  use_source_pods = podfile.use_source_pods   missing_binary_specs = []  specs_by_target.each do |target, rspecs|  # use_binaries 并且 use_source_pods 不包含 本地可过滤  use_binary_rspecs = if podfile.use_binaries? || podfile.use_binaries_selector  rspecs.select do |rspec|  ([rspec.name, rspec.root.name] &amp;amp; use_source_pods).empty? &amp;amp;&amp;amp;  (podfile.use_binaries_selector.nil? || podfile.use_binaries_selector.call(rspec.spec))  end  else  []  end   # Parallel.map(rspecs, in_threads: 8) do |rspec|  specs_by_target[target] = rspecs.map do |rspec|  # 含有 subspecs 的组件暂不处理  # next rspec if rspec.spec.subspec? || rspec.spec.subspecs.any?   # developments 组件采用默认输入的 spec (development pods 的 source 为 nil)  # 可以使 :podspec =&amp;gt; &amp;#34;htts://IMYFoundation.podspec&amp;#34;可以走下去，by slj  # unless rspec.spec.respond_to?(:spec_source) &amp;amp;&amp;amp; rspec.spec.spec_source  # next rspec  # end   # 采用二进制依赖并且不为开发组件  use_binary = use_binary_rspecs.include?(rspec)  source = use_binary ? sources_manager.binary_source : sources_manager.code_source   spec_version = rspec.spec.version  UI.message &amp;#39;cocoapods-imy-bin 插件&amp;#39;  UI.message &amp;#34;- 开始处理 #{rspec.spec.name}#{spec_version}组件.&amp;#34;   begin  # 从新 source 中获取 spec,在bin archive中会异常，因为找不到  specification = source.specification(rspec.root.name, spec_version)  UI.message &amp;#34;#{rspec.root.name}#{spec_version}\r\nspecification =#{specification}&amp;#34;  # 组件是 subspec  if rspec.spec.subspec?  specification = specification.subspec_by_name(rspec.name, false, true)  end  # 这里可能出现分析依赖的 source 和切换后的 source 对应 specification 的 subspec 对应不上  # 造成 subspec_by_name 返回 nil，这个是正常现象  next unless specification   used_by_only = if Pod.match_version?(&amp;#39;~&amp;gt; 1.7&amp;#39;)  rspec.used_by_non_library_targets_only  else  rspec.used_by_tests_only  end  # used_by_only = rspec.respond_to?(:used_by_tests_only) ? rspec.used_by_tests_only : rspec.used_by_non_library_targets_only  # 组装新的 rspec ，替换原 rspec  if use_binary  rspec = if Pod.match_version?(&amp;#39;~&amp;gt; 1.4.0&amp;#39;)  ResolverSpecification.new(specification, used_by_only)  else  ResolverSpecification.new(specification, used_by_only, source)  end  UI.message &amp;#34;组装新的 rspec ，替换原 rspec #{rspec.root.name}#{spec_version}\r\nspecification =#{specification}\r\n#{rspec}&amp;#34;   end   rescue Pod::StandardError =&amp;gt; e  # 没有从新的 source 找到对应版本组件，直接返回原 rspec   # missing_binary_specs &amp;lt;&amp;lt; rspec.spec if use_binary  missing_binary_specs &amp;lt;&amp;lt; rspec.spec  rspec  end   rspec  end.compact  end   if missing_binary_specs.any?  missing_binary_specs.uniq.each do |spec|  UI.message &amp;#34;【#{spec.name}| #{spec.version}】组件无对应二进制版本 , 将采用源码依赖.&amp;#34;  end  Pod::Command::Bin::Archive.missing_binary_specs(missing_binary_specs)   #缓存没有二进制组件到spec文件，local_psec_dir 目录  sources_sepc = []  des_dir = CBin::Config::Builder.instance.local_psec_dir  FileUtils.rm_f(des_dir) if File.exist?des_dir  Dir.mkdir des_dir unless File.exist?des_dir  missing_binary_specs.uniq.each do |spec|  next if spec.name.include?(&amp;#39;/&amp;#39;)   spec_git_res = false  CBin::Config::Builder.instance.ignore_git_list.each do |ignore_git|  spec_git_res = spec.source[:git] &amp;amp;&amp;amp; spec.source[:git].include?(ignore_git)  break if spec_git_res  end  next if spec_git_res   #获取没有制作二进制版本的spec集合  sources_sepc &amp;lt;&amp;lt; spec  unless spec.defined_in_file.nil?  FileUtils.cp(&amp;#34;#{spec.defined_in_file}&amp;#34;, &amp;#34;#{des_dir}&amp;#34;)  end  end  end   specs_by_target  end  end  end 上面是一种类似于OC的Method Swizzling。上面的instance_method临时存储resolver_specs_by_target方法，define_method类似于关键字def，def是定义一个方法，define_method是产生一个新的方法，类似于class_addMethod可以根据参数动态生成方法。
获取到specs_by_target后，取出需要切换的Specification对象的rspec和二进制源source，通过source的specification方法构建二进制Specification对象。
匹配规则 在执行pod install后，关于podspec的匹配规则可以简单的描述为：
 首先取出podfile配置的pod库 取出该pod在源内的所有版本 找到podfile.lock对应库的版本 根据podfile.lock中对应的版本，取出对应的podspec  在pod install命令执行过程中，会有一个解析依赖的阶段。当控制台打印Analyzing dependencies的时候就是在解析内部依赖关系的过程。在解析依赖的过程中有个很重要的方法resolver_specs_by_target,所有的pod库的最终信息都会在这个方法中返回，可以通过hook这个方法，拿到所有pod库的podspec信息，然后将其替换为想要的，即可晚餐切换。
cocoapods/installer.rb  def install!  # 准备环境  prepare  # 解析依赖  resolve_dependencies  # 下载依赖  download_dependencies  # 验证target  validate_targets  # 生成工程文件  if installation_options.skip_pods_project_generation?  show_skip_pods_project_generation_message  else  integrate  end  # 写入依赖  write_lockfiles  # 结束回调  perform_post_install_actions end 基础知识 简介 所有的Ruby文件扩展名都是.rb。在ruby代码中，空白字符一般都会被忽略，而字符串中的空白字符不会被忽略。
Ruby默认使用ASCII来读源码，如果在代码中直接使用中文会报错，需要在文件开头加入# -*- coding: UTF-8 -*-。
在Ruby中单行注释以#开头，直到该行结束。多行注释以=begin开头，以=end结束：
=begin 这是一个多行注释。 可扩展至任意数量的行。 但 =begin 和 =end 只能出现在第一行和最后一行。 =end  # 单行注释 变量 在Ruby中，变量不需要提前声明，为变量赋初值时会自动创建。例如，a = 300 会创建一个名为a的变量，并将300存储在该变量中。
Ruby变量可以容纳任何类型的数据，甚至可以对一个已经定义的变量，更改其数据类型，如下所示：
b = &amp;#34;test&amp;#34; puts b b = 233 puts b 命名 Ruby中变量名的风格偏好：使用小写字母，以下划线连接，不使用缩写，不以数字开头，以内容的含义命名。
作用域 参考资料
字符串 Ruby中字符串分为单引号和双引号字符串，区别在于双引号字符串能够支持更多的转义字符。即在双引号括起来的字符串中，转义字符会被解析。而在单引号括起来的字符串中，转义字符多数不会被解析，基本按照原样输出。
单引号 如果需要在单引号字符串中使用单引号，必须使用转义字符，例如&#39;Won\&#39;t you read O\&#39;Reilly\&#39;s book?&#39;
Ruby中还支持一种采用%q来引导的字符串（单引号引用规则），后面紧跟 !,{,[,|,&amp;lt;的开始定界符，最后以!,},],|,&amp;gt;结尾的定界符，如下所示：
puts %q! test ! puts %q{ test } puts %q[ test ] puts %q| test | puts %q&amp;lt; test &amp;gt; 双引号 在双引号括起来的字符串中，转义字符会被解析。而在单引号括起来的字符串中，转义字符多数不会被解析，基本按照原样输出。
Ruby中还支持一种采用%Q来引导的字符串（双引号引用规则），后面紧跟 !,{,[,|的开始定界符，最后以!,},],|结尾的定界符，如下所示：
name = &amp;#34;hello&amp;#34; puts %Q! test #{name} ! puts %Q{ test #{name}} puts %Q[ test #{name}] puts %Q| test #{name} | puts %Q&amp;lt; test #{name}&amp;gt; heredoc 参考资料
运算符  &amp;lt;= 判断左操作数的值是否小于或者等于右操作数的值，如果是则条件为真。 &amp;gt;= 判断左操作数的值是否大于或者等于右操作数的值，如果是则条件为真。 &amp;lt;=&amp;gt; 联合比较符，如果左边操作数等于右边操做数，则返回0，如果左边操作数大于右边操作数，则返回1，否则返回-1。 and 与 &amp;amp;&amp;amp; 均为和，区别是and优先级比&amp;amp;&amp;amp;低。 or 与 ||均为或，区别是前者的优先级低于后者。 not 与 !均为非，区别是前者的优先级低于后者。 &amp;amp;&amp;amp;的运算法则是左边为false或者nil时，直接返回false或nil，右边将不会被运算；否则返回右边的对象。 ||的运算法则是左边为false或者nil时，返回右边的对象；否则返回左边的对象，右边将不会被运算。  def current_user  @current_user ||= session[:user_id] &amp;amp;&amp;amp; User.find(session[:user_id]) end def current_user  if @current_user  return @current_user  else  if session[:user_id]  @current_user = User.find(session[:user_id])  else  @current_user = nil  end  return @current_user  end end 参考资料 参考资料
跳出作用域 参考资料
模块  模块定义了一个命名空间，相当于一个沙盒，把方法、类和常量组合在一起，在里面的方法，常量，类都不会与其他地方的常量冲突。
 模块中常量的命名和类常量命名相似，以大写字母开头。可以使用模块名称和两个冒号来引用一个常量。
require require类似于C&#43;&#43;中的include或者Java中的import语句。如果程序中想使用已经定义的模块，可以使用require filename来引用。
数组 在Ruby中，索引为-1表示数组的最后一个元素，-2表示倒数第二个元素，依次类推。数组不需要指定大小，当向数组添加元素时，Ruby数组会自动增长。对于数组可以使用count或size或length得到数组长度。
names = Array.new(20)  puts names.count, names.length  names = Array.new(4,&amp;#34;test&amp;#34;)  puts &amp;#34;#{names}&amp;#34;  nums = Array.new(10) { |e| e = e * 2 } puts &amp;#34;#{nums}&amp;#34;  nums = Array(0..9) puts &amp;#34;#{nums}&amp;#34;  nums = Array[11,23,45] puts &amp;#34;#{nums}&amp;#34;  nums = Array.[](88,99,1120,89,457,783) puts &amp;#34;#{nums}&amp;#34;  nums = Array.new nums.append(56) puts &amp;#34;#{nums}&amp;#34; 哈希 Ruby中的哈希类似于其他语言中的字典。可以使用new来创建带默认值的哈希，当访问有默认值的哈希中的键时，如果键或值不存在时，将返回默认值。没有默认值的哈希，访问的键或值不存在时，将返回nil。
months = Hash.new(&amp;#34;month&amp;#34;) puts months[&amp;#34;test&amp;#34;]  months = Hash.new &amp;#34;Test&amp;#34; puts months[&amp;#34;name&amp;#34;] 在Ruby中可以任何对象作为键或者值，甚至可以使用数组：
hash = Hash[&amp;#34;a&amp;#34; =&amp;gt; 12, &amp;#34;b&amp;#34; =&amp;gt; &amp;#34;test&amp;#34;] puts &amp;#34;#{hash[&amp;#39;a&amp;#39;]}#{hash[&amp;#39;b&amp;#39;]}&amp;#34; #12 test  hash[[1,&amp;#34;josn&amp;#34;]] = &amp;#34;json&amp;#34; puts hash #{&amp;#34;a&amp;#34;=&amp;gt;12, &amp;#34;b&amp;#34;=&amp;gt;&amp;#34;test&amp;#34;, [1, &amp;#34;josn&amp;#34;]=&amp;gt;&amp;#34;json&amp;#34;} 类 attr_accessor参考 参考资料
 参考资料 参考资料
</content>
    </entry>
    
     <entry>
        <title>属性包装</title>
        <url>https://iihui.github.io/post/ios-propertywrapper/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  属性包装器propertyWrapper的作用对象是属性，它的思想是只可以通过wrappedValue的get和set方法来访问属性，这样就可以通过get和set方法来对属性进行包装，提供特定功能的属性。属性包装器是一种通用结构，它封装了wrappedValue属性的读写访问，并可以为其添加其他行为，也就是如果需要限制属性值，向get和set方法添加限制逻辑即可。
 基本使用 属性包装器propertyWrapper是Swift 5.1引入，使用时必须满足两个条件。首先必须使用@propertyWrapper声明。其次，必须具有非静态的wrapppedValue属性。
@propertyWrapper struct SomeWrapper {  var wrappedValue: Int  var someValue: Double  init() {  self.wrappedValue = 100  self.someValue = 12.3  }  init(wrappedValue: Int) {  self.wrappedValue = wrappedValue  self.someValue = 45.6  }  init(wrappedValue value: Int, custom: Double) {  self.wrappedValue = value  self.someValue = custom  } }  struct SomeStruct {  // 使用 init() 进行初始化  @SomeWrapper var a: Int   // 使用 init(wrappedValue:) 进行初始化  @SomeWrapper var b = 10   // 两个都是使用 init(wrappedValue:custom:) 进行初始化  @SomeWrapper(custom: 98.7) var c = 30  @SomeWrapper(wrappedValue: 30, custom: 98.7) var d }  @propertyWrapper struct Wrapper&amp;lt;T&amp;gt; {  var wrappedValue: T }  struct TestWrapper {  @Wrapper var x: Int  @Wrapper var y = 12  @Wrapper(wrappedValue: 34) var z }  func test() {  let test1 = TestWrapper(x: 100)  print(test1.x, test1.y, test1.z)   let test2 = TestWrapper(x: 34, y: 45, z: Wrapper(wrappedValue: 89))  print(test2.x,test2.y,test2.z) } 在属性包装器中，也可以提供额外的功能，但如果要使用这些额外的功能，则需要访问包装器本身，而不是其封装的属性值wrappedValue。如果想要访问包装器本身，而不是包装的属性值，则需要在属性名称之前添加下划线。下面代码中属性包装器Wrapper提供了的函数foo不能直接访问，需要利用包装器本身来访问，即在包装属性前加下划线：
@propertyWrapper struct Wrapper&amp;lt;T&amp;gt; {  var wrappedValue: T   func foo(){  print(&amp;#34;foo&amp;#34;)  } }  struct TestWrapper {  @Wrapper var x: Int  @Wrapper var y = 12  @Wrapper(wrappedValue: 34) var z   func foo(){  _x.foo() //_x是属性包装器本身，不能通过x.foo()来访问foo  } }  func test() {  let test1 = TestWrapper(x: 100)  print(test1.x, test1.y, test1.z)   let test2 = TestWrapper(x: 34, y: 45, z: Wrapper(wrappedValue: 89))  print(test2.x,test2.y,test2.z)   test1.foo()  test2.foo() } 上面的_x是属性包装器本身，它是private级别的。因此，从外部使用它会产生编译错误。属性包装器还可以通过定义投影值来暴露其他功能。投影值的名称与包装值相同，只是它以$开头。投影值使用projectedValue定义，可以返回任何类型的值作为投影值：
@propertyWrapper struct Wrapper&amp;lt;T&amp;gt; {  var wrappedValue: T  var projectedValue: Wrapper&amp;lt;T&amp;gt; { return self }   func foo(){  print(&amp;#34;foo&amp;#34;)  } }  struct TestWrapper {  @Wrapper var x: Int  @Wrapper var y = 12  @Wrapper(wrappedValue: 34) var z   func foo(){  _x.foo()  $x.foo()  //不能使用x.foo()，因为x代表wrappedValue  print(x,_x,$x) //12 Wrapper&amp;lt;Int&amp;gt;(wrappedValue: 12) Wrapper&amp;lt;Int&amp;gt;(wrappedValue: 12)  } }  func test() {  let test1 = TestWrapper(x: 100)  print(test1.x, test1.y, test1.z)   let test2 = TestWrapper(x: 34, y: 45, z: Wrapper(wrappedValue: 89))  print(test2.x,test2.y,test2.z)   test1.foo()  test2.foo()   test1.$x.foo()  test2.$x.foo() } 在上面的例子中投影值返回的是包装器本身，也就是投影成自己。投影值可以返回任何类型的值，在下面的例子中，投影值是布尔类型：
@propertyWrapper struct SmallNumber {  private var number: Int  var projectedValue: Bool   init() {  self.number = 0  self.projectedValue = false  }   var wrappedValue: Int {  get {  return number  }  set {  if newValue &amp;gt; 12 {  number = 12  projectedValue = true  } else {  number = newValue  projectedValue = false  }  }  } }  struct SomeStruct {  @SmallNumber var someNum: Int }  func testSmall() {  var small = SomeStruct()  small.someNum = 3  print(small.$someNum) // false  small.someNum = 70  print(small.$someNum) // true } 参考资料 参考资料
减少重复代码 使用属性包装器可以减少重复代码。我们通常使用UserDefaults来保存引导页是否已经展示过，如果没有@propertyWrapper时，可能会使用如下代码实现：
extension UserDefaults {  public enum Keys {  static let hasDisplayedGuideView = &amp;#34;has_Displayed_guide_view&amp;#34;  }   var hasDisplayedGuideView: Bool {  get {  return bool(forKey: Keys.hasDisplayedGuideView)  }  set {  set(newValue, forKey: Keys.hasDisplayedGuideView)  }  } }  func showGuide() {  let hasDisplayed = UserDefaults.standard.hasDisplayedGuideView   if hasDisplayed {  // 显示引导页  UserDefaults.standard.hasDisplayedGuideView = false  } } 如果后续需要再添加另一个引导项，则需要重复上面的代码。如果使用@propertyWrapper，可以减少上面的重复代码，如下所示：
@propertyWrapper struct UserDefault&amp;lt;T&amp;gt; {  let key: String  let defaultValue: T   init(key: String, defaultValue: T) {  self.key = key  self.defaultValue = defaultValue  }   var wrappedValue: T {  get {  return UserDefaults.standard.object(forKey: key) as? T ?? defaultValue  }  set {  UserDefaults.standard.set(newValue, forKey: key)  }  } }  enum UserDefaultConfig {  @UserDefault(key: &amp;#34;speech_guide&amp;#34;, defaultValue: false) static var speechGuide: Bool  @UserDefault(key: &amp;#34;note_guide&amp;#34;, defaultValue: false) static var noteGuide: Bool }  func testGuide() {  UserDefaultConfig.speechGuide = false  UserDefaultConfig.noteGuide = true } 因为UserDefaults本身只能存储基本类型，所以上面的包装的属性UserDefault，也只适用于基本类型都。对于非基本类型，就要借助于Codable才能保存：
/// for codable @available(swift 5.1) @propertyWrapper struct UserDefaultJsonWrapper&amp;lt;T: Codable&amp;gt; {  var key: String  var defaultValue: T  var wrappedValue: T {  get {  guard let jsonString = UserDefaults.standard.string(forKey: key) else {  return defaultValue  }  guard let jsonData = jsonString.data(using: .utf8) else {  return defaultValue  }  guard let value = try? JSONDecoder().decode(T.self, from: jsonData) else {  return defaultValue  }  return value  }  set {  let encoder = JSONEncoder()  guard let jsonData = try? encoder.encode(newValue) else {  return  }  let jsonString = String(bytes: jsonData, encoding: .utf8)  UserDefaults.standard.set(jsonString, forKey: key)  }  }   init(key: String, defaultValue: T) {  self.key = key  self.defaultValue = defaultValue  } } /// 全局配置的属性包装，wrappedValue为可选值 @propertyWrapper public struct CodableGlobalConfigProperty&amp;lt;T: Codable&amp;gt; {   private var key: UserDefaultsKey   public init(key: UserDefaultsKey) {  self.key = key  }   public var wrappedValue: T? {  get {  if let data = UserDefaultsManager.standard.value(forKey: key) as? Data, let model = try? JSONDecoder().decode(T.self, from: data) {  return model  } else {  return nil  }  }  set {  if let value = newValue {  // 此处不可与上面合并,因为要确保newValue为nil时删除key对应的值  if let jsonData = try? JSONEncoder().encode(value) {  UserDefaultsManager.standard.set(value: jsonData, forKey: key)  }  } else {  UserDefaultsManager.standard.remove(forKey: key)  }  }  } } 参考资料
原子属性包装器 静态缓存类相关变量（类变量或者结构体中含有类变量），数组，字典均是多线程不安全的，为了解决线程安全问题，可以使用属性包装器定义原子属性：
@propertyWrapper public struct Atomic&amp;lt;Value&amp;gt; {   private var value: Value  private var lock: os_unfair_lock //自旋锁   public init(wrappedValue value: Value) {  self.value = value  lock = os_unfair_lock.init()  }   public var wrappedValue: Value {  mutating get {  return read()  }  set {  write(newValue: newValue)  }  }   mutating func read() -&amp;gt; Value {  os_unfair_lock_lock(&amp;amp;self.lock)  defer {  os_unfair_lock_unlock(&amp;amp;self.lock)  }  return value  }   mutating func write(newValue: Value) {  os_unfair_lock_lock(&amp;amp;self.lock)  defer {  os_unfair_lock_unlock(&amp;amp;self.lock)  }  value = newValue  } } 参考资料
public class UserConfigService {  private var pid: String  private let split: String = &amp;#34;...&amp;#34;   public init(pid: String) {  self.pid = pid  // 取巧的方式将id传递给属性包装器  _loginRestriction.setId(id: self.pid)  } } /// 用户个性化配置的属性包装，需带默认值 @propertyWrapper public struct UserConfigProperty&amp;lt;Value&amp;gt; {  /// 自定UserDefaultsKey，详见其定义  private var key: UserDefaultsKey  /// 默认值  private var defaultValue: Value  /// 用户主键  private var id: String   public init(key: UserDefaultsKey, id: String, defaultValue: Value) {  self.key = key  self.defaultValue = defaultValue  self.id = id  }   public init(key: UserDefaultsKey, defaultValue: Value) {  self.key = key  self.defaultValue = defaultValue  // 因为属性包装器会在init方法之前执行，导致id无法初始化，因此先给id一个初始空值  self.id = &amp;#34;&amp;#34;  }   /// 因为属性包装器会在init方法之前执行，所以初始给了一个空值，此函数是为了修改真正的id  /// - Parameter id: id  public mutating func setId(id:String) {  self.id = id  }   public var wrappedValue: Value {  get {  return (UserDefaultsManager.standard.value(forKey: key, forId: id) as? Value) ?? defaultValue  }  set {  UserDefaultsManager.standard.set(value: newValue, forKey: key, forId: self.id)  }  } } 测试代码 在工程中ConfigDataService文件中相关的缓存变量都是数组，例如static var desktopConfigItems: [MoConfigItemModel] = []是线程不安全的，不使用原子属性包装器下面测试代码会闪退：
static func testDemo(){  let group = DispatchGroup()  let models:[MoConfigItemModel] = [MoConfigItemModel(),MoConfigItemModel()]  for _ in 0..&amp;lt;2000 {  let delaySet = TimeInterval(arc4random() % 10);  group.enter()  DispatchQueue.global().asyncAfter(deadline: .now() &#43; delaySet) {  self.desktopConfigItems = models  group.leave()  }   let delaySetNil = TimeInterval(arc4random() % 10);  group.enter()  DispatchQueue.global().asyncAfter(deadline: .now() &#43; delaySetNil) {  self.desktopConfigItems.append(MoConfigItemModel())  group.leave()  }   let delayGet = TimeInterval(arc4random() % 10)  group.enter()  DispatchQueue.global().asyncAfter(deadline: .now() &#43; delayGet) {  let _ = self.allConfigItems  group.leave()  }  }   let success = group.wait(timeout: .now() &#43; 12)  if success == .success {  print(&amp;#34;test&amp;#34;)  }  } </content>
    </entry>
    
     <entry>
        <title>调试</title>
        <url>https://iihui.github.io/post/ios-debug/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> LLDB LLDB是一个庞大的工具,内置了许多有用的命令。
命令语法结构 &amp;lt;command&amp;gt; [&amp;lt;subcommand&amp;gt; [&amp;lt;subcommand&amp;gt;...]] &amp;lt;action&amp;gt; [-options [option-value]] [argument [argument...]] 其中：
 command和subcommand为LLDB调试命令的名称，命令和子命令按照层级结构来排列：一个命令对象为跟随其的子命令对象创建一个上下文，子命令又为其子命令创建一个上下文，依此类推。 action  上面的这些元素之间通过空格来分割，如果某一元素自身含有空格，则可以使用双引用。而如果元素中又包含双引号，则可以使用反斜杠；或者元素使用单引号。如下所示：
(lldb) command [subcommand] -option &amp;#34;some \&amp;#34;quoted\&amp;#34; string&amp;#34; (lldb) command [subcommand] -option &amp;#39;some &amp;#34;quoted&amp;#34; string&amp;#39; 获取变量值和状态 使用expression和e可以获取和改变变量的值
获取整个APP的状态和指定语言的命令  bugreport:生成当前应用状态的完整报告 frame:获取当前线程的当前栈帧的概述  参考资料
不能安装 无法安装 因为App是企业发布，偶尔有人反映安装不了，最近有人反映在iPhone8 Plus上遇到「无法安装XXX，请稍候再试」的情况，如下图所示： 这篇文章给出如下的建议：
安装到最后变灰了 安装到一半变灰了，可以先清除Safari浏览器，然后再重启，再通过ideviceinstaller -i命令安装：
参考资料
手机发烫 手机发烫，调试时看到总是看到字体日志和safe_M_setObjectforKeyedSubscript-------object is nil相关信息，如下图红色框所示：
CoreText note: Client requested name &amp;#34;.SFUI-Regular&amp;#34;, it will get TimesNewRomanPSMT rather than the intended font. All system UI font access should be through proper APIs such as CTFontCreateUIFontForLanguage() or &#43;[UIFont systemFontOfSize:]. 根据提示，设置CTFontLogSystemFontNameRequest符号端点，可以查看相关信息。
开启网络服务 Start a Web Server python2 -m SimpleHTTPServer 50524 python3 -m http.server --cgi 50524 参考资料
mospecs is not clean The repo `cmbchina-mospecs` at `../../../../.cocoapods/repos/cmbchina-mospecs` is not clean 需要先删除mospecs然后添加mospecs。
微信分享 iOS-Universal Link 接入与微信分享的配置 微信分享的配置
Safari调试  在Mac上调试iOS WebView既需要在Mac上的Safari浏览器上开启开发者选项，也需要在iOS设备上开启Web检查功能。
 开启Mac的开发者菜单 首先需要开启Mac上Safari浏览器的显示开发者菜单选项。即先进入到Safari浏览器中的设置，然后点击最右边的高级，再勾选在菜单栏中显示开发菜单，如下图所示：
开启iOS上Safari上的Web检查 然后开启iOS设备中Safari里的网页检查器，设置路径为：设置--&amp;gt;Safari-&amp;gt;高级-&amp;gt;网页检查器：
开始调试 将手机连接到Mac上，打开WebView页面，然后在Mac上的Safari浏览器中的开发者菜单中找到对应的iOS设备：
 参考资料
</content>
    </entry>
    
     <entry>
        <title>KSCrash</title>
        <url>https://iihui.github.io/post/ios-kscrash/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  KSCrash是知名的崩溃日志收集框架。总共分为三个部分，Crash Recording，Crash Reporting以及Installation。其中Installation用来启动KSCrash，并且指定Crash收集的方式。Crash收集方式包括：邮件KSCrashInstallationEmail，向自定义服务器发送KSCrashInstallationStandard，隐式收集KSCrashInstallationHockey和KSCrashInstallationQuincy，在控制台「Debug」输出崩溃日志KSCrashInstallationConsole。
 邮件发送崩溃日志 之前项目中使用PLCrashReporter来收集崩溃日志，但是相比于KSCrash，它对于导致崩溃的原因以及第三方framework的符号化相对较弱。下面是KSCrash使用邮件的方式来收集崩溃日志：
import KSCrash class CrashReporterService {  static var shared = CrashReporterService()  private let emailAddress = &amp;#34;xiaohui.sysu@qq.com&amp;#34;  func startCrashReport() {  let installation = KSCrashInstallationEmail.sharedInstance()  installation?.recipients = [emailAddress]  installation?.subject = &amp;#34;Crash Report&amp;#34;  installation?.message = &amp;#34;This is a crash report&amp;#34;  installation?.filenameFmt = &amp;#34;crash-report-%d.crash.gz&amp;#34;  installation?.reportStyle = KSCrashEmailReportStyleApple  // KSCrash.sharedInstance()?.deleteBehaviorAfterSendAll = KSCDeleteOnSucess  installation?.addConditionalAlert(withTitle: &amp;#34;Crash Detected&amp;#34;,  message: &amp;#34;The app crashed last time it was launched. Send a crash report?&amp;#34;,  yesAnswer: &amp;#34;Sure!&amp;#34;,  noAnswer: &amp;#34;No thanks&amp;#34;)  installation?.install()  installation?.sendAllReports { (reports, completed, error) -&amp;gt; Void in  if completed, let count = reports?.count {  print(&amp;#34;Sent \(count)reports&amp;#34;)  } else if let msg = error?.localizedDescription {  print(&amp;#34;Failed to send reports: \(msg)&amp;#34;)  }  }  } } 参考资料 参考资料 参考资料
行号为0 如果源文件的行号为0，则表示回溯堆栈未能映射到原始代码中的特定代码行。这是因为编译器通过内联函数等方式对代码进行了优化，而崩溃时执行的代码与原始代码中的确切行并不对应，在这种情况下，只能利用函数名这个线索。
修复崩溃 NSPlaceholderArray *** -[__NSPlaceholderArray initWithCapacity:]: capacity (18446744073709549746) is ridiculous 出现上面闪退，说明是在初始化的时候，使用的预设值太大。可能是数组初始化时容量过大，也可能是数组初始化时容量为负数。而在这个项目中，是因为设置tableView的frame时用到了CGFloat.greatestFiniteMagnitude：
参考资料 参考资料 参考资料
NSCameraUsageDescription 如果在使用相机前没有给定权限，就会报The app’s Info.plist must contain an NSCameraUsageDescription key with a string value explaining to the user how the app uses this data.。此时，应该在工程的info.plist文件中添加Privacy Camera Usage Description，并给它一个值，如下图所示：
 </content>
    </entry>
    
     <entry>
        <title>Shell 常用命令</title>
        <url>https://iihui.github.io/post/shell-base/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  本文记录工作中用的shell命令，以便下次使用的时候查阅。
 软链接 创建 ln ~/.cocoapods/repos-art/CocoaPods-cmb ~/.cocoapods/repos 删除 unlink cocoaPods-github </content>
    </entry>
    
     <entry>
        <title>Python 基础</title>
        <url>https://iihui.github.io/post/python-base/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> 字符串 在python中，用引号括起来的都是字符串，其中的引号可以是单引号，也可以是双引号。对于字符串，title()函数以首字母大写的方式显示每个单词；upper()函数将字符串全部转为大写；lower()函数将字符串全部转为小写。
lstrip()函数删除字符串前面的空白符；rstrip()函数删除字符串最后的空白符；strip()函数删除字符串开头和结尾的空白符。
print语句 在python2中print不是一个函数，而在python 3中它是一个函数，因此括号必不可少。在python2中可以把变量用括号括起来，所以也可以像python3一样使用print()，但与python3的函数调用完全不一样。在Python3中能使用help(print)来查看文档，在Python2中不行。此外，在Python3中使用print能更方便的重定向，而Python2中要使用类似C&#43;&#43;风格的重定向：
with open(&amp;#39;print.txt&amp;#39;, &amp;#39;w&amp;#39;) as f:  print(&amp;#39;hello, python!&amp;#39;, file = f) with open(&amp;#39;print.txt&amp;#39;, &amp;#39;w&amp;#39;) as f:  print &amp;gt;&amp;gt; f, &amp;#39;hello, python!&amp;#39; 参考资料。
列表 列表由一系列按特定顺序排列的元素组成，在Python中，用方括号[]来表示列表，并用逗号来分隔其中的元素。
负数索引 Python中通过将索引指定为-1，可让Python返回最后一个列表元素，这种方式也适用于其他负数索引。例如，索引-2返回倒数第二个列表元素， 索引-3返回倒数第三个列表元素，以此类推。
增删改 在列表末尾添加元素使用append函数，如果要在指定位置插入元素可以使用insert函数。例如motorcycles.insert(0, &#39;ducati&#39;)是在索引0处添加元素。
motorcycles.append(&amp;#39;test&amp;#39;) motorcycles.insert(0, &amp;#39;ducati&amp;#39;) 如果知道要删除元素在列表中的位置，可以使用delete函数，例如del motorcycles[0]可以删除第一个元素。
如果想要删除元素并获取它的值可以使用pop函数。不带参数的pop()函数可删除列表末尾的元素，并能返回最后一个元素的值。如果要删除列表中国呢任何位置的元素，可以在括号中指定要删除元素的索引。
last_owned = motorcycles.pop() print(&amp;#34;The last motorcycle I owned was a &amp;#34; &#43; last_owned.title() &#43; &amp;#34;.&amp;#34;) first_owned = motorcycles.pop(0) print(&amp;#39;The first motorcycle I owned was a &amp;#39; &#43; first_owned.title() &#43; &amp;#39;.&amp;#39;) 如果不知道要删除元素在列表中的索引，可以使用remove函数，但是它只会删除第一个指定的值，如果要删除全部元素，需要借助for循环。
如果要改变列表的值，可以直接使用赋值的方法，如motorcycles[0] = &#39;test&#39;。方法sort永久性的修改了列表元素的顺序。如果想要临时排序可以使用sorted函数。方法reverse也是永久地修改列表元素的顺序。
组织列表 排序 函数sort会永久性地修改列表元素的排列顺序。如果要保留列表元素原来的排列顺序，同时以特定的顺序呈现它们，可以使用sorted函数。
lists = [&amp;#34;test&amp;#34;, &amp;#34;wan&amp;#34;, &amp;#34;deng&amp;#34;] print(sorted(lists, reverse=True)) 长度 函数len可以获取列表的长度。访问列表最后一个元素时，可以使用索引-1，但当列表为空时，这种访问最后一个元素的方式会导致错误。因此可以先使用函数len来确定列表长度。
range 使用函数range可以生成半开半闭区间的数字。例如range(1,5)等同于数学上的[1,5)。使用range函数时，也可以指定步长。可使用函数list()将range()的结果直接转换为列表。
for value in range(1,5):  print(value)  even_numbers = list(range(2,11,2)) print(even_numbers) 切片 如果要创建切片，就需要指定第一个元素和最后一个元素的索引区间。在切片中，索引区间也是半闭半开的。如果切片区间没有指定第一个索引，则默认从列表开头开始；类似的，如果切片区间没有指定最后一个元素的索引，则切片终止于列表末尾:
players = [&amp;#39;charles&amp;#39;, &amp;#39;martina&amp;#39;, &amp;#39;michael&amp;#39;, &amp;#39;florence&amp;#39;, &amp;#39;eli&amp;#39;] print(players[0:3]) //[&amp;#39;charles&amp;#39;, &amp;#39;martina&amp;#39;, &amp;#39;michael&amp;#39;] print(players[1:4]) //[&amp;#39;martina&amp;#39;, &amp;#39;michael&amp;#39;, &amp;#39;florence&amp;#39;] print(players[:3]) //[&amp;#39;charles&amp;#39;, &amp;#39;martina&amp;#39;, &amp;#39;michael&amp;#39;] print(players[2:]) //[&amp;#39;michael&amp;#39;, &amp;#39;florence&amp;#39;, &amp;#39;eli&amp;#39;] 负数索引返回离列表末尾相应距离的元素，因此可以输出列表末尾的任何切片。例如，要输出名单上的最后的三名队员，可以使用负数索引切片：
print(players[-3:]) //[&amp;#39;michael&amp;#39;, &amp;#39;florence&amp;#39;, &amp;#39;eli&amp;#39;] 遍历切片 若要遍历列表的部分元素，可以借助切片和循环，如下所示：
for player in players[-3:]:  print(player) 复制列表 如果要复制列表，可创建一个包含整个列表的切片，方法是同时省略开始索引和终止索引([:])。这让Python创建一个始于第一个元素，终止于最后一个元素的切片，即复制整个列表：
players = [&amp;#39;charles&amp;#39;, &amp;#39;martina&amp;#39;, &amp;#39;michael&amp;#39;, &amp;#39;florence&amp;#39;, &amp;#39;eli&amp;#39;] test_players = players[:] test_players.append(&amp;#34;test&amp;#34;)  print players //[&amp;#39;charles&amp;#39;, &amp;#39;martina&amp;#39;, &amp;#39;michael&amp;#39;, &amp;#39;florence&amp;#39;, &amp;#39;eli&amp;#39;] print test_players //[&amp;#39;charles&amp;#39;, &amp;#39;martina&amp;#39;, &amp;#39;michael&amp;#39;, &amp;#39;florence&amp;#39;, &amp;#39;eli&amp;#39;, &amp;#39;test&amp;#39;] 如果直接使用列表赋值，不能得到两个列表，而是两个变量指向同一个列表，如下所示：
players = [&amp;#39;charles&amp;#39;, &amp;#39;martina&amp;#39;, &amp;#39;michael&amp;#39;, &amp;#39;florence&amp;#39;, &amp;#39;eli&amp;#39;] mo_players = players mo_players.append(&amp;#34;name&amp;#34;) print players //[&amp;#39;charles&amp;#39;, &amp;#39;martina&amp;#39;, &amp;#39;michael&amp;#39;, &amp;#39;florence&amp;#39;, &amp;#39;eli&amp;#39;, &amp;#39;name&amp;#39;] print mo_players //[&amp;#39;charles&amp;#39;, &amp;#39;martina&amp;#39;, &amp;#39;michael&amp;#39;, &amp;#39;florence&amp;#39;, &amp;#39;eli&amp;#39;, &amp;#39;name&amp;#39;] 元组 列表适合用于存储在程序运行期间可能变化的数据集，对于不可变的数据集合，Python中称为元组，使用圆括号而不是方括号来标识。
dimensions = (200, 50) //dimensions[0] = 34 //编译报错 元组变量 虽然不能修改元组中元素的值，但可以给储存元组的变量赋值。因此，如果要修改元组的尺寸，可重新定义整个元组。
dimensions = (200, 50) dimensions = (300, 400, 100) //可以整体改变元组 if 在Python中，if语句包括单独的if语句，if-else语句、还有if-elif-else语句，但并不要求if-elif结构后面必须有else代码块。
字典 在Python中字典用花括号{}中的键值对表示。字典是一种动态结构，可随时在其中添加键值对，如果要添加键值对，可依次指定字典名，用方括号括起来的键值关联的值。
test_dict = {&amp;#34;key&amp;#34;: 12, &amp;#34;key1&amp;#34;: &amp;#34;test&amp;#34;} print test_dict[&amp;#34;key&amp;#34;] print test_dict[&amp;#34;key1&amp;#34;] test_dict[&amp;#34;key2&amp;#34;] = 23 print test_dict //{&amp;#39;key2&amp;#39;: 23, &amp;#39;key1&amp;#39;: &amp;#39;test&amp;#39;, &amp;#39;key&amp;#39;: 12} 删除键值对 对于字典中不需要的信息，可使用del语句将相应的键值对彻底删除。使用del语句时，必须指定字典名和要删除的键。
test_dict = {&amp;#34;key&amp;#34;: 12, &amp;#34;key1&amp;#34;: &amp;#34;test&amp;#34;} print test_dict[&amp;#34;key&amp;#34;] print test_dict[&amp;#34;key1&amp;#34;] test_dict[&amp;#34;key2&amp;#34;] = 23 print test_dict del test_dict[&amp;#34;key&amp;#34;] //{&amp;#39;key2&amp;#39;: 23, &amp;#39;key1&amp;#39;: &amp;#39;test&amp;#39;, &amp;#39;key&amp;#39;: 12} print test_dict //{&amp;#39;key2&amp;#39;: 23, &amp;#39;key1&amp;#39;: &amp;#39;test&amp;#39;} 遍历字典 对于字典，既可以只遍历键，也可以只遍历值，或者同时遍历键值对，如下所示：
for key in test_dict.keys():  print key  for value in test_dict.values():  print value  for key, value in test_dict.items():  print key, value  for key in sorted(test_dict.keys()):  print key 函数 在Python中，函数是使用def关键字定义的。调用函数时，可以使用位置实参，也可以使用关键字实参。一个函数全部使用关键字实参调用时，关键字的位置可以不按顺序来指定。
def print_message(msg):  print msg   print_message(&amp;#34;test&amp;#34;) print_message(msg=&amp;#34;hello&amp;#34;) 默认值 编写函数时，可以给每个形参指定默认值。在调用函数时如果没有给形参指定实参，则将使用默认参数。
def print_test(name=&amp;#39;ty&amp;#39;):  print name  print_test() //ty 返回值 在函数中，可以使用return语句将值返回到调用函数的代码行，既可以返回一个也可以返回一组值。函数可以返回任何类型的值，包括列表和字典等较复杂的数据结构：
def return_test(name):  return name   print(return_test(&amp;#34;Hello&amp;#34;)) //hello 列表参数 将列表传递给函数后，函数就可以对这个列表进行修改。在函数中对这个列表所做的任何修改都是永久性的「与C&#43;&#43;的指针参数相似」。如果需要禁止函数修改列表，则可向函数传递列表的副本，即切片[:]。
任意数量的实参 在下面定义的函数中，形参名中的*让Python创建一个名为toppings的空元组，并将收到的所有值都封装到这个元组（元素类型相同）中：
def make_pizza(*toppings):  print toppings  make_pizza(&amp;#39;test&amp;#39;, 12) # (&amp;#39;test&amp;#39;, 12) 如果要让函数接受不同类型的实参，必须在函数定义中将接受任意数量实参放在最后。python先匹配位置实参和关键字实参，再将余下的实参都收集到最后一个形参中。
def make_pizza(size, *toppings):  &amp;#34;&amp;#34;&amp;#34;概述要制作的比萨&amp;#34;&amp;#34;&amp;#34;  print(&amp;#34;\nMaking a &amp;#34; &#43; str(size) &#43; &amp;#34;-inch pizza with the following toppings:&amp;#34;)  for topping in toppings:  print(&amp;#34;- &amp;#34; &#43; topping)  make_pizza(16, &amp;#39;pepperoni&amp;#39;) make_pizza(12, &amp;#39;mushrooms&amp;#39;, &amp;#39;green peppers&amp;#39;, &amp;#39;extra cheese&amp;#39;) 有时候，需要接受任意数量不同类型实参，但预先不知道传递给函数的会是什么样的信息。在这种情况下，可将函数编写成能够接受任意数量的键值对——调用语句提供多少就接受多少。
def build_profile(first, last, **user_info):  &amp;#34;&amp;#34;&amp;#34;创建一个字典，其中包含我们知道的有关用户的一切&amp;#34;&amp;#34;&amp;#34;  profile = {}  profile[&amp;#39;first_name&amp;#39;]=first  profile[&amp;#39;last_name&amp;#39;] = last   for key, value in user_info.items():  profile[key] = value  return profile  user_profile = build_profile(&amp;#39;albert&amp;#39;, &amp;#39;einstein&amp;#39;, location=&amp;#39;princeton&amp;#39;, field=&amp;#39;physics&amp;#39;) print(user_profile) 导入函数 要让函数是可导入的，先得创建模块。模块是扩展名为.py的文件，包含要导入到程序中的代码。例如，现在有一个名为test.py的文件，如果要使用其中的函数，则在需要使用的文件中import test ，然后使用类似test.test()调用函数即可。
如果只需要导入特定的函数，则使用from module_name import func_name_0, function_1, function_2这种方式导入，这种方式导入函数之后则不需要加module前缀来调用了。
如果要导入的函数的名称可能和当前文件中函数冲突，则可以将函数指定别名from module_name import func_name as other_name。
如果要导入模块中的所有函数，则可以使用from module_name import *。
 </content>
    </entry>
    
     <entry>
        <title>Swift Tips</title>
        <url>https://iihui.github.io/post/swift-tips/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> 柯里化 柯里化(curry)：把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下参数而且返回结果的新函数。
func addTo(_ adder: Int) -&amp;gt; (Int) -&amp;gt; Int {  return { num in  return num &#43; adder  } }  let addTwo = addTo(2) // addTwo: Int -&amp;gt; Int let result = addTwo(6) // result = 8 柯⾥化是⼀种量产相似⽅法的好办法，可以通过柯⾥化⼀个⽅法模板来避免写出很多重复代码，也方便今后的维护：
func greaterThan(_ comparer: Int) -&amp;gt; (Int) -&amp;gt; Bool {  return { $0 &amp;gt; comparer } }  let greaterThan10 = greaterThan(10);  greaterThan10(13) // =&amp;gt; true greaterThan10(9) // =&amp;gt; false  target-action 在swift中selector只能使用字符串生成，这面临一个很严重的问题，就是难以重构，并且无法编译期间进行检查。但target-action⼜是 Cocoa中如此重要的⼀种设计模式，⽆论如何我们都想安全地使⽤的话，应该怎么办呢？⼀种可能的解决⽅式就是利⽤⽅法的柯⾥化。
protocol TargetAction {  func performAction() }  struct TargetActionWrapper&amp;lt;T: AnyObject&amp;gt;: TargetAction {  weak var target: T?  let action: (T) -&amp;gt; () -&amp;gt; ()   func performAction() -&amp;gt; () {  if let t = target {  action(t)()  }  } }  enum ControlEvent {  case TouchUpInside  case ValueChanged  // ... }  class Control {  var actions = [ControlEvent: TargetAction]()   func setTarget&amp;lt;T: AnyObject&amp;gt;(target: T, action: @escaping (T) -&amp;gt; () -&amp;gt; (), controlEvent: ControlEvent) {   actions[controlEvent] = TargetActionWrapper(target: target, action: action)  }   func removeTargetForControlEvent(controlEvent: ControlEvent) {  actions[controlEvent] = nil   }   func performActionForControlEvent(controlEvent: ControlEvent) {  actions[controlEvent]?.performAction()  }  } protocol Swift中的protocol不仅可以被class类型实现，也可以被struct和enum是实现。mutating关键字修饰方法是为了能在该方法中修改struct或是enum的变量，如果如果没在协议⽅法⾥写mutating的话，别⼈如果⽤struct或者enum来实现这个协议的话，就不能在⽅法⾥改变⾃⼰的变量了。因此，在定义协议时需要多考虑是否适用mutating来修饰方法。
public protocol Vehicle {  mutating func changeColor() } 在使用class来实现带有mutating的方法的协议时，具体实现的前面是不需要加mutating修饰的，因为class可以随意修改自己的成员变量。所以说在协议里mutating修饰方法，对于class的实现是完全透明，可以当作不存在的。
Sequence Swift中的for ... in可以用在所有实现了Sequence协议的类型上，而为了实现Sequence协议，首先需要实现IteratorProtocol协议。下面是一个反向迭代器的例子：
class ReverseIterator&amp;lt;T&amp;gt;: IteratorProtocol {   typealias Element = T  var array: [Element]  var currentIndex = 0   init(array: [Element]) {  self.array = array  self.currentIndex = array.count - 1  }   func next() -&amp;gt; Element? {  if currentIndex &amp;lt; 0 {  return nil  } else {  let element = array[currentIndex]  currentIndex -= 1  return element  }  } } 接着使用ReverseIterator迭代器来创建一个实现Sequence协议的反向ReverseSequence，代码如下：
struct ReverseSequence&amp;lt;T&amp;gt;: Sequence {  var array: [T]   init(array: [T]) {  self.array = array  }   typealias Iterator = ReverseIterator&amp;lt;T&amp;gt;   func makeIterator() -&amp;gt; ReverseIterator&amp;lt;T&amp;gt; {  return ReverseIterator(array: self.array)  }  }  func test() {  let arr = [0, 1, 2, 3, 4]  // 对 Sequence 可以使⽤ for...in 来循环访问  for i in ReverseSequence(array: arr) {  print(&amp;#34;Index \(i)is \(arr[i])&amp;#34;)  } } 多元组 在Swift中使用多元组可以轻松的交换两个值，而不需要额外的交换空间：
func swap&amp;lt;T&amp;gt;(a: inout T, b: inout T) {  (a,b) = (b,a) } autoclosure @autoclosure把一句表达式自动地封装成一个闭包closure。但是，@autoclosure并不支持带有输入参数的写法，也就是说只有形如()-&amp;gt;T的参数才能使用此特性进行简化。
func testAutoClosure(predicate:@autoclosure ()-&amp;gt;Bool) {  if predicate() {  print(&amp;#34;true&amp;#34;)  }else{  print(&amp;#34;false&amp;#34;)  } } testAutoClosure(predicate: 2&amp;gt;1) // true 在testAutoClosure(predicate: 2&amp;gt;1)中，Swift会把2&amp;gt;1这个表达式自动转换为() -&amp;gt; Bool。操作符??、&amp;amp;&amp;amp;、||也中用到了autoclosure：
public func ?? &amp;lt;T&amp;gt;(optional: T?, defaultValue: @autoclosure () throws -&amp;gt; T) rethrows -&amp;gt; T  public func ?? &amp;lt;T&amp;gt;(optional: T?, defaultValue: @autoclosure () throws -&amp;gt; T?) rethrows -&amp;gt; T?  public static func &amp;amp;&amp;amp; (lhs: Bool, rhs: @autoclosure () throws -&amp;gt; Bool) rethrows -&amp;gt; Bool  public static func || (lhs: Bool, rhs: @autoclosure () throws -&amp;gt; Bool) rethrows -&amp;gt; Bool @escaping 接受@escaping的闭包，因为要确保闭包内的成员依然有效，如果闭包内引出了self及其成员的话，Swift将强制明确的写出self。
如果在协议或者父类中定义了一个接受@escaping为参数的方法，那么在实现协议和类型或者是这个父类的子类，对应的方法也必须声明为@escaping，否则两个方法会被认为拥有不同的函数签名。
Optional Chaining Optional Chaining随时都可能返回nil的，所以使用Optional Chaining所得到的东西其实都是Optional。
typealias typealias是用来为已经存在的类型重新定义名字的，通过重命名，可以使代码变得更清晰。使用typealias关键字就像使用普通的赋值语句一样，可以将某个已经存在的类型赋值为新名字。
typealias Location = CGPoint typealias Distance = Double  func distance(from location: Location, to anotherLocation: Location) -&amp;gt; Distance {  let dx = Distance(location.x - anotherLocation.x)  let dy = Distance(location.y - anotherLocation.y)  return sqrt(dx * dx &#43; dy * dy) }  let origin: Location = Location(x: 0, y: 0) let point: Location = Location(x: 1, y: 1)  let d: Distance = distance(from: origin, to: point) 在涉及到泛型时，情况就稍微不太⼀样。⾸先，typealias是单⼀的，也就是说你必须指定将某个特定的类型通过typealias赋值为新名字，⽽不能将整个泛型类型进⾏重命名。下⾯这样的命名都是⽆法通过编译的。
class Person&amp;lt;T&amp;gt; {} typealias Worker = Person typealias Worker = Person&amp;lt;T&amp;gt; 在别名中也引入泛型，是可以的：
// This is OK typealias Worker&amp;lt;T&amp;gt; = Person&amp;lt;T&amp;gt; 当泛型类型确定性得到保证后，显然别名也是可以使用的：
class Person&amp;lt;T&amp;gt; {} typealias WorkId = String typealias Worker = Person&amp;lt;WorkId&amp;gt; 另⼀个使⽤场景是某个类型同时实现多个协议的组合时。我们可以使⽤ 后给它们⼀个新的更符合上下⽂的名字，来增强代码可读性：
protocol Cat { ... } protocol Dog { ... } typealias Pat = Cat &amp;amp; Dog 初始化方法顺序 Swift的初始化方法需要保证类型的所有属性都被初始化，因此在子类中，需要保证当前子类实例的成员初始化完成后才能调用父类的初始化方法。
class Cat {  var name: String  init() {  name = &amp;#34;cat&amp;#34;  } }  class Tiger: Cat {  let power: Int  override init() {  power = 10. //先初始化子类的成员变量  super.init() //再初始化父类的成员  name = &amp;#34;tiger&amp;#34; //最后修改父类的成员变量  } } 一般来说，子类的初始化顺序分为以下三步：
 设置子类自己需要初始化的参数power=10 调用父类相应的初始化方法super.init 对父类中需要改变的成员进行设定name=tiger  其中第三步是根据具体情况决定的，如果子类中不需要对父类的成员做出改变的话，就不存在第三步。在这种情况下，Swift会自动对父类的init方法进行调用，也就是说第二步的super.init也是可以不写：
class Cat {  var name: String  init() {  name = &amp;#34;cat&amp;#34;  } }  class Tiger: Cat {  let power: Int  override init() {  power = 10  }  } default参数 在Swift中默认参数限制较少，可以不放在最后，如下所示，两种写法都是可以的：
func sayHello1(str1: String = &amp;#34;Hello&amp;#34;, str2: String, str3: String) {  print(str1 &#43; str2 &#43; str3) }  func sayHello2(str1: String, str2: String, str3: String = &amp;#34;World&amp;#34;) {  print(str1 &#43; str2 &#43; str3) }  可变参数 在Swift中写一个可变参数只需要在声明参数时在类型后面加上...就可以了。其他语言因为编译器和语言自身语法限制，在使用可变参数时，往往可变参数只能作为方法中最后一个参数来使用。而不能先声明一个可变参数。
fun sum(input:Int ...) -&amp;gt; Int {  return input.reduce(0,&#43;) } 正则表达式 Swift还没有在语言层面上支持正则表达式，在Cocoa中使用NSRegularExpression来做正则表达，所以在Swift中可以对其进行封装：
struct RegexHelper {  let regex: NSRegularExpression   init(_ pattern: String) throws {  try regex = NSRegularExpression(pattern: pattern, options: .caseInsensitive)  }   func match(_ input: String) -&amp;gt; Bool {  let matches = regex.matches(in: input, options: [], range: NSMakeRange(0, input.utf16.count))   return matches.count &amp;gt; 0  }  } let mailPattern = &amp;#34;^([a-z0-9_\\.-]&#43;)@([\\da-z\\.-]&#43;)\\.([a-z\\.]{2,6})$&amp;#34; let matcher: RegexHelper do {  matcher = try RegexHelper(mailPattern)  let maybeMailAddress = &amp;#34;onev@onevcat.com&amp;#34;  if matcher.match(maybeMailAddress) {  print(&amp;#34;有效的邮箱地址&amp;#34;)  } }catch {  print(error.localizedDescription) } 接着封装=～运算符，就可以像其他语言一样使用正则表达式了：
precedencegroup MatchPrecedence {  associativity: none higherThan: DefaultPrecedence }  infix operator =~: MatchPrecedence  func =~(lhs: String, rhs: String) -&amp;gt; Bool {  do {  return try RegexHelper(rhs).match(lhs)  } catch {  print(error.localizedDescription)  return false  } }  if &amp;#34;xxx@test.com&amp;#34; =~ &amp;#34;^([a-z0-9_\\.-]&#43;)@([\\da-z\\.-]&#43;)\\.([a-z\\.]{2,6})$&amp;#34; {  print(&amp;#34;有效的邮箱地址&amp;#34;) } 模式匹配 Swift中没有内置正则表达式，但是有一个和正则表达式类似的特性——模式匹配。从概念上来说，正则匹配只是模式匹配的一个子集。
协议和类方法中的Self 在定义一些协议时，首字母大写的Self出现在类型的位置上。在下面IntervalType协议中，定义了一个方法，接受实现该协议的自身类型，并返回一个同样的类型：
protocol IntervalType {  /// Return `rhs` clamped to `self`. The bounds of the result, even   /// if it is empty, are always within the bounds of `self`  func clamp(intervalToClamp: Self) -&amp;gt; Self } 这么定义是因为协议本身没有自己的上下文类型的信息，在声明协议的时候，我们并不知道最后究竟会是什么样的类型来实现这个协议。
Reflection 和 Mirror  反射是一种在运行时检测、访问或者修改类型的行为特性。一般的静态语言类型的结构和方法的调用等都需要在编译时决定。
 Selector @selector是OC时代的一个关键词，可以将一个方法转换并赋值给一个SEL类型，它的表现类似一个动态的函数指针。
-(void) callMe { //...  }  -(void) callMeWithParam:(id)obj { //...  }  SEL someMethod = @selector(callMe); SEL anotherMethod = @selector(callMeWithParam:);  // 或者也可以使⽤ NSSelectorFromString  // SEL someMethod = NSSelectorFromString(@&amp;#34;callMe&amp;#34;);  // SEL anotherMethod = NSSelectorFromString(@&amp;#34;callMeWithParam:&amp;#34;); 在Swift中没有@selector了，取而代之是从#selector来暴露给OC的代码中获取一个selector。
@objc func callMe() { //... }  @objc func callMeWithParam(obj: AnyObject!) { //... }  let someMethod = #selector(callMe) let anotherMethod = #selector(callMeWithParam(obj:)) selector其实是OC运行的概念，在Swift 4中，默认情况下所有的Swift方法在OC中是不可见的，所以需要在这类方法加上@objc关键字，将这个方法暴露给OC，才能进行使用。
编译标记 可以使用Mark:这样的标记，Xcode将在代码中寻找这样的标记，然后以粗体标签的形式将名称显示在导航栏中。还可以在冒号的后⾯加⼀个横杠Mark:-分隔开各个部分，会显得更加清晰：
as as是在编译期间执行的，as?和as!是在运行时执行的。执行下面的代码会崩溃，是因为as?和as!是在运行时执行，运行时4已经先赋值为Int类型，然后强制转换为Double时必然失败，所以会产生崩溃。
print(4 as Double) // print 4.0 print(4 as! Double) // crash  </content>
    </entry>
    
     <entry>
        <title>Kotlin基础</title>
        <url>https://iihui.github.io/post/kotlin-base/</url>
        <categories>
          <category>kotlin</category>
        </categories>
        <tags>
          <tag>kotlin</tag>
        </tags>
        <content type="html"> 变量和函数 常量 Kotlin中使用val来声明常量「val是value的缩写」，val声明的常量不可以再重新赋值，否则会报错。val对应Java中的final。
val str = &amp;#34;Hello world&amp;#34; 变量 Kotlin中使用var来声明变量「var是variable的缩写」，var声明的变量可以重新赋值。var声明的变量对应Java中的final变量。
var test = &amp;#34;ch&amp;#34; println(test) test = &amp;#34;ccc&amp;#34; println(test) 函数 在Kotlin中fun用于定义函数，例如fun methodName(param1:Int, param2:Int):Int定义一个名为methodName，接受两个Int类型的参数，返回Int的函数。
fun largeNumber1(param1:Int,param2:Int):Int {  return max(param1,param2) }  fun largeNumber2(param1:Int,param2:Int):Int = max(param1,param2)  fun largeNumber3(param1:Int,param2:Int) = max(param1,param2) 条件语句 if语句 Kotlin中的if相比于Java中有一个额外功能，它是可以有返回值的，返回值是if语句每一个条件中最后一行代码的返回值。
fun largeNumber4(num1: Int, num2: Int): Int {  val value = if (num1 &amp;gt; num2) {  num1  } else {  num2  }  return value } fun largeNumber5(num1: Int, num2: Int): Int {  return if (num1 &amp;gt; num2) {  num1  } else {  num2  } } fun largeNumber6(num1: Int, num2: Int): Int = if (num1 &amp;gt; num2) {  num1 } else {  num2 } // 自动推断类型 fun largerNumber7(num1: Int, num2: Int) = if (num1 &amp;gt; num2) {  num1 } else {  num2 } when Kotlin不包含三元运算符，更加倾向于使用条件表达式，随着if-else的复杂性增加，可以使用when表达式。Kotlin中的when表达式中每个分支由一个条件，一个箭头和一个结果表示，如果箭头左侧的条件求值为true，则会返回右侧表达式的值。
传入参数 标准的when语句使用是传入参数。when语句和if语句一样，也是可以有返回值，因此依然可以使用单行代码函数语法糖。
fun checkNumber(num: Number) {  when (num) {  is Int -&amp;gt; println(&amp;#34;number is Int&amp;#34;)  is Double -&amp;gt; println(&amp;#34;number is Double&amp;#34;)  else -&amp;gt; println(&amp;#34;number not support&amp;#34;)  } } when {  count == 43 -&amp;gt; println(&amp;#34;43&amp;#34;)  tt == &amp;#34;name&amp;#34; -&amp;gt; println(&amp;#34;name&amp;#34;)  str1 == &amp;#34;test&amp;#34; -&amp;gt; println(str1) } val count = 43 var str1 = when (count) {  42 -&amp;gt; &amp;#34;42&amp;#34;  56 -&amp;gt; &amp;#34;56&amp;#34;  else -&amp;gt; &amp;#34;else&amp;#34; } fun getValue(colorEnum: ColorEnum) =  when(colorEnum){  ColorEnum.RED -&amp;gt; 1;  ColorEnum.BLUE -&amp;gt; 2;  ColorEnum.GREEN -&amp;gt; 3;  } 不传参数 可以不在when语句中传入参数。这种用法是将判断的表达式完整地写在when结构体中，对于其他的一些情况很有用，如下所示：
fun getScore1(name: String) = when {  name == &amp;#34;A&amp;#34; -&amp;gt; 1  name == &amp;#34;B&amp;#34; -&amp;gt; 2  name == &amp;#34;C&amp;#34; -&amp;gt; 3  else -&amp;gt; -1 }  fun getScore2(name: String) = when {  name.startsWith(&amp;#34;test&amp;#34;) -&amp;gt; 89  name == &amp;#34;M&amp;#34; -&amp;gt; 90  else -&amp;gt; 4589 } 循环语句 Kotlin在for在循环方面做了很大幅度的修改，直接舍弃了Java中的for-i，而在Java中的另一种for-each循环则被Kotlin进行大幅度的加强，变成了for-in循环。
区间 Kotlin中的区间有左闭右闭，左闭右开。左右双闭区间使用..来定义，而左闭右开使用until来定义。这两个关键字定义的区间都必须左端小于右端区间，也就是这两种关键字创建的都是升序区间。
升序区间 fun forTest1() {  for (i in 0..100) {  println(i)  } }  fun forTest2() {  for (i in 0 until 100) {  println(i)  } } 由..和until定义的升序区间，默认步长都是1，如果想要更改步长就需要使用step关键字，如下所示：
fun forTest3() {  for (i in 0..100 step 6) {  println(i)  } }  fun forTest4() {  for (i in 0 until 100 step 6) {  println(i)  } } 降序区间 如果要使用降序区间，需要使用downTo关键字，由downTo定义的区间是也是左闭右闭的，也可以使用step关键字设置步长。
fun forTest5() {  for (i in 10 downTo 1) {  println(i)  } }  fun forTest6() {  for (i in 10 downTo 1 step 4) {  println(i)  } } 类与对象 在Kotlin中任何一个非抽象类默认都是不可以被继承的，相当于Java中给类声明了final关键字。如果要想一个非抽象类可以被继承，就要在其前添加open关键字。
构造函数 主构造函数 构造函数分为了两种，一种是主构造函数，另一种是次构造函数。每个类默认都会有一个不带参数的主构造函数。主构造函数的特点是没有函数体，直接定义在类名的后面即可：
open class Person {  var name = &amp;#34;&amp;#34;  var age = 0  fun eat() {  println(name &#43; &amp;#34; is eating. He is &amp;#34; &#43; age &#43; &amp;#34;years old.&amp;#34;)  } }  class Student : Person() {  var sno = &amp;#34;&amp;#34;  var grade = 0   init {  println(sno)  println(grade)  } } 主构造函数没有函数体，如果想要在主构造函数中编写一些逻辑，则可以写在init结构体中。主构造函数声明为val或者var的参数将自动成为该类的字段。
open class Person(val name: String, val age: Int) {  // }  class Student(val sno: String, val grade: Int, name: String, age: Int) : Person(name, age) {  // } 次构造函数 任何一个类只能(至多)有一个主构造函数，但是可以有多个次构造函数。次构造函数也可以用于实例化一个类。次构造函数是通过constructor关键字来定义，次构造函数是有函数体的，可以通过this关键字来调用主构造函数。
class Student(val sno: String, val grade: Int, name: String, age: Int) : Person(name, age) {  constructor(name: String, age: Int) : this(&amp;#34;&amp;#34;, 0, name, age) {  //  }   constructor() : this(&amp;#34;&amp;#34;, 0) {  //  } } 当一个类没有显式地定义主构造函数且定义了次构造函数时，它就是没有主构造函数的。因为没有主构造函数，次构造函数只能直接调用父类的构造函数：
class Student : Person {  constructor(name: String, age: Int) : super(name, age) } 接口 在Java中，任何一个类最多只能继承一个父类，但可以实现任意多接口，Kotlin也是。Java中继承使用的关键字为extends，实现接口使用的关键字为implements，而Kotlin中统一使用冒号，中间用逗号进行分隔。Kotlin中使用override关键字来重写父类或者实现接口中的函数。
interface Study {  fun readBooks()  fun doHomework() }  class Student(val sno: String, val grade: Int, name: String, age: Int) : Person(name, age), Study {  constructor(name: String, age: Int) : this(&amp;#34;&amp;#34;, 0, name, age) {  //  }   constructor() : this(&amp;#34;&amp;#34;, 0) {  //  }   override fun readBooks() {  println(&amp;#34;$nameis reading&amp;#34;)  }   override fun doHomework() {  println(&amp;#34;$nameis doing homework.&amp;#34;)  } } 参考
exception is java.lang.IllegalArgumentException: Could not resolve placeholder &amp;#39;NEW_MYSQL_URL&amp;#39; in value &amp;#34;${NEW_MYSQL_URL}&amp;#34; </content>
    </entry>
    
     <entry>
        <title>使用charles</title>
        <url>https://iihui.github.io/post/tool-charles/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  charles是一款用于iOS抓包的工具，可以将它设置成网络访问的代理服务器，使得所有网络访问请求都通过它来完成，从而实现网络封包的截取和分析，以作为网络访问的监视器。当App连接charles代理访问互联网时，charles可以监控这个App发送和接收的所有数据，这些信息包括request,response和headers（包含cookies与caching）。
 安装证书 首先打开charles，然后点击菜单栏的Help，选择SSL Proxing，接着选中Install Charles Root Certificate on a Mobile Device or Remote Browser，步骤如下图所示：
然后会出现如下图提示：
根据提示，应该先在手机上设置代理(代理中的服务器IP地址和端口具体值要根据Charles相应的提示进行设置)，步骤如下所示：
打开Safari浏览器，输入chls.pro/ssl，点击前往，然后弹出下载描述文件的界面，点击允许，下载好之后打开设置，在头像下面会出现已下载描述文件：
点击已下载描述文件选项，会弹出下面安装界面，点击右上角安装按钮，接着会有警告，再次点击弹出的安装按钮即可，步骤如下图所示：
如果手机上设置代理之后或者在浏览器中输入chls.pro/ssl之后，若Mac OS上弹出如下所示的提示框，则需要点击Allow按钮：
https抓包 安装好描述文件之后，就可以抓包，默认http的请求都可以直接查看，但https的请求不能直接查看，需要额外设置。有两种方式设置，第一种是直接在SSL Proxying Settings中设置，另外一种是在请求地址目录上选中然后右键设置Enable SSL Proxying。
第一种 打开charles，在菜单栏中选中Proxy，再选中SSL Proxying Settings，如下图所示：
然后出现如下界面，点击Add按钮，把需要抓包的https请求地址加上：
第二种 第二种方式，是在带锁的https地址上右键，选中Enable SSL Proxying，然后下次有同样的请求就可以到请求的具体内容了，如下图所示：
下图一带锁的标志表示不能查看的https请求，需要设置Enable SSL Proxying之后才能查看，下图二设置之后的，蓝色表示可以查看具体的请求信息：
额外设置 如果抓包之后不能看到具体资源的名称，则需要到设置--&amp;gt;通用--&amp;gt;关于本机--证书信任设置查看Charles Proxy CA ...是否信任，如果尚未信任，打开即可：
参考资料
</content>
    </entry>
    
     <entry>
        <title>刘海屏适配</title>
        <url>https://iihui.github.io/post/ios-layout/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  自从苹果推出刘海屏之后，App开发就要做相应的适配，适配过程通常会用到topLayoutGuide和bottomLayoutGuide或者safeAreaLayoutGuide。topLayoutGuide和bottomLayoutGuide是UIViewController的两个与view同级的只读属性。这两个属性是iOS 7.0引入的，而在iOS 11.0开始废弃。而safeAreaLayoutGuide是iOS 11.0之后才引入的，属于UIViewController中view的一个属性。
 topLayoutGuide  topLayoutGuide区分界面是否有导航栏。若没有导航栏，topLayoutGuide的顶部与状态栏顶部对齐，底部与状态栏的底部对齐。若有导航栏，topLayoutGuide的顶部与状态栏顶部对齐，底部与导航栏的底部对齐。
 private func topLayoutGuideTest(){  let view = UIView()  view.backgroundColor = .red  self.view.addSubview(view)  view.snp.makeConstraints(){ maker in  maker.leading.equalToSuperview()  maker.trailing.equalToSuperview()  maker.top.equalTo(self.topLayoutGuide.snp.top)  maker.bottom.equalTo(self.topLayoutGuide.snp.bottom)  } } 上面的代码对于根据是否有导航栏，表现是不同的。如下图一表示没有导航栏，图二表示有导航栏。
无导航栏 有导航栏 bottomLayoutGuide  bottomLayoutGuide要区分有没有是否刘海屏。对于刘海屏bottomLayoutGuide底部与手机屏幕底部对其，bottomLayoutGuide的顶部与底部圆角的顶部对齐；对于非刘海屏，bottomLayoutGuide的顶部和底部与都与屏幕底部对齐。
 private func bottomLayoutGuideTest(){  let view = UIView()  view.backgroundColor = .red  self.view.addSubview(view)  view.snp.makeConstraints(){ maker in  maker.leading.equalToSuperview()  maker.trailing.equalToSuperview()  maker.top.equalTo(self.bottomLayoutGuide.snp.top)  maker.bottom.equalTo(self.bottomLayoutGuide.snp.bottom)  } } private func bottomLayoutGuideTest(){  let view = UIView()  view.backgroundColor = .red  self.view.addSubview(view)  view.snp.makeConstraints(){ maker in  maker.leading.equalToSuperview()  maker.trailing.equalToSuperview()  maker.bottom.equalTo(self.bottomLayoutGuide.snp.top)  maker.height.equalTo(20)  } } self.view.addSubview(self.performanceView) self.performanceView.snp.makeConstraints { maker in  if #available(iOS 11.0, *) {  maker.trailing.equalTo(self.view.safeAreaLayoutGuide.snp.trailing).inset(20)  maker.bottom.equalTo(self.view.safeAreaLayoutGuide.snp.bottom).inset(15)  } else {  maker.trailing.equalToSuperview().inset(20)  maker.bottom.equalTo(self.bottomLayoutGuide.snp.top).inset(-15)  }  maker.width.equalTo(200)  maker.height.equalTo(40) }  safeAreaLayoutGuide  iOS 11.0之后引入了safe area，它用于定义视图的安全可视区域，可以保证在safe area区域内的子view不会被遮挡。UIKit定义的navigation controller、tabbar controller会展示一个顶部的导航栏或者底部的tabbar，也会遮挡一部分 child view controller的视图。safe area描述当前view不被父Controller的控件挡住的区域。
 private func safeAreaTest(){  let view = UIView(frame: .zero)  view.backgroundColor = .red  self.view.addSubview(view)  view.snp.makeConstraints(){ maker in  maker.leading.equalTo(self.view.safeAreaLayoutGuide.snp.leading)  maker.trailing.equalTo(self.view.safeAreaLayoutGuide.snp.trailing)  maker.top.equalTo(self.view.safeAreaLayoutGuide.snp.top)  maker.bottom.equalTo(self.view.safeAreaLayoutGuide.snp.bottom)  } } 底部适配 这两天在做一个选择器时需要在底部加两个按钮，这涉及到刘海屏的适配问题，可以在storyBoard中通过约束来实现适配，如下图所示：
也可以通过safeAreaLayoutGuide或者bottomLayoutGuide达到适配的目的，代码如下所示：
safeAreaLayoutGuide private func setupUI(){  let view = UIView()  view.backgroundColor = .red  self.view.addSubview(view)  view.snp.makeConstraints(){ maker in  maker.bottom.equalToSuperview()  maker.top.equalTo(self.view.safeAreaLayoutGuide.snp.bottom).inset(60)  maker.leading.equalToSuperview()  maker.trailing.equalToSuperview()  } } bottomLayoutGuide private func setupUI(){  let view = UIView()  view.backgroundColor = .red  self.view.addSubview(view)  view.snp.makeConstraints(){ maker in  maker.top.equalTo(self.bottomLayoutGuide.snp.top .inset(-60)  maker.bottom.equalToSuperview()  maker.leading.equalToSuperview()  maker.trailing.equalToSuperview()  } } 顶部适配 同样顶部的适配可以使用safeAreaLayoutGuide或者bottomLayoutGuide达到目的，代码如下所示：
safeAreaLayoutGuide private func setupUI2() {  let topView = UIView()  topView.backgroundColor = .blue   self.view.addSubview(topView)  topView.snp.makeConstraints { maker in  maker.leading.equalToSuperview()  maker.trailing.equalToSuperview()  maker.top.equalToSuperview()  maker.bottom.equalTo(self.view.safeAreaLayoutGuide.snp.top).inset(60)  } } topLayoutGuide private func setupUI3() {  let topView = UIView()  topView.backgroundColor = .blue   self.view.addSubview(topView)  topView.snp.makeConstraints { maker in  maker.leading.equalToSuperview()  maker.trailing.equalToSuperview()  maker.top.equalToSuperview()  maker.bottom.equalTo(self.topLayoutGuide.snp.bottom).inset(-60)  } } 参考资料
</content>
    </entry>
    
     <entry>
        <title>UITabBarController</title>
        <url>https://iihui.github.io/post/ios-uitabbar/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> 添加Tab 既可以直接添加UITabBarController到storyboard中，也可以在现有的ViewController中添加UITabBarController。
直接添加 如下图所示，在Xcode 12右上角点击&#43;号，然后输入Tab，在出现的提示中选中Tab Bar Controller，拖到storyboard，然后松开即可添加：
已有中添加 在已有的ViewController之前添加Tab Bar Controller，有两种方式。第一种是在storyboard编辑界面的右下角的Embed In中添加；另一种是在菜单栏的Editor下添加。
Storyboard编辑界面右下角 如下图所示，在storyboard中先选择已有的ViewController，如下图标号1所示，先选中左边第一个按钮，然后在标号2处点击，选中Tab Bar Controller:
添加Navigation 菜单栏Editor下 除了在storyboard右下角添加，也可以在菜单栏中添加。如下图所示，首先选中已有的ViewController，然后在菜单栏上选择Editor --&amp;gt; Embed In --&amp;gt; Tab Bar Controller:
双击检测 private let intervalThreshold: Double = 0.8 private var dkLastClickedDate: Date? = nil private var ePaperLastClickedDate: Date? = nil func tabBarController(_ tabBarController: UITabBarController, shouldSelect viewController: UIViewController) -&amp;gt; Bool {  if tabBarController.selectedIndex == 1,let nav = tabBarController.selectedViewController as? UINavigationController,let vc:NewsViewController = nav.visibleViewController  let date = Date()  switch vc.segmentedView.selectedIndex {  case 0:  if let lastDate = self.ePaperLastClickedDate, (date.timeIntervalSince1970 - lastDate.timeIntervalSince1970) &amp;lt; intervalThreshold {  NotificationCenter.default.post(name: .ePaperScrollToTopNotification, object: nil)  }  self.ePaperLastClickedDate = date  case 1:  if let lastDate = self.dkLastClickedDate, (date.timeIntervalSince1970 - lastDate.timeIntervalSince1970) &amp;lt; intervalThreshold {  NotificationCenter.default.post(name: .dkScrollToTopNotification, object: nil)  }  self.dkLastClickedDate = date  default:  break  }  }  return true } </content>
    </entry>
    
     <entry>
        <title>Go枚举</title>
        <url>https://iihui.github.io/post/go-iota/</url>
        <categories>
          <category>go</category>
        </categories>
        <tags>
          <tag>go</tag>
        </tags>
        <content type="html">  Go中没明确意义上的enum定义，但是可以借助iota来生成一组自增常量值来实现枚举，iota是一个比较奇怪的存在，它只能用在const的声明中，是一个从0开始的行数索引器。
 iota 按行递增 首先，iota是一个行数索引器,它是按行递增的。
const ( 	x1 = iota //x1=0 	x2 //x2=1 	x3 //x3=2 	x4 //x4=3 )  fmt.Println(x1, x2, x3, x4) //0 1 2 3 const ( 	_, _ = iota, iota * 10 //0 0*10 	a, b //1 1*10 	c, d //2 2*10 ) const ( 	_ = iota //iota 代表0 	KB = 1 &amp;lt;&amp;lt; (10 * iota) //iota 代表1 	MB //iota 代表2 	GB ) println(KB,MB,GB) //1024 1048576 1073741824  iota恢复 如果中断iota自增，则必须显式恢复，且后续自增按行序递增，而不是C&#43;&#43;语言中的enum那样按上一个取值递增。
const ( 	a = iota 	b // 1 	c = 100 // 中断iota的计数 	d // 100 	e = iota // 4，显式恢复，因为是行增，所以得到是4 	f // 5 ) fmt.Println(a, b, c, d, e, f) //0 1 100 100 4 5  多个iota 可在多常量中定义中使用多个iota，他们是各自单独计数，只须确保组中每行常量的列数量相同即可。
const ( 	_, _ = iota, iota 	a, b 	c, d ) fmt.Println(a, b, c, d) // 1 1 2 2 const中的iota自增默认数据类型是int，但也可显式指定类型。
const ( 	x = iota 	y float32 = iota //指定类型 	z = iota ) fmt.Println(x, y, z) //0 1 2  </content>
    </entry>
    
     <entry>
        <title>Go常量</title>
        <url>https://iihui.github.io/post/go-let/</url>
        <categories>
          <category>go</category>
        </categories>
        <tags>
          <tag>go</tag>
        </tags>
        <content type="html">  常量值必须是编译期间可确定的字符、字符串、数字或者布尔值。常量的类型可以指定，或者由编译器通过初始化值推断，不支持C或者C&#43;&#43;数字类型后缀。可在函数代码块中定义常量，不使用的常量不会引发编译错误。
 const x, y int = 12, 0x12 const s = &amp;#34;hello world&amp;#34; const c = &amp;#39;我&amp;#39; const ( 	i, f = 1, 0.123 	b = false ) 显式转换 在定义常量时，如果显式指定类型，必须确保常量左右值类型一致，需要时可做显式转换。右值不能超出常量类型的取值范围，否则会引发溢出错误。
const ( 	x, y int = 99, -999 	b byte = byte(x) //x是int类型必须显式转换为byte 	n = uint8(y) //转换溢出，会报错 ) 常量值也可以是某些编译器能够计算出结果的表达式，如unsafe.SizeOf,len,cap等。
const ( 	ptrSize = unsafe.Sizeof(uintptr(0)) 	strSize = len(&amp;#34;hello world&amp;#34;) ) 在常量组中如果不指定类型和初始值，则与上一行非空常量右值（表达式文本）相同。
const ( 	x uint16 = 120 	y 	s = &amp;#34;abc&amp;#34; 	z ) println(x, y, s, z) // 120 120 abc abc 没有地址 数字常量不会分配存储空间，无须像变量那样通过内存寻址来取值，因此无法获取地址，如下所示：
var x = 0x100 const y = 0x200 println(&amp;amp;x, x) println(&amp;amp;y, y) //cannot take the address of y  </content>
    </entry>
    
     <entry>
        <title>Go变量</title>
        <url>https://iihui.github.io/post/go-var/</url>
        <categories>
          <category>go</category>
        </categories>
        <tags>
          <tag>go</tag>
        </tags>
        <content type="html"> Go中每一个文件都以package声明开头，表明文件属于哪一个包。package声明后面是import声明，然后是不区分顺序的包级别的类型，变量、常量和函数的声明。对于包级别的声明不仅对于包含其声明的源文件可见，而且对于同一包里面的所有的源文件可见。
变量命名   以字母（这里指的是广义字母，只要能够被unicode编码即可）或下划线开始，由多个字母，数字下划线组合而成。尽管Go支持使用汉字等unicode字符命名，但从编程习惯上来说，这并不是最好的选择。
  在Go中变量的标识符是区分大小写。
  变量名首字母大小写决定了其作用域，首字母大写的为导出成员，可被外部不同的包使用，而小写仅能在包内使用。
  对变量标识符习惯上使用驼峰命名法。
  习惯上Go对专有名词通常会全部大写（这样一来这个专有名词就是可导出的了）。
  有一个名为_的特殊成员（称为空占位符），通常作为忽略占位符使用，可以用作表达式左值，但无法读取内容，即空标识符只写不读。
  空标识符可用来临时规避编译器对未使用变量和导入包的错误检查，但是它是预置成员，不能重新定义。 导入包时使用空标识符的目的是为了使用包中初始化函数以进行初始化，而一般的变量定义中使用空标识符是为了舍弃错误的处理（一般不建议这么做，因为出现错误时应当进行相应的处理）。
y,_ := strconv.Atoi(&amp;#34;12&amp;#34;) println(y)    变量声明 变量的声明方式有3种：①使用var关键字声明变量； ②使用简短模式； ③使用new函数来声明变量。
使用var定义变量 Go是一种静态类型语言，所以变量总需要有确定的类型，类型决定了变量的内存长度和存储格式。
var声明一个具体类型的变量，然后给它附加一个名字，设置它的初始值，每一个声明有一个通用的形式：
var name type = expression 这里的类型和表达式可以省略一个，但是不能全部省略。如果类型省略，那么变量的类型由表达式决定；如果表达式省略，则变量的初始值对应其类型零值。
var x int var y = false println(x,y) 运行时内存分配操作会确保变量自动初始化为二进制零值(zero value)。类型零值：对于数字是0，对于布尔型是false，对于字符串是“”，对于接口和引用类型（slice，指针，map，通道，函数）是nil。而对于数组，结构体这样的复合类型，零值是其所有元素或成员的零值。
  使用var定义变量，类型放在变量名后面var x int。这样的好处是定义多个指针变量时，不必每次都声明是指针变量。
  使用var进行变量定义的时候，可以使用初始值。使用初始值时，可以省略类型，Go会自动进行类型推导，例如var x = 12 此时x的类型被推导为int。
  同样可以一次可以定义多个变量，使用逗号隔开:  var x,y int。
  可以使用成组的方式定义个多个或多种变量，即使用一个var关键词定义多种类型的变量：
var (  y int  s = 100, &amp;#34;abc&amp;#34; //这一行两个变量，并且类型不相同 ) fmt.Println(x, y, a, s) //0 0 100 abc   赋值操作必须确保左右值类型相同，（有3种情况例外，详见基本类型中的类型转换规则）如果等式两边的类型不同则会出现编译错误。
  编译器将未使用「重新赋值不算做使用」的局部变量当作错误处理。全局定义的变量如果未使用，编译器不会报错；局部定义的变量一定要使用，并且重新赋值不算是使用。也就是说局部变量必须被读一次，编译器才不会报错。
  编译器确保变量总是被初始化类型0值，在函数内部还可以使用简略形式来定义变量。
var s = &amp;#34;hello world&amp;#34; // 使用类型推导，编译器将s的类型推导为string y := make([]int, 0, 5) //函数内部省略 var 关键字，更简单的模式 fmt.Println(y) //y是切片类型 for i := 0; i &amp;lt; 10; i&#43;&#43; {  y = append(y, i) //追加后重新赋值  } fmt.Println(y) //[0 1 2 3 4 5 6 7 8 9]   在Go中，var声明通常是为那些与初始化表达式类型不一致的局部变量保留的，或者用于后面才对变量赋值以及变量初始值不重要的情况。
   简短模式定义变量 还可以使用例如 x := 100这样的简短模式声明变量,但是简短模式具有以下限制：
  必须使用显式初始化。
  简短模式不能提供数据类型，Go会按照进行类型推导。
  只能在函数内部使用简短模式。
  简短模式并不总是变量定义，也可能是部分退化的赋值操作，退化赋值的前提是：至少有一个新变量被定义，且必须是同一作用域。
func test() { 	x := 200 	x1 := x &#43; 100  	if x1 &amp;gt; 0 { 	println(&amp;#34;x&amp;#34;) 	} else { 	println(&amp;#34;-x&amp;#34;) 	} 	x1, y := 200, &amp;#34;abc&amp;#34; // x1 是重新赋值，y是变量定义 	fmt.Println(x1, y) } x := 100 println(&amp;amp;x,x) { 	x, y := 200, 300 //定义了一个新变量 	println(&amp;amp;x, &amp;amp;y, x, y) } 多变量赋值操作时，总是首先计算出所有的右值，然后再依次完成赋值操作，即并行赋值。
x, y := 1, 2 x, y = y&#43;3, x&#43;2 //先计算出右值y&#43;3,x&#43;2,然后再依次完成赋值操作 fmt.Println(x, y)  使用new函数定义变量 new函数是Go中内置的函数，表达式new(T)创建一个未命名的T类型变量，初始化为T类型的零值，并返回其指针。
使用new创建的变量和取其地址的普通变量没有什么不同，只是不需要引入一个虚拟名字，因此new（T）只是在语法上的便利。下面两个newInt函数有同样的行为：
func newInt() *int { 	return new(int) }  func newInt() *int { 	var dummy int 	return &amp;amp;dummy }  </content>
    </entry>
    
     <entry>
        <title>snapkit 使用</title>
        <url>https://iihui.github.io/post/ios-snapkit/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> inset和offset  在描述view与superview关系时，应该使用inset，而描述view与同一层级的其它view时，应该使用offset。
 使用offset来设置距离子控件相对于父控件边距时，对于右边和下方的约束都需要加-号。这和在storyboard中设置约束不一致，显得有些不合理。
/* extension String { func boundingRect(with constrainedSize: CGSize, font: UIFont, lineSpacing: CGFloat? = nil) -&amp;gt; CGSize { let attritube = NSMutableAttributedString(string: self) let range = NSRange(location: 0, length: attritube.length) attritube.addAttributes([NSAttributedString.Key.font: font], range: range) if lineSpacing != nil { let paragraphStyle = NSMutableParagraphStyle() paragraphStyle.lineSpacing = lineSpacing! attritube.addAttribute(NSAttributedString.Key.paragraphStyle, value: paragraphStyle, range: range) } let rect = attritube.boundingRect(with: constrainedSize, options: [.usesLineFragmentOrigin, .usesFontLeading], context: nil) var size = rect.size if let currentLineSpacing = lineSpacing { // The height of the text minus the height of the font is less than or equal to the line spacing 1 line let spacing = size.height - font.lineHeight if spacing &amp;lt;= currentLineSpacing &amp;amp;&amp;amp; spacing &amp;gt; 0 { size = CGSize(width: size.width, height: font.lineHeight) } } return size } func boundingRect(with constrainedSize: CGSize, font: UIFont, lineSpacing: CGFloat? = nil, lines: Int) -&amp;gt; CGSize { if lines &amp;lt; 0 { return .zero } let size = boundingRect(with: constrainedSize, font: font, lineSpacing: lineSpacing) if lines == 0 { return size } let currentLineSpacing = (lineSpacing == nil) ? (font.lineHeight - font.pointSize) : lineSpacing! let maximumHeight = font.lineHeight * CGFloat(lines) &#43; currentLineSpacing * CGFloat(lines - 1) if size.height &amp;gt;= maximumHeight { return CGSize(width: size.width, height: maximumHeight) } return size } } */ func format(phoneNumber: String, shouldRemoveLastDigit: Bool = false) -&amp;gt; String {   guard !phoneNumber.isEmpty else {  return &amp;#34;&amp;#34;  }   guard let regex = try? NSRegularExpression(pattern: &amp;#34;[\\s-\\(\\)]&amp;#34;, options: .caseInsensitive) else {  return &amp;#34;&amp;#34;  }   let r = NSString(string: phoneNumber).range(of: phoneNumber)  var number = regex.stringByReplacingMatches(in: phoneNumber, options: .init(rawValue: 0), range: r, withTemplate: &amp;#34;&amp;#34;)   if number.count &amp;gt; 11 {  let tenthDigitIndex = number.index(number.startIndex, offsetBy: 11)  number = String(number[number.startIndex..&amp;lt;tenthDigitIndex])  }   if shouldRemoveLastDigit {  let end = number.index(number.startIndex, offsetBy: number.count - 1)  number = String(number[number.startIndex..&amp;lt;end])  }   if number.count &amp;lt; 7 {  let end = number.index(number.startIndex, offsetBy: number.count)  let range = number.startIndex..&amp;lt;end  number = number.replacingOccurrences(of: &amp;#34;(\\d{3})(\\d&#43;)&amp;#34;, with: &amp;#34;$1 $2&amp;#34;, options: .regularExpression, range: range)  } else {  let end = number.index(number.startIndex, offsetBy: number.count)  let range = number.startIndex..&amp;lt;end  number = number.replacingOccurrences(of: &amp;#34;(\\d{3})(\\d{4})(\\d*)&amp;#34;, with: &amp;#34;$1 $2 $3&amp;#34;, options: .regularExpression, range: range)  }   return number  } 参考资料
参考资料
</content>
    </entry>
    
     <entry>
        <title>富文本</title>
        <url>https://iihui.github.io/post/ios-richtext/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> 在文字后面添加红点 /// 使用富文本的方式在UILabel文本后面添加红点 /// - Parameter add: isNeedAdd 为true表示要加红点，否则不需要 /// - Returns: 处理后的富文本 func addRedDot(isNeedAdd: Bool) -&amp;gt; NSMutableAttributedString {  var text: String = (self.text ?? &amp;#34;&amp;#34;)  if isNeedAdd {  text &#43;= &amp;#34; &amp;#34;  let contentText = NSMutableAttributedString(string: text)  let attach = NSTextAttachment()  let dotImg = UIImage(named: &amp;#34;reddot&amp;#34;)  let width: CGFloat = 10  attach.bounds = CGRect(x: 0, y: 0.5, width: width, height: width)  attach.image = dotImg  let attrText = NSMutableAttributedString(attachment: attach)  attrText.insert(contentText, at: 0)  return attrText  } else {  let attrText = NSMutableAttributedString(string: text)  return attrText  } }  文字前面添加标签 /// 标题前面添加红底白字的标签，参考自https://www.jianshu.com/p/ab7ada727606 /// - Parameters: /// - category: 标签类别 /// - title: 真正的标题 func addCategoryBackground(category: String, title: String) -&amp;gt; NSMutableAttributedString {  // 设计要求title前面需要有空格  let contentText = NSMutableAttributedString(string: &amp;#34; &amp;#34; &#43; title)  let paragraphStyle = NSMutableParagraphStyle()  paragraphStyle.lineSpacing = self.lineSpace  paragraphStyle.lineBreakMode = .byWordWrapping  if #available(iOS 9.0, *) {  paragraphStyle.allowsDefaultTighteningForTruncation = true  }  // 设计要求category前后都需要有空格  let text = &amp;#34; &amp;#34; &#43; category &#43; &amp;#34; &amp;#34;  let width = calculateWidth(text: text, height: self.categoryHeight, font: UIFont.systemFont(ofSize: self.categoryFontSize, weight: .regular), maxWidth: CGFloat.greatestFiniteMagnitude)  let tmpLbl = UILabel(frame: CGRect(x: 0.0, y: 0.0, width: self.multiple * width, height: self.multiple * self.categoryHeight))  tmpLbl.text = text  tmpLbl.font = UIFont.systemFont(ofSize: self.multiple * self.categoryFontSize, weight: .regular)  tmpLbl.backgroundColor = UIColor.hexColor(&amp;#34;ed534d&amp;#34;)  tmpLbl.textColor = .white  tmpLbl.clipsToBounds = true  tmpLbl.cornerRadius = self.categoryCornerRadius  tmpLbl.textAlignment = .center  if let image = labelConvertToImage(view: tmpLbl) {  let attach = NSTextAttachment()  attach.bounds = CGRect(x: 0, y: self.categoryHeightSkewing, width: width, height: self.categoryHeight)  attach.image = image  let attrText = NSAttributedString(attachment: attach)  contentText.insert(attrText, at: 0)  let attributes = [NSAttributedString.Key.paragraphStyle: paragraphStyle]  contentText.addAttributes(attributes, range: NSRange(location: 0, length: contentText.length))  }  return contentText } /// 将UIView转换为UIImage，以便AttributedString使用图文混排 /// - Parameter view: 待转换的view /// - Returns: 转换后的图片 private func labelConvertToImage(view: UIView) -&amp;gt; UIImage? {  var image: UIImage? = nil  UIGraphicsBeginImageContext(view.bounds.size)  if let context = UIGraphicsGetCurrentContext() {  view.layer.render(in: context)  image = UIGraphicsGetImageFromCurrentImageContext()  UIGraphicsEndImageContext()  }  return image }  自动计算宽度 自动计算宽度分为两种，第一种以一个UILabel作为试探，使用sizeToFit()来计算；另一种是使用字符串的boundingRect来计算，如下代码所示：
/// 动态计算给定字符串在固定高度下的宽度，若小于最大宽度则返回实际宽度，否则返回最大宽度 /// - Parameters: /// - text: 待计算的字符串 /// - height: 固定的高度 /// - font: 固定的字体 /// - maxWidth: 允许最大的宽度 private func calculateWidth(text: String, height: CGFloat, font: UIFont, maxWidth: CGFloat) -&amp;gt; CGFloat {  let tmpLbl = UILabel(frame: CGRect(x: 0, y: 0, width: CGFloat.greatestFiniteMagnitude, height: height))  tmpLbl.numberOfLines = 0  tmpLbl.lineBreakMode = .byCharWrapping  tmpLbl.font = font  tmpLbl.text = text  tmpLbl.sizeToFit()  let width = tmpLbl.frame.width &amp;gt; maxWidth ? maxWidth : tmpLbl.frame.width  return width } /// 根据高度和字体大小计算字符串宽度 func widthWithConstrainedHeight(height: CGFloat, fontSize: CGFloat) -&amp;gt; CGFloat {  let constraintRect = CGSize(width: .greatestFiniteMagnitude, height: height)  let boundingBox = self.boundingRect(with: constraintRect, options: [.usesLineFragmentOrigin, .usesFontLeading], attributes: [NSAttributedString.Key.font: UIFont.systemFont(ofSize: fontSize)], context: nil)  return boundingBox.width }  </content>
    </entry>
    
     <entry>
        <title>Live JavaScript debug</title>
        <url>https://iihui.github.io/post/safari-debug/</url>
        <categories>
          <category>safari</category>
        </categories>
        <tags>
          <tag>safari</tag>
        </tags>
        <content type="html">  从2020年4月开始，Safari支持Live JavaScript debug，使得在使用safari调试时可以使用本地文件覆盖从服务端下载的资源文件。Safari浏览器支持3种方式创建本地覆盖。
 创建本地覆盖 第一种 首先选中某个文件，然后点击右上角创建覆盖的图标，就会创建当前文件的本地覆盖，如下图所示：
第二种 依然是首先选中某个文件，然后点击鼠标右键，选中创建本地覆盖，如下图所示：
第三种 在左下角点击新增按钮，然后选中本地覆盖，然后输入正确的url，如下图所示：
参考资料
参考资料
</content>
    </entry>
    
     <entry>
        <title></title>
        <url>https://iihui.github.io/post/ios-customizeuiview/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> class RecommendView: UIView {  @IBOutlet weak var imageView: UIImageView!  @IBOutlet weak var subTitleLbl: UILabel!  @IBOutlet weak var titleLbl: UILabel!   @IBOutlet var contentView: UIView!   override init(frame: CGRect) { //每一步都必须实现父初始化  super.init(frame: frame)  contentView = loadViewFromNib()  contentView.frame = bounds  addSubview(contentView)  }   //可视化IB初始化调用  required init?(coder aDecoder: NSCoder) {  super.init(coder: aDecoder)  contentView = loadViewFromNib()  contentView.frame = bounds  addSubview(contentView)  }   //MARK：自定义方法  func loadViewFromNib() -&amp;gt; UIView {  let nib = UINib(nibName: String(describing: RecommendView.self), bundle: Bundle(for: RecommendView.self))  let view = nib.instantiate(withOwner: self, options: nil)[0] as! UIView  return view  } } 参考资料
</content>
    </entry>
    
     <entry>
        <title>Swift 范型</title>
        <url>https://iihui.github.io/post/swift-generirs/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> 范型类型 Swift允许自定义的范型类型包括类、结构体、枚举类型。
struct Stack {  var items = [Int]()  mutating func push(_ item:Int){  items.append(item)  }  mutating func pop(_ item:Int) -&amp;gt; Int {  return items.removeLast()  } } //调用 var stack_int = Stack() stack_int.push(7) stack_int.push(3) stack_int.push(2) print(stack_int)//Stack(items: [7, 3, 2]) 类型约束 范型函数和范型类型虽然可以和任何类型一起使用，但有时需要限制使用的类型，此时就需要使用类型约束。例如Swift中Dictionary的Key便被约束为必须遵守hashable协议。
 类型约束是指指定类型参数必须继承自特定的类，遵守某个协议或协议组合。
 func someFunction&amp;lt;T: SomeClass, U: SomeProtocol&amp;gt;(someT: T, someU: U) {  // `T`约束为继承自`SomeClass`的类型 `U`约束为遵守`SomeProtocol` 协议的类型 }  func findIndex&amp;lt;T : Equatable&amp;gt;(of valueToFind: T, in array:[T]) -&amp;gt; Int? {  for (index, value) in array.enumerated() {  if value == valueToFind {  return index  }  }  return nil } 关联类型 在定义协议时，有时声明一个或多个关联类型作为协议定义的一部分是很有用的。关联类型的作用，主要是提供某个类型的占位名称，然后作为协议的一部分去使用。关联类型的实际使用类型直到协议被实现时才会指定。关联类型使用关键字associatedtype指定。
//定义协议使用类型关联 protocol Container {  associatedtype Item  mutating func append(_ item : Item)  var count : Int{get}  subscript(i:Int)-&amp;gt;Item{get} } //定义整型Stack类型 struct IntStack : Container {  var items = [Int]()  mutating func push(_ item:Int){  items.append(item)  }  mutating func pop(_ item:Int) -&amp;gt; Int {  return items.removeLast()  }  //实现协议时，需要明确关联类型的实际类型  typealias Item = Int //!&amp;lt; ①   mutating func append(_ item: Item) {//!&amp;lt; ①若不存在，此处可直接 Int  push(item)  }   var count: Int {  items.count  }  subscript(i: Int) -&amp;gt; Int {  items[i]  } } 摘抄自
</content>
    </entry>
    
     <entry>
        <title>Swift中defer</title>
        <url>https://iihui.github.io/post/swift-defer/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  从语言设计上来说，defer是为了进行资源清理和返回前避免重复执行相关的代码，而不是用来取巧的实现某些功能，这样做只会让代码的可读性降低。
 典型用法 Swift中defer声明的block会在当前代码执行退出后调用，这种延迟调用特性，一般用来进行资源释放或者销毁。
func operateOnFile(descriptor: Int32) {  let fileHandle = FileHandle(fileDescriptor: descriptor)   let data = fileHandle.readDataToEndOfFile()   if /* onlyRead */ {  fileHandle.closeFile()  return  }   let shouldWrite = /* 是否需要写文件 */  guard shouldWrite else {  fileHandle.closeFile()  return  }   fileHandle.seekToEndOfFile()  fileHandle.write(someData)  fileHandle.closeFile() } 上面代码在不同的地方调用fileHandle.closeFile()来关闭文件，更好的方法是使用defer来统一处理。这不仅可以就近在资源申请的地方就声明释放，也减少了未来添加代码时忘记释放资源的可能性，如下所示：
func operateOnFile(descriptor: Int32) {  let fileHandle = FileHandle(fileDescriptor: descriptor)  defer { fileHandle.closeFile() }  let data = fileHandle.readDataToEndOfFile()   if /* onlyRead */ { return }   let shouldWrite = /* 是否需要写文件 */  guard shouldWrite else { return }   fileHandle.seekToEndOfFile()  fileHandle.write(someData) } 作用域 一般都人defer是在函数退出的时候调用，其实它是在是当前scope退出的时候调用。在 if，guard，for，try这些语句中使用defer时，应该要特别注意。
defer闭包不持有值 虽然defer后面跟了一个闭包，但是它更多地像是一个语法糖，和我们所熟知的闭包特性不一样，并不会持有里面的值：
func foo() {  var number = 1  defer { print(&amp;#34;Statement 2: \(number)&amp;#34;) }  number = 100  print(&amp;#34;Statement 1: \(number)&amp;#34;) } 上面代码将会输出：
Statement 1: 100 Statement 2: 100 执行时机 defer的执行时机紧接在离开作用域之后，但在其他语句之前。这个特性为defer带来了一些很“微妙”的使用方式，例如下面的代码是先执行返回语句，然后执行自增，所以输出为0，1，2而不是1，2，3：
class Foo {  var num = 0  func foo() -&amp;gt; Int {  defer { num &#43;= 1 }  return num  }  }  let f = Foo() f.foo() // 0 f.foo() // 1 f.num // 2 参考资料
</content>
    </entry>
    
     <entry>
        <title>屏幕旋转</title>
        <url>https://iihui.github.io/post/ios-rotate/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  iOS开发时经常会遇到要将某些界面强制竖屏或者横屏。要做到某个页面能强制横竖屏的前提是允许屏幕旋转，然后再在具体的界面强制横竖屏。但是要区分这个具体的界面时push还是present呈现的。
 全局允许横竖屏 第一种方式，是在Target中的General下Device Orientation中设置，但是这种方式设置的允许横竖屏会被AppDelegate.swift中对应的代码覆盖，所以一般不在这里设置。设置方式如下图所示：
另一种方法是在AppDelegate.swift中设置允许横竖屏，如下代码所示：
func application(_ application: UIApplication, supportedInterfaceOrientationsFor window: UIWindow?) -&amp;gt; UIInterfaceOrientationMask {  return .all } 界面强制竖屏 对于以present方式呈现的界面，需要在当前界面所属的UIViewController中重写以下两个属性：
override var supportedInterfaceOrientations: UIInterfaceOrientationMask {  return .portrait } override var shouldAutorotate: Bool {  return false } 而对于以push方式呈现的界面，需要重写对应的UINavigationController中重写上面的两个属性。为了方便可以写一个继承自UINavigationController，然后将强制横竖屏的代码交给要push的界面，如下所示：
class RotatableNavigationController: UINavigationController {   override var shouldAutorotate : Bool {  return self.topViewController?.shouldAutorotate ?? super.shouldAutorotate  }   override var supportedInterfaceOrientations : UIInterfaceOrientationMask {  return self.topViewController?.supportedInterfaceOrientations ?? super.supportedInterfaceOrientations  } }  </content>
    </entry>
    
     <entry>
        <title>WCDB</title>
        <url>https://iihui.github.io/post/ios-wcdb/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> 自定义类型入库 自定义类型要遵循ColumnCodable才能入库：
enum UserOrgType: String, ColumnCodable {   case CMB = &amp;#34;CMB&amp;#34;  case ODC = &amp;#34;3&amp;#34;   static var columnType: ColumnType = .text   init(with value: FundamentalValue) {  self = UserOrgType(rawValue: value.stringValue) ?? UserOrgType.CMB  }   func archivedValue() -&amp;gt; FundamentalValue {  return FundamentalValue(self.rawValue)  } } /// 查看用户表是否为空 func isEmpty() -&amp;gt; Bool {  do {  let count = try DBManager_V2.shared.userDb.getValue(on: UserInfoModel_V2.CodingKeys.openId.count(), fromTable: tableName).int64Value  return count == 0  } catch let error {  printError(msg: error.localizedDescription, type: .db)  return true  } } </content>
    </entry>
    
     <entry>
        <title>UIAlertViewController</title>
        <url>https://iihui.github.io/post/ios-alertviewcontroller/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  最近使用UIAlertViewController时，需要定制其背景颜色，在网上找到一个解决方案，基本思路是为UIAlertViewController设置一个计算属性，这个属性改变时即将UIAlertViewController的背景色修改。
 添加计算属性 class AlertController: UIAlertController {  /// Buttons background color.  var buttonBackgroundColor: UIColor = .darkGray {  didSet {  // Invalidate current colors on change.  view.setNeedsLayout()  }  }   override func viewDidLayoutSubviews() {  super.viewDidLayoutSubviews()   // Traverse view hierarchy.  view.allViews.forEach {  // If there was any non-clear background color, update to custom background.  if let color = $0.backgroundColor, color != .clear {  $0.backgroundColor = buttonBackgroundColor  }  // If view is UIVisualEffectView, remove it&amp;#39;s effect and customise color.  if let visualEffectView = $0 as? UIVisualEffectView {  visualEffectView.effect = nil  visualEffectView.backgroundColor = buttonBackgroundColor  }  }  // Update background color of popoverPresentationController (for iPads).  popoverPresentationController?.backgroundColor = buttonBackgroundColor  } } 获取views extension UIView {  /// All child subviews in view hierarchy plus self.  fileprivate var allViews: [UIView] {  var views = [self]  subviews.forEach {  views.append(contentsOf: $0.allViews)  }  return views  } } 扩展VC extension UIViewController {   func notify(msg: String) -&amp;gt; Void {  let alert = UIAlertController(title: &amp;#34;&amp;#34;, message: msg, preferredStyle: .alert)  if let visualEffectView = alert.view.searchVisualEffectsSubview() {  visualEffectView.effect = UIBlurEffect(style: .light)  }   alert.setMessage(font: UIFont.systemFont(ofSize: 17))   present(alert, animated: true, completion: nil)  DispatchQueue.main.asyncAfter(deadline: .now() &#43; 1.5) { [weak self] in  self?.dismiss(animated: true)  }  } }   func searchVisualEffectsSubview() -&amp;gt; UIVisualEffectView? {  if let visualEffectView = self as? UIVisualEffectView {  return visualEffectView  } else {  for subview in subviews {  if let found = subview.searchVisualEffectsSubview() {  return found  }  }  }  return nil  } 定制字体和颜色 extension UIAlertController {   func setBackgroundColor(color: UIColor) {  if let bgView = self.view.subviews.first, let groupView = bgView.subviews.first, let contentView = groupView.subviews.first {  contentView.backgroundColor = color  }  }   func setTitle(font: UIFont?, color: UIColor? = nil) {  guard let title = self.title else {  return  }  let attributeString = NSMutableAttributedString(string: title)  if let titleFont = font {  attributeString.addAttributes([NSAttributedString.Key.font: titleFont],  range: NSMakeRange(0, title.count))  }   if let titleColor = color {  attributeString.addAttributes([NSAttributedString.Key.foregroundColor: titleColor],  range: NSMakeRange(0, title.count))  }  self.setValue(attributeString, forKey: &amp;#34;attributedTitle&amp;#34;)  }   func setMessage(font: UIFont?, color: UIColor? = nil) {  guard let message = self.message else {  return  }  let attributeString = NSMutableAttributedString(string: message)  if let messageFont = font {  attributeString.addAttributes([NSAttributedString.Key.font: messageFont],  range: NSMakeRange(0, message.count))  }   if let messageColor = color {  attributeString.addAttributes([NSAttributedString.Key.foregroundColor: messageColor],  range: NSMakeRange(0, message.count))  }  self.setValue(attributeString, forKey: &amp;#34;attributedMessage&amp;#34;)  }   func setTint(color: UIColor) {  self.view.tintColor = color  } }  </content>
    </entry>
    
     <entry>
        <title>linux 命令大全</title>
        <url>https://iihui.github.io/post/linux-base/</url>
        <categories>
          <category>linux</category>
        </categories>
        <tags>
          <tag>linux</tag>
        </tags>
        <content type="html">  这篇笔记是学习Linux命令大全的读书笔记，用于记录那些个人认为有用的命令，供后续查询。
 shell 是什么 df df命令用于磁盘驱动器当前的可用空间
free free命令可以显示可用内存
</content>
    </entry>
    
     <entry>
        <title>vim 学习</title>
        <url>https://iihui.github.io/post/tool-vim/</url>
        <categories>
          <category>vim</category>
        </categories>
        <tags>
          <tag>vim</tag>
        </tags>
        <content type="html"> 配置文件 vim从一个名为.vimrc（在类Unix系统中，以.开头的文件为隐藏文件，为了看到这些文件，可以运行ls -a命令行）的文件中读取配置信息。
syntax on &amp;#34;支持语法高亮显示 filetype plugin indent on &amp;#34;启用根据文件类型缩进 set autoindent &amp;#34;开启新行时处理缩进 set expandtab &amp;#34;将制表符Tab展开为空格 set tabstop=4 &amp;#34;要计算的空格数 set shiftwidth=4 &amp;#34;用于自动缩进的空格数 set backspace=2 &amp;#34;在多终端上修正退格键backspace的行为 colorscheme murphy &amp;#34;修改配色 打开文件 vim test.txt会打开一个名为test.txt的文件。如果该文件存在，则读者会看到它的内容，如果文件不存在，则得到一个空白界面。
清空内容 首先进入到命令模式，然后输入gg命令， 接着输入dG命令。
无提示生成ssh-key ssh-keygen -q -t rsa -C &amp;#34;xxx.com&amp;#34; -N &amp;#34;&amp;#34; -f ~/.ssh/id_rsa_yst &amp;lt;&amp;lt;&amp;lt;y &amp;gt;/dev/null 2&amp;gt;&amp;amp;1 </content>
    </entry>
    
     <entry>
        <title>Mach-O 文件</title>
        <url>https://iihui.github.io/post/ios-macho/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  Mach-O为Mach Object文件格式的缩写，它是一种用于可执行文件、目标代码、动态库的文件格式。
 文件类型 常见的MachO文件有下面这些，可以通过file&#43;文件路径来查看文件的类型信息：
 目标文件.o 库文件.a | .dylib | xxx.framework/xxx 可执行文件 符号表文件.dysm  通用二进制 通用二进制文件是一种能够同时兼容多种架构的二进制文件，常用的架构有arm64,arm64e,armv7,armv7s，除了能够兼容多种架构，还有以下特点：
  能够为不同的架构提供最理想的性能。
  因为要存储多种架构的代码，通用二进制程序包要比单一架构的二进制程序包大。
  因为多种架构只是代码不同，但资源相同，通用二进制的资源只有一份，所以并不会比单一架构的程序包大小多一倍。
  运行时也只执行对应架构的代码，不会占用多余的内存。
  lipo lipo可以用来合并真机包和模拟器包：
lipo -create [真机编译路径/xxx.framework/xxx] [模拟器编译路径/xxx.framework/xxx] -output [合并后输出的文件路径] 也可以用来从通用二进制文件中拆分出不同架构：
// 从通用二进制文件拆分出不同的架构 lipo [通用二进制文件路径] -thin [要拆的架构] -output [拆出的二进制输出的路径] MachO的文件结构 MachO文件分为Header、Load、commands、Data三部分，如下图所示：
切换cocoapods版本  sudo gem uninstall cocoapods  sudo gem uninstall cocoapods-art  sudo gem install cocoapods -v 1.5.3  sudo gem install cocoapods-art -v 1.0.3 参考资料
</content>
    </entry>
    
     <entry>
        <title>创建私有库</title>
        <url>https://iihui.github.io/post/ios-private-pods/</url>
        <categories>
          <category>ios</category>
        </categories>
        <tags>
          <tag>ios</tag><tag>pod</tag>
        </tags>
        <content type="html">  使用cocoapods可以创建远程私有库，供项目使用。首先需要在github上创建一个远程索引库，然后使用cocopods在本地创建文件夹，并与远程私有库进行关联。再在github上创建远程组件库，接着使用pod创建本地工程，然后修改组件库的podspec文件，并将本地工程与远程组件库关联，打上与podspec文件中版本号一致的tag，然后提交，最后将podspec文件提交本地索引库。
 远程私有索引库 首先在github上创建一个私有库，用来存放私有库的详细描述信息，如下图所示：
本地私有索引库 在创建本地索引库之前，首先需要查看本地已存在的索引库，以免创建同名的本地索引库，如下所示：
pod repo 然后使用如下命令，将远程库添加到本地，以创建本地索引库：
pod repo add MoSpec https://github.com/***/MoSpec.git 添加之后，可以再使用pod repo查看本地已存在的索引库，如下所示多了一个本地索引库:
创建基础组件仓库 下面就本地创建WCDBSwift为例讲解基础组件库的创建。WCDBSwift依赖于HY_SQLiteRepairKit和HY_WCDBOptimizedSQLCipher，而HY_SQLiteRepairKit又依赖于HY_WCDBOptimizedSQLCipher，所以开始从HY_WCDBOptimizedSQLCipher组件库开始：
本地组件库 首先使用pod命令在本地创建组件库，如下所示：
pod lib create HY_WCDBOptimizedSQLCipher 然后将所有代码源文件Classes目录下：
远程组件库 接着在github上创建远程组件库，通常需要和本地库的名字保持一致，如下所示：
修改podspec 在给定的模版上修改podspec文件，注意s.version的值将于tag保持一致，而s.source则表示上一步创建的远程组件库的地址，如下所示：
# # Be sure to run `pod lib lint HY_WCDBOptimizedSQLCipher.podspec&amp;#39; to ensure this is a # valid spec before submitting. # # Any lines starting with a # are optional, but their use is encouraged # To learn more about a Podspec see https://guides.cocoapods.org/syntax/podspec.html #  Pod::Spec.new do |s|  s.name = &amp;#39;HY_WCDBOptimizedSQLCipher&amp;#39;  s.version = &amp;#39;0.1.0&amp;#39;  s.summary = &amp;#39;HY_WCDBOptimizedSQLCipher from WeChat WCDBOptimizedSQLCipher 1.2.1.&amp;#39;  # This description is used to generate tags and improve search results. # * Think: What does it do? Why did you write it? What is the focus? # * Try to keep it short, snappy and to the point. # * Write the description between the DESC delimiters below. # * Finally, don&amp;#39;t worry about the indent, CocoaPods strips it!   s.description = &amp;lt;&amp;lt;-DESC  private WCDBOptimizedSQLCipher from WeChat WCDBOptimizedSQLCipher 1.2.1.  DESC   s.homepage = &amp;#39;https://github.com/***/HY_WCDBOptimizedSQLCipher&amp;#39;  s.license = { :type =&amp;gt; &amp;#39;MIT&amp;#39;, :file =&amp;gt; &amp;#39;LICENSE&amp;#39; }  s.author = { &amp;#39;***&amp;#39; =&amp;gt; &amp;#39;****&amp;#39; }  s.source = { :git =&amp;gt; &amp;#39;https://github.com/***/HY_WCDBOptimizedSQLCipher.git&amp;#39;, :tag =&amp;gt; s.version.to_s }   s.ios.deployment_target = &amp;#39;9.0&amp;#39;   s.module_name = &amp;#39;sqlcipher&amp;#39;  s.source_files = &amp;#39;HY_WCDBOptimizedSQLCipher/Classes/*.{h,c}&amp;#39;,&amp;#39;HY_WCDBOptimizedSQLCipher/Classes/src/*.{h,c}&amp;#39;,&amp;#39;HY_WCDBOptimizedSQLCipher/Classes/ext/*.{h,c}&amp;#39;,&amp;#39;HY_WCDBOptimizedSQLCipher/Classes/ext/**/*.{h,c}&amp;#39; s.public_header_files = &amp;#39;HY_WCDBOptimizedSQLCipher/Classes/sqlite3.h&amp;#39;,&amp;#39;HY_WCDBOptimizedSQLCipher/Classes/ext/fts3/fts3_tokenizer.h&amp;#39; s.frameworks = &amp;#39;Security&amp;#39;, &amp;#39;Foundation&amp;#39; s.requires_arc = false s.xcconfig = { &amp;#39;GCC_PREPROCESSOR_DEFINITIONS&amp;#39; =&amp;gt; &amp;#39;SQLITE_ENABLE_FTS3 SQLITE_ENABLE_FTS3_PARENTHESIS SQLITE_ENABLE_API_ARMOR SQLITE_OMIT_BUILTIN_TEST SQLITE_OMIT_AUTORESET SQLITE_ENABLE_UPDATE_DELETE_LIMIT SQLITE_ENABLE_RTREE SQLITE_ENABLE_LOCKING_STYLE=1 SQLITE_SYSTEM_MALLOC SQLITE_OMIT_LOAD_EXTENSION SQLITE_CORE SQLITE_THREADSAFE=2 SQLITE_DEFAULT_CACHE_SIZE=250 SQLITE_DEFAULT_CKPTFULLFSYNC=1 SQLITE_DEFAULT_PAGE_SIZE=4096 SQLITE_OMIT_SHARED_CACHE SQLITE_HAS_CODEC SQLCIPHER_CRYPTO_CC USE_PREAD=1 SQLITE_TEMP_STORE=2 SQLCIPHER_PREPROCESSED HAVE_USLEEP SQLITE_MALLOC_SOFT_LIMIT=0 SQLITE_WCDB_SIGNAL_RETRY=1 SQLITE_DEFAULT_MEMSTATUS=0 SQLITE_ENABLE_COLUMN_METADATA SQLITE_DEFAULT_WAL_SYNCHRONOUS=1 SQLITE_LIKE_DOESNT_MATCH_BLOBS SQLITE_MAX_EXPR_DEPTH=0 SQLITE_OMIT_DEPRECATED SQLITE_OMIT_PROGRESS_CALLBACK SQLITE_OMIT_SHARED_CACHE OMIT_CONSTTIME_MEM OMIT_MEMLOCK SQLITE_ENABLE_FTS3_TOKENIZER SQLITE_WCDB_CHECKPOINT_HANDLER SQLITE_MMAP_READWRITE SQLITE_ENABLE_DBSTAT_VTAB SQLITE_ENABLE_FTS5&amp;#39;, &amp;#39;CLANG_WARN_CONSTANT_CONVERSION&amp;#39; =&amp;gt; &amp;#39;YES&amp;#39;, &amp;#39;GCC_WARN_64_TO_32_BIT_CONVERSION&amp;#39; =&amp;gt; &amp;#39;NO&amp;#39;, &amp;#39;CLANG_WARN_UNREACHABLE_CODE&amp;#39; =&amp;gt; &amp;#39;NO&amp;#39;, &amp;#39;GCC_WARN_UNUSED_FUNCTION&amp;#39; =&amp;gt; &amp;#39;NO&amp;#39;, &amp;#39;GCC_WARN_UNUSED_VARIABLE&amp;#39; =&amp;gt; &amp;#39;NO&amp;#39;, &amp;#39;CLANG_WARN_COMMA&amp;#39; =&amp;gt; &amp;#39;NO&amp;#39;, &amp;#39;CLANG_WARN_STRICT_PROTOTYPES&amp;#39; =&amp;gt; &amp;#39;NO&amp;#39;, &amp;#39;APPLICATION_EXTENSION_API_ONLY&amp;#39; =&amp;gt; &amp;#39;YES&amp;#39;} s.header_dir = &amp;#39;sqlcipher&amp;#39; end 检查podspec 在终端下转到工程目录下，然后执行pod lib lint命令，以检查下一步修改的podspec文件：
本地验证组件 在终端下转到Example目录下，然后执行pod install命令，然后打开Xcode在模拟器或者跑一下工程，未报错则本地验证通过：
上传到远程库 在终端下或者使用sourceTree将本地库添加的文件以及修改的podspec提交然后上传到远程库：
添加tag 然后给本地库添加跟s.version一样的tag，然后再push到远程库：
关联到本地索引库 在终端下转到本地组件工程目录，使用pod repo push MoSpec HY_WCDBOptimizedSQLCipher.podspec --allow-warnings命令将podspec文件提交到本地索引库，提交的时候依然会验证 podspec文件，验证通过后会自动上传到在远程spec`索引库。
 参考资料 参考资料
</content>
    </entry>
    
     <entry>
        <title>指定Podfile中source</title>
        <url>https://iihui.github.io/post/ios-pods-question/</url>
        <categories>
          <category>iOS</category><category>pod</category>
        </categories>
        <tags>
          <tag>iOS</tag><tag>pod</tag>
        </tags>
        <content type="html">  在笔记本上安装好Cocoapods之后，执行pod install后报trunk repo update failed，解决方案是在Podfile中指定另一个源仓库。
 报错信息 解决方案 解决方案是在Podfile中指定source，如下所示：
platform :ios, &amp;#39;8.0&amp;#39; source &amp;#39;https://github.com/CocoaPods/Specs.git&amp;#39; use_frameworks!  target &amp;#39;NewWCDB&amp;#39; do  pod &amp;#39;WCDB.swift&amp;#39; end 如上图所示，此时，执行pod install是正常的，但是执行pod search依然会报错，此时就需要将trunk移除：
pod repo remove trunk  参考资料
</content>
    </entry>
    
     <entry>
        <title>验证码绑定界面</title>
        <url>https://iihui.github.io/post/ios-login/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  验证码绑定，包括个人账户，和虚拟账户。之前写的验证码绑定界面扩展性太差，这次决定尝试使用tableView实现验证码绑定界面，主要是为了增加可扩展性，便于当需要增加新的验证信息时，可以不大动原界面。这篇文章是对应的ViewController的代码和最终的界面。
 VC代码 import UIKit  enum SMSLoginType {  case Personal  case Virtual }  class NewSMSViewController: UIViewController, UITableViewDelegate, UITableViewDataSource {  @IBOutlet weak var personalAccountBtn: UIButton!  @IBOutlet weak var personalAccountUnderline: UILabel!  @IBOutlet weak var virtualAccountBtn: UIButton!  @IBOutlet weak var virtualAccountUnderline: UILabel!  @IBOutlet weak var tableView: UITableView!  private let defaultColor = UIColor(hex: &amp;#34;#4B5169&amp;#34;)  private let hiddenColor = UIColor(hex: &amp;#34;#9294A6&amp;#34;)  private var imageAndText: [(image: String, tip: String)] = [(&amp;#34;virtualid&amp;#34;, &amp;#34;请输入虚拟账号ID&amp;#34;), (&amp;#34;no&amp;#34;, &amp;#34;请输入一事通ID或员工编号&amp;#34;), (&amp;#34;idcard_small&amp;#34;, &amp;#34;请输入身份证后六位&amp;#34;)]  private var _loginType: SMSLoginType = .Personal  private var loginType: SMSLoginType {  get {  return _loginType  }  set {  switch newValue {  case .Personal:  self.personalAccountUnderline.isHidden = false  self.virtualAccountUnderline.isHidden = true  self.personalAccountBtn.setTitleColor(self.defaultColor, for: .normal)  self.virtualAccountBtn.setTitleColor(self.hiddenColor, for: .normal)  case .Virtual:  self.personalAccountUnderline.isHidden = true  self.virtualAccountUnderline.isHidden = false  self.personalAccountBtn.setTitleColor(self.hiddenColor, for: .normal)  self.virtualAccountBtn.setTitleColor(self.defaultColor, for: .normal)  }  _loginType = newValue   self.tableView.reloadData()  }  }   override func viewDidLoad() {  super.viewDidLoad()  self.tableView.delegate = self  self.tableView.dataSource = self  self.tableView.tableFooterView = UIView()  self.tableView.separatorColor = UIColor.gray  self.tableView.separatorInset = UIEdgeInsets(top: 0, left: -10, bottom: 0, right: 0)  }   @IBAction func back(_ sender: Any) {  self.navigationController?.popViewController(animated: true)  }   @IBAction func showPersonalAccountUI(_ sender: Any) {  self.loginType = .Personal  }   @IBAction func showVirtualAccountUI(_ sender: Any) {  self.loginType = .Virtual  }   func numberOfSections(in tableView: UITableView) -&amp;gt; Int {  return 3  }   func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&amp;gt; CGFloat {  return 48  }   func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&amp;gt; Int {  switch section {  case 0:  switch _loginType {  case .Personal:  return 2  case .Virtual:  return 3  }  default:  return 1  }  }   func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) {  cell.selectionStyle = .none  }   func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -&amp;gt; CGFloat {  if section == 2 {  return 60  }  return 0  }   func tableView(_ tableView: UITableView, heightForFooterInSection section: Int) -&amp;gt; CGFloat {  switch section {  case 0, 1:  return 0.5  default:  return 0  }  }   func tableView(_ tableView: UITableView, viewForFooterInSection section: Int) -&amp;gt; UIView? {  let headerView = UIView()  headerView.backgroundColor = UIColor.gray  return headerView  }   func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -&amp;gt; UIView? {  let footerView = UIView()  footerView.backgroundColor = UIColor.clear  return footerView  }    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&amp;gt; UITableViewCell {  switch indexPath.section {  case 0:  let cell = tableView.dequeueReusableCell(withIdentifier: &amp;#34;SMSNormalCell&amp;#34;, for: indexPath)  if let norCell = cell as? SMSNormalCell {  var index = indexPath.row  switch loginType {  case .Personal:  index = index &#43; 1  default:  break  }  norCell.iconImageView.image = UIImage(named: imageAndText[index].image)  norCell.textField.placeholder = imageAndText[index].tip  norCell.textField.clearButtonMode = .whileEditing  }  return cell  case 1:  let cell = tableView.dequeueReusableCell(withIdentifier: &amp;#34;SMSCodeCell&amp;#34;, for: indexPath)  if let codeCell = cell as? SMSCodeCell {  codeCell.iconImageView.image = UIImage(named: &amp;#34;authcode&amp;#34;)  codeCell.textField.placeholder = &amp;#34;请输入手机验证码&amp;#34;  codeCell.textField.clearButtonMode = .whileEditing  codeCell.codeBtn.layer.cornerRadius = 18.0  codeCell.codeBtn.layer.borderColor = UIColor.black.cgColor  codeCell.codeBtn.layer.borderWidth = 1.0  }  cell.separatorInset = UIEdgeInsets(top: 0, left: 0, bottom: 12, right: 0)  return cell  default:  let cell = tableView.dequeueReusableCell(withIdentifier: &amp;#34;SMSBindCell&amp;#34;, for: indexPath)  return cell  }  } } 绑定界面  按钮圆角设置
自定义
// if let navBarHeight = self.navigationController?.navigationBar.frame.height { // navHeight &#43;= navBarHeight // }   navBGView.alpha = 0  navBGView.backgroundColor = UIColor.white  navBGView.frame = CGRect(x: 0, y: 0, width: self.view.bounds.size.width, height: navHeight) // navBGView.layer.shadowColor = UIColor.lightGray.cgColor // navBGView.layer.shadowOffset = CGSize(width: 0, height: 1.8) // navBGView.layer.shadowOpacity = 0.2 // navBGView.layer.shadowRadius = 2.5 // navBGView.layer.shadowPath = UIBezierPath.init(rect: navBGView.bounds).cgPath  // // let topSafeMargin = UIApplication.shared.keyWindow!.pagingLayoutInsets().top // let navTitleLbl = UILabel() // navTitleLbl.text = &amp;#34;资讯&amp;#34; // navTitleLbl.font = UIFont.systemFont(ofSize: 17.5, weight: .medium) // navTitleLbl.textAlignment = .center // navTitleLbl.frame = CGRect(x: 0, y: topSafeMargin, width: self.view.bounds.size.width, height: 44) // navBGView.addSubview(navTitleLbl) // navBGView.isHidden = false  let model = self.ePaperPresenter.ePapersModels[indexPath.row]  var url = self.ePaperPresenter.webConfig.webUrl  if let lowerBound = url.range(of: action)?.lowerBound {  url = String(url.prefix(upTo: lowerBound))  } </content>
    </entry>
    
     <entry>
        <title>AutoLayout</title>
        <url>https://iihui.github.io/post/ios-autolayout/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  苹果公司推出的AutoLayout是一个基于约束，动态计算视图大小和位置的库。它以布局引擎系统Layout Engine为核心，采用了Cassowary布局算法，在简化布局思路的同时，还保证了布局的高效性。布局算法Cassowary能够有效解析线性等式系统和线性不等式系统，用来表示用户界面中那些相等关系和不等关系，通过设定约束来表示一个视图相对于另一个视图的位置。
 原理 在Layout Engine中，每当约束发生变化，会重新计算布局，获取到布局后会调用superview.setNeedLayout()，然后触发Deffered Layout Pass做容错处理，然后Layout Engine会从上到下调用layoutSubviews()来确定各子视图的位置，算出来后将子视图的frame从Layout Engine中拷贝出来，然后进行绘制、渲染。
几个更新方法的区别
  setNeedsLayout 告知页面需要更新，但是不会立刻开始更新，也就是先做一个标记。
  layoutIfNeeded 如果有需要刷新的标记，立即调用layoutSubViews进行布局；如果没有标记，不会调用layoutSubbViews。如果希望立即刷新frame，要先调用setNeedsLayout，把标记为需要布局，然后马上调用layoutIfNeeded实现布局。
  layoutSubviews 对subviews进行布局，不能主动调用，需要的时候在子类中重写，系统会在合适的时候调用。
  setNeedsUpdateConstraints 告知需要更新约束，但是不会立刻开始，也就是先做一个标记，调用updateConstraintsIfNeeded会查看该标记。
  updateConstraintsIfNeeded 告知立刻更新约束，如果有需要刷新约束的标记，则立即更新，否则不更新约束。
  updateConstraints 系统更新约束？？？。
  系统调layoutSubviews时机   使用init初始化不会触发layoutSubviews，但是使用initWithFrame进行初始化且rect不为zero时会调用layoutSubviews。
  调用addSubview的时候会触发系统调用layoutSubviews。
  当view的frame发生改变时触发layoutSubviews调用。
  滚动一个UIScrollView会触发layoutSubviews调用。
  旋转屏幕会触发父UIView上的layoutSubviews事件。
  改变一个UIView大小的时候也会调用父UIView上的layoutSubviews事件。
  固有内容大小 Intrinsic content size 就是固有内容大小，对应的是intrinsicContentSize计算属性。实际上，可以通过继承可以重写UIView的固有内容大小，达到定制的目的：
class TestView: UIView {  override var intrinsicContentSize: CGSize {  return CGSize(width: 300, height: 800)  } } UITableView高度计算 自动计算 当布局满足self-satisfied（设置约束时，只有一个不确定时，例如高度）时，系统会自动计算高度，缺点时慢，因为没有缓存高度，每次都要计算一次。
//首先在viewDidLoad中cell预估高度,设一个接近cell高度的值 self.tableView.estimatedRowHeight = 100;  //然后在设置返回automaticDimension override func tableView(_ tableView:UITableView, heightForRawAt: indexPath IndexPath) -&amp;gt; CGFloat {  return UITableView.automaticDimension }  摘抄自这里
</content>
    </entry>
    
     <entry>
        <title>不常见的关键字</title>
        <url>https://iihui.github.io/post/ios-keywords/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  使用Swift写代码时，经常会遇到一些不常见的关键词或者常用关键词的特殊使用场景，因为比较少使用，通常这些不常见的关键词或者特殊场景很容易忘记。
 便利构造函数 关键字convenience用于初始化器（构造函数）中，称之为便利初始化器（构造函数）。通常是在对一些系统类进行扩展时使用，下面是对UIColor进行扩展：
extension UIColor {   convenience init(hex: String) {  var cString: String = hex.trimmingCharacters(in: .whitespacesAndNewlines).uppercased()   if (cString.hasPrefix(&amp;#34;#&amp;#34;)) {  cString.remove(at: cString.startIndex)  }   assert(cString.count == 6, &amp;#34;无效的hex值&amp;#34;)   var rgbValue: UInt64 = 0  Scanner(string: cString).scanHexInt64(&amp;amp;rgbValue)   self.init(  red: CGFloat((rgbValue &amp;amp; 0xFF0000) &amp;gt;&amp;gt; 16) / 255.0,  green: CGFloat((rgbValue &amp;amp; 0x00FF00) &amp;gt;&amp;gt; 8) / 255.0,  blue: CGFloat(rgbValue &amp;amp; 0x0000FF) / 255.0,  alpha: CGFloat(1.0)  )  } } Swift为了保证安全，不加修饰的init方法需要保证所有的非Optional的实例属性都被初始化。此时，如果想写一个自定义构造函数，就一定要把类型中所有的非Optional的实例属性初始化，如果类型中很多实例属性将会变得很麻烦。此时便利初始化器就发挥作用了，它通常在对系统类进行初始化器扩展时使用。
  必须在构造函数中，而且必须调用本类的初始化器，不能调用父类的初始化器。
  其本身不负责属性的创建和初始化工作。
  不能被重写。
  </content>
    </entry>
    
     <entry>
        <title>Keyboard Maestro 使用</title>
        <url>https://iihui.github.io/post/tool-maestro/</url>
        <categories>
          <category>tool</category>
        </categories>
        <tags>
          <tag>tool</tag>
        </tags>
        <content type="html">  Keyboard Maestro是一款神奇的软件，在我心里它与Alfred同样重要，也是装机必备软件。使用它可以省去安装很多软件，这篇文章记录平常工作中使用它的一些特性或技巧，以便后续查阅。
 快捷输入 粘贴方式输入 模拟键盘输入 打开应用 可以设置全局快捷键打开某个应用程序，下面设置了快捷键control&#43;s打开Safari：
开启和关闭wifi 如果想要开启和关闭wifi，可以使用如下的方式：
窗口管理 左半屏 右半屏 最大化 全屏 去格式粘贴 复制当前行 焦点 切换到屏幕一 切换到屏幕二 Execute a Script in Terminal 如果想要在系统的Terminal中运行脚本可以在这里下载压缩文件，然后把压缩文件代表的Action整体拖动到Keyboard Maestro中。
Imported action already exit 按照上面方式已经导入的Action，如果再重新导入的话会报Imported action already exists错误。那么需要到~/Library/Application Support/Keyboard Maestro/Keyboard Maestro Actions/目录下删除对应的Action，然后再重新导入。
Execute a Script in iTerm2 参考这里的代码，我自己写了一个AppleScript脚本，结合plist文件创建了Keyboard Maestro的Action，代码和文件如下所示：
# Description: Part of a KM action. Passes a command or script to the Terminal. # Author: Tom Floeren &amp;lt;ecdltf@mac.com&amp;gt;, http://dflect.net # Version: 1.0.1 # Mod. Date: 2017-01-17  (* set winFront to system attribute &amp;#34;KMPARAM_Bring_Terminal_to_foreground&amp;#34; set winNew to system attribute &amp;#34;KMPARAM_New_Terminal_window&amp;#34; set theScript to do shell script &amp;#34;echo $KMPARAM_Script&amp;#34;  if winNew is &amp;#34;1&amp;#34; then 	tell application &amp;#34;iTerm&amp;#34; 	launch 	do script theScript 	if winFront is &amp;#34;1&amp;#34; then activate 	end tell else 	tell application &amp;#34;iTerm&amp;#34; 	launch 	if winFront is &amp;#34;1&amp;#34; then activate 	set windowCount to (count of the windows) 	if windowCount is greater than 0 then 	repeat with w from 1 to windowCount 	if window 1 is busy or history of window 1 contains &amp;#34;[Process completed]&amp;#34; then 	set frontmost of window 1 to false 	else 	do script theScript in window 1 	set frontmost of window 1 to true 	return 	end if 	end repeat 	end if 	tell window 1 	do script theScript 	set frontmost to true 	end tell 	end tell end if *)  set theScript to do shell script &amp;#34;echo $KMPARAM_Script&amp;#34; # do shell script &amp;#34;echo deploy&amp;#34; set winFront to system attribute &amp;#34;KMPARAM_Bring_iTerm_to_foreground&amp;#34; # &amp;#34;1&amp;#34; set winNew to system attribute &amp;#34;KMPARAM_New_iTerm_window&amp;#34; # &amp;#34;1&amp;#34; if winNew is &amp;#34;1&amp;#34; then 	tell application &amp;#34;iTerm&amp;#34; 	launch 	create window with default profile 	tell current session of current window 	write text theScript 	#display dialog theScript 	end tell 	if winFront is &amp;#34;1&amp;#34; then activate 	end tell else 	tell application &amp;#34;iTerm&amp;#34; 	launch 	if winFront is &amp;#34;1&amp;#34; then activate 	set windowCount to (count of the windows) 	if windowCount is 0 then 	create window with default profile 	tell current session of current window 	write text theScript 	#display dialog theScript 	end tell 	return 	end if 	tell current session of current window 	write text theScript 	#display dialog theScript 	end tell 	end tell end if &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;!DOCTYPE plist PUBLIC &amp;#34;-//Apple//DTD PLIST 1.0//EN&amp;#34; &amp;#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd&amp;#34;&amp;gt; &amp;lt;plist version=&amp;#34;1.0&amp;#34;&amp;gt; &amp;lt;dict&amp;gt; 	&amp;lt;key&amp;gt;Name&amp;lt;/key&amp;gt; 	&amp;lt;string&amp;gt;Execute a Script in iTerm&amp;lt;/string&amp;gt; 	&amp;lt;key&amp;gt;Script&amp;lt;/key&amp;gt; 	&amp;lt;string&amp;gt;Action.scpt&amp;lt;/string&amp;gt; 	&amp;lt;key&amp;gt;Icon&amp;lt;/key&amp;gt; 	&amp;lt;string&amp;gt;Icon.png&amp;lt;/string&amp;gt; 	&amp;lt;key&amp;gt;Title&amp;lt;/key&amp;gt; 	&amp;lt;string&amp;gt;Execute ‘%Param%Script%’ in iTerm&amp;lt;/string&amp;gt; 	&amp;lt;key&amp;gt;Author&amp;lt;/key&amp;gt; 	&amp;lt;string&amp;gt;Tom Floeren&amp;lt;/string&amp;gt; 	&amp;lt;key&amp;gt;Help&amp;lt;/key&amp;gt; 	&amp;lt;string&amp;gt;Execute a script or a script file in the iTerm application.&amp;lt;/string&amp;gt; 	&amp;lt;key&amp;gt;Results&amp;lt;/key&amp;gt; 	&amp;lt;string&amp;gt;None&amp;lt;/string&amp;gt; 	&amp;lt;key&amp;gt;Parameters&amp;lt;/key&amp;gt; 	&amp;lt;array&amp;gt; 	&amp;lt;dict&amp;gt; 	&amp;lt;key&amp;gt;Label&amp;lt;/key&amp;gt; 	&amp;lt;string&amp;gt;Script&amp;lt;/string&amp;gt; 	&amp;lt;key&amp;gt;Type&amp;lt;/key&amp;gt; 	&amp;lt;string&amp;gt;Text&amp;lt;/string&amp;gt; 	&amp;lt;key&amp;gt;Default&amp;lt;/key&amp;gt; 	&amp;lt;string&amp;gt;&amp;lt;/string&amp;gt; 	&amp;lt;/dict&amp;gt; 	&amp;lt;dict&amp;gt; 	&amp;lt;key&amp;gt;Label&amp;lt;/key&amp;gt; 	&amp;lt;string&amp;gt;New iTerm window&amp;lt;/string&amp;gt; 	&amp;lt;key&amp;gt;Type&amp;lt;/key&amp;gt; 	&amp;lt;string&amp;gt;Checkbox&amp;lt;/string&amp;gt; 	&amp;lt;key&amp;gt;Default&amp;lt;/key&amp;gt; 	&amp;lt;string&amp;gt;1&amp;lt;/string&amp;gt; 	&amp;lt;/dict&amp;gt; 	&amp;lt;dict&amp;gt; 	&amp;lt;key&amp;gt;Label&amp;lt;/key&amp;gt; 	&amp;lt;string&amp;gt;Bring iTerm to foreground&amp;lt;/string&amp;gt; 	&amp;lt;key&amp;gt;Type&amp;lt;/key&amp;gt; 	&amp;lt;string&amp;gt;Checkbox&amp;lt;/string&amp;gt; 	&amp;lt;key&amp;gt;Default&amp;lt;/key&amp;gt; 	&amp;lt;string&amp;gt;1&amp;lt;/string&amp;gt; 	&amp;lt;/dict&amp;gt; 	&amp;lt;/array&amp;gt; &amp;lt;/dict&amp;gt; &amp;lt;/plist&amp;gt; </content>
    </entry>
    
     <entry>
        <title>git 使用</title>
        <url>https://iihui.github.io/post/tool-git/</url>
        <categories>
          <category>tool</category>
        </categories>
        <tags>
          <tag>git</tag>
        </tags>
        <content type="html"> 清理文件 如果本地.git文件太大，可以使用git gc命令清理不必要的文件并优化本地存储库，其中gc是garbage collection的缩写:
git gc [--aggressive] [--auto] [--quiet] [--prune=&amp;lt;date&amp;gt; | --no-prune] [--force] [--keep-largest-pack] 大小写敏感 默认情况下git追踪的项目对文件名大小写是不敏感的，但是git提供了命令使得当前项目或者所有项目都能区分文件名的大小写。
如果只需要对当前项目设置文件名大小写敏感。首先打开终端，利用cd命令，将目录切换到需要修改的git仓库下，输入如下命令使其对文件名大小写敏感：
git config core.ignorecase false 如果想要所有项目都对文件名大小写敏感，就需要进行全局设置。执行如下命令，就能改变git的全局设置，使得文件名大小写是敏感的：
git config --global core.ignorecase false errno 54 使用pod install时报了error: RPC failed; curl 56 LibreSSL SSL_read: SSL_ERROR_SYSCALL, errno 54错误，如下图所示：
原因是在拉取大文件时，设置的缓存太小，因此需要加大缓存。缓存设置包括http和https两种，具体设置使用如下命令：
git config --global http.postBuffer 1048576000 git config --global https.postBuffer 1048576000 rebase 整合来自不同分支的修改主要有两种方法，一种是Merge，一种是rebase。Merge会把两个分支的最新快照（C3和C4），以及二者最近的共同祖先（C2）进行三方合并，合并的结果是生成一个新的快照并提交。
还有一种方法：可以提取在C4中引入的补丁和修改，然后在C3的基础上应用一次。 在 Git中，这种操作就叫做「变基」（rebase）。 可以使用rebase命令将提交到某一分支上的所有修改都移至另一分支上。在上面的例子中，可以检出 experiment 分支，然后将它变基到 master 分支上：
git checkout experiment git rebase master 它的原理是首先找到这两个分支（即当前分支experiment、变基操作的目标基底分支master） 的最近共同祖先 C2，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件，然后将当前分支指向目标基底 C3, 最后以此将之前另存为临时文件的修改依序应用：
SourceTree中使用rebase
Device not Configured 因为修改了git密码，在PyCharm中运行脚本拉取代码时报错：could not find Username for ... Device not configured。此时需要使用交互式的命令行，再输入用户名和密码，比如使用git push命令：
[ruby-2.7.2]~/Documents/Code/Modules/LC10_01_MoCore:517 ✓ ➭ git push Username for &amp;#39;http://xxx&amp;#39;: xxx Password for &amp;#39;http://xxx&amp;#39;: Everything up-to-date 更改ssh方式 今天往github推送代码时，出现了报错：Support for password authentication was removed on August 13。详细提示如下所示:
nothing to commit, working tree clean remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead. remote: Please see https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/ for more information. fatal: unable to access &amp;#39;https://github.com/xxx/xxx.git/&amp;#39;: The requested URL returned error: 403 于是按照官方文档添加SSH Key，并添加到github，再push代码的时候依然报错。切到工程目录，使用git remote -v命令，发现原仓库clone的时候是HTTPS方式。需要使用git remote set-url 命令切换到SSH方式：
git remote -v git remote set-url origin git@github.com:username/repo.git 修改commit时间 有时需要自定义或者修改commit的时间，如果想要修改当前本地待提交commit的时间，可以使用如下命令：
git commit --amend --date=&amp;#34;2022-01-01T00:00:00&#43;0800&amp;#34; -am &amp;#34;update&amp;#34; 如果需要修改之前提交的某次commit时间，首先通过git log获取提交的id，然后执行如下命令：
git commit --amend --date=&amp;#34;2022-01-01T00:00:00&#43;0800&amp;#34; -C 02219d93287a939c4fd7b4678c7e87b369ae0961 对于之前已经提交到远程仓库的提交，需要再执行一次git push推送到远程仓库。
exited with 128 执行 brew tap homebrew/core命令时出现如下报错，需要用户主目录下的.bash_profile文件中添加export PATH=/opt/homebrew/bin:$PATH才能解决：
=&amp;gt; Tapping homebrew/core Cloning into &amp;#39;/usr/local/Homebrew/Library/Taps/homebrew/homebrew-core&amp;#39;... fatal: unable to access &amp;#39;https://github.com/Homebrew/homebrew-core/&amp;#39;: HTTP/2 stream 1 was not closed cleanly before end of the underlying stream Error: Failure while executing; `git clone https://github.com/Homebrew/homebrew-core /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core --origin=origin --template=` exited with 128 参考资料
homebrew/core 使用 brew tap homebrew/core命令修复时出现Cannot tap homebrew/core: invalid syntax in tap
Cloning into &amp;#39;/usr/local/Homebrew/Library/Taps/homebrew/homebrew-core&amp;#39;... remote: Enumerating objects: 1227237, done. remote: Counting objects: 100% (67/67), done. remote: Compressing objects: 100% (38/38), done. remote: Total 1227237 (delta 37), reused 58 (delta 29), pack-reused 1227170 Receiving objects: 100% (1227237/1227237), 499.01 MiB | 1.23 MiB/s, done. Resolving deltas: 100% (847288/847288), done. Error: Invalid formula: /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core/Formula/libgccjit.rb libgccjit: undefined method `on_arm&amp;#39; for #&amp;lt;Class:0x00007fdaadec9110&amp;gt; Error: Cannot tap homebrew/core: invalid syntax in tap! 参考资料
</content>
    </entry>
    
     <entry>
        <title>pcm No such file or directory</title>
        <url>https://iihui.github.io/post/ios-pcm-warnning/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  在封装静态framework时，在本机上没有报任何警告，在其他机器上却报warning: ***/Library/Developer/Xcode/DerivedData/ModuleCache.noindex/2MSIKR0H4Y5WQ/Foundation-A3SOD99KJ0S9.pcm: No such file or directory 警告。这篇文章就是解决这个警告问题，主要是改变工程的build setting有三个地方需要修改，暂且归为三步。
 第一步 首先在Build Settings中将Enable Bitcode设置为No，如下图所示：
第二步 然后在Build Settings中将Debug Information Format下的Debug设置为DWARF，如下图所示： 第三步 最后将Precompile Prefix Header设置为NO，如下图所示：  下面是国密封装设置
</content>
    </entry>
    
     <entry>
        <title>CLion 添加Google test</title>
        <url>https://iihui.github.io/post/clion-test/</url>
        <categories>
          <category>Code</category>
        </categories>
        <tags>
          <tag>CLion</tag>
        </tags>
        <content type="html">  首先在github下载最新的googletest，解压之后重命名为googletest。然后将其放入到CLion工程目录下，接着修改工程的CMakeList.txt文件。最后，修改main函数，编写单元测试用例。
 下载 在github下载最新的googletest，解压之后命名为googletest，然后将其放在工程目录下：
修改CMkeLists 接着修改CMakeLists.txt文件，使其将googletest纳入到工程中，以供使用：
cmake_minimum_required(VERSION 3.15) project(test)  set(CMAKE_CXX_STANDARD 14)  set(googleTestDir ./googletest)  #Add the google test subdirectory add_subdirectory(${googleTestDir}) #include googletest/include dirinclude_directories(${googleTestDir}/googletest/include) #include the googlemock/include dirinclude_directories(${googleTestDir}/googlemock/include)  set(SOURCE_FILE main.cpp) add_executable(test ${SOURCE_FILE})  # Link with GoogleTest target_link_libraries(test gtest gtest_main) #Link with GoogleMock target_link_libraries(test gmock gmock_main) 修改main.cpp CLion重新加载CMakeLists.txt文件未报错之后，开始按下面修改main.cpp文件：
#include &amp;lt;iostream&amp;gt;#include &amp;#34;gtest/gtest.h&amp;#34;int main(int argc, char** argv) {  testing::InitGoogleTest(&amp;amp;argc, argv);  return RUN_ALL_TESTS(); } 单元测试 最后按照googletest的语法规则编写测试用例，如下所示：
#include &amp;lt;iostream&amp;gt;#include &amp;#34;gtest/gtest.h&amp;#34; int add(int a, int b){  return a&#43;b; }  TEST(test1, add){  EXPECT_EQ(3, add(1,2));  EXPECT_EQ(0, add(-1,1)); }  int main(int argc, char** argv) {  testing::InitGoogleTest(&amp;amp;argc, argv);  return RUN_ALL_TESTS(); }  参考资料 参考资料
</content>
    </entry>
    
     <entry>
        <title>where 关键字</title>
        <url>https://iihui.github.io/post/ios-where/</url>
        <categories>
          <category>ios</category>
        </categories>
        <tags>
          <tag>swift</tag><tag>ios</tag>
        </tags>
        <content type="html">  Swift中的where关键字主要用于限定条件，既可在switch语句中使用，也可以在for中使用，还可以用在扩展中用于限定应该遵循某种协议。
 switch中 在switch语句中使用，where一般是配合if let来用于限定某些条件，例如：
let names = [&amp;#34;dog&amp;#34;, &amp;#34;cat&amp;#34;, &amp;#34;fish&amp;#34;, &amp;#34;bigDog&amp;#34;, &amp;#34;bigCat&amp;#34;, &amp;#34;bigFish&amp;#34;] names.forEach {  switch $0 {  case let name where name.hasPrefix(&amp;#34;big&amp;#34;):  print(&amp;#34;wow this is a \(name)&amp;#34;)  default:  break  } }  for 循环中 在for in使用，也是用于添加限定条件(过滤)，同filter函数具有相同的效果，如下所示：
let names = [&amp;#34;dog&amp;#34;, &amp;#34;cat&amp;#34;, &amp;#34;fish&amp;#34;, &amp;#34;bigDog&amp;#34;, &amp;#34;bigCat&amp;#34;, &amp;#34;bigFish&amp;#34;] for name in names where name == &amp;#34;dog&amp;#34; {  print(&amp;#34;\(name)&amp;#34;) }  接口扩展中 在扩展中使用where，目的也是进行限定，即希望扩展需要满足某些限定的条件下才可以用，如下所示:
extension ContiguousArray where Element: BidirectionalCollection {  public func joined() -&amp;gt; FlattenBidirectionalCollection&amp;lt;ContiguousArray&amp;lt;Element&amp;gt;&amp;gt; }  extension ContiguousArray where Element: Sequence {  public func joined&amp;lt;Separator&amp;gt;(separator: Separator) -&amp;gt; JoinedSequence&amp;lt;ContiguousArray&amp;lt;Element&amp;gt;&amp;gt; where Separator: Sequence, Separator.Element == Element.Element }  extension Array where Element: Comparable {  public var isSorted: Bool {  var preIndex = startIndex  var curIndex = startIndex &#43; 1   while curIndex != endIndex {  if self[preIndex] &amp;gt; self[curIndex] {  return false  }  preIndex = curIndex  curIndex &#43; 1  }  return true  } }  参考资料
</content>
    </entry>
    
     <entry>
        <title>Swift 方法交换中的addMethod</title>
        <url>https://iihui.github.io/post/ios-addmethod/</url>
        <categories>
          <category>Swift</category><category>iOS</category>
        </categories>
        <tags>
          <tag>Swift</tag><tag>iOS</tag>
        </tags>
        <content type="html">  Swizzle是OC的黑魔法之一，可以在运行时对两个方法的实现进行交换，也就是s用户可以用自己的方法替换原来的方法实现，做一些其它事情。Swift也可以使用运行时的方法交换，如果要了解Swift的方法交换，首先应该了解class_addMethod这个方法的作用。
 class_addMethod 要了解class_addMethod方法的作用，首先看下面的这段代码，在下面的代码中直接交换了originalSelector和swizzledSelector
extension NSObject {  static func swizzlingForClass(_ forClass: AnyClass, originalSelector: Selector, swizzledSelector: Selector) {  guard let originalMethod = class_getInstanceMethod(forClass, originalSelector),  let swizzledMethod = class_getInstanceMethod(forClass, swizzledSelector) else {  return  }  method_exchangeImplementations(originalMethod, swizzledMethod)  } } 存在的问题 假设父类名为method的方法，子类未重写这个method方法，子类的中想要用来交换的方法为swizzledMethod。如果按照上面的方法交换时，因为父类有该方法，而子类未重写该方法，所以调用class_getInstanceMethod得到的是父类的method方法，所以它与子类的swizzledMethod方法进行交换需要分两种情形来讨论：
  如果在子类实例中调用method方法时，因为已经与自己的swizzledMethod方法交换，所以实际上调用的自己swizzledMethod，所以能够正常运行。
  如果在父类的实例中调用method方法，因为已经与子类的swizzledMethod方法交换，所以调用的是子类的swizzledMethod方法。也就是说此时是父类调用子类的方法，所以会崩溃。
  根据上面的讨论，首先应该判断子类是否重写了method方法，如果实重写了父类的该方法则直接进行交换。如果没有重写父类的该方法，则应该先在父类中新建一个同名的方法。为了新建一个同名的方法，首先应当了解class_addMethod这个函数。
完善的方案 根据上面的分析，先来看一下class_addMethod的函数原型，如下所示：
@available(iOS 2.0, *) public func class_addMethod(_ cls: AnyClass?, _ name: Selector, _ imp: IMP, _ types: UnsafePointer&amp;lt;Int8&amp;gt;?) -&amp;gt; Bool 这个方法的作用是在一个类中添加一个新方法(名字&#43;实现）,class_addMethod函数中参数的含义为下：
  cls表示需要添加方法的类
  name表示要添加的方法的selector（方法名，这里的方法名是一个结构体）
  imp 表示要添加的方法的实现的指针IMP（定义在这里)）
  types用来描述方法参数的字符串数组
  如果cls中含有name则添加失败，返回false。这个方法会重写cls父类中与name同名的方法，但是不会替换cls中已经存在的与cls同名的方法。但是，如果想要替换cls中与name同名的方法，应该调用method_setImplementation。
  因此，可以使用class_addMethod方法的返回值来确定当前类中是否存在能够交换的方法，如果存在(添加失败)则直接交换。
let didAddMethod: Bool = class_addMethod(object, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)) 上面的代码中如果didAddMethod返回为false，则说明可以直接进行方法交换，如果返回值为true，则说明在子类中添加originalSelector成功，并且originalSelector指向了子类的swizzledMethod的实现。但是swizzledSelector的实现还是它原来的实现，接下来就要将swizzledSelector指向originalMethod的实现。因此，完整的代码应该如下所示：
static func exchangeSelector(object:AnyClass,originalSelector: Selector, swizzledSelector: Selector) {  guard let originalMethod = class_getInstanceMethod(object, originalSelector) else {  return  }  guard let swizzledMethod = class_getInstanceMethod(object, swizzledSelector) else {  return  }  let didAddMethod: Bool = class_addMethod(object, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod))   if didAddMethod {  class_replaceMethod(object, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod))  } else {  method_exchangeImplementations(originalMethod, swizzledMethod)  } } 构建工具类 因为当前App埋点的时候很多地方需要使用到方法交换，因此决定写一个专门的工具类来实现Swift的方法交换，如下所示：
class MethodSwizzlingTools {  static func exchangeSelector(object: AnyClass, originalSelector: Selector, swizzledSelector: Selector) {  //对于class_getInstanceMethod方法，若类没有实现对应的方法，但父类实现了，则这个函数会返回父类的方法  guard let originalMethod = class_getInstanceMethod(object, originalSelector) else {  return  }  guard let swizzledMethod = class_getInstanceMethod(object, swizzledSelector) else {  return  }   //参考https://juejin.im/post/5cb6df44e51d456e6f45c6f1  let didAddMethod: Bool = class_addMethod(object, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod))   if didAddMethod {  class_replaceMethod(object, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod))  } else {  method_exchangeImplementations(originalMethod, swizzledMethod)  }  }   //交换两个不同类的方法，这两个类应该满足父子关系  static func exchangeSelector(originalClass: AnyClass, originalSelector: Selector, swizzledClass: AnyClass, swizzledSelector: Selector) {  guard let originalMethod = class_getInstanceMethod(originalClass, originalSelector), let swizzledMethod = class_getInstanceMethod(swizzledClass, swizzledSelector) else {  return  }   let didAddMethod: Bool = class_addMethod(originalClass, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod))   if didAddMethod {  class_replaceMethod(swizzledClass, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod))  } else {  method_exchangeImplementations(originalMethod, swizzledMethod)  }  } } 参考资料 参考资料
</content>
    </entry>
    
     <entry>
        <title>Any,AnyObject,AnyClass</title>
        <url>https://iihui.github.io/post/ios-any/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>swift</tag><tag>iOS</tag>
        </tags>
        <content type="html">  最近在看Swift中的方法交换，遇到Any、AnyObject与AnyClass次数较多，所以在网上找了一些文章看了一下他们的区别，以此篇为记。
 AnyObject AnyObject类似于OC中的id类型，表示任意的class类型。但在Swift中由于String、Array等都变成结构体了，AnyObject的适用范围就变窄了。
实际上AnyObject是一个成员为空的协议@objc public protocol AnyObject {}。它注释的第一行:The protocol to which all classes implicitly conform表明所有的类都隐式遵守了这个协议。
Any Any也是一个协议，根据其注释The protocol to which all types implicitly conform.表明所有的类型都遵守该协议，包括基本数据类型，enum, struct, func等等。因此Any可以表示任何类型的实例，包括函数类型
AnyClass 而AnyClass表示任意类的元类型，其定义为typealias AnyClass = AnyObject.Type。根据定义可知它为AnyObject.Type的别名。
AnyObject.Type中的.Type就是获取元类型。例如，对于Student类，Student.Type就是获取Student的元类型。再根据注释The protocol to which all class types implicitly conform，可知道所有的类的类型都隐式遵守这个协议。
self 于Self 在Swift中，.self可以用在类型后面取得类型本身，也可以在某个实例后面取得这个实例本身。定义协议的时候经常会使用Self，它不仅指代的是实现该协议的类型本身，也包括了这个类型的子类。
重要区别 AnyObject代表任意class类型的对象实例，Any代表任意类型，甚至包括方法类型，所以AnyObject是Any的子集。
类型转换 操作符is检查一个实例是否某个确定的类或者其子类类型，如果是则返回true，否则返回false。
class Cat {  func hairColor() -&amp;gt; String {  return &amp;#34;五颜六色&amp;#34;  } } class WhiteCat: Cat {  override func hairColor() -&amp;gt; String {  return &amp;#34;白色&amp;#34;  } } class BlackCat: Cat {  override func hairColor() -&amp;gt; String {  return &amp;#34;黑色&amp;#34;  } } //必须符合`Cat`类以及其子类，类型推断需要 let kinds = [WhiteCat(),BlackCat(),WhiteCat(),WhiteCat()] for item in kinds {  if item is WhiteCat {  print(&amp;#34;白猫&amp;#34;)// 3次  }  if item is BlackCat {  print(&amp;#34;黑猫&amp;#34;)// 1次  }  if item is Cat {  print(&amp;#34;猫&amp;#34;)// 4次  } } 向下转换 某个类型的常量或变量可能是其子类的实例，此时需要用到类型转换操作as？或as!向下转换为子类类型
  as?：类型转换的条件形式，向下转换为某个类型时，返回该类型的可选值，即转换失败时返回nil。
  as!：类型转换的强制形式，向下转换为某个类型时，会进行强制解包，即：转换失败时触发运行时错误。除非十分确定类型转换会成功，否则不建议使用该模式。
  参考资料 参考资料 参考资料
</content>
    </entry>
    
     <entry>
        <title>UIControl</title>
        <url>https://iihui.github.io/post/ios-uicontrol/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  UIControl是UIView的子类，也是UIResponder的子类。是UIButton，UISwitch，UITextField等控件的父类。它本身定义了一些属性和方法，但是不能直接使用。
 方法交换 extension UIControl {  class func swizzleMethod() {  struct Static {  static var token = NSUUID().uuidString  }   // 确保不是子类  if self != UIControl.self {  return  }  // 防止手动调用，造成交换多次  DispatchQueue.once(token: Static.token) {  MethodSwizzlingTools.exchangeSelector(object: self, originalSelector: #selector(UIControl.sendAction(_:to:for:)), swizzledSelector: #selector(userSendAction(_:to:for:)))  }  }   @objc func userSendAction(_ action: Selector, to target: Any?, for event: UIEvent?) {  self.userSendAction(action, to: target, for: event)  } </content>
    </entry>
    
     <entry>
        <title>Swift 中的反射</title>
        <url>https://iihui.github.io/post/ios-reflection/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>swift</tag><tag>iOS</tag>
        </tags>
        <content type="html">  reflection是指计算机程序在runtime时可以访问、检测和修改它本身状态或行为的一种能力。比较形象的说法就是，反射是程序在运行的时候能够观察并且修改自己的行为。
 @objc Swift是一门静态语言，和OC不同，不能在运行时做很多复杂的操作。Swift虽然不能像OC一样在运行时做很多事，但是还是做一些小动作，比如和Java类似的反射机制等。
标记@objc，可以用来标记函数和类、协议等等。这个标记表示该方法或者该类可以被用于运行时。例如，在Swift中类似按钮点击的selector都必须用@objc标记，表示该方法是运行时调用（按钮点击是运行时事件，编译器在编译时对没有调用到的非运行时函数会优化掉）。
在Swift 4之后的版本里，类继承 NSObjct不会再默认带@objc 标记，当重写NSObjct编辑器会自动提示带上@objc。
除了上面用@objc标记这种方法外，还可以通过Reflection来实现一些诸如运行时获取类型、成员信息，调用任意方法等行为。Reflection主要使用Mirror这个结构体来做一些事情。
Swift反射 Swift的反射机制是基于一个叫Mirror的Stuct来实现的。具体的操作方式为：首先创建一个你想要反射的类的实例，再传给Mirror的构造器来实例化一个Mirror对象，最后使用这个Mirror来获取你想要的东西。
尽管Swift一直都在强调强类型、编译时安全并推荐使用静态调度，但它的标准库仍然提供了一个基于Mirror的Struct来实现的反射机制。简单来说，例如你有一个Class A并创建了一个A的实例对象a，此时你就可以通过Mirror(reflecting: a)来生成一个Mirror对象m，然后遍历m.children就可以获取到a对象的所有属性：
// // main.swift import Foundation  protocol Drive {  func run() }  public class Tire { //轮胎  var brand: String? //品牌  var size: Float = 0 //大小 }  public class Vehicle: Drive {  var carType: String?  var tires: [Tire]?  var host: String?// 主人  var brand: String?//汽车品牌   func run() {  if let h = host {  print(&amp;#34;\(h)Drive a \(brand)\(carType)car run&amp;#34;)  } else {  print(&amp;#34;this car is not selled&amp;#34;)  }  } }  public class Trunk: Vehicle {  public var packintBox: String? }  public struct TranGroup { //货运集团  var trunks = {  return [Trunk]()  }()   var country: String?  var turnover: Float? }  //一个中国的货运集团 var tranGroup = TranGroup()  tranGroup.country = &amp;#34;天朝&amp;#34; tranGroup.turnover = 2222 let trunk1 = Trunk() trunk1.brand = &amp;#34;MAN&amp;#34; trunk1.host = &amp;#34;Stan&amp;#34; trunk1.packintBox = &amp;#34;Big And Long&amp;#34; tranGroup.trunks.append(trunk1) let mirrorTran = Mirror(reflecting: tranGroup) print(tranGroup) //打印出 TranGroup 相关信息 print(mirrorTran.subjectType) //打印出 TranGroup print(mirrorTran.displayStyle) //Optional(Swift.Mirror.DisplayStyle.Struct)，是个Struct类型 print(mirrorTran.superclassMirror) //nil，因为没有父类 for (key, value) in mirrorTran.children {  print(&amp;#34;\(key): \(value)&amp;#34;) }  //打印结果 TranGroup(trunks: [test.Trunk], country: Optional(&amp;#34;天朝&amp;#34;), turnover: Optional(2222.0)) TranGroup Optional(Swift.Mirror.DisplayStyle.struct) nil Optional(&amp;#34;trunks&amp;#34;) : [test.Trunk] Optional(&amp;#34;country&amp;#34;) : Optional(&amp;#34;天朝&amp;#34;) Optional(&amp;#34;turnover&amp;#34;) : Optional(2222.0) </content>
    </entry>
    
     <entry>
        <title>KVC 键值编码</title>
        <url>https://iihui.github.io/post/ios-kvc/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag><tag>oc</tag>
        </tags>
        <content type="html">  KVC(Key Value Coding)键值编码，指允许通过Key名字来直接访问对象的属性，而不需要调用明确的存取方法。这样，便能在运行时动态地访问和修改对象的属性值。在iOS中，无论是Swift还是OC，KVC都是通过对NSObject的扩展来实现的。所以，继承了NSObject的类型的对象都能使用KVC。
 KVC KVC是一种通过字符串间接访问对象的属性的方法，而不是通过调用存取方法（setter/getter）来获取属性，下面是KVC最为重要的四个方法：
- (nullable id)valueForKey:(NSString *)key; //直接通过Key(NSString属性的名字)来取值 - (void)setValue:(nullable id)value forKey:(NSString *)key; //通过Key(NSString属性的名字)来设值 - (nullable id)valueForKeyPath:(NSString *)keyPath; //通过KeyPath(xx.xx)来取值 - (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath; //通过KeyPath(xx.xx)来设值 寻找Key机制 在赋值和取之的时候都要先寻找Key，但这两者在寻找Key的方式是有区别的，接下来一一说明它们寻找Key的机制。
设置值 当调用setValue：属性值 forKey：@”name“，来设置值时，底层的执行机制如下：
  程序优先调用set&amp;lt;Key&amp;gt;:属性值方法，代码通过setter方法完成设置。这里的Key是指成员变量名，而不是forKey表示的值。
  如果没有找到setName:方法，KVC机制会检查&#43; (BOOL)accessInstanceVariablesDirectly方法有没有返回YES（默认返回）。如果重写了该方法并返回NO的话，那么接下来执行setValue：forUndefinedKey方法，不过一般开发者不会这么做。所以KVC机制会搜索该类里面有没有名为_&amp;lt;key&amp;gt;的成员变量，无论该变量是在类接口处定义，还是在类实现处定义，也无论用了什么样的访问修饰符，只在存在以_&amp;lt;key&amp;gt;命名的变量，KVC都可以对该成员变量赋值。
  如果该类既没有set&amp;lt;key&amp;gt;方法，也没有_&amp;lt;key&amp;gt;成员变量，KVC机制会搜索_is&amp;lt;Key&amp;gt;的成员变量。
  如果该类既没有set&amp;lt;Key&amp;gt;方法，也没有_&amp;lt;key&amp;gt;和_is&amp;lt;Key&amp;gt;成员变量，KVC机制再会继续搜索是否存在&amp;lt;key&amp;gt;和is&amp;lt;Key&amp;gt;的成员变量，再给它们赋值。
  如果上面列出的方法或者成员变量都不存在，系统将会执行该对象的setValue：forUndefinedKey方法，默认是抛出异常。
  如果想让这个类禁用KVC，只要重写&#43; (BOOL)accessInstanceVariablesDirectly方法，并让它返回NO即可。
@interface Dog : NSObject @end @implementation Dog {  NSString* toSetName;  NSString* isName;  //NSString* name;  NSString* _name;  NSString* _isName; } // -(void)setName:(NSString*)name{ // toSetName = name; // } //-(NSString*)getName{ // return toSetName; //} &#43;(BOOL)accessInstanceVariablesDirectly{  return NO; } -(id)valueForUndefinedKey:(NSString *)key{  NSLog(@&amp;#34;出现异常，该key不存在%@&amp;#34;,key);  return nil; } -(void)setValue:(id)value forUndefinedKey:(NSString *)key{  NSLog(@&amp;#34;出现异常，该key不存在%@&amp;#34;,key); } @end int main(int argc, const char * argv[]) {  @autoreleasepool {  // insert code here...  Dog* dog = [Dog new];  [dog setValue:@&amp;#34;newName&amp;#34; forKey:@&amp;#34;name&amp;#34;];  NSString* name = [dog valueForKey:@&amp;#34;toSetName&amp;#34;];  NSLog(@&amp;#34;%@&amp;#34;,name);  }  return 0; } 上面代码的输出为：
2020-02-15 09:33:48.596397&#43;0800 test[52035:3057928] 出现异常，该key不存在name 2020-02-15 09:33:48.596949&#43;0800 test[52035:3057928] 出现异常，该key不存在toSetName 2020-02-15 09:33:48.596987&#43;0800 test[52035:3057928] (null) 这是因为重写了&#43;(BOOL)accessInstanceVariablesDirectly，并让它返回了NO之后，KVC不再去找name系列成员变量，而是直接调用setValue：forUndefinedKey：。所以如果不想让自定义的类实现KVC，则可以像上面那样做。
如果将下面的注释取消：
 -(void)setName:(NSString*)name{  toSetName = name;  } -(NSString*)getName{  return toSetName; } 并将NSString* name = [dog valueForKey:@&amp;quot;toSetName&amp;quot;]; 换成 NSString* name = [dog valueForKey:@&amp;quot;name&amp;quot;]; 就可以得到正确的结果了：
2020-02-15 09:59:52.961889&#43;0800 test[52736:3072979] newName 根据上面的寻找机制，按照如下修改，仍然可以设置name的值：
#import &amp;#34;Dog.h&amp;#34;  @implementation Dog {  NSString* toSetName;  NSString* isName;  //NSString* name;  NSString* _name;  NSString* _isName; } // -(void)setName:(NSString*)name{ // toSetName = name; // } //-(NSString*)getName{ // return toSetName; //} &#43;(BOOL)accessInstanceVariablesDirectly{  return YES; } -(id)valueForUndefinedKey:(NSString *)key{  NSLog(@&amp;#34;出现异常，该key不存在%@&amp;#34;,key);  return nil; } -(void)setValue:(id)value forUndefinedKey:(NSString *)key{  NSLog(@&amp;#34;出现异常，该key不存在%@&amp;#34;,key); } @end  #import &amp;lt;Foundation/Foundation.h&amp;gt; #import &amp;#34;Dog.h&amp;#34;  int main(int argc, const char * argv[]) {  @autoreleasepool {  // insert code here...  Dog * dog = [Dog new];  [dog setValue:@&amp;#34;newName&amp;#34; forKey:@&amp;#34;name&amp;#34;];  NSString* name = [dog valueForKey:@&amp;#34;name&amp;#34;];  NSLog(@&amp;#34;%@&amp;#34;,name);  }  return 0;  } 打印的结果如下所示：
2020-02-15 10:09:25.756648&#43;0800 test[52930:3077204] newName 取值 当调用valueForKey：@”name“的代码时，KVC对key的搜索方式不同于setValue：属性值 forKey：@”name“，其搜索方式如下：
  首先按get&amp;lt;Key&amp;gt;,&amp;lt;key&amp;gt;,is&amp;lt;Key&amp;gt;的顺序方法查找getter方法，找到的话会直接调用。如果是BOOL或者Int等值类型， 会将其包装成一个NSNumber对象。
  如果上面的getter没有找到，KVC则会查找countOf&amp;lt;Key&amp;gt;,objectIn&amp;lt;Key&amp;gt;AtIndex或&amp;lt;Key&amp;gt;AtIndexes格式的方法。如果countOf&amp;lt;Key&amp;gt;方法和另外两个方法中的一个被找到，那么就会返回一个可以响应NSArray所有方法的代理集合(它是NSKeyValueArray，为NSArray的子类)，调用这个代理集合的方法，或者说给这个代理集合发送属于NSArray的方法，就会以countOf&amp;lt;Key&amp;gt;,objectIn&amp;lt;Key&amp;gt;AtIndex或&amp;lt;Key&amp;gt;AtIndexes这几个方法组合的形式调用。还有一个可选的get&amp;lt;Key&amp;gt;:range:方法。所以你想重新定义KVC的一些功能，你可以添加这些方法，需要注意的是你的方法名要符合KVC的标准命名方法，包括方法签名。
  如果上面的方法没有找到，那么会同时查找countOf&amp;lt;Key&amp;gt;，enumeratorOf&amp;lt;Key&amp;gt;,memberOf&amp;lt;Key&amp;gt;格式的方法。如果这三个方法都找到，那么就返回一个可以响应NSSet所的方法的代理集合，和上面一样，给这个代理集合发NSSet的消息，就会以countOf&amp;lt;Key&amp;gt;，enumeratorOf&amp;lt;Key&amp;gt;,memberOf&amp;lt;Key&amp;gt;组合的形式调用。
  如果还没有找到，再检查类方法&#43;(BOOL)accessInstanceVariablesDirectly,如果返回YES(默认行为)，那么和先前的设值一样，会按_&amp;lt;key&amp;gt;,_is&amp;lt;Key&amp;gt;,&amp;lt;key&amp;gt;,is&amp;lt;Key&amp;gt;的顺序搜索成员变量名，这里不推荐这么做，因为这样直接访问实例变量破坏了封装性，使代码更脆弱。如果重写了类方法&#43; (BOOL)accessInstanceVariablesDirectly返回NO的话，那么会直接调用valueForUndefinedKey:
  还没有找到的话，调用valueForUndefinedKey:
  KeyPath 一个类的成员变量有可能是自定义类或其他的复杂数据类型，可以先用KVC获取该属性，然后再次用KVC来获取这个自定义类的属性，但这样是比较繁琐的。因此，KVC提供了一个解决方案，那就是键路径keyPath。
KeyPath，表示键路径，是一个由点作分隔符的键组成的字符串（点语法），用于表示一个连接在一起的对象序列。其中，后一个键的性质是由前一个键的性质决定的（如同现代面向对象语言取成员）。所以，KVC对于keyPath是搜索机制第一步就是分离key，用小数点.来分割key，然后再像普通key一样按照先前介绍的顺序搜索下去。
有了键路径，就可以不通过相应的方法来直接取相关的性质（属性/方法）。通过键路径，可以指定对象中的一个任意深度的路径，使其指向相关对象的特定属性。
- (nullable id)valueForKeyPath:(NSString *)keyPath; //通过KeyPath来取值 - (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath; //通过KeyPath来设值 下面是一个例子：
@interface Address : NSObject  @end @interface Address() @property (nonatomic,copy)NSString* country; @end @implementation Address @end @interface People : NSObject @end @interface People() @property (nonatomic,copy) NSString* name; @property (nonatomic,strong) Address* address; @property (nonatomic,assign) NSInteger age; @end @implementation People @end int main(int argc, const char * argv[]) {  @autoreleasepool {  People* people1 = [People new];  Address* addr = [Address new];  addr.country = @&amp;#34;China&amp;#34;;  people1.address = addr;  NSString* country1 = people1.address.country;  NSString * country2 = [people1 valueForKeyPath:@&amp;#34;address.country&amp;#34;];  NSLog(@&amp;#34;country1:%@ country2:%@&amp;#34;,country1,country2);  [people1 setValue:@&amp;#34;USA&amp;#34; forKeyPath:@&amp;#34;address.country&amp;#34;];  country1 = people1.address.country;  country2 = [people1 valueForKeyPath:@&amp;#34;address.country&amp;#34;];  NSLog(@&amp;#34;country1:%@ country2:%@&amp;#34;,country1,country2);  }  return 0; } //打印结果 2020-02-15 11:13:48.223700&#43;0800 test[54340:3105892] country1:China country2:China 2020-02-15 11:13:48.224670&#43;0800 test[54340:3105892] country1:USA country2:USA 异常处理 KVC中最常见的异常就是不小心使用了错误的key，或者在设置值的时候不小心传递了nil。如果不小心传递了nil值，KVC会调用setNilValueForKey:方法，这个方法默认是抛出异常，所以一般而言还是重写这个方法：
@implementation People  -(void)setNilValueForKey:(NSString *)key{  NSLog(@&amp;#34;不能将%@设成nil&amp;#34;,key); } @end 非对象和自定义对象 不是每一个方法都返回对象，但是valueForKey：总是返回一个id对象。如果原本的变量类型是值类型或者结构体，返回值会封装成NSNumber或者NSValue对象。这两个类会处理从数字，布尔值到指针和结构体的任何类型。然后，如果需要使用的话，需手动转换成原来的类型。尽管valueForKey会自动将值类型封装成对象，但是setValue：forKey：却不行。必须手动将值类型转换成NSNumber或者NSValue类型，才能传递过去。
Address* add2 = [Address new]; add2.country = @&amp;#34;England&amp;#34;; [people1 setValue:add2 forKey:@&amp;#34;address&amp;#34;]; NSString* country1 = people1.address.country; NSString * country2 = [people1 valueForKeyPath:@&amp;#34;address.country&amp;#34;]; NSLog(@&amp;#34;country1:%@ country2:%@&amp;#34;,country1,country2); 缺点   一旦使用KVC，编译器将无法检查出错误，即不会对设置的键、键路径进行错误检查。
  执行效率要低于合成存取器方法和自定义的setter和getter方法。效率低的原因是使用KVC键值编码，它必须先解析字符串，然后在设置或者访问对象的实例变量。
  KVC的使用 KVC在iOS开发中是绝不可少的利器，这种基于运行时的编程方式极大地提高了灵活性，简化了代码，下面来列举iOS开发中KVC的使用场景。
动态的取值和设值 上面很多例子就是使用KVC动态地取值和设值，这是最基本的用途了，每一个iOS developer都应该要掌握。
访问私有成员 对于类中的私有成员，OC是无法直接访问的，但是KVC是可以的，可以参考前面Dog的例子。
Model和字典的相互转换 Model和字典的相互转换，具体参考。充分地运用了KVC和Runtime组合的技巧，只用了短短数行代码就是完成了很多功能。
修改一些控件的内部属性 众所周知很多UI控件都由很多内部UI控件组合而成的，但是Apple没有提供这访问这些控件的API，这样我们就无法正常地访问和修改这些控件的样式。而KVC在大多数情况可下可以解决这个问题，最常用的就是个性化UITextField中的placeHolderText了。下面演示如果修改placeHolder的文字样式。这里的关键点是如何获取要修改的样式的属性名，也就是key或者keyPath：
let count:UnsafeMutablePointer&amp;lt;UInt32&amp;gt; = UnsafeMutablePointer&amp;lt;UInt32&amp;gt;() var properties = class_copyIvarList(UITextField.self, count) while properties.memory.debugDescription != &amp;#34;0x0000000000000000&amp;#34;{  let t = ivar_getName(properties.memory)  let n = NSString(CString: t, encoding: NSUTF8StringEncoding)  print(n) //打印出所有属性，这里我用了Swift语言  properties = properties.successor() }  //上面省略了部分属性 Optional(_disabledBackgroundView) Optional(_systemBackgroundView) Optional(_floatingContentView) Optional(_contentBackdropView) Optional(_fieldEditorBackgroundView) Optional(_fieldEditorEffectView) Optional(_displayLabel) Optional(_placeholderLabel) //这个正是我想要修改的属性。 Optional(_dictationLabel) Optional(_suffixLabel) Optional(_prefixLabel) Optional(_iconView) //下面省略了部分属性 操作集合 Apple对KVC的valueForKey:方法作了一些特殊的实现，比如说NSArray和NSSet这样的容器类就实现了这些方法，所以可以用KVC很方便地操作集合。
高阶消息传递 当对容器类使用KVC时，valueForKey:将会被传递给容器中的每一个对象，而不是容器本身进行操作。结果会被添加进返回的容器中。这样，开发者可以很方便的操作集合来返回另一个集合。
NSArray* arrStr = @[@&amp;#34;english&amp;#34;,@&amp;#34;franch&amp;#34;,@&amp;#34;chinese&amp;#34;]; NSArray* arrCapStr = [arrStr valueForKey:@&amp;#34;capitalizedString&amp;#34;]; for (NSString* str in arrCapStr) {  NSLog(@&amp;#34;%@&amp;#34;,str); } NSArray* arrCapStrLength = [arrStr valueForKeyPath:@&amp;#34;capitalizedString.length&amp;#34;]; for (NSNumber* length in arrCapStrLength) {  NSLog(@&amp;#34;%ld&amp;#34;,(long)length.integerValue); }  //结果 2020-02-15 13:08:35.863142&#43;0800 test[55706:3138103] English 2020-02-15 13:08:35.863904&#43;0800 test[55706:3138103] Franch 2020-02-15 13:08:35.863924&#43;0800 test[55706:3138103] Chinese 2020-02-15 13:08:35.864765&#43;0800 test[55706:3138103] 7 2020-02-15 13:08:35.864805&#43;0800 test[55706:3138103] 6 2020-02-15 13:08:35.864820&#43;0800 test[55706:3138103] 7 方法capitalizedString被传递到NSArray中的每一项。NSArray的每一员都会执行capitalizedString并返回一个包含结果的新的NSArray。
参考资料 参考资料
</content>
    </entry>
    
     <entry>
        <title>工具使用文档</title>
        <url>https://iihui.github.io/post/tool-usage/</url>
        <categories>
          <category>tool</category>
        </categories>
        <tags>
          <tag>tool</tag>
        </tags>
        <content type="html">  使用Mac开发时会使用各种软件，例如Visual Studio Code，Xcode，iTerm，AppCode等。在这些工具的使用过程中，也会遇到一些问题，因为遇到这些问题频率较低，解决之后也容易忘记，这篇文章用来记录解决方法，以期后续能节省时间。
 Visual Studio Code 列选择模式 如果要进行列选择，需要先按住快捷键shift &#43; option，然后单击拖动鼠标，即可进行范围。具体效果如下图所示：
生成html模版 如果要生成html模板，首先新建一个文件，然后保存，文件名称的后缀为html，然后输入!，再键入Tab，则可按提示生成html模版文件：
Word Wrap 如果要开启编辑器的Word Wrap，首先需要打开设置，然后再搜索wrap，接着找到Editor: Word Wrap，把Controls how lines should wrap开关打开：
AppCode 列选择模式 如果想要进行列选择，需要先按住option键，然后单击以拖动鼠标，即可选择相应的范围。选择的具体效果如下图所示：
 iTerm 设置为默认终端 因为经常使用iTerm2，所以想将它设置为默认终端。实际上iterm2本身支持修改自身为默认终端，只要在应用的菜单栏点击Make Iterm2 to default Term，如下图所示：
常用快捷键   command &#43; d 纵向将当前窗口分为大小相同的两个窗口。
  shift &#43; command &#43; d 横行将当前窗口分为大小相同的两个窗口。
  设置滚动 iTerm默认只能显示1000行的历史数据，可以在设置中进行更改。打开设置，然后选中Profiles，再点击Termal，在Scrollback lines这一行后面勾选Unlimited scrollback，如下图所示：
 Homebrew 替换源 使用homebrew安装软件时，默认会先进行更新，但国内访问github经常不稳定，导致更新时特别慢。可行的方法是替换源，对于homebrew而言，需要替换4个模块的镜像，如下所示：
 Homebrew Homebrew Core Homebrew Cask Homebrew-bottles  目前来看，最全的是中科大镜像，其他家都缺少第4个，所以换了前三个后，执行brew update依然很慢，具体替换方式如下：
# 替换 Homebrew git -C &amp;#34;$(brew --repo)&amp;#34; remote set-url origin https://mirrors.ustc.edu.cn/brew.git  # 替换 Homebrew Core git -C &amp;#34;$(brew --repo homebrew/core)&amp;#34; remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git  # 替换 Homebrew Cask git -C &amp;#34;$(brew --repo homebrew/cask)&amp;#34; remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git  # 替换 Homebrew-bottles # 对于 bash 用户： echo &amp;#39;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles&amp;#39; &amp;gt;&amp;gt; ~/.bash_profile source ~/.bash_profile # 对于 zsh 用户： echo &amp;#39;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles&amp;#39; &amp;gt;&amp;gt; ~/.zshrc source ~/.zshrc 参考资料
 ideviceinstaller 安装App 使用ideviceinstaller安装App，若Mac上只连了一台手机，可以直接使用如下命令进行ipa安装，其中的xxx代表具体的名字：
ideviceinstaller -i xxx.ipa 如果当前电脑连接了多部手机，需要通过设备的UDID来确定安装到哪台设备上。如果想要查看连接的所有设备的UDID，需要使用如下命令：
idevice_id -l 根据上一步获取到的手机UDID，并且在使用ideviceinstaller命令时添加-u选项，则可以将ipa文件安装到特定的手机上：
ideviceinstaller -u xxx -i xxx.ipa 如果要查看连接到电脑手机的详细信息，需要使用ideviceinfo命令，其中的-s选项表示只是展示一些简单的信息：
ideviceinfo -s 查看安装的App 如果想要查看手机安装的所有第三方App，则添加-l选项即可：
ideviceinstaller -l 卸载应用 如果要卸载某台手机的某个应用，依然可以使用ideviceinstaller命令，其中的小写-u选项指定设备，大写-U用于指定应用：
ideviceinstaller -u [udid] -U [bundleId]  Word 如果Mac系统设置为英文，安装Word之后显示语言默认为英文，为了设置中文显示，可以先关闭Word，然后执行如下命令：
defaults write com.microsoft.Word AppleLanguages &amp;#39;(&amp;#34;zh-cn&amp;#34;)&amp;#39; 其中com.microsoft.Word是Word的bundle identifier，可以通过下图所示步骤查看，即最后一张图的Bundle identifier所对应的值：
实际上，下面的命令具有通用性，只要将com.microsoft.Word改成其它软件的 Bundle identifier值即可。例如，下面的命令就是修改Powerpoint &amp;amp; Excel的默认显示语言：
defaults write com.microsoft.Powerpoint AppleLanguages &amp;#39;(&amp;#34;zh-cn&amp;#34;)&amp;#39; defaults write com.microsoft.Excel AppleLanguages &amp;#39;(&amp;#34;zh-cn&amp;#34;)&amp;#39; ZeroTier One 今天打开ZeroTier One后发现提示Could not connect to the server。按照网上的资料使用如下两个命令，发现依然有报错：
sudo launchctl unload /Library/LaunchDaemons/com.zerotier.one.plist sudo launchctl load /Library/LaunchDaemons/com.zerotier.one.plist 第一条命令的报错信息为Could not find specified service，第二条命令的报错信息为Service is disabled。最后发现在App Cleaner &amp;amp; Uninstaller PRO软件中的System Daemons条目下的com.zerotier.one被关闭了。直接打开就能正常使用了：
/Library/LaunchDaemons/com.zerotier.one.plist: Could not find specified service Unload failed: 113: Could not find specified service  /Library/LaunchDaemons/com.zerotier.one.plist: Service is disabled Load failed: 119: Service is disabled Brave 使用Brave浏览器全屏播放视频时经常出现蓝色边框，查找资料发现需要设置brave://flags/#enable-oop-rasterization，将默认值改为Enabled即可：
Sqlcipher 不能使用Intellij idea直接打开用Sqlcipher加密过的Sqlite数据库文件，需要先从这里下载驱动文件到本地，然后添加到Intellij idea中，如下图所示，首先右键工程右边的Database，然后点击&#43;号，选择Driver：
然后再在弹出的添加界面将Name填写好（此处我填写为Sqlcipher），Class填写为org.sqlite.JDBC，并将刚刚下载的驱动文件添加到Driver Files中，最后点击OK按钮：
接着回到主界面，依次点击&#43;，Data Source,Sqlcipher，输入Name，Authentication选择No auth，并且URL这一列输入类似jdbc:sqlite:/Users/xxx/xxx/xxx.db?cipher=sqlcipher&amp;amp;key=xxx&amp;amp;legacy=xxx&amp;amp;kdf_iter=xxx&amp;amp;kdf_algorithm=xxx&amp;amp;legacy_page_size=xxx&amp;amp;hmac_algorithm=xxx串，即可打开加密的数据库表：
jdbc:sqlite:/Users/xxx/xxx/xxx.db?cipher=sqlcipher&amp;amp;key=xxx&amp;amp;legacy=xxx&amp;amp;kdf_iter=xxx&amp;amp;kdf_algorithm=xxx&amp;amp;legacy_page_size=xxx&amp;amp;hmac_algorithm=xxx` 上面代码段中?前的xxx代表数据库文件路径，后面的xxx代表对应key所取的具体值，每个选项的具体值的含义参考此链接，下图是最后打开后的效果图：
参考资料
CrossOver 宋体 在CrossOver中安装软件后若提示未安装宋体，则需要安装简体中文字体包。搜索Font，然后选择Adobe Source Han Sans Simplified Chinese Font Package安装即可：
</content>
    </entry>
    
     <entry>
        <title>iOS 可视化埋点</title>
        <url>https://iihui.github.io/post/ios-log-point/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag><tag>oc</tag>
        </tags>
        <content type="html">  埋点方案大体上可以归为3类：代码埋点，可视化埋点，无埋点。代码埋点，由开发人员在触发事件的具体方法里，植入多行代码把需要上传的数据发送至服务端。可视化埋点，根据标识来识别每一个事件，针对指定的事件进行取参埋点。而事件的标识与参数信息都写在配置表中，通过动态下发配置表来实现埋点统计。无埋点，无埋点并不是不需要埋点，更准确的说应该是“全埋点”，前端的任意一个事件都被绑定一个标识，所有的事件都被记录下来。通过定期上传记录文件，配合文件解析，解析出想要的数据，并以此生成可视化报告供专业人员分析，因此实现无埋点统计。
 可视化埋点 可视化埋点并非完全摒弃了代码埋点，而是在代码埋点的上层封装的一套逻辑来代替手工埋点，大体上架构如下图：
要实现可视化埋点也有很多问题需要解决，比如事件唯一标识的确定，业务参数的获取，有逻辑判断的埋点配置项信息等等。
事件唯一标识 唯一标识的组成方式主要是由target &#43; action来确定，即任何一个事件都存在一个target与action。在此引入AOP编程，AOP（Aspect-Oriented-Programming）即面向切面编程的思想，基于Runtime的 Method Swizzling能力，来hook相应的方法，从而在hook方法中进行统一的埋点处理。例如所有的按钮被点击时，都会触发UIApplication的sendActio方法，我们hook这个方法，即可拦截所有按钮的点击事件:
事件的锁定主要是靠事件唯一标识符，而事件的唯一标识是事先写入配置表中，然后根据配置表来解析具体是哪个界面的哪个事件。
埋点数据分为两种类型：固定数据与可变的业务数据，固定数据可以直接写到配置表中，通过唯一标识来获取。对于业务数据，可以这么理解：数据是有持有者的，例如Controller的一个属性值，又如数据在Model的某一个层级。 这样就可以通过KVC(全称是Key Value Coding)的方式来递归获取该属性的值来取到业务数据。
统计术语 UV(Unique Visitor)：独立访客，将每个独立上网电脑（以cookie为依据）视为一位访客，一天之内（00:00-24:00），访问您网站的访客数量。一天之内相同cookie的访问只被计算1次。
PV（Page View）：访问量，即页面浏览量或者点击量，用户每次对网站的访问均被记录1次，用户对同一页面的多次访问，访问量值累计。
统计独立IP：00:00-24:00内相同IP地址只被计算一次，做网站优化的朋友最关心这个。
</content>
    </entry>
    
     <entry>
        <title>Objective-C Runtime</title>
        <url>https://iihui.github.io/post/oc-runtime/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>oc</tag><tag>iOS</tag>
        </tags>
        <content type="html">  Objective-C扩展了C语言，并加入了面向对象特性和Smalltalk式的消息传递机制。而这个扩展的核心是一个用C写的Runtime库，它是OC面向对象和动态机制的基石。OC的Runtime用于创建类对象、进行消息传递和转发。理解OC的Runtime机制可以更好地了解这个语言，适当的时候还能对语言进行扩展，从系统层面解决项目中的一些设计或技术问题。理解Runtime，首先应该了解它的核心——消息传递（Messaging）机制。
 Runtime版本 Runtime有两个版本: modern和legacy版。现用的Objective-C 2.*是Modern 版，只能运行在iOS和macOS 10.5之后的64位程序中。而macOS较老的32位程序仍采用Objective-C 1.*中的Legacy版本。两个版本最大的区别在于：当更改一个类的实例变量布局时，在早期版本中需要重新编译它的子类，而Modern版不需要重新编译子类。
高级编程语言想要成为可执行文件需要先编译为汇编语言，再将汇编语言转换为机器语言（机器语言是计算机能够识别的唯一语言）。但是，OC并不能直接编译为汇编语言，而是要先转写为纯C语言再进行编译和汇编操作，从OC到C的过渡是由runtime库来实现的。因为OC主要进行面向对象开发，而C语言是面向过程开发，这就需要将面向对象的类转变为面向过程的结构体。
消息传递 所有的OC方法调用[receiver selector]在编译时都会转化为对应的C函数objc_msgSend(receiver，selector)的调用。 例如一个对象方法调用[obj,foo]，Runtime执行方法调用的过程如下：
  首先，通过obj的isa指针找到它的class
  然后，在obj的class的objc_method_list找foo
  如果class的objc_method_list中没到foo，继续往它的super_class中寻找foo
  若找到foo这个函数，就去执行它的实现IMP，否则报错
  但上述流程存在效率低的问题：通常一个class只有20%的函数经常被调用，可能占总调用次数的80%，所以每次消息传递的时候都遍历一次objc_method_list并不合理。如果把经常被调用的函数缓存下来，就可以大大提高函数的查询效率。objc_cache就是做这样的事情，当找到selector后，它将selector的method_name作为key，method_imp作为value存储起来，当再次收到selector消息时，可以直接在objc_cache里找到，避免去遍历objc_method_list。
objc_msgSend定义 在runtime中，objc_msgSend的定义如下：
OBJC_EXPORT id objc_msgSend(id self, SEL op, ...) 要了解消息传递机制，首先需要了解类objc_class、对象objc_object、方法objc_method这几个结构体。
//对象 struct objc_object {  Class isa OBJC_ISA_AVAILABILITY; }; //类 struct objc_class {  Class isa OBJC_ISA_AVAILABILITY; #if !__OBJC2__  Class super_class OBJC2_UNAVAILABLE;  const char *name OBJC2_UNAVAILABLE;  long version OBJC2_UNAVAILABLE;  long info OBJC2_UNAVAILABLE;  long instance_size OBJC2_UNAVAILABLE;  struct objc_ivar_list *ivars OBJC2_UNAVAILABLE;  struct objc_method_list **methodLists OBJC2_UNAVAILABLE;  struct objc_cache *cache OBJC2_UNAVAILABLE;  struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; #endif } OBJC2_UNAVAILABLE; //方法列表 struct objc_method_list {  struct objc_method_list *obsolete OBJC2_UNAVAILABLE;  int method_count OBJC2_UNAVAILABLE; #ifdef __LP64__  int space OBJC2_UNAVAILABLE; #endif  /* variable length structure */  struct objc_method method_list[1] OBJC2_UNAVAILABLE; } OBJC2_UNAVAILABLE; //方法 struct objc_method {  SEL method_name OBJC2_UNAVAILABLE;  char *method_types OBJC2_UNAVAILABLE;  IMP method_imp OBJC2_UNAVAILABLE; } 类对象objc_class 在OC中，类是由Class类型来表示的，它实际上是一个指向objc_class结构体的指针：
typedef struct objc_class *Class; //Class是一个指向objc_class 的指针 其中objc_class结构体在objc/runtime.h中的定义如下：
struct objc_class {  Class _Nonnull isa OBJC_ISA_AVAILABILITY;  #if !__OBJC2__  Class _Nullable super_class OBJC2_UNAVAILABLE; // 指向父类的指针  const char * _Nonnull name OBJC2_UNAVAILABLE; // 类的名字  long version OBJC2_UNAVAILABLE; // 类的版本信息，默认为 0  long info OBJC2_UNAVAILABLE; // 类的信息，供运行期使用的一些位标识   long instance_size OBJC2_UNAVAILABLE; // 该类的实例变量大小;  struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; // 该类的实例变量列表  struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; // 方法定义的列表  struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; // 方法缓存  struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE; // 遵守的协议列表 #endif } OBJC2_UNAVAILABLE; 类对象就是一个结构体struct objc_class，这个结构体存放的数据称为元数据(metadata)。该结构体的第一个成员变量也是isa指针，这说明了Class本身其实是一个对象，称之为类对象。类对象在编译期产生用于创建实例对象，是单例。
实例对象(object) 在objc/runtime.h中，对象被定义为指向objc_object结构体的指针，objc_object结构体的定义如下：
//runtime对objc_object结构体的定义 struct objc_object {  Class isa OBJC_ISA_AVAILABILITY; //objc_object只有一个成员，就是指向O };  //id是一个指向objc_object结构体的指针： typedef struct objc_object *id; //id是指向objc_class指针的指针 类对象中的元数据存储的都是如何创建一个实例的相关信息，那么类对象和类方法应该从哪里创建呢？就是从isa指针指向的结构体创建，类对象的isa指针指向的我们称之为元类(meatclass)，元类中保存了创建类对象以及类方法所需的所有信息，因此整个结构应该如下图所示:
元类(meta class) 通过上图可以看出整个体系构成了一个自闭环，struct objc_object结构体实例的isa指针指向类对象，类对象的isa指针指向了元类，super_class指针指向了父类的类对象，而元类的super_class指针指向了父类的元类，那元类的isa指针又指向了自己(还不理解为什么会指向自己)。
元类(Meta Class)是一个类对象的类。在上面我们提到，所有的类自身也是一个对象，我们可以向这个对象发送消息(即调用类方法)。为了调用类方法，这个类的isa指针必须指向一个包含这些类方法的一个objc_class结构体。这就引出了meta-class的概念，元类中保存了创建类对象以及类方法所需的所有信息。
任何NSObject继承体系下的meta-class都使用NSObject的meta-class作为自己的所属类，而基类的meta-class的isa指针是指向它自己。
方法(method) 首先看一下objc_method的定义：
runtime.h /// An opaque type that represents a method in a class definition.代表类定义中一个方法的不透明类型 typedef struct objc_method *Method; struct objc_method {  SEL method_name OBJC2_UNAVAILABLE; //方法名  char *method_types OBJC2_UNAVAILABLE; //方法类型  IMP method_imp OBJC2_UNAVAILABLE; //方法实现 在objc_method的定义中，可以看到SEL和IMP，这说明SEL和IMP都是方法的属性:
  SEL method_name方法名
  char * method_types 方法类型
  IMP method_imp 方法实现
  SEL方法选择器 ojbc_msgSend函数第二个参数类型为SEL，可以理解为用于区分方法的ID，这个ID的数据结构就是SEL：
在objc/runtime.h,SEL被定义为指向objc_selector结构体的指针：
///objc.h /// An opaque type that represents a method selector.代表一个方法的不透明类型 typedef struct objc_selector *SEL; 而selector是SEL的一个实例：
@property SEL selector; selector的解释为：
A method selector is a C string that has been registered (or “mapped“) with the Objective-C runtime. Selectors generated by the compiler are automatically mapped by the runtime when the class is loaded. 也就是说selector就是个映射到方法的C字符串，可以用OC编译器命令@selector()或者Runtime系统的sel_registerName函数来获得一个SEL类型的方法选择器。
selector既然是一个字符串，应该类似className&#43;method的组合，命名的规则有两条：
  同一个类，selector不能重复
  不同的类，selector可以重复
  这也带来个弊端，就是在写C代码的时候，经常会用到函数重载，就是函数名相同，参数不同。但在OC中行不通，因为selector只记了method的name，没有参数，所以没法区分不同的method。
比如下面代码在OC中是会报错的：
- (void)caculate(NSInteger)num; - (void)caculate(CGFloat)num; 所以只能通过命名来区分：
- (void)caculateWithInt(NSInteger)num; - (void)caculateWithFloat(CGFloat)num; IMP IMP是指向一个方法实现的指针，实质上就是指向最终实现程序的内存地址的指针，它的定义为：
/// A pointer to the function of a method implementation. 指向一个方法实现的指针 typedef id (*IMP)(id, SEL, ...); #endif 在iOS的runtime中，方法通过selector和IMP两个属性，实现了快速查询方法及其实现，相对提高了性能，又保持了灵活性。
Objective-C在编译时，会依据每一个方法的名字、参数序列，生成一个唯一的整型标识(Int类型的地址)，这个标识就是SEL
Category(objc_catory) 当Catrgory表示一个指向分类的结构体的指针，它的定义如下：
struct category_t {  const char *name;  classref_t cls;  struct method_list_t *instanceMethods;  struct method_list_t *classMethods;  struct protocol_list_t *protocols;  struct property_list_t *instanceProperties; };   name是class_name而不是category_name。
  cls表示要扩展的类对象，编译期间是不会定义的，而是在Runtime阶段通过name对应到相应的类对象。
  instanceMethods表示category中所有给类添加的实例方法的列表。
  classMethods表示category中所有添加的类方法的列表。
  protocols 表示category实现的所有协议的列表。
  instanceProperties 表示category里所有的Properties，这就是我们可以通过objc_setAssociatedObject和objc_getAssociatedObject增加实例变量的原因，不过这个和一般的实例变量是不一样的。
  从上面的category_t结构体中可以看出，分类中可以添加实例方法，类方法，甚至可以实现协议，添加属性，不可以添加成员变量。
Runtime消息转发 OC在发送消息时会在相关的类对象中搜索方法列表，如果找不到则会沿着继承树向上一直搜索直到树根部（NSObject），如果还是找不到，那么消息转发就是失败了。此时，会执行doesNotRecognizeSelector:方法，报unrecognized selector错。
动态方法转发 首先，OC运行时会调用&#43;resolveInstanceMethod:或者 &#43;resolveClassMethod:，让你有机会提供一个函数实现。如果添加了函数并返回YES，那运行时系统就会重新启动一次消息发送的过程。
实现一个动态方法解析的例子：
- (void)viewDidLoad {  [super viewDidLoad];  // Do any additional setup after loading the view, typically from a nib.  //执行foo函数  [self performSelector:@selector(foo:)]; }  &#43; (BOOL)resolveInstanceMethod:(SEL)sel {  if (sel == @selector(foo:)) {//如果是执行foo函数，就动态解析，指定新的IMP  class_addMethod([self class], sel, (IMP)fooMethod, &amp;#34;v@:&amp;#34;);  return YES;  }  return [super resolveInstanceMethod:sel]; }  void fooMethod(id obj, SEL _cmd) {  NSLog(@&amp;#34;Doing foo&amp;#34;);//新的foo函数 } 可以看到虽然没有实现foo:这个函数，但是通过class_addMethod动态添加fooMethod函数，并执行fooMethod这个函数的IMP。但如果resolve方法返回NO，运行时就会移到下一步：forwardingTargetForSelector。
备用接收者 如果目标对象实现了-forwardingTargetForSelector:，Runtime这时就会调用这个方法，给你把这个消息转发给其他对象的机会。
实现一个备用接收者：
#import &amp;#34;ViewController.h&amp;#34; #import &amp;#34;objc/runtime.h&amp;#34;  @interface Person: NSObject  @end  @implementation Person  - (void)foo {  NSLog(@&amp;#34;Doing foo&amp;#34;);//Person的foo函数 }  @end  @interface ViewController ()  @end  @implementation ViewController  - (void)viewDidLoad {  [super viewDidLoad];  // Do any additional setup after loading the view, typically from a nib.  //执行foo函数  [self performSelector:@selector(foo)]; }  &#43; (BOOL)resolveInstanceMethod:(SEL)sel {  return NO;//返回NO，进入下一步转发 }  - (id)forwardingTargetForSelector:(SEL)aSelector {  if (aSelector == @selector(foo)) {  return [Person new];//返回Person对象，让Person对象接收这个消息  }   return [super forwardingTargetForSelector:aSelector]; }  @end 完整消息转发 如果在上一步还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了。
首先它会发送-methodSignatureForSelector:消息获得函数的参数和返回值类型。如果-methodSignatureForSelector:返回nil，则Runtime则会发出-doesNotRecognizeSelector:消息，程序这时也就挂掉了。如果返回了一个函数签名，Runtime就会创建一个NSInvocation对象并发送 -forwardInvocation:消息给目标对象。
#import &amp;#34;ViewController.h&amp;#34; #import &amp;#34;objc/runtime.h&amp;#34;  @interface Person: NSObject  @end  @implementation Person  - (void)foo {  NSLog(@&amp;#34;Doing foo&amp;#34;);//Person的foo函数 }  @end  @interface ViewController ()  @end  @implementation ViewController  - (void)viewDidLoad {  [super viewDidLoad];  // Do any additional setup after loading the view, typically from a nib.  //执行foo函数  [self performSelector:@selector(foo)]; }  &#43; (BOOL)resolveInstanceMethod:(SEL)sel {  return YES;//返回YES，进入下一步转发 }  - (id)forwardingTargetForSelector:(SEL)aSelector {  return nil;//返回nil，进入下一步转发 }  - (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {  if ([NSStringFromSelector(aSelector) isEqualToString:@&amp;#34;foo&amp;#34;]) {  return [NSMethodSignature signatureWithObjCTypes:&amp;#34;v@:&amp;#34;];//签名，进入forwardInvocation  }   return [super methodSignatureForSelector:aSelector]; }  - (void)forwardInvocation:(NSInvocation *)anInvocation {  SEL sel = anInvocation.selector;   Person *p = [Person new];  if([p respondsToSelector:sel]) {  [anInvocation invokeWithTarget:p];  }  else {  [self doesNotRecognizeSelector:sel];  }  }  @end instancetype和id的区别 instancetype和id都可以用来表示任意类型，将对象的类型确定往后推迟，用于体现OC语言的动态性，使其声明的对象具有运行时特性。区别是：
  instancetype只能作为返回值类型，但在编译期instancetype会进行类型检测，因此对于所有返回类的实例的类方法或实例方法，建议返回类型instancetype而不是id。
  id类型既可以作为返回类型，也可以作为参数类型，也可以作为变量类型，但id类型在编译期不会进行类型检测。
  selector selector是一个方法的名字。基于动态绑定环境下，method是一个组合体，包含了名字和实现。可以理解@selector()就是取类方法的编号，他的行为基本可以等同C语言中的函数指针，只不过C语言中，可以把函数名直接赋值给一个函数指针，而OC的类不能直接应用函数指针，这样只能做一个@selector语法来取，它的结果是一个SEL类型。而这个类型本质是类方法的编号（函数地址）。
target-action机制 目标是动作消息的接收者。例# 目标是动作消息的接收者。例目标是动作消息的接收者。例如一个控件，或者更为常见的是它的单元，以插座变量的形式保有其动作的目标。动作是控件发送给目标的消息，或者从目标的角度看，他是目标为了响应动作而实现的方法。程序需要某些机制来进行实践和指令的翻译，这个机制就是目标-动作机制。
Runtime的应用 Runtime的应用场景有很多，常见的如下：
  关联对象(Objective-C Associated Objects)，给分类添加属性
  方法魔法(Method Swizzling),添加和替换KVO实现
  实现NSCoding的自动归档和自动解档
  实现字典和模型的自动转换(MJExtension)
  关联对象 在OC中分类是不能自定义属性和变量的，但是可以通过关联对象实现给分类添加属性。Runtime给关联对象添加了以下几个接口：
3个接口 //关联对象 void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) //获取关联的对象 id objc_getAssociatedObject(id object, const void *key) //移除关联的对象 void objc_removeAssociatedObjects(id object) 参数解释 id object：被关联的对象 const void *key：关联的key，要求唯一 id value：关联的对象 objc_AssociationPolicy policy：内存管理的策略 内存管理策略的定义：
typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) {  OBJC_ASSOCIATION_ASSIGN = 0, /**&amp;lt; Specifies a weak reference to the associated object. */  OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**&amp;lt; Specifies a strong reference to the associated object. * The association is not made atomically. */  OBJC_ASSOCIATION_COPY_NONATOMIC = 3, /**&amp;lt; Specifies that the associated object is copied. * The association is not made atomically. */  OBJC_ASSOCIATION_RETAIN = 01401, /**&amp;lt; Specifies a strong reference to the associated object. * The association is made atomically. */  OBJC_ASSOCIATION_COPY = 01403 /**&amp;lt; Specifies that the associated object is copied. * The association is made atomically. */ }; 内存分配各个值的含义如下所示： 下面是OC中下实现一个UIView的Category添加自定义属性defaultColor：
#import &amp;#34;ViewController.h&amp;#34; #import &amp;#34;objc/runtime.h&amp;#34;  @interface UIView (DefaultColor)  @property (nonatomic, strong) UIColor *defaultColor;  @end  @implementation UIView (DefaultColor)  @dynamic defaultColor;  static char kDefaultColorKey;  - (void)setDefaultColor:(UIColor *)defaultColor {  objc_setAssociatedObject(self, &amp;amp;kDefaultColorKey, defaultColor, OBJC_ASSOCIATION_RETAIN_NONATOMIC); }  - (id)defaultColor {  return objc_getAssociatedObject(self, &amp;amp;kDefaultColorKey); }  @end  @interface ViewController ()  @end  @implementation ViewController  - (void)viewDidLoad {  [super viewDidLoad];  // Do any additional setup after loading the view, typically from a nib.   UIView *test = [UIView new];  test.defaultColor = [UIColor blackColor];  NSLog(@&amp;#34;%@&amp;#34;, test.defaultColor); }  @end 在Swift中是按如下使用方法使用的：
extension NSObject {  func setAssociated&amp;lt;T&amp;gt;(value: T, associatedKey: UnsafeRawPointer, policy: objc_AssociationPolicy = objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN_NONATOMIC) -&amp;gt; Void {  objc_setAssociatedObject(self, associatedKey, value, policy)  }   func getAssociated&amp;lt;T&amp;gt;(associatedKey: UnsafeRawPointer) -&amp;gt; T? {  let value = objc_getAssociatedObject(self, associatedKey) as? T  return value  } } Method Swizzling 方法添加 添加方法的实际上在上面的消息转发机制中已经提到了，其函数定义为：
//class_addMethod(Class _Nullable __unsafe_unretained cls, SEL _Nonnull name, IMP _Nonnull imp, const char * _Nullable types) class_addMethod([self class], sel, (IMP)fooMethod, &amp;#34;v@:&amp;#34;); 其中，参数的解释如下：
 cls表示被添加的类 name添加的方法的名称SEL imp方法的实现，该函数必须至少有两个参数self,_cmd  方法替换 下面OC代码实现替换ViewController的viewDidLoad方法：
@implementation ViewController  &#43; (void)load {  static dispatch_once_t onceToken;  dispatch_once(&amp;amp;onceToken, ^{  Class class = [self class];  SEL originalSelector = @selector(viewDidLoad);  SEL swizzledSelector = @selector(jkviewDidLoad);   Method originalMethod = class_getInstanceMethod(class,originalSelector);  Method swizzledMethod = class_getInstanceMethod(class,swizzledSelector);   //judge the method named swizzledMethod is already existed.  BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));  // if swizzledMethod is already existed.  if (didAddMethod) {  class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));  }  else {  method_exchangeImplementations(originalMethod, swizzledMethod);  }  }); }  - (void)jkviewDidLoad {  NSLog(@&amp;#34;替换的方法&amp;#34;);   [self jkviewDidLoad]; }  - (void)viewDidLoad {  NSLog(@&amp;#34;自带的方法&amp;#34;);   [super viewDidLoad]; }  @end OC的swizzling应该只在&#43;load中完成。在OC的Runtime中，每个类有两个方法都会自动调用。&#43;load是在一个类被初始装载时调用，&#43;initialize是在应用第一次调用该类的类方法或实例方法前调用的。两个方法都是可选的，并且只有在方法被实现的情况下才会被调用。
swizzling应该只在dispatch_once中完成，由于swizzling改变了全局的状态，所以我们需要确保每个预防措施在运行时都是可用的。原子操作就是这样一个用于确保代码只会被执行一次的预防措施，就算是在不同的线程中也能确保代码只执行一次。Grand Central Dispatch的dispatch_once满足了所需要的需求，并且应该被当做使用swizzling的初始化单例方法的标准。
在上图中，通过Swizzling特性，将selectorC的方法实现IMPc与selectorN的方法实现IMPn交换了，当调用selectorC，也就是给对象发送selectorC消息时，所查找到的方法实现就是IMPn而不是IMPc了。
KVO实现 KVO的全称是Key-value observing，译为键值观察。提供了一种当其它对象属性被修改的时候能通知当前对象的机制。再MVC大行其道的Cocoa中，KVO机制很适合实现model和controller类之间的通信。
KVO的实现依赖于OC强大的Runtime，当观察某对象A时，KVO机制动态创建一个对象A当前类的子类，并为这个新的子类重写了被观察属性keyPath的setter方法。setter方法随后负责通知观察对象属性的改变状况。
Apple使用了isa-swizzling来实现KVO。当观察对象A时，KVO机制动态创建一个新的名为：NSKVONotifying_A的新类，该类继承自对象A的本类，且KVO为 NSKVONotifying_A重写观察属性的setter方法，setter方法会负责在调用原setter方法之前和之后，通知所有观察对象属性值的更改情况。
NSKVONotifying_A类剖析：
NSLog(@&amp;#34;self-&amp;gt;isa:%@&amp;#34;,self-&amp;gt;isa); NSLog(@&amp;#34;self class:%@&amp;#34;,[self class]); 在建立KVO监听前，打印结果为：
self-&amp;gt;isa:A self class:A 在建立KVO监听之后，打印结果为：
self-&amp;gt;isa:NSKVONotifying_A self class:A 在这个过程，被观察对象的isa指针从指向原来的A类，被KVO机制修改为指向系统新创建的子类NSKVONotifying_A类，来实现当前类属性值改变的监听；
所以当我们从应用层面上看来，完全没有意识到有新的类出现，这是系统隐瞒了对KVO的底层实现过程，让我们误以为还是原来的类。但是此时如果我们创建一个新的名为NSKVONotifying_A的类，就会发现系统运行到注册KVO的那段代码时程序就崩溃，因为系统在注册监听的时候动态创建了名为NSKVONotifying_A的中间类，并指向这个中间类了。
子类setter方法剖析：
KVO的键值观察通知依赖于NSObject的两个方法willChangeValueForKey:和 didChangeValueForKey:，在存取数值的前后分别调用2个方法：被观察属性发生改变之前，willChangeValueForKey:被调用，通知系统该keyPath的属性值即将变更； 当改变发生后，didChangeValueForKey:被调用，通知系统该keyPath的属性值已经变更；之后，observeValueForKey:ofObject:change:context:也会被调用。且重写观察属性的setter方法这种继承方式的注入是在运行时而不是编译时实现的。
KVO为子类的观察者属性重写调用存取方法的工作原理在代码中相当于：
- (void)setName:(NSString *)newName {  [self willChangeValueForKey:@&amp;#34;name&amp;#34;]; //KVO 在调用存取方法之前总调用  [super setValue:newName forKey:@&amp;#34;name&amp;#34;]; //调用父类的存取方法  [self didChangeValueForKey:@&amp;#34;name&amp;#34;]; //KVO 在调用存取方法之后总调用 } 热更新JSPatch JSPatch是一个iOS动态更新框架，只需在项目中引入极小的引擎，就可以使用 JavaScript调用任何OC原生接口，获得脚本语言的优势：为项目动态添加模块，或替换项目原生代码动态修复bug。
关于消息转发，前面已经讲到过了，消息转发分为三级，我们可以在每级实现替换功能，实现消息转发，从而不会造成崩溃。JSPatch不仅能够实现消息转发，还可以实现方法添加、替换等一系列功能。
实现NSCoding的自动归档和自动解档 用Runtime提供的函数遍历Model自身所有属性，并对属性进行encode和decode操作。 核心方法：在Model的基类中重写方法：
- (id)initWithCoder:(NSCoder *)aDecoder {  if (self = [super init]) {  unsigned int outCount;  Ivar * ivars = class_copyIvarList([self class], &amp;amp;outCount);  for (int i = 0; i &amp;lt; outCount; i &#43;&#43;) {  Ivar ivar = ivars[i];  NSString * key = [NSString stringWithUTF8String:ivar_getName(ivar)];  [self setValue:[aDecoder decodeObjectForKey:key] forKey:key];  }  }  return self; }  - (void)encodeWithCoder:(NSCoder *)aCoder {  unsigned int outCount;  Ivar * ivars = class_copyIvarList([self class], &amp;amp;outCount);  for (int i = 0; i &amp;lt; outCount; i &#43;&#43;) {  Ivar ivar = ivars[i];  NSString * key = [NSString stringWithUTF8String:ivar_getName(ivar)];  [aCoder encodeObject:[self valueForKey:key] forKey:key];  } } 实现字典和模型的自动转换(MJExtension) 用runtime提供的函数遍历Model自身所有属性，如果属性在json中有对应的值，则将其赋值。 核心方法：在NSObject的分类中添加方法。
- (instancetype)initWithDict:(NSDictionary *)dict {   if (self = [self init]) {  //(1)获取类的属性及属性对应的类型  NSMutableArray * keys = [NSMutableArray array];  NSMutableArray * attributes = [NSMutableArray array];  /* * 例子 * name = value3 attribute = T@&amp;#34;NSString&amp;#34;,C,N,V_value3 * name = value4 attribute = T^i,N,V_value4 */  unsigned int outCount;  objc_property_t * properties = class_copyPropertyList([self class], &amp;amp;outCount);  for (int i = 0; i &amp;lt; outCount; i &#43;&#43;) {  objc_property_t property = properties[i];  //通过property_getName函数获得属性的名字  NSString * propertyName = [NSString stringWithCString:property_getName(property) encoding:NSUTF8StringEncoding];  [keys addObject:propertyName];  //通过property_getAttributes函数可以获得属性的名字和@encode编码  NSString * propertyAttribute = [NSString stringWithCString:property_getAttributes(property) encoding:NSUTF8StringEncoding];  [attributes addObject:propertyAttribute];  }  //立即释放properties指向的内存  free(properties);   //(2)根据类型给属性赋值  for (NSString * key in keys) {  if ([dict valueForKey:key] == nil) continue;  [self setValue:[dict valueForKey:key] forKey:key];  }  }  return self;  } 参考资料 参考资料 参考资料
</content>
    </entry>
    
     <entry>
        <title>陈小厨作品</title>
        <url>https://iihui.github.io/post/food-2020/</url>
        <categories>
          <category>美食</category>
        </categories>
        <tags>
          <tag>美食</tag>
        </tags>
        <content type="html">  2020年给自己定了些年度目标，用心下厨是其中一项。我是一个喜欢倒腾吃的人，每次看到自己做的东西既美味又有颜值的时候，总会很开心，但多数时候都忘了记录大致的步骤和拍照留存，2020年想给自己多留点值得回忆的东西，故以此为记。
 二月作品 猪血丸子、腊肉炒辣椒（猪血丸子先整个煮，再用冷水冷却，趁热切片，再放油小火煎，随后放佐料和辣椒中火翻炒）
花仙子桂花汤圆、湾仔码头水晶汤圆（烧开水再放汤圆，再小火慢煮，水开之后加一杯冷水，再开之后再加一杯冷水，然后煮到下面样子的时候捞出来）
萝卜和土豆炖牛腩和排骨（牛腩和排骨先煮，然后捞出来，洗干净，再和土豆萝卜一起放电饭煲里炖，炖差不多一个半小时）
排骨炖土豆（首先将排骨洗净，然后在放锅里煮，煮熟之后捞出来晾干，这一步主要是去浮沫，然后再放油煎一下排骨，煎完之后放土豆炒，之后放水煮即可，）
西兰花炒肉（首先将西兰花焯水，注意千万不要太久，然后炒肉，肉炒得差不多的时候放西兰花，再炒一段时间，炒得时间千万不要过长） 清炒胡萝卜（炒胡萝卜最关键的是切胡萝丝，一定要有耐心，厚度尽量保持一致，炒的时候不要太要太久，葱花最后要起锅的时候放）
炒长豆角丁（肉应该选那种肥瘦相间的，切成肉沫，肉沫应该先单独炒，放一些酸辣椒或者橄榄菜或许更好）
青椒炒肉(先炒肉，炒熟之后，再放姜蒜和小米椒大火炒几秒钟，再放青椒，翻炒一小会，最后和肉一起炒，临近起锅的时候放些生抽味道会更好)
早餐面（面上是卤豆腐，牛腩，腊猪血丸子）
 </content>
    </entry>
    
     <entry>
        <title>macOS 安装Homebrew 报错</title>
        <url>https://iihui.github.io/post/qa_install_brew/</url>
        <categories>
          <category>QA</category>
        </categories>
        <tags>
          <tag>QA</tag>
        </tags>
        <content type="html">  重装了macOS Catalina 10.15.2，但使用/usr/bin/ruby -e &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;安装Homebrew时报curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused错误，网上大多数说要设置代理，但于我而言没有任何效果。翻了一圈资料，猜测是系统的curl有问题，按照这个思路，首先应该使用另一种方式安装Homebrew，然后再利用Homebrew安装curl，最后设置Homebrew安装的curl优先级高于系统的curl。
 安装Homebrew 首先在浏览器中打开https://raw.githubusercontent.com/Homebrew/install/master/install。若不能打开，就是网络问题；如果能打开就如下图所示：
然后将这个网页的内容复制粘贴保存，并命名为brew_install.rb。再再终端中输入curl命令，如果出现curl: try &#39;curl --help&#39; or &#39;curl --manual&#39; for more information则表示curl本身没有问题：
接着在终端跳转到保存brew_install.rb的目录下，输入命令ruby brew_install.rb，以完成安装Homebrew。
安装并启用新curl 当上一步提示安装成功之后，则可以通过Homebrew安装curl，即在终端输入brew install curl，安装成功之后，如果在终端通过sh -c &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&amp;quot;命令安装oh my zsh 依然会报错curl: (35) Server aborted the SSL handshake 错误，这是因为brew安装的curl的优先级低于系统的。
接着就需要将Homebrew安装的curl的优先级调高，使其高于系统的curl，使用命令 brew link curl --force会提示 按照上面的提示，首先执行echo &#39;export PATH=&amp;quot;/usr/local/opt/curl/bin:$PATH&amp;quot;&#39; &amp;gt;&amp;gt; ~/.zshrc 然后将export LDFLAGS=&amp;quot;-L/usr/local/opt/curl/lib&amp;quot;和export CPPFLAGS=&amp;quot;-I/usr/local/opt/curl/include&amp;quot;放到.zshrc（我用的zsh，如果用户的是其他shell则修改对应的配置文件）中，至此问题解决。
参考资料 参考资料
另一种方式 由于众所周知的原因，安装homebrew经常报错，可以使用如下方式安装：
/bin/zsh -c &amp;#34;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&amp;#34; 参考资料
</content>
    </entry>
    
     <entry>
        <title>Almofire的使用</title>
        <url>https://iihui.github.io/post/ios-alamofire/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  如果使用过OC进行开发，那么知道AFNetworking这个网络操作库。Mattt Thompson作为AFNetworking的发起人，又基于Swift语言开发了一个新的网络操作库 Alamofire。Alamofire的优雅之处在于它完完全全是由Swift写成的，并且没有从AFNetworking那里继承任何特性。Alamofire网络库适用于iOS和macOS，它提供了链式request/response方法，JSON的传参和响应序列化，身份认证和其他特性。
 上传 func upLoadStaticsFile(){  do {  guard let sessionID = userInfoService.activeUser?.sessionID, let sessionIDSM = userInfoService.activeUse  return  }  let parameters = [&amp;#34;sessionID&amp;#34;: sessionID]  let formatter = DateFormatter()  formatter.dateFormat = &amp;#34;yyyy-MM-dd HH:mm:ss&amp;#34;  let temName = &amp;#34;\(formatter.string(from: Date()))-\(deviceID).txt&amp;#34;  let temPath = self.statisticsDir.path.stringByAppendingPathComponent(temName)  let path = self.statisticsDir.path.stringByAppendingPathComponent(fileName)  try FileManager.default.moveItem(atPath: path, toPath: temPath)  // 遍历埋点文件夹下的埋点数据文件,以获取  let fileList = try FileManager.default.contentsOfDirectory(atPath: statisticsDir.path)  let needUploadFileList = fileList.filter {  $0 != self.fileName  }  for file in needUploadFileList {  let path = self.statisticsDir.path.stringByAppendingPathComponent(file)  let dataURL = URL(fileURLWithPath: path)  let data = try Data(contentsOf: dataURL)  self.uploadFile(data: data, parameters: parameters, file: file, path: path)  }  } catch let error as NSError {  log.error(error.localizedDescription)  } } private func uploadFile(data: Data, parameters: [String: String], file: String, path: String) {  Alamofire.upload(multipartFormData: { multipartFormData in  multipartFormData.append(data, withName: &amp;#34;file&amp;#34;, fileName: file, mimeType: &amp;#34;text/plain&amp;#34;)  for (key, value) in parameters {  if let valueData = value.data(using: .utf8) {  multipartFormData.append(valueData, withName: key)  }  }  }, to: addreess, method: .post) { result in  switch result {  case .success:  do {  try FileManager.default.removeItem(atPath: path)  } catch let error as NSError {  log.error(error.localizedDescription)  }  case let .failure(error):  log.error(error.localizedDescription)  }  } } 下载 func requestScreenImage(url:String,completionHandler:@escaping (_ :Data?) -&amp;gt;Void){  Alamofire.request(url, method: .get).response { response in  if response.error == nil{  completionHandler(response.data)  }else{  completionHandler(nil)  }  } } func requestImage(url: String, completionHandler: @escaping (_ image: UIImage?) -&amp;gt; Void) {  self.tokenHttpController.requestLoginDataAndToken(type: .base64, success: { (data, token) in  let data = data?.extStringByUrlEncode ?? &amp;#34;&amp;#34;  let token = token?.extStringByUrlEncode ?? &amp;#34;&amp;#34;  let header: HTTPHeaders = [  &amp;#34;data&amp;#34;: data,  &amp;#34;token&amp;#34;: token  ]  Alamofire.request(url, method: .get, headers: header).response { (response) in  if let data = response.data {  let image = UIImage(data: data)  completionHandler(image)  }else{  completionHandler(nil)  }  }  }) {  completionHandler(nil)  } } func requestScreenADConfigInfo(completionHandler:@escaping (JSON) -&amp;gt; Void){  let url = ConfigRequestUrl  let op = ConfigRequestAction.getScreenPictureInfo  let meta = getDefaultMetaData(op)  var data = [String:String]()  if let model = ScreenADConfigDBRepository.Instance.getScreenConfigModel(),let jsonStr = model.screenConfigJsonStr{  if let dataJson = jsonStr.data(using: String.Encoding.utf8) {  do{  let json = try JSON(data:dataJson)  data[&amp;#34;configHash&amp;#34;] = json[&amp;#34;configHash&amp;#34;].stringValue  }catch{  data[&amp;#34;configHash&amp;#34;] = &amp;#34;&amp;#34;  }  }  }else{  data[&amp;#34;configHash&amp;#34;] = &amp;#34;&amp;#34;  }   switch UIDevice.current.userInterfaceIdiom{  case .pad: data[&amp;#34;type&amp;#34;] = &amp;#34;Pad&amp;#34;  case .phone: data[&amp;#34;type&amp;#34;] = &amp;#34;Phone&amp;#34;  default:break  }   var bodyData = [String:Any]()  bodyData[&amp;#34;meta&amp;#34;] = meta  bodyData[&amp;#34;data&amp;#34;] = data   Alamofire.request(url, method: .post, parameters: bodyData,encoding: JSONEncoding.default).responseJSON{ response in  switch response.result{  case .success(let value):  let json = JSON(value)  let subJSON = json[&amp;#34;data&amp;#34;]  let retCode = subJSON[&amp;#34;retCode&amp;#34;].stringValue  //retCode 为1表示有更新，0表示没有更新，其它表示出错  switch retCode{  case &amp;#34;1&amp;#34;:  completionHandler(subJSON)  case &amp;#34;0&amp;#34;: break  default:  let msg = subJSON[&amp;#34;retMsg&amp;#34;].stringValue  DPrint(msg)  }  case .failure(let error):  Dprint(error.localizedDescription)  }  } } func bindUserDevice(with model: LoginUserModel, and existUsers: ExistUsers, block: @escaping (_ model: UserInfoModel?, _ errorMsg: String?) -&amp;gt; Void) {  var dataDic = Dictionary&amp;lt;String, String&amp;gt;()  dataDic[&amp;#34;rand&amp;#34;] = UUID().uuidString   var metaDic = self.getDefaultMetaDic(forAction: ConfigRequestAction.bindUserDeviceV2)  metaDic[&amp;#34;ystID&amp;#34;] = model.ystId  metaDic[&amp;#34;sapID&amp;#34;] = model.sapId  metaDic[&amp;#34;inuseID&amp;#34;] = model.inUseId   let parameters = self.getRequestPostParameters(metaDic: metaDic, dataDic: dataDic)   Alamofire.request(ConfigRequestMoUrl, method: .post, parameters: parameters, encoding: JSONEncoding.default, headers: nil).responseJSON { (response) in  switch response.result {  case .success(let value):  let json = JSON(value)  if let retCode = json[&amp;#34;data&amp;#34;][&amp;#34;retCode&amp;#34;].string, retCode == &amp;#34;0&amp;#34; {  let model = UserInfoModel(from: json[&amp;#34;data&amp;#34;])  block(model, nil)  } else {  block(nil, json[&amp;#34;data&amp;#34;][&amp;#34;retMsg&amp;#34;].stringValue)  }  case .failure(_):  block(nil, &amp;#34;network is poor&amp;#34;)  }  } }  参考资料 参考资料 对比
</content>
    </entry>
    
     <entry>
        <title>UITableView 使用</title>
        <url>https://iihui.github.io/post/ios-uitableview/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  在iOS开发中，UITableView的使用频率较高，这篇文章主要用于记录一些常用的使用方法和问题解决方案。
 点击cell不变色 func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&amp;gt; UITableViewCell {  let cell = tableView.dequeueReusableCell(withIdentifier: cellId, for: indexPath) as! NoteDetailInfoCell  cell.selectionStyle = .none //点击该cell不变色  return cell }  Cell异步更新 在UITableView中经常要使用到异步请求，请求回来之后要更新相应cell的外观，由于UITableView中的cell存在复用问题，因此异步请求返回之后要特别小心处理。目前个人总结可以有三种方式。
使用内存缓存 在presenter中增加缓存，一般使用map来实现，然后一般以indexPath作为key（也可以其他具有唯一性的id作为key），以异步请求之后返回的某项数据作为value。异步返回之后，更新缓存，然后再在主线程中调用reload方法。
override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&amp;gt; UITableViewCell {  let cell = tableView.dequeueReusableCell(withIdentifier: self.zhGroupCellIdentifier, for: indexPath)  let model = self.presenter.dataSource[indexPath.row]  if let groupCell: ZHGroupCell = cell as? ZHGroupCell {  groupCell.nameLbl.text = model.sessionName  if let image = self.presenter.headCache[model.sessionID] {  groupCell.imgView.image = image  } else {  self.presenter.requestImage(id: model.sessionID,indexPath: indexPath) { [weak self] index in  DispatchQueue.main.async { [weak self] in  tableView.reloadRows(at: [index], with: .none)  }  }  }  }  }  return cell } /// 从服务端获取用户头像 private func getHeaderImageFromRemote(user: ContactsUser, indexPath: IndexPath) {  self.contactsHeadPhotoService.getServerImage(user: user) { [weak self] _ in  DispatchQueue.main.async { [weak self] in  if self?.tableView.cellForRow(at: indexPath) != nil {  if self?.isSearching == true {  self?.tableView.reloadRows(at: [indexPath], with: .none)  } else {  //非搜索状态时有可能有相同的联系人在不同的分组，所以选择全部reload  self?.tableView.reloadData()  }  }  }  } } 使用prepareForReuse() 使用KingFisher请求图片资源时，由于有些图片返回较慢，因为cell复用，可能会导致图片出现错乱，此时可以在prepareForReuse先取消相应的网络请求。
/// 因为使用kingfisher进行图片下载为异步的，所以要解决复用问题 override func prepareForReuse() {  super.prepareForReuse()  self.headerImageView.kf.cancelDownloadTask()  self.dkImageView.kf.cancelDownloadTask() } 设置对应cell 首先异步请求时多加一个indexPath参数，异步返回时把返回的数据和indexPath作为回调参数，然后根据indexPath找到对应的cell，最后更新cell的外观。
override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&amp;gt; UITableViewCell {  let cell = tableView.dequeueReusableCell(withIdentifier: self.zhGroupCellIdentifier, for: indexPath)  let model = self.presenter.dataSource[indexPath.row]  if let groupCell: ZHGroupCell = cell as? ZHGroupCell {  groupCell.nameLbl.text = model.sessionName  if let image = self.presenter.headCache[model.sessionID] {  groupCell.imgView.image = image  } else {  self.presenter.requestImage(id: model.sessionID,indexPath: indexPath) { [weak self] index in  DispatchQueue.main.async { [weak self] in  if let cell = tableView.cellForRow(at: index) as? ZHGroupCell,let model = self?.presenter.dataSource[index.row] {  cell.imgView?.image = self?.presenter.headCache[model.sessionID]  }  }  }  }  }  return cell } 分组显示 链接
range
动态调整footer高度 override func viewDidLayoutSubviews() {  super.viewDidLayoutSubviews()  guard let footerView = self.tableView.tableFooterView else {  return  }  let width = self.tableView.bounds.size.width  let size = footerView.systemLayoutSizeFitting(CGSize(width: width, height: UIView.layoutFittingCompressedSize.height))  if footerView.frame.size.height != size.height {  footerView.frame.size.height = size.height  self.tableView.tableFooterView = footerView  } } 参考
 </content>
    </entry>
    
     <entry>
        <title>贵州之行</title>
        <url>https://iihui.github.io/post/travel-guizhou/</url>
        <categories>
          <category>旅行</category>
        </categories>
        <tags>
          <tag>旅行</tag><tag>贵州</tag>
        </tags>
        <content type="html"> 黄果树瀑布景区 娄山关 外伶仃岛 </content>
    </entry>
    
     <entry>
        <title>Cocoapods 使用</title>
        <url>https://iihui.github.io/post/ios-cocoapods-storage/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> 放入制品库  项目需要引入百度语音合成SDK，但这个第三方库中包含的.a文件过于庞大，按规定不能直接放到代码仓库里，需要移到Cocoapods制品库中，然后再在项目中依赖这个组件。用已有的模板，只要按照要求修改对应文件，然后执行相应上传命令即可，这一过程可以总结为5个步骤。
 第一步 首先修改.podspec文件。为了修改.podspec文件，首先必须创建第三方库目录。下图为第三方库存放的目录结构，如需新建一个第三方库目录，则选中任意一个拷贝一份:
拷贝完了之后修改下图中长方形内文件或者文件夹(共3处)的名字，然后删除下图椭圆内的文件：
为了测试，将上图的副本重命名为BaiduTest，修改上面的3个地方的文件名，再删除文件后如下图所示:
然后修改.podspec文件，这个文件的修改必须使用终端文本编辑器（我使用vim编辑器），否则可能出错，这个文件也有三个地方需要修改。
第一个地方 首先修改s.name,s.version,s.summary,s.description这四个地方，其中s.name保持为上面修改的名字，版本号为0.0.1：
第二个地方 接下来修改s.homepage,只要将最后的名字修改为BaiduTest:
第三个地方 最后修改s.source,将后面两项修改即可，这两项的名字要和s.name和s.version保持一致:
 第二步 第二步修改push.py,目的是将LC10_01_BaiduTest这个目录打包并上传到仓库中，这个文件要修改两处:
第一个地方 将zipCommands后面的名字改为LC10_01_BaiduTest：
第二个地方 将uploadCommand命令后打包目录和打包后的文件的名字改成LC10_01_BaiduTest，如下图所示：
 第三步 第三步执行push.py，即转到push.py脚本所在目录执行./push.py即可。
第四步 修改工程所使用的podfile，在其中添加LC10_01_BaiduTest这一条目，如下图所示：
 第五步 第五步，在终端里首先执行pod repo-art update CocoaPods-cmb命令（可在任何目录），然后转到工程目录下执行pod update命令:
  pod repo-art update CocoaPods-cmb
  pod update
   incompatible target 发布MoUser组件时，使用pod lib lint进行本地检查，发现报错信息为not found for architecture ...
通过可以修改podspce文件，增加s.pod_target_xcconfig = { &#39;VALID_ARCHS&#39; =&amp;gt; &#39;arm64 armv7&#39;, &#39;EXCLUDED_ARCHS[sdk=iphonesimulator*]&#39; =&amp;gt; &#39;arm64&#39; }可以规避这个问题。
参考资料
@objc requires iOS 13.0.0 组件的二进制发布时，遇到了&#39;@objc&#39; instance method in extension of subclass of &#39;ModalViewController&#39; requires iOS 13.0.0 这样的报错信息。这是因为组件设置BUILD_LIBRARY_FOR_DISTRIBUTION = YES，这是因为Swift的ABI不稳定导致的，具体参考
</content>
    </entry>
    
     <entry>
        <title>引入百度语音合成</title>
        <url>https://iihui.github.io/post/ios-synthesizer/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  项目中需要用百度语音合成SDK，因此自己先建了一个Demo工程作为测试，总结下来为准备--&amp;gt; 导入 --&amp;gt; 创建应用 --&amp;gt; 测试。
 准备 首先从百度官网下载百度语音合成的SDK,如下图所示首先在左边选择语音合成，然后在右边选择iOS版的离在线融合SDK:
导入 有两部分需要导入，第一部分是导入百度语音合成所需的文件，第二部分是导入百度语音合成依赖的框架，下面分别讲解：
导入文件夹 接着新建一个测试工程，并将下载到的SDK解压，将下面的3个文件夹导入到项目中，3个文件夹的名称如下图所示:
导入框架 百度语音依赖如下红框里标识的framework，因此需要在TARGETS--&amp;gt;Build Phases-&amp;gt;LikBinary With Libraries中将这些framework导入到项目中：
创建应用 要使用百度语音合成，首先需要创建相关的应用，而创建应用的前提是有百度云帐号。注册好百度云帐号之后登录，在控制台选择百度语音：
然后选择创建百度语音应用：
接着填写相关信息，要注意的是语音包名要与测试工程的Bundle identifier一致（称为绑定），才可以使用百度语音合成的离在线模式:
测试代码 import UIKit  let APP_ID = &amp;#34;XXXXX&amp;#34; let API_KEY = &amp;#34;XXXXX&amp;#34; let SECRET_KEY = &amp;#34;XXXXX&amp;#34;  class ViewController: UIViewController, BDSSpeechSynthesizerDelegate {   fileprivate var synthesiser: BDSSpeechSynthesizer = BDSSpeechSynthesizer.sharedInstance()  @IBOutlet weak var synthesisButton: UIButton!  @IBOutlet weak var textView: UITextView!  @IBOutlet weak var offlineSwitch: UISwitch!   override func viewDidLoad() {  super.viewDidLoad()  BDSSpeechSynthesizer.setLogLevel(BDS_PUBLIC_LOG_VERBOSE)  self.synthesiser.setSynthesizerDelegate(self)  self.textView.delegate = self  self.configOffline()  }   @IBAction func clickedSynthesis(_ sender: UIButton) {  if let sentence = self.textView.text {  self.synthesiser.speakSentence(sentence, withError: nil)  }  }   @IBAction func offlineSwitchClicked(_ sender: UISwitch) {  if sender.isOn {  self.configOffline()  } else {  self.configOnline()  }  }   func configOnline() {  self.synthesiser.setApiKey(API_KEY, withSecretKey: SECRET_KEY)  var error = self.synthesiser.setSynthParam(4, for: BDS_SYNTHESIZER_PARAM_PITCH)  if let err = error {  print(err.localizedDescription)  }  error = self.synthesiser.setSynthParam(5, for: BDS_SYNTHESIZER_PARAM_SPEED)  if let err = error {  print(err.localizedDescription)  }  error = self.synthesiser.setSynthParam(9, for: BDS_SYNTHESIZER_PARAM_VOLUME)  if let err = error {  print(err.localizedDescription)  }  self.synthesiser.unloadDomainDataFromOfflineEngine()  }   func configOffline() {  let offlineEngineSpeechData = Bundle.main.path(forResource: &amp;#34;Chinese_And_English_Speech_Female&amp;#34;, ofType: &amp;#34;dat&amp;#34;)  let offlineChineseAndEnglishTextData = Bundle.main.path(forResource: &amp;#34;Chinese_And_English_Text&amp;#34;, ofType: &amp;#34;dat&amp;#34;)   let error = self.synthesiser.loadOfflineEngine(offlineChineseAndEnglishTextData, speechDataPath: offlineEngineSpeechData, licenseFilePath: nil, withAppCode: APP_ID)  if let err = error {  print(err.localizedDescription)  }  }   func synthesizerNewDataArrived(_ newData: Data!, dataFormat fmt: BDSAudioFormat, characterCount newLength: Int32, sentenceNumber SynthesizeSentence: Int) {   }   func synthesizerErrorOccurred(_ error: Error!, speaking SpeakSentence: Int, synthesizing SynthesizeSentence: Int) {  print(error.localizedDescription)  }   override func viewDidDisappear(_ animated: Bool) {  super.viewDidDisappear(animated)  self.synthesiser.speakSentence(&amp;#34;进入后台&amp;#34;, withError: nil)  } }  extension ViewController: UITextViewDelegate {  func textViewDidChange(_ textView: UITextView) {  if let text = textView.text {  //self.synthesiser?.speakSentence(text, withError: nil)  print(text)  }  } } 参考资料
</content>
    </entry>
    
     <entry>
        <title>半透明的悬浮提示窗</title>
        <url>https://iihui.github.io/post/ios-alert-window/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  项目中需要一个悬浮提示窗，从网上找到一篇以OC为示例的文章，因为公司项目是Swift写的，因此需要将OC转为Swift。
 OC代码 .h文件 //CustomAlertWindow.h #import &amp;lt;UIKit/UIKit.h&amp;gt; typedef NS_ENUM(NSInteger, AlertWindowPositionOption) {  AlertWindowPositionTopMiddle = 0,  AlertWindowPositionCenter,  AlertWindowPositionBottomMiddle };  @interface CustomAlertWindow : UIWindow &#43; (instancetype)aletWindowWithPositionOption:(AlertWindowPositionOption)positionType andInfoText:(NSString *)text; //显示 - (void)show; // 消失 - (void)dismiss; @end .m文件 //CustomAlertWindow.m  #import &amp;#34;CustomAlertWindow.h&amp;#34;  #define LABEL_MARGIN 10 //Label的外边距 #define CENTER_Y_TO_EDGE 80 //悬浮窗中心点距边缘的纵坐标值  @implementation CustomAlertWindow  &#43; (instancetype)aletWindowWithPositionOption:(AlertWindowPositionOption)positionType andInfoText:(NSString *)text {  return [[CustomAlertWindow alloc] initWithPositionOption:positionType andInfoText:text]; }  - (instancetype)initWithPositionOption:(AlertWindowPositionOption)positionType andInfoText:(NSString *)text {  self = [super init];  if (self) {  UILabel *infoLabel = [[UILabel alloc] initWithFrame:CGRectMake(0, 0, 40, 15)];  infoLabel.text = text;  infoLabel.textAlignment = NSTextAlignmentCenter;  infoLabel.font = [UIFont systemFontOfSize:13];  infoLabel.textColor = [UIColor whiteColor];  //label尺寸适应文字大小  [infoLabel sizeToFit];   //根据labelSize确定window的大小  CGSize labelSize = infoLabel.frame.size;  CGSize windowSize = CGSizeMake(labelSize.width &#43; 2*LABEL_MARGIN, labelSize.height &#43; 2*LABEL_MARGIN);  //根据window的尺寸确定label的中心点位置  infoLabel.center = CGPointMake(windowSize.width / 2, windowSize.height / 2);   //得到屏幕的尺寸  CGRect superRect = [[UIScreen mainScreen] bounds];  CGSize superSize = superRect.size;  //计算window的大小  self.frame = CGRectMake((superSize.width - windowSize.width) / 2, 0, windowSize.width, windowSize.height);   //根据指定的positionType设置window的center  switch (positionType) {  case AlertWindowPositionTopMiddle:  self.center = CGPointMake(superSize.width / 2, CENTER_Y_TO_EDGE);  break;   case AlertWindowPositionCenter:  self.center = CGPointMake(superSize.width / 2, superSize.height / 2);  break;   case AlertWindowPositionBottomMiddle:  self.center = CGPointMake(superSize.width / 2, superSize.height - CENTER_Y_TO_EDGE);  break;   default:  break;  }   self.windowLevel = UIWindowLevelAlert &#43; 1;  self.backgroundColor = [UIColor colorWithRed:64 / 255.0 green:64 / 255.0 blue:64 / 255.0 alpha:0.7];  self.layer.cornerRadius = 5;   [self addSubview:infoLabel];  }   return self; }  //显示window - (void)show {  [self makeKeyAndVisible]; }  //window消失 - (void)dismiss {  [self resignKeyWindow]; }  @end  Swift实现 根据上面的OC代码，将其改造为Swift代码：
import Foundation //参考自 https://www.jianshu.com/p/e31eeb26cdce enum positionStyle: Int {  case TopMiddle = 0  case Center = 1  case BottomMiddle = 2 }  class NoteAlertWindow: UIWindow {  fileprivate var style = positionStyle.TopMiddle  fileprivate var infoLabel: UILabel?  fileprivate var labelMargin: CGFloat = 10  fileprivate var centerYToEdge: CGFloat = 80   required init?(coder aDecoder: NSCoder) {  super.init(coder: aDecoder)  }   init(option: positionStyle, text: String) {  let frame = CGRect()  super.init(frame: frame)  self.style = option   if self.infoLabel == nil {  self.infoLabel = UILabel(frame: CGRect(x: 0, y: 0, width: 30, height: 15))  adjustWindow(message: text)  self.addSubview(self.infoLabel!)  }  }   func show() {  self.makeKeyAndVisible()  }   func dismiss() {  self.resignKey()  }   func moveCenter(center: CGPoint) {  self.center = center  }   func setMessage(text: String) {  adjustWindow(message: text)  }   fileprivate func adjustWindow(message: String) {  self.infoLabel?.text = message  self.infoLabel?.textAlignment = .center  self.infoLabel?.font = UIFont.systemFont(ofSize: 13)  self.infoLabel?.textColor = UIColor.white  self.infoLabel?.sizeToFit()   if let labelSize = self.infoLabel?.frame.size {  let windowSize = CGSize(width: labelSize.width &#43; 2 * self.labelMargin, height: labelSize.height &#43; 2 * self.labelMargin)  self.infoLabel?.center = CGPoint(x: windowSize.width / 2, y: windowSize.height / 2)  let superGect = UIScreen.main.bounds  let superSize = superGect.size   self.frame = CGRect(x: (superSize.width - windowSize.width) / 2, y: 0, width: windowSize.width, height: windowSize.height)   switch self.style {  case .TopMiddle: self.center = CGPoint(x: superSize.width / 2, y: self.centerYToEdge)  case .Center: self.center = CGPoint(x: superSize.width / 2, y: superSize.height / 2)  case .BottomMiddle: self.center = CGPoint(x: superSize.width / 2, y: superSize.height / 2 - self.centerYToEdge)  }   self.windowLevel = UIWindowLevelAlert &#43; 1  self.backgroundColor = UIColor(red: 64 / 255.0, green: 64 / 255.0, blue: 64 / 255.0, alpha: 0.7)  self.layer.cornerRadius = 5  }  } }  </content>
    </entry>
    
     <entry>
        <title>JS事件捕获</title>
        <url>https://iihui.github.io/post/js-event/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>JS</tag>
        </tags>
        <content type="html">  DOM事件从发生到开始经历了三个阶段，分别为捕获阶段、命中阶段以及冒泡阶段。捕获阶段表示从最上层开始，直到最下层(点击的那个target元素)，路过的所有节点都可以捕获到该事件。命中阶段:如果某个事件到达了target，它就会进行处理。冒泡阶段:事件从最下层向上传递，依次触发父元素的该事件处理。
 </content>
    </entry>
    
     <entry>
        <title>使用Visual Code的文件对比功能</title>
        <url>https://iihui.github.io/post/qa-compare/</url>
        <categories>
          <category>QA</category>
        </categories>
        <tags>
          <tag>QA</tag>
        </tags>
        <content type="html">  在使用坚果云的时候，由于较长时间没有同步，导致本地文件和云端文件冲突，再次同步时，坚果云保留了两个版本。为了弄清两个文件的差异，以进行修改，需要一个工具来比对。最初是想下载一个专门的文件对比软件，但转念一想或许Visual Code可以呢，一搜果真Visual Code自带文件对比功能。
 废话不多说，首先放上动图：
上面动图的操作可以分解为3步，第一步为打开左侧边栏，第二步为打开需要比较的文件，第三步为对比。
 第一步 首先打开SideBar，在菜单栏中依次点击View--&amp;gt;Appearance--&amp;gt;Toggle Side Bar,如下图所示:
 第二步 按住Command &#43; o(字母)打开要比较的文件，或者在菜单栏找到File---&amp;gt;Open：  第三步 在左侧的Open Editors目录下找到上一步需要比较的文件，然后点击鼠标右键，选中Compare Selected进行比对：  </content>
    </entry>
    
     <entry>
        <title>创建新的Target</title>
        <url>https://iihui.github.io/post/ios-new-target/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  项目需要新建一条众测流水线，因此首先需要基于DEV环境新建一个Target，然后将新建的Target配置到新建的流水线上。
 Duplicate 新Target的创建一般以已有的Target为模板，如下图所示，首先选中模板Target，然后右键点击选中Duplicate就能创建新的Target:
 修改Target名字 首先点击新的Target然后按回车键修改名字，此时修改的名字
修改plist 一旦点击Duplicate就会生成一个模板的copy,同时会生成一个新的plist文件，如下图所示： 新的plist文件和
</content>
    </entry>
    
     <entry>
        <title>Range的保存与恢复</title>
        <url>https://iihui.github.io/post/js-focus-save/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>JS</tag>
        </tags>
        <content type="html">  在iOS 11.3以下的UIWebview中插入图片时，因图片选择器的弹出导致UIWebview失去焦点，故在插入图片前需先保存图片将要插入的位置。
 保存range区域 图片选择器打开前，利用一个全局的Range对象保存插入前光标所在的位置的Range对象：
//插入图片和超链接的时候因为webview会失去焦点，因此需要保存range区域 let currentSelection; function backupRange() {  let selection = window.getSelection();  if (selection.rangeCount) {  let range = selection.getRangeAt(0);  this.currentSelection = {  &amp;#34;startContainer&amp;#34;: range.startContainer,  &amp;#34;startOffset&amp;#34;: range.startOffset,  &amp;#34;endContainer&amp;#34;: range.endContainer,  &amp;#34;endOffset&amp;#34;: range.endOffset  }  } }  恢复Range区域 选择图片后，插入时要找到图片选择器打开前光标所在的Range，以便插入到正确的位置：
//恢复保存的range区域 function restoreRange() {  if (this.currentSelection) {  let selection = window.getSelection();  selection.removeAllRanges();  let range = document.createRange();  range.setStart(this.currentSelection.startContainer, this.currentSelection.startOffset);  range.setEnd(this.currentSelection.endContainer, this.currentSelection.endOffset);  selection.addRange(range); // 向选区中添加一个区域  } }  </content>
    </entry>
    
     <entry>
        <title>Swift访问权限</title>
        <url>https://iihui.github.io/post/swift-access-controller/</url>
        <categories>
          <category>iOS</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  访问权限用于限制部分代码被其它源文件或者模块访问，目的是隐藏某些代码的实现细节。在Swift中可以设置类型(类、结构和枚举)的访问权限，也可以设置属性和方法的访问权限。Swift提供了5个访问级别，这些访问级别以模块和源文件为区分粒度。
 模块 模块是指独立的代码单元，在iOS中框架或应用程序就是一个独立模块。在一个模块中可以用import关键字导入另一个模块。
源文件 源文件即Swift中的源代码文件，它通常属于一个模块，即一个框架（Framework）或者应用程序。
访问级别 Swift有5个级别的访问权限，从高到低依次为open，public，internal，fileprivate和private。它们遵循的原则是，高级别的变量不允许被定义为低级别变量的成员变量。例如，一个private的类中不应该出现public的String。但是，低级别的变量可以定义在高级别的变量中。例如，public的class中可以含有private的Int值。
open open具有最高的访问权限。其修饰的类和方法可以在任意Module中被访问和重写，它是Swift3中新添加的访问权限。
public public的权限仅次于open，它与open区别在于：public修饰的对象可以在任意module中被访问，但是不能被其他module重写或继承。
open与public的区别 虽然open和public都有最高的访问级别，但open访问权限只适用于修饰class和class的成员，它与public有明显的不同：
  public修饰的class只允许外部模块调用，但是不允许外部模块继承，本模块可以继承。而open修饰的class既允许其他模块调用，也允许被子类继承。
  public修饰的成员只允许其他模块调用，但不能被外部模块重写(override)，本模块可以重写。而open修饰的成员既允许被其他模块调用，也允许成员被覆盖。
  open和public如果是用于继承某个类的话，那么open和public必须是在父类的约束限定之下。例如：不能父类是用public修饰，而子类却用open修饰。
  其他模块继承覆盖父类的成员时，也需要把成员声明为open。
  open class SubclassableParentClass {  public func foo() {  //  }   open func bar() {  //  }   public final func baz() {  //  } }  open class SubclassC: SubclassableParentClass {  //非法，成员没有被声明为open  override func bar() {  //  } } internal internal是默认的权限。它表示只能在当前定义的module中访问和重写。它可以被一个module中的多个文件访问，但不能被其他module访问。
fileprivate 由fileprivate修饰的实体可以在当前文件内被访问。若某个功能只要在文件内使用，则可以使用这个访问符修饰，这也是Swift 3新添加的权限。
private private是最低阶别的访问权限，它的对象只能在定义的作用域内使用，离开了这个作用域，即时是同一个文件的其他作用域，也无法访问。
</content>
    </entry>
    
     <entry>
        <title>img添加和取消点击监听</title>
        <url>https://iihui.github.io/post/js-image-addclicklistener/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>JS</tag>
        </tags>
        <content type="html">  一篇图文笔记可能有多张图片，目前的需求为单击图片后开始预览图片。想到的解决思路有两种，第一种是为每张图片添加点击事件的监听，这种方式的麻烦在于要监听是否有新图片插入，一旦有新图片插入时则要对其加入点击事件的监听；第二种则是全局监听点击事件，用户一旦点击，则判断该点击事件是否在img标签上，如果是则进入图片预览，否则什么也不做。
 第一种方式 每次进入图文笔记的浏览模式时为所有img添加点击事件的监听。因此，需要监听是否有新图片插入，一旦有新图片插入时需要将原来所有图片的点击事件的监听删除，再重新为所有图片添加新的点击监听。
添加监听 function addImagesClickListener(){  $(&amp;#39;body&amp;#39;).on(&amp;#39;click&amp;#39;, &amp;#39;img&amp;#39;, function () {  let position = this.offsetTop;  this.focus();  let result = {};  result.position = position.toString(); //顺便将图片所在纵位置返回  result.src = $(this).attr(&amp;#34;src&amp;#34;);  let jsonString = JSON.stringify(result);  let escapedJsonString = encodeURI(jsonString); //重新编码  let scheme = &amp;#34;position://&amp;#34;;  document.location.href = scheme &#43; &amp;#34;#&amp;#34; &#43; escapedJsonString; //向ios发送  }); }  取消监听  function removeImagesClickListener() {  // let pic = document.getElementsByTagName(&amp;#39;img&amp;#39;);  // for (i = 0; i &amp;lt; pic.length; i&#43;&#43;) {  // pic[i].off(&amp;#39;click&amp;#39;);  // }  $(&amp;#39;img&amp;#39;).each(function () {  $(this).off(&amp;#39;click&amp;#39;); //移除所有图片的点击监听  })  }  第二种方式 利用全局监听点击事件，检查该点击事件的元素是否在img上，如果是则进入图片预览模式，但是这种方式会与UIWebview键盘弹出有冲突，因此进入图片浏览时需要先关掉键盘：
//与软键盘弹出有冲突，应该先关闭键盘 function clickHandler(event) {  if (event.target instanceof HTMLImageElement) {  //点击的是图片标签,则获取点击图片的src  $(&amp;#39;img&amp;#39;).each(function () {  if (this.isSameNode(event.target)) {  //https://segmentfault.com/q/1010000000156830/a-1020000000156902  document.activeElement.blur(); //首先关闭键盘以免冲突  let result = {};  result.src = $(this).attr(&amp;#34;src&amp;#34;);  let jsonString = JSON.stringify(result);  let escapedJsonString = encodeURI(jsonString); //重新编码  let scheme = &amp;#34;position://&amp;#34;;  document.location.href = scheme &#43; &amp;#34;#&amp;#34; &#43; escapedJsonString; //向ios发送  }  });  } }  </content>
    </entry>
    
     <entry>
        <title>img点击监听</title>
        <url>https://iihui.github.io/post/js-image-clickedlistener/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>JS</tag>
        </tags>
        <content type="html">  一篇图文笔记可能有多张图片，目前的需求为单击图片后开始预览图片。想到的解决思路有两种，第一种是为每张图片添加点击事件的监听，这种方式的麻烦在于要监听是否有新图片插入，一旦有新图片插入时则要对其加入点击事件的监听；第二种则是全局监听点击事件，用户一旦点击，则判断该点击事件是否在img标签上，如果是则进入图片预览，否则什么也不做。
 第一种方式 每次进入图文笔记的浏览模式时为所有img添加点击事件的监听。因此，需要监听是否有新图片插入，一旦有新图片插入时需要将原来所有图片的点击事件的监听删除，再重新为所有图片添加新的点击监听。
添加监听 function addImagesClickListener(){  $(&amp;#39;body&amp;#39;).on(&amp;#39;click&amp;#39;, &amp;#39;img&amp;#39;, function () {  let position = this.offsetTop;  this.focus();  let result = {};  result.position = position.toString(); //顺便将图片所在纵位置返回  result.src = $(this).attr(&amp;#34;src&amp;#34;);  let jsonString = JSON.stringify(result);  let escapedJsonString = encodeURI(jsonString); //重新编码  let scheme = &amp;#34;position://&amp;#34;;  document.location.href = scheme &#43; &amp;#34;#&amp;#34; &#43; escapedJsonString; //向ios发送  }); }  取消监听  function removeImagesClickListener() {  // let pic = document.getElementsByTagName(&amp;#39;img&amp;#39;);  // for (i = 0; i &amp;lt; pic.length; i&#43;&#43;) {  // pic[i].off(&amp;#39;click&amp;#39;);  // }  $(&amp;#39;img&amp;#39;).each(function () {  $(this).off(&amp;#39;click&amp;#39;); //移除所有图片的点击监听  })  }  第二种方式 利用全局监听点击事件，一旦出现点击事件，则判断该点击事件的元素是否在img上，如果是则进入图片预览模式，但是这种方式会与UIWebview键盘弹出有冲突，因此进入图片浏览前需要先关掉键盘：
//与软键盘弹出有冲突，应该先关闭键盘 function clickHandler(event) {  if (event.target instanceof HTMLImageElement) {  //点击的是图片标签,则获取点击图片的src  $(&amp;#39;img&amp;#39;).each(function () {  if (this.isSameNode(event.target)) {  //https://segmentfault.com/q/1010000000156830/a-1020000000156902  document.activeElement.blur(); //首先关闭键盘以免冲突  let result = {};  result.src = $(this).attr(&amp;#34;src&amp;#34;);  let jsonString = JSON.stringify(result);  let escapedJsonString = encodeURI(jsonString); //重新编码  let scheme = &amp;#34;position://&amp;#34;;  document.location.href = scheme &#43; &amp;#34;#&amp;#34; &#43; escapedJsonString; //向ios发送  }  });  } }  </content>
    </entry>
    
     <entry>
        <title>单例模式</title>
        <url>https://iihui.github.io/post/ios-singleton/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  单例模式(Singleton Pattern)属于创建型模式，该模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有一个单例对象被创建。
 第一种方式 利用Swift中全局变量的懒加载和全局变量初始化时默认使用dispatch_once以保证全局变量的构造器只会被调用一次:
let sharedManager = MyManager(string: someString) //定义全局变量 class MyManager {  let string: String  //初始化器  init(string: String) {  self.string = string  } }  第二种方式 利用static和private两个关键字,static关键字说明该变量是类变量而不是实例变量；而private保证了该类变量为单例：
class MyManager {  // 全局变量  static let shared = MyManager(string: someString)   // 属性  let string: String  // 初始化器  private init(string: String) {  self.string = string  } } // 使用 print(MyManager.shared)  第三种方式 第三种方式是让单例在闭包中初始化，同时加入类方法以获取单例。这种方式的好处是可以在闭包中做一些额外的配置：
class MyManager {  // private 修饰  private static let sharedManager: MyManager = {  let shared = MyManager(string: someString)  // 可以做一些其他的配置  // ...  return shared  }()  // Properties  let string: String  // 构造函数，由private修饰  private init(string: String) {  self.string = string  }  // 访问器  class func shared() -&amp;gt; MyManager {  return sharedManager  } } //使用 print(MyManager.shared()) 单例的缺陷   由于单例是共享的，因此程序员无法预测单例当前的状态。
  因为其它共享的实例可以修改，因此测试困难。
  无法对访问权限作出限定，容易造成管理上的混乱。
   参考资料
</content>
    </entry>
    
     <entry>
        <title>Papers教程</title>
        <url>https://iihui.github.io/post/tool-papers/</url>
        <categories>
          <category>Tool</category>
        </categories>
        <tags>
          <tag>Tool</tag>
        </tags>
        <content type="html">  Papers软件对自己的定位为个人科研图书馆，其主要功能为文献收集(Find)、文献整理(Organize)、文献阅读(Read)和文献引用(Cite)。这篇教程主要关注Papers的引用功能。
 四个功能 首先对上面提到的4个功能进行简介，以对Papers这个软件有个初步的认识，同时也可以了解文献管理软件的基本功能特点。
文献收集 文献收集：把原来需要借助浏览器从谷歌学术等学术站点搜索文献的功能整合到Papers软件中。即可以直接在Papers中搜索文献，而不用切换到浏览器去搜索文献。但因为这是国外开发的一款软件，因此不支持如百度学术这样的中文学术搜索站点：
文献整理 文献整理：利用Papers对收集到的学术资料进行整理。换句话说，就是对搜集到的文献资料进行分类整理，建立档案系统的过程。
有了完善的档案系统，后续需要查找某个文献的时候，只要在Papers中进行搜索就可以。如果需要引用某个文献只要按住快捷键搜索就可导入到Word中(随后详细介绍)。下面就你开题时我帮你查资料时，整理的一些参考文献：
文献阅读 文献阅读：是指可以在Papers中阅读文献，但只限于PDF文档和在Papers中搜索到的文章。可以事先将PDF文档导入到Papers中，或者在Papers中下载相关的PDF文档，再在其中阅读。下图即为阅读界面：
文献引用 文献引用：就是在Papers建立的个人图书馆中搜索相关的文献，然后将其对应的引用格插入到Word或者其他的文字编辑软件中，下面的动图是一个简单的例子：
上面的动图实际上是5个步骤组合起来的效果，后面会详细介绍，当前只做一个演示。
安装与打开 软件安装 通过上面4个功能的简介，你对这个软件应该有一点了解了，下面开始介绍怎么安装软件。先下载软件，然后按照下面的gif的步骤进行操作即可：
上面gif所演示的操作可以分解为3步：
  首先选中后缀为.dmg的文件，然后双击打开，出现下图所示的界面：   在上图中点击同意，然后出现下图所示的界面：   将上图中的Papers拖到Applications中，安装到此完成了。
   打开软件 首先在应用程序中找到Papers的图标，然后点击该图标以打开Papers软件：
当第一次打开时，会提示Papers是从互联网下载的应用程序，是否确定要打开它：
在上图中点击打开，软件会要求创建一个新库或者导入以前在电脑里保存的库(只有第一次打开才会有这个提示)：
因为是第一次安装，因此选择创建新库即可，上图中Other Location表示可以选择创建新的库的存放位置，选择默认即可，不用去设置。
软件界面 打开了软件，软件的5大区域映入眼帘，分别为左侧边栏，顶部按钮栏，主工作区,预览区域和右侧边栏，如下图所示：
顶部按钮 顶部按钮栏包括6个小按钮，如下图所示从左到右分别为搜索、库、标记、作者、来源以及阅读。除了搜索按钮外，其他5个按钮均表示分类查看文献：
  搜索：搜索文献(在此处搜索和在浏览器搜索有相似的效果)。
  库：表示查看导入到软件中的所有文献。
  标记：按照事先做好的标记来查看文献。
  作者：根据作者来查看文献。
  来源：根据文献的来源来查看。
  阅读：在这个软件中阅读打开的文献(指PDF文档或者网页)。
  左侧边栏 当点击某个顶部按钮后，左侧边栏显示的是分类和结构（具体功能决定于点击的是哪个顶部按钮），下图为前5个顶部按钮对应的左侧边栏：
 右侧边栏 当点击某个顶部按钮后，右侧边栏显示的是在主工作区中选中的某篇文献的属性。如下图所示，属性分为四种，从左到右分别表示概览、信息、笔记和动态：
  概览(Overview)：显示的是选中文献的类型(Type)、标题(Title)、作者(Authors)、来源(Sources)（这些信息在概览中不可以修改,需要在Info中修改）。同时可以给文献添加或修改评论(My Review)、关键字(Keyword)，也可以把选中的文献放入某个收藏集(Collection)，也可以给文章按1~5颗星的标准评分，添加颜色(Color)标记和旗标(Flag)。
  信息(Info): 这里可以修改文档大部分属性，如标题(Title)、副标题(Subtitle)、作者(Authors)、类型(Type)、出版日期(Published) 等。
  笔记(Notes): 如果对一篇文章进行了标注，添加了笔记，将在这里显示。
  动态(Activity): 显示的是与选中的文献相关的文献，以及社交网络分享情况。
  下图展示的是点击概览、信息、笔记和动态按钮后所展示的界面：
导入文献 通过安装软件和界面的展示，应该对这个软件有了一个整体的认识，那接下来就介绍怎么将参考文献导入到Papers中。
建立库的过程就是将文献不断导入到Papers软件中。导入文献有两种方式，一种是通过软件的搜索来导入，一种是通过导入文件的形式导入。
搜索导入 搜索导入指的是首先在软件中进行搜索，然后将搜索到的文献直接导入软件中，如下动图所示：
这种方式看起来虽然很方便，但有3只拦路虎🐯阻止了我们使用这个功能☹️：
  第一只🐯&amp;mdash;不支持中文站点。在前面讲文献收集的时候，我提到过因为是外国的软件，所以暂时不支持如百度学术等的中文站点的搜索，这导致了不能将中文参考文献直接导入到软件中(后面会说通过“曲线救国”的方式来导入)。   从上面的图来看，你可能会问谷歌学术不是支持中文搜索吗? 谷歌学术 是支持中文搜索，但是有两个问题要弄明白：首先正常状态下(不翻墙)我们不能直接访问谷歌学术，其次谷歌学术上收录中文期刊比较少，不如百度学术丰富。所以第二只🐯&amp;mdash;支持中文搜索的引擎收录的中文参考文献少而且正常情况下不能直接访问这些站点。
  第三只🐯&amp;mdash;搜索功能对于中文输入及其不友善。搜索的时候只能一个字一个字输入，不能一下子输入两个以上字的词(听起来就想很无语😁是吧？)。   啰嗦了这么一大堆，你可能会疑惑那为什么还要把这个搜索导入单独拿出来讲这么多？ 那是因为写论文时有很多参考文献都是英文的，搜中文不行，直接搜索导入英文参考文献它还是可以的😂。
文件导入 因为不支持中文站点的直接搜索，那么我们就先到百度学术上去搜索，看看能不能直接引用：
疑惑1 看到上面那个gif里的那个引用按钮是不是有点小雀跃？哈哈，竟然能直接引用诶😄。到最后一步是不是又有点懵了？&amp;mdash;我是该直接复制呢，还是选一个链接导入到文献管理软件呢？
哈哈，当然是选「利用其中一个链接导入到文献管理软件中」，因为复制粘贴的话，一旦在Word中删除或者添加一个文献时，引用的小上标的序号都需要修改，参考文献很多时，这个就变得异常麻烦。
疑惑2 上面那个疑惑解决了，看到导入链接有好几个选项，你是不是开始疑惑应该要选哪一个呢？
答案是选Papers支持导入的格式，在Papers的菜单栏中依次打开File---&amp;gt;Import可以查看支持的导入格式：
和上面一对比，可以发现BibTex、EndNote和Refman(不需要知道这三种格式具体是怎么样的)都支持。所以这3种都是可以选的，在Word中我通常会选EndNote，因此下面的介绍都默认选择EndNote格式的引用。
下载 点击EndNote之后会自动下载引用文件，引用文件是存储文献中的作者、发表年代以及发表的期刊等信息的文件，不是指文献本身，如下所示：
上面下载的引用文件默认是保存到下载目录，如果下载目录没有叫做xueshu.enw的文件，那么刚刚下载的引用文件就会被命名为xueshu.enw，如果已经有了就会被命名为xushu-2.enw，如果再下载新的引用文件则会命名为xushu-3.enw，依次类推，如下所示：
导入 下载后引用文件，就要将其导入到Papers中，使其成为文献库的一部分。导入分为两种方式，第一种是还没有打开papers软件，第二种情况是已经打开Papers软件。
未打开导入 先看还没有打开Papers软件的情况，首先选中要导入的引用文件(如果要选多个就按住shift键，然后一个一个添加)，然后双击即可(是不是超简单呢😄):
 打开导入 如果已经打开了Papers软件，那么就在顶部的菜单栏中找到File--&amp;gt;Import--&amp;gt;EndNoteEnw导入即可：
修改信息 修改作者 问题引入 按照上面的方式导入了引用文件，按理来说此时应该就可以直接进入引用了。那接下来我们就开始引用，看会不会出现什么问题。假如我们要引用《音乐的德育功能》这篇论文：
从上面的动图，不难看出作者的名字从焉树芬变成了芬焉树，也就是Papers把作者的姓放在了后面。看到这你应该明白这是中西方文化差异引起的。
那你肯定会有疑问，是不是哪个地方能改呢。还真被你猜到了，在Papers中的设置中可以修改(但你接下来会发现软件的开发者太不友好了)，在菜单栏按照如下操作Papers--&amp;gt;Preferences--&amp;gt;Sources--&amp;gt;Author Format：
上面的例子中作者的中文名字叫做冯登科，从动图中可以发现，所有的组合都没能正确显示冯登科(看Example那一行)，最接近的中间还有个,。
看到这里你可能会想这个软件好菜😂，为什么一到中文就不行了呢？ 其实它对英文参考文献是很友好的，只是还没有对中文进行优化。
解决方案 是不是没有解决方法呢？这个问题是有一种解决方案的，先来看动图的操作：
为了详细的介绍，将上面的操作可以分解为3步：
  首先单击选中参考文献：   在右侧栏选中info(第二个按钮)   然后单击选中Author下的姓名: 然后先删除First、Middle、Last， 再选中Company or Institute,然后在Last那一项下输入焉树芬，改完之后点击Save就可以保存了:   最后再在Word中引用显示的姓名就正常了☺️。
修改其他 在右侧边栏里提到过info这一项可以修改很多信息，只要点击相应的项就可以了，如下图所示：
添加收藏集 当一篇参考文献导入之后，我们可以将其归为某一类。归为某一类通常是加入收藏集(Collection)，下图就是我在使用过程中的归类:
将某个参考文献加入到收藏集(Collection)相当简单，只要在右侧边栏选中概览(第一个按钮)，然后单击Add to collection就可以开始添加：
在最后一步中，如果把参考文献加入已有的收藏集，则只要选中相应行的矩形就可以，如果不存在你要加的收藏集，则只要在Fiter那一行输入新的名字，然后按回车键(Enter)即可:
添加好收藏集就可以查看收藏集下面的参考文献了，首先点击顶部按钮的库，然后选中相应的收藏集，如下图所示: 引用文献 导入了引用文件，将信息修正并加入到对应的收藏集之后，所有的准备工作就算是完成了，接下来开始引用参考文献。
配置快捷键 上面已经好几次出现了引用参考文献，可能会有疑惑——在Word中是怎么把下面这个参考文献搜索界面调出来的?
答案就是事先配置快捷键，只要事先为引用配置了快捷键，在Word中只要按住改快捷键就可以调出这个搜索界面，配置快捷键的方法如下:
为了更清楚的展示上面的操作，将其分解为3步：
  首先在菜单栏找到Papers按钮，然后再点击选中Preferencses(也可以直接按住快捷键Command&#43;,)：   然后再在弹出的界面中，点击选中Citations:   最后单击选中Click to record shortcut，会提示type shortcut，此时只要按住Shift &#43; M(也可以是其其它快捷键)就把快捷键设置好了:
  设置引用样式 对于同一篇参考文献，世界上不同的国家和期刊会使用不同的引用样式，我查看了你学校的硕士毕业论文参考文献格式要求，发现是用的国标，所以需要修改参考文献样式，操作如下动图所示:
为了更清楚的展示上面的操作，将其分解为6步：
 首先在菜单栏找到Papers按钮，然后再点击选中Preferencses(也可以直接按住快捷键Command&#43;,)：  然后再在弹出的界面中，点击选中Citations:  然后在Favorite Styles下拉选中More Styles:  然后在搜索框里搜索GB(表示国标):  然后选中7714-GB2005(numberic,Chinese)，选中之后点击Done:  点击Done之后会返回到上一个界面，此时在Favorite Styles下拉，然后选中7714-GB2005(numberic,Chinese):   开始引用 看到这里是不是已经开始头晕了😂，不要紧，先去休息下吧，精彩稍后继续💤💤💤。到这一步的时候，其实所有的准备工作都已经做好了，接下来只管引用参考文献就好了。参考文献的引用可以分为两步，第一步是插入占位，第二步为格式化。
插入占位 所谓插入，就是在论文中找到对应的位置插入一个占位符以标识某一句是引用自哪篇文章,如下图所示:
插入占位的步骤的动图如下:
上面的动图可以分解为3步:
 首先，按住快捷键Shift&#43;M,以调出参考文献搜索界面：  然后，从搜索结果里选中目标文章，然后按回车键(Enter键):  最后，选中insert Citation进行插入:   格式化 所谓格式化，就是把上一步的所有的占位符变为数字上标，并在文章最后以设置的样式显示参考文献，如下图所示: 上面的操作可以分解为2步:
 首先，按住快捷键Shift&#43;M,以调出参考文献搜索界面,此时如果上次没有进行搜索过的话会出现如下界面： 如果上次搜索过文献，则会出现下面这个界面，那么首先应当删除搜索框里的内容，这样才会显示Format manuscript选项:  在上一步出现了Format manuscript的界面，单击选中这一项，即进行格式化:   总结 哈哈终于写完啦☺️，上面就是插入参考文献的完整过程，使用流程图总结，如下图所示：
参考资料 参考资料 参考资料
</content>
    </entry>
    
     <entry>
        <title>Swift中for循环</title>
        <url>https://iihui.github.io/post/swift-for-in/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  Swift中只有一种形式for循环，即for in。但是for-in有多种形式，既包括常规用法又包括区间循环。
 常规用法 常规用法一般用于直接访问数组中的元素，可以分为直接访问和按索引访问：
let arr = [34,78,789,-12] for item in arr{  print(item) } 在OC中是通过索引i来访问数组中的元素，在Swift中需要借助枚举enumerated()来实现，如下所示：
for item in arr.enumerated(){  print(item.offset,item.element) } for (i,num) in arr.enumerated(){  print(i,num) }  区间循环 在Swift中...表示闭区间，例如0...10表示0，1，2，...，10；而..&amp;lt;表示前闭后开区间，例如0..&amp;lt;10表示0，1，2，...，9。
for i in 0...10{  print(i) }  for i in 0..&amp;lt;10{  print(i) } 如果要使用倒序，则需要将顺序区间进行reversed()，在...和..&amp;lt;这两种表示中要求左边界小于等于右边界。
for i in (0 ... 10).reversed() {  print(i) } 此外，Swift还提供了一种更灵活的stride，以满足不同的递增条件以和开闭区间的结合：
func stride&amp;lt;T&amp;gt;(from start: T, to end: T, by stride: T.Stride) func stride&amp;lt;T&amp;gt;(from start: T, through end: T, by stride: T.Stride) //from:开始位置包括上边界 by：递增步长 //to：结束位置，前闭后开区间，不包含右边界 //through：结束位置，全闭区间，包含右边界 for i in stride(from: 0, to: 10, by: 2){  print(i, terminator: &amp;#34;\t&amp;#34;) //0 2 4 6 8 } for i in stride(from: 0, through: 10, by: 2){  print(i, terminator: &amp;#34;\t&amp;#34;) //0 2 4 6 8 10 } 如果要实现递减，则需要将by改成负数:
for i in stride(from: 10, through: 0, by: -2){  print(i, terminator: &amp;#34;\t&amp;#34;) //10 8 6 4 2 0 } 如果中途改变by的值，不会起作用，查看源码发现by是以传值的方式传递到stride函数中的：
var step = -3 for i in stride(from: 10, through: 0, by: step){  print(i, terminator: &amp;#34;\t&amp;#34;) //10 7 4 1  step -= 2 //虽然改变了step但结果依然是10 7 4 1 }  参考资料 参考资料
 </content>
    </entry>
    
     <entry>
        <title>基本内排序算法Swift实现</title>
        <url>https://iihui.github.io/post/swift-sort/</url>
        <categories>
          <category>算法</category>
        </categories>
        <tags>
          <tag>算法</tag>
        </tags>
        <content type="html">  排序就是重新排列表中的元素，使表中的元素满足按关键字递增或者递减的排列过程。排序算法分为内排序和外排序。内排序是指排序期间元素全部放在内存中的排序；而外排序是指在排序期间元素太多，不能同时全部存放在内存中，必须在排序过程中根据要求，不断在内，外存之间移动的排序。内排序可归纳为插入排序，选择排序，交换排序、归并排序，计数排序，基数排序等。
 插入排序 直接插入排序 直接插入排序是在有序的基础上进行排序。对于数组来说第一个元素默认是有序的，从第二个元素开始，在前面已经有序的元素中找到当前元素应该在的位置进行插入：
//直接插入排序，时间复杂度为O(n^2)，空间复杂度为O(1)，稳定的排序算法 static func insertSort&amp;lt;T: Comparable&amp;gt;(data: [T]) -&amp;gt; [T] {  var result = data  var j: Int  for i in 1 ..&amp;lt; result.count {  let tmp = result[i]  j = i - 1  while j &amp;gt;= 0 {  if result[j] &amp;gt; tmp {  result[j &#43; 1] = result[j]  j -= 1  } else {  break  }  }  result[j &#43; 1] = tmp  }  return result }  直接插入排序是稳定的排序算法 时间复杂度为$O(n^2)$ 空间复杂度为$O(1)$   折半插入排序 折半插入排序，在查找当前元素应该插入的位置时，利用前面元素已经有序的特点，以二分法进行查找：
//二分插入排序,时间复杂度为O(nlog(n))，空间复杂度为O(1)，不稳定的排序算法,例子为(2,2,2) static func binarySort&amp;lt;T: Comparable&amp;gt;(data: [T]) -&amp;gt; [T] {  var result = data  var start, end, mid: Int  for i in 1 ..&amp;lt; result.count {  let tmp = result[i]  start = 0  end = i - 1  while start &amp;lt;= end {  mid = start &#43; (end - start) / 2  if result[mid] == result[i] {  end = mid  break  } else if result[mid] &amp;gt; result[i] {  end = mid - 1  } else {  start = mid &#43; 1  }  }  for j in stride(from: i - 1, through: end &#43; 1, by: -1) {  result[j &#43; 1] = result[j]  }  result[end &#43; 1] = tmp  }  return result }  是不稳定的排序算法，例如(1,1,1,1,1) 时间复杂度为$O(n^2)$，二分查找插入位置，因为不是查找相等值，而是基于比较查插入合适的位置，所以必须查到最后一个元素才知道插入位置。 空间复杂度为$O(1)$   Shell排序 希尔排序是先将待排序的表分割为若干形如$L[i,i&#43;d,i&#43;2d,..i&#43;kd]$的子表，分别进行直接插入排序，当整个表中元素已呈基本有序时，再对全体进行一次直接插入排序。
//shell排序，时间复杂度O(nlog^k(n)),空间复杂度为O(1),不稳定的排序算法，例子为(2,2,1) static func shellSort&amp;lt;T: Comparable&amp;gt;(data: [T]) -&amp;gt; [T] {  var result = data  var step = result.count / 2  while step &amp;gt;= 1 {  self.assistShellSort(data: &amp;amp;result, step: step)  step /= 2  }  return result } static private func assistShellSort&amp;lt;T: Comparable&amp;gt;(data: inout [T], step: Int) {  guard step &amp;gt;= 1 else {  return  }  var j = 0  for i in 1 ..&amp;lt; data.count {  let tmp = data[i]  j = i - step  while j &amp;gt;= 0 {  if data[j] &amp;gt; tmp {  data[j &#43; step] = data[j]  j -= step  } else {  break  }  }  data[j &#43; step] = tmp  } }  是不稳定的排序算法，例如(2,1,1) 空间复杂度为$O(1)$   选择排序 简单选择排序 简单选择排序，首先从数组所有元素中找到最小的元素，然后将其与第一个元素进行交换，这样第一个元素就变成了最小元素；然后从第二个元素开始找剩下元素中最小的那一个，并将这个最小元素与第二个元素进行交换，如此第二个元素就变成第二小的元素，依次类推：
//选择排序，时间复杂度为O(n^2),空间复杂度为O(1),不稳定的排序算法，例子为(2,2,1) static func selectSort&amp;lt;T: Comparable&amp;gt;(data: [T]) -&amp;gt; [T] {  var result = data  var index: Int  for i in 0 ..&amp;lt; result.count - 1 {  index = i  for j in i &#43; 1 ..&amp;lt; result.count {  if result[j] &amp;lt; result[index] {  index = j  }  }  if index != i {  (result[index], result[i]) = (result[i], result[index])  }  }  return result }  不稳定的排序算法，例如2,2,1 时间复杂度为$O(n^2)$ 空间复杂度为$O(1)$   堆排序 堆排序算法，是先将数组排成大顶堆（也可以是小顶堆）。然后将堆顶元素（当前最大）和数组的最后一个元素进行交换，那么此时堆顶到数组的倒数第二个元素之间的堆可能就不再满足堆的定义，需要调整。调整好之后，堆顶元素即为堆顶到数组的倒数第二个元素之间最大的元素，此时将堆顶元素和倒数第二个元素交换，此时又可能不满足堆的定义了，因此再调整堆，如此继续，直到处理完所有数据。
//堆排序，时间复杂度为O(nlog(n))，空间复杂度为O(1)，不稳定的排序算法，例子为(2,2,1) static func heapSort&amp;lt;T: Comparable&amp;gt;(data: [T]) -&amp;gt; [T] {  var result = data  //首先排序为大顶堆  for i in stride(from: (result.count - 1) / 2, through: 0, by: -1) {  self.adjustHeap(data: &amp;amp;result, start: i, end: result.count - 1)  }  //然后交换，再重新调整为大顶堆  for i in stride(from: result.count - 1, through: 1, by: -1) {  (result[0], result[i]) = (result[i], result[0])  self.adjustHeap(data: &amp;amp;result, start: 0, end: i - 1)  }  return result } //辅助函数，默认除了第一个元素不满足大顶堆，所以要调整第一个元素到合适位置 static private func adjustHeap&amp;lt;T: Comparable&amp;gt;(data: inout [T], start: Int, end: Int)  var parent = start, child = 2 * start &#43; 1  while child &amp;lt;= end {  if child &amp;lt; end, data[child] &amp;lt; data[child &#43; 1] {  child &#43;= 1  }  if data[parent] &amp;lt; data[child] {  (data[parent], data[child]) = (data[child], data[parent])  parent = child  child = 2 * parent &#43; 1  }else{  break  }  } }  是不稳定的排序算法,例如(1,2,2) 时间复杂度为$O(nlog(n))$ 空间复杂度为$O(1)$   交换排序  交换排序，就是根据序列中两个元素关键字的比较结果来对换这两个记录在序列中的位置。
 冒泡排序 冒泡排序假设待排序表长为n，从后往前（或从前往后）两两比较相邻元素的值，若为逆序$A[i-1]&amp;gt;A[i]$，则交换它们，直到序列比较完。称之为一趟冒泡，结果将最小的元素交换到待排序列的第一个位置（关键字最小的元素如气泡一般逐渐往上漂浮，直到水面，这就是冒泡排序的名字的由来）。下一趟冒泡时，前一趟确定的最小元素不再参与比较，待排序减少一个元素，每趟冒泡的结果把序列中的最小元素放到序列的最终位置，&amp;hellip;，这样最多做$n-1$趟冒泡就能把所有元素排好序。
//交换排序，时间复杂度为O(n^2),空间复杂度为O(1),稳定的排序算法 static func bubbleSort&amp;lt;T: Comparable&amp;gt;(data: [T]) -&amp;gt; [T] {  var result = data  var flag = false //用于标识本趟是否有交换  for i in 0 ..&amp;lt; result.count - 1 {  flag = false  for j in 0 ..&amp;lt; result.count - i - 1 {  // 大数沉底  if result[j] &amp;gt; result[j &#43; 1] {  (result[j], result[j &#43; 1]) = (result[j &#43; 1], result[j])  flag = true  }  }  if flag == false {  break  }  }  return result }  是稳定的排序算法 时间复杂度为$O(n^2)$ 空间复杂度为$O(1)$   快速排序 //快速排序，时间复杂度为O(nlog(n))，空间复杂度为log(n),不稳定的排序算法，例子(2,2,1) static func quickSort&amp;lt;T: Comparable&amp;gt;(data: inout [T], start: Int, end: Int) {  guard start &amp;lt; end else {  return  }  let pivot = assistQuickSort(data: &amp;amp;data, start: start, end: end)  if pivot &amp;gt; start {  quickSort(data: &amp;amp;data, start: start, end: pivot - 1)  }  if end &amp;gt; pivot {  quickSort(data: &amp;amp;data, start: pivot &#43; 1, end: end)  } } //在start...end之间随机抽取一个数字，并将其放置其最终的位置 static private func assistQuickSort&amp;lt;T: Comparable&amp;gt;(data: inout [T], start: Int, end: Int) -&amp;gt; Int {  let index = Int.randomIntNumber(lower: start, upper: end &#43; 1)  (data[end], data[index]) = (data[index], data[end])  var small = start - 1  for i in start ..&amp;lt; end {  if data[i] &amp;lt; data[end] {  small &#43;= 1  if small != i {  (data[small], data[i]) = (data[i], data[small])  }  }  }  small &#43;= 1  (data[small], data[end]) = (data[end], data[small])  return small } extension Int {  //返回的结果： [lower,upper) 之间的半开半闭区间的数。  public static func randomIntNumber(lower: Int = 0, upper: Int = Int(UInt32.max)) -&amp;gt; Int {  return lower &#43; Int(arc4random_uniform(UInt32(upper - lower)))  }   //生成某个区间的随机数  public static func randomIntNumber(range: Range&amp;lt;Int&amp;gt;) -&amp;gt; Int {  return randomIntNumber(lower: range.lowerBound, upper: range.upperBound)  } }   是不稳定的排序算法，例如(3,2,2)时，Pivot为0
  时间复杂度为$O(nlog(n))$
  空间复杂度为$O(log(n))$
  平均条件下，最快的排序算法
   归并排序  归并的含义是将两个或者两个以上的有序表组合成一个新的有序表。假定待排序表含有n个记录，则可以视为n个有序子表，每个表的长度为1，然后两两归并，得到$\biggl\lceil\frac{n}{2}\biggr\rceil$个长度为2或1的有序表，再两两归并，&amp;hellip;，如此重复，直到合并成一个长度为n的有序表为止，这种排序方法称为二路归并排序。
 //归并排序，时间复杂度为O(nlog(n)),空间复杂度为(O(n),稳定的排序算法 static func mergeSort&amp;lt;T: Comparable&amp;gt;(data: [T]) -&amp;gt; [T] {  var result = data  var assist = data  self.mergeSort(data: &amp;amp;result, assist: &amp;amp;assist, start: 0, end: result.count - 1)  return result } static private func mergeSort&amp;lt;T: Comparable&amp;gt;(data: inout [T], assist: inout [T], start: Int, en  if start &amp;lt; end {  let mid = start &#43; (end - start) / 2  mergeSort(data: &amp;amp;data, assist: &amp;amp;assist, start: start, end: mid)  mergeSort(data: &amp;amp;data, assist: &amp;amp;assist, start: mid &#43; 1, end: end)  var index = start, i = start, j = mid &#43; 1  while i &amp;lt;= mid &amp;amp;&amp;amp; j &amp;lt;= end {  if data[i] &amp;lt; data[j] {  assist[index] = data[i]  i &#43;= 1  } else {  assist[index] = data[j]  j &#43;= 1  }  index &#43;= 1  }  while i &amp;lt;= mid {  assist[index] = data[i]  index &#43;= 1  i &#43;= 1  }  while j &amp;lt;= mid {  assist[index] = data[j]  index &#43;= 1  j &#43;= 1  }  data = assist  } } func mergeSort(data:inout Array&amp;lt;Int&amp;gt;){  var assist = data  mergeSort(data: &amp;amp;data, assist: &amp;amp;assist,start: 0,end: data.count-1) }  func mergeSort(data:inout Array&amp;lt;Int&amp;gt;,assist:inout Array&amp;lt;Int&amp;gt;,start:Int,end:Int){  if start == end{  assist[start] = data[start]  return  }  let length = (end - start)/2  mergeSort(data: &amp;amp;data, assist: &amp;amp;assist, start: start, end: start &#43; length)  mergeSort(data: &amp;amp;data, assist: &amp;amp;assist, start: start &#43; length &#43; 1, end: end)   var i=start, j = start &#43; length &#43; 1,k = start  while i &amp;lt;= start &#43; length &amp;amp;&amp;amp; j &amp;lt;= end{  if data[i] &amp;lt;= data[j]{  assist[k] = data[i]  i &#43;= 1  }else{  assist[k] = data[j]  j &#43;= 1  }  k &#43;= 1  }   if i &amp;lt;= start &#43; length {  assist[k...(k &#43; (start &#43; length - i))] = data[i...start&#43;length]  }  if j &amp;lt;= end {  assist[k...(k &#43; (end - j))] = data[j...end]  }  data = assist }  计数排序 计数排序是一种非比较性质的排序算法，元素从未排序状态变为已排序状态的过程，是由额外空间的辅助和元素本身的值决定的。计数排序过程中不存在元素之间的比较和交换操作，根据元素本身的值，将每个元素出现的次数记录到辅助空间后，通过对辅助空间内数据的计算，即可确定每一个元素最终的位置。
//计数排序，时间复杂度为O(n&#43;K),空间复杂度为O(n&#43;K),稳定的排序算法 static func countSort(data: [Int]) -&amp;gt; [Int]? {  guard let arr = preCountSort(data: data), let max = arr.max() else  return nil  }  var countArr = [Int](repeating: 0, count: max &#43; 1)  for item in arr {  countArr[item] &#43;= 1  }  for i in 1 ..&amp;lt; countArr.count {  countArr[i] &#43;= countArr[i - 1]  }  var result = [Int](repeating: 0, count: arr.count)  for i in stride(from: arr.count - 1, through: 0, by: -1) {  result[countArr[arr[i]] - 1] = arr[i]  countArr[arr[i]] -= 1  }  let realResult = postCountSort(data: data, result: result)  return realResult } static private func preCountSort(data: [Int]) -&amp;gt; [Int]? {  guard let min = data.min() else {  return nil  }  if min &amp;lt; 0 {  let adder = abs(min)  let result = data.map {  $0 &#43; adder  }  return result  } else {  return data  } } static private func postCountSort(data: [Int], result: [Int]) -&amp;gt; [Int]?  guard data.count == result.count, let min = data.min() else {  return nil  }  var realResult = result  if min &amp;lt; 0 {  realResult = result.map {  $0 &#43; min  }  }  return realResult } 参考资料
 基数排序 基数排序(Radix Sort)是桶排序的扩展，它的基本思想是：将整数按位数切割成不同的数字，然后按每个位数分别比较。具体做法是：将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后,待排序序列就变成一个有序序列。
//十进制的基数排序 static func radixSort(data: [Int]) -&amp;gt; [Int]? {  guard var arr = preRadixSort(data: data), let max = arr.max() else {  return nil  }  var assist = 1  while assist &amp;lt;= max {  inRadixSort(data: &amp;amp;arr, assist: assist, radix: 10)  assist *= 10  }  return arr } static private func preRadixSort(data: [Int]) -&amp;gt; [Int]? {  for item in data {  if item &amp;lt; 0 {  return nil  }  }  return data } static private func inRadixSort(data: inout [Int], assist: Int, radix: Int) {  var countArr = [Int](repeating: 0, count: 10)  for item in data {  countArr[(item / assist) % radix] &#43;= 1  }  var tmpArr = data  for i in 1 ..&amp;lt; countArr.count {  countArr[i] &#43;= countArr[i - 1]  }  for i in stride(from: data.count - 1, through: 0, by: -1) {  tmpArr[countArr[(data[i] / assist) % radix] - 1] = data[i]  countArr[(data[i] / assist) % radix] -= 1  }  data = tmpArr } 总结  </content>
    </entry>
    
     <entry>
        <title>Framework</title>
        <url>https://iihui.github.io/post/ios-framework/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> 链接库 库是一种共享程序代码的方式，分为静态库和动态库。静态库链接时被完整地拷贝到可执行文件，多次使用时就会有多个副本。
而动态库在链接时不复制，程序运行时由系统动态加载到内存，供程序调用。动态库只加载一次到内存，然后供多个程序共用，以节省内存。
静态库的形式 在iOS中静态库分为.a和.framework。.a是一个纯二进制文件，.framework中除了二进制文件之外，还有资源文件。.a文件不能直接使用，至少要有.h文件配合，而.framework文件可以直接使用。
$$ .a &#43; .h &#43; sourceFile = .framework$$
 动态库的形式 在iOS中动态库分为.dylib和.framework两种形式。.framework既可以是动态库又可以是静态库，需要在构建的时候进行设置：
 构建Framework 一般构建 新建项目时选择Cocoa Touch Framwork： 然后输入Product Name： 为了让制作出的framework在低版本的系统上也能使用，可以在General-&amp;gt;Deployment Info里设置一个较低的发布版本: 将需要添加的文件加入到项目中，进行编译，如下图所示选择不同的active scheme则会生成对应于不同平台的framework：  引入OC代码 如果要在framework中引入OC代码，则首先将.m和.h文件拖入到项目中。然后在设置时选中相应的tagert，找到Build Phases,再在其下的Header中找到相应的头文件，将该头文件从project拖到public下:
再在创建工程时，自动生成的.h文件中引入刚刚拖到工程中的.h文件：  使用Framework 首先将自己构建的Framework拖到目标工程中，如下图所示： 添加的时候选中Copy items if needed和Create groups，然后需要加到哪个target就在对应的target前进行勾选: 添加完成后如下图所示： 然后到相应的target的设置中，找到General下的Embedded Binaries：
接着点击&#43;号添加相应的Framework： 最后的效果如下图所示:  参考资料 参考 参考
</content>
    </entry>
    
     <entry>
        <title>桥接文件</title>
        <url>https://iihui.github.io/post/ios-bridge/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> 因为历史原因，在使用Swift编程时，常常需要用到OC类中的方法，此时就需要使用桥接文件来引入OC中的头文件，以告诉Swift。
手动创建桥接文件 第一步 首先使用快捷键Command&#43;N来新建一个文件： 第二步 选择Header File: 第三步 给Header File命名： 第四步 点击工程配置，添加关联： 第五步 设置桥接文件的路径： 第六步 将要引入的OC头文件，加入到桥接文件中，例如：
//透云QR解码 #import &amp;#34;TYQRViewController.h&amp;#34;  //显示GIF的Label #import &amp;#34;UIImage&#43;GIF.h&amp;#34; #import &amp;#34;CFTextModel.h&amp;#34; #import &amp;#34;CFLabel.h&amp;#34; #import &amp;#34;CFTableViewCell.h&amp;#34; #import &amp;#34;CFTextView.h&amp;#34;  // 百度语音 #import &amp;#34;BDSEventManager.h&amp;#34; #import &amp;#34;BDSASRDefines.h&amp;#34; #import &amp;#34;BDSASRParameters.h&amp;#34; 参考 参考资料
 </content>
    </entry>
    
     <entry>
        <title>JS的prototype</title>
        <url>https://iihui.github.io/post/js-prototype/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>js</tag>
        </tags>
        <content type="html">  在JS中，每当定义一个对象(函数也是对象)时，对象中都会包含一些预定义的属性；每个对象都有一个prototype对象，这个属性指向函数的原型对象。
 原型对象 缘由 Brendan Eich在设计JS时，将所有的数据类型都设计为对象，因此需要有一种机制将这些对象都联系起来。但他只想设计一种简易的脚本语言，所以没有引入类的概念，因为一旦有了类的概念，JS就是一种完整的面向对象的编程语言。
借鉴了Java和C&#43;&#43;使用new来生成实例，Brendan Eich利用new后面跟构造函数「因为没有类的概念」生成对象。
function DOG(name) {  this.name = name;  this.species = &amp;#39;犬科&amp;#39;; } var dogA = new DOG(&amp;#34;大毛&amp;#34;); var dogB = new DOG(&amp;#34;二毛&amp;#34;); 上面这两个对象的species属性都是独立的，修改其中一个，不会影响到另外一个，即每一个实例对象都有自己属性和方法的副本，通过这种方式无法达到数据共享。
 引入 考虑到数据共享的需要，Brendan Eich打算为构造函数设置一个prototype属性，这个属性包含一个对象，所有实例对象需要共享的属性和方法，都放在这个对象里面；那些不需要共享的属性和方法，就放在构造函数中。
实例对象一旦创建，将自动引用prototype对象的属性和方法。即实例对象的属性和方法，分为两种，一种是本地的，另一种是引用的。
function DOG(name) {  this.name = name; } DOG.prototype = { species: &amp;#34;犬科&amp;#34; };  var dogA = new DOG(&amp;#34;大毛&amp;#34;); var dogB = new DOG(&amp;#34;二毛&amp;#34;);  alert(dogA.species); // 犬科 alert(dogB.species); // 犬科  总结 由于所有的实例对象共享一个prototype对象，因此在外界看起来，prototype就好像是实例对象的原型，而实例对象则好像继承了prototype对象一样。
 参考资料 参考资料
 </content>
    </entry>
    
     <entry>
        <title>iOS 版本检查</title>
        <url>https://iihui.github.io/post/ios-new-version/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> 首先由AboutViewController中的presenter调用其requestLastestVersion方法，而presenter是 AboutPresenter类的实例：
lazy var presenter:AboutPresenter = AboutPresenter(delegate:self)  presenter.requestLatestVersion() AboutPresenter类 而AboutPresenter类的实现如下所示:
import Foundation  protocol AboutPresenterDelegate:class {  func updateUIForLatestVersion(shouldUpdate:Bool,updateMessage:String,updateUrl:String,minOSVersion: String?) }  class AboutPresenter:NSObject,WelcomeHttpProtocol {   lazy var webConfigs:[WebConfig?] = [self.webConfigService.versionDescriptionWebConfig,self.webConfigService.teamWebConfig,self.webConfigService.statisticWebConfig]   let publishVersion:String = UpdateService().publishVersion  let appDelegate = UIApplication.shared.delegate as! AppDelegate  let deviceID:String = EnvironmentService.shared.deviceID   fileprivate lazy var welcomHttpController: WelcomeHttpController = WelcomeHttpController(delegate: self)  fileprivate lazy var webConfigService = WebConfigService()  fileprivate weak var delegate:AboutPresenterDelegate?   init(delegate:AboutPresenterDelegate?) {  self.delegate = delegate  }   func requestLatestVersion() {  welcomHttpController.requestLatestVersion(false)  }   func didReceiveLatestVersion(_ jsonData: JSON) {  let retCode = jsonData[&amp;#34;data&amp;#34;][&amp;#34;retCode&amp;#34;].stringValue  let message = jsonData[&amp;#34;data&amp;#34;][&amp;#34;changeLog&amp;#34;].stringValue  let updateUrl = jsonData[&amp;#34;data&amp;#34;][&amp;#34;appUrl&amp;#34;].stringValue  let isLatest = (retCode == &amp;#34;0&amp;#34; || retCode == &amp;#34;&amp;#34;)  let minOSVersion = jsonData[&amp;#34;data&amp;#34;][&amp;#34;minOSVersion&amp;#34;].string   appDelegate.isLatest = isLatest  delegate?.updateUIForLatestVersion(shouldUpdate: !isLatest, updateMessage: message, updateUrl: updateUrl, minOSVersion: minOSVersion)   }   func didError() {  BaseHttpController.commonNetworkError()  }  }  WelcmeHttpController类 在presenter中的requestLastestVersion方法中调用了welcomHttpController.requestLatestVersion(false)，而WelcmeHttpController的实现为：
import UIKit  protocol WelcomeHttpProtocol: BaseHttpProtocol {  func didReceiveLatestVersion(_ jsonData: JSON) }  class WelcomeHttpController: BaseHttpController {   fileprivate weak var delegate: WelcomeHttpProtocol?  fileprivate lazy var environmentService = EnvironmentService.shared  fileprivate lazy var updateService = UpdateService()  fileprivate lazy var userInfoService = UserInfoService()   init(delegate: WelcomeHttpProtocol) {  super.init()  self.delegate = delegate  }   func requestLatestVersion(_ async: Bool) {  let dataDic = NSMutableDictionary()  dataDic[&amp;#34;rand&amp;#34;] = UUID().uuidString  dataDic[&amp;#34;buildVersion&amp;#34;] = updateService.buildVersion  dataDic[&amp;#34;pubVersion&amp;#34;] = updateService.publishVersion  if let activeUser = userInfoService.activeUserEntity {  dataDic[&amp;#34;pathID&amp;#34;] = activeUser.pathID  }   let metaDic = getDefaultMetaData(ConfigRequestAction.getLatestVersion)  if async {  startAsynchronousRequest(metaDic: metaDic, dataDic: dataDic, handler: {(response, data, error) -&amp;gt; Void in  if error == nil {  let jsonData = JSON(data: data!)  self.delegate?.didReceiveLatestVersion(jsonData)  } else {  self.didError()  }  })  } else {  if let result = startSynchronousRequest(metaDic: metaDic, dataDic: dataDic, timeoutInterval: 3) {  if result.error == nil {  let jsonData = JSON(data: result.data!)  self.delegate?.didReceiveLatestVersion(jsonData)  } else {  self.didError()  }  } else {  self.didError()  }  }  }   override func didError() {  self.delegate?.didError()  } } updateUIForLatestVersion 最后由AboutViewController作为代理实现updateUIForLatestVersion方法，用于更新该版本的提示
func updateUIForLatestVersion(shouldUpdate:Bool,updateMessage:String,updateUrl:String,minOSVersion: String?) {  if shouldUpdate {  if let minOS = minOSVersion {  let minF = (minOS as NSString).floatValue  let sysF = (UIDevice.current.systemVersion as NSString).floatValue   if minF &amp;gt; sysF {  let alertView = UIAlertView(title: &amp;#34;发现更新&amp;#34;, message: &amp;#34;最新版移事通已不再支持您的手机系统版本，请升级手机系统到\(minOS)或以上后再检查更新&amp;#34;, delegate: self, cancelButtonTitle: nil otherButtonTitles: &amp;#34;确定&amp;#34;.localized)  alertView.tag = 102  alertView.show()  return  }  }   self.newAppUrl = updateUrl  let alertVC = UIAlertView(title: &amp;#34;发现更新&amp;#34;.localized, message: &amp;#34;&amp;#34;, delegate: self, cancelButtonTitle: &amp;#34;取消&amp;#34;.localized, otherButtonTitles: &amp;#34;更新&amp;#34;.localized)  alertVC.tag = 100  alertVC.extShow(.left, messageStr: updateMessage)  } else {  let alertView = FlashAlertView(message: &amp;#34;已经是最新版本&amp;#34;.localized, delegate: nil)  alertView.show()  } }  </content>
    </entry>
    
     <entry>
        <title>javascript 中this指针</title>
        <url>https://iihui.github.io/post/js-this/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>js</tag>
        </tags>
        <content type="html">  在JavaScript中，this是动态绑定，或称为运行期绑定的，这导致JavaScript中的this关键字具有多重含义。它可以是全局对象、当前对象或者任意对象，这完全取决于函数的调用方式。
  作为对象方法调用 在JS中，函数也是对象，因此函数可以作为一个对象的属性，此时该函数被称为该对象的方法，在使用这种调用方式时，this被自然地绑定到该对象。
var point = { x : 0, y : 0, moveTo : function(x, y) {  this.x = this.x &#43; x;  this.y = this.y &#43; y;  } };  point.moveTo(1, 1)//this 绑定到当前对象，即 point 对象  作为函数调用 函数可以直接调用，此时this绑定到全局对象，在浏览器中，window就是该全局对象。在下面的例子中，函数调用时，this被绑定到全局对象，接下来执行赋值语句，相当于隐式的声明了一个全局变量。
function makeNoSense(x) {  this.x = x; }  makeNoSense(5); x;// x 已经成为一个值为 5 的全局变量 对于内部函数(即声明在另一个函数体中的函数)，如果使用this指针，那么绑定的是全局对象，会产生下面问题：
var point = {  x: 0,  y: 0,  moveTo: function(x, y) {  // 内部函数  var moveX = function(x) {  this.x = x; //this 绑定到了哪里？  };  // 内部函数  var moveY = function(y) {  this.y = y; //this 绑定到了哪里？  };   moveX(x);  moveY(y);  } }; point.moveTo(1, 1); point.x; //==&amp;gt;0 point.y; //==&amp;gt;0 x; //==&amp;gt;1 y; //==&amp;gt;1 这属于JavaScript的设计缺陷，正确的设计方式是内部函数的this应该绑定到其外层函数对应的对象上，为了规避这一缺陷，使用变量替换的方式：
var point = {  x: 0,  y: 0,  moveTo: function(x, y) {  var that = this;  // 内部函数  var moveX = function(x) {  that.x = x;  };  // 内部函数  var moveY = function(y) {  that.y = y;  };  moveX(x);  moveY(y);  } }; point.moveTo(1, 1); point.x; //==&amp;gt;1 point.y; //==&amp;gt;1  作为构造函数调用 JavaScript支持面向对象编程，但它没有类的概念，而是使用基于原型prototype的继承方式。
相应的JavaScript中的构造函数也很特殊，如果不使用new调用，则和普通函数一样。约定俗成，构造函数以大写字母开头，以提醒调用者使用正确的方式调用。
function Point(x, y){  this.x = x;  this.y = y; }  使用apply或call调用 在JS中函数也是对象，对象则有方法，apply和call就是函数对象的方法。他们允许切换函数执行的上下文环境context,即this绑定的对象。
function Point(x, y) {  this.x = x;  this.y = y;  this.moveTo = function(x, y) {  this.x = x;  this.y = y;  }; }  var p1 = new Point(0, 0); var p2 = { x: 0, y: 0 }; p1.moveTo(1, 1); p1.moveTo.apply(p2, [10, 10]); //p1的方法应用到p2 函数存在①定义时上下文；②运行时上下文；③上下文是可以改变的。在JS中call和apply都是为了改变某个函数执行的上下文context而存在的，即是改变函数体内的this的指向。
var func = function(arg1, arg2) {  //语句 }; func.call(this, arg1, arg2); func.apply(this, [arg1, arg2])  参考资料 参考资料 一定要看
 </content>
    </entry>
    
     <entry>
        <title>selection 对象</title>
        <url>https://iihui.github.io/post/js-selection/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  在富文本编辑器中，需要控制光标的各种状态信息，位置信息。浏览器提供了selection对象和range对象来操作光标。
 selection Selection对象表示用户选择的文本范围或插入符号的当前位置。它代表页面中的文本选区，可能横跨多个元素(element)，文本选区由用户拖拽鼠标而产生。
let selection = window.getSelection(); 通常需要操作selection对象所对应的用户选择区(range)(俗称拖蓝)，获取方式为:
if (selection.rangeCount &amp;gt; 0) {  let range = selection.getRangeAt(0); } //或者 if (selection.rangeCount) {  let range = selection.getRangeAt(0); }  range对象 range对象代表页面上一段连续的区域，通过range对象可以获取或者修改页面上的任何区域，也可以通过Range的方法进行复制和移动页面上的任何区域。
  startContainer: range范围的起始节点。
  endContainer:range 范围的结束节点。
  startOffset: 如果startContainer是文本节点、注释节点、或者CDATA节点，则返回起点在startContainer中的字符偏移量，如果startContainer是元素节点，则返回起点在startContainer.childNodes中的次序。
  endOffset: 表示终点，含义与startOffset类似。
  commonAncestorContainer: 返回包含startContainer和endContainer的最近祖先节点。
  collapsed:返回一个用于判断range起始位置和终止位置是否相同的布尔值。
   range常用方法   setStart(node,offset):设置起点的位置，node是对startContainer的引用，偏移则是startOffset。
  setEnd(node,offset): 设置的终点的位置，node是对endContainer的引用，偏移则是endOffset。
  selectNode(referenceNode)：设置Range的范围，包括referenceNode和它的所有子孙节点。
  selectNodeContents(referenceNode)设置Range的范围，包括它的所有后代节点，但不包含referenceNode节点。与selectNode区别较大。
  collapse(bool): 向起点start折叠。
  insertNode(node): 在range的起始处插入节点。
  cloneRange(): 返回一个当前Range的副本
  function resetRange(startContainer, startOffset, endContainer, endOffset) {  let selection = window.getSelection();  selection.removeAllRanges();  let range = document.createRange();  range.setStart(startContainer, startOffset);  range.setEnd(endContainer, endOffset);  selection.addRange(range); } 参考资料
 </content>
    </entry>
    
     <entry>
        <title>KVO 介绍</title>
        <url>https://iihui.github.io/post/ios-kvo/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag><tag>oc</tag><tag>swift</tag>
        </tags>
        <content type="html">  在应用开发中，经常需要使用观察者模式，以监听某些对象属性的变化，然后进行相应操作。OC提供了一套简洁优雅的观察方式——KVO。KVO(key-value observing)是一种通知机制，当指定的被观察者对象的属性被修改时，KVO会自动通知相应的观察者。KVO由NSKeyValueObserving协议提供支持，NSObject类继承了该协议，所以任何NSObject的子类都可使用该方法。
 KVO的使用 KVO的使用比较简单，只需要给对象的指定属性添加监听，并设置监听类型。每当对指定的属性进行读写操作时，OC就会调用observeValueForKeyPath方法，在observeValueForKeyPath中进行判断，确定是哪个对象的事件。
下面的例子是便实现一个属性值的监听。可总结为三步：第一步是添加监听；第二步是实现协议；第三步是移除监听：
Person *person = [Person alloc] init]; /* 作用:给对象绑定一个监听器(观察者) - Observer 观察者 - KeyPath 要监听的属性 - options 选项(方便在监听的方法中拿到属性值) */ [person addObserver:person forKeyPath:@&amp;#34;name&amp;#34; options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:nil]; // 移除监听 [person removeObserver:person forKeyPath:@&amp;#34;name&amp;#34;]; /** * 当监听的属性值发生改变 * * @param keyPath 要改变的属性 * @param object 要改变的属性所属的对象 * @param change 改变的内容 * @param context 上下文 */ - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&amp;lt;NSString *,id&amp;gt; *)change context:(void *)context{  NSLog(@&amp;#34;%@------%@------%@&amp;#34;, keyPath, object, change); } 添加监听 //第一个参数 observer观察者 （这里观察self.myKVO对象的属性变化） //第二个参数 keyPath被观察的属性名称(这里观察 self.myKVO 中 num 属性值的改变) //第三个参数 options： 观察属性的新值、旧值等的一些配置（枚举值，可以根据需要设置，例如这里可以使用两项） //第四个参数 context： 上下文，可以为 KVO 的回调方法传值（例如设定为一个放置数据的字典） - (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context; 实现协议 在回调方法中处理属性值发生变化。
//keyPath:属性名称 //object:被观察的对象 //change:变化前后的值都存储在change字典中 //context:注册观察者时，context 传过来的值  - (void)observeValueForKeyPath:(nullable NSString *)keyPath ofObject:(nullable id)object change:(nullable NSDictionary *)change context:(nullable void *)context; 移除观察者。 - (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath; 注意事项 使用KVO消息传递机制有两个要求：
  观察者必须知道被观察者对象，即在同一作用域。
  观察者还需要知道被观察对象的生命周期，因为在销毁发送者对象之间，需要取消观察者的注册。
  Swift中属性观察器 在Swift中有两个属性观察者willSet和didSet,类似于触发器。用来监控属性除初始化之外的属性值变化，当属性值发生变化时可以对此作出响应。
 不仅可以在属性值发生变化后触发didSet,也可以在属性值改变前触发willSet。 给属性添加观察者必须要声明清楚属性的类型，否则编译器报错。 willSet可以带一个newName的参数，没有的话，默认命名为newValue。 didSet 可以带一个oldName的参数，表示旧的值，不带的话，默认命名为oldValue。 属性初始化时，willSet和didSet不会调用。只有初始化上下文之外，属性值发生变化时才会调用。 即使设置的值和原来的一样，willSet和didSet也会被调用。  var firstName: String = &amp;#34;First&amp;#34; {  willSet { //新值设置之前被调用，在此可以进行条件筛选，过滤数据  print(&amp;#34;willSet的新值是\(newValue)&amp;#34;)  }  didSet { //新值设置之后立即调用，在此可以进行条件筛选，过滤数据,可以直接绑定数据到UI上面  print(&amp;#34;didSet的旧值是\(oldValue)--- 新值是 \(firstName)&amp;#34;)  self.nameLabel.text = firstName  } }  Swift实现KVO值监听 利用设计模式中的观察者模式，观察者定义了对象之间的一对多依赖。当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。观察者模式适用在一个被观察者（数据源）要通知多个观察者的场景。
参考资料 参考资料
</content>
    </entry>
    
     <entry>
        <title>给图片添加点击监听</title>
        <url>https://iihui.github.io/post/js-img/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>js</tag>
        </tags>
        <content type="html"> 给所有图片添加监听 function setImagesClick(){  $(&amp;#39;body&amp;#39;).on(&amp;#39;click&amp;#39;,&amp;#39;img&amp;#39;,function(){  let position = this.offsetTop; //当前元素距离顶部的距离  //window.scrollTo(0,position)  let result = {};  result.position = position.toString()  let jsonString = JSON.stringify(result);  let escapedJsonString = encodeURI(jsonString); //重新编码  let scheme = &amp;#34;position://&amp;#34;;  document.location.href = scheme &#43; &amp;#34;#&amp;#34; &#43; escapedJsonString; //向ios发送  }); } 参考资料
 </content>
    </entry>
    
     <entry>
        <title>RunLoop</title>
        <url>https://iihui.github.io/post/ios-runloop/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> 概念 一般来讲，一个线程一次只能执行一个任务，执行完成后，线程就会退出。若我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是下面这样的：
function loop() {  initialize();  do {  var message = get_next_message();  process_message(message);  } while (message != quit); } 这种模型被称为Event Loop,实现这种模型的关键点在于：
 如何管理事件/消息 如何让线程在没有处理消息时休眠以避免资源占用，在有消息到来时立刻被唤醒。  因此，RunLoop实质上是一个对象，这个对象管理了其需要处理的事件和消息
 参考资料
</content>
    </entry>
    
     <entry>
        <title>权限检查</title>
        <url>https://iihui.github.io/post/ios-authority/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> 相机权限检查 相机和音频的权限分为4种，分别是.denied,restricted,.authorized,.notDetermined,.authorized四种:
  .denied 未授权，用户曾经选择过拒绝授权。
  .authorized 已经授权。
  .restricted 未授权，例如家长控制。
  .notDetermined 没有询问过用户是否授权，所以是未确定状态。
  //MARK:检查相机访问权限 func cameraPermissionCheck(){  let authStatus = AVCaptureDevice.authorizationStatus(forMediaType: AVMediaTypeVideo)  switch authStatus {  case .denied, .restricted:  let alert = UIAlertController(title: &amp;#34;提示&amp;#34;.localized, message: CameraAccessMsg, preferredStyle: .alert)  let settingAction = UIAlertAction(title: &amp;#34;去设置&amp;#34;.localized, style: .default) { (_) in  let url = NSURL(string: UIApplicationOpenSettingsURLString)!  if UIApplication.shared.canOpenURL(url as URL){  UIApplication.shared.openURL(url as URL)  }  }  let cancelAction = UIAlertAction(title: &amp;#34;取消&amp;#34;.localized, style: .cancel) { (_) in  DPrint(&amp;#34;cancel!&amp;#34;)  }  alert.addAction(settingAction)  alert.addAction(cancelAction)  self.present(alert, animated: true, completion: nil)  default:break  } } func cameraPermissionCheck(){  let msg = &amp;#34;没有相机访问权限，请移步到设置--&amp;gt;隐私--&amp;gt;相机--&amp;gt;APP&amp;#34;  let authStatus = AVCaptureDevice.authorizationStatus(for: .video)  switch authStatus {  case .denied, .restricted,.notDetermined:  let alert = UIAlertController(title: &amp;#34;提示&amp;#34;, message: msg, preferredStyle: .alert)  let settingAction = UIAlertAction(title: &amp;#34;去设置&amp;#34;, style: .default) { (_) in  let url = URL(string: UIApplicationOpenSettingsURLString)  if let cameraURL = url,UIApplication.shared.canOpenURL(cameraURL){  UIApplication.shared.open(cameraURL, options: [:], completionHandler: nil)  }  }  let cancelAction = UIAlertAction(title: &amp;#34;取消&amp;#34;, style: .cancel) { (_) in  print(&amp;#34;点击了取消&amp;#34;)  }  alert.addAction(settingAction)  alert.addAction(cancelAction)  self.present(alert, animated: true, completion: nil)  default:break  } } override func viewDidAppear(_ animated: Bool) {  super.viewDidAppear(animated)  cameraPermissionCheck() }  麦克风权限检查 let status = AVCaptureDevice.authorizationStatus(forMediaType: AVMediaTypeAudio) if status == .denied || status == .restricted {  let message = &amp;#34;麦克风访问权限被禁用，请前往系统设置-&amp;gt;隐私-&amp;gt;麦克风中，启用本程序对麦克风的访问权限&amp;#34;.localized  let tipsAlertController = UIAlertController(title: &amp;#34;提示&amp;#34;.localized, message: message, preferredStyle: .alert)  let confirm = UIAlertAction(title: &amp;#34;去设置&amp;#34;.localized, style: .default){ (_) in  let url = NSURL(string: UIApplicationOpenSettingsURLString)!  if UIApplication.shared.canOpenURL(url as URL) {  UIApplication.shared.openURL(url as URL)  }  }  let cancelAction = UIAlertAction(title: &amp;#34;取消&amp;#34;.localized, style: .cancel) { (_) in  self.dismiss(animated: true, completion: nil)  }   tipsAlertController.addAction(confirm)  tipsAlertController.addAction(cancelAction)  self.present(tipsAlertController, animated: true, completion: nil) } 参考资料
 </content>
    </entry>
    
     <entry>
        <title>CABasicAnimation</title>
        <url>https://iihui.github.io/post/ios-animation/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> 关键帧动画 所谓关键帧动画，就是将Layer的属性作为KeyPath来注册，只要指定动画的起始帧和结束帧，然后自动计算和实现中间的过度的一种动画方式。
func recordingButtonAnimation(){  let animation = CABasicAnimation(keyPath: &amp;#34;opacity&amp;#34;)  animation.fromValue = 1.0  animation.toValue = 0.3  animation.fillMode = kCAFillModeForwards  animation.isRemovedOnCompletion = false  animation.duration = self.animationDuration  self.recordButton.layer.add(animation, forKey: nil) }  //添加定时器 if recordingAnimationTimer == nil{  recordingAnimationTimer = Timer.scheduledTimer(timeInterval: self.animationDuration, target: self, selector: #selector(recordingButtonAnimation), userInfo: nil, repeats: true) }  //销毁定时器 self.recordingAnimationTimer?.invalidate() //移除动画层 self.recordButton.layer.removeAllAnimations() 属性说明：
 duration动画时长，默认为0,不设置的话会快速执行完动画 speed 执行速度，默认为1倍速度，如果设置了该属性，则执行时长为$\frac{duration}{speed}$ repeatCount重复次数，默认为0，如果需要设置为永久的话可以设置为HUGE_VALE autoreverses 动画执行完是否执行逆动画，默认不执行 fromValue 开始值 toValue 结束值  当CABasicAnimation执行完动画后会回归动画开始的状态，如果想要让它变成动画执行最后的状态，设置一下两个属性：
animation.removedOnCompletion = false animation.fillMode = kCAFillModeForwards 如果要设置永久重复，则需要将repeatCount的值置为HUGE或者.greatestFiniteMagnitude。
let animation = CABasicAnimation(keyPath: &amp;#34;opacity&amp;#34;) animation.duration = 1.0 animation.repeatCount = .greatestFiniteMagnitude//HUGE animation.autoreverses = true animation.fromValue = 1.0 animation.toValue = 0.0 testButton.layer.add(animation, forKey: nil) 当给一个CALayer添加动画时，动画其实并没有改变这个Layer的实质属性，取而代之，系统会创建一个原始Layer的拷贝。苹果称这个原始Layer为Model Layer，而这个复制的Layer被称为Presentation Layer。
Presentation Layer的属性会随着动画的进度实时改变，而Model Layer中对应的属性不会发生变化。 默认情况下，系统会在duration时间后自动移除CAKeyframeAnimation。当移除某个动画后，系统会自动销毁这个Layer的Presentation Layer，只留下Model Layer。因为Model Layer的属性没有发生变化，所以视图一瞬间就回到了动画的初始状态。要解决这种状态需要先把removeOnCompletion设置为false,然后设置fillMode为kCAFillModeForwards。
animation.removedOnCompletion = false animation.fillMode = kCAFillModeForwards 关于fillMode它有四个值：
 KCAFillModelRemoved 这个是默认值，表示动画开始前和结束后对Model Layer没有影响，动画结束会回到视图的初始状态。 kCAFillModeForwards 当动画结束后，Model Layer会保持动画的最后状态。 kCAFillModeBackwards 在动画开始前，只要将动画加入到一个Layer,则Layer立即进入动画的初始状态并等待动画开始。 kCAFillModeBoth 动画加入Layer后，Layer便处于初始状态，动画结束后Layer保持最后的状态。   添加引导动画 fileprivate var guideImageView:UIImageView? private let guideKey = &amp;#34;GUIDE_NOTE_SPEECH_KEY&amp;#34; //应用级别的引导，如果增加用户的id，则是用户级别的引导 func showGuide(){  let isShowed = UserDefaults.standard.value(forKey: self.guideKey)  if isShowed == nil {  let guideImage = UIImage(named: &amp;#34;guide_note_speech&amp;#34;)  if self.guideImageView == nil{  self.guideImageView = UIImageView(image: guideImage)  let width:CGFloat = 132  let height:CGFloat = 100  let x = bottomView.bounds.width/2 &#43; 15  let y = topView.bounds.size.height &#43; centerView.bounds.size.height &#43; soundWaveView.bounds.size.height - height &#43; 20   if let guideView = self.guideImageView{  self.guideImageView?.frame = CGRect(x: x, y: y, width: width, height: height)  self.view.addSubview(guideView)   let startPoint = CGPoint(x: 0, y: 1)  setAnchorPoint(point: startPoint, view: guideView)   UIView.animate(withDuration: 1.2, delay: 0, options: [.repeat, .autoreverse], animations: {  guideView.transform = CGAffineTransform(scaleX: 0.8, y: 0.8)  }, completion:nil)  }  }  } } 需要注意的是：因为上面的函数涉及到bounds的计算，因此guideShow函数应当放到viewDidLayoutSubviews()中，或者viewDidAppear(_ animated: Bool)中，经过试验，发现如果放到viewDidLayoutSubviews()中，图片会变黑很多。
override func viewDidLayoutSubviews() {  super.viewDidLayoutSubviews()  showGuide() } override func viewDidAppear(_ animated: Bool) {  super.viewDidAppear(animated)  showGuide() } 取消引导动画时，首先应当移除引导的imageview，并将key记录到plist文件中。如果设置时用户点击某个按钮时移除引导，则将如下代码添加到相应UIButton的响应函数中：
if let guideView = self.guideImageView{  self.removeGuide(view: guideView) } func removeGuide(view:UIView) {  view.removeFromSuperview()  UserDefaults.standard.setValue(true, forKey: self.guideKey) } 如果是用户点击imageView的任何地方，移除引导，则应先在imageView里添加手势，如下所示：
func tapGuide(gesture: UITapGestureRecognizer) {  gesture.view?.removeFromSuperview()  UserDefaults.standard.setValue(true, forKey: self.guideKey) } guideImageView.isUserInteractionEnabled = true let tapGesture = UITapGestureRecognizer(target: self, action: #selector(tapGuide(gesture:))) guideImageView.addGestureRecognizer(tapGesture) 适配iPad添加横竖屏的支持
private let guideKey = &amp;#34;GUIDE_NOTE_SPEECH_KEY12&amp;#34; func showGuide(){  let isShowed = UserDefaults.standard.value(forKey: self.guideKey)  if isShowed == nil {  self.guideImageView?.removeFromSuperview()  let guideImage = UIImage(named: &amp;#34;guide_note_speech&amp;#34;)  self.guideImageView = UIImageView(image: guideImage)   let width:CGFloat = 132  let height:CGFloat = 100  let bounds = UIScreen.main.bounds  let x = bounds.size.width/2 &#43; 20   var y = bounds.size.height - self.bottomView.bounds.size.height - height  if let navHeight = self.navigationController?.navigationBar.bounds.size.height{  y -= navHeight  }   if let guideView = self.guideImageView{  self.guideImageView?.frame = CGRect(x: x, y: y, width: width, height: height)  guideView.alpha = 0.8  self.view.addSubview(guideView)  let startPoint = CGPoint(x: 0, y: 1)  setAnchorPoint(point: startPoint, view: guideView)   UIView.animate(withDuration: 1.6, delay: 0, options: [.repeat, .autoreverse], animations: {  guideView.transform = CGAffineTransform(scaleX: 0.8, y: 0.8)  }, completion:nil)  }  } } 参考资料 参考资料 参考资料 参考资料
 两个效果 let transformA = CGAffineTransform(scaleX: 0.5, y: 0.5) let transformB = CGAffineTransform(translationX:100, y：100) guideImageView.transform = transformA.concatenating(transformB) 参考资料
CABasicAnimation  使用CABasicAnimation做旋转动画时，发现切到后台之后，再切回到前台时，动画停止了。查阅相关资料，发现切到后台之后，CABasicAnimation被移除了，为此，需要将isRemovedOnCompletion属性置为false。
 private func addAnimation() {  let rotationAnimation = CABasicAnimation(keyPath: &amp;#34;transform.rotation&amp;#34;)  rotationAnimation.fromValue = 0.0  rotationAnimation.toValue = 2 * Double.pi  rotationAnimation.dutation = 1.0  rotationAnimation.repeatCount = .infinity  rotationAnimation.isRemovedOnCompletion = false  self.imageView.layer.add(rotationAnimation, forKey: nil) }  </content>
    </entry>
    
     <entry>
        <title>透明度渐变动画</title>
        <url>https://iihui.github.io/post/ios-opicity-animation/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> CABasicAnimation关键帧动画 所谓关键帧动画，就是将Layer的属性作为KeyPath来注册，只要指定动画的起始帧和结束帧，然后自动计算和实现中间的过度的一种动画方式。
func recordingButtonAnimation(){  let animation = CABasicAnimation(keyPath: &amp;#34;opacity&amp;#34;)  animation.fromValue = 1.0  animation.toValue = 0.3  animation.fillMode = kCAFillModeForwards  animation.isRemovedOnCompletion = false  animation.duration = self.animationDuration  self.recordButton.layer.add(animation, forKey: nil) }  //添加定时器 if recordingAnimationTimer == nil{  recordingAnimationTimer = Timer.scheduledTimer(timeInterval: self.animationDuration, target: self, selector: #selector(recordingButtonAnimation), userInfo: nil, repeats: true) }  //销毁定时器 self.recordingAnimationTimer?.invalidate() //移除动画层 self.recordButton.layer.removeAllAnimations() 属性说明：
 duration动画时长，默认为0,不设置的话会快速执行完动画 speed 执行速度，默认为1倍速度，如果设置了该属性，则执行时长为$\frac{duration}{speed}$ repeatCount重复次数，默认为0，如果需要设置为永久的话可以设置为HUGE_VALE autoreverses 动画执行完是否执行逆动画，默认不执行 fromValue 开始值 toValue 结束值  CABasicAnimation执行完动画后会回归动画开始的状态，如果想要让它变成动画执行最后的状态，设置一下两个属性：
animation.removedOnCompletion = false animation.fillMode = kCAFillModeForwards 如果要设置永久重复，则需要将repeatCount的值置为HUGE或者.greatestFiniteMagnitude。
let animation = CABasicAnimation(keyPath: &amp;#34;opacity&amp;#34;) animation.duration = 1.0 animation.repeatCount = .greatestFiniteMagnitude//HUGE animation.autoreverses = true animation.fromValue = 1.0 animation.toValue = 0.0 testButton.layer.add(animation, forKey: nil)  添加引导动画 fileprivate var guideImageView:UIImageView? private let guideKey = &amp;#34;GUIDE_NOTE_SPEECH_KEY&amp;#34; //应用级别的引导，如果增加用户的id，则是用户级别的引导 func showGuide(){  let isShowed = UserDefaults.standard.value(forKey: self.guideKey)  if isShowed == nil {  let guideImage = UIImage(named: &amp;#34;guide_note_speech&amp;#34;)  if self.guideImageView == nil{  self.guideImageView = UIImageView(image: guideImage)  let width:CGFloat = 132  let height:CGFloat = 100  let x = bottomView.bounds.width/2 &#43; 15  let y = topView.bounds.size.height &#43; centerView.bounds.size.height &#43; soundWaveView.bounds.size.height - height &#43; 20   if let guideView = self.guideImageView{  self.guideImageView?.frame = CGRect(x: x, y: y, width: width, height: height)  self.view.addSubview(guideView)   let startPoint = CGPoint(x: 0, y: 1)  setAnchorPoint(point: startPoint, view: guideView)   UIView.animate(withDuration: 1.2, delay: 0, options: [.repeat, .autoreverse], animations: {  guideView.transform = CGAffineTransform(scaleX: 0.8, y: 0.8)  }, completion:nil)  }  }  } } 需要注意的是：因为上面的函数涉及到bounds的计算，因此guideShow函数应当放到viewDidLayoutSubviews()中，或者viewDidAppear(_ animated: Bool)中，经过试验，发现如果放到viewDidLayoutSubviews()中，图片会变黑很多。
override func viewDidLayoutSubviews() {  super.viewDidLayoutSubviews()  showGuide() } override func viewDidAppear(_ animated: Bool) {  super.viewDidAppear(animated)  showGuide() } 取消引导动画时，首先应当移除引导的imageview，并将key记录到plist文件中。如果设置时用户点击某个按钮时移除引导，则将如下代码添加到相应UIButton的响应函数中：
if let guideView = self.guideImageView{  self.removeGuide(view: guideView) } func removeGuide(view:UIView) {  view.removeFromSuperview()  UserDefaults.standard.setValue(true, forKey: self.guideKey) } 如果是用户点击imageView的任何地方，移除引导，则应先在imageView里添加手势，如下所示：
func tapGuide(gesture: UITapGestureRecognizer) {  gesture.view?.removeFromSuperview()  UserDefaults.standard.setValue(true, forKey: self.guideKey) } guideImageView.isUserInteractionEnabled = true let tapGesture = UITapGestureRecognizer(target: self, action: #selector(tapGuide(gesture:))) guideImageView.addGestureRecognizer(tapGesture) 适配iPad添加横竖屏的支持
private let guideKey = &amp;#34;GUIDE_NOTE_SPEECH_KEY12&amp;#34; func showGuide(){  let isShowed = UserDefaults.standard.value(forKey: self.guideKey)  if isShowed == nil {  self.guideImageView?.removeFromSuperview()  let guideImage = UIImage(named: &amp;#34;guide_note_speech&amp;#34;)  self.guideImageView = UIImageView(image: guideImage)   let width:CGFloat = 132  let height:CGFloat = 100  let bounds = UIScreen.main.bounds  let x = bounds.size.width/2 &#43; 20   var y = bounds.size.height - self.bottomView.bounds.size.height - height  if let navHeight = self.navigationController?.navigationBar.bounds.size.height{  y -= navHeight  }   if let guideView = self.guideImageView{  self.guideImageView?.frame = CGRect(x: x, y: y, width: width, height: height)  guideView.alpha = 0.8  self.view.addSubview(guideView)  let startPoint = CGPoint(x: 0, y: 1)  setAnchorPoint(point: startPoint, view: guideView)   UIView.animate(withDuration: 1.6, delay: 0, options: [.repeat, .autoreverse], animations: {  guideView.transform = CGAffineTransform(scaleX: 0.8, y: 0.8)  }, completion:nil)  }  } } 参考资料 参考资料 参考资料 参考资料
 同时添加两个效果 let transformA = CGAffineTransform(scaleX: 0.5, y: 0.5) let transformB = CGAffineTransform(translationX:100, y：100) guideImageView.transform = transformA.concatenating(transformB) 参考资料
 </content>
    </entry>
    
     <entry>
        <title>iOS视频开发入门</title>
        <url>https://iihui.github.io/post/ios-video/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html"> 视频实质 纯粹的视频（不包括音频）实质上就是一组帧图片，经过视频编码成为视频(video)文件再把音频（audio）文件以及字幕文件组装在一起成为视频（movie）文件。
1秒内出现的图片数就是帧率，图片间隔越小画面就越流畅，所以帧率越高效果就越好，需要的存储空间也就越多。
录制视频的3种实现方式   UIImagePickerViewController：只能设置一些简单的参数来实现基本的视频录制的效果，自定义程度不高。
  AVFoundation：苹果提供的底层多媒体框架，用于音视频采集、解码、视频编辑等，使用AVFoundation进行视频录制有以下两种方式：
  AVCaptureSession &#43; AVCaptureMoiveFileOutput。
  AVCaptureSession &#43; AVAssetWriter。
    UIImagePickerController 这种方式只能设置一些简单的参数，自定义程度不高，只能自定义界面上的操作按钮以及视频的画质：
- (void)viewDidLoad {  [super viewDidLoad];   if ([self isVideoRecordingAvailable]) {  return;  }  self.sourceType = UIImagePickerControllerSourceTypeCamera;  self.mediaTypes = @[(NSString *)kUTTypeMovie];  self.delegate = self;   //隐藏系统自带UI  self.showsCameraControls = NO;  //设置摄像头  [self switchCameraIsFront:NO];  //设置视频画质类别  self.videoQuality = UIImagePickerControllerQualityTypeMedium;  //设置散光灯类型  self.cameraFlashMode = UIImagePickerControllerCameraFlashModeAuto;  //设置录制的最大时长  self.videoMaximumDuration = 20; } - (BOOL)isVideoRecordingAvailable {  if([UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypeCamera]){  NSArray *availableMediaTypes = [UIImagePickerController availableMediaTypesForSourceType:UIImagePickerControllerSourceTypeCamera];  if([availableMediaTypes containsObject:(NSString *)kUTTypeMovie]){  return YES;  }  }  return NO; } - (void)switchCameraIsFront:(BOOL)front {  if (front) {  if([UIImagePickerController isCameraDeviceAvailable:UIImagePickerControllerCameraDeviceFront]){  [self setCameraDevice:UIImagePickerControllerCameraDeviceFront];   }  } else {  if([UIImagePickerController isCameraDeviceAvailable:UIImagePickerControllerCameraDeviceRear]){  [self setCameraDevice:UIImagePickerControllerCameraDeviceRear];   }  } }  AVCaptureSession&#43;AVCaptureMovieFileOutput 采用AVCaptureSession&#43;AVCaptureMovieFileOutput进行视频录制一般要经过以下6步：
 创建捕捉会话AVCaptureSession,用于控制input到output的流向。 设置视频的输入设备 AVCaptureDeviceInput，用于视频采集，然后将设备绑定到AVCaptureSession的输入口input中。 设置音频输入设备 AVCaptureDeviceInput，用于音频采集，然后将设备绑定到AVCaptureSession的输入口input中。 设置输出源AVCaptureMovieFileOutput。此时音频和视频会合并在一起，在代理方法中也可以单独拿到视频或者音频数据，给AVCaptureMovieFileOutput指定路径，开始录制之后就会向这个路径写入数据。 添加视频预览层。 开始采集数据，这个时候还没有写入数据，用户点击录制后就可以开始写入数据。  如果需要对视频进行实时处理，则需要对相机缓冲区中的视频流进行处理：
 定义一个视频数据输出AVCaptureVideoDataOutput,并将其添加到Session上。 设置接受的Controller作为视频数据输出缓冲区Sample Buffer的代理。 实现代理方法。   参考资料 参考资料
 AVCaptureSession&#43;AVAssetWriter 基本流程为
 创建捕捉会话 设置视频的输入和输出 设置音频的输入和输出 添加视频预览层 开始采集数据，这个时候还没有写入数据，用户点击录制的时候才开始写入数据 初始化AVAssetWriter，我们会拿到视频和音频数据流，用AVAssetWriter写入文件，这一步需要自己实现。   录制视频开启蓝牙录音 思路是先判断是否有蓝牙或者耳机插入，如果有则将其设置为音频输入源，否则使用默认的麦克风，应当注意的是要在设置了音频输入源之后，再设置self.captureSession.usesApplicationAudioSession = true和self.captureSession.automaticallyConfiguresApplicationAudioSession = false。
fileprivate var isBlueToothAvailable = false fileprivate var audioSession = AVAudioSession.sharedInstance() func isBlueToothConnected()-&amp;gt;Bool{  let route = AVAudioSession.sharedInstance().currentRoute  for item in route.outputs{  if item.portType == AVAudioSessionPortHeadphones || item.portType == AVAudioSessionPortBluetoothA2DP{  self.isBlueToothAvailable = true  return true  }  }  return false }  if isBlueToothConnected(){  do{  try audioSession.setCategory(AVAudioSessionCategoryPlayAndRecord, with: AVAudioSessionCategoryOptions.allowBluetooth)  }catch{} }  if self.isBlueToothAvailable {  self.captureSession.usesApplicationAudioSession = true  self.captureSession.automaticallyConfiguresApplicationAudioSession = false } 参考资料
</content>
    </entry>
    
     <entry>
        <title>HTML入门</title>
        <url>https://iihui.github.io/post/htm-primer/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>html</tag>
        </tags>
        <content type="html"> 简介 HTML指的是超文本标记语言 (Hyper Text Markup Language)，它不是一种编程语言，而是一种标志语言，标记语言是一套标记标签，使用标记标签来描述网页。
 .htm or .html 当保存HTML文件时，可以使用.htm,也可以使用.html文件后缀。使用.htm,这只是长久以来形成的习惯，因为过去的很多软件只允许三个字母的文件后缀。对于新的软件，使用.html完全没有问题。
 HTML标签 HTML标签是由尖括号包围的关键词，比如&amp;lt;html&amp;gt;。标签通常是成对出现的「也有可能是单个出现」，比如&amp;lt;b&amp;gt;和&amp;lt;/b&amp;gt;；标签对中的第一个标签时开始标签，第二个标签是结束标签。
 HTML元素 HTML文档用于描述网页「HTML文档也被称为网页」，文档包含HTML标签和纯文本。HTML元素，指的是从开始标签(start tag)到结束标签(end tag)的所有代码。元素的内容是开始标签与结束标签之间的内容。
某些HTML元素具有空内容，没有内容的HTML元素被称为空元素,空元素在开始标签中进行关闭。
&amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt;  &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt;  &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34;&amp;gt;  &amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;ie=edge&amp;#34;&amp;gt;  &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt;  &amp;lt;div&amp;gt;测试&amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;  HTML属性 大多数HTML元素可拥有属性,属性提供了有关HTML元素的更多的信息，属性总是以名称/值对的形式出现，比如：name=&amp;quot;value&amp;quot;：
  属性总是在HTML元素的开始标签中规定。
  属性和属性值对大小写不敏感。不过，万维网联盟在其HTML 4 推荐标准中推荐小写的属性/属性值。而新版本的(X)HTML要求使用小写属性。
  属性值应该始终被包括在引号内，双引号是最常用的，不过使用单引号也没有问题。
  &amp;lt;a href=&amp;#34;http://www.w3school.com.cn&amp;#34;&amp;gt;This is a link&amp;lt;/a&amp;gt;  外部样式表 &amp;lt;head&amp;gt; &amp;lt;link rel=&amp;#34;stylesheet&amp;#34; type=&amp;#34;text/css&amp;#34; href=&amp;#34;mystyle.css&amp;#34;&amp;gt; &amp;lt;/head&amp;gt;  &amp;lt;head&amp;gt; &amp;lt;link href=&amp;#34;./style.css&amp;#34; rel=&amp;#34;stylesheet&amp;#34; type=&amp;#34;text/css&amp;#34;&amp;gt; &amp;lt;/head&amp;gt;  内部样式表 &amp;lt;head&amp;gt; &amp;lt;style type=&amp;#34;text/css&amp;#34;&amp;gt; body {background-color: red} p {margin-left: 20px} &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt;  内联样式表 &amp;lt;p style=&amp;#34;color: red; margin-left: 20px&amp;#34;&amp;gt; This is a paragraph &amp;lt;/p&amp;gt;  超链接 超链接可以是一个字，一个词，或者一组词，也可以是一副图像，你可以点击这些内容来跳转到新的文档或者当前文档的某个部分。
通过使用&amp;lt;a&amp;gt;标签在HTML中创建新链接，可以有两种使用超链接的方式：
  通过使用href属性创建指向另一个文档的链接。
  通过使用name属性，创建文档内的书签（锚）。
   页面间跳转 &amp;lt;a href=&amp;#34;http://www.w3school.com.cn/&amp;#34;&amp;gt;Visit W3School&amp;lt;/a&amp;gt; &amp;lt;a href=&amp;#34;http://www.w3school.com.cn/html/html_links.asp#tips&amp;#34;&amp;gt;有用的提示&amp;lt;/a&amp;gt;&amp;lt;!--从其他页面创建指向该页面的锚--&amp;gt;  页面内跳转 页面内的跳转需要两个步骤：
  设置一个锚点链接&amp;lt;a href=&amp;quot;#miao&amp;quot;&amp;gt;去找喵星人&amp;lt;/a&amp;gt;。需要注意的是要在href的属性值value前加#。
  在页面中需要的位置设置一个锚点&amp;lt;a name=&amp;quot;miao&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;，标签中按需填写必要的文字，一般不写内容。设置锚点有两种方式
  &amp;lt;a name=&amp;quot;miao&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;。
  &amp;lt;h3 id=&amp;quot;miao&amp;quot;&amp;gt;喵星人基地&amp;lt;/h3&amp;gt;。这种方式不用单独添加一个a标签来设置锚点。
    &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; 	&amp;lt;meta charset=&amp;#34;utf-8&amp;#34;&amp;gt; 	&amp;lt;title&amp;gt;测试&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; 	&amp;lt;ul&amp;gt;  &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;#miao&amp;#34;&amp;gt;去找喵星人&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;!--同一个文档中创建指向该锚的链接--&amp;gt;  &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;#wang&amp;#34;&amp;gt;去找汪星人&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;!--同一个文档中创建指向该锚的链接--&amp;gt;  &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;#meng&amp;#34;&amp;gt;其他萌物&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;!--同一个文档中创建指向该锚的链接--&amp;gt;  &amp;lt;/ul&amp;gt;   &amp;lt;a name=&amp;#34;miao&amp;#34;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;!--设置锚点方法1--&amp;gt;  &amp;lt;h3 id=&amp;#34;miao&amp;#34;&amp;gt;喵星人基地&amp;lt;/h3&amp;gt;&amp;lt;!--设置锚点方法2--&amp;gt;  &amp;lt;p&amp;gt;喵喵喵~&amp;lt;/p&amp;gt;  &amp;lt;p&amp;gt;喵喵喵~&amp;lt;/p&amp;gt;  &amp;lt;p&amp;gt;喵喵喵~&amp;lt;/p&amp;gt;  &amp;lt;p&amp;gt;喵喵喵~&amp;lt;/p&amp;gt;  &amp;lt;p&amp;gt;喵喵喵~&amp;lt;/p&amp;gt;  &amp;lt;p&amp;gt;喵喵喵~&amp;lt;/p&amp;gt;   &amp;lt;a name=&amp;#34;wang&amp;#34;&amp;gt;&amp;lt;/a&amp;gt;  &amp;lt;p&amp;gt;汪汪汪~&amp;lt;/p&amp;gt;  &amp;lt;p&amp;gt;汪汪汪~&amp;lt;/p&amp;gt;  &amp;lt;p&amp;gt;汪汪汪~&amp;lt;/p&amp;gt;  &amp;lt;p&amp;gt;汪汪汪~&amp;lt;/p&amp;gt;  &amp;lt;p&amp;gt;汪汪汪~&amp;lt;/p&amp;gt;  &amp;lt;p&amp;gt;汪汪汪~&amp;lt;/p&amp;gt;   &amp;lt;a name=&amp;#34;meng&amp;#34;&amp;gt;&amp;lt;/a&amp;gt;  &amp;lt;p&amp;gt;萌萌萌~&amp;lt;/p&amp;gt;  &amp;lt;p&amp;gt;萌萌萌~&amp;lt;/p&amp;gt;  &amp;lt;p&amp;gt;萌萌萌~&amp;lt;/p&amp;gt;  &amp;lt;p&amp;gt;萌萌萌~&amp;lt;/p&amp;gt;  &amp;lt;p&amp;gt;萌萌萌~&amp;lt;/p&amp;gt;  &amp;lt;p&amp;gt;萌萌萌~&amp;lt;/p&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 参考资料
 图片 在HTML中，图像由&amp;lt;img&amp;gt;标签定义，&amp;lt;img&amp;gt;是空标签，即只包含属性，没有闭合标签。
&amp;lt;img src=&amp;#34;https://i.loli.net/2018/12/06/5c09153160635.jpg&amp;#34; alt=&amp;#34;none&amp;#34;&amp;gt; &amp;lt;!--`alt`属性表示当图片找不到时，应该显示的替换文本--&amp;gt;  span标签 span标签表示无语义行内元素，常用来组合文档内的行内元素，以便通过样式来格式化它们。
 类 可以为元素表设置类，然后为相同的类定义CSS样式：
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;style&amp;gt; .cities {  background-color:black;  color:white;  margin:20px;  padding:20px; } &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt;  &amp;lt;body&amp;gt;  &amp;lt;div class=&amp;#34;cities&amp;#34;&amp;gt; &amp;lt;h2&amp;gt;London&amp;lt;/h2&amp;gt; &amp;lt;p&amp;gt;London is the capital city of England. It is the most populous city in the United Kingdom, with a metropolitan area of over 13 million inhabitants.&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt;  &amp;lt;div class=&amp;#34;cities&amp;#34;&amp;gt; &amp;lt;h2&amp;gt;Paris&amp;lt;/h2&amp;gt; &amp;lt;p&amp;gt;Paris is the capital and most populous city of France.&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt;  &amp;lt;div class=&amp;#34;cities&amp;#34;&amp;gt; &amp;lt;h2&amp;gt;Tokyo&amp;lt;/h2&amp;gt; &amp;lt;p&amp;gt;Tokyo is the capital of Japan, the center of the Greater Tokyo Area, and the most populous metropolitan area in the world.&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt;  &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;  HTML布局 &amp;lt;div&amp;gt;元素常用于布局工具，因为能够轻松通过CSS对其进行定位，下面这个例子使用4个&amp;lt;div&amp;gt;元素来创建多列布局：
&amp;lt;body&amp;gt;  &amp;lt;div id=&amp;#34;header&amp;#34;&amp;gt; &amp;lt;h1&amp;gt;City Gallery&amp;lt;/h1&amp;gt; &amp;lt;/div&amp;gt;  &amp;lt;div id=&amp;#34;nav&amp;#34;&amp;gt; London&amp;lt;br&amp;gt; Paris&amp;lt;br&amp;gt; Tokyo&amp;lt;br&amp;gt; &amp;lt;/div&amp;gt;  &amp;lt;div id=&amp;#34;section&amp;#34;&amp;gt; &amp;lt;h1&amp;gt;London&amp;lt;/h1&amp;gt; &amp;lt;p&amp;gt; London is the capital city of England. It is the most populous city in the United Kingdom, with a metropolitan area of over 13 million inhabitants. &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; Standing on the River Thames, London has been a major settlement for two millennia, its history going back to its founding by the Romans, who named it Londinium. &amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt;  &amp;lt;div id=&amp;#34;footer&amp;#34;&amp;gt; Copyright W3School.com.cn &amp;lt;/div&amp;gt;  &amp;lt;/body&amp;gt; &amp;lt;style&amp;gt; #header {  background-color:black;  color:white;  text-align:center;  padding:5px; } #nav {  line-height:30px;  background-color:#eeeeee;  height:300px;  width:100px;  float:left;  padding:5px; } #section {  width:350px;  float:left;  padding:10px; } #footer {  background-color:black;  color:white;  clear:both;  text-align:center;  padding:5px; } &amp;lt;/style&amp;gt;  HTML框架 通过使用框架，你可以在同一个浏览器窗口中显示不止一个页面。每份HTML文档称为一个框架，并且每个框架都独立于其他的框架。
使用框架的缺点——开发人员必须同时跟踪更多的HTML文档。
结构框架标签frameset定义如何将窗口分割为框架，每个frameset定义了一系列行与列。rows/columns的值规定了每行与每列占据屏幕面积。
&amp;lt;frameset cols=&amp;#34;25%,75%&amp;#34;&amp;gt;  &amp;lt;frame src=&amp;#34;frame_a.htm&amp;#34;&amp;gt;  &amp;lt;frame src=&amp;#34;frame_b.htm&amp;#34;&amp;gt; &amp;lt;/frameset&amp;gt; 上面的代码设置两列的框架集，第一列被设置占浏览器的25%，第二列占浏览器的75%。
假如一个框架有可见边框，用户可以拖动边框来改变它的大小。为了避免这种情况发生，可以在&amp;lt;frame&amp;gt;标签中加入：noresize=&amp;quot;noresize&amp;quot;。
不能将&amp;lt;body&amp;gt;&amp;lt;/body&amp;gt;标签与&amp;lt;frameset&amp;gt;&amp;lt;/frameset&amp;gt;标签同时使用。不过，假如你添加包含一段文本的&amp;lt;noframes&amp;gt;标签，就必须将这段文字嵌套于 &amp;lt;body&amp;gt;&amp;lt;/body&amp;gt;标签内。
 内联框架 内联框架用于在网页内显示页面，使用iframe标签，其中width和height可以设置宽度和高度，默认值是像素，也可以使用百分比来显示。
&amp;lt;body&amp;gt;  &amp;lt;iframe src=&amp;#34;http://localhost:1313/post/htm-primer/&amp;#34; width=&amp;#34;600&amp;#34; height=&amp;#34;600&amp;#34;&amp;gt;&amp;lt;/iframe&amp;gt; &amp;lt;/body&amp;gt; ifame标签的frameborder属性规定是否显示 iframe周围的边框，值为0表示移除边框。
frame可用作链接的目标（target）。链接的target属性必须引用 iframe的name属性。
&amp;lt;iframe src=&amp;#34;http://localhost:1313/post/htm-primer/&amp;#34; width=&amp;#34;600&amp;#34; height=&amp;#34;600&amp;#34; frameborder=&amp;#34;0&amp;#34;&amp;gt;&amp;lt;/iframe&amp;gt; &amp;lt;br/&amp;gt; &amp;lt;iframe src=&amp;#34;http://localhost:1313/post/htm-primer/&amp;#34; name=&amp;#34;iframe_a&amp;#34;&amp;gt;&amp;lt;/iframe&amp;gt; &amp;lt;p&amp;gt;&amp;lt;a href=&amp;#34;http://www.w3school.com.cn&amp;#34; target=&amp;#34;iframe_a&amp;#34;&amp;gt;W3School.com.cn&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;  背景颜色 &amp;lt;body&amp;gt;标签具有两个配置背景的属性，背景可以是颜色或者图片，分别是背景颜色属性bgcolor和背景图片属性background。bgcolor用于设置背景颜色；而background将背景设置为图片，其属性值为图片的URL。
&amp;lt;body bgcolor=&amp;#34;#000000&amp;#34;&amp;gt; &amp;lt;body bgcolor=&amp;#34;rgb(0,0,0)&amp;#34;&amp;gt; &amp;lt;body bgcolor=&amp;#34;black&amp;#34;&amp;gt; &amp;lt;body background=&amp;#34;clouds.gif&amp;#34;&amp;gt; &amp;lt;body background=&amp;#34;http://www.w3school.com.cn/clouds.gif&amp;#34;&amp;gt; &amp;lt;body&amp;gt;标签中的背景颜色（bgcolor）、背景（background）和文本（text）属性在最新的HTML标准（HTML4和XHTML）中已被废弃。W3C在其的推荐标准中已删除这些属性。
 HTML脚本 &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;script type=&amp;#34;text/javascript&amp;#34;&amp;gt; document.write(&amp;#34;&amp;lt;h1&amp;gt;Hello World!&amp;lt;/h1&amp;gt;&amp;#34;) &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;  HTML头部 head元素是所有头部元素的容器，head内部的元素可包含脚本，指示浏览器在何处可以找到样式表，提供元信息等。以下标签都可以加到&amp;lt;head&amp;gt;部分：
  &amp;lt;title&amp;gt;:定义浏览器工具栏中的标题。
&amp;lt;title&amp;gt;RichTextEditor&amp;lt;/title&amp;gt;   &amp;lt;base&amp;gt;: 为页面上所有的链接规定默认的地址或默认目标。
&amp;lt;head&amp;gt; &amp;lt;base href=&amp;#34;http://www.w3school.com.cn/images/&amp;#34; /&amp;gt; &amp;lt;base target=&amp;#34;_blank&amp;#34; /&amp;gt; &amp;lt;/head&amp;gt;   &amp;lt;link&amp;gt;: 定义文档与外部资源之间的关系。
&amp;lt;head&amp;gt; &amp;lt;link rel=&amp;#34;stylesheet&amp;#34; type=&amp;#34;text/css&amp;#34; href=&amp;#34;mystyle.css&amp;#34; /&amp;gt; &amp;lt;/head&amp;gt;   &amp;lt;meta&amp;gt;:定义文档的元数据信息，元数据用于规定页面的描述，关键词，修改时间等。
 &amp;lt;meta charset=&amp;#34;utf-8&amp;#34;&amp;gt;  &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0,maximum-scale=1.0, user-scalable=no&amp;#34; &amp;gt;  &amp;lt;meta content=&amp;#34;ie=edge&amp;#34; http-equiv=&amp;#34;X-UA-Compatible&amp;#34;&amp;gt;   &amp;lt;script&amp;gt;:用于定义客户端的脚本。
  &amp;lt;style&amp;gt;: 定义样式信息。
&amp;lt;head&amp;gt; &amp;lt;style type=&amp;#34;text/css&amp;#34;&amp;gt;  body {background-color:yellow}  p {color:blue} &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt;    HTML URL URL统一资源定位器，也被称为网址，其用于定位万维网上的文档（或其他数据）:
scheme://host.domain:port/path/filename  scheme: 定义因特网服务的类型，例如http,https,ftp,file等。 host: 定义域主机，http的默认主机是www。 domain: 定义因特网的域名，例如mmhui.top。 :post: 定义主机上的端口，http默认是80。 Path: 定义服务器上的路径，如果省略，则文档必须位于网站的根目录下。 filename:定义文档或者资源的名称。   URL的编码 URL只能使用ASCII字符集来通过因特网进行发送，但是URL中常常包含ASCII集合之外的字符，URL必须转换为有效的ASCII格式。
URL编码使用%其后跟随两位的十六进制的数来替代非ASCII字符。
 文档类型 HTML文档存在不同的版本，只有事先声明HTML文档的版本，浏览器才能完全正确的显示出HTML页面。!DOCTYPE可以用于声明HTML文档的版本：
html 5 文档 &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;!--html5文档--&amp;gt; html 4.1 文档 &amp;lt;!DOCTYPE HTML PUBLIC &amp;#34;-//W3C//DTD HTML 4.01 Transitional//EN&amp;#34; &amp;#34;http://www.w3.org/TR/html4/loose.dtd&amp;#34;&amp;gt; &amp;lt;!--html 4.1 文档--&amp;gt; xhtml 1.0 文档 &amp;lt;!DOCTYPE html PUBLIC &amp;#34;-//W3C//DTD XHTML 1.0 Transitional//EN&amp;#34; &amp;#34;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&amp;#34;&amp;gt; &amp;lt;!--xhtml 1.0文档--&amp;gt;  高度 function getInfo(){  let s = &amp;#34;&amp;#34;;  s &#43;= &amp;#34; 网页可见区域宽：&amp;#34;&#43; document.body.clientWidth;  s &#43;= &amp;#34; 网页可见区域高：&amp;#34;&#43; document.body.clientHeight;  s &#43;= &amp;#34; 网页可见区域宽：&amp;#34;&#43; document.body.offsetWidth &#43; &amp;#34; (包括边线和滚动条的宽)&amp;#34;;  s &#43;= &amp;#34; 网页可见区域高：&amp;#34;&#43; document.body.offsetHeight &#43; &amp;#34; (包括边线的宽)&amp;#34;;  s &#43;= &amp;#34; 网页正文全文宽：&amp;#34;&#43; document.body.scrollWidth;  s &#43;= &amp;#34; 网页正文全文高：&amp;#34;&#43; document.body.scrollHeight;  s &#43;= &amp;#34; 网页被卷去的高(ff)：&amp;#34;&#43; document.body.scrollTop;  s &#43;= &amp;#34; 网页被卷去的高(ie)：&amp;#34;&#43; document.documentElement.scrollTop;  s &#43;= &amp;#34; 网页被卷去的左：&amp;#34;&#43; document.body.scrollLeft;  s &#43;= &amp;#34; 网页正文部分上：&amp;#34;&#43; window.screenTop;  s &#43;= &amp;#34; 网页正文部分左：&amp;#34;&#43; window.screenLeft;  s &#43;= &amp;#34; 屏幕分辨率的高：&amp;#34;&#43; window.screen.height;  s &#43;= &amp;#34; 屏幕分辨率的宽：&amp;#34;&#43; window.screen.width;  s &#43;= &amp;#34; 屏幕可用工作区高度：&amp;#34;&#43; window.screen.availHeight;  s &#43;= &amp;#34; 屏幕可用工作区宽度：&amp;#34;&#43; window.screen.availWidth;  s &#43;= &amp;#34; 你的屏幕设置是 &amp;#34;&#43; window.screen.colorDepth &#43;&amp;#34; 位彩色&amp;#34;;  s &#43;= &amp;#34; 你的屏幕设置 &amp;#34;&#43; window.screen.deviceXDPI &#43;&amp;#34; 像素/英寸&amp;#34;; } 去除UIWebview底部的黑线   将UIWebView的opaque设置为false。
  设置UIWebView的背景颜色以清除颜色。
   </content>
    </entry>
    
     <entry>
        <title>CSS 入门</title>
        <url>https://iihui.github.io/post/css-primer/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>CSS</tag><tag>code</tag>
        </tags>
        <content type="html"> 关注点分离和混合 关注点分离 关注点分离的意思是：各种技术只负责自己的领域，不要混合在一起，形成耦合。对于网页开发来说，主要是三种技术分离。
  HTML:负责网页的结构，称为语义层。
  CSS:负责网页的样式，称为视觉层。
  JavaScript:负责网页的逻辑和交互，称为逻辑层或者交互层。
  也就是说不要写行内样式和行内脚本，例如下面的代码就很糟糕：
&amp;lt;h1 style=&amp;#34;color:red;font-size:46px;&amp;#34; onclick=&amp;#34;alert(&amp;#39;Hi&amp;#39;)&amp;#34;&amp;gt;  Hello World &amp;lt;/h1&amp;gt;  关注点混合 而React出现之后，这个原则就不适用了，因为React是组件结构，强制要求把HTML,CSS,JavaScript写在一起。
const style = {  &amp;#39;color&amp;#39;: &amp;#39;red&amp;#39;,  &amp;#39;fontSize&amp;#39;: &amp;#39;46px&amp;#39; };  const clickHandler = () =&amp;gt; alert(&amp;#39;hi&amp;#39;);  ReactDOM.render(  &amp;lt;h1 style={style} onclick={clickHandler} &amp;gt;  Hello, world!  &amp;lt;/h1&amp;gt;  document.getElementById(&amp;#39;example&amp;#39;) ); 上面代码写在一个文件中，封装了结构、样式和逻辑，完全违背了关注点分离的原则。但是，这种方式有利于组件的隔离。每个组件包含了所有需要用到的代码，不依赖外部，组件之间没有耦合，很方便复用。所以，随着React的走红和组件模式深入人心，这种关注点混合的新写法逐渐成为主流。
CSS 实例 CSS规则是由两个主要的部分构成：选择器以及一条或者多条声明，声明总是以分号结束。
* { margin:0; padding:0; } p { font-size:2em; } .info { background:#ff0; } p.info { background:#ff0; } p.info.error { color:#900; font-weight:bold; } #info { background:#ff0; } p#info { background:#ff0; } CSS的注释是由/*开始，以*/结束，用于解释代码，并可以随意编辑它，浏览器会忽略它。
 选择器 CSS的基本选择器包括：  通用选择器，匹配任何元素。 标签选择器，匹配所有使用该标签的元素。 class选择器，匹配所有class属性中包含info的元素。 id选择器，匹配所有id属性为footer的元素。   标签选择器 标签选择器，即将HTML中的标签作为选择器：
p { &amp;lt;!--标签选择器--&amp;gt;  line-height: auto; //行距自动变化  margin-top: 0px;  margin-bottom: 15px; /*24*/ }  html, body { &amp;lt;!--标签选择器--&amp;gt; 	padding: 0; 	margin: 0; 	font-family: Arial, Helvetica, sans-serif; }  id选择器 id选择器可以为标有特定的id的HTML元素指定特定的样式。HTML元素以id属性来设置id选择器，CSS中id选择器以#来定义：
#separatorDiv {  -webkit-user-select: none;  padding-left: 10px;  padding-right: 10px; }  #content {  outline: 0px solid transparent; } 需要特别注意的是ID属性不要以数字开头，否则ID在火狐浏览器中不起作用。
 class选择器 class选择器用于描述一组元素的样式，class选择器有别于id选择器，class可以在多个元素中使用。class选择器在HTML中以class属性表示, 在 CSS中，类选择器以一个点.号显示。在下例中，所有拥有center类的HTML元素均为居中:
.center {text-align:center;} 同样地，类名的第一个不能使用数字，否则无法在火狐浏览器中起作用。
参考资料
 innerHeight 和outerHeight 通过window.innerHeight和window.outerHeight可以得到整个窗口的高度，其中：
  innerHeight 是DOM视口的大小，包括滚动条。
  couterHeight 是整个浏览器窗口的大小，包括窗口标题，工具栏和状态栏等。
  在不支持window.innerHeight的浏览器中，可以读取documentElement和body的高度，它们的大小和window.innerHeight类似，但有区别。
document.documentElement.clientHeight document.body.clientHeight 其中documentElement是文档根元素——&amp;lt;html&amp;gt;标签，而body就是&amp;lt;body&amp;gt;标签。因此为了解决兼容性问题，常常使用如下代码：
var height = window.innerHeight || document.documentElement.clientHeight|| document.body.clientHeight; 实际上后面两种方式获取的高度和window.innerHeight是不一样的，这3个属性的值逐渐变小，具体来说:
  window.innerHeight包括整个DOM：内容，边框以及滚动条高度。
  documentElement.clientHeight不包括整个文档滚动条高度，但包括&amp;lt;html&amp;gt;元素的边框高度。
  body.clientHeight不包括整个文档的滚动条高度，也不包括&amp;lt;html&amp;gt;元素的边框高度，也不包括&amp;lt;body&amp;gt;的边框和滚动条高度。
   滚动高度 使用JS控制页面滚动时（如回到顶部），需要知道页面当前滚动到了哪里，以及将要滚动到哪里。这涉及到4个DOM属性，所有的DOM元素都有以下4个属性。
  clientHeight 内部可视区域的高度。
  offsetHeight 整个可视区域的高度，包括border和scrollbar在内。
  scrollHeight 元素内部的高度，包括溢出的部分。
  scrollTop 元素内容向上滚动了多少像素，如果没有滚动则返回0。
   参考资料
</content>
    </entry>
    
     <entry>
        <title>Xcode</title>
        <url>https://iihui.github.io/post/xcode-quick/</url>
        <categories>
          <category>tool</category>
        </categories>
        <tags>
          <tag>tool</tag>
        </tags>
        <content type="html"> 快捷键 键盘图标  ⌘——Command () ⌃ ——Control ⌥——Option (alt) ⇧——Shift ⇪——Caps Lock  快捷键  Command&#43;R 运行 Command&#43;B 编译 Command&#43;. 停止 Command &#43; Shift &#43; K 清除工程 Command &#43; K 清除控制台信息 Command &#43; N 新建文件 Command &#43; Shift &#43; N 创建新工程  导航栏   Command&#43;0~9 工程导航
  Command &#43; 0 快速打开实用面板
  Command &#43; 1 查看工程文件
  Command &#43; 2 版本控制导航
  Command &#43; 3 符号导航(类)
  Command &#43; 4 警告和错误导航
  Command &#43; 5 测试导航
  Command &#43; 6 调试导航
  Command &#43; 7 断点导航
  Command &#43; 9 报告导航
    Command &#43; Option &#43; 0 打开右侧导航栏
  Command &#43; Option &#43; T 打开工具栏
  Command &#43; Shift &#43; Y 打开底部导航栏
  Command &#43; Z 撤销
  Command &#43; Shift &#43; Z 反撤销
  查找与跳转  Command &#43; F 在当前文档中查找 Command &#43; Shift &#43; G 搜索上一处 Command &#43; G 搜索下一处 Command &#43; L 跳转到特定行 Command &#43; Shift &#43; O（字母） 快速查找打开类 Command &#43; Shift &#43; J 快速定位到当前类在项目中的位置 Command &#43; Shift &#43; 0(数字zero)查看帮助文档 Command &#43; Control&#43;↑/Command&#43;Control&#43;↓ 类文件和实现文件之间跳转 Command&#43;Control&#43;←/Command&#43;Control&#43;→ 回到上一个/下一个打开的页面 Command&#43;Option&#43;←/Command&#43;Option&#43;→ 收放方法体，即将方法体收起或者展开 Control &#43; 6 在当前类查找变量和方法 「键入方法或者变量名&#43;Enter跳转」  光标操作  Control &#43; F 向右一个字符 Control &#43; B 向左一个字符 Control &#43; P 向上一行 Control &#43; N 向下一行 Control &#43; A 跳到行首 Control &#43; E 跳到行尾 Control &#43; T 调换光标两边的字符 Control &#43; D 删除光标右侧的单个字符 Control &#43; K 删除本行剩余的字符  整体位移  Command &#43; [ 选中的代码整体左移 Command &#43; ] 选中的代码整体右移 Command &#43; Option &#43; [ 选中的代码整体上移 Command &#43; Option &#43; ] 选中的代码整体下移  补充   Command &#43; Option &#43; 点击桌面上空白的区域:把除Finder窗口以外的所有窗口隐藏起来，直接显示桌面。分别点击Dock栏上各个相关应用程序图标就可以解除窗口的隐藏状态了。
  Command &#43; Option &#43; H: 把所有已打开的程序窗口（不包括当前正在运行的应用程序窗口）最小化到Dock栏上。注意不是关闭哦，是最小化。如果需要把程序窗口恢复到屏幕上，直接点击相应的应用程序图标就可以了。
  编译选项 在schema中添加DYLD_PRINT_STATISTICS可统计启动时间。
参考资料1 参考资料2 参考资料3
Interface Builder IBOutlet Swift编译器在看到@IBOutlet声明时不会进行任何特殊处理。它存在的意义仅仅是提示XCode这个属性需要关联到storyboard或nib文件中的对象上。
从storyboard中创建@IBOutlet变量或者操作方法，有两种方式。第一种是先在storyboard中选中某个对象，然后同时按住Control键和鼠标左键并拖动光标到辅助编辑器上，然后松开鼠标左键，便可得到如下界面：
第二种方法也是先在storyboard中选中某个对象，然后按住鼠标右键，接着拖动光标到辅助编辑器上，最后放开鼠标右键，即可得到上图所示的界面。
复制对象 除了从对象库中拖出一个对象，也可以按住option键不放，并拖动想要复制的对象，以生成副本。按住option键是告诉Interface Builder创建一个被拖动对象的副本。
不可见对象 如果有不可见的用户界面元素，比如空白标签，但又希望能看到它们在storyboard中的位置，可以设置Editor→Canvas→Show Bounds Rectangles，便可看到空白标签：
约束设置 打开视图结构文档缩略图，选中要设置的对象，按住鼠标右键同时拖动到某个对象上，然后松开鼠标右键，便可得到一个设置约束的灰色的浮动框，点击任意一个都会生效：
在上图中，为了一次可以设置多个约束，需要一直按住shift键，然后点击需要设置的约束，便可设置多个约束，效果如下图所示：
Xcode Source Editor 如果在System Preferences--&amp;gt;Extensions下没有Xcode Source Editor。参考此篇文章，最快的方式是将Xcode重命名，然后再改回名字为Xcode，或者把Xcode移出Application文件夹，然后再移回来即可。
</content>
    </entry>
    
     <entry>
        <title>OC 入门</title>
        <url>https://iihui.github.io/post/oc-tour/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>OC</tag><tag>iOS</tag>
        </tags>
        <content type="html">  Objective-C简称OC， 是C语言的严格超集——任何C语言程序不经过修改都可以直接通过OC的编译器，在OC中使用C语言代码也是完全合法的。OC被描述为覆盖在C语言上的一层，因为OC的原意就是在C语言的主体上加入面向对象的特性。
 文件扩展名    文件扩展名 类型和作用     .h 头文件，包含类，类型，函数和常数声明   .m 源代码文件，典型的源代码文件扩展名，可以包含OC和C代码   .mm 源代码文件，带这种扩展名的源代码文件，除了可以包含OC和C代码以外，还可以包含C&#43;&#43;代码    源代码中需要包含头文件的时候，可以使用标准的#include编译选项，也可以使用#import选项，但是OC中使用#import可以确保相同的文件只包含一次，因此一般使用#import来引入头文件。
 语法 Objective-C最大的特色使用Smalltalk的消息传递模型。在OC中与其说是对象调用方法，不如说向对象传递消息更为精确。
调用方法 在OC中，调用方法视为向对象发送消息，所有方法(类方法和实例方法)都被视为对消息的回应。
所有消息的处理直到运行时（runtime）才会动态决定，并交由类自行决定如何处理收到的消息。也就是说，一个类不保证一定会回应收到的消息，如果类收到了一个无法处理的消息，程序只会抛出异常，不会出错或崩溃。
在OC中发送消息的语法为：
[obj method: argument]; //C&#43;&#43;对应的是obj.method(argument); 一个例子:
[car fly] 上面的例子典型的C&#43;&#43;意义解读是:调用car类的fly方法。若car类里头没有定义fly方法，那编译肯定不会通过。但是OC里，应当解读为:发送一个fly的消息给car对象，fly是消息，而car是消息的接收者。car收到消息后会决定如何回应这个消息，若car类别内定义有fly方法就运行方法内之代码，若car内不存在fly方法，则程序依旧可以通过编译，运行期则抛出异常。
因此OC天生具备鸭子类型的动态类型绑定能力，运行期间才处理消息，允许发送未知消息给对象，可以发送消息给整个对象集合而不需要检查每个对象的类型，也具备消息转发机制。同时空对象nil接受消息后默认不做任何回应，所以发送消息给nil也不用担心崩溃。
 字符串 作为C语言的超集，OC支持C语言字符串方面的约定：单个字符被单引号包括，字符串被双引号包括。但是，大多数OC通常不使用C语言风格的字符串，大多数框架把字符串传递给NSString对象NSString类提供了字符串的类包装，包含了所有你期望的优点——包括对保存任意长度字符串的内建内存管理机制，支持Unicode，printf风格的格式化工具等。
因为这种字符串使用的非常频繁，OC提供了一个助记符可以方便地从常量值创建NSString对象，即在普通的双引号字符串前放置一个@符号:
NSString* myString = @&amp;#34;My String\n&amp;#34;; NSString* anotherString = [NSString stringWithFormat:@&amp;#34;%d %s&amp;#34;, 1, @&amp;#34;String&amp;#34;];  // 从一个C语言字符串创建Objective-C字符串 NSString* fromCString = [NSString stringWithCString:&amp;#34;A C string&amp;#34; encoding:NSASCIIStringEncoding];  类 OC类的说明包含两个部分：定义(interface)和实现(implementation)。类定义包含了类声明、实例变量的定义以及相关的方法（包括类方法和实例方法）；实现则包含了类方法的实际代码。
类的声明总是以@interface编译选项开始，由@end编译选项结束。类名之后的（用冒号分隔）是父类的名字。类的变量声明在被大括号包含的代码块中。变量块后是类声明的方法的列表，每个变量和方法声明都以分号结尾。
 Interface 定义部分，以关键字@interface作为开始，@end作为结束，其中定义的实例变量的默认权限是protected：
@interface MyObject : NSObject {  int memberVar1; // 实例变量，在定义部分声明的实例变量的默认访问权限是protected  id memberVar2; //id 类型表示任意类型 }  &#43;(return_type) class_method; // 类方法  -(return_type) instance_method1; // 实例方法 -(return_type) instance_method2: (int) p1; -(return_type) instance_method3: (int) p1 andPar: (int) p2; @end 方法前面的&#43;或者-号代表函数的类型：加号&#43;代表类方法（class method），不需要实例就可以调用，与C&#43;&#43;的静态函数（static member function）相似；减号-表示一般的实例方法（instance method）。
下面是与OC对应的C&#43;&#43;的声明：
class MyObject : public NSObject { protected:  int memberVar1; // 实体变量  void * memberVar2;   public:  static return_type class_method(); // 类方法   return_type instance_method1(); // 实例方法  return_type instance_method2( int p1 );  return_type instance_method3( int p1, int p2 ); } OC定义一个新方法时，名称内的冒号代表传递参数：
- (void) setColorToRed: (float)red Green: (float)green Blue:(float)blue; /* 声明方法*/  [myColor setColorToRed: 1.0 Green: 0.8 Blue: 0.2]; /* 调用方法*/ 上面这个方法的签名是setColorToRed:Green:Blue。每个冒号后面都带着一个float类别的参数，分别代表红绿蓝三色。
 Implementation 实现块包含了公开的方法的实现，以及定义私有变量以及方法，以关键字@implementation作为区块的开始，@end结尾。
@implementation MyObject {  int memberVar3; //私有实例变量 }  &#43;(return_type) class_method {  .... //方法的实现部分 } -(return_type) instance_method1 {  .... } -(return_type) instance_method2: (int) p1 {  .... } -(return_type) instance_method3: (int) p1 andPar: (int) p2 {  .... } @end   不只Interface区域可定义实体变量，Implementation区块也可以定义实体变量。
  两者的差别在于访问权限的不同，Interface区块内的实体变量默认权限为protected。而在implementation区域定义的实体变量则默认为private，故在Implementation区块定义私有成员更匹配面向对象之封装原则，因为类的私有信息就不需暴露在公开interface(.h文件)中。
   创建对象 OC创建对象需通过alloc以及init两个消息,alloc的作用是分配内存，init是初始化对象。init与alloc都是定义在NSObject里的方法，父对象收到这两个信息并做出正确回应后，新对象才创建完毕。
MyObject * my = [[MyObject alloc] init]; 在OC 2.0里，若创建对象不需要参数，则可以直接使用new
MyObject * my = [MyObject new];  方法 在OC中类可以声明两种类型的方法：实例方法和类方法。实例方法在类的一个具体实例的范围内执行，即要调用实例方法前，需要首先创建类的实例，而类方法不需要创建一个实例。
方法声明包括方法类型标识符，返回值类型，一个或多个方法标识关键字，参数类型和名信息，下图展示 insertObject:atIndex: 实例方法的声明。
  声明由一个减号-开始，这表明这是一个实例方法。方法实际的名字(insertObject:atIndex:)是所有方法标识关键的级联，包含了冒号。
  冒号表明了参数的出现，如果方法没有参数，你可以省略第一个(也是唯一的)方法标识关键字后面的冒号。
  当需要调用一个方法时，即传递消息给对应的对象，这里的消息是指方法标识符以及传递给方法的参数信息。
  发送给对象的所有消息都会动态分发，这样有利于实现OC的多态行为。
  如果子类定义了和父类具有相同标识符的方法，那么子类首先收到消息，然后选择把收到的消息转发（也可以不转发）给他的父类。
  消息被中括号包括。中括号里，接收消息的对象在左边，消息（包括消息需要的任何参数）在右边。例如，给myArray变量传递消息insertObject:atIndex:消息，需要使用如下的语法：
[myArray insertObject:anObj atIndex:0]; 为了避免过多地声明本地变量保存临时结果，OC允许使用嵌套消息，每个嵌套消息的返回值可以作为其他消息的参数。例如，有另外一个对象叫做myAppObject有方法可以访问数组对象，以及插入一个对象到一个数组，就可以将前面的例子写成如下的形式：
[[myAppObject getArray] insertObject:[myAppObject getObjectToInsert] atIndex:0]; 消息也可以传递给类本身，当给类发消息的时候，指定的方法必须为类方法。类方法的典型用途是用做创建新类实例的工厂方法，或者是访问类相关的共享信息的途径。
NSMutableArray* myArray = nil; // nil 基本上等同于 NULL  // 创建一个新的数组，并把它赋值给 myArray 变量 myArray = [NSMutableArray arrayWithCapacity:0]; 上面是一个类方法作为一个工厂方法来使用。arrayWithCapacity是NSMutableArray类的类方法，为类的新实例分配内容并初始化，然后返回。
 属性 属性使用一个等式来表示：@property = 成员变量 &#43; getter &#43; setter，即一个属性包含了一个成员变量以及该成员变量的getter和setter方法：
@property = 成员变量 &#43; getter &#43; setter 为什么OC要添加属性，这就要从成员变量说起。成员变量的写法，一般如下：
@interface Person :NSObject {  int _age; //定义成员变量，_下划线开始是苹果的编程规范 } @end 成员变量具有如下的特点：
  只能通过对象来访问
  成员变量离不开类，离开了类就不是成员变量
  成员变量不能在定义的时候同时进行初始化
  成员变量存储在当前对象对应的堆空间中，不会自动释放，只能手动释放
  成员变量前加_是苹果的编程规范
  在OC中.访问符是为getter和setter服务的，而在OC中成员变量默认是没有getter和setter方法，因此在类外无法直接访问。如果需要访问就要自定义的getter和setter方法，然后通过自定义的getter和setter方法来访问成员变量。
因此，苹果为了大众方便，在iOS 5以后使用了属性@property。定义属性时会自动将getter和setter方法实现了，你无须再手动去实现getter和setter方法。当然了，如果你需要在getter和setter方法中想要做点事情，直接重写就好。
顺带地，@property还会生成一个成员变量，变量名就是_属性名。当然这个名字你也可以修改，是在.m文件中的implements中去定义：
@synthesize name = myName; 参考文献 参考文献
属性提供了一些关键字用以控制setter和getter的实现细节, 这些关键字我们称为属性的属性(attribute)，总共有三类:
 读写性readonly,readwrite。其中readonly表示只能读取, 不能写入（系统默认是可读写的）  @property (readonly)NSString *name; 表示只能读取 @property (readwrite)NSString *name；表示可以读写  原子性控制atomic，nonatomic。其中atomic表示属性对应的setter和getter方法在多线程访问下绝对安全。而nonatomic表示不做线程安全处理，只是普通的setter和getter方法。使用atomic, 需要不断地对setter和getter加锁解锁以保证线程安全, 会很占用系统资源, 降低系统性能。  @property(readwrite,nonatomic)NSString *name;表示name 可读写, 无原子性   语义设置assign, retain, copy,strong,weak。这5个属性决定了setter方法中是如何赋值的。
 其中assign实现setter和getter是直接赋值，计数器不会加一，简单的赋值方法，默认赋值方式，适合基本数据类型。相当于说两个对象指向同个内存区，一个地方的变了，其他的也跟着改变。  @property(nonatomic, assign) NSInteger age; -(void)setName:(NSInteger )age {  _age = age; } -(NSInteger )age {  return _age; }   strong : 表示强引用关系，即拥有对象的所有权。
  weak : 表示弱引用，不拥有对象的所有权，当目标对象被销毁之后，属性值会被自动设为nil;
  ​copy(拷贝)：把原来的对象拷贝过来，计数器会加一，比如原来对象的地址为0x01 ,拷贝过来的对象的地址为0x02。用于希望保持一份传入值的拷贝，而不是值自身的情况，即把原来的对象完整的赋值到另外一地方，重新加载一内存区，一个地方变了不影响另一个地方的对象。是内容拷贝。
  ​retain(保留)：这种方式传递的是指针，原有的对象和被赋值的对象的地址是一样的。释放旧的对象,将旧对象的值赋予输入对象,再提高输入对象的索引计数为1。是指针拷贝。
     设计模式 设计模式的两个目标
 可复用性：得到较高的生产效率。 可扩展性：当用户的需求发生变化时，做很少的变化就能够满足用户的需求。  单例模式 单例设计模式：自始至终一个类只有一个对象实例。Cocoa中主要的单例类有：
 UIApplication NSNotificationCenter NSUserDefaults NSFileManager NSBundle  OC中单例模式： //singleton.h @interface Singleton:NSObject &#43; (Singleton *) sharedManager @property (nonatomic,strong) NSString * singletonData; @end  //singleton.m @implemention Singleton @synthesize singletonData = _singletonData; static Singleton * sharedManager = nil &#43; (Singleton *) sharedManager{  static dispatch_once_t once;  dispatch_once(&amp;amp;once,^{  sharedManager = [[self alloc] init];  });  return sharedManager; } 单例设计模式使用场景：
 在整个过程中只需要一个实例保存状态。 无状态对象(只有方法，没有属性）  单例模式时，访问对象时，修改状态的时候要十分小心（它就像一个全局变量）。
UIApplication  sharedApplication方法：它是创建和获得UIApplication实例的实例方法。 openURL:方法：该方法可以打开一些内置的iOS应用，其中包括打开浏览器、打开Google地图、拨打电话、发送短信和发送Email等。  [[UIApplication sharedApplication] openURL: [NSURL URLWithString:@&amp;#34;http://www.baidu.com&amp;#34;]];  委托模式 委托：某个对象指定另一个对象处理某些特定任务（某些方法的实现）的设计模式。例如当没空的时候委托别人帮忙买火车票，乘车人、乘车日期以及出发地和目的地就是协议「规定」（协议通俗的说就是某种规定，如果能执行这种规定就说遵守了某个协议）。
在上面的类图中带空心三角形的实线表示继承；带空心三角形的虚线表示实现接口；带箭头的实线表示单向关联（has）。上面的意思是通用类有一个叫做“委托协议”的成员，它被赋值为（绑定到）为一个委托对象实例，而委托对象实现了委托协议中的相关方法。然后通过这个委托对象实例来做相应的动作（完成委托的事情）。
  委托需要做的工作有： 1.1 定义协议与协议中的方法 1.2 声明委托变量 1.3 设置代理（委托变量绑定到哪个对象实例） 1.4 通过委托变量调用委托方法
  代理需要做的工作有: 2.1 遵循协议（在类的定义时声明遵循相应的协议） 2.2 实现委托方法（实现协议中的方法）
  场景 场景：Boss准备举行一场party，准备邀请Atany来参加party，但是Boss没空写email给Atany，于是他委托Henry与Mary来做这件事情。
在YGViewController.h（根控制器，程序第一个界面，类似于Boss）中首先定义协议，接着声明委托变量（Boss并没有实现inviteToMyParty这个方法，他没有自己去邀请）：
#import &amp;lt;UIKit/UIKit.h&amp;gt; @protocol InviteDelegate -(void)inviteToMyParty:(NSString *)personName;//1.1定义协议与方法 @end  @interface YGViewController : UIViewController @property (assign,nonatomic) id&amp;lt;InviteDelegate&amp;gt; delegate;//1.2声明委托变量 - (IBAction)ClickByMary:(id)sender;//委托给Mary - (IBAction)ClickByHenry:(id)sender;//委托给Henry @end 然后再设置代理，最后通过委托变量调用委托方法：
- (IBAction)ClickByMary:(id)sender {  Mary *mary = [[Mary alloc]init];  self.delegate = mary;//1.3设置代理  [self.delegate inviteToMyParty:@&amp;#34;atany&amp;#34;];//1.4通过委托变量调用委托方法 } - (IBAction)ClickByHenry:(id)sender {  Henry *henry = [[Henry alloc]init];  self.delegate = henry;//1.3设置代理  [self.delegate inviteToMyParty:@&amp;#34;atany&amp;#34;];//1.4通过委托变量调用委托方法 } BOSS可以选择不同的代理（Henry与Mary）来做这件事情（inviteToMyParty），而自己却不用做。以Henry为例，首先遵循协议，然后实现协议中的委托方法：
#import &amp;lt;UIKit/UIKit.h&amp;gt; #import &amp;#34;YGViewController.h&amp;#34;  @interface Henry : UIViewController &amp;lt;InviteDelegate&amp;gt;//2.1遵循协议 @end  -(void)inviteToMyParty:(NSString *)personName{  NSString *hello = [NSString stringWithFormat:@&amp;#34;Hello,%@&amp;#34;,personName];  NSString *str = [NSString stringWithFormat:@&amp;#34;Hey Boy,this is Henry,Come to our party Please!!&amp;#34;];  UIAlertView *alert = [[UIAlertView alloc]initWithTitle:hello message:str delegate:self cancelButtonTitle:@&amp;#34;OK&amp;#34; otherButtonTitles:nil];  [alert show]; }  观察者设计模式 观察模式的定义
有很多观察者正在观察对象的变化，当对象发生时会通知所有的观察者
KVO是观察对象属性的变化 通知机制观察的是对象的变化
NSNotification 可以通过object（NSObject） 和 userInfo（NSDictionary） 来回传数据
投送通知：postNotification
KVO要搞清楚谁是观察者，谁是被观察者
模态视图：关闭不能通过故事板，只能通过代码实现
runtime  runtime是一套存C语言的API，OC代码最终都会被编译器转为运行时代码，通过消息机制决定函数的调用方式。
 消息机制的基本原理 在OC语言中，对象方法调用都是类似[receiver selector]的形式，其本质：让对象在运行时发送消息的过程。
方法调用[receiver selector]分为两个过程：
  编译阶段。[receiver selector]方法被编译器转化，分为两种情况
 不带参数的方法被编译为objc_msgSend(receiver,selector) 带参数的方法被编译为objc_msgSend(receiver,selector,org1,org2,...)    运行阶段：消息接收者receiver寻找对应的selector，也分为两种情况
 接收者能找到对应的selector，直接执行receiver对象的selector方法 接收者找不到对应的selector，消息被转发或者临时向接收者添加这个selector对应的实现内容，否则崩溃。    总而言之，OC调用方法[receiver selector]，编译阶段确定了要向那个接收者发送message消息，但是接收者如何响应决定于运行时的判断。
</content>
    </entry>
    
     <entry>
        <title>swift中的方法</title>
        <url>https://iihui.github.io/post/swift-method/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>iOS</tag>
        </tags>
        <content type="html">  在Swift中方法是关联了特定类型的函数。类，结构体，枚举类型都能定义实例方法，方法封装了给定类型特定的任务和功能。
 实例方法 实例方法是属于特定实例（类实例、结构体实例或者枚举实例）的函数。实例方法只能在类型的具体实例里被调用，不能独立于实例而被调用，也就是说不能直接使用类名直接调用。
class Counter {  var count = 0  func increment() {  count &#43;= 1  }  func increment(by amount: Int) {  count &#43;= amount  }  func reset() {  count = 0  } } 异变方法 在Swift中结构体和枚举是值类型。默认情况下，值类型属性不能被自身的实例方法修改。如果需要改变结构体或者枚举类型的属性，应该将实例方法进行异变。即在实例方法的func关键字前添加mutating关键字：
struct Point {  var x = 0.0, y = 0.0  mutating func moveBy(x deltaX: Double, y deltaY: Double) {  x &#43;= deltaX  y &#43;= deltaY  } } 但是，不能在常量结构体类型里调用异变方法，因为常量代表自身属性不能被改变，即使这些属性是变量属性：
let fixedPoint = Point(x: 3.0, y: 3.0) fixedPoint.moveBy(x: 2.0, y: 3.0) //编译器会报错，因为常量结构体里的数据不能被修改，而moveBy声明是异变的，所以矛盾，编译器会报错。 self属性 每一个类的实例都隐含一个叫做self的属性，它完全和实例本身相等，可以使用self来调用实例的方法或者使用实例的属性。
struct Point {  var x = 0.0, y = 0.0  func isToTheRightOf(x: Double) -&amp;gt; Bool {  return self.x &amp;gt; x //形参的优先级别高于实例属性  } } 枚举的异变方法可以设置隐含的self属性为相同枚举里的不同成员。也就是在枚举类型中其异变的方法中，self也是可以变换的：
enum TriStateSwitch {  case off, low, high  mutating func next() {  switch self {  case .off:  self = .low  case .low:  self = .high  case .high:  self = .off  }  } } 类型方法 类型方法是用来定义类型本身调用的方法，通过在func关键字前加static来实现。类还可以用关键字class来允许子类重写父类的方法实现。
在类方法中，隐含的self指向的是类本身而不是类的实例。同样在类型方法中，有self访问的属性与同名的形参相比，优先级低一些：
struct Point{  static var x = 12  static func test(x:Int)-&amp;gt;Bool{  return self.x &amp;gt; x  } }  </content>
    </entry>
    
     <entry>
        <title>JavaScript 数据类型</title>
        <url>https://iihui.github.io/post/js-data-struct/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>JS</tag>
        </tags>
        <content type="html"> JavaScript不需要进行类型声明，因此它是一种弱类型的语言，这意味着可以在任何阶段改变变量的数据类型。
字符串 字符串是由零个或者多个字符组成，必须包含在引号中，单引号和双引号都可以。
 数值 如果想给一个变量赋一个数值，不必限定它必须是一个整数。JavaScript允许使用带小数点的数值，并且允许任意位的小数。
 数组 字符串、数值、布尔值都被称为标量（如果某个变量称为标量，那么在任何时候它就只能有一个值）。
数组的声明 var beatles = Array(4) //声明长度 var beatles = Array() var beatles = Array(&amp;#34;John&amp;#34;,&amp;#34;Paul&amp;#34;,&amp;#34;George&amp;#34;,&amp;#34;Ringo&amp;#34;} var bratles = [&amp;#34;John&amp;#34;,&amp;#34;Paul&amp;#34;,&amp;#34;George&amp;#34;,&amp;#34;Ringo&amp;#34;] var lennon = [&amp;#34;john&amp;#34;,1992,false] //数组中声明不同类型的元素 填充数组 var lennon = Array() lennon[&amp;#34;name&amp;#34;] = &amp;#34;john&amp;#34; lennon[&amp;#34;year&amp;#34;] = 1940 lennon[&amp;#34;living&amp;#34;] = false  对象 与数组相似，对象也是使用一个名字来表示一组值，对象的每个值都是对象的一个属性。
var lennon = Object() lennon.name = &amp;#34;john&amp;#34; lennon.year = 1980 lennon.living = false  var lennon = {name:&amp;#34;john&amp;#34;,year:1940,living:false} //更简洁的声明方式  运算符 相等操作符==并不是表示严格意义的相等。例如下面的代码中==操作符认为空字符和false的值是相等的，因此返回真。
var a = false var b = &amp;#34;&amp;#34; if ( a == b){  alert(&amp;#34;a 等于 b“) } 如果要进行严格意义的相等判断，则需要使用===，这个全等操作符，不仅比较值而且比较类型。同理，要比较严格不等也要使用！==。
</content>
    </entry>
    
     <entry>
        <title>泼辣修图中的人像工具</title>
        <url>https://iihui.github.io/post/pixel-portrait/</url>
        <categories>
          <category>后期</category>
        </categories>
        <tags>
          <tag>后期</tag><tag>泼辣</tag>
        </tags>
        <content type="html">  在泼辣修图中有22个强大且易用的人像调整工具，涵盖了面部结构、五官大小、肤色亮度等等的调整。当图片中出现一张脸时，泼辣修图会智能的识别脸部并区分其五官，选中相应的区域然后调整对应的参数即可。
 自动调整 点击自动增强，程序可以自动优化五官、结构和肤色，使得照片呈现更好的状态。
 皮肤控制 皮肤控制选项包括平滑，光泽，阴影，高光，色相，跑和度，下面一一说明：
皮肤平滑：提高数值可以实现磨皮效果，让皮肤更加光滑细腻，降低数值可以增加皮肤质感。
皮肤光泽：提高数值可以为面部补光，让面部看起来更加白皙明亮，降低数值可以降低面部的亮度。
皮肤阴影：控制面部较暗区域的亮度，一般而言我们需要降低皮肤阴影的数值，提高皮肤高光的数值，让面部的立体感更加强烈。
皮肤高光：控制面部较亮区域的亮度，一般而言我们需要降低皮肤阴影的数值，提高皮肤高光的数值，让面部的立体感更加强烈。
皮肤色相：改变皮肤的色彩，例如让皮肤由偏红色转变为偏黄色.
皮肤饱和度：控制面部皮肤的色彩鲜艳程度，如果我们感觉面部过于泛红时可以降低该选项；如果感觉面部皮肤没有气色时，可以提高该选项。
 面部控制 面部控制选项包括面部宽度，下巴宽度，前额宽度。其中面部宽度用于调整面部的宽度，下巴高度用于控制下巴的高度，前额宽度用于控制额头的高低：
 眼睛控制 眼睛控制包括眼睛大小、亮度、对比度以及清晰度：
 鼻子调整 鼻子控制包括：鼻子宽度和鼻子长度：
 嘴巴调整 嘴巴控制包括微笑、嘴高度、嘴宽度、亮度以及饱和度：
 牙齿控制 牙齿控制包括牙美白和牙亮度：
 参考资料
</content>
    </entry>
    
     <entry>
        <title>泼辣修图后期术语3</title>
        <url>https://iihui.github.io/post/pixel-term3/</url>
        <categories>
          <category>后期</category>
        </categories>
        <tags>
          <tag>后期</tag>
        </tags>
        <content type="html"> 质感 质感：质感是指物体的材质与质量所带给人的感觉。在泼辣修图中，质感选项下的调整包括清晰度、锐化、降噪色彩、降噪明度。
清晰度 清晰度用来调整画面的清晰程度。提高清晰度数值可以让画面更加清晰，可以用来修复轻微失焦的画面。降低清晰度数值可以画面更加模糊，有时候可以用它来模拟动漫效果、水彩效果等。
 锐化 锐化是补偿图像的轮廓，增强图像的边缘及灰度跳变的部分，使图像变得清晰。它的效果相较于清晰度更加细腻。
 降噪色彩 噪点分为两种：色彩噪点与明度噪点。所谓色彩噪点，就是带有颜色的画面噪点；所谓明度噪点，就是不带有色彩的画面噪点。
下面的左图，可以明显的观察到颜色噪点的存在（为了方便观察，此处的锐化值提高到了&#43;50）。当对中间这张图应用了色彩降噪之后，画面留下的就是明度噪点，可以看到，明度噪点就是类似黑白颗粒一样的存在。最右边这张图是同时使用色彩降噪和明度降噪之后的效果，可以看到画面相较于原图更加纯净。
 去雾 去雾是指消除画面中的雾霾或为画面添加雾霾。提高去雾值，让画面更加通透自然；降低去雾值，为画面加入雾气。
 曲线 曲线分为白色曲线、红色曲线、绿色曲线、蓝色曲线，白色曲线又称为RGB曲线，红色曲线、绿色曲线、蓝色曲线又统称为通道曲线。
曲线的初始形态是一条45度的直线，当调整这条直线的形态时就可以达到调整画面的目的。利用白色曲线可以调整画面的曝光，利用红色曲线、绿色曲线、蓝色曲线可以调整画面的色彩。
 白色曲线 </content>
    </entry>
    
     <entry>
        <title>泼辣修图后期术语2</title>
        <url>https://iihui.github.io/post/pixel-term2/</url>
        <categories>
          <category>后期</category>
        </categories>
        <tags>
          <tag>后期</tag><tag>泼辣</tag>
        </tags>
        <content type="html"> 曝光 曝光：用于调整画面的明亮程度。提高曝光值会让画面变得更加明亮，整体显得干净而又轻盈；降低曝光值会让画面变得更加昏暗，整体显得沉重而又严肃。
 高光、白色色阶、黑色色阶、阴影 可以按照曝光去划分照片的区域，例如把照片划分为最亮的区域、较亮的区域、较暗的区域和最暗的区域，这样我们就可以实现对照片的精细调整。
在泼辣修图中，这4个区域，按照如下关系进行对应：①高光——最亮的区域；②白色色阶——较亮的区域；③黑色色阶——较暗的区域；④阴影——最暗的区域。
高光对应的是画面中最亮的部分，例如天空。降低高光值，可以降低天空的亮度，让天空的细节得到更好的呈现。
白色色阶对应的是画面中比较亮的部分，它的影响范围一般比高光更大。这两个参数调整并不会对画面中较暗的区域，如下图所示调整高光和白色色阶并不会影响阴影和黑色色阶部分：  阴影对应最暗的区域；黑色色阶对应的是画面中比较暗的部分，它影响的范围一般比阴影更大。阴影和黑色色阶两个参数调整并不会对画面中较亮的区域。  色温 当黑体发射的光的颜色与某个光源所发射的光的颜色相同时，这个黑体加热的温度称之为该光源的颜色温度，简称色温。简而言之色温就是指光线的颜色，不同的光源具有不同的色温。
当色温越高的时候，光源发出的颜色就越偏冷，大致是经历一个红——橙红——黄——黄白——白——蓝白的渐变过程。 一天中的色温也是在不停发生变化的，例如日出之前的色温是蓝色，日出之后的色温是橙色，中午的色温是白色，而晚上的色温是黄色等等，引起太阳光颜色变化的原因主要是因为大气层的反射作用，而并不是因为太阳的温度发生了大幅度的改变。
为画面加入黄色可以提高色温值；或画面加入蓝色可以降低色温值。  白平衡 白平衡是指将白色还原为白色的过程。如果我们身处一个黄色光源的环境之中，那么环境中的白色会被渲染成黄色。由于人眼具有智能色偏修正的功能，即使进入这样一个环境，过不了多久我们就能适应这个环境的光源色彩，因此有可能感觉不到白色发生了异常。但是，相机没有智能色偏修正，因此需要借助白平衡的能力来实现纠正色偏的效果。
可以通过为相机设置一个机内色温值来实现白平衡的效果，当机内色温值与外界一致时，相机就能正确的表现白色。例如现在外界色温是4000K，我们将机内色温也设置为4000K时，白色就能被相机还原为白色。
如果相机内设置的色温大于环境中的色温时，相机就会认为外界色温是偏蓝色的，因此需要增加黄色来中和蓝色，以实现还原白色的效果。
如果相机内设置的色温小于环境中的色温时，相机就会认为外界色温是偏黄色的，因此需要增加蓝色来中和黄色，以实现还原白色的效果。
 使用色温值来调节白平衡 不同的色温能够给人不同的心理感受。例如暖色能够给人一种温暖、温馨、和谐的感觉；冷色则能够给人一种平静、阴凉、寒冷的感觉；中性色则能给人一种安宁、舒适、稳定的感觉。
在后期创作的时候，就要学会使用不同的色温去辅助我们表达不同的感情效果。可以利用色温工具实现画面的白平衡，从而得到一个更加中性的色彩取向。
  当画面偏蓝的时候，可以提高色温值，为画面加入暖色（黄色），从而实现白平衡的效果。   当画面偏黄的时候，我们可以降低色温值，为画面加入冷色（蓝色），从而实现白平衡的效果。    色调 色调：为画面加入洋红色（品红色）可以提高色调值；为画面加入绿色可以降低色调值。也就是说，当降低色调工具的值时，可以为画面加入绿色，当我们提高色调工具的值时，可以为画面加入洋红色。 如果画面偏洋红色，就可以降低色调为画面加入绿色，从而削弱洋红色，以呈现出更加中性的色调：  色温和色调工具通常结合起来帮助我们调整画面的白平衡以及渲染画面的色彩。例如这一张照片：
为了降低画面的色温值，为画面加入蓝色；提高色调值，为画面加入洋红色：  色调分离 利用色调分离工具可以为画面的阴影或高光加入指定的色彩。当为高光加入某种色彩时，它主要会影响画面中亮度较高的区域；当我们为阴影加入某种色彩时，它主要会影响画面中亮度较低的区域。
可以看到，当为高光加入黄色的时候，天空（比较亮的区域）受到了较为明显的影响，但是地面（比较暗的区域）受到的影响则不大；
于此同时，当为阴影加入蓝色的时候，地面（比较暗的区域）受到的影响比较明显，但是天空（比较亮的区域）受到的影响则不大。
 暗角 是指因为镜头存在光学缺陷等原因导致相机进光不均匀，因此出现照片四周亮度较低的现象。
当为画面增添暗角时，可以让画面的视觉焦点更加集中；在后期中，我们不仅仅会为照片添加暗角，有时候也会为照片添加亮角，即照片四周亮度高于中间，这可以营造一种明亮、纯洁的画面氛围。在泼辣修图中，质感选项下的调整包括暗角程度、暗角羽化、暗角高光、暗角大小、暗角圆度。
 暗角程度 用于控制暗角的浓烈程度。数值为正值时，为画面加入白色边角；数值为负值时，为画面加入黑色边角；绝对值越大，效果越强烈。  暗角羽化 暗角羽化用于控制暗角的羽化程度（柔和程度），数值越大边缘越柔和。
 暗角高光 暗角高光：数值越大，画面中的高光部分受到暗角影响的程度就越小（营造不规则的暗角风格）。
 暗角大小 暗角大小：控制暗角的影响范围，数值越小不受暗角影响的区域就越小（当然受影响的区域就越大）。
 暗角圆度 暗角圆度：控制暗角的圆形程度。数值越大暗角越呈现出圆形，数值越小暗角越呈现出方形。
 </content>
    </entry>
    
     <entry>
        <title>泼辣修图后期术语1</title>
        <url>https://iihui.github.io/post/pixel-term1/</url>
        <categories>
          <category>后期</category>
        </categories>
        <tags>
          <tag>后期</tag><tag>泼辣</tag>
        </tags>
        <content type="html"> 对比度 维基百科对比度的解释为：画面黑与白的比值，即从黑到白的渐变层次。比值越大，从黑到白的渐变层次越多，从而色彩表现越丰富。对比度对于视觉的影响非常关键，一般说来对比度越大，图像越清晰越醒目，色彩也越鲜明亮丽；对比度小，则让整个画面灰蒙蒙的。
提高对比度可以让画面更加通透，但是会损失一些细节；降低对比度会让画面获得相对更加丰富的细节，但是会让画面灰蒙蒙的。
 饱和度 饱和度是指色彩的纯度，一种颜色的饱和度越高，它就越鲜艳；反之，一种颜色的饱和度越低，它就越接近于灰色。
一张照片的饱和度越高，越能引起人的注意，但是过高的饱和度有时候会让人产生反感的情绪：
一张照片的饱和度越低，画面就越平和，就越能给人安静、舒适的视觉感受，但是过低的饱和度有时候会让画面产生不通透感。
提高饱和度的数值时，画面会变得更加鲜艳，但是如果数值提高得过高，有时候会让画面出现色彩溢出等不正常现象。
降低饱和度的数值时，画面会变得更加偏灰，如果将数值降至最低，画面会变成黑白照片。
 自然饱和度 自然饱和度工具相当于智能饱和度工具，它可以控制画面的饱和度程度，不会让画面过于饱和。
相比于饱和度，自然饱和度会保护饱和度高的地方，比如说提升自然饱和度的时候，本来高饱和的区域提升幅度较弱，本来低饱和的区域提升幅度较强，而饱和度则是同等幅度提升所有颜色的饱和度。
因此，在进行后期的调整的时候，特别是调整风光类照片的时候，可以更多的采用自然饱和度工具去调整画面的色彩，这样不容易出现过度饱和的问题。
 增强画面表现力 有时候感觉画面有些沉闷，这时可以尝试提高画面的饱和度，让画面的色彩更加鲜艳，从而让画面拥有更强的色彩表现力。
 削弱色彩攻击性 画面饱和度过高会让色彩的攻击性增强，但是过高的饱和度容易让画面对人产生过度的刺激，有时候过高的饱和度还会让画面显得沉重，或者画面显得比较脏。这时就可以通过降低画面的饱和度削弱色彩的攻击性。
 变黑白照片 将画面的饱和度降到最低时，画面就可以变成黑白照片，如下图所示：
 调整局部色彩 可以利用HSL、笔刷等工具分别调整不同颜色或不同区域的饱和度，让画面形成高饱和和低饱和并存的局部色彩效果，更好的凸显画面主体、增强画面的视觉表现力。
利用HSL调整青色的饱和度，将其值调到-100可以得到下图：
 色相 色相（Hue）是指色彩的相貌名称，例如红色、橙色、紫色等。它是颜色的首要特征，是区别各种不同色彩最准确的标准。除了黑白灰以外的其他颜色都有色相属性。
当使用HSL工具去调整色相时，可以将一种颜色转变为另一种颜色。例如选中蓝色，调整蓝色的色相时：
画面中的树叶和向日葵并没有受到影响，这是因为树叶和向日葵的颜色并不是蓝色，因此我们在调整蓝色色相的时候，其他颜色并不会受到影响。
 明度 即是指一种颜色的明亮程度，明度越高，颜色越明亮（白一点），明度越小，颜色越深沉（暗一点）。同一种颜色有明暗之分，例如浅蓝色和深蓝色，不同颜色之间也有明暗之分，例如黄色的明度就相对比较高，紫色的明度就相对比较低。
可以看到在HSL工具中，当调整蓝色明度的时候，画面中蓝色（天空）发生了变化，其颜色更加明亮或深沉。但是画面中的绿色（树叶）、黄色（向日葵）则不受影响。
 亮度 亮度用于调整画面的灰色，相较于“曝光”，它的调整范围主要集中于中间调，可以用于修复画面的细节。提高亮度的效果近似于提高曝光&#43;降低对比度；降低亮度的效果近似于降低曝光&#43;提高对比度。
HSL HSL工具可以帮助我们来调整一种颜色的色相、饱和度、明度。例如当选中蓝色，然后调整蓝色的色相。可以看到，天空的颜色发生了改变，左边、中间和右边的天空颜色都明显不同，这是因为我们改变了蓝色的色相，而天空是蓝色的，所以受到了影响。
画面中的树叶和向日葵并没有受到影响，这是因为树叶和向日葵的颜色并不是蓝色，因此我们在调整蓝色色相的时候，其他颜色并不会受到影响。
 同理，选中蓝色，然后调整蓝色的饱和度。提高饱和度之后，天空的色彩变得更加鲜艳了；降低饱和度之后，天空的色彩更加偏向于灰色了：
与此同时，画面中的树叶和向日葵并没有受到影响，因为我们调整的是蓝色的饱和度，但是树叶和向日葵的颜色并不是蓝色，所以说饱和度并不会随之改变。
 利用HSL分区调整 分区调整，就是指把照片按照一定的标准划分为不同的区域，然后对这些区域分别调整。而HSL工具就可以把画面按照色彩进行划分，然后针对不同的色彩进行调整。在HSL工具里面，可以选择洋红色、紫色、蓝色、青色、红色、橙色、黄色、绿色这8种颜色进行分别调整。
 提高饱和度让天空更鲜艳 在调整天空颜色时，一般选择蓝色和青色，这是最为常见的天空颜色。在下图中，如果选择红色，然后调整红色的饱和度，天空将不会受到影响；而当选中蓝色，然后提高蓝色的饱和度时，则可以看到天空的颜色明显变得更加鲜艳了。
 利用明度调整天空的亮度 例如选中蓝色，当降低蓝色的明度时，可以看到第二张照片相对于第一张照片天空的亮度降低了；当提高蓝色的明度时，可以看到第三张照片中的天空变得更加明亮了。
因此，可以利用较高明度的天空去表达一种轻盈、通透的场景氛围，可以利用较低明度的天空去表达一种深沉、压抑的场景氛围。
 利用色相渲染天空色彩 不同色相对于人的心理存在不同的影响，我们可以利用色相的这一特性去渲染天空的色彩，使画面呈现出不同的场景氛围。
例如选中蓝色，然后提高蓝色的色相值，这时候天空一般会呈现出紫色，画面会给人一种晚霞的场景感；当降低蓝色的色相值，这时候天空一般会呈现出青色，能够给人一种微妙的离奇感，因为它不同于我们常见的天空色彩。
 利用HSL调整草地/树木 在下图中，草地显得有些枯黄，如果想要将它们变成蓝天绿草的效果，该如何处理呢？ 画面中的这些草地是黄色的，因此可以选中黄色，然后调整黄色的色相，使草地的颜色由黄色转换为绿色：
提高黄色的色相，使其有黄色转换为绿色，然后提高黄色的饱和度，使草地的颜色更加鲜艳，然后降低黄色的明度，使草地的颜色更加深沉。
 经过这样的调整之后，可以发现画面中还存在一些枯草，这些枯草对应的色彩是橙色，因此可以选中橙色，然后调整橙色的色相，将橙色转换为绿色：
提高橙色的色相，使画面中草地的颜色由橙色转变为绿色；然后提高橙色的饱和度，使得草地的颜色更加鲜艳；然后降低橙色的明度，让草地存在高明度与低明度的对比，从而让画面更加富有层次感。
 然后可以调整一下画面的天空，利用前面学习的调整天空的方法，这张照片中天空的色彩更加倾向于青色，因此我们选中青色，然后调整青色：
提高青色的饱和度，使得天空的颜色更加鲜艳，我们降低青色的明度，使得天空的亮度变低，从而呈现出更加丰富的细节。
 经过这样几步简单的调整，这张照片就呈现出蓝天绿草的景观了。利用HSL工具调整草地/树木的时候，我们的思维过程是这样的：
  确定最终色
  选择目标色
  色彩输出
  使用HSL工具之前，首先要思考的是我们最终想要呈现的效果是怎样的。例如，在上图中，我们最终想要的效果是让天空更蓝、草地变绿，这就是需要的最终色。
 例如看到下面这张枫叶时，可能想到调整画面中的黄色和橙色，因为这两个颜色比较接近，其他颜色都离画面中枫叶的颜色太远了。 但是当调整黄色的时候，发现画面基本上没有变化时，就可以确定调整橙色了。按下图右侧的数值，依次调整色相，饱和度，明度:  </content>
    </entry>
    
     <entry>
        <title>使用pixelmator pro修改证件照背景颜色</title>
        <url>https://iihui.github.io/post/pixel-background/</url>
        <categories>
          <category>后期</category>
        </categories>
        <tags>
          <tag>后期</tag><tag>mator</tag>
        </tags>
        <content type="html">  现有一张白底的证件照需要修改为蓝底的。使用pixelmator pro这款软件，自己摸索出了2种方法来实现这个需求。
 第一种方法 第一种方法的思路，首先将头像抠出来，然后新建一个同样大小的文件，再将抠出来图层粘贴到新建的图层，最后改变背景的颜色。可归纳为抠图$\to$新建$\to$换背景。
抠头像 首先使用pixelmator pro将原照片打开，然后使用快速选择中的快速选区，如下图所示：
然后移动圆圈，左键点击选中那只兔子,如下图所示黄色部分：
最后释放鼠标左键，表示选中对应区域，如下图虚线所示
 新建文件 选中兔子之后，将按住command&#43;c复制，然后新建一个新的文件，如下图所示，其中红色框中表示可以调整大小：
然后将之前抠出来的那只兔子，粘贴到新的文件中，就形成了如下所示的两个图层：
 填充背景颜色 然后选中上图的白色背景图层，在右边的工具栏中选中样式，如下图所示：
然后选择填充，填充的时候选择颜色，不要选渐变。然后选择喜欢的颜色，至此就完成了背景的更改：
 第二种方法 第二种方法的思路是先选中背景颜色的区域，然后对这个区域用另外一种颜色进行填充。可归纳为选择$\to$替换。
按颜色选择背景 首先在右侧的工具栏中选择快速选择，然后选择选择颜色，如下所示：
然后选择背景颜色区域对应的颜色，如下图虚线所示：
 填充背景颜色 选择好颜色区域之后，然后在右侧的工具栏中选择颜色填充，如下图所示：
然后选择相应的颜色在我们选定的区域内进行填充，如下图所示，但是在填充的时候要选择平滑边缘，至此背景色就已经改好了。
 </content>
    </entry>
    
     <entry>
        <title>Go 实现各种内排序算法</title>
        <url>https://iihui.github.io/post/go-sort/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html"> 内排序是指在排序过程中，数据都能够放在内存中处理，排序时不涉及数据的内、外交换。
插入类排序 直接插入排序 func InsertSort(data []int) { 	var i, j, cur int 	length := len(data) //获得切片对应数组的长度  	for i = 1; i &amp;lt; length; i&#43;&#43; { 	cur = data[i] 	for j = i - 1; j &amp;gt;= 0; j-- { 	if data[j] &amp;gt; cur { 	data[j&#43;1] = data[j] 	} else { 	break 	} 	} 	data[j&#43;1] = cur 	} }  二分直接插入排序 func BinInsertSort(data []int) { 	var cur, start, mid, end int 	length := len(data) 	for i := 1; i &amp;lt; length; i&#43;&#43; { 	cur = data[i] 	start = 0 	end = i - 1 	for start &amp;lt;= end { 	mid = start &#43; (end-start)/2 	if data[mid] == cur { 	end = mid 	break 	} else if data[mid] &amp;gt; cur { 	end = mid - 1 	} else { 	start = mid &#43; 1 	} 	}  	for j := i - 1; j &amp;gt;= end&#43;1; j-- { 	data[j&#43;1] = data[j] 	} 	data[end&#43;1] = cur 	} }  shell排序 func shellCore(data [] int, step int) { 	var i, j, cur int 	length := len(data) 	for i = step; i &amp;lt; length; i&#43;&#43; { 	cur = data[i] 	for j = i - step; j &amp;gt;= 0; j -= step { 	if data[j] &amp;gt; cur { 	data[j&#43;step] = data[j] 	} else { 	break 	} 	} 	data[j&#43;step] = cur 	} }  func ShellSort(data [] int) { 	step := len(data) / 2 	for step &amp;gt; 0 { 	shellCore(data, step) 	step /= 2 	} }  交换类排序 冒泡排序 func BubbleSortBig(data []int) { //大数沉底 	length := len(data)  	for i := 1; i &amp;lt; length; i&#43;&#43; { 	flag := false //标志本趟是否有交换 	for j := 0; j &amp;lt; length-i; j&#43;&#43; { 	if data[j] &amp;gt; data[j&#43;1] { 	data[j], data[j&#43;1] = data[j&#43;1], data[j] //并行赋值 	flag = true 	} 	}  	if !flag { 	break 	} 	} } func BubbleSortSmall(data [] int) { //小数上浮 	length := len(data) 	for i := 1; i &amp;lt; length; i&#43;&#43; { 	flag := false 	for j := length - 1; j &amp;gt;= i; j-- { 	if data[j] &amp;lt; data[j-1] { 	data[j], data[j-1] = data[j-1], data[j] //并行赋值 	flag = true 	} 	} 	if !flag { 	break 	} 	} }  快速排序 func partition(data [] int, start int, end int) int { 	small := start - 1 	index := rand.Intn(end-start) &#43; start //找到随机的基准 	data[index], data[end] = data[end], data[index] //并行赋值  	for i := start; i &amp;lt; end; i&#43;&#43; { 	if data[i] &amp;lt; data[end] { 	small&#43;&#43; 	if small &amp;lt; i { 	data[small], data[i] = data[i], data[small] //并行赋值 	} 	} 	} 	small&#43;&#43; 	data[small], data[end] = data[end], data[small] //并行赋值 	return small }  func QuickSort(data []int, start int, end int) { 	if start &amp;lt; end { 	pivot := partition(data, start, end)  	if pivot &amp;gt; start { 	QuickSort(data, start, pivot-1) 	}  	if end &amp;gt; pivot { 	QuickSort(data, pivot&#43;1, end) 	} 	} }  选择类排序 简单选择排序 func SelectSort(data []int) { 	length := len(data)  	for i := 0; i &amp;lt; length-1; i&#43;&#43; { 	index := i 	for j := i &#43; 1; j &amp;lt; length; j&#43;&#43; { 	if data[j] &amp;lt; data[index] { 	index = j 	} 	} 	if index != i { 	data[i], data[index] = data[index], data[i] 	} 	} }  堆排序 func adjustHeap(data []int, start int, end int) { 	for parent, child := start, 2*start&#43;1; child &amp;lt;= end; child = 2*parent &#43; 1 { 	if child &amp;lt; end &amp;amp;&amp;amp; data[child] &amp;lt; data[child&#43;1] { //注意控制条件 	child&#43;&#43; 	}  	if data[parent] &amp;lt; data[child] { 	data[parent], data[child] = data[child], data[parent] 	parent = child 	} else { 	break 	} 	} }  func HeapSort(data []int) { 	length := len(data) 	for i := (length - 2) / 2; i &amp;gt;= 0; i-- { 	adjustHeap(data, i, length-1) 	}  	for i := length - 1; i &amp;gt; 0; i-- { 	data[i], data[0] = data[0], data[i] 	adjustHeap(data, 0, i-1) 	} }  归并排序 func mergeCore(data, assist []int, start, end int) { 	if start == end { 	assist[start] = data[start] 	return 	}  	mid := start &#43; (end-start)/2 	mergeCore(data, assist, start, mid) 	mergeCore(data, assist, mid&#43;1, end)  	i, j, k := start, mid&#43;1, start  	for i &amp;lt;= mid &amp;amp;&amp;amp; j &amp;lt;= end { 	if data[i] &amp;lt; data[j] { 	assist[k] = data[i] 	k&#43;&#43; 	i&#43;&#43; 	} else { 	assist[k] = data[j] 	k&#43;&#43; //Go中后置&#43;&#43;不能作为表达式，只能是语句 	j&#43;&#43; 	} 	}  	for i &amp;lt;= mid { 	assist[k] = data[i] 	k&#43;&#43; //Go中后置&#43;&#43;不能作为表达式，只能是语句 	i&#43;&#43; 	} 	for j &amp;lt;= end { 	assist[k] = data[j] 	k&#43;&#43; //Go中后置&#43;&#43;不能作为表达式，只能是语句 	j&#43;&#43; 	}  	for i := start; i &amp;lt;= end; i&#43;&#43; { 	data[i] = assist[i] 	} }  func MergeSort(data [] int) { 	assist := make([]int, len(data)) //需要重新生成一个切片 	mergeCore(data, assist, 0, len(data)-1) }  计数排序 func CountSort(data []int, radix int) { 	length := len(data) 	count := make([]int, radix) 	assist := make([]int, length)  	for i := 0; i &amp;lt; length; i&#43;&#43; { 	count[data[i]]&#43;&#43; 	}  	for i := 1; i &amp;lt; radix; i&#43;&#43; { 	count[i] &#43;= count[i-1] 	}  	for i := length - 1; i &amp;gt;= 0; i-- { 	count[data[i]]-- //下标是从0开始的，因此先减1 	assist[count[data[i]]] = data[i] 	}  	for i := 0; i &amp;lt; length; i&#43;&#43; { 	data[i] = assist[i] 	} }  基数排序 func findMax(data []int) int { 	length, max := len(data), data[0] 	for i := 1; i &amp;lt; length; i&#43;&#43; { 	if data[i] &amp;gt; max { 	max = data[i] 	} 	} 	return max }  func BucketSort(data []int, radix, exp int) { 	length, count, assist := len(data), make([]int, radix), make([]int, len(data)) 	for i := 0; i &amp;lt; length; i&#43;&#43; { 	count[(data[i]/exp)%radix]&#43;&#43; 	}  	for i := 1; i &amp;lt; radix; i&#43;&#43; { 	count[i] &#43;= count[i-1] 	}  	for i := length - 1; i &amp;gt;= 0; i-- { 	count[(data[i]/exp)%radix]-- 	assist[count[(data[i]/exp)%radix]] = data[i] 	}  	for i := 0; i &amp;lt; length; i&#43;&#43; { 	data[i] = assist[i] 	}  }  func RadixSort(data []int, radix int) { 	max := findMax(data) 	for exp := 1; exp &amp;lt;= max; exp *= radix { 	BucketSort(data, radix, exp) 	} }  </content>
    </entry>
    
     <entry>
        <title>VirtualBox 虚拟机扩容</title>
        <url>https://iihui.github.io/post/tool-vb-resize/</url>
        <categories>
          <category>QA</category>
        </categories>
        <tags>
          <tag>QA</tag>
        </tags>
        <content type="html">  今天在使用VirtualBox安装win10虚拟机的时候，开始创建的虚拟磁盘空间有点小，安装了许多软件之后磁盘不够用了，需要进行扩容，接下来分三步来解决该问题。
 加入到环境变量 首先将VirtualBox的安装目录添加到环境变量path中。首先将右键任务栏上的Windows图标：
 命令行下扩容 首先关闭虚拟机，然后以管理员身份打开命令行，输入VBoxManage list hdds查看已经安装的虚拟机的情况,找到对应的虚拟机的UUID：
然后以VBoxmanage modifyhd UUID --resize 重置后大小(以MB为单位)，其中--resize后面是重新分配空间的大小，单位为MB，上图是将24GB的空间重置为30GB
 扩展C盘 在虚拟机中首先打开磁盘管理，可以看到多了2GB的未分配空间，然后鼠标右键C盘，选择扩展卷： 然后点击下一步，设置将要扩展到C盘的容量： 最后可以看到C盘的容量如预期的那样变大了： 需要注意的是未分配的空间需要在C盘的紧邻的右侧才能按照如上所述的方式直接进行扩展。
 </content>
    </entry>
    
     <entry>
        <title>C&#43;&#43; 常见知识点</title>
        <url>https://iihui.github.io/post/cpp-base/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>C&#43;&#43;</tag>
        </tags>
        <content type="html"> static的作用   对普通函数和全局变量而言static具有隐藏作用：将其修饰的全局变量和函数的作用域限定在本文件中。不加static修饰的函数和全局变量具有全局可见性。
  普通局部变量而言
  未初始化的static普通局部变量，编译器会将其初始化为0，因为BSS段(未初始化数据段）中所有的字节都默认为0x00。
  使用static修饰的普通局部变量的生存期为整个源程序，即初始化一次便具有记忆性。但是，作用域只在定义该变量的函数中。
void testLocalStaticVar(){  static int x = 4;  x&#43;&#43;;  std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; }  int main(int argc, char **argv) {  for (int i = 0; i &amp;lt; 3; &#43;&#43;i) {  testLocalStaticVar(); }   return 0; } // 5,6,7     成员变量：
  属于类的，只有一份，每个对象共享，可以使用类名直接调用。
  除了基本整型的const static整型可以在类的定义体中初始化，其他的必须在类外初始化。
  sizeof计算的时候不会计算静态数据成员，因为它不放在栈区，放在全局（静态）存储区。
    成员函数：
  不与任何对象实例关联，所以没有this指针，因此不能访问非静态成员变量和成员函数。
  static成员函数不能声明为const。毕竟将函数声明为const就承诺不会修改该函数所属对象，而static成员函数不属于任何对象实例。
  因为没有this指针的开销，所以静态成员函数与类的非静态成员函数相比速度上有少许增长。
     const的作用 对于普通变量而言const修饰符的目的为了替代宏定义，与宏定义对比，总共有5点区别：
  const常量有类型，编译器对其进行类型安全检查；而宏定义没有类型，编译器只对宏定义进行字符替换。
  #define是一个编译时概念，在预处理的时候展开，进行直接替换，存储在代码段，不分配内存，生命周期止于编译时期；而const常量存在于数据段，分配内存，属于运行时的概念。
  宏定义可以使用#undef来使之前的宏定义失效；const常量定义后将在定义域内永久有效。
  使用const常量可能比使用#define产生更小的目标代码（例如代码中使用100次同一个宏定义）。
  常量折叠（编译期间简化常量表达式&amp;ndash;对常量表达式求值,并将求得的值替换表达式，放入到常量表中)。
   普通变量与const修饰符需注意的3点：
  声明const变量时必须进行初始化
  const对象的动态数组：必须提供数组的初始化
  const全局变量：在全局作用域中声明的const变量是定义该对象的文件的局部变量，此变量只存在于那个文件中，不能被其他文件所访问。
   指针变量和const修饰符：
  const指针：一旦初始化便不能再指向别的对象，但是可以通过解引用来改变所绑定对象的值。
  指向const对象的指针：不能通过解引用来改变所指的对象的值，但是可以更改所指向的对象，即解除绑定，重新再绑定。
  指向const对象的const指针：一旦初始化便不能再指向别的对象，也不能通过解引用来改变所指的对象的值。
   函数与const修饰符：
  函数的返回值和const修饰符：
 如果返回值是值类型(非指针、引用类型），对于内部数据类型来说，返回值是否是常量并没有关系。而对类类型如果返回值为某个对象的const或某个对象的引用const，则返回值具有const属性，只能访问返回值的公有(可能也可以保护成员）数据成员和const成员函数，并且不允许进行赋值操作。     如果返回值是指针类型，函数不能返回局部变量的指针，因为函数调用之后栈被清理，只能返回指向堆区的分配的存储空间的指针，或者指向静态存储区的指针，因为在函数返回后它们依然有效。   函数的参数和const修饰符：
  如果是传值：对函数调用者的约束不太大，可以传入一个const变量也可以传入一个普通变量，只能说明在函数中不会改变其值。
  如果是传指针：对于指向非const变量的指针参数，只能传入一个指向非const变量的指针，不能传入一个const指针，因为指明不能通过解引用来改变值。因此，若是传地址，则无论什么时候传递一个地址给函数，应该尽可能用const修饰它（除非此实参在函数内需要修改），如果不这么做，就使得指向const的指针不能做实参。
     函数参数为const引用时可以接收临时对象。   成员变量和const修饰符：
  对于类来说const变量是可变的，但是对于对象实例来说是不可变的。
  必须在构造函数的成初始化列表中初始化。
   成员函数和const修饰符：
  this指针类型由obj * const 变为 const obj * const
  const对象实例、指向const对象的指针、指向const对象的引都只能调用const成员函数。const实施于成员函数的目的，确保该成员函数可作用于const对象实例。如果不存在const成员函数，则const对象实例无法调用任何成员函数。
  对于非const对象而言可以调用const成员函数和非const成员函数。
   C&#43;&#43;构造函数 构造函数的特点 构造函数是一种特殊的成员函数， 它具有如下特点：
  名字与类名相同。
  没有返回值。
  在对象创建时自动调用，但是不能被显式调用。
   构造函数的作用   给创建的对象建立一个标识符;
  为对象数据成员开辟内存空间;
  完成对象数据成员的初始化。
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-02 上午8.27.52.png)
   构造函数的分类 构造函数可以分为普通的构造函数和拷贝(复制)构造函数：
  普通的构造函数
  拷贝构造函数: 对于一个构造函数的第一个参数为如下的几种，而且其他参数都有默认值，称为拷贝构造函数：
 A &amp;amp; const A &amp;amp; volatile A &amp;amp; 其中volatile（不稳定的）编译器访问该变量的代码不再进行优化 const volatile A &amp;amp;     防止默认拷贝发生：声明一个私有的拷贝构造函数
  因此一个类其实可以有多个拷贝构造函数，拷贝构造函数又分为：
  浅拷贝：只对对象中的数据成员进行简单的赋值。
  深拷贝：对于对象中动态成员重新分配空间。
   malloc/free和new/delete的区别   malloc/free是标准库函数，而new/delete是C&#43;&#43;运算符。
  new自动计算需要分配的空间，而malloc需要手工计算字节数。
  new是类型安全的，因为new中内置了sizeof, 具有类型转换和类型安全检查功能，而malloc不是类型安全的。
int * p = new float[2]; //编译时指出错误 int *p = (int*)malloc(2*sizeof(double)); //编译时无法指出错误   new首先调用operator new标准库函数，分配足够大的原始的未类型化的空间。接下来调用相关对象的构造函数，以初始化对象。最后返回新分配并构造的对象的指针。而malloc不能调用构造函数；delete将调用该实例的析构函数，然后调用operator delete标准库函数以施放该实例占用的空间，free不能调用析构函数。 ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-02 上午8.27.52.png)
  malloc/free需要头文件支持，而new/delete不需要。
  new操作自由存储区(free store)上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。
  自由存储区是C&#43;&#43;基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。
  堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。
  那么自由存储区是否能够是堆（问题等价于new是否能在堆上动态分配内存），这取决于operator new的实现细节。自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。
  特别地，new甚至可以不为对象分配内存。定位new的功能可以办到这一点： ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-02 上午8.26.28.png)
    new内存分配失败时会抛出bad_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL。
  是否可以被重载 ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-02 上午8.29.22.png)
  new与malloc是否可以相互调用：operator new /operator delete的实现可以基于malloc，而malloc的实现不可以去调用new。
  能够直观地重新分配内存：使用malloc分配的内存后，如果在使用过程中发现内存不足，可以使用realloc函数进行内存重新分配实现内存的扩充。realloc先判断当前的指针所指内存是否有足够的连续空间，如果有，原地扩大可分配的内存地址，并且返回原来的地址指针。如果空间不够，先按照新指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存区域。
  内存分配不足的处理：在operator new抛出异常以反映一个未获得满足的需求之前，它先调用一个用户指定的错误处理函数，这就是new-handler。 ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-02 上午8.32.56.png) ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-02 上午8.30.59.png)
   堆和栈的区别 堆和栈的区别，总共分为6点：   C&#43;&#43;空类默认生成的成员函数   构造函数
  拷贝构造函数
  赋值操作符
  析构函数
  取址运算符
  取址运算符const版本
   delete和delete[]的区别   针对基本数据类型：使用new分配后的不管是数组还是非数组形式内存空间用两种方式均可，原因是：分配简单类型内存时，内存大小已经确定，系统可以记忆并且进行管理，在析构时，系统并不会调用析构函数。
  针对类类型：
  delete ptr;代表用来释放内存，且只用来释放ptr指向的内存。
  delete[] ptr; 用来释放ptr指向的内存，还逐一调用数组中每个对象的destructor。 ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-01 下午2.51.46.png)
  delete a;仅释放了a指针指向的内存空间 , 也就是只调用了 a[0]对象的析构函数， 剩下的从a[1]到a[9]这9个用户自行分配的m_cBuffer对应内存空间将不能释放从而造成内存泄漏。
  delete [] a;释放了a指针指向的全部内存空间，也就是调用a[0]到a[9]对象的析构函数释放分配的内存空间。
     虚函数表 ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-01 下午11.09.32.png)
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-01 下午11.10.04.png)
 一般继承 ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-01 下午11.10.31.png)
多重继承-无虚函数覆盖 多重继承时，有几个基类就有几个vptr
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-01 下午11.11.02.png)
这样做就是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数。
 多重继承-有虚函数覆盖 ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-01 下午11.11.54.png)
 哪些函数不能为虚函数   普通函数 ： 只能重载不能被重写,即不能被继承
  静态成员函数: 不属于任何对象实例，因而没有动态绑定的
  构造函数
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-01 下午11.07.52.png) 按照 动态绑定原理，此时B的构造函数会覆盖掉A的构造函数
  友元函数： C&#43;&#43;不支持友元函数的继承
  内联函数：
  赋值操作符重载函数
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-01 下午11.08.16.png)
   C&#43;&#43;对象布局   单一的一般继承   多重继承   重复继承   菱形继承 ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-01 下午11.06.45.png)    内存溢出 内存溢出(out of memory）：是指程序在申请内存时，没有足够的内存空间供其使用。导致不够用的原因很多,泄漏只是其中一种。通常在运行大型软件或游戏时，软件或游戏所需要的内存远远超出了你主机内安装的内存所承受大小，就叫内存溢出。
内存溢出的几种情况：
  比如系统只有存放integer的空间，但你却申请了存放long，那就是内存溢出。
  比方定义了20个字节大小的内存空间，却写入了21个字节的数据。通俗的说，就是内存不够，没办法支持当前程序。（当发生内存溢出时，程序将无法进行，强制终止。）
   内存泄漏 内存泄漏是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。
内存泄漏的分类：
  常发性内存泄漏。发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。
  偶发性内存泄漏。发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。
  一次性内存泄漏。发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。比如，在类的构造函数中分配内存，在析构函数中却没有释放该内存，所以内存泄漏只会发生一次。
  隐式内存泄漏。程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。 但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。
   C&#43;&#43;中哪些操作符是不能重载的   .  （成员访问运算符)
  .* (成员指针访问运算符）
  :: （域运算符）
  sizeof
  ?: (条件运算符）
  typeid 域运算符和sizeof运算符的运算对象是类型而不是变量或者一般的表达式，不具备重载的特征
   C&#43;&#43;强制类型转换 static_cast   static_cast也可以用在于基类与派生类指针或引用类型之间的转换。然而它不做运行时的检查，不如dynamic_cast安全。static_cast仅仅是依靠类型转换语句中提供的信息来进行转换，而dynamic_cast则会遍历整个类继承体系进行类型检查,因此dynamic_cast在执行效率上比static_cast要差一些。
  编译器隐式执行的任何类型转换都可以由static_cast来完成，比如int与float、double与char、enum与int之间的转换等。
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-02 上午9.45.33.png)
   const_cast  将转换掉表达式的const性质。 ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-02 上午9.39.34.png)  那既然const变量的值是肯定不会发生变化的，还需要这个const_cast类型转化有何用？这就引出了const_cast的最常用用法：
如果 有一个函数，它的形参是non-const类型变量，而且函数不会对实参的值进行改动，这时我们可以使用类型为const的变量来调用函数，此时const_cast就派上用场了。
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-05-02 上午9.41.33.png)
const_cast绝对不是为了改变const变量的值而设计的！在函数参数的传递上const_cast的作用才显现出来。
 只有使用const_cast才能将const性质性质转化掉。试图使用其他三种形式的强制转换都会导致编译时的错误。（添加const还可以用其他转换符，如static_const）
  除了添加const或删除const特性，使用const_cast符来执行其他任何类型的转换都会引起编译错误。
   dynamic_cast   类型必须为类的指针，引用、void*
  需要检查运行时类型信息，而这个信息存储在虚函数表中，所以只有定义了虚函数的类才可以使用，否则会出现编译错误
  如果绑定到引用或指针对象的类型不是目标类型，则dynamci_cast失败，指针会返回0，引用会抛出bad_cast异常。
   reinterpret_cast 仅仅重新解释类型，但没有进行二进制的转换:
  转换的类型必须是一个指针、引用、算术类型、函数指针或者成员指针
  在比特位级别上进行转换。它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值）
  最普通的用途就是在函数指针类型之间进行转换
   C&#43;&#43; 中的引用   引用是变量的别名，定义引用的时候必须先初始化
  不能定义引用数组
  不能定义引用的引用
  引用可以减少构造开销
  当函数返回引用类型时，没有复制返回值，返回的是对象本身，所以不要返回局部对象的引用
  函数参数为const引用时可以接收临时对象
   </content>
    </entry>
    
     <entry>
        <title>线性表</title>
        <url>https://iihui.github.io/post/arith-linear-list/</url>
        <categories>
          <category>算法</category>
        </categories>
        <tags>
          <tag>算法</tag>
        </tags>
        <content type="html">  线性表是由 $n$个具有相同特性的元素$(n \ge 0)$ 组成的一个有限序列，是一种逻辑结构。它的特征在于：①表中所有数据元素类型相同。②表由有限个数据元素构成。③表中数据元素是位置相关的（这一点表明线性表不同于集合)，并且每个元素都有一个对应的序号，表中元素可以重复出现。
 逻辑结构 线性表是一种逻辑结构，其一般表示为: ($a_1,a_2,&amp;hellip;,a_{i-1},a_i,a_{i&#43;1},&amp;hellip;,a_n$)
  除了起始元素$a_1$没有前驱元素之外，其他元素$a_i$有且仅有一个前驱元素$a_{i-1}$。
  除了终端元素$a_n$没有后继元素外，其他元素$a_i$有且仅有一个后继元素$a_{i&#43;1}$。
  根据上面的表示，在线性表中，每个元素至多只有一个前驱元素，并且至多只有一个后继元素。
存储结构 线性表是一种逻辑结构，其存储结构有两种：
  顺序存储：顺序表
  链式存储：单链表
  顺序表 线性表的顺序存储是指一组地址连续的存储单元依次存储线性表中的各个元素，使得线性表中在逻辑结构上相邻的数据元素存储在相邻的物理存储单元中。即通过数据元素物理存储的相邻关系来反映数据元素之间逻辑上的相邻关系，采用顺序存储结构的线性表通常称为顺序表。
顺序表的特点 根据顺序表的定义，总结顺序表有以下的特征：
  属于直接映射——逻辑上相邻的元素，其物理位置也相邻。
  具有随机存取特性，通过首地址和元素序号可以在 $O(1)$ 时间内找到指定元素。
  存储密度高，其值为$1$。$存储密度=\frac{节点数据本身所占用的存储量}{节点结构占用的存储量}$
  删除和插入元素需要移动大量元素：
  插入元素移动的平均次数$=\frac{1}{n}\sum_{i=1}^{n}(n-i&#43;1)=\frac{n}{2}$, 因此时间复杂度为$O(n)$。
  删除元素移动的平均次数$=\frac{1}{n}\sum_{i=1}^{n}(n-i)=\frac{n-1}{2}$，因此时间复杂度为$O(n)$。
    描述顺序表的结构 为了描述顺序表，需要知道：① 顺序表的起始地址；② 顺序表的最大长度；③ 顺序表的当前长度。
#define MaxSize 1000 typedef struct {  int data[MaxSize];  int length; } SqList; 一些习题 最长平台 给定一个有$n$个元素的整型数组$data$,其中连续的相等元素构成的子序列称为平台，请设计一个算法求 $data$ 中最长平台的长度。
template&amp;lt;typename T&amp;gt; int linerArith&amp;lt;T&amp;gt;::maximumPlatform(T *data, int length) {  int start = 0;  int maxLen = 1;  int curLen = 1;   for (int i = 1; i &amp;lt; length; &#43;&#43;i) {  if (data[i] == data[start]) {  curLen&#43;&#43;;  } else {  if (curLen &amp;gt; maxLen) {  maxLen = curLen;  }  curLen = 1;  start = i;  }  }  //可能最后一个连续的子序列为最大平台  if (curLen &amp;gt; maxLen) {  maxLen = curLen;  }  return maxLen; } 以key为轴调整 设有一个数组 $data$， 其元素为整型数据，设计一个算法将 $data$ 中所有小于 $key$ 的整数放在前半部分，大于等于 $key$ 的整数放在后半部分。
template&amp;lt;typename T&amp;gt; void linerArith&amp;lt;T&amp;gt;::rotate(T *data, int length, int key) {  assert(length &amp;gt;= 0);  int start = 0, end = length - 1;  while (start &amp;lt; end) {  while (start &amp;lt; end &amp;amp;&amp;amp; data[start] &amp;lt; key) {  start&#43;&#43;;  }  while (start &amp;lt; end &amp;amp;&amp;amp; data[end] &amp;gt;= key) {  end--;  }  if (start &amp;lt; end) {  std::swap(data[start], data[end]);  }  } } 以第一个元素为轴调整 设有一个数组 $data$，其元素为整型。设计一个尽可能高效的算法，以第一个元素为分界线，将所有小于等于它的元素移到该元素前面，将所有大于它的元素移到该元素的后面。
template&amp;lt;typename T&amp;gt; void linerArith&amp;lt;T&amp;gt;::rotateByFirst(T *data, int length) {  assert(length &amp;gt;= 0);  int start = 0, end = length - 1;  T pivot = data[0];   while (start &amp;lt; end) {  while (start &amp;lt; end &amp;amp;&amp;amp; data[start] &amp;lt;= pivot) {  start&#43;&#43;;  }   while (start &amp;lt; end &amp;amp;&amp;amp; data[end] &amp;gt; pivot) {  end--;  }   if (start &amp;lt; end) {  std::swap(data[start], data[end]);  }  }  //因为忽略了第一个元素，因此这里需要检查最终位置的那个元素和第一个元素的大小关系  if (data[start] &amp;lt; pivot) {  std::swap(data[start], data[0]);  } }  template&amp;lt;typename T&amp;gt; void linerArith&amp;lt;T&amp;gt;::rotateByFirstVersion2(T *data, int length) {  assert(length &amp;gt;= 0);  int start = 0, end = length - 1;  int pivot = data[0];   while (start &amp;lt; end) {  while (start &amp;lt; end &amp;amp;&amp;amp; data[end] &amp;gt; pivot) {  end--;  }  if (start &amp;lt; end) {  data[start&#43;&#43;] = data[end];  }   while (start &amp;lt; end &amp;amp;&amp;amp; data[start] &amp;lt;= pivot) {  start&#43;&#43;;  }  if (start &amp;lt; end) {  data[end--] = data[start];  }  }  data[start] = pivot; //找到最终位置 }  // 剑指offer里快速排序的思路,该方法保持相对次序不变 template&amp;lt;typename T&amp;gt; void linerArith&amp;lt;T&amp;gt;::rotateByFirstVersion3(T *data, int length) {  assert(length &amp;gt;= 0);  int i = 0;  T pivot = data[0];  for (int j = 1; j &amp;lt; length; &#43;&#43;j) {  //是小于不是&amp;lt;=,因为第一个元素要被替换掉  if (data[j] &amp;lt; pivot) {  i&#43;&#43;;  if (i &amp;lt; j) {  std::swap(data[i], data[j]);  }  }  }  //最后交换下标为0的元素和下标为i的元素  std::swap(data[0],data[i]); } void move1(SqList &amp;amp;L) {  int i = 0;  j = L.length - 1;  int pivot = L.data[0];  int tmp;   while (i &amp;lt; j) {  while (i &amp;lt; j &amp;amp;&amp;amp; L.data[j] &amp;gt; pivot)  j--;  while (i &amp;lt; j &amp;amp;&amp;amp; L.data[i] &amp;lt;= pivot) //第一个元素肯定会被忽略掉  i&#43;&#43;;   //此处可以添加一个 i &amp;lt; j 的判断，这里省略掉是因为前面已经判断i&amp;lt;j,  //所以到这里的时候最多也是i==j, 这时候直接交换也是没有副作用的  tmp = L.data[i];  L.data[i] = L.data[j];  L.data[j] = tmp;   }   if (L.data[i] &amp;lt; pivot)//因为忽略了第一个元素，因此这里需要检查最终位置的那个元素和第一个元素的大小关系  {  tmp = L.data[0];  L.data[0] = L.data[i];  L.data[i] = tmp;  } }  void move2(SqList &amp;amp;L) {  int i = 0, j = L.length - 1;  int pivot = L.data[0];   while (i &amp;lt; j) {  while (i &amp;lt; j &amp;amp;&amp;amp; L.data[j] &amp;gt; pivot) j--; //先从最后开始，因为第一个元素需要首先被替换  if (i &amp;lt; j) {  L.data[i] = L.data[j];  i&#43;&#43;;  }   while (i &amp;lt; j &amp;amp;&amp;amp; L.data[i] &amp;lt;= pivot) i&#43;&#43;;  if (i &amp;lt; j) {  L.data[j] = L.data[i];  j--;  }  }  L.data[i] = pivot; //最后找到最终的位置 }   void move3(SqList &amp;amp;L) //剑指offer里快速排序的思路 { //该算法可以保持相对次序不变  int i = 0;  int pivot = L.data[0];  int tmp;   for (int j = 1; j &amp;lt; L.length; j&#43;&#43;) {  if (data[j] &amp;lt; pivot) {  i&#43;&#43;;  if (i &amp;lt; j) //是小于不是&amp;lt;=,因为第一个元素要被替换掉  {  tmp = L.data[i];  L.data[i] = L.data[j];  L.data[j] = tmp;  }  }  }  tmp = L.data[0]; //最后交换下标为0的元素和下标为i的元素  L.data[0] = L.data[i];  L.data[i] = tmp; } 删除元素 已知长度为$n$的数组$data$，编写一个时间复杂度为$O(n)$,空间复杂度为$O(1)$ 的算法，该算法删除线性表中所有值为$value$的元素。
template&amp;lt;typename T&amp;gt; int linerArith&amp;lt;T&amp;gt;::deleteSameElement(T *data, int length, int value) {  assert(length &amp;gt;= 0);  int base = 0;  for (int i = 0; i &amp;lt; length; &#43;&#43;i) {  if (data[i] != value) {  data[base&#43;&#43;] = data[i];  }  }  return base; }  template&amp;lt;typename T&amp;gt; int linerArith&amp;lt;T&amp;gt;::deleteSameElement(T *data, int length, int value) {  assert(length &amp;gt;= 0);  int count = 0; //不同的是记录目前等于value的元素个数  for (int i = 0; i &amp;lt; length; &#43;&#43;i) {  if (data[i] == value) {  count&#43;&#43;;  } else {  data[i - count] = data[i];  }  }  return length - count; } 一般类似的题目有：已知长度为 $n$ 的线性表 $L$ 采用顺序存储结构，试设计一个时间复杂度空间复杂度两方面都尽可能高效的算法，该算法删除线性表中元素值为$[x,y]$之间的所有数据元素。
单链表 单链表是任意一组存储单元存放线性表中的元素，每个节点通过一个指针指向其后继节点。这组存储单元可以是连续的也可以是不连续的。单链表具有如下的特点：
  通过首节点(带哨兵节点或不带哨兵节点)的指针来标识一个单链表。
  从一个已知节点出发，只能访问该节点和通过 $next$ 指针访问其后继节点，无法直接找到该节点之前的其他节点。
  在单链表中插入一个节点或者删除一个节点必须找到其前驱节点，插入和删除操作不需要移动节点。「删除一个节点也可以不用知道其前驱节点，只要将其后继节点的元素内容往前移到当前节点，并将当前节点的后继修改为其后继节点的后继节点，然后删除后继节点即可。但是要考虑该节点是否为最后一个节点，或者第一个节点」
  typedef struct LinkedNode {  T data; //T表示数据类型  struct LinkedNode *next; } LinkedList; 建立单链表 建立单链表有两种方式，一种是从头部插入；另一种是从尾部插入。从头部插入节点生成的单链表，最后节点元素顺序与插入元素的顺序相反，即成逆序排列了。
void creatLinkedList(LinkedList *&amp;amp;L, int *a, int n) {  LinkedList *cur;  L = (LinkedList *) malloc(sizeof(LinkedList));  L-&amp;gt;next = NULL;   for (int i = 0; i &amp;lt; n; i&#43;&#43;) {  cur = (LinkedList *)(malloc(sizeof(LinkedList)));  cur-&amp;gt;data = a[i];  cur-&amp;gt;next = L-&amp;gt;next;  L-&amp;gt;next = cur; //当前节点成为哨兵节点的下一个节点  } } 尾插法是在单链表的尾部插入节点元素，最后生成的单链表的节点元素顺序和插入元素的顺序是相同的。
void creatLinkedList(LinkedList *&amp;amp;L, int *a, int n) {  LinkedList *cur, *tail;  L = (LinkedList *) malloc(sizeof(LinkedList));  tail = L; //tail始终指向最后的节点，开始时指向链表的头结点   for (int i = 0; i &amp;lt; n; i&#43;&#43;) {  cur = (LinkedList *) malloc(sizeof(LinkedList));  cur-&amp;gt;data = a[i];  tail-&amp;gt;next = cur;  tail = cur;  }  tail-&amp;gt;next = NULL; } 基本操作  按序号查找节点值算法  bool findNode(LinkedList *L,int i,int &amp;amp;result) {  int j=0;  LinkedList *cur=L;   while(cur!=NULL &amp;amp;&amp;amp; j&amp;lt;i)  {  j&#43;&#43;;  cur=cur-&amp;gt;next;  }  if(NULL==cur) return false;   result=cur-&amp;gt;data;  return true;  } 按元素值查找序号算法  int findNode(LinkedList *L,int key) {  LinkedList *cur=L-&amp;gt;next;  int index=0;   while(cur!=NULL &amp;amp;&amp;amp; cur-&amp;gt;data!=key)  {  index&#43;&#43;;  cur=cur-&amp;gt;next;  }   if(cur!=NULL) return index;  else return -1; //返回-1，表示没有找到该元素 }   插入元素：将值为$x$的元素的新节点插入到第$i$个节点的位置上，即先在单链表中找到插入节点的前驱节点，即第$i-1$个节点，再在其后插入新节点。
 cur-&amp;gt;next=pre-&amp;gt;next; //cur表示将要插入到链表中的节点,插入的位置是节点pre之后  pre-&amp;gt;next=cur;   删除元素:将单链表中的第$i$个节点删除。
 cur=pre-&amp;gt;next; //pre-&amp;gt;next是待删除的节点，cur是待删除节点的上一个节点  pre-&amp;gt;next=cur-&amp;gt;next;  free (cur);    就地逆置 有一个线性表$(a_1,a_2,&amp;hellip;,a_n)$ 采用带哨兵节点的单链表$L$存储，设计一个就地算法将其就地逆置，所谓“就地”是指算法的辅助空间为$O(1)$。
void reverse(LinkedList * &amp;amp; L) //传入引用 {  LinkedList *cur=L-&amp;gt;next;  LinkedList *next;  L-&amp;gt;next=NULL;  while(cur!=NULL)  {  next=ptr-&amp;gt;next; //先保存下一个节点，然后使用头插法进行逆置  cur-&amp;gt;next=L-&amp;gt;next;  L-&amp;gt;next=cur;  cur=next;  } }  拆分链表 设$C={a_1,b_1,a_2,b_2,&amp;hellip;,a_n,b_n}$ 为一线性表，采用带哨兵节点的$hc$单链表存放，设计一个就地算法，将其拆分为两个线性表（它们都是用单链表存放）使得$A={a_1,a_2,&amp;hellip;,a_n},B={b_n,b_{n-1},&amp;hellip;,b_2,b_1}$，即$A$是正序排列，$B$是逆序排列。
//参数传入引用，ha存储是A，hb存储的是B void split(LinkedList *hc,LinkedList *&amp;amp;ha,LinkedList *&amp;amp; hb) {  LinkedList *tail=ha;  LinkedList *cur=hc-&amp;gt;next;  LinkedList *next;   hb-&amp;gt;next=NULL;  while(cur != NULL)  {  tail-&amp;gt;next=cur; //尾插法  tail=cur;   cur=cur-&amp;gt;next;   next=cur-&amp;gt;next;  cur-&amp;gt;next= hb-&amp;gt;next; //头插法  hb-&amp;gt;next= cur;  cur=next;  }  tail-&amp;gt;next=NULL; //别忘了 } 递增排序 有一个带哨兵结点的单链表$L$,设计一个算法使其元素递增有序。最基本的想法是使用直接插入排序的思想，一个一个排，不同于数组排序，这里单链表只能从头开始查找。
void sort（LinkedList * &amp;amp;L) {  LinkedList *cur=L-&amp;gt;next;  LinkedList *next=cur-&amp;gt;next;  LinkedList *pre,*assist; //   cur-&amp;gt;next=NULL; //只含有一个元素的有序单链表  cur=next;   while(cur!=NULL)  {  next=cur-&amp;gt;next; //首先保存下一个链表节点  pre=L; //单链表只能从头开始往后寻找节点   assist=pre-&amp;gt;next; //assist从头开始遍历  while(assist!=NULL &amp;amp;&amp;amp; assist-&amp;gt;data &amp;lt; cur-&amp;gt;data)  {  pre=assist; //pre记录插入位置的前一个节点  assist=assist-&amp;gt;next;  }   cur-&amp;gt;next=pre-&amp;gt;next; //pre的下一个节点就是要插入的位置  pre-&amp;gt;next=cur; //pre的下一个节点就是要插入的位置   cur=next;  } }  公共节点 给定两个单链表，编写算法找出其公共的节点。第一种方法分析：从头到尾扫描单链表$A$，判断当前元素是否在单链表$B$中出现，若在则插入到单链表$C$中。
void findSameNode(LinkedList *A,LinkedList *B,LinkedList *&amp;amp;C) {  LinkedList *curA=A-&amp;gt;next;  LinkedList *curB=B-&amp;gt;next;  LinkedList *tail; //尾插法构建新的单链表   C=(LinkedList*)malloc(sizeof(LinkedList)); //静态存储区分配内存  C-&amp;gt;next=NULL;  tail=C;  while(curA!=NULL)  {  curB=B-&amp;gt;next;  while(curB!=NULL &amp;amp;&amp;amp; curB-&amp;gt;data!= curA-&amp;gt;data)  curB=curB-&amp;gt;next;   if(curB!=NULL)  {  tail-&amp;gt;next=curA;  tail=curA;  }  curA=curA-&amp;gt;next;  }  tail-&amp;gt;next=NULL; //尾插法最后应该将尾巴的next域置空 } 第二种方法分析：借用两个辅助栈，分别存储两个链表遍历时的序列，然后同时将两个辅助栈中元素弹出，直到弹出的元素不相等，弹出时采用头插法进行构造新的单链表。
第三种方法分析：首先遍历两个链表，得到两个单链表的长度差$k$，然后长的单链表先走$k-1$步，然后短的和长的同时走，直到遇到相等的元素，即为新的单链表的首节点。
 精选习题 循环左移 将$n$个整数存放到一维数组$R$中。试设计一个在时间和空间尽可能高的算法。将$R$中保存的序列循环左移$p （0 \lt q\lt n)$个位置，即将$R$中的数据由$(X_0,X_1,...,X_{n-1})$变换为$(X_p,X_{p&#43;1},...,X_{n-1},X_0,X_1,....,X_{p-1})$
void reverse(int R[],int start,int end) {  int i=start,j=end;  int assist;  while(i&amp;lt;j)  {  assist=R[i];  R[i]=R[j];  R[j]=assist;  i&#43;&#43;;  j--;  } }  void leftShift(int R[],int n,int p) {  if(p&amp;gt;0 &amp;amp;&amp;amp;p&amp;lt;n)  {  reverse(R,0,n-1);  reverse(R,0,n-p-1);  reverse(R,n-p,n-1);  } }  寻找中位数 给定两个数组$A$和$B$,数组的长度为$n$,两个数组都分别有序，求出两个数组中的所有数排序后的中位数「偶数序列中间两数的前一个为其中位数」。
解法一 因为数组$A$和$B$均有序，因此将两个数组排序后，第$n$个数就是题目中所要找的中位数。
int search(int A[], int B[], int n) {  int i = 0, j = 0, k = 0;   while (i &amp;lt; n &amp;amp;&amp;amp; j &amp;lt; n) {  k&#43;&#43;;  if (A[i] &amp;lt; B[j]) {  if (k == n)  return A[i];  i&#43;&#43;;  } else {  if (k == n)  return B[j];  j&#43;&#43;;  }  } } 解法二 分别求出两个升序序列$A$，$B$的中位数，记为$a，b$。若$a=b$,则$a$或$b$即为所求，否则舍弃$a,b$中较小者所在序列的较小一半，同时舍弃较大者所在序列的较大一半，要求两次舍弃的元素个数相同（每次从左侧和右侧删除相同个数的元素后，新的两个数组，它们的中位数与原始数组的中位数是相同的）。重复上述过程，直到两个序列均只含一个元素为止，则较小的即为所求的中位数。
int searchMid(int A[], int B[], int n) {  int startA, midA, endA;   startA = 0;  endA = n - 1;  startB = 0;  endB = n - 1;   while (startA != endA || startB != endB) {  midA = (startA &#43; endA) / 2;  midB = (startB &#43; endB) / 2;   if (A[midA] == B[midB])  return A[midA];   if (A[midA] &amp;lt; B[midB]) {  if ((startA &#43; endA) % 2 == 0)//若元素个数为奇数时  {  startA = midA; //舍弃A中间点以前的部分且保留中间点  endB = midB; //舍弃B中间点以后的部分且保留中间点  } else //若元素个数为偶数时  {  startA = midA &#43; 1; //舍弃A的前半部分,每次舍弃的长度相同，可以保证同时到达  endB = midB; //舍弃B的后半部分  }  } else if (A[midA] &amp;gt; B[midB]) {  if ((startA &#43; endA) % 2 == 0)//若元素个数为奇数时  {  endA = midA; //舍弃A中间点以后的部分且保留中间点  startB = midB;//舍弃B中间点以前的部分且保留中间点  } else //若元素个数为偶数时  {  endA = midA; //舍弃A的后半部分  startB = midB &#43; 1; //舍弃B的前半部分  }  }  }   return A[startA] &amp;lt; B[startB] ? A[startA] : B[startB]; //较小者即为所求 }   若$A$和$B$数组的长度为$2k&#43;1$，取$A$数组的中位数为$A[k]$，$B$数组的中位数为$B[k]$，$A$和$B$组合起来的中位数应该是第$2k&#43;1$大的那个数。如果$A[k]==B[k]$，则$A[k]$必定为第$2k&#43;1$大的数，是所有数字的中位数。如果$A[k]\gt B[k]$，则$A[k]$至少为第$2k&#43;2$大的数，$B[k]$至多为第$2k&#43;1$大的数，中位数介于$B[k]$和$A[k]$之间。
  若$A$和$B$数组的长度为$2k$，按照题目所述条件，则$A$的中位数为$A[k-1]$,则$B$的中位数为$B[k-1]$,$A$和$B$组合起来的中位数应该是第$2k$大的那个数，若$A[k-1]==B[k-1]$,则$B[k-1]$必为第$2k$大的那个数，即所有数字的中位数。如果$A[k-1]\gt B[k-1]$，则$A[k-1]$至少为第$2k$大的数，$B[k-1]$至多为第$2k-1$大的数，中位数介于$B[k-1]$和$A[k-1]$之间。
   次数大于一半 已知一个整数序列$A=(a_0,a_1,...,a_{n-1})$，在这个序列中若存在「不要求连续的序列」$a_{p_1} = ... = a_{p_m} = x，0&amp;lt;= a_{i} &amp;lt; n, m &amp;gt; n/2 , (0 &amp;lt;= p_k &amp;lt; n, 1&amp;lt;=k&amp;lt;=m)$,则称 $x 为 A$ 的主元素，例如$A=(0,5,5,3,5,7,5,5)$,则$5$为主元素；又如$A=(0,5,5,3,5,1,5,7)$，则$A$中没有主元素。假设$A$中的 $n$ 个元素保存在一个一维数组中，请设一个尽可能高效的算法，找出$A$的主元素。若存在主元素，则输出该元素，否则输出$-1$。
解法一 主元素问题方法一：对数组中元素进行计数，然后查看出现次数最多的元素，若次数大于一半，则为主元素。这种方式只需要对数组扫描一遍，时间复杂度为$O(n)$,空间复杂度为$O(n)$。
int moreThanHalf(int A[],int n) {  int *count=(int*)malloc(sizeof(int)*n);  int index=0;   for(int i=0;i&amp;lt;n;i&#43;&#43;) count[i]=0;   for(int i=0;i&amp;lt;n;i&#43;&#43;)  {  count[A[i]]&#43;&#43;;  if(count[A[i]) &amp;gt; count[A[index]]) index=A[i];  }   if(count[index]&amp;gt;(n/2))  return index;  else  return -1; }  解法二 首先使用快速排序，将元素排好序，然后统计相同元素出现的最大次数。统计的时候可以使用求最长平台的算法。时间复杂度为$O(nlogn)$,空间复杂度为$O(n)$。
void quickSort(int A[],int start,int end) {  int i=start,j=end;   if(i&amp;lt;j)  {  while(i&amp;lt;j)  {  while(i&amp;lt;j &amp;amp;&amp;amp; A[j]&amp;gt;tmp) j--;  A[i]=A[j];  if(i&amp;lt;j)  {  A[i]=A[j];  i&#43;&#43;;  }  while(i&amp;lt;j &amp;amp;&amp;amp; A[i]&amp;lt;=tmp) i&#43;&#43;;  if(i&amp;lt;j)  {  A[j]=A[i];  j--;  }  }  quickSort(A,start,i-1);  quickSort(A, i&#43;1, end);  } } //然后使用平台算法  解法三 数组中存在主元素时，所有的非主元素个数和必少于一半。如让主元素与一个非主元素&amp;quot;配对“，则最后多出来的元素（没有元素与之配对）就是主元素。从前往后扫描数组元素，假定遇到的当前值选定为主元素，再次遇到它时计数加1，遇到不等的值时，计数减1。当计数减为0后，将遇到的下一个值重新选定为主元素。扫描完毕，当前选定的元素（计数值大于0）可能是主元素，但未必是主元素。还需要对数组再进行一次扫描，记录它出现的实际个数，以判定它是否是主元素。时间复杂度为$O(n)$,空间复杂度为 $O(1)$。
void moreThanHalf(int A[],int n) {  int pivot=A[0];  int count=1;  int count2=0;  for(int i=1;i&amp;lt;n;i&#43;&#43;)  {  if(A[i]==base)  count&#43;&#43;;  else  {  if(count&amp;gt;0) count--;  else  {  pivot=A[i];  count=1;  }  }  }   if(count &amp;gt; 0)  {  count2=0;  for(int i=0;i&amp;lt;n;i&#43;&#43;)  {  if(pivot==A[i])  count2&#43;&#43;;  }   if(count2 &amp;gt; n/2)  return pivot;  }  return ERROR; //ERROR 代表不会在序列中出现的那个数 }  </content>
    </entry>
    
     <entry>
        <title>Go 标签</title>
        <url>https://iihui.github.io/post/go-label/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html">  在for,switch或者select中都可以配合标签形式的标识符使用——某一行第一个以冒号结尾的单词（因为gofmt会自动将后续代码移动至下一行）。
 一个实例 package main  import &amp;#34;fmt&amp;#34;  func main() {  LABEL1: 	for i := 0; i &amp;lt;= 5; i&#43;&#43; { 	for j := 0; j &amp;lt;= 5; j&#43;&#43; { 	if j == 4 { 	continue LABEL1 	} 	fmt.Printf(&amp;#34;i is: %d, and j is: %d\n&amp;#34;, i, j) 	} 	} 注意事项   标签的名称是大小写敏感的，为了提升可读性，一般建议标签全部使用大写。
  使用逆向的go to语句容易产生意大利苗条似的代码，所以应该避免。逆向是指先使用go to语句，后定义标签。
  如果一定要使用标签，建议使用正向标签。但是，标签和go to 语句之间不能有变量定义，否则会出现编译错误。
  定义了标签，如果不使用标签会产生编译错误。
  正确使用标签的情形：发生错误时，跳出无限循环，并关闭某些东西。
   </content>
    </entry>
    
     <entry>
        <title>Go 中if语句</title>
        <url>https://iihui.github.io/post/go-if/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html"> if是用于测试某个条件（布尔型，又被称为逻辑型）的语句，如果该条件成立，则会执行if后由大括号括起来的代码块，否则就忽略该代码块继续执行后续的代码。Go中if语句总共有三种形式，分别是：
  不带else的if；
  带一个else的if语句；
  带else if的if语句；
  包含初始化的if语句
  不带else的if 测试条件是布尔型的语句，如果该条件成立，则执行大括号中的内容。
if condition { //{ 与condition 须在同一行  //do something } 带else的if if condition {  //do something }else{  //do something }  带else if的if if condition1 {  // do something  }  else if condition2 { // do something else } else { // catch-all or default }  带初始化的if if initialization; condition { // do something }   在if条件中声明的变量的作用域只存在于if结构中，即在if结构的大括号之间，如果使用if-else结构则在else代码块中变量也会存在。
  如果变量在if结构之前就已经存在，那么在if结构中，该变量原来的值会被隐藏。
   注意事项   需要注意的是，即使代码块之间只有一条语句，大括号也不能被省略。
  关键字if和else之后的左大括号{必须和关键字在同一行，这是编译器强制规定的。
  如果使用了else-if结构，则前段代码块的右大括号}必须和else-if关键字在同一行，这是编译器强制规定的。
  使用gofmt格式化代码之后，每个分支内的代码都会缩进4个或8个空格，或者是1个 tab，并且右大括号与对应的if关键字垂直对齐。
  当if结构内有break、continue、goto或者return语句时，Go 代码的常见写法是省略else部分。
   </content>
    </entry>
    
     <entry>
        <title>位运算</title>
        <url>https://iihui.github.io/post/arith-bits/</url>
        <categories>
          <category>算法</category>
        </categories>
        <tags>
          <tag>算法</tag>
        </tags>
        <content type="html"> 判断是否为2的n次方 对于正整数来说，如果一个数为$x=2^n$,那么必然有一位为1，右边其它位全为0。那么$(x-1)$在其对应为1的位置上为0，对应位右边全部为1。因此，x&amp;amp;(x-1)的值则为0。
// 要求x是正整数 (x&amp;amp;(x-1) == 0) 位运算实现加法 对于二进制加法，如果不考虑相加时的进位，则有：1&#43;1=0，0&#43;1=1，1&#43;0=1，0&#43;0=0，这是二进制的异或。再考虑相加时有进位时的情况：1&#43;1=1，1&#43;0=0，0&#43;1=0，0&#43;0=0，这是二进制的与运算。
因此，二进制可以按照如下的方式进行：①首先不考虑进位的情况时，计算各位的累加得到值a；②然后考虑有进位的情况，先计算进位并将其左移得到b，如果b的值为0，那么a的值就是最后的计算结果，如果b的值不为0，则a&#43;b是最后的结果。
非递归实现 int add(int x,int y) {  int result=x,carray=y,tmp;  while(carray!=0)  {  tmp = (result &amp;amp; carray) &amp;lt;&amp;lt;1;  result ^= carray;  carray = tmp;  }  return result; } /// 位运算加法 /// - Parameters: /// - x: 被加数 /// - y: 加数 /// - Returns: x &#43; y 的和  public class Arithmetic {  public static func add(x:Int ,y:Int) -&amp;gt; Int {  var sum = x  var carry = y  while carry != 0 {  let tmp = (sum &amp;amp; carry) &amp;lt;&amp;lt; 1  sum ^= carry  carry = tmp  }  return sum  } }  func testArith() throws {  XCTAssert(Arithmetic.add(x:23,y:23) == 46) } 递归方式实现 int recAddNoArithm(int a, int b) {  if (b == 0)  return a;  int sum = a ^ b;  int carry = (a &amp;amp; b) &amp;lt;&amp;lt; 1;   return recAddNoArithm(sum, carry); } 位运算实现减法 减法可以转换为加法，例如a-b可以写成a&#43;(-b)。因此，只要先通过b的值，求得-b的值，然后再利用上面的加法实现就可以得到a-b的值。由b求-b的快捷方式是按位取反，然后末位加1，因此位运算的减法如下所示：
int subNoArithm(int a, int b) {  auto sub = nonRecAddNoArithm(~b, 1);  return nonRecAddNoArithm(a, sub); } 交换两个数的值 在异或运算中，偶数个相同的数异或的结果为0；奇数个相同的数的异或的结果为还是当前数；某个数和0进行异或的结果仍为原数，并且异或运算是支持交换律的：
a = a ^ b; b = a ^ b; a = a ^ b; 上面是a在公式左边出现两次，或者b在公式左边出现两次，这两次是最开始和最后出现：
b = a ^ b; a = a ^ b; b = a ^ b; 两个数较大者 主要运用异或的特点：偶数个相同的数异或的结果为0；奇数个相同数异或结果还是当前数；某个数和0进行异或的结果仍为原数，并且异或运算是支持交换律的，对于-1来说其二进制位全部为1。
y ^ ((x ^ y) &amp;amp; (-(x &amp;gt;= y)) //快速记忆：y 在前则找较大者 两个数较小者 x ^ ((x ^ y) &amp;amp; (-( x &amp;gt;= y)) //快速记忆：x 在前则找较小者 两个数的平均值  (x &amp;amp; y) &#43; (x ^ y &amp;gt;&amp;gt; 1); 二进制中1的个数 利用n &amp;amp; (n-1) 第一种方式每次使用公式n&amp;amp;(n-1)可以去除二进制表示中的1位1，当所有位置的1都被去除之后，结果为0，这就是终止条件。
int getBinary1Bits1(int n) {  int count = 0;  while (n != 0)  {  n = n &amp;amp; (n - 1); //n &amp;amp; （n-1)每次可以去除二进制表示中的一个1  count&#43;&#43;;  }  return count; }  //注意参数的变化 int getBinary1Bits2(unsigned int n) {  int count = 0;  while (n &amp;gt; 0) //终止条件是 n&amp;gt;0,因为 n 总是&amp;gt;=0  {  n = n &amp;amp; (n - 1);  count&#43;&#43;;  }  return count; } 利用标识位 第二种方式，使用一个标识数，其初始值设置为1。然后，使用这次标识数与当前数进行位与运算，便可得到当前位是否为1；接着，使标识数向左移动一位，然后重复上一步，最终得到1的个数。
int getBinary1Bits3(int n) {  int count = 0;  unsigned int flag = 1; //标识数应该声明为无符号数   while (flag != 0)  {  if (flag &amp;amp; n)  {  count&#43;&#43;;  }  flag = flag &amp;lt;&amp;lt; 1;  }  return count; } 利用汉明编码 第三种方式使用汉明：
typedef unsigned int64 uint64; //assume this gives 64-bits const uint64 m1 = 0x5555555555555555; //binary: 0101... const uint64 m2 = 0x3333333333333333; //binary: 00110011.. const uint64 m4 = 0x0f0f0f0f0f0f0f0f; //binary: 4 zeros, 4 ones ... const uint64 m8 = 0x00ff00ff00ff00ff; //binary: 8 zeros, 8 ones ... const uint64 m16 = 0x0000ffff0000ffff; //binary: 16 zeros, 16 ones ... const uint64 m32 = 0x00000000ffffffff; //binary: 32 zeros, 32 ones ... const uint64 hff = 0xffffffffffffffff; //binary: all ones const uint64 h01 = 0x0101010101010101; //the sum of 256 to the power of 0,1,2,3...  //This is a naive implementation, shown for comparison, //and to help in understanding the better functions. //It uses 24 arithmetic operations (shift, add, and). int popcount_1(uint64 x) {  x = (x &amp;amp; m1 ) &#43; ((x &amp;gt;&amp;gt; 1) &amp;amp; m1 ); //put count of each 2 bits into those 2 bits  x = (x &amp;amp; m2 ) &#43; ((x &amp;gt;&amp;gt; 2) &amp;amp; m2 ); //put count of each 4 bits into those 4 bits  x = (x &amp;amp; m4 ) &#43; ((x &amp;gt;&amp;gt; 4) &amp;amp; m4 ); //put count of each 8 bits into those 8 bits  x = (x &amp;amp; m8 ) &#43; ((x &amp;gt;&amp;gt; 8) &amp;amp; m8 ); //put count of each 16 bits into those 16 bits  x = (x &amp;amp; m16) &#43; ((x &amp;gt;&amp;gt; 16) &amp;amp; m16); //put count of each 32 bits into those 32 bits  x = (x &amp;amp; m32) &#43; ((x &amp;gt;&amp;gt; 32) &amp;amp; m32); //put count of each 64 bits into those 64 bits  return x; }  </content>
    </entry>
    
     <entry>
        <title>败者树</title>
        <url>https://iihui.github.io/post/arith-loser-tree/</url>
        <categories>
          <category>算法</category>
        </categories>
        <tags>
          <tag>算法</tag>
        </tags>
        <content type="html">  胜者树和败者树都是完全二叉树，是树形选择排序的一种变型。每个叶子结点相当于一个选手，每个中间结点相当于一场比赛，每一层相当于一轮比赛。不同的是，胜者树的中间结点记录的是胜者的标号；而败者树的中间结点记录的败者的标号。胜者树与败者树都可以在$log(n)$的时间内找到最值。任何一个叶子结点的值改变后，利用中间结点的信息，还是能够快速地找到最值，在k路归并排序中经常用到。
 胜者树 胜者树的父节点保存的是两两比较胜出者的下标，所以当重构时（一个选手的值发生改变时）只要找到其父节点然后与其兄弟节点比较，并将父节点更改为新的胜利节点的下标。
这是因为重构时覆盖原来叶子节点的下一个节点都比原叶子节点小，这里的小是指胜利的反方向，此时只要和败者比较就可以了，因为不清楚上一次的败者是谁，所以一定要和兄弟以及父节点比较。
因此，只要沿着发生改变的结点到根结点的路径修改这棵二叉树，而不必改变其他比赛的结果。在下面给出的例子的图示中都是数值越小表示胜利。
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-09-29 下午9.29.49.png)
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-09-29 下午9.32.04.png)
但是，胜者树每上升一次需要访问两个节点——父节点和兄弟节点。而对于败者树来说，它只要访问父节点，这是败者树的优势。
 败者树 对于胜者树来说，在节点上升的时候首先需要获得父节点，然后再获得兄弟节点，然后再比较。这时人们又想能否减少访存次数，于是就有了败者树。
在败者树中，用父结点记录其左右子结点进行比赛的败者，让胜者参加下一轮的比赛。败者树的根结点记录的是败者，因此，需要加一个结点来记录比赛的最终胜者。
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-09-29 下午9.37.52.png)
败者树重构过程如下：①首先，将新进入败者树的新结点与其父结点进行比较，并将败者存放在父结点中；②然后，将第1步中比较后的胜者再与上一级的父结点比较。
因为重构时覆盖原来叶子节点的下一个节点都比原叶子节点小，这里的小是指胜利的反方向，所以只要和败者比即可。此时父节点记录的就是败者，因此，只要和父节点比较即可。所以说对于败者树来说，它只要访问父节点，这是败者树的优势。
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-09-29 下午9.41.55.png)
 胜者树和败者树与堆的区别 相同点 胜者树、败者树和堆的相同点：空间和时间复杂度均相同——调整一次的时间复杂度都是 $O(logN)$，空间复杂度为$O(1)$。
 不同点 堆排序中每次取出当前最小值之后，把最后一个数换到堆顶。在调整堆的时候，每次都要选出父节点的两个孩子节点的最小值，然后再用孩子节点的最小值和父节点进行比较，所以每调整一次需要比较两次。
所以胜者树相对于堆来说减少了一次比较，败者树相对于胜者树来说减少了一个访存，但是并不能保证每次都可以减少一次访存。例如上题，假如$b_3$一开始是13，而不是6，那么$b_3$是败者，而此时$b_3$ 被替换为6时，由于此前 $b_3$ 为败者，因此此时就要和兄弟节点比较了，所以此时访存次数为2。
也就是说，堆排序中一定要和兄弟节点和父节点比较，即访存2次，比较2次；而胜者树只要和兄弟比较，但是需要访问兄弟节点和父节点，即访存2次，比较1次；而败者数一般和父节点比较，可能要和兄弟节点比较，因此访存此数可能比胜者树少1次，即访存是1次或者2次，比较1次。
 外排序 在外排序的K路归并的时候，由于需要访问外存，而对于计算来说此时访问外存是最主要的时间耗费。此时，常使用败者树来进行K路归并排序，归并的时候K个叶子节点保存的就是K个文件中的当前最小值。
所以对于K个有序段进行K路归并时的步骤为：
  取每个输入有序段的第一个数据作为败者树的叶子节点，建立初始败者树。然后，两两叶子节点进行比较，在双亲节点中记录比赛的败者，而让胜者去参加更高一层的比赛。最后，在根节点之上胜出的冠军是关键字最小者。
  胜出的记录写到输出归并段中，在对应的叶子节点处补充其输入有序段的下一个记录，若该段有序变空，则补充一个大关键字（比所有记录关键字都大，设为 $k_{max}$）。
  调整败者树，选择新的关键字最小的记录。从补充记录的叶子节点向上和双亲节点的关键字比较，败者留在该双亲节点，胜者继续向上，直到根节点，最后将胜者放到根节点的双亲节点中。
  若胜出的记录的关键字等于$k_{max}$,则归并结束，否则转到第2步。
   最佳归并树 若参加归并的初始归并段有m个，做k路平衡归并，最佳归并树是带权路径长度最短的k次哈夫曼树。则构造步骤如下：
  若 $(m-1),mod,(k-1) \neq 0$,则需要附加 $(k-1)-(m-1),mod,(k-1)$ 个长度为0的虚段，以使每次归并都可以对应$k$个段。
  按照哈夫曼树的构造规则构造最佳归并树。
  参考1 参考2 参考3
 </content>
    </entry>
    
     <entry>
        <title>剑指offer题集1</title>
        <url>https://iihui.github.io/post/arith-sword-1/</url>
        <categories>
          <category>算法</category>
        </categories>
        <tags>
          <tag>算法</tag>
        </tags>
        <content type="html"> 二维数组中查找 在一个二维数组中，每一行都按从左到右递增的顺序排序，每一列都按从上到下递增的顺序排列，试从该二维数组查找给定的元素。
首先应该从右上角的元素(记为cur)开始比较，如果当前要查找的元素key的值比cur大，那么就应该往cur所在行的下面开始寻找；如果key的值比cur小，那么应该往cur所在列的左边寻找，具体代码如下：
bool findKeyInMatrix(int *matrix, int rows, int colums, int key) {  bool found = false;   if (matrix != nullptr &amp;amp;&amp;amp; rows &amp;gt;= 0 &amp;amp;&amp;amp; colums &amp;gt;= 0) {  int row = 0;  int column = colums - 1; //row=0,column=colums-1表示定位到右上角的元素  int cur = 0;   while (row &amp;lt; rows &amp;amp;&amp;amp; colums &amp;gt;= 0) {  cur = matrix[row * colums &#43; column];  if (cur == key) {  found = true;  break;  } else if (cur &amp;gt; key) {  column--;  } else {  row&#43;&#43;;  }  };  }  return found; }  字符串的赋值操作符重载 对于自定义的字符串类的赋值操作符的重载时，需要注意4点：①是否传入常引用const A &amp;amp;。②传入的引用是否是自身。 ③是否释放掉原来的空间。 ④是否返回*this。
class CMyString { private:  char *pdata; public:  CMyString(char *ptr = NULL);   CMyString(const CMyString &amp;amp;str);   CMyString &amp;amp;operator=(const CMyString &amp;amp;str); } ~CMyString() {}  };  CMyString &amp;amp;CMyString::operator=(const CMyString &amp;amp;str) {  if (this != &amp;amp;str) {  CMyString tmp(str);  char *ptmp = tmp.pdata;  tmp.pdata = pdata;  pdata = ptmp;  }  return *this; } 在这个赋值操作符重载函数中，首先创建了一个临时变量tmp，如果分配内存不成功的话，那么会抛出bad_alloc异常，此时也不会修改原来的对象实例。
如果正常分配的话，因为tmp是临时变量，所以在if的作用域结束之后，那么会自动调用析构函数，此时就会析构掉tmp.pdata所指向的内存。因为tmp.pdata已经和pdata交换了，所以这相当于自动调用析构函数释放实例的内存。
从尾到头打印链表 从尾到头打印链表中的元素，有两种解决方法，一种是递归算法，另一种是利用栈来实现非递归算法。下面是递归算法的实现：
void recPrintLinkedList(LinkedNode *head) {  if (head != nullptr)  {  recPrintLinkedList(head-&amp;gt;next);  std::cout&amp;lt;&amp;lt;head-&amp;gt;data&amp;lt;&amp;lt;&amp;#34;\t&amp;#34;;  } } 非递归算法是借助栈的后进先出的特性，首先遍历链表的所有元素，并将它们存入到栈中。当遍历完栈的时候就可以出栈：
void nonRecPrintLinkedList(LinkedNode *head) {  if(head != nullptr)  {  stack&amp;lt;LinkedNode*&amp;gt; st;  LinkedNode * cur = head;   while(cur != nullptr)  {  st.push(cur);  cur = cur-&amp;gt;next;  }   while(!st.empty())  {  cur = st.top();  st.pop();  std::cout&amp;lt;&amp;lt;cur-&amp;gt;data&amp;lt;&amp;lt;&amp;#39;\t&amp;#39;;  }  } }  两个栈实现队列 将stack1作为入队使用， 将stack2作为出队使用。当stack2不空时，就从stack2直接弹出元素，否则将stack1里元素先全部弹出到stack2中，再从stack2中弹出，这样便实现了先进先出。
template &amp;lt;typename T&amp;gt; class stackQueue {  public:  stackQueue(void){};  ~stackQueue(){};  void push(const T &amp;amp;node);  void pop();  T &amp;amp;top();   private:  stack&amp;lt;T&amp;gt; stack1;  stack&amp;lt;T&amp;gt; stack2; };  template &amp;lt;typename T&amp;gt; void stackQueue&amp;lt;T&amp;gt;::push(const T &amp;amp;node) {  stack1.push(node); }  template &amp;lt;typename T&amp;gt; void stackQueue&amp;lt;T&amp;gt;::pop() {  if (stack2.empty()) {  while (!stack1.empty())  {  stack2.push(stack1.top());  stack1.pop();  }  }  if (stack2.empty())  throw string(&amp;#34;queue is empty!&amp;#34;);   stack2.pop(); }  template &amp;lt;typename T&amp;gt; T &amp;amp;stackQueue&amp;lt;T&amp;gt;::top() {  return stack2.top(); } 两个队列实现一个栈 总是保持一个队列是空，出栈的时候将不空的那个队列的前$n-1$个元素都放到空的那个队列里，然后出剩下的那一个元素；入队的时候入到不空的那个队列里。
template &amp;lt;typename T&amp;gt; class queueStack { public:  queueStack(void){};  ~queueStack(){};  void push(const T &amp;amp; node);  T pop();  private:  queue&amp;lt;T&amp;gt; queue1;  queue&amp;lt;T&amp;gt; queue2; };  template &amp;lt;typename T&amp;gt;void queueStack&amp;lt;T&amp;gt;::push(const T &amp;amp;node) {  if(queue1.empty() &amp;amp;&amp;amp; queue2.empty())  {  queue1.push(node);  }  else if(queue1.empty())  {  queue1.push(node);  }  else if(queue2.empty())  {  queue2.push(node);  }  else  throw string(&amp;#34;Error!&amp;#34;); }  template &amp;lt;typename T&amp;gt;T queueStack&amp;lt;T&amp;gt;::pop() {  if(!queue1.empty() &amp;amp;&amp;amp; queue2.empty())  {  while(queue1.size() != 1)  {  queue2.push(queue1.front());  queue1.pop();  }  T &amp;amp; data = queue1.front();  queue1.pop();  return data;  }  else if(queue1.empty() &amp;amp;&amp;amp; !queue2.empty())  {  while(queue2.size() != 1)  {  queue1.push(queue2.front());  queue2.pop();  }  T &amp;amp; data = queue2.front();  queue2.pop();  return data;  }  else  throw string(&amp;#34;Error!&amp;#34;); } 快速排序 快速排序中，基准元素的选择有3种方式：①选择待排序区间左边的第一个元素。②选择待排序空间的中间元素。③随机从待排序区间中选择一个元素。下面的代码是随机选择基准元素：
int quickSortPartition(int *input, int length, int start, int end) {  if (input == nullptr || start &amp;lt; 0 || length &amp;lt;= 0 || end &amp;gt;= length)  {  return -1; // 参数错误  }   srand(time(NULL)); //C风格   int index = rand() % (end - start &#43; 1);  int small = start - 1;   swap(input[index], input[end]);  for (int i = start; i &amp;lt; end; &#43;&#43;i)  {  if (input[i] &amp;lt; input[end])  {  small&#43;&#43;;  if (small &amp;lt; i)  {  swap(input[small], input[i]);  }  }  }   small&#43;&#43;;  swap(input[small], input[end]);  return small; }  void quickSortMore(int *input, int length, int start, int end) {  if (start == end)  return;   int index = quickSortPartition(input,length,start,end);   if (index &amp;gt; start)  quickSortMore(input,length,start,index-1);   if (end &amp;gt; index)  quickSortMore(input,length,index&#43;1,end); } 旋转数组中的最小值 把一个数组的最开始的若干元素移动到数组的末尾，称之为数组的旋转。输入一个递增的数组的一个旋转，找到数组中的最小元素。
最简单的方法是从头到尾遍历一遍数组，就可以找到最小的元素，但是这种方法没有用到旋转数组的前部和后部是有序这一特点。
int findSpinArrayMin(int *data, int length) {  if (data == nullptr || length &amp;lt; 0)  return -1;   int start = 0;  int end = length - 1;  int mid, result = -1;   while (data[start] &amp;gt;= data[end])  {  if (end - start == 1)  {  mid = end;  break;  }  mid = (start &#43; end) / 2;   if (data[start] == data[mid] &amp;amp;&amp;amp; data[mid] == data[end])  {  return minInOrder(data, start, end);  }   if (data[mid] &amp;gt;= data[end])  start = mid;   else if (data[mid] &amp;lt;= data[end])  end = mid;  }   return data[mid]; }  int minInOrder(int *data, int start, int end) {  int result = data[start];   for (int i = start &#43; 1; i &amp;lt;= end; &#43;&#43;i)  {  if (result &amp;gt; data[i])  result = data[i];  }  return result; } 斐波那契数列 首先根据定义很容易想到递归算法，但是递归算法会重复计算很多次，所以实际上浪费了很多资源
long long recFibonacci(unsigned int n) {  if (n &amp;lt;= 1)  return n;  else  return recFibonacci(n - 1) &#43; recFibonacci(n - 2); } 使用非递归解法，不必重复计算
long long nonRecFibonacci(unsigned int n) {  if (n &amp;lt;= 1)  return n;   long long first = 0, second = 1, result = 0;   for (int i = 2; i &amp;lt;= n; i&#43;&#43;)  {  result = first &#43; second;  first = second;  second = result;  }   return result; } 数组的整数次方 实现函数double power(double base,int exponent),求 base的expoent次方，不使用库函数，同时不考虑大数问题。但是在这个问题上需要考虑base接近于0的情况。
double power(double base, int exponent) {  double result = 1.0;  unsigned int absExponent = (unsigned int) (exponent);   if (base &amp;gt; 0.000001 &amp;amp;&amp;amp; base &amp;lt; 0.000001 &amp;amp;&amp;amp; exponent &amp;lt; 0)  return 0;    if (exponent &amp;lt; 0)  {  absExponent = (unsigned int) (-exponent);  }   for (unsigned int i = 0; i &amp;lt; absExponent; &#43;&#43;i)  {  result *= base;  }   if (exponent &amp;lt; 0)  result = 1.0 / result;    return result; } 优化的方法，使用如下方法
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-17 下午2.42.37.png)
double powerOptimize(double base, int exponent) {  if (exponent == 0)  return 1;   if (exponent == 1)  return base;   double result = powerOptimize(base, exponent &amp;gt;&amp;gt; 1);  result *= result;   if ((exponent &amp;amp; 0x1) == 1)  result *= base;   return result; } 打印1到最大的n位数 输入数字 n，打印1到最大的 n 位十进制数
void printNdigits(unsigned int n) {  auto *digits = new char[n &#43; 1];  memset(digits, &amp;#39;0&amp;#39;, (n &#43; 1) * sizeof(char));  digits[n] = &amp;#39;\0&amp;#39;;   while (!incrementByone(digits))  {  printNumber(digits);  }  delete[] digits; }  bool incrementByone(char *digits) {  int length = strlen(digits);  bool isOverFlow = false;  int takeOver = 0;  int cur = 0;   for (auto i = length-1; i &amp;gt;= 0; --i)  {  cur = digits[i]-&amp;#39;0&amp;#39;&#43;takeOver;  if( i==length-1)  cur &#43;&#43;;   if(cur &amp;gt; 10)  {  if(i == 0)  isOverFlow = true;  else  {  cur -= 10;  digits[i]=&amp;#39;0&amp;#39;&#43;cur;  takeOver =1;  }   }  else  {  digits[i]=&amp;#39;0&amp;#39;&#43;cur;  break;  }  }   return isOverFlow; }  void printNumber(const char *digits) {  if (digits != nullptr)  {  while (*digits == &amp;#39;0&amp;#39;)  {  digits&#43;&#43;;  }  cout &amp;lt;&amp;lt; digits &amp;lt;&amp;lt; endl;  } } 递归方式，如果将前面的数字补0的话，就会发现n位所有十进制数其实就是n个从0开始到9的全排列，就是把数字从0到9排列一遍，就得到了十进制的全排列。
void newPrintNdigts(unsigned int n) {  auto *digits = new char[n &#43; 1];  digits[n] = &amp;#39;\0&amp;#39;;   for (int i = 0; i &amp;lt; 10; &#43;&#43;i)  {  digits[0] =char(i&#43;&amp;#39;0&amp;#39;);  recPrintNdigits(digits,n,0);  }  delete[] digits; }  void recPrintNdigits(char *digits, int length, int index) {  if(index == length-1)  {  printNumber(digits);  return;  }   for (int i = 0; i &amp;lt; 10; &#43;&#43;i)  {  digits[index&#43;1] = char(i&#43;&amp;#39;0&amp;#39;);  recPrintNdigits(digits,length,index&#43;1);  } } 在O(1)时间内删除节点 在 $O(1)$ 时间复杂度内删除某个节点,假设要删除的节点一定在链表中。如果删除的不是尾节点，则只要将它的下一个节点的数据移到该节点即可。
void deleteLinkedNode(LinkedNode * &amp;amp;root, LinkedNode * key) {  if( root == nullptr || key == nullptr || !isNodeInLinkedList(root, key))  return;   if(key-&amp;gt;next != nullptr) //删除的如果不是尾节点  {  LinkedNode * next = key-&amp;gt;next;  key-&amp;gt;data = next-&amp;gt;data;  key-&amp;gt;next = next-&amp;gt;next;  delete next;  next = nullptr;  }  else if( root-&amp;gt;next == nullptr) //删除的是尾节点，而且链表只有一个节点  {  delete root;  root = nullptr;  } else //删除的是尾节点，且链表不止一个节点  {  LinkedNode * pre = root;  LinkedNode * cur = root-&amp;gt;next;   while(cur != nullptr )  {  pre = cur;  cur = cur-&amp;gt;next;  }  pre-&amp;gt;next = nullptr;  delete cur;  cur = nullptr;  } } 链表中的倒数第 k 个节点 输入一个链表，输出该链表中的倒数第 k 个节点，其中链表的尾节点为倒数第1个节点。
基本思路是用两个指针，其中第一个游标先向前走k-1次，然后和另外一个游标一起往前走，如果第一个游标走到尾节点，那么第二个游标也就到了倒数第k个节点。
LinkedNode *findLastKthNodeFaster(LinkedNode *root, int k) {  if( root == nullptr || k &amp;lt;= 0)  return nullptr;   LinkedNode * cur = root;  LinkedNode * result = root;   for (int i = 0; i &amp;lt; k-1; &#43;&#43;i)  {  if (cur-&amp;gt;next != nullptr) //要考虑k的值是否超过了链表的总节点数目  cur = cur-&amp;gt;next;  else  return nullptr;  }  while (cur != nullptr)  {  cur = cur-&amp;gt;next;  result = result-&amp;gt;next;  }  return result; }  反转链表 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头结点。分为递归和非递归解法，非递归使用头插法即可
LinkedNode * reverseLinkedList(LinkedNode *pHead) {  if (pHead == nullptr)  return nullptr;   LinkedNode *newHead = pHead;  LinkedNode *cur = pHead-&amp;gt;next;  newHead-&amp;gt;next = nullptr;   LinkedNode *next = nullptr;   while (cur != nullptr)  {  next = cur-&amp;gt;next;  cur-&amp;gt;next = newHead;  newHead = cur;  cur = next;  }   return newHead; } 递归解法
LinkedNode *recurReversionLinkedList(LinkedNode *head) {  LinkedNode *cur = nullptr;  LinkedNode *tmp = nullptr;  LinkedNode *recurHead = nullptr;   if(head == nullptr)  {  return nullptr;  }   if(head-&amp;gt;next == nullptr)  return head;  else  {  cur = head;  tmp = head-&amp;gt;next;  recurHead = recurReversionLinkedList(tmp); //得到反转之后的头节点  tmp-&amp;gt;next = cur; //此时tmp就是最后一个节点了,应该将cur放到此时的最后一个节点tmp的后面  cur-&amp;gt;next = nullptr;  return recurHead;  } } 压缩字符串 给定一段字符串，仅压缩连续重复出现的字符，例如字符串abcbc压缩后为1a1b1c，xxxyyyyzz压缩后为3x4y2z
void compressString(const char *src) {  assert(src != nullptr);  auto length = strlen(src);   auto *result = new char[2 * length &#43; 1]; //当字符都不相同时，压缩后的字符串长度变为原来的2倍   int i = 0, j = 0, k = 0;  char cur;   while (src[i] != &amp;#39;\0&amp;#39;)  {  cur = src[i];  j = i &#43; 1;  while (src[j] == cur)  {  j&#43;&#43;;  }   result[k&#43;&#43;] = (char) (j - i &#43; &amp;#39;0&amp;#39;);  result[k&#43;&#43;] = cur;  i = j;  }  result[k] = &amp;#39;\0&amp;#39;;  cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; endl;  delete[] result; } 删除多余空格 在不开辟额外空间的情况下删除开始和结尾处的空格，并将中间的多个连续的空格合成一个。
void deleteSpaces2(char *str) {  auto length = strlen(str);  auto i = length - 1;  int j =0;   while (str[i] == &amp;#39; &amp;#39;) i--;  str[i&#43;1] = &amp;#39;\0&amp;#39;;   i = 0;  while (str[i] == &amp;#39; &amp;#39;) i&#43;&#43;;    while(str[i] != &amp;#39;\0&amp;#39;)  {  str[j&#43;&#43;] = str[i&#43;&#43;];   if(str[i] == &amp;#39; &amp;#39;)  {  while(str[i] == &amp;#39; &amp;#39;) i&#43;&#43;;  str[j&#43;&#43;] = &amp;#39; &amp;#39;;  }  }  str[j] = &amp;#39;\0&amp;#39;;  cout&amp;lt;&amp;lt;&amp;#34;***&amp;#34;&amp;lt;&amp;lt;str&amp;lt;&amp;lt;&amp;#34;***&amp;#34;&amp;lt;&amp;lt;endl; } 合并两个有序的链表 当得到两个链表中值较小的头节点并把它链接到已经合并的链表之后，两个链表剩余的节点依然是有序的，因此合并的步骤和之前的步骤一样。
LinkedNode *mergeOrderLinkedList(LinkedNode *head1, LinkedNode *head2) {  if (head1 == nullptr)  return head2;  else if (head2 == nullptr)  return head1;   LinkedNode *mergeHead = nullptr;   if (head1-&amp;gt;data &amp;lt;= head2-&amp;gt;data)  {  mergeHead = head1;  mergeHead-&amp;gt;next = mergeOrderLinkedList(head1-&amp;gt;next, head2);  } else  {  mergeHead = head2;  mergeHead-&amp;gt;next = mergeOrderLinkedList(head1, head2-&amp;gt;next);  }   return mergeHead; } 树的子结构 输入两棵二叉树 A 和 B，判断 B 是不是 A 的子树
bool hasSubTree(BinTreeNode *root1, BinTreeNode *root2) {  bool result = false;  if(root1 != nullptr &amp;amp;&amp;amp; root2 != nullptr )  {  if(root1-&amp;gt;data == root2-&amp;gt;data)  result = DoesTree1HasTree2(root1,root2);   if(false == result)  {  result = hasSubTree(root1-&amp;gt;leftChild,root2);  }   if(false == result)  {  result = hasSubTree(root1-&amp;gt;rightChild,root2);  }  }   return result; }  bool DoesTree1HasTree2(BinTreeNode *root1, BinTreeNode *root2) {  if(root2 == nullptr)  return true;  else if(root1 == nullptr)  return false;   if(root1-&amp;gt;data != root2-&amp;gt;data)  return false;    return DoesTree1HasTree2(root1-&amp;gt;rightChild,root2-&amp;gt;leftChild) &amp;amp;&amp;amp; DoesTree1HasTree2(root1-&amp;gt;rightChild,root2-&amp;gt;rightChild); } 树的镜像 先前序遍历这棵树的每一个节点，如果遍历到的节点有子节点则交换它们，当交换完所有的非叶子节点的左右子节点之后，就得到了树的镜像
void changeToMirror(BinTreeNode *root) {  if (root == nullptr)  return;   if (root-&amp;gt;leftChild == nullptr &amp;amp;&amp;amp; root-&amp;gt;rightChild == nullptr)  return;   BinTreeNode *tmp;  tmp = root-&amp;gt;leftChild;  root-&amp;gt;leftChild = root-&amp;gt;rightChild;  root-&amp;gt;rightChild = tmp;   if(nullptr != root-&amp;gt;leftChild)  changeToMirror(root-&amp;gt;leftChild);   if(nullptr != root-&amp;gt;rightChild)  changeToMirror(root-&amp;gt;rightChild); }  顺时针打印矩阵 void clockwisePrintMatrix(int **input, int columns, int rows) {  if (input == nullptr || columns &amp;lt; 0)  return;   int start = 0;  while (columns &amp;gt; start * 2 &amp;amp;&amp;amp; rows &amp;gt; start * 2) //打印进行的条件  {  printMatrixInCircle(input, columns, rows, start);  start&#43;&#43;;  } }  void printMatrixInCircle(int **input, int rows, int columns, int start) {  int endX = columns - 1 - start; //记录行的最右边  int endY = rows - 1 - start; //记录列的最下边   //从左往右打印一行  for (int i = start; i &amp;lt;= endX ; &#43;&#43;i)  {  cout&amp;lt;&amp;lt;input[start][i]&amp;lt;&amp;lt;&amp;#34;\t&amp;#34;;  }   //从上往下打印一列  for (int i = start&#43;1; i&amp;lt;= endY; &#43;&#43;i)  {  cout&amp;lt;&amp;lt;input[i][endX]&amp;lt;&amp;lt;&amp;#34;\t&amp;#34;;  }   for (int i = endX-1; i &amp;gt;=start ; --i)  {  cout&amp;lt;&amp;lt;input[endY][i]&amp;lt;&amp;lt;&amp;#34;\t&amp;#34;;  }   for (int i = endY-1; i &amp;gt; start ; --i)  {  cout&amp;lt;&amp;lt;input[i][start]&amp;lt;&amp;lt;&amp;#34;\t&amp;#34;;  }   cout&amp;lt;&amp;lt;endl; }  包含min函数的栈 定义栈的数据结构，在该类型中实现一个能够得到栈的最小元素的min函数。
利用一个辅助栈，每次将最小的元素（当前最小和入栈压入的新元素比较）都保存在这个辅助栈中。当弹出元素时，辅助栈中的元素也弹出一个。
判断正确的出栈序列 输入两个整数序列，第一个表示栈的压入顺序，第二个表示弹出序列，判断弹出序列是否是第一个压入序列的有效弹出序列。
使用一个辅助栈来保存压入序列，如果下一个弹出的数字刚好是栈顶数字，那么直接弹出，如果下一个弹出的数字不在栈顶，则把压栈序列中还未压入的数字压入到栈中，直到把下一个需要弹出的数字压入到栈顶为止，如果所有数字都压入到栈中了还未找到下一个弹出的数字，那么该序列就不是合法的弹出序列。
下面这个是针对与栈中元素是整型变量的：
bool isPopOrder(const int *pushOrder, const int *popOrder, int length) {  bool result = false;  const int *nextPush = pushOrder;  const int *nextPop = popOrder;  stack&amp;lt;int&amp;gt; st;   if (pushOrder != nullptr &amp;amp;&amp;amp; popOrder != nullptr &amp;amp;&amp;amp; length &amp;gt; 0)  {  while ((nextPop - popOrder) &amp;lt; length)  {  while (st.empty() || *nextPop != st.top())  {  if ((nextPush - pushOrder) == length)  break;   st.push(*nextPush);  nextPush&#43;&#43;;  }   if (st.top() != *nextPush)  break;   nextPop&#43;&#43;;  st.pop();  }   if (st.empty() &amp;amp;&amp;amp; (nextPop - popOrder == length))  result = true;  }   return result; } 这个是针对于栈中元素是字符型
bool isPopOrder(const char *pushOrder, const char *popOrder) {  bool result = false;  auto length = strlen(pushOrder);   if(popOrder != nullptr &amp;amp;&amp;amp; pushOrder != nullptr &amp;amp;&amp;amp; length == strlen(popOrder))  {  stack&amp;lt;char&amp;gt; st;  const char * nextPush = pushOrder;  const char * nextPop = popOrder;   while(*nextPop != &amp;#39;\0&amp;#39;)  {  while(st.empty() || *nextPop != st.top())  {  if(*nextPush == &amp;#39;\0&amp;#39;)  break;   st.push(*nextPush);  nextPush&#43;&#43;;  }   if(*nextPop != st.top())  break;   nextPop&#43;&#43;;  st.pop();  }   if(st.empty() &amp;amp;&amp;amp; *nextPop == &amp;#39;\0&amp;#39;)  result = true;  }   return result; }  二叉搜索树的后序遍历序列 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果，如果是则返回true，不是则返回false
bool verifySquenceOfBST(int *input, int length) {  bool result = false;   if (input == nullptr || length &amp;lt;= 0)  return result;   int cur = input[length - 1]; //根节点  int index = 0;  int mid = 0;   while (index &amp;lt; length &amp;amp;&amp;amp; input[index] &amp;lt; cur)  {  index&#43;&#43;;  }  mid = index;   while (index &amp;lt; length &amp;amp;&amp;amp; input[index] &amp;gt; cur)  {  index&#43;&#43;;  }   if (index == length - 1) //注意边界判断  {  bool left = false, right = false;  if (mid &amp;gt; 0)  left = verifySquenceOfBST(input, mid);   if (mid &amp;lt; length - 1)  right = verifySquenceOfBST(input &#43; mid, length - mid - 1);   result = left &amp;amp;&amp;amp; right;  }   return result; }  二叉树中从根开始和为某一值的路径 输入一棵二叉树和一个整数，打印二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到某一节点所经过的节点形成一条路径。
void findPath(BinTreeNode *root, int sum) {  if (root == nullptr)  return;   vector&amp;lt;char&amp;gt; path;  int currentSum = 0;  findPath(root, path, sum, currentSum); }  void findPath(BinTreeNode *root, vector&amp;lt;char&amp;gt; &amp;amp;path, int sum, int currentsum) {  currentsum &#43;= root-&amp;gt;data;  path.push_back(root-&amp;gt;data);  if (sum == currentsum)  {  for (auto it = path.begin(); it != path.end(); it&#43;&#43;)  {  cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#39;\t&amp;#39;;  }  cout &amp;lt;&amp;lt; endl;  }   if (root-&amp;gt;leftChild != nullptr)  {  findPath(root-&amp;gt;leftChild, path, currentsum, sum);  }   if (root-&amp;gt;rightChild != nullptr)  {  findPath(root-&amp;gt;rightChild, path, currentsum, sum);  }   path.pop_back(); } 不用vector算法的写法：
void printSumPath(BinTreeNode *root, char *path, int length, int sum) {  if (root == nullptr)  return;   path[length] = root-&amp;gt;data;  sum -= root-&amp;gt;data;  length&#43;&#43;;   if (0 == sum)  {  for (int i = 0; i &amp;lt;= length; &#43;&#43;i)  {  cout &amp;lt;&amp;lt; path[i];  }  cout &amp;lt;&amp;lt; endl;  }   if (root-&amp;gt;leftChild != nullptr)  {  printSumPath(root-&amp;gt;leftChild, path, length, sum);  }   if (root-&amp;gt;rightChild != nullptr)  {  printSumPath(root-&amp;gt;rightChild, path, length, sum);  }   length--; //减不减其实无所谓 }  二叉树中和为某一值的路径 一棵二叉树每个节点包含一个整数，设计一个算法输出所有满足条件的路径：在此路径上所有给定的节点之和为给定值，不必从根节点开始
void printSumPath(BinTreeNode *root, vector&amp;lt;char&amp;gt; &amp;amp;path, int sum, int level) {  if(root != nullptr)  {  path.push_back(root-&amp;gt;data);   int currentSum = sum;   for (int i = level; i &amp;gt;=0; &#43;&#43;i)  {  currentSum-=path[i];   if(currentSum == 0)  printSumPath(path,i,level);  }  level&#43;&#43;;  if(root-&amp;gt;leftChild != nullptr)  printSumPath(root-&amp;gt;leftChild,path,sum,level);   if(root-&amp;gt;rightChild != nullptr)  printSumPath(root-&amp;gt;rightChild,path,sum,level);   path.pop_back();  } }  void printSumPath(vector&amp;lt;char&amp;gt; path, int start, int end) {  for (int i = start; i &amp;lt;= end; &#43;&#43;i)  {  cout&amp;lt;&amp;lt;path[i]&amp;lt;&amp;lt;&amp;#39;\t&amp;#39;;  }  cout&amp;lt;&amp;lt;endl; }  </content>
    </entry>
    
     <entry>
        <title>C&#43;&#43;智能指针</title>
        <url>https://iihui.github.io/post/cpp-smart-pointer/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>C&#43;&#43;</tag>
        </tags>
        <content type="html">  智能指针是一个类，它对普通指针进行封装，使智能指针类对象具有普通指针类型一样的操作。具体而言，复制对象时，副本和原对象都指向同一存储区域，如果通过一个副本改变其所指的值，则通过另一对象访问的值也会改变。与普通指针所不同的是，智能指针能够对内存进行进行自动管理，避免出现悬垂指针等情况。
 普通指针 对于普通指针，当有多个指针指向同一个基础对象时，如果某个指针delete了该基础对象，对这个指针来说已经明确说明它所指的对象被释放掉了，所以它不会再对所指对象进行操作。但是，对于剩下的指向同一个基础对象的指针来说，它们依然指向已经被删除的基础对象并随时准备对它进行操作，于是悬垂指针就形成了。
int * ptr1 = new int (1); int * ptr2 = ptr1; int * ptr3 = prt2;  cout &amp;lt;&amp;lt; *ptr1 &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; *ptr2 &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; *ptr3 &amp;lt;&amp;lt; endl;  delete ptr1; cout &amp;lt;&amp;lt; *ptr2 &amp;lt;&amp;lt; endl; ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-13 下午4.12.02.png)
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-13 下午4.12.12.png)
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-13 下午4.12.32.png)
从图可以看出，错误的产生来自于ptr1的“无知”：它并不知道还有其他指针共享着它指向的对象。如果有个办法让ptr1知道，除了它自己外还有两个指针指向基础对象，而它不应该删除基础对象，那么悬垂指针的问题就得以解决了。
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-13 下午4.14.30.png)
 引用计数 如何来让指针知道还有其他指针的存在呢？这个时候该引入引用计数的概念了。引用计数是这样一个技巧，它允许有多个相同值的对象共享这个值的实现。引用计数的使用常有两个目的：
  一旦一个对象通过调用new被分配出来，记录谁拥有这个对象是很重要的，因为其所有者要负责对它进行delete。但是对象所有者可以有多个，且所有权能够被传递，这就使得内存跟踪变得困难。引用计数可以跟踪对象所有权，并能够自动销毁对象。可以说引用计数是个简单的垃圾回收体系。
  节省内存，提高程序运行效率。如果很多对象有相同的值，为这多个相同的值存储多个副本是很浪费空间的，所以最好做法是让左右对象都共享同一个值的实现。C&#43;&#43;标准库中string类采取一种称为“写时复制”的技术，使得只有当字符串被修改的时候才创建各自的拷贝，否则可能（标准库允许使用但没强制要求）采用引用计数技术来管理共享对象的多个对象。
   智能指针实现 智能指针的实现策略有两种：辅助类与句柄类，这里介绍辅助类实现
基础类 class Point { public:  Point(int xVal = 0, int yVal = 0) :x(xVal), y(yVal) { }  int getX() const { return x; }  int getY() const { return y; }  void setX(int xVal) { x = xVal; }  void setY(int yVal) { y = yVal; }  private:  int x, y; };  辅助类 在创建智能指针类之前，我们先创建一个辅助类。这个类的所有成员皆为私有类型，因为它不被普通用户所使用。为了只为智能指针使用，还需要把智能指针类声明为辅助类的友元。这个辅助类含有两个数据成员：计数count与基础对象指针。也即辅助类用以封装使用计数与基础对象指针。
class U_Ptr { private:   friend class SmartPtr;  U_Ptr(Point *ptr) :p(ptr), count(1) { }  ~U_Ptr() { delete p; }   int count;  Point *p; };  智能指针类 引用计数是实现智能指针的一种通用方法。智能指针将一个计数器与类指向的对象相关联，引用计数跟踪共有多少个类对象共享同一指针。它的具体做法如下：
  当创建类的新对象时，初始化指针，并将引用计数设置为1
  当对象作为另一个对象的副本时，复制构造函数复制副本指针，并增加与指针相应的引用计数（加1）
  使用赋值操作符对一个对象进行赋值时，处理复杂一点：先使左操作数的指针的引用计数减1（因为指针已经指向别的地方），如果减1后引用计数为0，则释放指针所指对象内存。然后增加右操作数所指对象的引用计数（为何增加：因为此时做操作数指向对象即右操作数指向对象）。
  析构函数：调用析构函数时，析构函数先使引用计数减1，如果减至0则delete对象。
  class SmartPtr {  public:  SmartPtr(Point *ptr) : rp(new U_Ptr(ptr)) {}  SmartPtr(const SmartPtr &amp;amp;sp) : rp(sp.rp) { &#43;&#43;rp-&amp;gt;count; }  SmartPtr &amp;amp;operator=(const SmartPtr &amp;amp;rhs) {  &#43;&#43;rhs.rp-&amp;gt;count;  if (--rp-&amp;gt;count == 0) delete rp;  rp = rhs.rp;  return *this;  }  ~SmartPtr() {  if (--rp-&amp;gt;count == 0)  delete rp;  else  cout &amp;lt;&amp;lt; &amp;#34;还有&amp;#34; &amp;lt;&amp;lt; rp-&amp;gt;count &amp;lt;&amp;lt; &amp;#34;个指针指向基础对象&amp;#34; &amp;lt;&amp;lt; endl;  }   private:  U_Ptr *rp; };  使用与测试 int main() {  Point *pa = new Point(10, 20); //定义一个基础对象类指针  //定义三个智能指针类对象，对象都指向基础类对象pa  //使用花括号控制三个指针指针的生命期，观察计数的变化  {  SmartPtr sptr1(pa); //此时计数count=1  {  SmartPtr sptr2(sptr1); //调用复制构造函数，此时计数为count=2  {  SmartPtr sptr3 = sptr1; //调用赋值操作符，此时计数为conut=3  } //此时count=2  } //此时count=1；  } //此时count=0；pa对象被delete掉  cout &amp;lt;&amp;lt; pa-&amp;gt;getX() &amp;lt;&amp;lt; endl;   return 0; }  改进一 虽然此时的SmartPtr类称为智能指针，但它目前并不能像真正的指针那样有-&amp;gt;、*等操作符，为了使它看起来更像一个指针，我们来为它重载这些操作符。代码如下所示：
class SmartPtr { public:  SmartPtr(Point *ptr) :rp(new U_Ptr(ptr)) { }  SmartPtr(const SmartPtr &amp;amp;sp) :rp(sp.rp) { &#43;&#43;rp-&amp;gt;count; }  SmartPtr&amp;amp; operator=(const SmartPtr&amp;amp; rhs) {  &#43;&#43;rhs.rp-&amp;gt;count;  if (--rp-&amp;gt;count == 0)  delete rp;  rp = rhs.rp;  return *this;  }  ~SmartPtr() {  if (--rp-&amp;gt;count == 0)  delete rp;  else  cout &amp;lt;&amp;lt; &amp;#34;还有&amp;#34; &amp;lt;&amp;lt; rp-&amp;gt;count &amp;lt;&amp;lt; &amp;#34;个指针指向基础对象&amp;#34; &amp;lt;&amp;lt; endl;  }   Point &amp;amp; operator *() //重载*操作符  {  return *(rp-&amp;gt;p);  }  Point* operator -&amp;gt;() //重载-&amp;gt;操作符  {  return rp-&amp;gt;p;  } private:  U_Ptr *rp; };  改进二 目前这个智能指针智能用于管理Point类的基础对象，如果此时定义了个矩阵的基础对象类，那不是还得重新写一个属于矩阵类的智能指针类吗？但是矩阵类的智能指针类设计思想和Point类一样啊，就不能借用吗？答案当然是能，那就是使用模板技术。
//模板类作为友元时要先有声明 template &amp;lt;typename T&amp;gt; class SmartPtr;  template &amp;lt;typename T&amp;gt; class U_Ptr //辅助类 {  private:  //该类成员访问权限全部为private，因为不想让用户直接使用该类  friend class SmartPtr&amp;lt;  T&amp;gt;; //定义智能指针类为友元，因为智能指针类需要直接操纵辅助类   //构造函数的参数为基础对象的指针  U_Ptr(T *ptr) : p(ptr), count(1) {}   //析构函数  ~U_Ptr() { delete p; }  //引用计数  int count;   //基础对象指针  T *p; };  template &amp;lt;typename T&amp;gt; class SmartPtr //智能指针类 {  public:  SmartPtr(T *ptr) : rp(new U_Ptr&amp;lt;T&amp;gt;(ptr)) {} //构造函数  SmartPtr(const SmartPtr&amp;lt;T&amp;gt; &amp;amp;sp) : rp(sp.rp) { &#43;&#43;rp-&amp;gt;count; } //复制构造函数  SmartPtr &amp;amp;operator=(const SmartPtr&amp;lt;T&amp;gt; &amp;amp;rhs) { //重载赋值操作符  &#43;&#43;rhs.rp-&amp;gt;count; //首先将右操作数引用计数加1，  if (--rp-&amp;gt;count == 0) //然后将引用计数减1，可以应对自赋值  delete rp;  rp = rhs.rp;  return *this;  }   T &amp;amp;operator*() //重载*操作符  {  return *(rp-&amp;gt;p);  }  T *operator-&amp;gt;() //重载-&amp;gt;操作符  {  return rp-&amp;gt;p;  }   ~SmartPtr() { //析构函数  if (--rp-&amp;gt;count ==  0) //当引用计数减为0时，删除辅助类对象指针，从而删除基础对象  delete rp;  else  cout &amp;lt;&amp;lt; &amp;#34;还有&amp;#34; &amp;lt;&amp;lt; rp-&amp;gt;count &amp;lt;&amp;lt; &amp;#34;个指针指向基础对象&amp;#34; &amp;lt;&amp;lt; endl;  }   private:  U_Ptr&amp;lt;T&amp;gt; *rp; //辅助类对象指针 };  </content>
    </entry>
    
     <entry>
        <title>Go 中映射(字典）</title>
        <url>https://iihui.github.io/post/go-map/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html">  映射(或称为字典)是一种数据结构，用于存储一系列无序的键值对，它是基于键来存储值。映射的键可以是任何值，只要这个值可以使用==运算符做比较即可。切片、函数以及包含切片的结构类型这些类型由于具有引用语义， 不能作为映射的键。
 创建和初始化 使用make函数 //创建一个映射，键的类型是string，值的类型是int dict1 := make(map[string]int) dict2 := make(map[string]int,5) //长度为5  使用字面量 // 创建一个映射，键和值的类型都是 string，使用两个键值对初始化映射 dict2 := map[string]string{&amp;#34;Red&amp;#34;: &amp;#34;#da1337&amp;#34;, &amp;#34;Orange&amp;#34;: &amp;#34;#e95a22&amp;#34;} 需要注意的是，直接使用var m map[string][int]这种方式定义的map变量的初始值为nil,并且这个变量是只能读不能写的，也就是说可以按照键来读值，读出来是类型的默认零值，但是不可以往里面添加键值对，否则会产生一个运行时错误。
// 通过声明映射创建一个 nil 映射 var colors map[string]string  // 将 Red 的代码加入到映射 colors[&amp;#34;Red&amp;#34;] = &amp;#34;#da1337&amp;#34; //产生运行时错误  //Runtime Error: //panic: runtime error: assignment to entry in nil map 相比于值为nil的映射，空映射有初始化过程，但是映射此时的容量为0，此时的映射是可以用来存储键值对的：
// 创建一个空映射，用来存储颜色以及颜色对应的十六进制代码 colors := map[string]string{} //空映射 // 将 Red 的代码加入到映射 colors[&amp;#34;Red&amp;#34;] = &amp;#34;#da1337&amp;#34; 内容为空的映射与nil是不同的，空映射可以添加键值，nil字典不可以添加键值：
var m1 map[string]int //nil映射 m2 := map[string]int{} //空映射  println(m1==nil,m2==nil)//true false  使用映射 映射的使用包括：①根据键来取值——通常要通过ok-idiom模式来判断给定的键是否有值； ②作为函数参数——因为是引用类型，因此函数中做的更改可以影响被调函数中原引用的值。
根据键取值 value, exists := colors[&amp;#34;Blue&amp;#34;] // 这个键存在吗？，这就是ok-idiom模式  if exists {  fmt.Println(value)  } // 创建一个映射，存储颜色以及颜色对应的十六进制代码 colors := map[string]string{ &amp;#34;AliceBlue&amp;#34;: &amp;#34;#f0f8ff&amp;#34;, &amp;#34;Coral&amp;#34;: &amp;#34;#ff7F50&amp;#34;, &amp;#34;DarkGray&amp;#34;: &amp;#34;#a9a9a9&amp;#34;, &amp;#34;ForestGreen&amp;#34;: &amp;#34;#228b22&amp;#34;, }  // 显示映射里的所有颜色 for key, value := range colors {  fmt.Printf(&amp;#34;Key: %s Value: %s\n&amp;#34;, key, value) } 作为函数参数 因为映射是引用类型，在函数间传递映射并不会制造出该映射的一个副本。实际上，当传递映射给一个函数，并对这个映射做了修改时，所有对这个映射的引用都会察觉到这个修改。
colors := map[string]string{ 	&amp;#34;AliceBlue&amp;#34;:&amp;#34;#f0f8ff&amp;#34;, 	&amp;#34;Coral&amp;#34;:&amp;#34;#ff7F50&amp;#34;, 	&amp;#34;DarkGray&amp;#34;:&amp;#34;#a9a9a9&amp;#34;, 	&amp;#34;ForestGreen&amp;#34;: &amp;#34;#228b22&amp;#34;, }  // 显示映射里的所有颜色 for key, value := range colors { 	fmt.Printf(&amp;#34;Key: %s Value: %s\n&amp;#34;, key, value) }  // 调用函数来移除指定的键 removeColor(colors, &amp;#34;Coral&amp;#34;)  // 显示映射里的所有颜色  for key, value := range colors { 	fmt.Printf(&amp;#34;Key: %s Value: %s\n&amp;#34;, key, value) }   func removeColor(colors map[string]string, key string) { 	delete(colors, key) }  注意事项 字典map是无序的，每次打印出来的结果都会不一样，不能通过index获取（下标获取）只能通过key获取
字典要求key必须支持相等运算符==,!=的数据类型，所以切片以及包含切片的结构体不能为key。键的值，可以是数字、字符串、指针、数组、结构体以及接口类型。
内置的len函数返回key的数量，不可以使用cap（即cap不接受字典类型，因为它没有容量的概念）。
map的初始化可以通过key:val的方式初始化：
rating := map[string]float32{&amp;#34;C&amp;#34;: 5, &amp;#34;Go&amp;#34;: 1.83} fmt.Println(rating) //map[C:5 Go:1.83] map是一种引用类型，如果两个map同时指向同一个底层，那么一个改变，另一个也改变。
m := make(map[string]string) m[&amp;#34;Hello&amp;#34;] = &amp;#34;hello&amp;#34; m1 := m m1[&amp;#34;Hello&amp;#34;] = &amp;#34;world&amp;#34; fmt.Println(m, m1) //map[Hello:world] map[Hello:world] 访问不存在的键值，默认返回的是value的默认零值，不会引发错误，但推荐使用ok-idiom模式。
m := make(map[string]bool) m[&amp;#34;chen&amp;#34;] = true fmt.Println(m[&amp;#34;xiao&amp;#34;]) //默认零值false 当value是结构体或者数组时，不能直接修改value中的成员，正确的做法是返回整个value，待修改后再设置字典键值，或直接用指针类型。
type user struct { 	name string 	age byte } m := map[int]user{ 	1: {&amp;#34;Tom&amp;#34;, 19}, }  m[1].age = 20 //错误,结构体的value不能直接修改  u := m[1] //先取出来，在改变value的值，然后再根据索引改变map中value的值 u.age = 20 m[1] = u 不能对nil字典进行写操作，但却能读，读出来的value是其类型对应的零值。
println(m[&amp;#34;a&amp;#34;]) m[&amp;#34;a&amp;#34;] = 1 //错误 内容为空的字典与nil是不同的，内容为空的字典可以添加键值，但是nil字典不可以。
var m1 map[string]int m2 := map[string]int{}  println(m1 == nil, m2 == nil) //true false 在迭代期间(for range)删除或者新增键值是安全的，但是在运行时会对字典并发操作作出检测，如果某个任务正在对字典进行写操作，那么其他任务就不能对该字典进行并发操作（读，写，删除）否则会导致进程崩溃，即是所谓的线程不安全的。
应该使用make来创建map，永远不要使用new来创建map，因为map是引用类型，需要初始化某些东西，而new是将内存清0。
map中的value可以是任意类型，包括函数：
a6 := map[int]func() int{ 	1: func() int { return 1 }, 	2: func() int { return 2 }, 	3: func() int { return 3 }, }  fmt.Println(a6) //map[1:0x10982f0 2:0x1098300 3:0x1098310] map的长度是不固定的，可以根据key-value动态的伸缩，因此不存在固定长度和最大长度「但受内存限制」。如果提前能预估key-value的个数，可以在使用make指定长度，这样可以减少因为动态增长key-value带来的性能消耗问题。m:=make(map[string]int,10)
如果一个key要对应多个value，这时候建议将slice作为value。例如，当要处理unix机器上的所有进程，以父进程（pid为整型变量）作为 key，所有的子进程（以所有子进程的pid组成的切片）作为value。
使用delete(map1, key1)从map中删除键值对，如果key1不存在，该操作不会产生错误。
假设我们想获取一个map类型的切片，我们必须使用两次make函数，第一次分配切片，第二次分配切片中每个map元素。
items := make([]map[int]int, 5) //注意写法 for i := range items { 	items[i] = make(map[int]int, 1)  	items[i][1] = 2 } fmt.Printf(&amp;#34;Version A: Value of items: %v\n&amp;#34;, items) map默认是无序的，不管是按照key还是按照value默认都不排序；这与C&#43;&#43;中的map有很大区别。
 </content>
    </entry>
    
     <entry>
        <title>Go 切片</title>
        <url>https://iihui.github.io/post/go-slice/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html"> 定义 切片是围绕动态数组的概念来构建的，但是本身并非动态数组或数组指针，它通过内部指针引用底层数组，设定相关属性，将数据读写操作限定到指定区域。切片这个名字来自于——创建一个新的切片就是把底层数组切出一部分。
type slice struct{  array unsafe.Pointer // slice中指向底层数组指定位置的的指针  len int // slice 的长度  cap int //slice 容量，即最大长度，就是slice开始位置到数组的最后位置的长度 } ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-03 下午3.38.29.png)
 声明和初始化 使用make 一种创建切片的方法是使用内置的切片的长度，如下所示使用make函数。当使用make时，需要传入一个参数，指定长度：
slice1 := make([]string, 5) //只指定长度，切片的长度和容量相等，均为5 slice2 := make([]int, 3, 5) //分别指定长度和容量，长度为3，容量为5 make在创建切片的时候，可以指定两个长度信息，分别表示切片的当前长度和容量大小「概念参考C&#43;&#43;标准库中的vector。不允许创建容量小于长度的切片，否则会出现编译错误。
 利用字面量 另一种常用的创建切片的方法是使用切片字面量。这种方法和创建数组类似，只是不需要指定[]运算符里的值。初始的长度和容量会基于初始化时提供的元素的个数确定。
// 创建字符串切片，其长度和容量都是 5 个元素 slice1 := []string{&amp;#34;Red&amp;#34;, &amp;#34;Blue&amp;#34;, &amp;#34;Green&amp;#34;, &amp;#34;Yellow&amp;#34;, &amp;#34;Pink&amp;#34;} // 创建一个整型切片，其长度和容量都是 3 个元素 slice2 := []int{10, 20, 30} 如果在 [] 运算符里指定了一个值，那么创建的就是数组而不是切片。
// 创建有 3 个元素的整型数组 array := [3]int{10, 20, 30} // 创建长度和容量都是 3 的整型切片 slice := []int{10, 20, 30} 当使用切片字面量时， 可以设置初始长度和容量，即在就是在初始化时给出所需的长度和容量作为索引：
// 创建字符串切片，使用空字符串初始化第 100 个元素 slice := []string{99: &amp;#34;&amp;#34;} //最大的索引是99，因此长度为99&#43;1 fmt.Println(len(slice1),cap(slice1)) //长度为100，容量也为100  从已知切片创建 切片可以从一个数组中获取，前提是这个数组必须是可寻址的。切片通过array[i:j]来获取，表示的区间是[i,j)即前闭后开区间，长度为j-i，对于底层数组容量为k的数组来说，切片slice[i:j]的容量为k-i。
var arr =[10]byte{&amp;#39;a&amp;#39;,&amp;#39;b&amp;#39;,&amp;#39;c&amp;#39;,&amp;#39;d&amp;#39;} //array 声明长度 var a,b []byte //slice，方括号里不声明长度 a = arr[1:3] //前闭后开,长度为2,容量为9 b = arr[2:4] //前闭后开，长度为2，容量为8 fmt.Println(a,b) //[98 99] [99 100] 或者从一个已经存在的的切片中再次声明，即将原切片看成是[cap]slice,据此创建的新切片对象不能超出cap。
// 创建一个整型切片，其长度和容量都是 5 slice := []int{10, 20, 30, 40, 50} // 创建一个新切片，其长度为 2 个元素，容量为 4 newSlice := slice[1:3] ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-03 下午4.41.43.png)
 nil切片 在声明切片时不做任何初始化，就会创建一个nil切片，nil切片无底层数组，因此不可按下标访问。nil切片变为正常的切片有两种方式：①利用赋值。 ②使用append函数。
var slice []int //不做任何初始化，创建的为nil切片 fmt.Println(slice==nil) //true ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-03 下午4.27.26.png)
 空切片 空切片相对于nil切片而言，已经完成了初始化——即其内部指针已经被赋值为非0，而nil切片内部的指针为nil。但是，空切片的len(s)和cap(s)的值都为0。
// 使用 make 创建空的整型切片 slice1 := make([]int, 0) //空切片 // 使用切片字面量创建空的整型切片 slice2 := []int{} //nil切片 fmt.Println(slice1==nil,slice2==nil)//false false ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-03 下午4.29.26.png)
 注意 切片是引用类型 切片是引用类型，所以当引用改变其中元素的值时，其他所有引用都会改变该值：
var arr =[10]byte{81,82,83,84,85,86} //array var a,b,c [] byte //nil slice  a = arr[1:3] b = arr[2:4] fmt.Println(a,b) //[98 99] [99 100]  c = a[0:2] //c切片来自于切片a，切片a发生变化时，c就会跟着变化 fmt.Println(c) //[82,83]  a = arr[1:5] fmt.Println(a,c) //[82 83 84 85] [82 83] slice := []int{10, 20, 30, 40, 50} newSlice := slice[1:3] fmt.Println(slice,newSlice)//[10 20 30 40 50] [20 30] // 修改newSlice索引为1的元素，同时也修改了原来的 slice 的索引为 2 的元素 newSlice[1] = 35 fmt.Println(slice,newSlice) //[10 20 35 40 50] [35 88] ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-03 下午4.42.59.png)
 索引越界 索引越界会引发运行时错误：
// 创建一个整型切片，其长度和容量都是 5 个元素 slice := []int{10, 20, 30, 40, 50} // 创建一个新切片，其长度为 2 个元素，容量为 4 个元素 newSlice := slice[1:3] // 修改newSlice索引为3的元素，这个元素对于newSlice来说并不存在 newSlice[3] = 45 //因为newSlice的长度为2，因此索引只包括0，1 // 这个切片操作试图设置容量为4，这比可用的容量大 source := []string{&amp;#34;Apple&amp;#34;, &amp;#34;Orange&amp;#34;, &amp;#34;Plum&amp;#34;, &amp;#34;Banana&amp;#34;, &amp;#34;Grape&amp;#34;} slice := source[2:3:6] //容量大于已有容量，因为包括2在内的索引为2，3，4，只有3个元素了  切片增长 使用append向slice里面追加一个或者多个元素，总是会增加新切片的长度，而容量有可能会改变，这取决于被操作的切片的可用容量。
使用append会返回一个和原slice一样类型的slice。并且会改变slice所引用的数组的内容，从而影响到引用同一数组的其他slice。因此使用append函数可能会影响之前的切片。
// 创建一个整型切片，其长度和容量都是 5 个元素 slice := []int{10, 20, 30, 40, 50}  // 创建一个新切片，其长度为 2 个元素，容量为 4 个元素 newSlice := slice[1:3] //[20 30] fmt.Println(slice,newSlice)//[10 20 30 40 50] [20 30]  // 使用原有的容量来分配一个新元素，将新元素赋值为 60 newSlice = append(newSlice, 60) //替换 slice 中 40 为 60 fmt.Println(slice,newSlice) //[10 20 30 60 50] [20 30 60] ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-03 下午5.04.54.png)
如果切片的底层数组没有足够的可用容量——是指超出切片的cap限制，而非底层数组长度限制，因为数组长度len可小于数组容量cap。此时，append 函数会创建一个新的底层数组，将被引用的现有的值复制到新数组里，再追加新的值：
// 创建一个整型切片其长度和容量都是 4 个元素 slice := []int{10, 20, 30, 40} // 向切片追加一个新元素 fmt.Println(slice) //[10 20 30 40] newSlice := append(slice, 50)// 将新元素赋值为 50 fmt.Println(slice,newSlice)//[10 20 30 40] [10 20 30 40 50] 当这个append操作完成后， 拥有一个全新的底层数组，这个数组的容量是原来的两倍「新分配的底层数组是原cap的2倍，而非原数组的2倍」，此外新分配时并非总是2倍，对于较大的切片，会尝试扩容1/4，以节约内存。
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-03 下午5.34.08.png)
在切片的容量小于1000个元素时，总是会成倍地增加容量。一旦元素个数超过1000，容量的增长因子会设为1.25，也就是会每次增加25%的容量。随着语言的演化，这种增长算法可能会有所改变。
因此在对切片使用append函数时，要特别注意是否超出了容量，如果超出了容量，则会创建一个新的底层数组
 迭代切片 当迭代切片时，关键字range会返回两个值。第一个值是当前迭代到的索引位置(下标），第二个值是该位置对应元素值的一份副本。
slice := []int{10, 20, 30, 40} // 迭代每一个元素，并显示其值 for index, value := range slice {  fmt.Printf(&amp;#34;Index: %d Value: %d\n&amp;#34;, index, value) } ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-03 下午5.45.17.png)
使用for-range迭代数组和切片有很重要的区别，如下所示：
data :=[3] int{10,20,30} for i,x := range data { //更新数组的值之后,x的值不起作用,猜测是另外使用了一个数组来复制原数组，因为数组不是引用类型 	if i == 0{ 	data[0] &#43;= 100 	data[1] &#43;= 200 	data[2] &#43;= 300 	} 	fmt.Println(x,data[i]) }//10 110 20 220 30 330   for i,x := range data[:] { //更新引用中的值之后,x的值在下一轮立即起作用 	if i == 0{ 	data[0] &#43;= 100 	data[1] &#43;= 200 	data[2] &#43;= 300 	} 	fmt.Println(x,data[i]) }//110 210 420 420 630 630  函数参数为切片 由于与切片关联的数据包含在底层数组里，不属于切片本身，所以将切片复制到任意函数的时候，对底层数组大小都不会有影响，复制时只会复制切片本身，不会涉及底层数组，但是操作时可能改变顶层数组。
// 分配包含 100 万个整型值的切片 slice := make([]int, 1e6) // 将 slice 传递到函数 foo slice = foo(slice) // 函数 foo 接收一个整型切片，并返回这个切片 func foo(slice []int) []int { ... return slice } ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-03 下午5.54.25.png)
在函数间传递24字节（64位机器）的数据会非常快速、简单。这也是切片效率高的地方。不需要传递指针和处理复杂的语法，只需要复制切片，按想要的方式修改数据，然后传递回一份新的切片副本。
 </content>
    </entry>
    
     <entry>
        <title>Go 数组</title>
        <url>https://iihui.github.io/post/go-array/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html"> 定义 在Go语言里，数组是一个长度固定的数据类型，用于连续存储多个具有相同的类型的元素。数组存储的类型可以是内置类型，如整型或者字符串，也可以是某种结构类型。
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-03 下午3.13.38.png)
 声明和初始化 声明 声明数组时需要指定内部存储的数据的类型，以及需要存储的元素的数量，这个数量也称为数组的长度。数组长度必须是一个常量表达式，并且是一个非负数，数组长度最大为2Gb。
var a [5]int //[5]与int紧贴 一旦声明，数组里存储的数据类型和数组长度就都不能改变了。如果需要存储更多的元素， 就需要先创建一个更长的数组，再把原来数组里的值复制到新数组里。
在Go语言中声明变量时，总会使用对应类型的零值来对变量进行初始化。数组也不例外。 当数组初始化时，数组内每个元素都初始化为对应类型的零值。
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-03 下午3.16.38.png)
 初始化 如果使用...替代数组的长度，Go语言会根据初始化时数组元素的数量来确定该数组的长度。
array1 := [5]int{10,20,30,40,50} //前面的数字5来确定数组的长度 array2 := [...]int{1,2,3,4,5} //后面的数据元素来确定数组的长度 // var array3 [...]int =[...]int{12,35.89}这种方式是不行的， //也就是说[...]int 声明数组的时候，[...]int只能出现在=的右边，不能在左边出现 如果知道数组的长度，并且准备给每个值都指定具体值，就可以使用如下的形式来声明数组：
array :=[5]int{1:10,2:20} //数组长度已知，给数组中某些元素赋予特殊的值 ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-08-03 下午3.21.09.png)
array := [4][2]int{1: {20, 21}, 3: {40, 41}}  注意事项   使用下标来访问数组时，因为会检测下标的大小，所以一旦超出了数组的长度，那么会给出提示；如果没有检测到超出范围而实际上超出了数组长度，则运行时会panic。
  数组变量的类型包括数组长度和每个元素的类型。只有这两部分都相同的数组，才是类型相同的数组，才能相互赋值。
  多维数组的类型包括每一维度的长度以及数据的类型。
  在函数之间传递变量时，总是以值的方式传递的。如果这个变量是一个数组，意味着整个数组，不管有多长都会完整复制，并传递给函数。如果数组长度很大的话，会影响性能，此时建议使用切片。
var array [1e6]int // 将数组传递给函数 foo foo(array) // 函数 foo 接受一个 100 万个整型值的数组 func foo(array [1e6]int) { ... }   定义数组时，数组长度必须是非负整型常量表达式，长度是类型的组成部分，也就是说元素类型相同，但长度不同的数组不属于同一类型。
var d1 [3] int var d2 [4] int d1 = d2 //错误， d1 和 d2 不属于同一类型，不能赋值，不能比较   未提供初始化值的元素自动初始化为类型零值。
var d1 [3] int //初始化为[0 0 0] var d2 [4] int //初始化为[0 0 0 0] d3 := [5]int{2,3,4} //初始化为 [2 3 4 0 0] fmt.Println(d1,d2,d3) //[0 0 0] [0 0 0 0] [2 3 4 0 0]   数组初始化时，可指定位置进行初始化，只要不超出数组的长度范围即可。
d4 := [4]int{5,3:10} //[5 0 0 10]   编译器可以按照初始化值的数量确定数组长度，数组在声明的时候使用[...]即可
d5 := [...]int{34,8,9} //长度为3 d6 := [...]int{5,3:10} //长度为4，内容为[5 0 0 10]   在定义多维数组时，仅第一维可以允许使用...，即省略第1维的长度。
  内置函数len和cap可以返回第一维长度
d7 :=[3][4]int {{2},{3}} fmt.Println(len(d7),cap(d7)) //3,3 返回的是第一维的长度   如果数组中的元素支持==，！= 等操作符，那么数组也支持该操作。
var d1 [4] int //d1数组中元素全部为0 var d2 [4] int //d2数组中元素全部为0 d3 := [4]int{2,3,4} d4 := [4]int{5,3:10} fmt.Println(d1==d2,d3==d4) //true false   分清指针数组和数组指针：数组的地址为数组指针，而数组中的元素类型为指针则为数组指针。
d11,d12:=20,10 d13:=[...]*int{&amp;amp;d11,&amp;amp;d12} //指针数组 d14:=&amp;amp;d13 //数组指针 fmt.Println(d13,d14) //[0xc420072250 0xc420072258] &amp;amp;[0xc420072250 0xc420072258]   可以获取数组中任意元素的地址，只要在数组元素前加&amp;amp;即可。
d4 := [4]int{5,3:10} fmt.Println(&amp;amp;d4,&amp;amp;d4[0],&amp;amp;d4[3])//&amp;amp;[5 0 0 10] 0xc4200680e0 0xc4200680f8    </content>
    </entry>
    
     <entry>
        <title>Go 未命名类型</title>
        <url>https://iihui.github.io/post/go-undef-type/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html"> 未命名类型 在Go中数组、切片、字典、通道类型与具体元素类型或长度属性相关，故被称为未命名类型。具有相同声明的未命名类型被称为同一类型，在 Go 中未命名类型共有8类。
  具有相同基础类型的指针
  具有相同元素类型和长度的数组array
  具有相同元素类型的切片slice
  具有相同键和值类型的字典map
  具有相同数据类型以及操作方向的通道channel
  具有相同字段序列（字段名、字段类型、标签以及字段顺序）的结构体struct
  具有相同签名的（参数和返回值列表，不包括参数名）的函数func，其中函数的参数顺序也属于签名的组成部分
  具有相同方法集（方法名，方法签名，不包括顺序）的接口interface
  容易被忽略的是struct tag它属于类型组成的一部分，而不仅仅是元数据描述
  var a struct{  x int `x`  s string `s`  }  var b struct{  x int  s string }  b=a //cannot use a (type struct { x int &amp;#34;x&amp;#34;; s string &amp;#34;s&amp;#34; })  //as type struct { x int; s string } in assignment fmt.Println(b) 未命名类型的转换规则   所属类型完全相同
  基础类型相同，其中一个是未命名类型
  数据类型相同，将双向通道赋值给单向通道，且其中一个是未命名类型
 type data [2]int //data是使用数组新定义的类型  var d data =[2]int{1,2} //基础类型相同，其中一个是未命名类型   doubleChan := make(chan int,3) //双向通道  var singleChan chan&amp;lt;- int = doubleChan //双向通道赋值给单向通道   </content>
    </entry>
    
     <entry>
        <title>Go 接口</title>
        <url>https://iihui.github.io/post/go-interface/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html"> 接口定义 接口代表一种调用契约，是多个方法声明的集合。在某些动态语言中接口(interface)也被称为协议(protocol)。准备交互的双方，共同遵守事先的约定规则，使得在无须知道对方身份的情况下进行协作。接口关心的是做什么，而不关心怎么做，谁来做。
接口解除了类型依赖，有助于减少用户可视方法，屏蔽内部结构和实现细节。但这并不意味着可以滥用接口，因为实现接口会有运行时开销。接口最常见的使用场景是对包外提供访问，或预留扩展空间。
接口定义了一组方法，但是这些方法不包括实现代码，接口中也不包含变量「我的理解是不包含普通变量，但可以有接口变量」。
在Go中只要目标类型方法集内包含接口声明的全部方法，就被当作实现了该接口，不需要做显式的声明。显然这是一种非侵入式的设计方法，这种设计方法的好处是，在前期开发时设计出合理的接口并不容易，等后期代码重构时，模块分拆时再分离出接口时比较容易。
 注意事项 按照约定，接口名字首选以er或者r结尾，其次为able为后缀，最次以I开头。在定义接口时需要注意的事项：
  接口的本质可以认为是一个指针，但和指针又不完全相同——指向接口变量的指针是非法的，如下是var ai namer在内存中的布局： ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-12-18 上午8.54.39.png)
  接口定义中，不能出现变量定义。「我的理解是不可以有普通变量，但是可以嵌入其他接口」
  Go中接口都很简短，一般0到3个方法。
  接口定义中只能声明方法，不能包含方法的具体实现。
  接口定义中，不能定义接口自己的方法。
  编译器会根据目标类型的方法集来确定该类型是否实现了该接口，如果目标类型的方法集中没有完全实现接口中声明的方法，那么该目标类型就不可以赋值给该接口变量。
  即使接口在类型之后才定义，二者处于不同的包中，被单独编译。但是，只要类型实现了接口中的方法，它就实现了此接口。
  一个接口可以包含一个或多个其他接口，这相当于直接将这些内嵌接口的方法列举在外层接口中一样。
  可以像嵌入匿名字段那样，嵌入其他接口类型。此时目标类型方法集中必须包含嵌入的接口方法在内的全部方法，才能算实现了该接口。也就是说嵌入其他接口类型，相当于将嵌入的接口声明的全部方法导入。这就要求嵌入接口中的方法与本接口中不能有同名的方法，因为Go不支持重载。
  在接口中嵌入接口时，超集接口变量可以隐式转换为嵌入的接口变量。反过来不行——因为信息不完整了。
  在嵌入接口类型时，不能嵌入自身或循环嵌入，那会导致递归错误。
  支持匿名接口类型：①可以直接用于变量定义 ②可用于结构体字段类型。
  多个类型可以实现同一个接口，实现某个接口的类型（除了实现接口方法外）可以有其他的方法，这就说明一个类型可以实现多个接口。
  接口变量的默认值是nil(因为接口也是一种引用类型)。
  对于两个接口变量对应的目标类型支持判等运算，那么这两个变量就可以做相等运算。
  如果接口没有任何方法声明，那么就是一个空接口，它的用途和Java中的Object一样，可以被赋值为任何类型的对象。
   接口嵌套接口 一个接口可以包含一个或多个其他的接口，这相当于直接将这些内嵌接口的方法列举在外层接口中一样。
type ReadWrite interface{  Read(b buffer) bool  Write(b buffer) bool }  type Lock interface{  Lock()  Unlock() }  type File interface{  ReadWrite //嵌入接口  Lock  Close() //自己的方法 }  检测和转换接口变量 一个接口变量可以被任何实现了该接口的类型的变量赋值，即接口变量在运行时存在多态行为。因此需要一种方法来检测某个时刻一个接口变量是否是某个类型T。
v:=x.(T) //未检测类型断言  if v,ok := x.(T); ok{ //检测类型断言  do something  return } 其中x表示接口类型的变量，且必须是接口类型变量，否则编译器会报错。而T表示需要被检测的目标类型。在检测类型断言中，如果转换合法，那么v是x转换到T类型的值，ok为true，否则v是T类型的零值，ok的值为false，此时不会有运行时错误发生。
当需要检测的类型较多时，建议使用type-switch，但是在type-switch不允许有fallthrough。
switch t := areaIntf.(type) {  case *Square:  fmt.Printf(&amp;#34;Type Square %T with value %v\n&amp;#34;, t, t)  case *Circle:  fmt.Printf(&amp;#34;Type Circle %T with value %v\n&amp;#34;, t, t)  case nil:  fmt.Printf(&amp;#34;nil value: nothing to check?\n&amp;#34;)  default:  fmt.Printf(&amp;#34;Unexpected type %T\n&amp;#34;, t) } 但是所有的case语句中列举的类型(nil除外)都必须实现对应的接口，如果被检测类型没有匹配case语句列举的类型，就会执行default语句。
 空接口 空接口是不包含任何方法，它对实现不做任何要求。任何类型都实现了空接口，any或Any是空接口一个很好的别名或者缩写。
type any interface{} 可以给一个空接口类型的变量var val interface{} 赋任何类型的值。
每个空接口变量在内存中占据两个字节，一个用来存储它包含的类型，另一个用来存储它包含的数据或者指向数据的指针。
 执行机制 接口是一种契约，实现类型必须满足它，它描述了类型的行为，规定类型可以做什么。接口将类型能做什么和如何做分离开来，使得相同接口变量在不同时刻表现出不同的行为，这就是多态的本质。
从内部实现上来看，接口自身也是一种结构体，只是编译器会对其作出很多限制。接口使用一个名为itab的结构体存储运行期所需的相关类型信息。
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-12-18 上午8.54.39.png)
type iface struct{  tab * itab //类型信息  data unsafe.Pointer //实际对象指针 }  type itab struct{  inter *interfacetype //接口类型  _type *_type //实际对象类型  fun [1]uintptr //实际对象方法地址 } 接口有一个重要的特性：将对象赋值给接口变量时，会复制该对象。我们甚至无法修改接口存储的复制品，因为它是unaddreable，即使将其复制出来，使用本地变量修改后，依然无法对iface.data赋值。解决的方法是将对象指针赋值给接口，那么接口内存储的就是指针的复制品。
只有当接口变量的内部的两个指针(itab,data)都为nil时，接口才等于nil。因此造成的错误并不少见，尤其是在函数返回error时，详见Go学习笔记P149。
var a interface{}=nil var b interface{}=(*int)(nil) println(a==nil,b==nil) //true false 类型推断可将接口变量还原为原始类型，或者用来判断是否实现了某个更具体的接口类型
type data int func (d data) String() string{  return fmt.Sprintf(&amp;#34;data:&amp;#34;%d&amp;#34;,d) }  var d data=16 if n,ok:=x.(fmt.Stringer); ok{ //转换为更具体的接口类型  fmt.Println(n) }  if d2,ok:=x.(data); ok{ //转换为原始类型  fmt.Println(d2) }  e:=x.(error) //错误，main.data is not error fmt.Println(e) 使用ok-idiom模式，即使转换失败也不会引发panic。还可以用switch语句在多种类型间作出推断匹配，这样接口就能有更多的发挥空间。
var x interface{}=func(x int)string{  return fmt.Sprintf(&amp;#34;d:%d&amp;#34;,x) }  switch v := x.type{  case nil:  println(&amp;#34;nil&amp;#34;)  case *int:  println(*v)  case func(int)string:  println(v(100)  case fmt.Stringer:  fmt.println(v)  default:  fmt.println(&amp;#34;unknown&amp;#34;) } 如上所示的type switch中不支持fallthrought。
 </content>
    </entry>
    
     <entry>
        <title>Go 定义类型</title>
        <url>https://iihui.github.io/post/go-struct/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html">  值的类型给编译器提供两部分信息：①需要分配多少内存给这个值；②这段内存表示什么。Go语言允许用户定义类型，当用户声明一个新类型时，这个声明就给编译器提供一个框架，告知必要的内存大小和表示信息。
 结构体 Go语言中声明用户定义的类型有两种方法，①最常用的方法是使用关键字struct，它可以让用户创建一个结构类型；②另一种是使用根据已有类型来定义新的类型。
结构体的定义 结构体类型通过组合一系列固定且唯一的字段来声明，结构体中每个字段都会用一个已知类型声明。结构体声明以关键字type开始，之后是新类型的名字，最后是关键字struct。
type user struct {  name string  email string  ext int  privileged bool } var bill user //像声明内置类型变量一样声明  结构体的初始化 当声明结构体变量时，这个变量对应的值总是会被初始化。这个值要么用指定的值初始化，要么使用类型零值做初始化。
既然要创建初始化一个结构类型，可以使用结构体字面量来完成这个初始化。结构体字面量使用一对大括号括住内部字段的初始值，结构字面量可以对结构类型变量初始化可以采用两种形式。
一种是顺序字面量，另一种是命名字面量。初始化的时候，使用顺序字面量对结构体变量进行初始化称为顺序初始化，而使用命名字面量进行初始化称为命名初始化。推荐使用命名初始化，这样在扩充结构体的字段时就不会导致初始化错误。
user{ //命名字面量  name : &amp;#34;Lisa&amp;#34;,  email : &amp;#34;Lisa@gmail.com&amp;#34;,  ext : 123,  privileged : true, }  //顺序字面量进行顺序初始化，必须要和结构声明中的字段的顺序一致 lisa := user{&amp;#34;Lisa&amp;#34;,&amp;#34;Lisa@gmail.com&amp;#34;,123,true} //顺序方式 u1 ：= user{&amp;#34;Andy&amp;#34;,&amp;#34;Andy@gmail.com&amp;#34;} //错误，顺序初始化时参数不够 使用命名字面量进行初始化称为命名初始化：
type node struct {  _ int  id int  next * node }  n1 := node{  id:1, //逗号不可以省略，未初始化的为类型默认零值 }  n2 := node{  id:2,  next: &amp;amp;n1, //即使是结构体的最后一个变量，逗号不可以省略 }  fmt.Println(n1,n2)//{0 1 &amp;lt;nil&amp;gt;} {0 2 0xc4200be4e0}  匿名结构体 可直接定义匿名结构体类型变量，或用做结构体的命名字段类型「不能是匿名字段类型，因为类型已经没有名字」。匿名结构体在作为结构体的字段值时因其缺少类型标识，无法进行直接初始化，前面的两种方式的字面量都需要结构体类型名字：
u := struct { // 直接定义匿名结构体  name string  age byte }{  name : &amp;#34;Tom&amp;#34;,  age : 12, }  type file struct{  name string  attr struct { //匿名结构体字段  owner int  perm int }  f := file {  name: &amp;#34;test.dat&amp;#34; // attr: { //错误 // owner: 1, // perm: 0755, //}, }  f.attr.owner = 1 //也可以在初始化语句中再次定义，但那样看上去会非常丑陋 f.attr.perm = 0755  注意事项 只有在所有字段类全部支持判等操作时，才可以做相等操作:
type data struct {  x int  y map[string]int }  d1 := data{ //命名初始化  x: 100, }  d2 := data{ //命名初始化  x: 100, }  println(d1 == d2) 可以使用指针直接操作结构字段，但不能是多级指针。
type user struct {  name string  age int }  p := &amp;amp; user{  name : &amp;#34;Tom&amp;#34;  age : 12 }  p.name = &amp;#34;Mary&amp;#34; //指针直接操作结构体字段 p.age &#43;&#43; //指针直接操作结构体字段  p2 := &amp;amp; p *p2.name = &amp;#34;Jack&amp;#34; //错误，不能使用多级指针直接操作结构体字段  空结构体 空结构体struct {}是指没有字段的结构类型，它比较特殊，因为无论是其自身，还是作为数组元素类型，其长度均为0。
var a struct{} var b [100] struct{}  println(unsafe.Sizeof(a),unsafe.Sizeof(b))//0 0 对于空结构体来说，尽管没有分配数组内存，但依然可以操作元素，对应切片len,cap属性也正常。
var d[100] struct{} s := d[:]  d[1] = struct{}{} d[2] = struct{}{}  fmt.Println(s[3],len(s),cap(s)) //{} 100 100 实际上，这类长度为0的空结构体对象通常指向runtime.zerobase变量。 空结构体可作为通道元素类型，用于事件通知。
a := [10]struct{}{} b := a[:] c := [0]int{}  fmt.Println(&amp;amp;a,&amp;amp;b,&amp;amp;c)  结构体的匿名字段 所谓匿名字段，是指没有名字，仅有类型的字段，也称作嵌入字段或嵌入类型。
type attr struct {  perm int }  type file struct {  name string  attr //匿名字段,但不是匿名结构体，注意区别 } 从编译器的角度看，这只是隐式的以类型作为字段名字。可直接引用匿名字段的成员，但初始化时须当作独立字段。
f := file{  name : &amp;#34;test.data&amp;#34;,  attr : attr{ //显式初始化匿名字段，注意于匿名结构体那一小结的区别  perm : 0755,  }, //分号不能少 }  f.perm = 0644 //直接设置匿名字段成员 println(f.perm) 如果嵌入其他包中的类型，则隐式字段名字「不是匿名字段，是匿名字段的名字」不包括包名：
type data stuct {  os.File //匿名字段，包括包名 }  func main{  d := data {  File : os.File{} //匿名字段初始化时，字段名字不包括包名 } 不仅仅是结构体，除接口指针和多级指针以外任何命名类型都可以作为结构体的匿名字段：
type data stuct {  * int  string }  x := 100 d := data {  int: &amp;amp;x, //指针作为匿名字段时，其隐式名字为基础类型的名字  string: &amp;#34;abc&amp;#34;, } 需要注意的是，不能将基础类型和其指针类型同时嵌入，因为两者隐式名字相同。
type data stuct { * int //指针类型 int //基础类型 }  虽然可以像普通字段那样访问匿名字段成员，但会存在重名问题。默认情况下，编译器从当前显式名字字段开始，逐步向内查找匿名字段成员。如匿名字段成员被外层同名字段遮蔽，那么必须使用显式字段名。
type file struct {  name string }  type data struct{  file  name string }  d := data {  name : &amp;#34;data&amp;#34;  file : file{&amp;#34;file&amp;#34;} //匿名字段初始化 }  d.name = &amp;#34;data2&amp;#34; d.file.name = &amp;#34;file2&amp;#34; //同名字段，使用显式字段名访问 data.file.name 如果多个相同层级的匿名字段成员重名，就只能使用显式字段名，因为编译器无法确定目标：
type file struct {  name string }  type log struct {  name string }  type data struct {  file  log }  func main(){  d := data{}  d.name = &amp;#34;name&amp;#34; //错误，必须使用显式字段名  d.file.name = &amp;#34;file&amp;#34;  d.log.name = &amp;#34;log&amp;#34; }  字段标签 字段标签并不是注释，而是用来对字段进行描述的元数据。尽管它不属于数据成员，但却是类型的组成部分。在运行期，可用反射获取标签信息，它常被用作格式校验，数据库关系映射等。
type user struct{  name string `昵称`  sex type `性别` }  内存布局 在Go中不管结构体包含多少个字段，其内存总是一次性分配的，各字段在相邻的地址空间按定义顺序排列。当然，引用类型、字符串和指针，结构内存中只包含其基本(头部)数据。
在分配内存时，字段须做对齐处理，通常以所有字段中最长的基础类型宽度为标准。
比较特殊的空结构体类型。如果它是最后一个字段，那么编译器将其当作长度为1的类型做对齐处理，以便其地址不会越界，避免引发垃圾回收错误。
如果仅有一个空结构体字段，那么同样按1对齐，只不过长度为0，且指向runtime.zerobase变量。
 根据已有类型定义新类型 另一种声明用户定义的类型的方法是，基于一个已有的类型，将其作为新类型的类型说明。当需要一个可以用已有类型表示的新类型的时候，这种方法会非常有用。
type Duration int64 给不同类型的变量赋值会产生编译错误
package main type Duration int64  func main(){  var dur Duration  dur = int64(1000) //会出现编译错误 }  </content>
    </entry>
    
     <entry>
        <title>Go 延迟调用</title>
        <url>https://iihui.github.io/post/go-defer/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html">  关键字defer允许我们推迟到函数返回前一刻(或任意位置执行return语句之后)才执行某个语句或函数。
 为什么要在返回之后才执行这些语句？因为return语句同样可以包含一些操作，而不是单纯地返回某个值，实际上此时return语句要做三件事：①如果有命名参数，将返回值赋给命名返回值。②执行defer语句或函数。③结束函数的执行。
语句defer向当前函数注册稍后执行的函数调用，这些函数被称为延迟调用，因为它们直到当前函数执行结束之后才被执行，常用于资源释放，解除锁定，以及错误处理等操作。
执行顺序 同一函数中注册多个defer语句时，执行时将会按照注册顺序先进后出的顺序执行即FILO的次序执行。
如果遇到panic语句，那么和遇到return语句一样，会触发延迟调用，并且延迟调用会先于panic中的打印语句。
func main() { 	defer_call() }  func defer_call() { 	defer func() { fmt.Println(&amp;#34;打印前&amp;#34;) }() //最后调用 	defer func() { fmt.Println(&amp;#34;打印中&amp;#34;) }() //中间调用 	defer func() { fmt.Println(&amp;#34;打印后&amp;#34;) }() //最先调用  	panic(&amp;#34;触发异常&amp;#34;) //在defer之后执行 } //打印后 //打印中 //打印前 //panic: 触发异常 编译器通过插入额外的指令来实现延迟调用执行，而return和panic语句都会终止当前函数流程，引发延迟调用。此外，return语句不是ret汇编指令，它会更新返回值，如下例所示：
func TestDefer() (z int) { 	defer func() { 	println(&amp;#34;defer&amp;#34;, z) //100 	z &#43;= 100 	}() 	return 100 //最后z的值为200，实际执行次序为z=100， call defer，ret }  使用场景 延迟调用一般用于做一些收尾工作，例如：①关闭文件流；②关闭数据库连接；③解锁一个加锁的资源；④打印最终的报告。
一个基础但十分实用的实现代码执行追踪的方案就是在进入和离开某个函数打印相关的消息，即可以提炼为下面两个函数
func trace(s string) {  fmt.Println(&amp;#34;entering:&amp;#34;, s) } func untrace(s string) {  fmt.Println(&amp;#34;leaving:&amp;#34;, s) }  注意事项 延迟调用注册的是调用，必须提供执行所需要的参数（哪怕为空），参数在注册的时候被复制并缓存起来，如对状态敏感，可改用指针或闭包。
 func TestDeferRegister(){ 	x, y := 1,2 	defer func(a int){ //传给参数a的值被缓存起来 	println(&amp;#34;defer x,y =&amp;#34;,a,y) //y是在延迟调用时读取被改变之后的值 	}(x)  	x &#43;= 100 	y &#43;= 200  	println(x,y) //y对于defer函数来说是外部变量  }  //101 202  //defer x,y = 1 202  如果在延迟函数中使用外部变量，就应该通过参数传入。具体实例见下面代码：
func printNumber() { 	for i := 0; i &amp;lt; 5; i&#43;&#43; { 	defer func () { 	fmt.Printf(&amp;#34;%d\t&amp;#34;,i) 	} 	} }//输出为5 5 5 5 5 func printNumber() { 	for i := 0; i &amp;lt; 5; i&#43;&#43; { 	defer func (n int) { 	fmt.Printf(&amp;#34;%d\t&amp;#34;,i)		}(i) 	} } //输出为4 3 2 1 0 第一个函数的输出为5 5 5 5 5，是因为使用了外部变量i，当触发延迟调用的时候，i的值已经变成了5。
第二个函数的输出为4 3 2 1 0，是因为匿名函数被传入了一个参数，每次注册的时候，会将传入的参数缓存起来。
 </content>
    </entry>
    
     <entry>
        <title>Go 方法</title>
        <url>https://iihui.github.io/post/go-method/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html"> 方法 在Go中结构体就像是类的一种简化形式，方法就像类中的方法。方法是与对象实例绑定的特殊函数，方法和函数定义语法区别在于:方法有前置实例接收参数receiver，编译器以此确定方法所属类型。
接收者类型几乎可以是任何类型，不仅仅是结构体类型，甚至可以是函数类型。但是，有两种类型不可以有方法：
  接收者不能是一个接口类型， 因为接口是一个抽象定义，但是方法需要具体实现。
  接收者的类型不能是本身类型是指针的类型，例如type TP *int,那么TP就不可以定义方法。
  一个类型加上它的方法等价于面向对象中的一个类。在Go中，类型的代码和绑定在它上面的方法的代码可以不放置在一起，它们可以存在于不同的源文件，唯一的要求——它们必须在同一个包中。
 使用 package main  import ( 	&amp;#34;fmt&amp;#34; )  type user struct { 	name string 	email string }  // 使用user值类型作为接收者 func (u user) notify() { 	fmt.Printf(&amp;#34;Sending User Email To %s&amp;lt;%s&amp;gt;\n&amp;#34;, u.name, u.email) }  // 使用指针类型作为接收者 func (u *user) changeEmail(email string) { 	u.email = email }  // func main() { 	bill := user{&amp;#34;Bill&amp;#34;, &amp;#34;bill@email.com&amp;#34;} 	bill.notify() //值类型来调用方法  	lisa := &amp;amp;user{&amp;#34;Lisa&amp;#34;, &amp;#34;lisa@email.com&amp;#34;} 	lisa.notify() //指向user类型值的指针也可以调用使用值类型作为接收者的方法  	bill.changeEmail(&amp;#34;bill@newdomain.com&amp;#34;) 	bill.notify() //使用值来调用以指针作为接收者的类型  	lisa.changeEmail(&amp;#34;Lisa@newdomain.com&amp;#34;) 	lisa.notify() //指针类调用以指针类型作为接收者的类型 }  注意事项   方法是一种特殊的函数，因此方法是不支持重载的，即一个类型的方法集中的所有方法是不能够有同名的方法。
  如果方法内部不引用实例，可省略参数名，仅保留类型。
  接收者receiver类型可以是基础类型或指针类型，区别在于调用时对象实例是否被复制。值接收者使用值的副本来调用方法，而指针接受者使用实际值来调用方法。
type N int func TestMethod() {  var a N = 25  //println(a.toString())  a.value()  fmt.Printf(&amp;#34;a: %p,%v\n&amp;#34;, &amp;amp;a, a)   a.pointer()  fmt.Printf(&amp;#34;a: %p,%v\n&amp;#34;, &amp;amp;a, a) }  func (n N) value() { //值类型的接受者，调用的时候会复制，所以n的值的更改不会体现到接收者的类型上来  n&#43;&#43;  fmt.Printf(&amp;#34;v: %p,%v\n&amp;#34;, &amp;amp;n, n) }  func (n *N) pointer() {  (*n)&#43;&#43;  fmt.Printf(&amp;#34;p: %p, %v\n&amp;#34;, n, *n) }   可使用实例值或者指针调用方法，编译器会根据方法receiver类型自动在基础类型和指针类型间转换。
var a N = 25 p := &amp;amp;a a.value() a.pointer() p.value() p.pointer()   只能使用一级指针调用方法，不能使用多级指针调用方法。
var a N = 25 p := &amp;amp;a p2 := &amp;amp;p p2.value() //错误，使用多级指针 p2.pointer() //错误，使用多级指针调用   指针类型的receiver必须是合法地址（包括nil），或能获取实例的地址，否则会出现运行时错误。
var b * N b.value() //b 相当于nil,可以调用，但是会出现运行时错误，因为没有指向具体实例，所以在传参数时出现错误 //N{}.pointer()   别名类型能定义方法的前提是其原始类型没有定义过该方法。
  在Go中类型和作用在它上面的方法必须在同一个包里定义，这就是为什么不能在int、float或类似这样的标准类型上定义方法。有一个比较曲折的绕过这种规定的方式：可以先定义该类型（比如int或float）的别名类型，然后再为别名类型定义方法。
   receiver建议 选择方法的receiver的建议
  要修改实例状态，用 * T
  无须修改的小对象或固定值，建议用T
  大对象建议使用 *T，以减少复制成本
  引用类型，字符串，函数等指针包装对象，直接用T
  若包含 Mutex 等同步字段，用*T，避免因复制造成锁操作无效
  其他无法确定的情况，都用 *T
  可以像访问匿名字段那样调用其方法，由编译器负责查找，尽管可以直接访问匿名字段的成员和方法，但它们仍不属于继承关系
type data struct { 	sync.Mutex } d := data{} d.Lock() defer d.Unlock()  方法集 类型有一个与之对应的方法集，这决定了它是否实现某个接口。当一个匿名类型被内嵌在结构体中时，匿名类型的可见方法也同样被内嵌。这在效果上等同于外层类型继承了这些方法。这个机制提供了一种简单的方式来模拟经典面向对象语言中的子类和继承相关的效果。
  类型T的方法集包含了所有的receiver T方法
  类型*T包含了所有receiver T&#43;*T方法
  匿名嵌入S，T的方法集中包含所有receiver S方法
  匿名嵌入*S，T的方法集中包含所有receiver S&#43;*S方法
  匿名嵌入S或*S，*T的方法集中包含所有receiver S &#43; *S方法
  和内嵌类型方法具有同样名字的外层类型的方法会覆写内嵌类型对应的方法。
func (S) sVal() {} func (*S) sPtr() {} func (T) tVale() {} func (*T) tPtr() {}  func MethodSet(a interface{}) { 	t := reflect.TypeOf(a)  	for i, n := 0, t.NumMethod(); i &amp;lt; n; i&#43;&#43; { 	m := t.Method(i) 	fmt.Println(m.Name, m.Type) 	} }  方法表达式 方法和函数一样，除直接调用外，还可赋值变量，作为参数传递，依照具体的引用方法不同，分为 expression 和 value 两种。
Method Expression 通过类型引用的Method Expression会被还原成普通函数样式,receiver是第一参数，调用时须显式传参，可以是T或*T，只要该方法存在于该类型方法集中即可。
type N int func (n N) test() { 	fmt.Printf(&amp;#34;test.n:,%p,%d\n&amp;#34;, &amp;amp;n, n) }  var n N = 25 fmt.Printf(&amp;#34;main.n:,%p,%d\n&amp;#34;, &amp;amp;n, n)  f1 := N.test f1(n)  f2 := (*N).test //尽管*N方法集包装test方法receiver类型不同，但编译器会保证按原定义类型拷贝传值 f2(&amp;amp;n) //main.n:,0xc42006e1a8,25 //test.n:,0xc42006e1c8,25 //test.n:,0xc42006e1d8,25 还可以直接以表达式的方式调用
N.test(n) (*N).test(&amp;amp;n) //test.n:,0xc42006e1c8,25 //test.n:,0xc42006e1d8,25  Method Value 基于实例或指针引用的method value，参数签名不会改变，依旧按正常方式调用，但当method value被赋值给变量或作为参数传递时，会立即计算并复制该方法执行所需的receiver对象与其绑定，以便在稍后的执行时，能隐式传入receiver参数。
var n N = 25 p := &amp;amp;n  n&#43;&#43; t1 := n.test  n&#43;&#43; t2 := p.test  n&#43;&#43; fmt.Printf(&amp;#34;main.n:,%p,%d\n&amp;#34;, &amp;amp;n, n)  t1() t2() //main.n:,0xc42000e258,28 //test.n:,0xc42000e278,26 //test.n:,0xc42000e288,27 当method value作为参数时，会复制含receiver在内的整个method value
func call(m func()){  m() }  var n N = 25 p := &amp;amp;n  fmt.Printf(&amp;#34;main.n:,%p,%d\n&amp;#34;, &amp;amp;n, n)  n&#43;&#43; call(n.test)  n&#43;&#43; call(p.test)  //main.n:,0xc42006e1a8,25 //test.n:,0xc42006e1c8,26 //test.n:,0xc42006e1d8,27 如果目标方法的receiver是指针类型，那么被复制的仅是指针
只要receiver参数类型正确，使用nil同样可以执行
type N int func (n N) value(){} func (n *N) pointer(){} var ptr *N  ptr.pointer() (*N)(nil).pointer() (*N).pointer(nil)  </content>
    </entry>
    
     <entry>
        <title>Go 包</title>
        <url>https://iihui.github.io/post/go-package/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html">  包是结构化的一种方式,所有Go语言的程序都会组织成若干组文件，每组文件被称为一个包。每个文件都属于且仅属于一个包，一个包中可以包含许多以.go为扩展名的源文件。
 包中源文件 源文件都使用UTF-8编码，每个源文件都属于包的一部分，在文件头部用package声明所属包。
每一个可独立运行的Go语言程序必定包含一个main包，在这个main包中必定包含一个入口函数main，这个函数没有参数也没有返回值。
入口函数main没有参数，必须放到main包中，如果 main函数没有放到main包中，构建工具就不会生成可执行文件。
如果一个源文件被声明属于main代码包，且该文件代码中包含无参数声明和无返回值声明的main函数，则它是命令源码文件。命令源文件可以通过go run命令直接启动运行。
同一个代码包中可以有多个命令源文件，可通过go run命令分别运行，但这会使go build和go install命令无法编译和安装该代码包，因此不应该把多个命令源文件放入到同一个包中。
库源码文件声明的包名会和它所属的目录名一致（建议这样做），且库源码文件中不包含无参数声明和无返回值声明的main函数。
 工作空间 Go的工作空间就是一个对应于特定工程的目录，它包含3个目录，分别是src、bin、pkg目录。
  src目录用以代码包的形式组织并保存Go源码文件。
  pkg目录用以保存使用go install命令安装后的代码包的归档文件。归档文件是指那些以.a结尾的文件。该目录与GOROOT目录下的pkg目录的功能类似，区别在于工作区下的pkg目录保存的用户代码的归档文件。
  bin目录，与pkg目录类似，在通过go install命令完成安装后，保存由Go命令源码文件生成的可执行文件。
  通常需要将工作空间的路径添加GOPATH环境变量列表中，工作空间可以有一个或者多个。
  GOPATH中不要包含Go语言的根目录，以便将Go语言本身的工作空间同用户的工作区严格分开。
  通过go install命令获取的源码，将会下载到GOPATH中设定的第一个工作空间中，并在其中完成编译和安装。
  只有当环境变量GOPATH中只包含一个工作区的目录路径时，go install命令才会把命令的源码文件安装到当前工作区的bin目录下。否则执行go install就会出错，此时需要设置环境变量GOBIN，用于存放所有因安装Go命令源码文件而产生的可执行文件。
  在工作空间里，包括子包在内的所有源码文件都保存在src目录下。至于bin、pkg两个目录，其主要影响go install/get 命令，它们将编译结果安装到两个目录下，以实现增量编译。
使用标准库或第三方包前，须用import导入，参数是工作空间中以src为起始的绝对路径。
对于一个导入的包，编译器首先从标准库开始搜索，如果未找到然后就依次搜索GOPATH列表中的各个工作空间。一旦找到了导入的包，即刻停止搜索。
编译器等相关工具按GOPATH设置的路径搜索目标，导入目标库时，排在列表前面的路径比当前工作空间的优先级别更高。其中go get默认将下载的第三方包保存到列表中的第一个工作空间内。
环境变量GOROOT用于指示工具链和标准库的存放路径。环境变量PATH中也应该添加一项GOROOT/bin，这样就可以在任意目录中使用Go的命令了。
 4种方式导入 使用标准库或第三方包，须用import导入，参数是工作空间中以src目录为起始的绝对路径。
import语句告诉编译器到磁盘的哪里去找想要导入的包，编译器会使用Go环境变量设置的路径，通过引入的相对路径来查找磁盘上的包。
编译器首先会查找Go的安装目录，然后才会按顺序查找GOPATH变量中列出的目录。包的导入，总共有四种方式：
import &amp;#34;study/test&amp;#34; //默认方式： test.A import X &amp;#34;study/test&amp;#34; //别名方式： X.A import . &amp;#34;study/test&amp;#34; //简便方式：A import _ &amp;#34;study/test&amp;#34; //初始化方式，无法引用，仅用来初始化目标包，即调用init函数 在Go中未使用的导入(不包括初始化方式)会被编译器视为错误，这与C&#43;&#43;有很大的区别。
 注意事项 一个应用程序可以包含不同的包，按照惯例所有的包名都应该使用小写字母。在Go的安装文件中包含了一些可以直接使用的包——标准库。
属于同一包的源文件必须全部一起被编译，一个包就是编译时的一个单元。如果对一个包进行了重新编译，那么使用了这个包的客户端程序必须全部重新编译。
按照惯例，每个目录只包含一个包，包名一般和目录的名字相同，但这不是强制规定，包名和目录名可以不一样。
除了标识符_,包中所有的代码对象的标识符必须是唯一的，以避免名称冲突，但是相同的标识符可以在不同的包中使用，因为可以使用包名来区分它们。
当标识符以一个大写字母开头，那么它就可以被外部包的代码所使用，这种方式称之为包的导出。标识符如果以小写字母开头，则对外部包是不可见的，但是它们在内部包中是可见可用的。
  处于同一文件夹下的代码文件，必须使用同一个包名。
  在Go中按照惯例包和文件夹同名。实际上，包名和目录名并无关系，不要求保持一致。
  程序中每个代码文件中的init函数都会在main函数之前被执行。执行顺序为全局变量的初始化、init函数的执行，main函数的执行。
  以下几个包被保留，有特殊含义
  main： 可执行入口（入口函数main.main)。
  all: 标准库以及GOPATH中能找到的所有包。
  std,cmd: 标准库以及工具链。
  documentation: 存储文档信息，无法导入（和目录名无关）。
    所有成员在包内均可访问，无论是否在同一源码文件中；但只有名称首字母大写的为可导出成员，在包外是可见的。
  包内每个源码文件可定义一到多个初始化init函数，但编译器不保证执行次序，实际上所有这些初始化函数（包括标准库和导入第三方包）都由编译器自动生成的一个包装函数进行调用，因此可保证在单一线程上执行，且执行一次。
  编译器首先①确保完成所有全局变量初始化，然后②才执行初始化函数。直到这些全部结束后，运行时才正式③进入到main.main入口函数。
  使用import导入标准库或第三方包，必须删除未使用的导入，否则编译器会将其当作错误处理。
   </content>
    </entry>
    
     <entry>
        <title>Go 数据</title>
        <url>https://iihui.github.io/post/go-data/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html"> 数据类型 Go 中数据分为基本类型，数组，引用，字典（映射)，通道，函数，结构体，接口等等。
  切片slice可实现类似动态数组的功能y := make([]int, 0, 5); append(y,7)。
  将字典map类型内置，可以直接从运行层面获得性能优化。
  所谓ok-idiom模式，就是在返回值中用一个名为ok的布尔值来标识操作是否成功，因为很多操作默认返回零值，所以需要额外说明。
m := make(map[string]int) m[&amp;#34;a&amp;#34;]=1 z,ok:=m[&amp;#34;b&amp;#34;] fmt.Println(z,ok)   可以为任意类型定义方法:
type X int func (x * X) inc() {  *x&#43;&#43;  }    字符串 字符串是用一对双引号&amp;quot;&amp;quot;或者反引号括起来定义的，均采用UTF-8编码，并且是不可变的。
  字符串是一个不可变(byte）字节序列，本身是一个复合序列。头部指针指向字节数组，但没有nullptr结尾，默认以UTF-8存储字符，字面量里允许16进制，8进制以及UTF编码。
type stringStruct struct{ //字符串的底层结构  str unsafe.Pointer  len int }   字符串的默认值是&amp;quot;&amp;quot;而不是 nil。
  使用$`$定义不做转义处理的原始字符串, 并且支持跨行。
s := `line\r\n, //`开始定义不做转义的字符串  line 2` fmt.Println(s)   支持==、!=、&amp;lt;、&amp;gt;、&#43;、&#43;= 操作符，使用加法操作符跨行时，加法操作符必须接在上一行的结尾。
s：=&amp;#34;ab&amp;#34;&#43;  &amp;#34;cd&amp;#34; fmt.Println(s==&amp;#34;abcd&amp;#34;, s &amp;gt; &amp;#34;abc&amp;#34;) //true true   允许以索引号访问字节数组（非字符），但不能获取元素地址，因为字符串是不可变的。
s：=&amp;#34;hello&amp;#34; fmt.Println(s[0]) //但是不可以使用 &amp;amp;s[0]   以切片语法（起始和结束索引号）返回子串时，其内部依旧指向原字节数组。
s := &amp;#34;abcdefg&amp;#34; s1 := s[:3] //abc，前闭后开 s2:=s[1:4] //bcd s3:=s[2:] //cdefg  fmt.Println(s1,s2,s3) fmt.Printf(&amp;#34;%#v\n&amp;#34;,(*reflect.StringHeader)(unsafe.Pointer(&amp;amp;s))) //&amp;amp;reflect.StringHeader{Data:0x10b4007, Len:7} fmt.Printf(&amp;#34;%#v\n&amp;#34;,(*reflect.StringHeader)(unsafe.Pointer(&amp;amp;s1)))//&amp;amp;reflect.StringHeader{Data:0x10b4007, Len:3}   使用for遍历字符串时，分为byte 和 rune两种方式。因为字符串是UTF-8编码的，而UTF-8是变长编码，因此不难理解会有这两种形式。
s := &amp;#34;吉林&amp;#34; for i:=0;i&amp;lt;len(s) ;i&#43;&#43; { //byte形式  fmt.Printf(&amp;#34;%d:[%c]\n&amp;#34;,i,s[i]) //0:[å]1:[]2:[]3:[æ]4:[]5:[] }  for i,c:=range s { //rune形式 	fmt.Printf(&amp;#34;%d:[%c]\n&amp;#34;,i,c) //0:[吉]3:[林]  }   要修改字符串，必须将其转换为可变类型[]byte 或[]rune,待完成后再转换回来，但是不管如何转换，都必须重新分配内存，并复制数据。
  使用加法操作符拼接字符串时，每次都必须重新分配内存，因为字符串是不变的。
  字符串操作通常在堆上分配内存，这会对Web高并发应用造成较大影响，会有大量字符串对象要做垃圾回收，建议使用[]byte缓存池。
  使用单引号的字面量，其默认是rune（专门用来存储unicode码点，它是uint32的别名）。
  不能使用索引的方式修改字符串的值，但是可以使用使用赋值的方式修改整个字符串的值，类比与C&#43;&#43;中字符指针指向字符串常量时，不能以索引的形式修改单个字符，但是能够改变字符指针的指向。
s := &amp;#34;abcdef&amp;#34; fmt.Println(s,&amp;amp;s) //abcdef 0xc42000e3c0 s =&amp;#34;hello&amp;#34; //重新指向 fmt.Println(s,&amp;amp;s) //hello 0xc42000e3c0 s[1]=&amp;#39;c&amp;#39; //这是错误的,因为字符串的内部指针指向的是不可变字节，不能获取地址    数组   定义数组时，数组长度必须是非负整型常量表达式，长度是类型的组成部分，也就是说元素类型相同，但长度不同的数组不属于同一类型。
var d1 [3] int var d2 [4] int d1 = d2 // d1 和 d2 不属于同一类型，不能赋值，不能比较   未提供初始化值的元素自动初始化为类型零值（不同类型的零值不一样的）。
var d1 [3] int var d2 [4] int d3 := [5]int{2,3,4} fmt.Println(d1,d2,d3) //[0 0 0] [0 0 0 0] [2 3 4 0 0]   数组初始化时，可指定位置进行初始化。
d4 := [4]int{5,3:10} //[5 0 0 10]   编译器可以按照初始化值的数量确定数组长度。其中声明时的...一定不可以被省略。
d5 := [...]int{34,8,9} //长度为3 d6 := [...]int{5,3:10} //长度为4，内容为[5 0 0 10]   在定义多维数组时，仅第一维可以允许使用...，即省略第1维的长度。
  内置函数len和cap可以返回数组的第一维长度。
d7 :=[3][4]int {{2},{3}} fmt.Println(len(d7),cap(d7)) //3,3   如元素支持==，！= 等操作符，那么数组也支持该操作，这与C和C&#43;&#43;有很大的区别。
var d1 [4] int var d2 [4] int d3 := [4]int{2,3,4} d4 := [4]int{5,3:10} fmt.Println(d1==d2,d3==d4) //true false   分清指针数组和数组指针，这个概念和C与C&#43;&#43;是一样的。
d11,d12:=20,10 d13:=[]*int{&amp;amp;d11,&amp;amp;d12} //指针数组 d14:=&amp;amp;d13 //数组指针 fmt.Println(d13,d14) //[0xc420072250 0xc420072258] &amp;amp;[0xc420072250 0xc420072258]   可以获取任意元素的地址；而对于字符串来说，是不可以获取单个字符的地址。
d4 := [4]int{5,3:10} fmt.Println(&amp;amp;d4,&amp;amp;d4[0],&amp;amp;d4[3])//&amp;amp;[5 0 0 10] 0xc4200680e0 0xc4200680f8   数组的赋值和传参都会复制整个数组，为了避免数据复制，可以改用指针或切片。
   切片 切片本身并非动态数组或数组指针，它通过内部指针引用底层数组，设定相关属性，将数据读写操作限定到指定区域。
type slice struct{  array unsafe.Pointer // 指向数组中slice中指定的开始位置  len int // slice 的长度  cap int //最大长度，就是slice开始位置到数组的最后位置的长度 } 切片可以从一个数组或一个已经存在的的切片中再次声明。切片通过 array[i:j] 来获取，表示的区间是[i,j)即前闭后开区间，长度为j-i。
var arr =[10]byte{&amp;#39;a&amp;#39;,&amp;#39;b&amp;#39;,&amp;#39;c&amp;#39;,&amp;#39;d&amp;#39;} //array 声明长度 var a,b[] byte //slice，方括号里不声明长度  a = arr[1:3] b = arr[2:4]  fmt.Println(a,b) //[98 99] [99 100] 切片是引用类型，所以当指向相同的底层结构的切片改变元素的值时，其他所有引用该底层数组的切片都会改变该值。
var arr =[10]byte{81,82,83,84,85,86} //array  var a,b,c [] byte //slice  a = arr[1:3] b = arr[2:4]  fmt.Println(a,b) //[98 99] [99 100]  c = a[0:2]  fmt.Println(c) //[82,83]  a = arr[1:5]  fmt.Println(a,c) //[82 83 84 85] [82 83] 函数append向slice里面追加一个或者多个元素，然后返回一个和 slice一样类型的slice。并且会改变slice所引用的数组的内容，从而影响到引用同一数组的其他slice。
 字典 map是引用类型，应该使用make来分配空间。在声明的时候不需要知道map的长度，因为map是动态增长的。
未初始化的map的值是nil,此时不能对nil字典进行写操作，但是可以进行读操作。
  key可以是任意使用==或者!=操作符比较的类型，所以切片不能作为key(只包含内建类型的struct可以作为key，即不包含切片的数组)，指针和接口类型都可以作为key。
  value可以是任意类型，通过空接口可以存储任意类型的值，map也可以使用函数作为自己的值。
  字典map是无序的（因为key是无序的，导致value也是无序的），所以每次打印出来的结果都会不一样。
  value不能通过下标获取，只能通过key获取，此时的索引是key而不是下标。
  map的长度可以动态增长，当map增加到容量上限的时候，如果再增加新的Key-value对，map的大小会自动加1。出于性能考虑，对于大的map或者会快速扩张的map，即使只是大概知道容量，也最好预先标明容量。
  内置的len函数返回key的数量，不支持cap；而数组和切片中都可以使用len和cap函数。
  map的初始化可以通过key:val的方式初始化：
rating :=map[string]float32{&amp;#34;C&amp;#34;:5,&amp;#34;Go&amp;#34;:1.83} fmt.Println(rating) //map[C:5 Go:1.83]   map是一种引用类型，如果两个map同时指向同一个底层，那么一个改变，另一个也改变：
m := make(map[string]string) m [&amp;#34;Hello&amp;#34;] = &amp;#34;hello&amp;#34; m1 := m m1[&amp;#34;Hello&amp;#34;] = &amp;#34;world&amp;#34; fmt.Println(m,m1) //map[Hello:world] map[Hello:world]   访问不存在的键值，默认返回的是value的类型零值，不会引发错误，因此推荐使用ok-idiom模式，确定是否正确返回。
m := make(map[string]bool) m[&amp;#34;chen&amp;#34;] = true fmt.Println(m[&amp;#34;xiao&amp;#34;]) //false   当value是数组或者结构体成员时，不能直接修改value成员，正确的做法是返回整个value，待修改后再设置字典键值，或直接用指针类型。
  不能对nil字典进行写操作，但却能读。
var m map[string] int println(m[&amp;#34;a&amp;#34;]) m[&amp;#34;a&amp;#34;]=1 //错误   内容为空的字典与nil是不同的，内容为空的字典是可以写的，而nil字典不可以写。
var m1 map[string]int m2 := map[string]int{}  println(m1==nil,m2==nil)//true false   在迭代期间删除或者新增键值是安全的。
  运行时会对字典并发操作作出检测，如果某个任务正在对字典进行写操作，那么其他任务就不能对该字典进行并发操作（读，写，删除）否则会导致进程崩溃。
  map默认是无序的，不管是按照key还是按照value默认都不排序，如果想要为map排序，必须将key拷贝到一个切片，再对切片进行排序，然后使用切片的for-range的方法打印出所有的key和value。
   </content>
    </entry>
    
     <entry>
        <title>Go 函数</title>
        <url>https://iihui.github.io/post/go-func/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html"> Go中有3种类型的函数，第一种是普通带名字的函数，第二种是匿名函数(或者被称为lambda函数)，第三种是方法（含有接收者的特殊函数）。
特点 在Go中关键字func用于定义函数，相比于其他语言，Go中函数有以下的特点：
  函数是一等公民，即可作为参数或者返回值，可以存入变量，与变量的地位是等同的。
  函数可定义多个返回值，也可以对返回值命名。
  Go 中函数无需前置说明，即可以先使用后定义。
  Go中函数不支持同名重载，主要是因为函数重载需要匹配多余的类型而影响性能。因此，对于参数类型不同的功能相似的函数要取不同的名字。
  Go中不支持默认参数。
  Go函数中不支持命名嵌套定义(nested)——即在函数中再定义有名函数，但在函数中使可以定义匿名函数，而且可以将匿名函数赋值给变量，然后使用该变量来调用相应的函数。
  Go中函数支持不定长参数，但是必须放在末尾。
  Go中支持匿名函数和闭包。
  函数中的左花括号不可以另起一行。
   定义 每个普通函数的声明都包含一个名字，一个形参列表，一个可选的返回列表以及函数体。
func name(parameter-list)(result-list){  body } 函数的类型称之为函数签名。当两个函数拥有相同的形参列表和返回值列表时，认为两个函数的类型或签名是相同的。下面四种方式声明一个含有两个形参和一个返回值的函数：
func add(x int, y int)int{ return x&#43;y} func sub(x,y int)(z int) { z=x-y; return } func first(x int, _ int) int {return x} func zero(int, int) int {return 0} 函数形参以及命名返回值都属于函数最外层作用域的局部变量；实参是按值传递的，所以函数接收到的是每个实参的副本，修改函数的形参并不会影响到调用者提供的实参。但是，如果提供的实参包含引用类型，例如指针，slice，map、函数或者通道，那么当函数使用形参变量时就会可能间接地修改实参变量。
函数只能判断是否为nil，不支持其他比较操作可以认为函数是一种引用类型。
func A() {} func B() {} func main() { 	fmt.Println(hellolib.A == nil) //可以比较，结果为false } 从函数返回局部变量指针是安全的，编译器会通过逃逸分析(escape analysis）对函数中的指针进行扫描，查看它的作用域是否在函数内，来决定是否在堆上分配内存。
func LocalPtr() *int { 	x := 0x100 	return &amp;amp;x } fmt.Println(hellolib.LocalPtr()) //变成了堆内存,0xc42007a078  参数与返回值 参数   不支持有默认值的参数。
  不支持命名实参调用（即根据参数的名字打乱顺序调用，R语言支持这种方式）。
  调用时必须按照签名顺序传递指定类型和数量的实参，就算以_命名的参数也不能被忽略。
  在参数列表中，相邻的同类型参数可合并，这样写更方便一点：
func f(a, b int) {  fmt.Println(&amp;#34;Test&amp;#34;) }   参数可视作局部变量，因此不能在相同层次定义同名变量。
  不管是指针，引用类型还是其他类型参数，都是值拷贝，区别在于是拷贝目标对象还是拷贝指针。
  在函数调用前，会为形参和返回值分配内存空间，并将实参拷贝到形参内存中。
  变参（不定长）本质上是一个切片，只能接收0到多个同类型参数，且必须放到列表尾部。变参的长度可以为0，也就是说不传入参数。
func tt1(a ...int) {  fmt.Println(a) } func main() {  tt1() //可以不带参数调用 }   如果不定长参数的值都存储在切片中（不能是数组，如果是数组必须先转为切片），则使用slice...（3个点不能少）的方式进行展开，以传递参数。
  不定长参数可以作为对应类型的切片（不做任何修改）进行二次传递，而反过来不行，如上一条所示，必须在切片后面加...才能传递给不定长的参数。
  如果想传递类型不同的变长参数，一种方法是使用结构体，一种方式使用空接口。
  在函数调用中，切片、字典、通道以及接口都是按引用类型传递。
   返回值 有返回值的函数，必须有明确的return终止语句。除非有panic或者无break的死循环，才可以没有return语句。
func TestReturn(x int) int { 	for { 	break 	} } 命名返回值和参数一样，可当作函数局部变量使用，最后由return隐式返回。但是，这些特殊的“局部变量”可能会被不同层级的同名变量遮蔽，此时需要显式return返回。
func Add(x, y int) (z int) { 	{ 	z := x &#43; y //重新定义新的变量 	return z //因为有遮蔽作用，所有不可以直接使用隐式return，而需要显式的返回一个值，这相当于将新的z赋值给旧的z 	} 	return }  匿名函数 匿名函数如其名字一样，表示没有名字的函数。在定义匿名函数时，参数列表的第一对括号必须紧挨着关键字func，因为匿名函数没有名字，花括号{}涵盖着函数体，所以最后的一对圆括号()表示对该匿名函数的调用。
可以在函数内部定义匿名函数，形成类似嵌套的效果，①匿名函数可以直接调用;②或者保存到变量，作为参数或返回值。
func main() { 	func() { //匿名函数开始 	sum = 0.0 	for i := 1; i &amp;lt;= 1e6; i&#43;&#43; { 	sum &#43;= i 	} 	}() //表示调用 } 将匿名函数赋值给变量，与为普通函数提供名字标识符有着本质区别，编译器会为匿名函数生成一个随机符号名。
add := func(x, y int) int { 	return x &#43; y } println(add(23, 34)) 匿名函数可以作为参数。如下所示，相当于给匿名函数取了一个名字。
func add(f func()) { 	f() }  func main() { 	add(func() { 	println(&amp;#34;hello,world!&amp;#34;) 	}) } 在Go中不使用的匿名函数会被编译器当作错误。
在Go中普通函数和匿名函数都可作为结构体字段，或经通道传递，因为函数是一等公民。
 闭包 匿名函数同样被称之为闭包（函数式编程语言的术语）：它们被允许调用定义在其它环境下的变量。闭包可使得某个函数捕捉到一些外部状态，例如：函数被创建时的状态。另一种表示方式为：一个闭包继承了函数所声明时的作用域。这种状态（作用域内的变量）都被共享到闭包的环境中，因此这些变量可以在闭包中被操作，直到被销毁。
在Go中闭包函数保存并积累其中的变量的值，不管外部函数退出与否，它都能够继续操作外部函数中的局部变量。
func main() { 	var f = Adder() 	fmt.Print(f(1), &amp;#34; - &amp;#34;) 	fmt.Print(f(20), &amp;#34; - &amp;#34;) 	fmt.Print(f(300)) //输出结果为：1-21-321 }  func Adder() func(int) int { 	var x int 	return func(delta int) int { 	x &#43;= delta 	return x 	} } 在闭包中使用到的变量可以是在闭包函数体内声明的，也可以是在外部函数声明的：
var g int go func(i int) { 	s := 0 	for j := 0; j &amp;lt; i; j&#43;&#43; { 	s &#43;= j 	} 	g = s }(1000) // Passes argument 1000 to the function literal. 一个返回值为另一个函数的函数可以被称之为工厂函数，这在需要创建一系列相似的函数的时候非常有用：书写一个工厂函数而不是针对每种情况都书写一个函数。
可以返回其它函数的函数和接受其它函数作为参数的函数均被称之为高阶函数，是函数式语言的特点。
闭包只是在形式和表现上像函数，但实际上不是函数。函数是一些可执行的代码，这些代码在函数被定义后就确定了，不会在执行时发生变化，所以一个函数只有一个实例。
闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。
所谓引用环境是指在程序执行中的某个点所有处于活跃状态的约束所组成的集合。其中的约束是指一个变量的名字和其所代表的对象之间的联系。
那么为什么要把引用环境与函数组合起来呢？这主要是因为在支持嵌套作用域的语言中，有时不能简单直接地确定函数的引用环境。这样的语言一般具有这样的特性：
  函数是一阶值（First-class value），即函数可以作为另一个函数的返回值或参数，还可以作为一个变量的值。
  函数可以嵌套定义，即在一个函数内部可以定义另一个函数。
   延迟调用 语句defer向当前函数注册稍后执行函数调用，这些调用被称为延迟调用，因为它们直到函数执行结束前才被执行「遇到return或者panic也会触发延迟调用」。延迟调用常用于资源的释放，解除锁定，以及错误处理等操作。
  延迟调用注册时，必须提供执行所需参数(哪怕为空),参数值在注册时被拷贝缓存起来。
  多个延迟注册按照FILO(后进先出)次序执行。
  编译器通过插入额外指令来实现延迟调用执行，而return和panic语句会终止当前函数流程，引发延迟调用。
  在Go中，return语句不是ret汇编指令，它会先更新返回值。即Go中函数的return value不是原子操作，而是在编译器中分解为两部分：返回值赋值 和 return。而defer刚好被插入到末尾的return前执行。
func TestDefer() (z int) { 	defer func() { 	fmt.Println(&amp;#34;defer&amp;#34;, z) //100 	z &#43;= 100 	}() 	return 100 //先将100赋值给z，然后执行defer函数，最后返回200 } 相比于直接使用CALL指令调用函数，延迟调用则花费更大代价，包括注册、调用等操作，还有额外的缓存开销。
var m sync.Mutex  func call() { 	m.Lock() 	m.Unlock() } func deferCall() { 	m.Lock() 	defer m.Unlock() } func BenchmarkCall(b *testing.B) { 	for i := 0; i &amp;lt; b.N; i&#43;&#43; { 	call() 	} } func BenchmarkDefer(b *testing.B) { 	for i := 0; i &amp;lt; b.N; i&#43;&#43; { 	deferCall() 	} }  error 标准库将 error定义为接口类型，以便实现自定义错误类型。
type error inferface{  Error() string //只要实现了该方法，就认为是自定义的接口类型  } 按照惯例error总是最后一个返回参数，标准库提供了相关创建函数，可方便地创建包含简单错误文本的error对象
var errDivByZero = errors.New(&amp;#34;division by zero&amp;#34;)  func div(x,y int)(int, error){ 	if y ==0{ 	return 0,errDivByZero 	} 	return x/y,nil }  func TestDiv(){ 	z,err:= div(5,0) 	if err == errDivByZero{ 	log.Fatalln(err) 	} 	fmt.Println(z) } 如果要自定义错误类型，则只要实现Error方法就可以
type DivError struct { 	x,y int }  func(DivError) Error() string{ 	return &amp;#34;division by zero&amp;#34; }  func div1(x,y int)(int,error){ 	if y==0 { 	return 0,DivError{x,y} 	}  	return x/y,nil } 通常建议应该通过错误变量，而非错误文本内容来判定错误类型。
 panic和recover 与error相比，panic/recover在使用上更接近try/catch。它们是内置函数而非语句。panic会立即中断当前函数流程，执行延迟调用。而在延迟调用函数中，recover可捕获并返回panic提交的错误对象。
func panic(v interface{}) func recover() interface{} func TestPanic(){ 	defer func(){ 	if err:=recover();err !=nil{ 	log.Fatalln(err) 	} 	}()  	panic(&amp;#34;I am dead&amp;#34;) 	println(&amp;#34;exit&amp;#34;) //不会被执行 }   连续调用panic，仅最后一个panic会被recover捕获
  在延迟函数调用panic，不会影响后续延迟调用执行，而recover之后panic，可被再次捕获。
  recover必须在延迟调用函数中执行才能正常工作。
  除非是不可恢复性，导致系统无法正常工作错误，否则不建议使用panic。
  调试阶段，可使用runtime/debug.PrintStack函数输出完整调用堆栈信息。
   </content>
    </entry>
    
     <entry>
        <title>Go 表达式</title>
        <url>https://iihui.github.io/post/go-expression/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html"> 运算符 在Go中，一元运算符优先级最高，二元则分为5个级别，二元运算符遵循相同优先级从左到右依次计算，二元运算符从高到低的5个等级为：
* / % &amp;lt;&amp;lt; &amp;gt;&amp;gt; &amp;amp; &amp;amp;^
&#43; - | ^
== != &amp;lt; &amp;lt;= &amp;gt; &amp;gt;=
&amp;amp;&amp;amp;
||
二元运算符中除了移位操作外，操作数类型必须相同。如果其中一个是无显式类型声明的常量（该常量声明时，没有给出类型），那么该常量操作数会自动转型。
在Go中，位移右操作数必须是无符号整数，或可以转换的无显式类型常量（用整数字面值来定义常量时，未指定常量的类型）。
b := 23 x := 1 &amp;lt;&amp;lt; b // 错误，b的类型是int，使用简短模式声明的是变量 自增与自减「只有后置&#43;&#43;与后置--」不再是运算符，只能作为独立语句，不能用于表达式,也就是不能作为if中的condition，这与其他语言有很大的区别。
a := 1 //&#43;&#43;a //错误，只有后置&#43;&#43;与--  if a&#43;&#43; &amp;gt; 1{ //❌，不能作为表达式 } p := &amp;amp;a *p&#43;&#43; //优先级一样等价于(*p)&#43;&#43; 指针类型 指针类型支持相等运算符，但不支持做加减运算和类型转换。
指针没有专门指向成员的-&amp;gt; 运算符，统一使用.来选择表达式，编译器会自动做转换。
零长度对象的地址是否相等和具体的实现版本有关，但是绝对不等于nil。
var a, b struct{} print(&amp;amp;a, &amp;amp;b) //xc420039f56 0xc420039f56 fmt.Println(&amp;amp;a == &amp;amp;b, &amp;amp;a == nil) //true false 复合类型初始化 对复合类型（数组、切片、字典、结构体）变量初始化时，要遵循如下原则
  初始化表达式必须包含类型标签。
  左花括号必须在类型尾部，不能另起一行。
  多个成员初始值以逗号分隔。
  允许多行，但每行须以逗号或者右花括号结束。
  流控制 Go语言中仅支持三种控制语句，分别是if、switch、for。不同于其他语言，这3种控制语句中均可以有预处理语句「大多数情况下是变量定义」。
if 语句 if条件表达式可以省略括号「推荐的做法」；并且条件表达式的值必须是布尔类型；其中左括号不能另起一行。
x := 3 if x &amp;gt; 3 { 	fmt.Println(&amp;#34;A&amp;#34;) } else if x &amp;lt; 3 &amp;amp;&amp;amp; x &amp;gt; 0 { 	fmt.Println(&amp;#34;B&amp;#34;) } else { 	fmt.Println(&amp;#34;C&amp;#34;) } if中的条件判断语句之前：①允许声明一个变量；②执行函数调用。在预处理语句和条件语句间，它们使用分号分隔。如果是变量定义的话，这个变量的作用域只能在该条件逻辑块中，既包括if又包括else。
if a,b := x&#43;1,x&#43;10; a&amp;lt;b{  fmt.Println(a,b) }else { 	fmt.Println(&amp;#34;Test&amp;#34;) } 	if InitIF(); x &amp;lt; 10{ 	fmt.Println(&amp;#34;initif&amp;#34;) } func InitIF(){ 	fmt.Println(&amp;#34;Init&amp;#34;) } switch语句 一个case中可以有多个匹配条件，此时只要匹配其中一个就可以了。对于case是常量的情况，不能有重复的情况：
a, b, c, x := 1, 2, 3, 2 switch x { case a, b: 	fmt.Println(&amp;#34;a|b&amp;#34;) case c: 	fmt.Println(&amp;#34;c&amp;#34;) case 4: 	fmt.Println(&amp;#34;d&amp;#34;) default: 	fmt.Println(&amp;#34;z&amp;#34;) } switch中的条件表达式支持非常量值，这比C和C&#43;&#43;更灵活
switch支持初始化语句，按从上往下匹配，只有全部匹配失败时才执行default块,不会因为default语句在前面就先匹配default块。考虑到default的作用相当于else，所以建议将其放到末尾。
switch y := 5; y { default: 	y &#43;= 100 	fmt.Println(y) case 5: 	y &#43;= 50 	fmt.Println(y) } //55 不能出现重复的case常量值；相邻的空case不构成多条件匹配「这个与C和C&#43;&#43;有明显的区别」
无需显式执行break语句，case执行完毕后自动中断。
如需贯通后续case （按照源码顺序) 必须执行fallthrough,但不再匹配后续条件表达式，而且fallthrough必须放在case块末尾，可使用break语句阻止。
switch z := 20; z { default: 	fmt.Println(&amp;#34;default&amp;#34;) case 20: 	z &#43;= 10 	fmt.Println(z) 	fallthrough //必须是case语句块的最后一条语句 case 21: 	z &#43;= 88 	fmt.Println(z) } // 30 118  switch z := 20; z { case 20: 	z &#43;= 10 	fmt.Println(z) 	fallthrough //必须是case语句块的最后一条语句 case 21: 	z &#43;= 88 	fmt.Println(z) default: 	fmt.Println(&amp;#34;default&amp;#34;) } // 结果仍然是30 118 其中default语句不会执行 被省略条件表达式的switch，其表达式的默认值为true。这种情况，可以用来替换if语句
switch z1 := 5; { case z1 &amp;gt; 5: 	fmt.Println(&amp;#34;z1&amp;gt;5&amp;#34;) case z1 &amp;gt; 0 &amp;amp;&amp;amp; z1 &amp;lt;= 5: 	fmt.Println(&amp;#34;z1&amp;gt;0 &amp;amp;&amp;amp; z1&amp;lt;=5&amp;#34;) case z1 &amp;lt;= 0: 	fmt.Println(&amp;#34;z1&amp;lt;=&amp;#34;) default: 	fmt.Println(&amp;#34;Test&amp;#34;) } //z1&amp;gt;0 &amp;amp;&amp;amp; z1&amp;lt;=5 for语句 for语句，包括一般的for语句和 for range 语句。一般的for语句包括3种情况：①有初始化语句和条件判断语句的；②只有条件判断语句的；③既没有初始化语句也没有条件判断语句的。
for i := 1; i &amp;lt; 10; i&#43;&#43; { 	println(i) }  x1 := []int{12, 34, 78, 9, 22, 7, 9} //切片  for i, n := range x1 { 	println(i, &amp;#34;:&amp;#34;, n) } for x &amp;lt; 5 { 	println(x) 	x&#43;&#43; } for { 	println(x) 	x-- 	if x == 0 { 	break 	} } 初始化表达式支持函数调用或定义局部变量，其中初始化语句仅被执行一次，条件表达式如果有函数调用，须确认是否会被重复执行，可能会被编译器优化掉，也可能动态结果须每次执行确认。
func TestFor() { 	for i, c := 0, count(); i &amp;lt; c; i&#43;&#43; { 	println(&amp;#34;a&amp;#34;, i) 	}  	c := 0 	for c &amp;lt; count() { 	println(&amp;#34;b&amp;#34;, c) 	c&#43;&#43; 	} }  func count() int { 	print(&amp;#34;count.&amp;#34;) 	return 3 } 可用for ...range 完成数据迭代，支持字符串、数组、数组指针、切片、字典、通道类型，返回索引、键值数据。 range目标表达式是函数调用，也仅被执行一次。
data := [3]string{&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;} for i, s := range data { 	println(i, s)  } for i := range data { 	println(i, data[i]) } for _, s := range data { 	println(s) } for range data { //清空data } fmt.Println(data) break与continue break用于switch，for，select语句终止整个语句块执行
continue仅用于for循环，终止后续逻辑，立即进入下一轮
配合标签，break和continue可在多层嵌套中指定目录层级
outer: 	for x := 0; x &amp;lt; 10; x&#43;&#43; { 	for y := 0; y &amp;lt; 10; y&#43;&#43; { 	if y &amp;gt; 2 { 	println() 	continue outer 	} 	if x &amp;gt; 2 { 	break outer 	} 	println(x, y) 	} 	} </content>
    </entry>
    
     <entry>
        <title>Go 常量</title>
        <url>https://iihui.github.io/post/go-const/</url>
        <categories>
          <category>Go</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html">  常量是一种表达式，其可以保证在编译阶段计算出表达式的值，并不需要等到运行时，从而使编译器得以知晓其值。常量值必须是编译期可确定的字符、字符串、数字或布尔值。可指定常量类型，或由编译器通过初始值推断。
 特别说明 Go中常量可以是任意基本类型，也包括具名的基本类型(例如time.Duration)。但是许多常量并不从属某一具体类型。编译器将这些从属类型待定的常量表示成某些值，这些值比基本类型的数字精度更高，且算术精度高于原生的机器精度，可以认为它们的精度至少达到256位。
从属类型待定的常量共有6种，分别是：①无类型布尔；②无类型整数；③无类型文字符号(例如&#39;a&#39;)；④无类型浮点数；⑤无类型复数；⑥无类型字符串。
借助推迟确定从属类型，无类型常量不仅能够暂时维持更高的精度，与类型已确定的常量相比，还能写进更多的表达式无需类型转换。
在Go中只有常量才可以是无类型的。如果将无类型的常量声明为变量或者在类型明确的变量赋值的右方出现无类型的常量，则常量会被隐式转换为该变量的类型：
var f float64=3&#43;0i //无类型复数-&amp;gt;float64 f=2 //无类型整数-&amp;gt;float64 f=1e123 //无类型浮点数-&amp;gt;float64 f=&amp;#39;a&amp;#39; //无类型文字符号-&amp;gt;float64 不论隐式转换还是显式转换，常量从一种类型转换为另一种类型，都要求目标类型能够表示原值，实数和复数允许舍入取整。
const (  x =0xdeadbeef //无类型整数，值为3735928559  a = uint32(x) //unit32,值为3735928559没有超出范围  b = float32(x)//float32,值为3735928559  c = int32(x) //编译错误，溢出  d = float64(1e309) //编译错误，溢出  f = uint(-1) //编译错误，溢出，unit无法容纳-1  ) 变量声明时（包括简短声明）中，假如没有显式指定类型，无类型常量会隐式转换为该变量的默认类型。对于bool型来说为false，对于整型、浮点、复数来说为0，字符串为“”，引用类型为nil，复合类型为其基础类型的零值。
i:=0 //无类型整数，隐式int(0） r:=&amp;#39;\000&amp;#39; //无类型文字常量，隐式rune(&amp;#39;\000&amp;#39;)，这个要记住 f:=0.0 //无类型浮点数，隐式float64(0.0) c:=0i //无类型整数，隐式complex128(0i)  注意事项 常量必须是编译期可确定的字符、字符串、数字或布尔值。可指定常量类型，或由编译器通过初始化值推导，不支持C/C&#43;&#43;的数字类型后缀。
定义常量的时候必须初始化，否则编译错误。不同于未使用的局部变量，不使用的常量不会引起编译错误。
const x = 123 fmt.Println(x) const y = 1.23 { 	const x = &amp;#34;abc&amp;#34; 	fmt.Println(x) } 对于常量操作数，所有数学运算、逻辑运算和比较运算的结果依然是常量。常量的类型转换结果和某些内置函数的返回值，例如len,cap,real,imag,complex,unsafe.Sizeof同样是常量，因此可以将这些函数作用于常量用于常量的初始化。
在常量组中，如果不指定类型和初始化值，则与上一行非空常量右值（表达式文本）相同
const ( 	x uint16 = 120 	y 	s = &amp;#34;abc&amp;#34; 	z ) fmt.Println(x, y, s, z) //120,120,abc,abc 数字常量在预处理阶段直接展开，作为指令数据使用，不分配内存，因此无法获取地址
package main  const y = 0x200  func main() { 	println(y) 	//println(&amp;amp;y) // 错误，不能获取地址，这与C&#43;&#43;有很大的区别 } const t = y //同样无法获取t的地址 const x = 100 //x没有明确指定类型，也就是前面说的待定类型 const y byte = x //直接展开x，相当于const y byte = 100 如果显式指定类型，必须确定常量左右值类型一致，需要时可做显式转换，右值不能超出常量类型取值范围，否则会引起溢出错误。
const ( 	t1, t2 int = 99, -999 	t3 byte = byte(t1) //t1 指定为int型，需显式转换为byte类型，注意于上一个例子的区别 	//t4 = uint8(t2) // 常量-999,超出了unit8的范围，会报溢出错误 ) 常量值可以是某些编译器能计算出结果的表达式，如 unsafe.Sizeof、len、cap，不能是运行时才能计算出结果的表达式。因此len，cap等内置函数用于定义常量时，不能作用于变量。
const ( 	ptrSize = unsafe.Sizeof(uintptr(0)) //8 	strSize = len(&amp;#34;hello world!&amp;#34;) //12 	)  </content>
    </entry>
    
     <entry>
        <title>Go 基本类型</title>
        <url>https://iihui.github.io/post/go-type/</url>
        <categories>
          <category>code</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html"> Go语言中定义了清晰完备的预定义基本类型（共21类），使得开发跨平台应用时无须过多考虑符号和长度差异，具体如下表：
![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-12-21 下午2.36.532.jpg)
 整型数据   十进制整数，使用0-9的数字表示且不以0开头。
  八进制整数，以0开头，0-7的数字表示。
  十六进制整数，以0X或者是0x开头0-9|A-F|a-f组成。
a,b,c:=100,0144,0x64 fmt.Println(a,b,c) //100 100 100 //打印的时候默认是10进制 fmt.Printf(&amp;#34;0b%b, %#o,%#x\n&amp;#34;,a,a,a) //0b1100100, 0144,0x64 //%#b可以打印二进制，但是为了区分在前面条件0b fmt.Printf(&amp;#34;0b%#b,0b%b&amp;#34;,a,a) fmt.Println(math.MinInt8,math.MaxInt8) //-128,127   标准库strconv可在不同进制（字符串）间转换。
x,_:=strconv.ParseInt(&amp;#34;1100100&amp;#34;,2,32) //解释给定字符，2表示字符串是的基数是2，即以2进制表示， //32表示给出的结果至少要适应32位，返回值的类型为int64 y,_:=strconv.ParseInt(&amp;#34;0144&amp;#34;,8,32) //字符串是8进制 z,_:=strconv.ParseInt(&amp;#34;64&amp;#34;,16,32) //字符串是16进制  fmt.Println(x,y,z) //100 100 100  fmt.Println(strconv.FormatInt(x,2)) //1100100,转换为2进制表示 fmt.Println(strconv.FormatInt(x,8)) //0144，转换为8进制表示 fmt.Println(strconv.FormatInt(x,16)) //64，转换为16进制表示   默认整数类型是int，不同类型之间的运算需要进行强制类型转换。
a : = 10 b ：= byte(100) //100的默认类型是int，如果要使得b的类型为byte，那么就要用强制类型转换 c := a &#43; int(b) //a 和 b是不同的数据类型，因此要转换成一致的数据类型    浮点型 浮点数由整数部分、小数点和小数部分组成，整数部分和小数部分可以隐藏其中一种。也可以使用科学计数法表示（把一个数表示成$a$（$1\le a \lt 10，n$为整数）与10的幂相乘的形式，这种记数法叫做科学记数法）。
     72.40 072.40 和 72.40一样，这里就不区分8进制与10进制，浮点数的数字就全部是10进制了 2.71823 6.67428e-11 1E6 //这个也是浮点数 .25 .12345E&#43;5  浮点数的默认类型是float64，使用时需要注意小数点的位置。float32保证7位有效数字「小数点后7位」，float64保证15位有效数字「小数点后15位」。具体细节参见IEEE-754标准。
var a float32 = 1.1234567899 //保证小数点后7位有效数字 var b float32 = 1.12345678 //保证小数点后7位有效数字 var c float32 = 1.123456781 //保证小数点后7位有效数字  fmt.Println(a, b, c) // 1.1234568 1.1234568 1.1234568 fmt.Println(a == b, b == c) //true true 因为保证7位有效数字—小数点后7位 fmt.Printf(&amp;#34;%v %v %v\n&amp;#34;, a, b, c) //1.1234568 1.1234568 1.1234568  复数类型 由一个整数或者是一个小数加上i表示，在Go中它的默认类型是complex128即64位实部分&#43;64位虚部，虚部如下所示：
 0i 011i //==11i 这里不是八进制了，和浮点数一样，数字均表示10进制 0.i 2.71825i 6.23423-11i 1E&#43;6i .25i .1234E&#43;5i   引用 特指slice，map，channel这三种预定义类型，引用类型具有更复杂的存储结构，除分配内存外，还必须初始化一系列属性，诸如指针、长度、甚至包括哈希分布，数据队列等。
内置函数new按指定类型长度分配零值内存，返回指针，并不关心类型内部构造和初始化方式。而引用类型必须使用make函数创建，编译器会将make转换为目标类型专用的创建函数（指令）以确保完成全部内存分配和相关属性初始化。
m := make(map[string]int) m[&amp;#34;a&amp;#34;] = 1 fmt.Println(m) //map[a:1] s := make([]int, 0, 10) s = append(s, 100) fmt.Println(s) //[100] new函数也可以为引用类型分配内存，但是不完整创建。 以字典为例，它仅分配了字典本身所需的内存，并没有分配键值存储内存，也没有初始化散列桶等内部属性，因此无法正常工作
p := new(map[string]int) t := *p //t[&amp;#34;a&amp;#34;] = 100 //fmt.Println(t) //panic: assignment to entry in nil map  别名 在官方文档中，专门提到了两个别名 byte alias for unit8以及rune alias for int32
  别名类型无需转换，可直接赋值。别名的作用是为了“见型知意”
  拥有相同底层结构的就不一定是别名，就算在64位平台上int和int64结构完全一致，但是这两个也分属不同类型，这两个类型参与运算时须显式转换。
   未命名类型（8种） 在Go中 数组、切片、字典、通道类型与具体元素类型或长度属性相关，故被称为未命名类型。具有相同声明的未命名类型被称为同一类型。
  具有相同基类型的指针
  具有相同元素类型和长度的数组array
  具有相同元素类型的切片slice
  具有相同键值类型的字典map
  具有相同数据类型以及操作方向的通道channel
  具有相同字段序列（字段名、字段类型、标签以及字段顺序）的结构体struct
  具有相同签名的（参数和返回值列表，不包括参数名）的函数func，其中函数的参数顺序也属于签名的组成部分
  具有相同方法集（方法名，方法签名，不包括顺序）的接口
  容易被忽略的是结构体的标签struct tag 它属于类型组成的一部分，而不仅仅是元数据描述
var a struct { 	x int `x` 	s string `s` }  var b struct { 	x int 	s string }  b = a //这是错误的，因为一个有标签，另一个没有标签 fmt.Println(b)  指针 指针的默认值是nil，不支持加减操作和类型转换，只支持相等判断,这一点与C和C&#43;&#43;有很大区别
x := 100 p := &amp;amp;x //p&#43;&#43; //不能加 //p&#43;1 //不能加，只能比较是否相等 var p2 = p fmt.Println(p2 == p) //true 在指针的比较中，如果两个指针指向同一个地址，或都为nil则相等
 接口 接口定义了一个函数集合，但是这些方法不包括实现——它们是抽象的，接口里也不能含变量。
 自定义类型 使用关键字type 定义用户自定义类型，包括基于现有基础类型创建，或者是结构体、函数类型。与const和 var类似，多个type定义可以合并为组，可在函数或者代码块内定义局部类型
type ( 	user struct { 	name string 	age uint8 	} 	event func(string) bool ) 当自定义类型指定了基础类型时，也只表明他们具有相同的底层数据结构，两者间不存在任何关系，属于完全不同的两种类型，不能直接进行赋值操作。
除了操作符外，自定义类型不会继承基础类型的其他信息（包括方法），不能视作别名，不能隐式转换，不能直接用于比较表达式。
type X int var m X = 23  if m &amp;lt; 100 { //继承操作符 	fmt.Println(&amp;#34;Test&amp;#34;) }  类型转换 因为隐式转换带来的问题远大于它带来的好处，Go中严格按照类型进行操作。当两个变量的类型不一致的时候要做强制类型转换。
  除了常量、别名类型以及未命名类型外，Go强制要求使用显式类型转换
  Go中不支持操作符重载
  如果转换的目标类型是指针、单向通道或没有返回值的函数类型，那么必须用括号，以避免造成语法分解错误
x := 100 p := (*int)(&amp;amp;x)    </content>
    </entry>
    
     <entry>
        <title>memcpy 的实现</title>
        <url>https://iihui.github.io/post/cpp-memcpy/</url>
        <categories>
          
        </categories>
        <tags>
          <tag>C&#43;&#43;</tag>
        </tags>
        <content type="html"> 地址重叠 void *memcpy(void *dst, const void *src, size_t n); //If copying takes place between objects that overlap, the behavior is undefined.   注意注释，对于地址重叠的情况，该函数的行为是未定义的。事实上所说的陷阱也在于此，自己动手实现memcpy时就需要考虑地址重叠的情况。
  另外，标准库也提供了地址重叠时的内存拷贝函数：memmove，那么为什么还要考虑重写memcpy函数呢?
  因为memmove函数的实现效率问题，该函数把源字符串拷贝到临时buffer里，然后再从临时buffer里写到目的地址，增加了一次不必要的开销。
  自实现版本 当可能会发生重叠时，应该从后往前拷贝，类似于vector的插入时当插入点的元素大于要插入的元素个数时。
#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;string.h&amp;gt; void *Memcpy(void *dst, const void *src, size_t size);  int main(int argc, char *argv[]) {  char buf[100] = &amp;#34;abcdefghijk&amp;#34;;  // memcpy(buf&#43;2, buf, 5);  Memcpy(buf &#43; 2, buf, 5);  printf(&amp;#34;%s\n&amp;#34;, buf &#43; 2); }  void *Memcpy(void *dst, const void *src, size_t size) {  char *psrc;  char *pdst;   if (NULL == dst || NULL == src) {  return NULL;  }   if ((src &amp;lt; dst) &amp;amp;&amp;amp; (char *)src &#43; size &amp;gt; (char *)dst) // 自后向前拷贝  {  psrc = (char *)src &#43; size - 1;  pdst = (char *)dst &#43; size - 1;  while (size--) {  *pdst-- = *psrc--;  }  } else {  psrc = (char *)src;  pdst = (char *)dst;  while (size--) {  *pdst&#43;&#43; = *psrc&#43;&#43;;  }  }   return dst; }  </content>
    </entry>
    
     <entry>
        <title>基本排序算法</title>
        <url>https://iihui.github.io/post/arith-sort/</url>
        <categories>
          <category>算法</category>
        </categories>
        <tags>
          <tag>算法</tag>
        </tags>
        <content type="html"> 基本概念   排序算法的稳定性：如果待排序的数据中，存在多个关键字相同的元素，经过排序后这些具有相同关键字的元素之间的相对次序保持不变，则称这种排序算法是稳定的，反之则为不稳定。
  内排序：排序过程中，整个表都是放在内存中处理，排序时不涉及数据的内、外交换。
  外排序：指能够处理极大量数据的排序算法，外排序处理的数据不能一次装入内存，只能放在读写较慢的外存储器(通常是硬盘)上，外排序通常采用的是一种 排序-归并 的策略。在排序阶段，先读入能放在内存中的数据量，将其排序结果输出到一个临时文件，依此进行，将待排序数据组织为多个有序的临时文件。然后在归并阶段将这些临时文件组合为一个大的有序文件，即排序结果。
   内排序算法 一般说来，内排序算法可以分为7类，分别为：
  插入排序
  交换排序
  选择排序
  归并排序
  基数排序
  桶排序
  计数排序
   插入类排序 直接插入排序 直接插入排序，是在有序的基础上对数据元素进行直接插入，代码如下所示：
template&amp;lt;typename T&amp;gt; void innerSort&amp;lt;T&amp;gt;::insertSort(T *data, int length) {  assert(length &amp;gt;= 0);  int curItem, j;  for (int i = 1; i &amp;lt; length; &#43;&#43;i) {  curItem = data[i];  for (j = i - 1; j &amp;gt;= 0; --j) {  if (curItem &amp;lt; data[j]) {  data[j &#43; 1] = data[j];  } else {  break;  }  }  data[j &#43; 1] = curItem; //j&#43;1是最终位置  } }   最好情况为待排序序列是正序的时候，比较次数为$(n-1)$次，移动次数$2(n-1)$次，时间复杂度：$O(n)$。
  最坏情况为待排序序列是逆序的时候，比较次数 $（1&#43;2&#43;3&#43;&amp;hellip;&#43;(n-1))=\frac{n(n-1)}{2}$，移动次数 $(1&#43;2&#43;&amp;hellip;&#43;(n&#43;1))=\frac{n(n&#43;1)}{2}$，时间复杂度：$O(n^2)$。
  平均时间复杂度：$O(n^2)$。
  空间复杂度：$O(1)$。
  直接插入排序不能保证一趟之后有一个元素在其最终的位置。
  直接插入是稳定的排序算法。
   折半插入排序 折半插入排序，在查找插入位置的时候使用二分查找，代码如下：
template&amp;lt;typename T&amp;gt; void innerSort&amp;lt;T&amp;gt;::binInsertSort(T *data, int length) {  assert(length &amp;gt;= 0);  int start, mid, end, curItem;  for (int i = 1; i &amp;lt; length; &#43;&#43;i) {  start = 0;  end = i - 1;  curItem = data[i];  while (start &amp;lt;= end) {  mid = start &#43; (end - start) / 2; //尽可能地避免溢出  if (data[mid] == curItem) {  end = mid; //end&#43;1便是插入位置  break;  } else if (data[mid] &amp;lt; curItem) {  start = mid &#43; 1;  } else {  end = mid - 1;  }  }  //最终的插入位置为end&#43;1,因此需要将end&#43;1所在的元素移开  for (int j = i - 1; j &amp;gt;= end &#43; 1; --j) {  data[j &#43; 1] = data[j];  }  //放到最终的插入位置 end&#43;1  data[end &#43; 1] = curItem;  } }   注意后面的第二个for循环中j &amp;gt;= end &#43; 1，因为最终位置是end&#43;1。
  从时间上看，折半插入排序只是减少了关键字间的比较次数，而元素的移动次数不变，因为找到位置之后还是要将元素全部移动，因此平均时间复杂度为$O(n^2)$。
  空间复杂度：$O(1)$，折半插入排序算法不稳定的的内排序算法，例如1，1，1，1进行折半插入排序时。
   Shell排序 Shell排序，又称为缩小增量排序方法。其基本思想是：把记录按下标的某个增量 $d$ 分组，对每组记录采用直接插入排序方法进行排序，随着增量逐渐缩小，所分成的组所包含的记录越来越多，到增量的值减少到$1$时，整个数据合成为一组，构成一组有序记录，则完成排序。
  先取一个正整数 $d_1(d_1 \lt n)$，把全部记录分成 $d_1$ 个组，所有距离为 $d_1$ 的倍数的记录看成一组，然后在各组内进行插入排序。
  然后取 $d_2(d_2 \lt d_1)$重复上述分组和排序操作；直到取 $d_i = 1(i \ge 1)$ 位置，即所有记录成为一个组，最后对这个组进行插入排序。一般选$d_1$约为$\frac{n}{2}$，$d_2$为$\frac{d_1}{2}$， $d_3$ 为 $\frac{d_2}{2}$ ，&amp;hellip;， $d_i = 1$。
  template&amp;lt;typename T&amp;gt; void innerSort&amp;lt;T&amp;gt;::shellSort(T *data, int length) {  assert(length &amp;gt;= 0);  for (int step = length / 2; step &amp;gt; 0; step /= 2) {  assistShellSort(data, length, step);  } }  template&amp;lt;typename T&amp;gt; void innerSort&amp;lt;T&amp;gt;::assistShellSort(T *data, int length, int step) {  assert(length &amp;gt;= 1 &amp;amp;&amp;amp; step &amp;gt;= 0);  int j, curItem;  for (int i = step; i &amp;lt; length; &#43;&#43;i) {  curItem = data[i];  for (j = i - step; j &amp;gt;= 0; j -= step) {  if (data[j] &amp;gt; curItem) {  data[j &#43; step] = data[j];  } else {  break;  }  }  data[j &#43; step] = curItem; //j&#43;step是最终的位置  } }   Shell排序的每趟排序，都会使得整个序列变得更加有序，等整个序列基本有序了，再来一趟直接插入排序，这样会使排序效率更高。
  Shell排序不能保证一趟之后有一个元素在其最终的位置。
  Shell排序是不稳定的排序算法，例如2,2,1(d=2,1)。
  分析Shell排序是一个复杂的问题，它的时间复杂度是增量序列的函数，到现在为止还未得到数学上的解决。
   交换类排序 大数沉底冒泡 大数沉底的冒泡排序的基本流程如下：
  比较相邻的元素，如果第一个比第二个大，就交换他们两个。
  对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对，当交换到最后的时候，最后的一个元素将会是最大的数。
  除了已经找到的元素，针对所有剩下的元素重复以上的步骤。
  持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
  //大数沉底的冒泡排序 template&amp;lt;typename T&amp;gt; void innerSort&amp;lt;T&amp;gt;::bubbleSort(T *data, int length) {  assert(length &amp;gt;= 0);  bool flag; //标识本趟是否有交换  for (int i = 1; i &amp;lt; length; &#43;&#43;i) {  flag = false; //赋值为false表示还没有数据交换  for (int j = 0; j &amp;lt; length - i; &#43;&#43;j) {  if (data[j] &amp;gt; data[j &#43; 1]) {  swap(data[j], data[j &#43; 1]);  flag = true; //本论循环中有数据元素进行交换  }  }  if (!flag) {  break; //本次循环已经没有数据元素进行交换，说明已经排好序  }  } }  小数沉底冒泡 如果要将原序列排序成逆序，则只要将小数沉底即可，即每次比较的时候当前元素比下一个元素小的时候将将其交换到后面。
void smallBubbleSort(int *data, int n) //小数下沉，最后得到逆序 {  bool flag = false;   for (int i = 1; i &amp;lt; n; &#43;&#43;i) {  flag = false;  for (int j = 0; j &amp;lt; n - i; &#43;&#43;j) {  if (data[j] &amp;lt; data[j &#43; 1]) {  std::swap(data[j], data[j &#43; 1]);  flag = true;  }  }   if (!flag)  break;  } }   最坏情况：待排序序列逆序，时间复杂度为$O(n^2)$。
  最好情况：待排序序列有序，时间复杂度为$O(n)$。
  平均时间复杂度为：$O(n^2)$。
  空间复杂度为$O(1)$。
  每次都能保证一个元素在最终位置。
  冒泡排序是稳定的排序算法。
   快速排序 快速排序: 它采用了一种分治的策略，将原问题分解为若干个规模更小但结构与原问题相似的子问题,然后递归地解这些子问题。最后将这些子问题的解组合为原问题的解。快速排序算法的步骤为：
  首先，在数据集之中，选择一个元素作为基准（pivot）, 基准的选择一般有3种
  随机选择数据元素作为基准元素
  选择中间的那个数据元素作为基准元素
  选择待排序序列的第一个元素作为基准元素
    其次，所有小于基准的元素，都移到基准的左边；所有大于基准的元素，都移到基准的右边。
  最后，基准左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。
  假设数据集为{85, 24, 63, 45, 17, 31, 96, 50}，怎么对其进行排序呢？下面采用每次选择中间的那个元素作为基准元素：
  第一步，选择中间的元素45作为基准pivot。
  第二步，按照顺序将每个元素和pivot进行比较，形成两个子集，一个小于pivot，一个大于pivot：{24，17，31}，45，{85，63，96，50}。
  第三步，对两个子集不断重复第一步和第二步，直到所有子集只剩下一个元素。17，{24，31}，45，{50}，63，{85，96}。17，24，{31}，45，50，63，85，{96}。最后得到：17，24，31，45，50，63，85，96。
  第二种方式是每次选择第一个元素作为基准的算法：
void quickHelp(int *data, int start, int end) {  if (start &amp;lt; end) {  auto pivot = adjustByFirst(data, start, end);  quickHelp(data, start, pivot - 1);  quickHelp(data, pivot &#43; 1, end);  } }  int adjustByFirst(int *data, int start, int end) {  int cur = data[start];  int i = start, j = end;  while (i &amp;lt; j) {  while (i &amp;lt; j &amp;amp;&amp;amp; data[j] &amp;gt;= cur) j--;  if (i &amp;lt; j) {  data[i] = data[j];  i&#43;&#43;:  }  while (i &amp;lt; j &amp;amp;&amp;amp; data[j] &amp;lt; cur) j--;  if (i &amp;lt; j) {  data[j] = data[i];  j--:  }  }  data[i] = cur;  return i; } 借助于栈，可以将上面的递归算法改为非递归算法：
struct Region {  int start;  int high; }; void noncurQuickSort(int *data, int length) {  Region cur, left, right;  Region stack[MAXSIZE];  int index;  int top = -1;  cur.start = 0;  cur.high = length - 1;   stack[top&#43;&#43;] = cur;   while (top != -1) {  cur = stack[top--];  index = partition(data, length, cur.start, cur.high); //调用随机选择基准的函数   if (index &amp;gt; cur.start) {  left.start = cur.start;  left.high = index - 1;  stack[&#43;&#43;top] = left;  }  if (index &amp;lt; cur.high) {  right.start = index &#43; 1;  right.high = cur.high;  stack[&#43;&#43;top] = right;  }  } } 第三个种方式是随机选择一个元素作为基准进行调整算法：
template&amp;lt;typename T&amp;gt; void innerSort&amp;lt;T&amp;gt;::quickSort(T *data, int length) {  quickSort(data, 0, length - 1); }  template&amp;lt;typename T&amp;gt; void innerSort&amp;lt;T&amp;gt;::quickSort(T *data, int start, int end) {  if (start &amp;gt;= 0 &amp;amp;&amp;amp; start &amp;lt; end) {  int pivot = getPivot(data, start, end);  if (pivot &amp;gt; start) {  quickSort(data, start, pivot - 1);  }   if (end &amp;gt; pivot) {  quickSort(data, pivot &#43; 1, end);  }  } }  template&amp;lt;typename T&amp;gt; int innerSort&amp;lt;T&amp;gt;::getPivot(T *data, int start, int end) {  assert(start &amp;gt;= 0 &amp;amp;&amp;amp; start &amp;lt; end);   int index = random(start, end);  int small = start - 1;  swap(data[index], data[end]);   for (int i = start; i &amp;lt; end; &#43;&#43;i) {  if (data[i] &amp;lt; data[end]) {  &#43;&#43;small;  if (small != i) {  swap(data[small], data[i]);  }  }  }  &#43;&#43;small;  swap(data[small], data[end]);  return small; }  //http://notes.maxwi.com/2016/04/10/cpp-random/ //https://www.cnblogs.com/byhj/p/4149467.html template&amp;lt;typename T&amp;gt; int innerSort&amp;lt;T&amp;gt;::random(int start, int end) { // static std::default_random_engine e; // static std::uniform_int_distribution&amp;lt;unsigned&amp;gt; u(start, end); // int result = u(e);  srand(time(0));  int result = std::rand() % (end - start &#43; 1) &#43; start;  return result; } 上面这种方法应该注意后面是small&#43;&#43;之后再交换，想象一下全部有序就能理解了😂。
  快速排序最好情况下的时间复杂度为$O(nlog_2n)$。
  最坏情况下的时间复杂度为$O(n^2)$。
  平均时间复杂度为$O(nlog_2n)$,就平均而言快速排序是所有排序算法中效果最好的, 这是快排的名字的由来。
  待排序序列越接近无序，算法效率越高，个人理解应该是无序的时候基点两边平衡的比较好，所以效率比较高,这是针对于以第一个元素为pivot的情况。
  待排序序列越接近有序，算法效率越低（快速排序反而蜕化为冒泡排序？）。
  快速排序的趟数和初始序列相关。
  是不稳定的排序算法2，2，1 。
  空间复杂度为$O(log_2n)$。
   选择类排序 简单选择排序 简单选择排序：每一趟在$n-i(i=1,2,&amp;hellip;,n-1)$个数据元素中$R[i],R[i&#43;1],&amp;hellip;,R[n-1]$中选择最小的数据元素作为有序序列中第$i$个数据元素。
template&amp;lt;typename T&amp;gt; void innerSort&amp;lt;T&amp;gt;::selectSort(T *data, int length) {  assert(length &amp;gt;= 0);  int index;  //从0开始便于index的取值，因为数组下标是从0开始的  for (int i = 0; i &amp;lt; length - 1; &#43;&#43;i) {  index = i;  for (int j = i &#43; 1; j &amp;lt; length; &#43;&#43;j) {  if (data[index] &amp;gt; data[j]) {  index = j;  }  }  if (index != i) {  std::swap(data[index], data[i]);  }  } }   是不稳定的排序算法，例如2，2，1。
  时间复杂度为$O(n^2)$。
  空间复杂度为$O(1)$。
   堆排序 可以把堆看成一棵完全二叉树，满足：任何一个非叶子节点的值都不大于(或不小于）其左右孩子节点的值，若父亲大孩子小，则这样的堆叫做大顶堆，若父亲小孩子大，则这样的堆叫做小顶堆。
根据堆的定义，代表堆的这棵完全二叉树的根节点的值是最大的或者最小的，因此将一个无序的序列调整为一个堆，就可以找出这个序列的最大（最小）值，然后将找出的这个值交换到序列的最后（或最前），这样有序序列元素增加1个，无序序列中元素减少1个，对新的无序序列重复这样的操作就可以实现排序。
template&amp;lt;typename T&amp;gt; void innerSort&amp;lt;T&amp;gt;::heapSort(T *data, int length) {  assert(length &amp;gt;= 0);  //首先从(length-2)/2开始调整，让他成为大顶堆  //当数组下标是从0开始的时候i的初始值就为(length-2)/2，下标为1开始时为(length-1)/2  for (int i = (length - 2) / 2; i &amp;gt;= 0; --i) {  assistHeapSort(data, i, length - 1);  }   for (int j = length - 1; j &amp;gt;= 1; --j) {  std::swap(data[0], data[j]);  assistHeapSort(data, 0, j - 1);  } }  //构建大顶堆,堆顶元素data[start] template&amp;lt;typename T&amp;gt; void innerSort&amp;lt;T&amp;gt;::assistHeapSort(T *data, int start, int end) {  assert(start &amp;lt;= end &amp;amp;&amp;amp; start &amp;gt;= 0);  int parent = start, child = 2 * start &#43; 1;  while (child &amp;lt;= end) {  //注意控制条件是child &amp;lt; end，不越界  if (child &amp;lt; end &amp;amp;&amp;amp; data[child] &amp;lt; data[child &#43; 1]) {  child&#43;&#43;;  }   if (data[parent] &amp;lt; data[child]) {  std::swap(data[parent], data[child]);  }  parent = child;  child = 2 * parent &#43; 1;  } }   平均时间复杂度为$O(nlog_2(n))$。
  最坏情况下的时间复杂度也为$O(nlog_2(n))$。
  其空间复杂度为$O(1)$,空间复杂度是指占用内存大小，每次调用完调整堆的的函数后，所占用的那一个空间都会被释放，不想快速排序那样未排完之前是不会释放辅助空间的。
  适用于记录数较多的情况。
  是不稳定排序方法，例如使用2,2,1构造小顶堆时。
   归并排序 二路归并排序：将两个有序的子序列合并成一个新的有序子序列。归并的思想：将序列看成是$n$个有序子序列，每个序列的长度为$1$,然后两两归并，得到$⌈\frac{n}{2}⌉$个长度为$2$,的有序子序列，然后两两归并&amp;hellip;，如此重复，直到得到一个长度为 $n$ 的有序子序列。
void mergeSort(int *data, int length) {  assert(length &amp;gt;= 0 || data != nullptr);   auto *copy = new int[length];   /* for (int i = 0; i &amp;lt; length; &#43;&#43;i) { copy[i] = data[i]; }*/   mergeSort(data, copy, 0, length - 1);  delete[] copy; }  void mergeSort(int *data, int *copy, int start, int end) {  if (start == end) {  copy[start] = data[start];  return;  }  int length = (end - start) / 2;  mergeSort(data, copy, start, start &#43; length);  mergeSort(data, copy, start &#43; length &#43; 1, end);   int i = start, j = start &#43; length &#43; 1, k = start;   while (i &amp;lt;= start &#43; length &amp;amp;&amp;amp; j &amp;lt;= end) {  if (data[i] &amp;lt; data[j])  copy[k&#43;&#43;] = data[i&#43;&#43;];  else  copy[k&#43;&#43;] = data[j&#43;&#43;];  }   while (i &amp;lt;= start &#43; length)  copy[k&#43;&#43;] = data[i&#43;&#43;];   while (j &amp;lt;= end)  copy[k&#43;&#43;] = data[j&#43;&#43;];   for (i = start; i &amp;lt;= end; &#43;&#43;i) {  data[i] = copy[i];  } } template&amp;lt;typename T&amp;gt; void innerSort&amp;lt;T&amp;gt;::mergeSort(T *data, int length) {  assert(length &amp;gt;= 0);  int *assist = new int[length];  memcpy(assist, data, length * sizeof(int));  assistMergeSort(data, assist, 0, length - 1);  delete[] assist; }  template&amp;lt;typename T&amp;gt; void innerSort&amp;lt;T&amp;gt;::assistMergeSort(T *data, T *assist, int start, int end) {  if (start &amp;lt; end) {  int mid = start &#43; (end - start) / 2;  assistMergeSort(data, assist, start, mid);  assistMergeSort(data, assist, mid &#43; 1, end);   int i = start, j = mid &#43; 1, k = start;   while (i &amp;lt;= mid &amp;amp;&amp;amp; j &amp;lt;= end) {  if (data[i] &amp;lt;= data[j]) {  assist[k&#43;&#43;] = data[i&#43;&#43;];  } else {  assist[k&#43;&#43;] = data[j&#43;&#43;];  }  }  while (i &amp;lt;= mid) {  assist[k&#43;&#43;] = data[i&#43;&#43;];  }  while (j &amp;lt;= end) {  assist[k&#43;&#43;] = data[j&#43;&#43;];  }   for (int l = start; l &amp;lt;= end; &#43;&#43;l) {  data[l] = assist[l];  }  } }   排序时间代价不依赖于待排序数组的初始情况。
  在最好，最坏，平均时间复杂度都为$O(nlog_2n)$ 。
  空间复杂度为$O(n)
  稳定的排序方法。
  在平均情况下还是快速排序最快（常数因子更小）。
   比较排序的最优下界 比较排序算法小结 计数排序 计数排序是一种稳定的线性时间排序算法。计数排序使用一个额外的数组count，其中第i个元素是待排序数组A中值等于i的元素的个数。
然后根据数组count来将A中的元素排到正确的位置。当输入的元素是n个0到k之间的整数时，它的运行时间是$Θ(n &#43; k)$。
计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组count的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量内存。
template&amp;lt;typename T&amp;gt; void innerSort&amp;lt;T&amp;gt;::countSort(T *data, int length) {  assert(length &amp;gt;= 0);  int min = data[0], max = data[0];   int *assistArr = new int[length]{0};  int inc = 0;   //先找出最大值和最小值  for (int i = 0; i &amp;lt; length; &#43;&#43;i) {  assert(data[i] &amp;gt;= 0);  if (data[i] &amp;gt; max) {  max = data[i];  }   if (data[i] &amp;lt; min) {  min = data[i];  }  }  if (min &amp;lt; 0) {  inc = abs(min);  }  for (int i = 0; i &amp;lt; length; &#43;&#43;i) {  data[i] &#43;= inc;  }  int countLength = (max &#43; inc &#43; 1);  int *countArr = new int[countLength]{0};   for (int i = 0; i &amp;lt; length; &#43;&#43;i) {  countArr[data[i]]&#43;&#43;;  }   //注意是计数数组的上界限  for (int j = 1; j &amp;lt; countLength; &#43;&#43;j) {  countArr[j] &#43;= countArr[j - 1];  }   for (int k = length - 1; k &amp;gt;= 0; --k) {  assistArr[--countArr[data[k]]] = data[k];  }   for (int i = 0; i &amp;lt; length; &#43;&#43;i) {  data[i] = assistArr[i] - inc;  }  delete[] assistArr;  delete[] countArr; } 桶排序 桶排序(Bucket Sort)的基本思路是：
  将待排序元素划分到不同的桶。先扫描一遍序列求出最大值$max$和最小值$min$，设桶的个数为$k$，则把区间$[min, max]$均匀划分成$k$个区间，每个区间就是一个桶。将序列中的元素分配到各自的桶。
  对每个桶内的元素进行排序。可以选择任意一种排序算法。
  将各个桶中的元素合并成一个大的有序序列。
  复杂度分析：
  假设数据是均匀分布的，则每个桶的元素平均个数为$\frac{n}{k}$。
  假设选择用快速排序对每个桶内的元素进行排序，那么每次排序的时间复杂度为$O(\frac{n}{k}log(\frac{n}{k}))$。
  $O(n)&#43;O(m)O(\frac{n}{k}log(\frac{n}{k}))=O(n&#43;nlog(\frac{n}{k}))=O(n&#43;nlogn-nlogk)$为总的时间复杂度。当$k$接近于 $n$时，桶排序的时间复杂度就可以近似认为是$O(n)$ , 此时近似为计数排序。即桶越多，时间效率就越高，而桶越多，空间就越大。
   基数排序 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。
基数排序法会使用到桶，先进先出的队列，通过将要比较的位（个位、十位、百位…），将要排序的元素分配至$0 \to 9$ 个桶中，借以达到排序的作用，在某些时候，基数排序法的效率高于其它的比较性排序算法。
void radixSort(int *data, int length) {  int max = getMax(data, length); //找出待排序数组中最大的那个数  int radix = 10;   for (int exp = 1; exp &amp;lt;= max; exp *= 10) {  bucketSort(data, length, exp, radix);  } }  void bucketSort(int *data, int length, int exp, int radix) {  auto *count = new int[radix]{0};  auto *result = new int[length];   for (int i = 0; i &amp;lt; length; &#43;&#43;i) {  count[(data[i] / exp) % radix]&#43;&#43;; //(data[i] / exp) 获取当前位的数值  }   for (int j = 1; j &amp;lt; radix; &#43;&#43;j) {  count[j] &#43;= count[j - 1];  }   for (int i = length - 1; i &amp;gt;= 0; --i) {  result[--count[(data[i] / exp) % radix]] = data[i];  }   for (int i = 0; i &amp;lt; length; &#43;&#43;i) {  data[i] = result[i];  }  delete[] result;  delete[] count; }   是稳定的排序方法。
  时间复杂度：设数组长度为$n$,基数为$r$,关键字位数为$d$,则每趟分配的时间为$O(n)$，每趟收集的时间复杂度为$O(n)$，工序$d$趟分配与收集，所以时间复杂度为$O(d(2n))$,即$O(d \times n)$。
  空间复杂度为$O(rn)$。
   外排序算法 所谓外排序，顾名思义，即排序涉及到内存外面的排序。因为当要处理的数据量很大，而不能一次装入内存时，此时只能放在读写较慢的外存储器（通常是硬盘）上。外排序通常采用的是一种排序-归并的策略。
  在排序阶段，先读入能放在内存中的数据量，将其排序输出到一个临时文件，依此进行，将待排序数据组织为多个有序的临时文件；
  在归并阶段将这些临时文件组合为一个大的有序文件，即排序结果。
  例子1 假定现在有20个数据的文件A：{5，11， 0， 18， 4， 14， 9， 7 6， 8， 12， 17 ，16 ，13 ，19 ，10， 2， 1， 3， 15}，但内存一次只能装4个数据，所以，可以每趟先选择4个数据进行排序，然后将排好序的5路数据进行归并，具体步骤如下：
  首先把大文件$A$，按顺序分割为$a_1，a_2，a_3，a_4，a_5$等5个小文件，每个小文件4个数据。
  $a_1$文件为：5,11, 0,18。
  $a_2$文件为：4,14,9,7。
  $a_3$文件为：6, 8, 12, 17。
  $a_4$文件为：16,13, 19,10。
  $a_5$文件为：2,1,3,15然后依次对5个小文件分别进行排序。
  $a_1$文件完成排序后：0,5,11,18。
  $a_2$文件完成排序后：4,7,9,14。
  $a_3$文件完成排序后：6,8,12,17。
  $a_4$文件完成排序后：10,13,16,19。
  $a_5$文件完成排序后：1,2,3,15。
  最后进行5路归并，完成排序：0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19。
   例子2 要对900MB的数据进行排序，但机器上只有100MB的可用内存时，外部归并排序按如下方法操作：
  读入100MB的数据至内存中，用某种常规排序（如：快速排序、堆排序、归并排序等）在内存中完成排序。
  将排序完成的数据写入磁盘（临时文件）。
  重复步骤1和步骤2直到所有的数据都存入了不同的100MB的块（临时文件）中。本例中，900MB数据，100MB内存，故产生了9个临时文件。
  读入每个临时文件（顺串）的前10MB($10=\frac{100}{9&#43;1}$)，在进行多路归并的时候，这里有9路，然后输出缓冲算一个，所以要将内存资源分给10个部分)的数据放入内存中的输入缓冲区（总计90MB），最后的10MB作为输出缓冲区。（实践中，将输入缓冲适当调小，而适当增大输出缓冲区能获得比较好的效果）
  执行9路归并算法，将结果输出到输出缓冲区。一旦输出缓冲区满，将缓冲区中的数据写到目标文件，清空缓冲区。一旦9个输入缓冲区的一个变空，就从这个缓冲区关联的文件中读入下一个10MB数据，除非这个文件已读完。这是外部归并排序能在主存外完成排序的关键步骤。因为归并算法对每一个大块只是顺序地做一轮访问，每个大块不用完全载入主存。
   置换选择 为了增加每一个有序的临时文件的长度，可以采用置换选择排序——它可以产生大于内存有序序列。具体方法是在内存中使用一个最小堆进行排序，设这个最小堆的大小为M，算法描述如下：
  初始时将输入文件读入内存，建立最小堆。
  将堆顶元素输出至输出缓冲区，然后读入下一个记录。
    2.1 若该元素的关键码值不小于刚输出的关键码值，将其作为堆顶元素并调整堆，使之满足堆的性质。
  2.2 若该元素的关键码值小于刚输出的关键码值，将新元素放入堆底位置，将堆的大小减1。
   重复第2步，直至堆大小变为0。
  此时一个有序序列已经产生，此时将输入缓冲区中剩下的所有元素建立最小堆，开始生成下一个有序序列。
   </content>
    </entry>
    
     <entry>
        <title></title>
        <url>https://iihui.github.io/post/ios-profile/</url>
        <categories>
          
        </categories>
        <tags>
          
        </tags>
        <content type="html"> iPhone XS Max iOS 13.7 Total pre-main time: 1.9 seconds (100.0%)  dylib loading time: 538.45 milliseconds (28.3%)  rebase/binding time: 397.03 milliseconds (20.8%)  ObjC setup time: 482.18 milliseconds (25.3%)  initializer time: 483.96 milliseconds (25.4%)  slowest intializers :  libSystem.B.dylib : 9.05 milliseconds (0.4%)  MobileRTC : 87.87 milliseconds (4.6%)  BizConfSDK : 73.70 milliseconds (3.8%)  IpCall : 70.74 milliseconds (3.7%)  CMBMobileST : 162.20 milliseconds (8.5%)   total time: 3.4 seconds (100.0%)  total images loaded: 556 (534 from dyld shared cache)  total segments mapped: 77, into 64676 pages  total images loading time: 2.0 seconds (58.7%)  total load time in ObjC: 482.18 milliseconds (13.9%)  total debugger pause time: 1.4 seconds (43.1%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 1,108,451  total rebase fixups time: 114.17 milliseconds (3.3%)  total binding fixups: 120,557  total binding fixups time: 261.86 milliseconds (7.5%)  total weak binding fixups time: 80.24 milliseconds (2.3%)  total redo shared cached bindings time: 59.25 milliseconds (1.7%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 483.96 milliseconds (14.0%)  libSystem.B.dylib : 9.05 milliseconds (0.2%)  libBacktraceRecording.dylib : 7.90 milliseconds (0.2%)  libMTLCapture.dylib : 25.22 milliseconds (0.7%)  AgoraCore : 6.57 milliseconds (0.1%)  AgoraRtcKit : 17.58 milliseconds (0.5%)  AgoraRtmKit : 6.52 milliseconds (0.1%)  MobileRTC : 87.87 milliseconds (2.5%)  BizConfSDK : 73.70 milliseconds (2.1%)  IpCall : 70.74 milliseconds (2.0%)  JMSDK : 13.78 milliseconds (0.3%)  WebRTC : 4.23 milliseconds (0.1%)  CMBMobileST : 162.20 milliseconds (4.7%) total symbol trie searches: 501802 total symbol table binary searches: 0 total images defining weak symbols: 57 total images using weak symbols: 141 去除招乎代码之后 Total pre-main time: 762.07 milliseconds (100.0%)  dylib loading time: 134.11 milliseconds (17.5%)  rebase/binding time: 249.01 milliseconds (32.6%)  ObjC setup time: 154.58 milliseconds (20.2%)  initializer time: 224.36 milliseconds (29.4%)  slowest intializers :  libSystem.B.dylib : 6.34 milliseconds (0.8%)  libMainThreadChecker.dylib : 36.11 milliseconds (4.7%)  libMTLCapture.dylib : 21.32 milliseconds (2.7%)  CMBMobileST : 221.18 milliseconds (29.0%)   total time: 2.2 seconds (100.0%)  total images loaded: 451 (443 from dyld shared cache)  total segments mapped: 29, into 760 pages  total images loading time: 1.5 seconds (71.1%)  total load time in ObjC: 154.58 milliseconds (6.9%)  total debugger pause time: 1.4 seconds (65.1%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 376,693  total rebase fixups time: 31.87 milliseconds (1.4%)  total binding fixups: 68,566  total binding fixups time: 180.99 milliseconds (8.0%)  total weak binding fixups time: 54.56 milliseconds (2.4%)  total redo shared cached bindings time: 18.42 milliseconds (0.8%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 224.36 milliseconds (10.0%)  libSystem.B.dylib : 6.34 milliseconds (0.2%)  libBacktraceRecording.dylib : 7.72 milliseconds (0.3%)  libMainThreadChecker.dylib : 36.11 milliseconds (1.6%)  libMTLCapture.dylib : 21.32 milliseconds (0.9%)  CMBMobileST : 221.18 milliseconds (9.8%) total symbol trie searches: 384738 total symbol table binary searches: 0 total images defining weak symbols: 49 total images using weak symbols: 117 Total pre-main time: 1.1 seconds (100.0%)  dylib loading time: 162.00 milliseconds (14.3%)  rebase/binding time: 446.00 milliseconds (39.6%)  ObjC setup time: 262.91 milliseconds (23.3%)  initializer time: 254.93 milliseconds (22.6%)  slowest intializers :  libSystem.B.dylib : 13.37 milliseconds (1.1%)  libMainThreadChecker.dylib : 35.57 milliseconds (3.1%)  libMTLCapture.dylib : 29.51 milliseconds (2.6%)  CMBMobileST : 225.28 milliseconds (20.0%)   total time: 2.7 seconds (100.0%)  total images loaded: 451 (443 from dyld shared cache)  total segments mapped: 29, into 760 pages  total images loading time: 1.7 seconds (63.4%)  total load time in ObjC: 262.91 milliseconds (9.5%)  total debugger pause time: 1.5 seconds (57.6%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 376,693  total rebase fixups time: 34.03 milliseconds (1.2%)  total binding fixups: 68,566  total binding fixups time: 395.23 milliseconds (14.3%)  total weak binding fixups time: 58.50 milliseconds (2.1%)  total redo shared cached bindings time: 41.77 milliseconds (1.5%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 254.93 milliseconds (9.2%)  libSystem.B.dylib : 13.37 milliseconds (0.4%)  libBacktraceRecording.dylib : 7.63 milliseconds (0.2%)  libMainThreadChecker.dylib : 35.57 milliseconds (1.2%)  libMTLCapture.dylib : 29.51 milliseconds (1.0%)  CMBMobileST : 225.28 milliseconds (8.1%) total symbol trie searches: 384738 total symbol table binary searches: 0 total images defining weak symbols: 49 total images using weak symbols: 117 iPhone XS iOS 13.3.1 Total pre-main time: 1.9 seconds (100.0%)  dylib loading time: 827.84 milliseconds (42.8%)  rebase/binding time: 428.34 milliseconds (22.1%)  ObjC setup time: 296.91 milliseconds (15.3%)  initializer time: 376.98 milliseconds (19.5%)  slowest intializers :  libSystem.B.dylib : 10.29 milliseconds (0.5%)  MobileRTC : 69.22 milliseconds (3.5%)  BizConfSDK : 54.21 milliseconds (2.8%)  IpCall : 62.84 milliseconds (3.2%)  CMBMobileST : 109.94 milliseconds (5.6%)   total time: 3.3 seconds (100.0%)  total images loaded: 552 (530 from dyld shared cache)  total segments mapped: 77, into 64659 pages  total images loading time: 2.1 seconds (65.1%)  total load time in ObjC: 296.91 milliseconds (8.8%)  total debugger pause time: 1.3 seconds (40.4%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 1,108,451  total rebase fixups time: 99.35 milliseconds (2.9%)  total binding fixups: 120,475  total binding fixups time: 312.01 milliseconds (9.3%)  total weak binding fixups time: 79.09 milliseconds (2.3%)  total redo shared cached bindings time: 62.11 milliseconds (1.8%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 376.98 milliseconds (11.2%)  libSystem.B.dylib : 10.29 milliseconds (0.3%)  libBacktraceRecording.dylib : 7.35 milliseconds (0.2%)  libMTLCapture.dylib : 18.50 milliseconds (0.5%)  AgoraRtcKit : 30.24 milliseconds (0.9%)  AgoraRtmKit : 4.47 milliseconds (0.1%)  MobileRTC : 69.22 milliseconds (2.0%)  BizConfSDK : 54.21 milliseconds (1.6%)  IpCall : 62.84 milliseconds (1.8%)  JMSDK : 12.02 milliseconds (0.3%)  CMBMobileST : 109.94 milliseconds (3.2%) total symbol trie searches: 492104 total symbol table binary searches: 0 total images defining weak symbols: 56 total images using weak symbols: 140 iPhone 8 Plus iOS 14.7.1 Total pre-main time: 3.1 seconds (100.0%)  dylib loading time: 928.47 milliseconds (29.2%)  rebase/binding time: 1.7 seconds (53.8%)  ObjC setup time: 247.29 milliseconds (7.7%)  initializer time: 289.48 milliseconds (9.1%)  slowest intializers :  libSystem.B.dylib : 7.36 milliseconds (0.2%)  IpCall : 64.62 milliseconds (2.0%)  CMBMobileST : 93.64 milliseconds (2.9%)   total time: 11.1 seconds (100.0%)  total images loaded: 627 (607 from dyld shared cache)  total segments mapped: 71, into 64391 pages  total images loading time: 3.6 seconds (33.0%)  total load time in ObjC: 247.29 milliseconds (2.2%)  total debugger pause time: 2.7 seconds (24.6%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 1,124,101  total rebase fixups time: 1.7 seconds (15.3%)  total binding fixups: 1,888,598  total binding fixups time: 5.1 seconds (46.7%)  total weak binding fixups time: 6.43 milliseconds (0.0%)  total redo shared cached bindings time: 5.2 seconds (46.7%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 289.48 milliseconds (2.6%)  libSystem.B.dylib : 7.36 milliseconds (0.0%)  AgoraRtcKit : 19.41 milliseconds (0.1%)  MobileRTC : 61.02 milliseconds (0.5%)  GameController : 13.42 milliseconds (0.1%)  IpCall : 64.62 milliseconds (0.5%)  JMSDK : 12.75 milliseconds (0.1%)  CMBMobileST : 93.64 milliseconds (0.8%) total symbol trie searches: 2030698 total symbol table binary searches: 0 total images defining weak symbols: 90 total images using weak symbols: 179 iPhone X iOS 14.7.1 Total pre-main time: 935.41 milliseconds (100.0%)  dylib loading time: 458.72 milliseconds (49.0%)  rebase/binding time: 97.91 milliseconds (10.4%)  ObjC setup time: 84.45 milliseconds (9.0%)  initializer time: 294.32 milliseconds (31.4%)  slowest intializers :  libSystem.B.dylib : 6.90 milliseconds (0.7%)  libMTLCapture.dylib : 21.15 milliseconds (2.2%)  MobileRTC : 60.97 milliseconds (6.5%)  IpCall : 61.20 milliseconds (6.5%)  CMBMobileST : 89.33 milliseconds (9.5%)   total time: 4.6 seconds (100.0%)  total images loaded: 628 (607 from dyld shared cache)  total segments mapped: 75, into 64695 pages  total images loading time: 3.5 seconds (76.8%)  total load time in ObjC: 84.45 milliseconds (1.8%)  total debugger pause time: 3.1 seconds (67.0%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 1,140,366  total rebase fixups time: 97.52 milliseconds (2.0%)  total binding fixups: 1,889,469  total binding fixups time: 598.00 milliseconds (12.8%)  total weak binding fixups time: 5.03 milliseconds (0.1%)  total redo shared cached bindings time: 602.64 milliseconds (12.9%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 294.32 milliseconds (6.3%)  libSystem.B.dylib : 6.90 milliseconds (0.1%)  libBacktraceRecording.dylib : 7.36 milliseconds (0.1%)  libMTLCapture.dylib : 21.15 milliseconds (0.4%)  AgoraRtcKit : 16.22 milliseconds (0.3%)  AgoraRtmKit : 5.81 milliseconds (0.1%)  MobileRTC : 60.97 milliseconds (1.3%)  GameController : 5.65 milliseconds (0.1%)  IpCall : 61.20 milliseconds (1.3%)  JMSDK : 14.22 milliseconds (0.3%)  CMBMobileST : 89.33 milliseconds (1.9%) total symbol trie searches: 2033030 total symbol table binary searches: 0 total images defining weak symbols: 90 total images using weak symbols: 180 iPhone 11 iOS 15.1 ![image-20211209180145847](/Users/hui/Library/Application Support/typora-user-images/image-20211209180145847.png)
![image-20211209180202670](/Users/hui/Library/Application Support/typora-user-images/image-20211209180202670.png)
iPhone 8 iOS 12.1.2 Total pre-main time: 1.2 seconds (100.0%)  dylib loading time: 620.01 milliseconds (50.7%)  rebase/binding time: 142.79 milliseconds (11.6%)  ObjC setup time: 94.36 milliseconds (7.7%)  initializer time: 364.76 milliseconds (29.8%)  slowest intializers :  libSystem.B.dylib : 7.52 milliseconds (0.6%)  libMTLInterpose.dylib : 64.92 milliseconds (5.3%)  MobileRTC : 83.75 milliseconds (6.8%)  CMBMobileST : 146.68 milliseconds (12.0%)   total time: 2.4 seconds (100.0%)  total images loaded: 482 (435 from dyld shared cache)  total segments mapped: 149, into 67977 pages with 2916 pages pre-fetched  total images loading time: 1.4 seconds (57.3%)  total load time in ObjC: 94.36 milliseconds (3.8%)  total debugger pause time: 789.25 milliseconds (32.1%)  total dtrace DOF registration time: 0.13 milliseconds (0.0%)  total rebase fixups: 1,165,608  total rebase fixups time: 152.83 milliseconds (6.2%)  total binding fixups: 642,808  total binding fixups time: 429.44 milliseconds (17.4%)  total weak binding fixups time: 6.51 milliseconds (0.2%)  total redo shared cached bindings time: 445.98 milliseconds (18.1%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 364.76 milliseconds (14.8%)  libSystem.B.dylib : 7.52 milliseconds (0.3%)  libBacktraceRecording.dylib : 4.45 milliseconds (0.1%)  libMTLInterpose.dylib : 64.92 milliseconds (2.6%)  AgoraRtcKit : 21.12 milliseconds (0.8%)  AgoraRtmKit : 5.58 milliseconds (0.2%)  MobileRTC : 83.75 milliseconds (3.4%)  IpCall : 8.61 milliseconds (0.3%)  JMSDK : 16.15 milliseconds (0.6%)  WebRTC : 5.53 milliseconds (0.2%)  libswiftCore.dylib : 3.14 milliseconds (0.1%)  CMBMobileST : 146.68 milliseconds (5.9%) total symbol trie searches: 1422556 total symbol table binary searches: 0 total images defining weak symbols: 42 total images using weak symbols: 120 iPhone XR 12.4.1 Total pre-main time: 907.16 milliseconds (100.0%)  dylib loading time: 354.54 milliseconds (39.0%)  rebase/binding time: 210.20 milliseconds (23.1%)  ObjC setup time: 68.38 milliseconds (7.5%)  initializer time: 273.73 milliseconds (30.1%)  slowest intializers :  libSystem.B.dylib : 7.32 milliseconds (0.8%)  libMTLInterpose.dylib : 48.32 milliseconds (5.3%)  MobileRTC : 63.79 milliseconds (7.0%)  CMBMobileST : 103.82 milliseconds (11.4%)   total time: 2.2 seconds (100.0%)  total images loaded: 481 (457 from dyld shared cache)  total segments mapped: 80, into 65065 pages with 2776 pages pre-fetched  total images loading time: 1.6 seconds (73.1%)  total load time in ObjC: 68.38 milliseconds (3.0%)  total debugger pause time: 1.3 seconds (57.5%)  total dtrace DOF registration time: 0.29 milliseconds (0.0%)  total rebase fixups: 1,108,438  total rebase fixups time: 135.43 milliseconds (5.9%)  total binding fixups: 123,894  total binding fixups time: 79.60 milliseconds (3.5%)  total weak binding fixups time: 51.71 milliseconds (2.2%)  total redo shared cached bindings time: 56.54 milliseconds (2.4%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 273.73 milliseconds (12.0%)  libSystem.B.dylib : 7.32 milliseconds (0.3%)  libBacktraceRecording.dylib : 3.14 milliseconds (0.1%)  libMTLInterpose.dylib : 48.32 milliseconds (2.1%)  AgoraRtcKit : 16.51 milliseconds (0.7%)  AgoraRtmKit : 13.00 milliseconds (0.5%)  MobileRTC : 63.79 milliseconds (2.8%)  BizConfSDK : 2.84 milliseconds (0.1%)  IpCall : 5.40 milliseconds (0.2%)  JMSDK : 15.33 milliseconds (0.6%)  WebRTC : 5.88 milliseconds (0.2%)  CMBMobileST : 103.82 milliseconds (4.5%) total symbol trie searches: 380826 total symbol table binary searches: 0 total images defining weak symbols: 46 total images using weak symbols: 120 iPhone7 iOS 11.3 剥离前的冷启动 Total pre-main time: 1.7 seconds (100.0%)  dylib loading time: 900.42 milliseconds (50.8%)  rebase/binding time: 137.06 milliseconds (7.7%)  ObjC setup time: 131.64 milliseconds (7.4%)  initializer time: 601.68 milliseconds (33.9%)  slowest intializers :  libSystem.B.dylib : 17.65 milliseconds (0.9%)  libMTLInterpose.dylib : 66.05 milliseconds (3.7%)  AgoraRtcKit : 92.29 milliseconds (5.2%)  MobileRTC : 117.61 milliseconds (6.6%)  CMBMobile : 201.28 milliseconds (11.3%)   total time: 3.0 seconds (100.0%)  total images loaded: 472 (423 from dyld shared cache)  total segments mapped: 156, into 68104 pages with 2936 pages pre-fetched  total images loading time: 1.7 seconds (57.5%)  total load time in ObjC: 131.64 milliseconds (4.2%)  total debugger pause time: 868.18 milliseconds (28.2%)  total dtrace DOF registration time: 0.15 milliseconds (0.0%)  total rebase fixups: 1,155,778  total rebase fixups time: 128.26 milliseconds (4.1%)  total binding fixups: 649,585  total binding fixups time: 436.17 milliseconds (14.1%)  total weak binding fixups time: 7.71 milliseconds (0.2%)  total redo shared cached bindings time: 435.08 milliseconds (14.1%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 601.68 milliseconds (19.5%)  libSystem.B.dylib : 17.65 milliseconds (0.5%)  libBacktraceRecording.dylib : 15.31 milliseconds (0.4%)  libMainThreadChecker.dylib : 26.22 milliseconds (0.8%)  libViewDebuggerSupport.dylib : 8.99 milliseconds (0.2%)  libMTLInterpose.dylib : 66.05 milliseconds (2.1%)  AgoraRtcKit : 92.29 milliseconds (3.0%)  AgoraRtmKit : 13.18 milliseconds (0.4%)  MobileRTC : 117.61 milliseconds (3.8%)  BizConfSDK : 4.51 milliseconds (0.1%)  IpCall : 9.52 milliseconds (0.3%)  JMSDK : 20.20 milliseconds (0.6%)  libswiftCore.dylib : 4.20 milliseconds (0.1%)  WebRTC : 7.93 milliseconds (0.2%)  CMBMobile : 201.28 milliseconds (6.5%) total symbol trie searches: 1449736 total symbol table binary searches: 0 total images defining weak symbols: 55 total images using weak symbols: 124 剥离后的冷启动 Total pre-main time: 847.49 milliseconds (100.0%)  dylib loading time: 397.96 milliseconds (46.9%)  rebase/binding time: 53.20 milliseconds (6.2%)  ObjC setup time: 52.83 milliseconds (6.2%)  initializer time: 343.40 milliseconds (40.5%)  slowest intializers :  libSystem.B.dylib : 7.56 milliseconds (0.8%)  libMTLInterpose.dylib : 35.99 milliseconds (4.2%)  libswiftCore.dylib : 44.73 milliseconds (5.2%)  CMBMobileST : 241.90 milliseconds (28.5%)   total time: 1.4 seconds (100.0%)  total images loaded: 353 (319 from dyld shared cache)  total segments mapped: 102, into 4093 pages with 248 pages pre-fetched  total images loading time: 799.64 milliseconds (53.3%)  total load time in ObjC: 52.83 milliseconds (3.5%)  total debugger pause time: 401.68 milliseconds (26.8%)  total dtrace DOF registration time: 0.08 milliseconds (0.0%)  total rebase fixups: 444,245  total rebase fixups time: 48.30 milliseconds (3.2%)  total binding fixups: 460,857  total binding fixups time: 250.14 milliseconds (16.6%)  total weak binding fixups time: 4.33 milliseconds (0.2%)  total redo shared cached bindings time: 249.59 milliseconds (16.6%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 343.40 milliseconds (22.9%)  libSystem.B.dylib : 7.56 milliseconds (0.5%)  libBacktraceRecording.dylib : 8.58 milliseconds (0.5%)  libMainThreadChecker.dylib : 12.44 milliseconds (0.8%)  libMTLInterpose.dylib : 35.99 milliseconds (2.4%)  libswiftCore.dylib : 44.73 milliseconds (2.9%)  CMBMobileST : 241.90 milliseconds (16.1%) total symbol trie searches: 1166429 total symbol table binary searches: 0 total images defining weak symbols: 40 total images using weak symbols: 90 剥离后的热启动 Total pre-main time: 558.13 milliseconds (100.0%)  dylib loading time: 287.89 milliseconds (51.5%)  rebase/binding time: 35.51 milliseconds (6.3%)  ObjC setup time: 24.60 milliseconds (4.4%)  initializer time: 210.05 milliseconds (37.6%)  slowest intializers :  libSystem.B.dylib : 5.56 milliseconds (0.9%)  libMainThreadChecker.dylib : 12.68 milliseconds (2.2%)  libMTLInterpose.dylib : 27.95 milliseconds (5.0%)  CMBMobileST : 194.84 milliseconds (34.9%)   total time: 1.0 seconds (100.0%)  total images loaded: 353 (319 from dyld shared cache)  total segments mapped: 102, into 4093 pages with 248 pages pre-fetched  total images loading time: 641.42 milliseconds (58.3%)  total load time in ObjC: 24.60 milliseconds (2.2%)  total debugger pause time: 353.53 milliseconds (32.1%)  total dtrace DOF registration time: 0.06 milliseconds (0.0%)  total rebase fixups: 444,247  total rebase fixups time: 31.00 milliseconds (2.8%)  total binding fixups: 460,857  total binding fixups time: 188.33 milliseconds (17.1%)  total weak binding fixups time: 4.05 milliseconds (0.3%)  total redo shared cached bindings time: 187.88 milliseconds (17.0%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 210.05 milliseconds (19.1%)  libSystem.B.dylib : 5.56 milliseconds (0.5%)  libBacktraceRecording.dylib : 3.83 milliseconds (0.3%)  libMainThreadChecker.dylib : 12.68 milliseconds (1.1%)  libMTLInterpose.dylib : 27.95 milliseconds (2.5%)  libswiftCore.dylib : 1.31 milliseconds (0.1%)  CMBMobileST : 194.84 milliseconds (17.7%) total symbol trie searches: 1166434 total symbol table binary searches: 0 total images defining weak symbols: 40 total images using weak symbols: 90 剥离后的冷启动 Total pre-main time: 686.16 milliseconds (100.0%)  dylib loading time: 332.92 milliseconds (48.5%)  rebase/binding time: 39.67 milliseconds (5.7%)  ObjC setup time: 22.46 milliseconds (3.2%)  initializer time: 291.02 milliseconds (42.4%)  slowest intializers :  libSystem.B.dylib : 5.59 milliseconds (0.8%)  libMTLInterpose.dylib : 46.33 milliseconds (6.7%)  CMBMobileST : 230.69 milliseconds (33.6%)   total time: 1.3 seconds (100.0%)  total images loaded: 353 (319 from dyld shared cache)  total segments mapped: 102, into 4093 pages with 248 pages pre-fetched  total images loading time: 710.04 milliseconds (52.7%)  total load time in ObjC: 22.46 milliseconds (1.6%)  total debugger pause time: 377.11 milliseconds (28.0%)  total dtrace DOF registration time: 0.06 milliseconds (0.0%)  total rebase fixups: 444,247  total rebase fixups time: 35.48 milliseconds (2.6%)  total binding fixups: 460,857  total binding fixups time: 282.40 milliseconds (20.9%)  total weak binding fixups time: 3.69 milliseconds (0.2%)  total redo shared cached bindings time: 281.91 milliseconds (20.9%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 291.02 milliseconds (21.6%)  libSystem.B.dylib : 5.59 milliseconds (0.4%)  libBacktraceRecording.dylib : 6.88 milliseconds (0.5%)  libMainThreadChecker.dylib : 9.88 milliseconds (0.7%)  libMTLInterpose.dylib : 46.33 milliseconds (3.4%)  CMBMobileST : 230.69 milliseconds (17.1%) total symbol trie searches: 1166420 total symbol table binary searches: 0 total images defining weak symbols: 40 total images using weak symbols: 90 二进制重排前 测试手机为iPhone XS Max iOS版本为13.7，Xcode版本为 13.2.1，macOS版本为12.0.1。测试手机关机重启，Xcode关闭重启并清理缓存，测试4次，每次时间如下所示：
Total pre-main time: 1.6 seconds (100.0%)  dylib loading time: 522.40 milliseconds (31.4%)  rebase/binding time: 409.12 milliseconds (24.6%)  ObjC setup time: 261.59 milliseconds (15.7%)  initializer time: 468.08 milliseconds (28.1%)  slowest intializers :  libSystem.B.dylib : 12.01 milliseconds (0.7%)  MobileRTC : 94.61 milliseconds (5.6%)  BizConfSDK : 70.24 milliseconds (4.2%)  IpCall : 65.15 milliseconds (3.9%)  CMBMobileST : 107.68 milliseconds (6.4%)   total time: 3.3 seconds (100.0%)  total images loaded: 557 (534 from dyld shared cache)  total segments mapped: 81, into 64755 pages  total images loading time: 2.1 seconds (64.3%)  total load time in ObjC: 261.59 milliseconds (7.8%)  total debugger pause time: 1.6 seconds (48.8%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 1,113,280  total rebase fixups time: 122.58 milliseconds (3.6%)  total binding fixups: 121,271  total binding fixups time: 267.59 milliseconds (7.9%)  total weak binding fixups time: 73.89 milliseconds (2.2%)  total redo shared cached bindings time: 54.95 milliseconds (1.6%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 468.08 milliseconds (13.9%)  libSystem.B.dylib : 12.01 milliseconds (0.3%)  libBacktraceRecording.dylib : 7.75 milliseconds (0.2%)  libMainThreadChecker.dylib : 29.87 milliseconds (0.8%)  libMTLCapture.dylib : 31.91 milliseconds (0.9%)  AgoraRtcKit : 26.64 milliseconds (0.7%)  AgoraRtmKit : 7.92 milliseconds (0.2%)  MobileRTC : 94.61 milliseconds (2.8%)  BizConfSDK : 70.24 milliseconds (2.0%)  IpCall : 65.15 milliseconds (1.9%)  JMSDK : 13.66 milliseconds (0.4%)  WebRTC : 3.97 milliseconds (0.1%)  CMBMobileST : 107.68 milliseconds (3.2%) total symbol trie searches: 503818 total symbol table binary searches: 0 total images defining weak symbols: 57 total images using weak symbols: 141 Total pre-main time: 1.7 seconds (100.0%)  dylib loading time: 582.38 milliseconds (32.8%)  rebase/binding time: 434.03 milliseconds (24.4%)  ObjC setup time: 276.75 milliseconds (15.6%)  initializer time: 479.27 milliseconds (27.0%)  slowest intializers :  libSystem.B.dylib : 6.68 milliseconds (0.3%)  MobileRTC : 91.04 milliseconds (5.1%)  BizConfSDK : 54.77 milliseconds (3.0%)  IpCall : 60.78 milliseconds (3.4%)  CMBMobileST : 145.16 milliseconds (8.1%)   total time: 3.3 seconds (100.0%)  total images loaded: 557 (534 from dyld shared cache)  total segments mapped: 81, into 64755 pages  total images loading time: 2.0 seconds (63.1%)  total load time in ObjC: 276.75 milliseconds (8.3%)  total debugger pause time: 1.5 seconds (45.6%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 1,113,280  total rebase fixups time: 105.52 milliseconds (3.1%)  total binding fixups: 121,271  total binding fixups time: 282.01 milliseconds (8.4%)  total weak binding fixups time: 78.67 milliseconds (2.3%)  total redo shared cached bindings time: 32.17 milliseconds (0.9%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 479.27 milliseconds (14.4%)  libSystem.B.dylib : 6.68 milliseconds (0.2%)  libBacktraceRecording.dylib : 7.56 milliseconds (0.2%)  libMainThreadChecker.dylib : 30.00 milliseconds (0.9%)  libMTLCapture.dylib : 23.62 milliseconds (0.7%)  AgoraCore : 3.49 milliseconds (0.1%)  AgoraRtcKit : 29.97 milliseconds (0.9%)  AgoraRtmKit : 6.86 milliseconds (0.2%)  MobileRTC : 91.04 milliseconds (2.7%)  BizConfSDK : 54.77 milliseconds (1.6%)  IpCall : 60.78 milliseconds (1.8%)  JMSDK : 20.45 milliseconds (0.6%)  WebRTC : 5.51 milliseconds (0.1%)  CMBMobileST : 145.16 milliseconds (4.3%) total symbol trie searches: 503818 total symbol table binary searches: 0 total images defining weak symbols: 57 total images using weak symbols: 141 Total pre-main time: 1.5 seconds (100.0%)  dylib loading time: 517.37 milliseconds (33.4%)  rebase/binding time: 414.25 milliseconds (26.7%)  ObjC setup time: 185.96 milliseconds (12.0%)  initializer time: 428.16 milliseconds (27.6%)  slowest intializers :  libSystem.B.dylib : 8.82 milliseconds (0.5%)  libMTLCapture.dylib : 37.44 milliseconds (2.4%)  MobileRTC : 69.42 milliseconds (4.4%)  BizConfSDK : 58.93 milliseconds (3.8%)  IpCall : 54.33 milliseconds (3.5%)  CMBMobileST : 128.59 milliseconds (8.3%)   total time: 3.1 seconds (100.0%)  total images loaded: 557 (534 from dyld shared cache)  total segments mapped: 81, into 64755 pages  total images loading time: 2.0 seconds (65.9%)  total load time in ObjC: 185.96 milliseconds (5.8%)  total debugger pause time: 1.5 seconds (49.6%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 1,113,280  total rebase fixups time: 97.50 milliseconds (3.0%)  total binding fixups: 121,271  total binding fixups time: 303.48 milliseconds (9.5%)  total weak binding fixups time: 63.10 milliseconds (1.9%)  total redo shared cached bindings time: 49.83 milliseconds (1.5%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 428.16 milliseconds (13.5%)  libSystem.B.dylib : 8.82 milliseconds (0.2%)  libBacktraceRecording.dylib : 7.39 milliseconds (0.2%)  libMainThreadChecker.dylib : 29.58 milliseconds (0.9%)  libMTLCapture.dylib : 37.44 milliseconds (1.1%)  AgoraRtcKit : 15.06 milliseconds (0.4%)  AgoraRtmKit : 5.38 milliseconds (0.1%)  MobileRTC : 69.42 milliseconds (2.1%)  BizConfSDK : 58.93 milliseconds (1.8%)  IpCall : 54.33 milliseconds (1.7%)  JMSDK : 11.94 milliseconds (0.3%)  WebRTC : 3.76 milliseconds (0.1%)  CMBMobileST : 128.59 milliseconds (4.0%) total symbol trie searches: 503818 total symbol table binary searches: 0 total images defining weak symbols: 57 total images using weak symbols: 141 Total pre-main time: 1.6 seconds (100.0%)  dylib loading time: 508.85 milliseconds (31.0%)  rebase/binding time: 483.35 milliseconds (29.4%)  ObjC setup time: 249.26 milliseconds (15.2%)  initializer time: 397.63 milliseconds (24.2%)  slowest intializers :  libSystem.B.dylib : 9.90 milliseconds (0.6%)  MobileRTC : 58.59 milliseconds (3.5%)  BizConfSDK : 52.78 milliseconds (3.2%)  IpCall : 57.41 milliseconds (3.5%)  CMBMobileST : 126.32 milliseconds (7.7%)   total time: 3.2 seconds (100.0%)  total images loaded: 557 (534 from dyld shared cache)  total segments mapped: 81, into 64755 pages  total images loading time: 2.0 seconds (63.9%)  total load time in ObjC: 249.26 milliseconds (7.7%)  total debugger pause time: 1.5 seconds (48.2%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 1,113,280  total rebase fixups time: 120.97 milliseconds (3.7%)  total binding fixups: 121,271  total binding fixups time: 322.41 milliseconds (9.9%)  total weak binding fixups time: 74.53 milliseconds (2.3%)  total redo shared cached bindings time: 34.57 milliseconds (1.0%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 397.63 milliseconds (12.2%)  libSystem.B.dylib : 9.90 milliseconds (0.3%)  libBacktraceRecording.dylib : 7.75 milliseconds (0.2%)  libMainThreadChecker.dylib : 29.54 milliseconds (0.9%)  libMTLCapture.dylib : 23.28 milliseconds (0.7%)  AgoraRtcKit : 26.13 milliseconds (0.8%)  AgoraRtmKit : 6.21 milliseconds (0.1%)  MobileRTC : 58.59 milliseconds (1.8%)  BizConfSDK : 52.78 milliseconds (1.6%)  IpCall : 57.41 milliseconds (1.7%)  JMSDK : 11.99 milliseconds (0.3%)  WebRTC : 3.79 milliseconds (0.1%)  CMBMobileST : 126.32 milliseconds (3.9%) total symbol trie searches: 503818 total symbol table binary searches: 0 total images defining weak symbols: 57 total images using weak symbols: 141 测试手机为iPhone XS Max iOS版本为13.7，Xcode版本为 13.2.1，macOS版本为12.0.1。测试手机关机重启，Xcode关闭（Command&#43;Q）重启不清理缓存，测试4次，每次时间如下所示：
Total pre-main time: 1.5 seconds (100.0%)  dylib loading time: 494.80 milliseconds (31.0%)  rebase/binding time: 489.70 milliseconds (30.7%)  ObjC setup time: 222.29 milliseconds (13.9%)  initializer time: 387.28 milliseconds (24.2%)  slowest intializers :  libSystem.B.dylib : 6.90 milliseconds (0.4%)  MobileRTC : 67.72 milliseconds (4.2%)  BizConfSDK : 52.53 milliseconds (3.2%)  IpCall : 52.61 milliseconds (3.3%)  CMBMobileST : 103.05 milliseconds (6.4%)   total time: 3.2 seconds (100.0%)  total images loaded: 557 (534 from dyld shared cache)  total segments mapped: 81, into 64755 pages  total images loading time: 2.0 seconds (64.8%)  total load time in ObjC: 222.29 milliseconds (6.9%)  total debugger pause time: 1.5 seconds (49.4%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 1,113,280  total rebase fixups time: 84.47 milliseconds (2.6%)  total binding fixups: 121,271  total binding fixups time: 347.98 milliseconds (10.8%)  total weak binding fixups time: 87.95 milliseconds (2.7%)  total redo shared cached bindings time: 30.70 milliseconds (0.9%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 387.28 milliseconds (12.0%)  libSystem.B.dylib : 6.90 milliseconds (0.2%)  libBacktraceRecording.dylib : 9.05 milliseconds (0.2%)  libMainThreadChecker.dylib : 30.31 milliseconds (0.9%)  libMTLCapture.dylib : 27.39 milliseconds (0.8%)  AgoraRtcKit : 18.18 milliseconds (0.5%)  AgoraRtmKit : 5.78 milliseconds (0.1%)  MobileRTC : 67.72 milliseconds (2.1%)  BizConfSDK : 52.53 milliseconds (1.6%)  IpCall : 52.61 milliseconds (1.6%)  JMSDK : 12.21 milliseconds (0.3%)  WebRTC : 4.00 milliseconds (0.1%)  CMBMobileST : 103.05 milliseconds (3.2%) total symbol trie searches: 503818 total symbol table binary searches: 0 total images defining weak symbols: 57 total images using weak symbols: 141 Total pre-main time: 1.3 seconds (100.0%)  dylib loading time: 499.62 milliseconds (36.2%)  rebase/binding time: 330.78 milliseconds (24.0%)  ObjC setup time: 154.90 milliseconds (11.2%)  initializer time: 391.26 milliseconds (28.4%)  slowest intializers :  libSystem.B.dylib : 6.89 milliseconds (0.5%)  libMainThreadChecker.dylib : 29.28 milliseconds (2.1%)  MobileRTC : 70.59 milliseconds (5.1%)  BizConfSDK : 61.52 milliseconds (4.4%)  IpCall : 58.95 milliseconds (4.2%)  CMBMobileST : 101.66 milliseconds (7.3%)   total time: 2.9 seconds (100.0%)  total images loaded: 557 (534 from dyld shared cache)  total segments mapped: 81, into 64755 pages  total images loading time: 2.0 seconds (69.7%)  total load time in ObjC: 154.90 milliseconds (5.2%)  total debugger pause time: 1.5 seconds (52.8%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 1,113,280  total rebase fixups time: 79.70 milliseconds (2.6%)  total binding fixups: 121,271  total binding fixups time: 204.05 milliseconds (6.8%)  total weak binding fixups time: 67.79 milliseconds (2.2%)  total redo shared cached bindings time: 20.77 milliseconds (0.7%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 391.26 milliseconds (13.2%)  libSystem.B.dylib : 6.89 milliseconds (0.2%)  libBacktraceRecording.dylib : 6.99 milliseconds (0.2%)  libMainThreadChecker.dylib : 29.28 milliseconds (0.9%)  libMTLCapture.dylib : 21.65 milliseconds (0.7%)  AgoraRtcKit : 15.12 milliseconds (0.5%)  AgoraRtmKit : 4.96 milliseconds (0.1%)  MobileRTC : 70.59 milliseconds (2.3%)  BizConfSDK : 61.52 milliseconds (2.0%)  IpCall : 58.95 milliseconds (1.9%)  JMSDK : 12.63 milliseconds (0.4%)  WebRTC : 3.91 milliseconds (0.1%)  CMBMobileST : 101.66 milliseconds (3.4%) total symbol trie searches: 503818 total symbol table binary searches: 0 total images defining weak symbols: 57 total images using weak symbols: 141 Total pre-main time: 1.5 seconds (100.0%)  dylib loading time: 650.76 milliseconds (41.5%)  rebase/binding time: 322.68 milliseconds (20.6%)  ObjC setup time: 161.69 milliseconds (10.3%)  initializer time: 429.87 milliseconds (27.4%)  slowest intializers :  libSystem.B.dylib : 7.05 milliseconds (0.4%)  MobileRTC : 73.32 milliseconds (4.6%)  BizConfSDK : 55.98 milliseconds (3.5%)  IpCall : 65.51 milliseconds (4.1%)  CMBMobileST : 126.28 milliseconds (8.0%)   total time: 3.2 seconds (100.0%)  total images loaded: 557 (534 from dyld shared cache)  total segments mapped: 81, into 64755 pages  total images loading time: 2.3 seconds (71.2%)  total load time in ObjC: 161.69 milliseconds (4.9%)  total debugger pause time: 1.6 seconds (51.2%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 1,113,280  total rebase fixups time: 121.16 milliseconds (3.7%)  total binding fixups: 121,271  total binding fixups time: 152.63 milliseconds (4.6%)  total weak binding fixups time: 76.33 milliseconds (2.3%)  total redo shared cached bindings time: 27.45 milliseconds (0.8%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 429.87 milliseconds (13.1%)  libSystem.B.dylib : 7.05 milliseconds (0.2%)  libBacktraceRecording.dylib : 7.45 milliseconds (0.2%)  libMainThreadChecker.dylib : 28.79 milliseconds (0.8%)  libMTLCapture.dylib : 29.62 milliseconds (0.9%)  AgoraRtcKit : 17.95 milliseconds (0.5%)  AgoraRtmKit : 6.66 milliseconds (0.2%)  MobileRTC : 73.32 milliseconds (2.2%)  BizConfSDK : 55.98 milliseconds (1.7%)  IpCall : 65.51 milliseconds (2.0%)  JMSDK : 12.61 milliseconds (0.3%)  WebRTC : 3.94 milliseconds (0.1%)  CMBMobileST : 126.28 milliseconds (3.8%) total symbol trie searches: 503818 total symbol table binary searches: 0 total images defining weak symbols: 57 total images using weak symbols: 141 Total pre-main time: 1.6 seconds (100.0%)  dylib loading time: 598.76 milliseconds (36.0%)  rebase/binding time: 375.43 milliseconds (22.6%)  ObjC setup time: 212.66 milliseconds (12.8%)  initializer time: 472.13 milliseconds (28.4%)  slowest intializers :  libSystem.B.dylib : 6.64 milliseconds (0.4%)  MobileRTC : 84.73 milliseconds (5.1%)  BizConfSDK : 83.80 milliseconds (5.0%)  IpCall : 77.78 milliseconds (4.6%)  CMBMobileST : 135.47 milliseconds (8.1%)   total time: 3.2 seconds (100.0%)  total images loaded: 555 (533 from dyld shared cache)  total segments mapped: 77, into 64478 pages  total images loading time: 2.1 seconds (66.0%)  total load time in ObjC: 212.66 milliseconds (6.6%)  total debugger pause time: 1.5 seconds (47.3%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 1,113,280  total rebase fixups time: 124.96 milliseconds (3.8%)  total binding fixups: 102,477  total binding fixups time: 199.10 milliseconds (6.2%)  total weak binding fixups time: 80.84 milliseconds (2.5%)  total redo shared cached bindings time: 29.47 milliseconds (0.9%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 472.13 milliseconds (14.7%)  libSystem.B.dylib : 6.64 milliseconds (0.2%)  libBacktraceRecording.dylib : 7.39 milliseconds (0.2%)  libMainThreadChecker.dylib : 28.50 milliseconds (0.8%)  AgoraRtcKit : 26.91 milliseconds (0.8%)  AgoraRtmKit : 6.15 milliseconds (0.1%)  MobileRTC : 84.73 milliseconds (2.6%)  BizConfSDK : 83.80 milliseconds (2.6%)  IpCall : 77.78 milliseconds (2.4%)  JMSDK : 16.33 milliseconds (0.5%)  WebRTC : 4.49 milliseconds (0.1%)  CMBMobileST : 135.47 milliseconds (4.2%) total symbol trie searches: 484852 total symbol table binary searches: 0 total images defining weak symbols: 56 total images using weak symbols: 139 二进制重排后 Total pre-main time: 1.3 seconds (100.0%)  dylib loading time: 533.67 milliseconds (39.5%)  rebase/binding time: 244.70 milliseconds (18.1%)  ObjC setup time: 118.40 milliseconds (8.7%)  initializer time: 453.29 milliseconds (33.5%)  slowest intializers :  libSystem.B.dylib : 6.59 milliseconds (0.4%)  libMainThreadChecker.dylib : 27.66 milliseconds (2.0%)  MobileRTC : 62.09 milliseconds (4.5%)  BizConfSDK : 60.51 milliseconds (4.4%)  IpCall : 60.66 milliseconds (4.4%)  CMBMobileST : 174.32 milliseconds (12.9%)   total time: 2.9 seconds (100.0%)  total images loaded: 557 (534 from dyld shared cache)  total segments mapped: 81, into 64755 pages  total images loading time: 2.1 seconds (71.7%)  total load time in ObjC: 118.40 milliseconds (3.9%)  total debugger pause time: 1.6 seconds (53.9%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 1,113,803  total rebase fixups time: 84.88 milliseconds (2.8%)  total binding fixups: 121,283  total binding fixups time: 110.99 milliseconds (3.7%)  total weak binding fixups time: 74.69 milliseconds (2.5%)  total redo shared cached bindings time: 25.87 milliseconds (0.8%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 453.29 milliseconds (15.1%)  libSystem.B.dylib : 6.59 milliseconds (0.2%)  libBacktraceRecording.dylib : 6.28 milliseconds (0.2%)  libMainThreadChecker.dylib : 27.66 milliseconds (0.9%)  libMTLCapture.dylib : 23.48 milliseconds (0.7%)  AgoraRtcKit : 16.04 milliseconds (0.5%)  AgoraRtmKit : 5.19 milliseconds (0.1%)  MobileRTC : 62.09 milliseconds (2.0%)  BizConfSDK : 60.51 milliseconds (2.0%)  IpCall : 60.66 milliseconds (2.0%)  JMSDK : 12.54 milliseconds (0.4%)  WebRTC : 3.88 milliseconds (0.1%)  CMBMobileST : 174.32 milliseconds (5.8%) total symbol trie searches: 503902 total symbol table binary searches: 0 total images defining weak symbols: 57 total images using weak symbols: 141 Total pre-main time: 1.2 seconds (100.0%)  dylib loading time: 547.90 milliseconds (43.0%)  rebase/binding time: 221.05 milliseconds (17.3%)  ObjC setup time: 73.44 milliseconds (5.7%)  initializer time: 430.19 milliseconds (33.8%)  slowest intializers :  libSystem.B.dylib : 5.88 milliseconds (0.4%)  libMainThreadChecker.dylib : 27.48 milliseconds (2.1%)  libMTLCapture.dylib : 27.02 milliseconds (2.1%)  MobileRTC : 56.87 milliseconds (4.4%)  BizConfSDK : 65.07 milliseconds (5.1%)  IpCall : 59.02 milliseconds (4.6%)  CMBMobileST : 154.11 milliseconds (12.1%)   total time: 2.7 seconds (100.0%)  total images loaded: 557 (534 from dyld shared cache)  total segments mapped: 81, into 64755 pages  total images loading time: 2.0 seconds (72.9%)  total load time in ObjC: 73.44 milliseconds (2.6%)  total debugger pause time: 1.4 seconds (53.1%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 1,113,803  total rebase fixups time: 81.83 milliseconds (2.9%)  total binding fixups: 121,283  total binding fixups time: 94.73 milliseconds (3.4%)  total weak binding fixups time: 64.70 milliseconds (2.3%)  total redo shared cached bindings time: 20.22 milliseconds (0.7%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 430.19 milliseconds (15.6%)  libSystem.B.dylib : 5.88 milliseconds (0.2%)  libBacktraceRecording.dylib : 5.67 milliseconds (0.2%)  libMainThreadChecker.dylib : 27.48 milliseconds (0.9%)  libMTLCapture.dylib : 27.02 milliseconds (0.9%)  AgoraRtcKit : 14.61 milliseconds (0.5%)  AgoraRtmKit : 6.19 milliseconds (0.2%)  MobileRTC : 56.87 milliseconds (2.0%)  BizConfSDK : 65.07 milliseconds (2.3%)  IpCall : 59.02 milliseconds (2.1%)  JMSDK : 14.98 milliseconds (0.5%)  WebRTC : 5.03 milliseconds (0.1%)  CMBMobileST : 154.11 milliseconds (5.5%) total symbol trie searches: 503902 total symbol table binary searches: 0 total images defining weak symbols: 57 total images using weak symbols: 141 Total pre-main time: 1.4 seconds (100.0%)  dylib loading time: 540.41 milliseconds (36.8%)  rebase/binding time: 318.35 milliseconds (21.7%)  ObjC setup time: 152.68 milliseconds (10.4%)  initializer time: 455.29 milliseconds (31.0%)  slowest intializers :  libSystem.B.dylib : 6.78 milliseconds (0.4%)  MobileRTC : 61.52 milliseconds (4.1%)  BizConfSDK : 62.35 milliseconds (4.2%)  IpCall : 57.71 milliseconds (3.9%)  CMBMobileST : 174.93 milliseconds (11.9%)   total time: 3.0 seconds (100.0%)  total images loaded: 557 (534 from dyld shared cache)  total segments mapped: 81, into 64755 pages  total images loading time: 2.0 seconds (68.4%)  total load time in ObjC: 152.68 milliseconds (5.0%)  total debugger pause time: 1.5 seconds (50.5%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 1,113,803  total rebase fixups time: 120.37 milliseconds (3.9%)  total binding fixups: 121,283  total binding fixups time: 151.01 milliseconds (4.9%)  total weak binding fixups time: 75.20 milliseconds (2.4%)  total redo shared cached bindings time: 28.23 milliseconds (0.9%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 455.29 milliseconds (15.0%)  libSystem.B.dylib : 6.78 milliseconds (0.2%)  libBacktraceRecording.dylib : 6.91 milliseconds (0.2%)  libMainThreadChecker.dylib : 28.52 milliseconds (0.9%)  libMTLCapture.dylib : 23.62 milliseconds (0.7%)  AgoraRtcKit : 15.54 milliseconds (0.5%)  AgoraRtmKit : 5.05 milliseconds (0.1%)  MobileRTC : 61.52 milliseconds (2.0%)  BizConfSDK : 62.35 milliseconds (2.0%)  IpCall : 57.71 milliseconds (1.9%)  JMSDK : 13.86 milliseconds (0.4%)  WebRTC : 4.13 milliseconds (0.1%)  CMBMobileST : 174.93 milliseconds (5.7%) total symbol trie searches: 503902 total symbol table binary searches: 0 total images defining weak symbols: 57 total images using weak symbols: 141 Total pre-main time: 1.4 seconds (100.0%)  dylib loading time: 554.53 milliseconds (37.5%)  rebase/binding time: 291.86 milliseconds (19.7%)  ObjC setup time: 172.99 milliseconds (11.7%)  initializer time: 458.99 milliseconds (31.0%)  slowest intializers :  libSystem.B.dylib : 6.95 milliseconds (0.4%)  MobileRTC : 62.21 milliseconds (4.2%)  BizConfSDK : 60.06 milliseconds (4.0%)  IpCall : 60.50 milliseconds (4.0%)  CMBMobileST : 171.19 milliseconds (11.5%)   total time: 3.1 seconds (100.0%)  total images loaded: 557 (534 from dyld shared cache)  total segments mapped: 81, into 64755 pages  total images loading time: 2.1 seconds (69.8%)  total load time in ObjC: 172.99 milliseconds (5.5%)  total debugger pause time: 1.6 seconds (52.1%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 1,113,803  total rebase fixups time: 85.30 milliseconds (2.7%)  total binding fixups: 121,283  total binding fixups time: 153.31 milliseconds (4.8%)  total weak binding fixups time: 74.32 milliseconds (2.3%)  total redo shared cached bindings time: 21.08 milliseconds (0.6%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 458.99 milliseconds (14.6%)  libSystem.B.dylib : 6.95 milliseconds (0.2%)  libBacktraceRecording.dylib : 7.37 milliseconds (0.2%)  libMainThreadChecker.dylib : 28.78 milliseconds (0.9%)  libMTLCapture.dylib : 27.68 milliseconds (0.8%)  AgoraRtcKit : 17.13 milliseconds (0.5%)  AgoraRtmKit : 5.18 milliseconds (0.1%)  MobileRTC : 62.21 milliseconds (1.9%)  BizConfSDK : 60.06 milliseconds (1.9%)  IpCall : 60.50 milliseconds (1.9%)  JMSDK : 12.48 milliseconds (0.3%)  WebRTC : 3.90 milliseconds (0.1%)  CMBMobileST : 171.19 milliseconds (5.4%) total symbol trie searches: 503902 total symbol table binary searches: 0 total images defining weak symbols: 57 total images using weak symbols: 141 </content>
    </entry>
    
     <entry>
        <title></title>
        <url>https://iihui.github.io/post/ios-time2/</url>
        <categories>
          
        </categories>
        <tags>
          
        </tags>
        <content type="html"> iPhone XR iOS 12.4.1 生产5.13.5 Total pre-main time: 988.59 milliseconds (100.0%)  dylib loading time: 398.75 milliseconds (40.3%)  rebase/binding time: 193.73 milliseconds (19.5%)  ObjC setup time: 90.53 milliseconds (9.1%)  initializer time: 305.29 milliseconds (30.8%)  slowest intializers :  libSystem.B.dylib : 7.61 milliseconds (0.7%)  libMainThreadChecker.dylib : 22.48 milliseconds (2.2%)  libMTLInterpose.dylib : 46.70 milliseconds (4.7%)  MobileRTC : 63.41 milliseconds (6.4%)  CMBMobile : 105.77 milliseconds (10.6%)   total time: 2.7 seconds (100.0%)  total images loaded: 483 (457 from dyld shared cache)  total segments mapped: 87, into 65168 pages with 2784 pages pre-fetched  total images loading time: 2.0 seconds (75.5%)  total load time in ObjC: 90.53 milliseconds (3.3%)  total debugger pause time: 1.6 seconds (60.8%)  total dtrace DOF registration time: 0.27 milliseconds (0.0%)  total rebase fixups: 1,098,748  total rebase fixups time: 116.72 milliseconds (4.3%)  total binding fixups: 123,358  total binding fixups time: 88.70 milliseconds (3.2%)  total weak binding fixups time: 60.65 milliseconds (2.2%)  total redo shared cached bindings time: 72.34 milliseconds (2.6%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 305.29 milliseconds (11.2%)  libSystem.B.dylib : 7.61 milliseconds (0.2%)  libBacktraceRecording.dylib : 8.13 milliseconds (0.3%)  libMainThreadChecker.dylib : 22.48 milliseconds (0.8%)  libMTLInterpose.dylib : 46.70 milliseconds (1.7%)  AgoraRtcKit : 17.19 milliseconds (0.6%)  AgoraRtmKit : 14.06 milliseconds (0.5%)  MobileRTC : 63.41 milliseconds (2.3%)  BizConfSDK : 2.73 milliseconds (0.1%)  IpCall : 5.94 milliseconds (0.2%)  JMSDK : 16.04 milliseconds (0.5%)  WebRTC : 5.83 milliseconds (0.2%)  CMBMobile : 105.77 milliseconds (3.8%) total symbol trie searches: 382888 total symbol table binary searches: 0 total images defining weak symbols: 46 total images using weak symbols: 120 Total pre-main time: 1.0 seconds (100.0%)  dylib loading time: 400.48 milliseconds (38.8%)  rebase/binding time: 209.42 milliseconds (20.2%)  ObjC setup time: 95.44 milliseconds (9.2%)  initializer time: 326.30 milliseconds (31.6%)  slowest intializers :  libSystem.B.dylib : 7.46 milliseconds (0.7%)  libMainThreadChecker.dylib : 21.81 milliseconds (2.1%)  libMTLInterpose.dylib : 68.67 milliseconds (6.6%)  AgoraRtcKit : 24.55 milliseconds (2.3%)  MobileRTC : 64.76 milliseconds (6.2%)  CMBMobile : 104.31 milliseconds (10.1%)   total time: 2.7 seconds (100.0%)  total images loaded: 483 (457 from dyld shared cache)  total segments mapped: 87, into 65168 pages with 2784 pages pre-fetched  total images loading time: 1.9 seconds (73.6%)  total load time in ObjC: 95.44 milliseconds (3.5%)  total debugger pause time: 1.5 seconds (58.8%)  total dtrace DOF registration time: 0.29 milliseconds (0.0%)  total rebase fixups: 1,098,748  total rebase fixups time: 130.44 milliseconds (4.8%)  total binding fixups: 123,358  total binding fixups time: 99.69 milliseconds (3.6%)  total weak binding fixups time: 62.08 milliseconds (2.2%)  total redo shared cached bindings time: 82.80 milliseconds (3.0%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 326.30 milliseconds (12.0%)  libSystem.B.dylib : 7.46 milliseconds (0.2%)  libBacktraceRecording.dylib : 8.28 milliseconds (0.3%)  libMainThreadChecker.dylib : 21.81 milliseconds (0.8%)  libMTLInterpose.dylib : 68.67 milliseconds (2.5%)  AgoraRtcKit : 24.55 milliseconds (0.9%)  AgoraRtmKit : 6.72 milliseconds (0.2%)  MobileRTC : 64.76 milliseconds (2.3%)  BizConfSDK : 2.84 milliseconds (0.1%)  IpCall : 5.97 milliseconds (0.2%)  JMSDK : 16.03 milliseconds (0.5%)  WebRTC : 5.85 milliseconds (0.2%)  CMBMobile : 104.31 milliseconds (3.8%) total symbol trie searches: 382888 total symbol table binary searches: 0 total images defining weak symbols: 46 total images using weak symbols: 120 Total pre-main time: 1.0 seconds (100.0%)  dylib loading time: 407.35 milliseconds (39.6%)  rebase/binding time: 211.82 milliseconds (20.6%)  ObjC setup time: 86.36 milliseconds (8.4%)  initializer time: 320.28 milliseconds (31.2%)  slowest intializers :  libSystem.B.dylib : 6.67 milliseconds (0.6%)  libMainThreadChecker.dylib : 21.57 milliseconds (2.1%)  libMTLInterpose.dylib : 67.25 milliseconds (6.5%)  AgoraRtcKit : 24.17 milliseconds (2.3%)  MobileRTC : 63.08 milliseconds (6.1%)  CMBMobile : 105.10 milliseconds (10.2%)   total time: 2.7 seconds (100.0%)  total images loaded: 483 (457 from dyld shared cache)  total segments mapped: 87, into 65168 pages with 2784 pages pre-fetched  total images loading time: 2.0 seconds (74.5%)  total load time in ObjC: 86.36 milliseconds (3.1%)  total debugger pause time: 1.6 seconds (59.6%)  total dtrace DOF registration time: 0.29 milliseconds (0.0%)  total rebase fixups: 1,098,748  total rebase fixups time: 131.29 milliseconds (4.8%)  total binding fixups: 123,358  total binding fixups time: 95.50 milliseconds (3.5%)  total weak binding fixups time: 58.38 milliseconds (2.1%)  total redo shared cached bindings time: 73.36 milliseconds (2.6%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 320.28 milliseconds (11.7%)  libSystem.B.dylib : 6.67 milliseconds (0.2%)  libBacktraceRecording.dylib : 7.99 milliseconds (0.2%)  libMainThreadChecker.dylib : 21.57 milliseconds (0.7%)  libMTLInterpose.dylib : 67.25 milliseconds (2.4%)  AgoraRtcKit : 24.17 milliseconds (0.8%)  AgoraRtmKit : 6.31 milliseconds (0.2%)  MobileRTC : 63.08 milliseconds (2.3%)  BizConfSDK : 2.82 milliseconds (0.1%)  IpCall : 5.93 milliseconds (0.2%)  JMSDK : 15.81 milliseconds (0.5%)  WebRTC : 5.85 milliseconds (0.2%)  CMBMobile : 105.10 milliseconds (3.8%) total symbol trie searches: 382888 total symbol table binary searches: 0 total images defining weak symbols: 46 total images using weak symbols: 120 Total pre-main time: 980.65 milliseconds (100.0%)  dylib loading time: 402.82 milliseconds (41.0%)  rebase/binding time: 176.97 milliseconds (18.0%)  ObjC setup time: 69.85 milliseconds (7.1%)  initializer time: 330.73 milliseconds (33.7%)  slowest intializers :  libSystem.B.dylib : 6.99 milliseconds (0.7%)  libMainThreadChecker.dylib : 21.53 milliseconds (2.1%)  libMTLInterpose.dylib : 78.58 milliseconds (8.0%)  AgoraRtcKit : 24.38 milliseconds (2.4%)  MobileRTC : 64.43 milliseconds (6.5%)  CMBMobile : 106.34 milliseconds (10.8%)   total time: 2.6 seconds (100.0%)  total images loaded: 483 (457 from dyld shared cache)  total segments mapped: 87, into 65168 pages with 2784 pages pre-fetched  total images loading time: 2.0 seconds (75.7%)  total load time in ObjC: 69.85 milliseconds (2.6%)  total debugger pause time: 1.6 seconds (60.5%)  total dtrace DOF registration time: 0.26 milliseconds (0.0%)  total rebase fixups: 1,098,748  total rebase fixups time: 103.25 milliseconds (3.9%)  total binding fixups: 123,358  total binding fixups time: 84.53 milliseconds (3.1%)  total weak binding fixups time: 53.99 milliseconds (2.0%)  total redo shared cached bindings time: 64.81 milliseconds (2.4%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 330.73 milliseconds (12.4%)  libSystem.B.dylib : 6.99 milliseconds (0.2%)  libBacktraceRecording.dylib : 3.06 milliseconds (0.1%)  libMainThreadChecker.dylib : 21.53 milliseconds (0.8%)  libMTLInterpose.dylib : 78.58 milliseconds (2.9%)  AgoraRtcKit : 24.38 milliseconds (0.9%)  AgoraRtmKit : 6.46 milliseconds (0.2%)  MobileRTC : 64.43 milliseconds (2.4%)  BizConfSDK : 2.71 milliseconds (0.1%)  IpCall : 5.66 milliseconds (0.2%)  JMSDK : 15.40 milliseconds (0.5%)  WebRTC : 5.58 milliseconds (0.2%)  CMBMobile : 106.34 milliseconds (4.0%) total symbol trie searches: 382888 total symbol table binary searches: 0 total images defining weak symbols: 46 total images using weak symbols: 120 平均时间为$\frac{2.7 &#43; 2.7 &#43; 2.7 &#43; 2.6}{4}=2.675$
生产5.15.0 Total pre-main time: 998.66 milliseconds (100.0%)  dylib loading time: 377.08 milliseconds (37.7%)  rebase/binding time: 190.83 milliseconds (19.1%)  ObjC setup time: 89.32 milliseconds (8.9%)  initializer time: 341.15 milliseconds (34.1%)  slowest intializers :  libSystem.B.dylib : 7.43 milliseconds (0.7%)  libMainThreadChecker.dylib : 21.45 milliseconds (2.1%)  libMTLInterpose.dylib : 87.04 milliseconds (8.7%)  MobileRTC : 64.61 milliseconds (6.4%)  CMBMobile : 101.19 milliseconds (10.1%)   total time: 2.4 seconds (100.0%)  total images loaded: 482 (457 from dyld shared cache)  total segments mapped: 83, into 65140 pages with 2776 pages pre-fetched  total images loading time: 1.7 seconds (72.3%)  total load time in ObjC: 89.32 milliseconds (3.6%)  total debugger pause time: 1.3 seconds (56.7%)  total dtrace DOF registration time: 0.26 milliseconds (0.0%)  total rebase fixups: 1,100,134  total rebase fixups time: 109.98 milliseconds (4.5%)  total binding fixups: 123,420  total binding fixups time: 82.80 milliseconds (3.4%)  total weak binding fixups time: 48.23 milliseconds (1.9%)  total redo shared cached bindings time: 50.18 milliseconds (2.0%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 341.15 milliseconds (14.0%)  libSystem.B.dylib : 7.43 milliseconds (0.3%)  libBacktraceRecording.dylib : 8.16 milliseconds (0.3%)  libMainThreadChecker.dylib : 21.45 milliseconds (0.8%)  libMTLInterpose.dylib : 87.04 milliseconds (3.5%)  AgoraRtcKit : 17.86 milliseconds (0.7%)  AgoraRtcCryptoLoader : 7.27 milliseconds (0.2%)  AgoraRtmKit : 6.70 milliseconds (0.2%)  MobileRTC : 64.61 milliseconds (2.6%)  BizConfSDK : 2.83 milliseconds (0.1%)  IpCall : 5.53 milliseconds (0.2%)  JMSDK : 15.62 milliseconds (0.6%)  WebRTC : 6.06 milliseconds (0.2%)  CMBMobile : 101.19 milliseconds (4.1%) total symbol trie searches: 382644 total symbol table binary searches: 0 total images defining weak symbols: 46 total images using weak symbols: 120 Total pre-main time: 979.67 milliseconds (100.0%)  dylib loading time: 389.13 milliseconds (39.7%)  rebase/binding time: 183.88 milliseconds (18.7%)  ObjC setup time: 94.66 milliseconds (9.6%)  initializer time: 311.69 milliseconds (31.8%)  slowest intializers :  libSystem.B.dylib : 6.61 milliseconds (0.6%)  libMainThreadChecker.dylib : 21.54 milliseconds (2.1%)  libMTLInterpose.dylib : 62.83 milliseconds (6.4%)  AgoraRtcKit : 23.62 milliseconds (2.4%)  MobileRTC : 63.52 milliseconds (6.4%)  CMBMobile : 98.84 milliseconds (10.0%)   total time: 2.1 seconds (100.0%)  total images loaded: 482 (457 from dyld shared cache)  total segments mapped: 83, into 65140 pages with 2776 pages pre-fetched  total images loading time: 1.4 seconds (68.5%)  total load time in ObjC: 94.66 milliseconds (4.4%)  total debugger pause time: 1.0 seconds (50.0%)  total dtrace DOF registration time: 0.28 milliseconds (0.0%)  total rebase fixups: 1,100,134  total rebase fixups time: 103.16 milliseconds (4.8%)  total binding fixups: 123,420  total binding fixups time: 94.30 milliseconds (4.4%)  total weak binding fixups time: 58.66 milliseconds (2.7%)  total redo shared cached bindings time: 72.25 milliseconds (3.4%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 311.69 milliseconds (14.7%)  libSystem.B.dylib : 6.61 milliseconds (0.3%)  libBacktraceRecording.dylib : 8.45 milliseconds (0.4%)  libMainThreadChecker.dylib : 21.54 milliseconds (1.0%)  libMTLInterpose.dylib : 62.83 milliseconds (2.9%)  AgoraRtcKit : 23.62 milliseconds (1.1%)  AgoraRtmKit : 6.42 milliseconds (0.3%)  MobileRTC : 63.52 milliseconds (3.0%)  BizConfSDK : 2.37 milliseconds (0.1%)  IpCall : 5.50 milliseconds (0.2%)  JMSDK : 15.23 milliseconds (0.7%)  WebRTC : 5.49 milliseconds (0.2%)  CMBMobile : 98.84 milliseconds (4.6%) total symbol trie searches: 382644 total symbol table binary searches: 0 total images defining weak symbols: 46 total images using weak symbols: 120 Total pre-main time: 975.95 milliseconds (100.0%)  dylib loading time: 379.60 milliseconds (38.8%)  rebase/binding time: 189.22 milliseconds (19.3%)  ObjC setup time: 90.73 milliseconds (9.2%)  initializer time: 316.10 milliseconds (32.3%)  slowest intializers :  libSystem.B.dylib : 6.75 milliseconds (0.6%)  libMainThreadChecker.dylib : 21.55 milliseconds (2.2%)  libMTLInterpose.dylib : 65.58 milliseconds (6.7%)  AgoraRtcKit : 24.17 milliseconds (2.4%)  MobileRTC : 63.31 milliseconds (6.4%)  CMBMobile : 99.15 milliseconds (10.1%)   total time: 2.0 seconds (100.0%)  total images loaded: 482 (457 from dyld shared cache)  total segments mapped: 83, into 65140 pages with 2776 pages pre-fetched  total images loading time: 1.4 seconds (67.9%)  total load time in ObjC: 90.73 milliseconds (4.3%)  total debugger pause time: 1.0 seconds (49.7%)  total dtrace DOF registration time: 0.29 milliseconds (0.0%)  total rebase fixups: 1,100,134  total rebase fixups time: 124.21 milliseconds (5.9%)  total binding fixups: 123,420  total binding fixups time: 84.90 milliseconds (4.0%)  total weak binding fixups time: 53.41 milliseconds (2.5%)  total redo shared cached bindings time: 73.32 milliseconds (3.5%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 316.10 milliseconds (15.1%)  libSystem.B.dylib : 6.75 milliseconds (0.3%)  libBacktraceRecording.dylib : 8.05 milliseconds (0.3%)  libMainThreadChecker.dylib : 21.55 milliseconds (1.0%)  libMTLInterpose.dylib : 65.58 milliseconds (3.1%)  AgoraRtcKit : 24.17 milliseconds (1.1%)  AgoraRtmKit : 6.76 milliseconds (0.3%)  MobileRTC : 63.31 milliseconds (3.0%)  BizConfSDK : 2.67 milliseconds (0.1%)  IpCall : 5.65 milliseconds (0.2%)  JMSDK : 15.10 milliseconds (0.7%)  WebRTC : 5.84 milliseconds (0.2%)  CMBMobile : 99.15 milliseconds (4.7%) total symbol trie searches: 382644 total symbol table binary searches: 0 total images defining weak symbols: 46 total images using weak symbols: 120 Total pre-main time: 938.42 milliseconds (100.0%)  dylib loading time: 387.22 milliseconds (41.2%)  rebase/binding time: 173.66 milliseconds (18.5%)  ObjC setup time: 66.84 milliseconds (7.1%)  initializer time: 310.41 milliseconds (33.0%)  slowest intializers :  libSystem.B.dylib : 7.08 milliseconds (0.7%)  libMainThreadChecker.dylib : 21.29 milliseconds (2.2%)  libMTLInterpose.dylib : 63.90 milliseconds (6.8%)  AgoraRtcKit : 24.36 milliseconds (2.5%)  MobileRTC : 65.02 milliseconds (6.9%)  CMBMobile : 98.40 milliseconds (10.4%)   total time: 2.4 seconds (100.0%)  total images loaded: 482 (457 from dyld shared cache)  total segments mapped: 83, into 65140 pages with 2776 pages pre-fetched  total images loading time: 1.8 seconds (74.6%)  total load time in ObjC: 66.84 milliseconds (2.7%)  total debugger pause time: 1.4 seconds (58.6%)  total dtrace DOF registration time: 0.27 milliseconds (0.0%)  total rebase fixups: 1,100,134  total rebase fixups time: 95.45 milliseconds (3.9%)  total binding fixups: 123,420  total binding fixups time: 94.01 milliseconds (3.8%)  total weak binding fixups time: 48.90 milliseconds (2.0%)  total redo shared cached bindings time: 64.71 milliseconds (2.6%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 310.41 milliseconds (12.7%)  libSystem.B.dylib : 7.08 milliseconds (0.2%)  libBacktraceRecording.dylib : 3.19 milliseconds (0.1%)  libMainThreadChecker.dylib : 21.29 milliseconds (0.8%)  libMTLInterpose.dylib : 63.90 milliseconds (2.6%)  AgoraRtcKit : 24.36 milliseconds (1.0%)  AgoraRtmKit : 6.64 milliseconds (0.2%)  MobileRTC : 65.02 milliseconds (2.6%)  BizConfSDK : 2.80 milliseconds (0.1%)  IpCall : 5.62 milliseconds (0.2%)  JMSDK : 16.70 milliseconds (0.6%)  WebRTC : 5.38 milliseconds (0.2%)  CMBMobile : 98.40 milliseconds (4.0%) total symbol trie searches: 382644 total symbol table binary searches: 0 total images defining weak symbols: 46 total images using weak symbols: 120 平均时间为$\frac{2.4 &#43; 2.1 &#43; 2.0 &#43; 2.4}{4}=2.225$
对比 减少的平均时间为： $2.675 - 2.225 = 0.45$
iPhone XS Max iOS 13.7 生产5.13.5 Total pre-main time: 1.7 seconds (100.0%)  dylib loading time: 538.86 milliseconds (30.3%)  rebase/binding time: 386.41 milliseconds (21.7%)  ObjC setup time: 299.19 milliseconds (16.8%)  initializer time: 552.60 milliseconds (31.0%)  slowest intializers :  libSystem.B.dylib : 10.53 milliseconds (0.5%)  libMainThreadChecker.dylib : 39.12 milliseconds (2.2%)  MobileRTC : 152.32 milliseconds (8.5%)  BizConfSDK : 63.59 milliseconds (3.5%)  IpCall : 61.52 milliseconds (3.4%)  CMBMobile : 131.41 milliseconds (7.3%)   total time: 3.4 seconds (100.0%)  total images loaded: 558 (534 from dyld shared cache)  total segments mapped: 85, into 64783 pages  total images loading time: 2.1 seconds (63.3%)  total load time in ObjC: 299.19 milliseconds (8.6%)  total debugger pause time: 1.6 seconds (47.6%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 1,098,748  total rebase fixups time: 79.97 milliseconds (2.3%)  total binding fixups: 120,035  total binding fixups time: 254.60 milliseconds (7.3%)  total weak binding fixups time: 76.79 milliseconds (2.2%)  total redo shared cached bindings time: 24.96 milliseconds (0.7%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 552.60 milliseconds (16.0%)  libSystem.B.dylib : 10.53 milliseconds (0.3%)  libBacktraceRecording.dylib : 7.90 milliseconds (0.2%)  libMainThreadChecker.dylib : 39.12 milliseconds (1.1%)  libMTLCapture.dylib : 32.83 milliseconds (0.9%)  AgoraRtcKit : 31.18 milliseconds (0.9%)  AgoraRtmKit : 9.97 milliseconds (0.2%)  MobileRTC : 152.32 milliseconds (4.4%)  BizConfSDK : 63.59 milliseconds (1.8%)  IpCall : 61.52 milliseconds (1.7%)  JMSDK : 12.56 milliseconds (0.3%)  WebRTC : 4.45 milliseconds (0.1%)  CMBMobile : 131.41 milliseconds (3.8%) total symbol trie searches: 503950 total symbol table binary searches: 0 total images defining weak symbols: 57 total images using weak symbols: 141 Total pre-main time: 2.3 seconds (100.0%)  dylib loading time: 747.96 milliseconds (31.2%)  rebase/binding time: 618.27 milliseconds (25.8%)  ObjC setup time: 373.84 milliseconds (15.6%)  initializer time: 656.13 milliseconds (27.3%)  slowest intializers :  libSystem.B.dylib : 8.10 milliseconds (0.3%)  libMTLCapture.dylib : 55.58 milliseconds (2.3%)  MobileRTC : 156.67 milliseconds (6.5%)  BizConfSDK : 60.21 milliseconds (2.5%)  IpCall : 63.94 milliseconds (2.6%)  CMBMobile : 192.94 milliseconds (8.0%)   total time: 4.0 seconds (100.0%)  total images loaded: 558 (534 from dyld shared cache)  total segments mapped: 85, into 64783 pages  total images loading time: 2.3 seconds (58.2%)  total load time in ObjC: 373.84 milliseconds (9.1%)  total debugger pause time: 1.6 seconds (39.9%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 1,098,748  total rebase fixups time: 202.48 milliseconds (4.9%)  total binding fixups: 120,035  total binding fixups time: 384.18 milliseconds (9.3%)  total weak binding fixups time: 89.98 milliseconds (2.2%)  total redo shared cached bindings time: 58.38 milliseconds (1.4%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 656.13 milliseconds (16.0%)  libSystem.B.dylib : 8.10 milliseconds (0.1%)  libBacktraceRecording.dylib : 8.00 milliseconds (0.1%)  libMainThreadChecker.dylib : 40.82 milliseconds (0.9%)  libMTLCapture.dylib : 55.58 milliseconds (1.3%)  AgoraRtcKit : 34.51 milliseconds (0.8%)  AgoraRtmKit : 8.66 milliseconds (0.2%)  MobileRTC : 156.67 milliseconds (3.8%)  BizConfSDK : 60.21 milliseconds (1.4%)  IpCall : 63.94 milliseconds (1.5%)  JMSDK : 29.88 milliseconds (0.7%)  WebRTC : 14.61 milliseconds (0.3%)  CMBMobile : 192.94 milliseconds (4.7%) total symbol trie searches: 503950 total symbol table binary searches: 0 total images defining weak symbols: 57 total images using weak symbols: 141 Total pre-main time: 1.5 seconds (100.0%)  dylib loading time: 608.31 milliseconds (38.7%)  rebase/binding time: 352.50 milliseconds (22.4%)  ObjC setup time: 194.75 milliseconds (12.3%)  initializer time: 415.46 milliseconds (26.4%)  slowest intializers :  libSystem.B.dylib : 10.21 milliseconds (0.6%)  libMainThreadChecker.dylib : 39.52 milliseconds (2.5%)  libMTLCapture.dylib : 37.90 milliseconds (2.4%)  MobileRTC : 66.16 milliseconds (4.2%)  BizConfSDK : 58.92 milliseconds (3.7%)  IpCall : 63.56 milliseconds (4.0%)  CMBMobile : 98.79 milliseconds (6.2%)   total time: 3.3 seconds (100.0%)  total images loaded: 558 (534 from dyld shared cache)  total segments mapped: 85, into 64783 pages  total images loading time: 2.3 seconds (69.4%)  total load time in ObjC: 194.75 milliseconds (5.8%)  total debugger pause time: 1.6 seconds (51.1%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 1,098,748  total rebase fixups time: 81.83 milliseconds (2.4%)  total binding fixups: 120,035  total binding fixups time: 243.88 milliseconds (7.3%)  total weak binding fixups time: 77.43 milliseconds (2.3%)  total redo shared cached bindings time: 50.65 milliseconds (1.5%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 415.46 milliseconds (12.5%)  libSystem.B.dylib : 10.21 milliseconds (0.3%)  libBacktraceRecording.dylib : 7.89 milliseconds (0.2%)  libMainThreadChecker.dylib : 39.52 milliseconds (1.1%)  libMTLCapture.dylib : 37.90 milliseconds (1.1%)  AgoraRtcKit : 15.02 milliseconds (0.4%)  AgoraRtmKit : 5.78 milliseconds (0.1%)  MobileRTC : 66.16 milliseconds (1.9%)  BizConfSDK : 58.92 milliseconds (1.7%)  IpCall : 63.56 milliseconds (1.9%)  JMSDK : 15.42 milliseconds (0.4%)  WebRTC : 5.25 milliseconds (0.1%)  CMBMobile : 98.79 milliseconds (2.9%) total symbol trie searches: 503950 total symbol table binary searches: 0 total images defining weak symbols: 57 total images using weak symbols: 141 Total pre-main time: 1.6 seconds (100.0%)  dylib loading time: 583.22 milliseconds (35.5%)  rebase/binding time: 367.29 milliseconds (22.4%)  ObjC setup time: 241.65 milliseconds (14.7%)  initializer time: 447.02 milliseconds (27.2%)  slowest intializers :  libSystem.B.dylib : 7.51 milliseconds (0.4%)  libMainThreadChecker.dylib : 40.62 milliseconds (2.4%)  MobileRTC : 86.49 milliseconds (5.2%)  BizConfSDK : 63.20 milliseconds (3.8%)  IpCall : 67.52 milliseconds (4.1%)  CMBMobile : 102.96 milliseconds (6.2%)   total time: 3.4 seconds (100.0%)  total images loaded: 557 (534 from dyld shared cache)  total segments mapped: 81, into 64755 pages  total images loading time: 2.3 seconds (68.2%)  total load time in ObjC: 241.65 milliseconds (7.0%)  total debugger pause time: 1.7 seconds (51.2%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 1,100,134  total rebase fixups time: 84.65 milliseconds (2.4%)  total binding fixups: 120,097  total binding fixups time: 242.86 milliseconds (7.0%)  total weak binding fixups time: 80.28 milliseconds (2.3%)  total redo shared cached bindings time: 40.51 milliseconds (1.1%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 447.02 milliseconds (12.9%)  libSystem.B.dylib : 7.51 milliseconds (0.2%)  libBacktraceRecording.dylib : 7.84 milliseconds (0.2%)  libMainThreadChecker.dylib : 40.62 milliseconds (1.1%)  libMTLCapture.dylib : 30.38 milliseconds (0.8%)  AgoraRtcKit : 20.38 milliseconds (0.5%)  AgoraRtmKit : 6.56 milliseconds (0.1%)  MobileRTC : 86.49 milliseconds (2.5%)  BizConfSDK : 63.20 milliseconds (1.8%)  IpCall : 67.52 milliseconds (1.9%)  JMSDK : 15.31 milliseconds (0.4%)  WebRTC : 5.14 milliseconds (0.1%)  CMBMobile : 102.96 milliseconds (2.9%) total symbol trie searches: 503716 total symbol table binary searches: 0 total images defining weak symbols: 57 total images using weak symbols: 141 平均时间为$\frac{3.4 &#43; 4.0 &#43; 3.3 &#43; 3.3}{4}=3.5$
生产 5.15.0 Total pre-main time: 1.7 seconds (100.0%)  dylib loading time: 610.90 milliseconds (35.6%)  rebase/binding time: 421.77 milliseconds (24.6%)  ObjC setup time: 251.74 milliseconds (14.6%)  initializer time: 429.44 milliseconds (25.0%)  slowest intializers :  libSystem.B.dylib : 9.62 milliseconds (0.5%)  libMainThreadChecker.dylib : 39.94 milliseconds (2.3%)  MobileRTC : 72.81 milliseconds (4.2%)  BizConfSDK : 62.33 milliseconds (3.6%)  IpCall : 55.15 milliseconds (3.2%)  CMBMobile : 116.89 milliseconds (6.8%)   total time: 2.8 seconds (100.0%)  total images loaded: 557 (534 from dyld shared cache)  total segments mapped: 81, into 64755 pages  total images loading time: 1.7 seconds (60.8%)  total load time in ObjC: 251.74 milliseconds (8.7%)  total debugger pause time: 1.1 seconds (39.5%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 1,100,134  total rebase fixups time: 133.16 milliseconds (4.6%)  total binding fixups: 120,097  total binding fixups time: 227.59 milliseconds (7.9%)  total weak binding fixups time: 83.02 milliseconds (2.8%)  total redo shared cached bindings time: 22.02 milliseconds (0.7%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 429.44 milliseconds (14.9%)  libSystem.B.dylib : 9.62 milliseconds (0.3%)  libBacktraceRecording.dylib : 7.84 milliseconds (0.2%)  libMainThreadChecker.dylib : 39.94 milliseconds (1.3%)  libMTLCapture.dylib : 26.46 milliseconds (0.9%)  AgoraCore : 4.00 milliseconds (0.1%)  AgoraRtcKit : 16.55 milliseconds (0.5%)  AgoraRtmKit : 5.86 milliseconds (0.2%)  MobileRTC : 72.81 milliseconds (2.5%)  BizConfSDK : 62.33 milliseconds (2.1%)  IpCall : 55.15 milliseconds (1.9%)  JMSDK : 12.39 milliseconds (0.4%)  WebRTC : 4.03 milliseconds (0.1%)  CMBMobile : 116.89 milliseconds (4.0%) total symbol trie searches: 503716 total symbol table binary searches: 0 total images defining weak symbols: 57 total images using weak symbols: 141 Total pre-main time: 1.9 seconds (100.0%)  dylib loading time: 587.96 milliseconds (30.3%)  rebase/binding time: 512.29 milliseconds (26.4%)  ObjC setup time: 358.45 milliseconds (18.5%)  initializer time: 475.87 milliseconds (24.5%)  slowest intializers :  libSystem.B.dylib : 10.61 milliseconds (0.5%)  libMainThreadChecker.dylib : 38.87 milliseconds (2.0%)  libMTLCapture.dylib : 40.14 milliseconds (2.0%)  MobileRTC : 71.93 milliseconds (3.7%)  BizConfSDK : 59.30 milliseconds (3.0%)  IpCall : 62.98 milliseconds (3.2%)  CMBMobile : 125.07 milliseconds (6.4%)   total time: 3.6 seconds (100.0%)  total images loaded: 557 (534 from dyld shared cache)  total segments mapped: 81, into 64755 pages  total images loading time: 2.2 seconds (61.7%)  total load time in ObjC: 358.45 milliseconds (9.8%)  total debugger pause time: 1.6 seconds (45.6%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 1,100,134  total rebase fixups time: 137.06 milliseconds (3.7%)  total binding fixups: 120,097  total binding fixups time: 344.98 milliseconds (9.4%)  total weak binding fixups time: 78.39 milliseconds (2.1%)  total redo shared cached bindings time: 48.13 milliseconds (1.3%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 475.87 milliseconds (13.0%)  libSystem.B.dylib : 10.61 milliseconds (0.2%)  libBacktraceRecording.dylib : 7.84 milliseconds (0.2%)  libMainThreadChecker.dylib : 38.87 milliseconds (1.0%)  libMTLCapture.dylib : 40.14 milliseconds (1.1%)  AgoraRtcKit : 17.49 milliseconds (0.4%)  AgoraRtmKit : 17.02 milliseconds (0.4%)  MobileRTC : 71.93 milliseconds (1.9%)  BizConfSDK : 59.30 milliseconds (1.6%)  IpCall : 62.98 milliseconds (1.7%)  JMSDK : 17.47 milliseconds (0.4%)  WebRTC : 15.85 milliseconds (0.4%)  CMBMobile : 125.07 milliseconds (3.4%) total symbol trie searches: 503716 total symbol table binary searches: 0 total images defining weak symbols: 57 total images using weak symbols: 141 Total pre-main time: 1.5 seconds (100.0%)  dylib loading time: 553.58 milliseconds (36.1%)  rebase/binding time: 335.97 milliseconds (21.9%)  ObjC setup time: 183.34 milliseconds (11.9%)  initializer time: 459.07 milliseconds (29.9%)  slowest intializers :  libSystem.B.dylib : 7.34 milliseconds (0.4%)  libMainThreadChecker.dylib : 40.71 milliseconds (2.6%)  MobileRTC : 78.70 milliseconds (5.1%)  BizConfSDK : 62.17 milliseconds (4.0%)  IpCall : 58.73 milliseconds (3.8%)  CMBMobile : 136.18 milliseconds (8.8%)   total time: 3.2 seconds (100.0%)  total images loaded: 557 (534 from dyld shared cache)  total segments mapped: 81, into 64755 pages  total images loading time: 2.2 seconds (68.9%)  total load time in ObjC: 183.34 milliseconds (5.6%)  total debugger pause time: 1.6 seconds (51.7%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 1,100,646  total rebase fixups time: 79.73 milliseconds (2.4%)  total binding fixups: 120,109  total binding fixups time: 203.13 milliseconds (6.3%)  total weak binding fixups time: 76.69 milliseconds (2.3%)  total redo shared cached bindings time: 23.59 milliseconds (0.7%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 459.07 milliseconds (14.2%)  libSystem.B.dylib : 7.34 milliseconds (0.2%)  libBacktraceRecording.dylib : 7.86 milliseconds (0.2%)  libMainThreadChecker.dylib : 40.71 milliseconds (1.2%)  libMTLCapture.dylib : 24.64 milliseconds (0.7%)  AgoraRtcKit : 19.54 milliseconds (0.6%)  AgoraRtmKit : 7.21 milliseconds (0.2%)  MobileRTC : 78.70 milliseconds (2.4%)  BizConfSDK : 62.17 milliseconds (1.9%)  IpCall : 58.73 milliseconds (1.8%)  JMSDK : 12.57 milliseconds (0.3%)  WebRTC : 3.95 milliseconds (0.1%)  CMBMobile : 136.18 milliseconds (4.2%) total symbol trie searches: 503800 total symbol table binary searches: 0 total images defining weak symbols: 57 total images using weak symbols: 141 Total pre-main time: 1.5 seconds (100.0%)  dylib loading time: 581.62 milliseconds (37.2%)  rebase/binding time: 333.46 milliseconds (21.3%)  ObjC setup time: 225.84 milliseconds (14.4%)  initializer time: 421.27 milliseconds (26.9%)  slowest intializers :  libSystem.B.dylib : 7.83 milliseconds (0.5%)  libMainThreadChecker.dylib : 40.75 milliseconds (2.6%)  MobileRTC : 71.13 milliseconds (4.5%)  BizConfSDK : 65.07 milliseconds (4.1%)  IpCall : 60.22 milliseconds (3.8%)  CMBMobile : 97.62 milliseconds (6.2%)   total time: 2.7 seconds (100.0%)  total images loaded: 557 (534 from dyld shared cache)  total segments mapped: 81, into 64755 pages  total images loading time: 1.7 seconds (64.0%)  total load time in ObjC: 225.84 milliseconds (8.1%)  total debugger pause time: 1.2 seconds (43.2%)  total dtrace DOF registration time: 0.00 milliseconds (0.0%)  total rebase fixups: 1,100,134  total rebase fixups time: 81.05 milliseconds (2.9%)  total binding fixups: 120,097  total binding fixups time: 193.15 milliseconds (6.9%)  total weak binding fixups time: 80.13 milliseconds (2.8%)  total redo shared cached bindings time: 20.88 milliseconds (0.7%)  total bindings lazily fixed up: 0 of 0  total time in initializers and ObjC &#43;load: 421.27 milliseconds (15.1%)  libSystem.B.dylib : 7.83 milliseconds (0.2%)  libBacktraceRecording.dylib : 7.84 milliseconds (0.2%)  libMainThreadChecker.dylib : 40.75 milliseconds (1.4%)  libMTLCapture.dylib : 30.70 milliseconds (1.1%)  AgoraRtcKit : 17.91 milliseconds (0.6%)  AgoraRtmKit : 5.47 milliseconds (0.1%)  MobileRTC : 71.13 milliseconds (2.5%)  BizConfSDK : 65.07 milliseconds (2.3%)  IpCall : 60.22 milliseconds (2.1%)  JMSDK : 13.56 milliseconds (0.4%)  WebRTC : 3.95 milliseconds (0.1%)  CMBMobile : 97.62 milliseconds (3.5%) total symbol trie searches: 503716 total symbol table binary searches: 0 total images defining weak symbols: 57 total images using weak symbols: 141 平均时间为$\frac{2.8 &#43; 3.6 &#43; 3.2 &#43; 2.7}{4}=3.075$
对比 减少的平均时间为： $3.5 - 3.075 = 0.425$
</content>
    </entry>
    
     <entry>
        <title></title>
        <url>https://iihui.github.io/post/ios-time3/</url>
        <categories>
          
        </categories>
        <tags>
          
        </tags>
        <content type="html"> iPhone XR iOS 12.4.1 招乎5.13.5 5.13.5启动时间viewDidAppear为:1.226625919342041秒 5.13.5启动时间viewDidAppear为:1.2704359292984009秒 5.13.5启动时间viewDidAppear为:1.3160110712051392秒 5.13.5启动时间viewDidAppear为:1.1432379484176636秒 5.13.5启动时间viewDidAppear为:1.396178960800171秒 5.13.5启动时间viewDidAppear为:1.7251869440078735秒 平均时间为$(1.2266 &#43; 1.2704&#43; 1.3160 &#43; 1.1432 &#43; 1.3961 &#43; 1.7251)/6 = 1.346233$
招乎5.15.1 5.15.1启动时间viewDidAppear为:1.0555500984191895秒 5.15.1启动时间viewDidAppear为:0.5557539463043213秒 5.15.1启动时间viewDidAppear为:0.5732530355453491秒 5.15.1启动时间viewDidAppear为:0.6849340200424194秒 5.15.1启动时间viewDidAppear为:0.8058780431747437秒 5.15.1启动时间viewDidAppear为:0.5669820308685303秒 平均时间为(1.0555 &#43; 0.5557&#43; 0.5732 &#43; 0.6849 &#43; 0.8058 &#43; 0.56698)/6 = 0.70701
平均减少时间 平均减少时间为：$(1.346233 - 0.70701) = 0.639223$
iPhone XS Max iOS 13.7 招乎5.13.5 5.13.5启动时间viewDidAppear为:3.4725890159606934秒 5.13.5启动时间viewDidAppear为:5.468455076217651秒 5.13.5启动时间viewDidAppear为:3.571161985397339秒 5.13.5启动时间viewDidAppear为:3.682090997695923秒 5.13.5启动时间viewDidAppear为:2.239575982093811秒 平均时间为: $(3.4725&#43;5.4684&#43;3.5711&#43;3.6820&#43;2.2395)/5 = 3.686699$
招乎5.15.1 5.15.1启动时间viewDidAppear为:4.324195981025696秒 5.15.1启动时间viewDidAppear为:2.09130597114563秒 5.15.1启动时间viewDidAppear为:1.827226996421814秒 5.15.1启动时间viewDidAppear为:2.4541349411010742秒 5.15.1启动时间viewDidAppear为:2.442926049232483秒 平均时间为: $(4.3241 &#43; 2.0913 &#43; 1.82722&#43; 2.4541 &#43; 2.4429)/5 = 2.627924$
平均减少时间 平均减少时间为：$(3.686699 - 2.627924) = 1.0587$
iPhone 11 iOS 15.1 招乎5.13.5 启动时间viewDidAppear为:2.2245479822158813秒 启动时间viewDidAppear为:2.2333680391311646秒 启动时间viewDidAppear为:2.1755470037460327秒 启动时间viewDidAppear为:2.305835008621216秒 平均时间为$(2.2245&#43;2.2333&#43;2.17554&#43;2.3058)/4 = 2.234785$
招乎5.15.1 启动时间viewDidAppear为:1.6123250722885132秒 启动时间viewDidAppear为:1.6050660610198975秒 启动时间viewDidAppear为:1.6825041055679321秒 启动时间viewDidAppear为:1.5587329864501953秒 平均时间为$(1.6123&#43;1.6050&#43;1.6825&#43;1.5587)/4 = 1.614625$
平均减少时间 平均减少时间为:$(2.234785 - 1.614625) = 0.62016$
</content>
    </entry>
    
</search>