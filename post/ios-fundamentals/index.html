<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
    <title>iOS 14 编程基础 - Keep It Simple</title>
    <meta name="keywords" content="博客,思考,读书,笔记,技术,分享">
    
    <meta property="og:title" content="iOS 14 编程基础">
    <meta property="og:site_name" content="Keep It Simple">
    <meta property="og:image" content="/img/author.jpg"> 
    <meta name="title" content="iOS 14 编程基础 - Keep It Simple" />
    <meta name="description" content="Swift | Go | C&#43;&#43; "> 
    <link rel="shortcut icon" href="https://iihui.github.io/img/favicon.ico" />
    <link rel="apple-touch-icon" href="https://iihui.github.io/img/apple-touch-icon.png" />
    <link rel="apple-touch-icon-precomposed" href="https://iihui.github.io/img/apple-touch-icon.png" />
    <link href="https://iihui.github.io/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />
    <link href="https://iihui.github.io/js/vendor/fancybox/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />
    <link href="https://iihui.github.io/css/main.css" rel="stylesheet" type="text/css" />
    <link href="https://iihui.github.io/css/syntax.css" rel="stylesheet" type="text/css" />

    <script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
     fancybox: true, 
    motion: true
  };
</script>

    <link href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/monokai-sublime.min.css" rel="stylesheet">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/go.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/swift.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/objectivec.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/clojure.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/kotlin.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/yaml.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<div class="container one-collumn sidebar-position-left page-home  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-meta  custom-logo ">

  <div class="custom-logo-site-title">
    <a href="https://iihui.github.io/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Keep It Simple</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">靡不有初，鲜克有终</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
    <ul id="menu" class="menu">
      
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/tags/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-tag"></i> <br />标签
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/post/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/categories/%E7%BE%8E%E9%A3%9F/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-fire"></i> <br />美食
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/categories/%E5%90%8E%E6%9C%9F/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-edit"></i> <br />后期
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/categories/%E6%97%85%E8%A1%8C/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-leaf"></i> <br />旅行
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/about/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于
          </a>
        </li>
      
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger"> <i class="menu-item-icon fa fa-search fa-fw"></i> <br /> 搜索</a>
      </li>
    </ul>
    <div class="site-search">
      <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>

    </div>
</nav>
<script type="text/javascript"
        async
        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
		<!-- src = "http://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> <\!--  -\-> -->
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>

<!DOCTYPE html>
<html lang="en">


<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css" integrity="sha384-D+9gmBxUQogRLqvARvNLmA9hS2x//eK1FhVb9PiU86gmcrBrJAQT8okdJ4LMp2uv" crossorigin="anonymous">

    
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js" integrity="sha384-483A6DwYfKeDa0Q52fJmxFXkcPCFfnXMoXblOkJ4JcA8zATN6Tm78UNL72AKk+0O" crossorigin="anonymous"></script>
</head>
<body>

</body>
</html>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
<section id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="https://iihui.github.io/post/ios-fundamentals/" itemprop="url">
        iOS 14 编程基础
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">创建: </span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2021-08-28">
    2021-08-28
</time>
</span>
&nbsp; | &nbsp;
<span class="post-updated-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-check-o"></i>
</span>
<span class="post-meta-item-text">更新: </span>
<time itemprop="dateUpdated" content="2021-08-29">
    2021-08-29
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类: </span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="https://iihui.github.io/categories/ios" itemprop="url" rel="index">
        <span itemprop="name">iOS</span>
      </a>
      &nbsp; 
    </span>
  
</span>


      <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-file-word-o"></i>
</span>
<span class="post-meta-item-text">字数: </span>
<span class="leancloud-visitors-count">80265</span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-coffee"></i>
</span>
<span class="post-meta-item-text">阅读: </span>
<span class="leancloud-visitors-count">161 分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <h1 id="object">Object</h1>
<p>在<code>Swift</code>中，万物皆为对象，这是什么意思呢？这取决于我们所说的「对象」是什么，以及所说的「万物」是指什么。简单地说，对象就是可以向其发送消息的东西，而消息指的是一个命令式指令。在<code>Swift</code>中，发送消息的语法是点表示法：<font color=red>以对象开始，然后紧跟一个点，最后紧跟消息</font>。</p>
<p>万物皆为对象是一种暗示：即使是「最原始的」语言实体也可以接收消息。例如，<code>1</code>在多数编程语言中仅仅是字面意义上的含义，而在<code>Swift</code>中可以按照如下方式使用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#ae81ff">1.</span>description
</span></span></code></pre></div><p>从上面的代码可以看出，<code>1</code>确实是一个对象，因为它可以接收<code>description</code>这样的消息。在表达式<code>1+2</code>中，如同<code>1</code>是一个对象一样，<code>+</code>实际上是一个消息（运算符语法消息）。在<code>Swift</code>中，<strong><font color=red>每个名词都是一个对象，而每个动词都是一个消息</font></strong>。</p>
<p>在<code>Swift</code>中，<strong><font color=Blue>检验一个东西是否为对象的最终标准是看能否修改它</font></strong>。一个对象类型可以在<code>Swift</code>中被扩展，这意味着<font color=LightSeaGreen>可以在这个类型上定义自己的消息，即该对象类型是可以被修改的</font>。</p>
<p>例如，通常不能向一个整数字面量发送<code>sayHello</code>消息，但可以通过扩展来改变一个<code>Int</code>类型，使得可以向其实例发送<code>sayHello</code>消息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">extension</span> <span style="color:#a6e22e">Int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sayHello</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;Hello, I&#39;m </span><span style="color:#e6db74">\(</span><span style="color:#66d9ef">self</span><span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在<code>Swift</code>中，<code>1</code>是对象，在<code>Objective-C</code>中，它是<strong>标量内置类型</strong>。但在<code>Swift</code>中，<strong>不存在标量类型</strong>，<font color=red>所有类型都是对象类型</font>，<strong><font color=Blue>这就是「万物皆为对象」的真正含义</font></strong>。</p>
<p>在许多其它语言中，对象是类或者类的实例。在<code>Swift</code>中，也有类的概念，但字面量<code>1</code>既不是类，也不是类的实例。在<code>Swift</code>中，<font color=red>字面量<code>1</code>的类型是<code>Int</code>，该类型是一个结构体</font>。</p>
<p>在<code>Swift</code>中有三种对象类型，它们依次是<font color=LightSeaGreen>类，结构体以及枚举类型</font>。它们都是非常明确的对象类型，并且它们之间的相似性远大于差异性。实际上，在<code>Swift 5.5</code>中，还有第<code>4</code>种对象类型，那就是<code>actors</code>。</p>
<p>一个完整的<code>Swift</code>命令为一条语句，一般使用换行符来分隔语句。一个<code>Swift</code>文件一般由多行文本组成，<font color=red>通常一行一条语句</font>。如果想要一行包含多条语句，则需要使用分号分隔：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;hello&#34;</span>); print(<span style="color:#e6db74">&#34;world&#34;</span>)
</span></span></code></pre></div><p>如果一个语句太长，实际上是可以拆成多行的，但是<font color=LightSeaGreen>拆分的位置应当尽量在合理的地方</font>。如下代码所示，左括号是一个较好的位置：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>print(
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;world&#34;</span>)
</span></span></code></pre></div><p>在<code>Swift</code>编码习惯中，花括号后面都是紧跟换行符，并且为了使代码更清晰，通常会进行缩进，<code>Xcode</code>中也会强化这种约定：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;woof&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>但实际上这只是一种编码惯例，<code>Swift</code>编译器并不在乎这些。下面示例代码将花括号后面没有紧跟换行符，而是将类的定义写在一行也是合法的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> { <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() { print(<span style="color:#e6db74">&#34;woof&#34;</span>) }}
</span></span></code></pre></div><p><code>Swift</code>是一种编译语言，这意味着代码必须先经过编译，<font color=LightSeaGreen>通过编译器将语句转换为计算机可以理解的较低级别的形式，然后才能运行并执行这些代码</font>。</p>
<h2 id="variables">Variables</h2>
<p>变量是对象的名称，从技术上来说，一个<font color=red>变量指向一个对象，是这个对象的引用</font>。非严格地说，变量就是一个存放对象的盒子，<font color=LightSeaGreen>这个对象可能会发生变化或者盒子的对象可能被另一个对象取代，但这个名字有其自身的完整性</font>。变量所指向的对象就是变量的值。</p>
<p>在<code>Swift</code>中，所有变量都<font color=LightSeaGreen>必须先声明后使用</font>。变量声明通常伴随着初始化，即作为声明的一部分增加一个等号，并且立即给变量一个初始值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> two = <span style="color:#ae81ff">2</span>
</span></span></code></pre></div><p>用<code>let</code>声明的是一个常量，<font color=red>它的值只能赋一次（可以先声明后面再初始化一次，或者声明的同时初始化，但必须保证只赋值一次）</font>。一旦初始化后，如果试图再次改变<code>let</code>声明的常量的值，就会出现编译错误。</p>
<p>变量都有一个类型，这个类型是在变量声明时就确定了的，并且不能被更改。在下面的例子中，变量<code>two</code>声明时的类型是<code>Int</code>，因此不能使用<code>String</code>类型来覆盖它：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> two = <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>two = <span style="color:#e6db74">&#34;hello&#34;</span> <span style="color:#75715e">// 编译错误：Cannot assign value of type &#39;String&#39; to type &#39;Int&#39;</span>
</span></span></code></pre></div><p>按照惯例，类型名字以大写字母开头，变量名以小写字母开头。如果违反了这种规范，代码仍然能够通过编译，但强烈建议不要这么做。</p>
<h2 id="functions">Functions</h2>
<p>通常来说，<font color=red>可执行代码必须放在一个函数体内</font>。但有一个例外，在<code>main.swift</code>文件中，<font color=LightSeaGreen>可以在其顶层（任何函数体之外）放置可执行代码</font>。</p>
<p>一个<font color=Blue>函数是一批可执行语句的集合</font>，可以作为一个批次来运行。函数体由花括号包围，通常一个函数有一个名字（也有匿名函数），通过函数声明获得这个名字:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sum</span>(a: Int, b: Int) -&gt; Int {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> a <span style="color:#f92672">+</span> b
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="the-structure-of-a-swift-file">The Structure of a Swift File</h2>
<p>一个<code>Swift</code>程序可以由一个或多个文件组成。在<code>Swift</code>中，一个文件是一个有意义的单元，而且对于可以放在文件里的代码结构有明确的规定。通常来说，只有下面的东西可以放在<code>Swift</code>文件的顶层：</p>
<ul>
<li>
<p>模块导入语句，例如：<code>import UIKit</code>。<code>module</code>是更高层次的单元，一个模块包含多个文件，同一个模块里的文件默认能够自动看到各自。一个<code>App</code>属于一个<code>module</code>，里面的文件能够看到各自。在一个<code>module</code>中，不通过<code>import</code>不能看到另一个<code>module</code>中的文件。</p>
</li>
<li>
<p>全局变量和常量声明：文件顶层声明的变量，被称为全局变量，包括以<code>let</code>和<code>var</code>声明的变量。同一个模块中任何文件中的所有代码都将能够看到并访问它，无需依赖任何对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> str = <span style="color:#e6db74">&#34;test&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> cons = <span style="color:#ae81ff">13</span>
</span></span></code></pre></div></li>
<li>
<p>全局函数声明：在文件顶层声明的函数为全局函数，默认情况下，同一个模块中的<font color=red>任何文件中的代码都可以看到并访问它</font>，而无需依赖任何对象。</p>
</li>
<li>
<p>对象类型声明：包括<code>class,struct,enum,protocol</code>等对象类型的声明。</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">import</span> <span style="color:#a6e22e">UIKit</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> one = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> constant = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">changeOne</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Manny</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Moe</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Jack</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在上面的例子中，<font color=LightSeaGreen>花括号里的内容可以是变量声明、函数声明和对象类型声明</font>。事实上，<font color=red>任何花括号里面都可以包含变量声明、函数声明和对象类型的声明</font>。</p>
<p>像<code>one = two</code>或<code>debugPrint(&quot;hello&quot;)</code>这样的语句是可执行语句，<font color=LightSeaGreen>一般不能放在文件的顶层，而是将其放在函数体中</font>（除了<code>main.swift</code>中的顶层可以有可执行语句）。在下面的代码中，<code>func changeOne()</code>是一个函数声明，可执行代码放在花括号中以形成函数体:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> one = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">changeOne</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> two = <span style="color:#ae81ff">2</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 可执行语句</span>
</span></span><span style="display:flex;"><span>    one = two 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>同样地，<font color=Blue>可执行代码不能直接放在类<code>Manny</code>声明的花括号内</font>，<font color=LightSeaGreen>因为那是类声明的顶层，而不是函数体内</font>。但是一个类声明可以包含一个函数声明，并且该函数声明中可以包含可执行代码。</p>
<h2 id="scope-and-lifetime">Scope and Lifetime</h2>
<p>在<code>Swift</code>程序中，所有事物都有一个作用域。<font color=red>作用域指的是能够被其它事物看到的能力</font>。事物可以嵌套在其它事物内部，形成嵌套层次结构。作用域的可见规则：<font color=LightSeaGreen>事物可以看到它们自己所在的层次和包含它们的更高层次的事物</font>，这些层次依次是：</p>
<ul>
<li><code>module</code>：模块</li>
<li><code>file</code>：文件</li>
<li><code>{}</code>：花括号</li>
</ul>
<p>当某事物被声明时，它一定是在层次结构中的某个级别声明的。它在层次结构中的位置决定了是否可以被其它事物看到。作用域是<font color=red>共享信息的一种非常重要方式</font>，首先来看下面的代码段：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> one = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">changeOne</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> two = <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> 		<span style="color:#75715e">// 内部函数</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sayTwo</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(two)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Klass</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 内部类实现</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Struct</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 内部结构体实现</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Enum</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 内部枚举实现</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    one = two
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Manny</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> name = <span style="color:#e6db74">&#34;manny&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sayName</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(name)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Klass</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 内部类实现</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Struct</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 内部结构体实现</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Enum</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 内部枚举实现</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Moe</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> name = <span style="color:#e6db74">&#34;moe&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sayName</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(name)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Klass</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 内部类实现</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Struct</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 内部结构体实现</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Enum</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 内部枚举实现</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Jack</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name: String {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;jack&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sayName</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(name)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Klass</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 内部类实现</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Struct</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 内部结构体实现</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Enum</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 内部枚举实现</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在上面代码中，类<code>Manny</code>中声明的所有函数都可以看到<code>Manny</code>顶层声明的<code>name</code>。类<code>Manny</code>、<code>Jack</code>和<code>Moe</code>中的代码都能看到文件顶层声明的函数、变量和常量。</p>
<p>对于一个东西而言，只要包含它的<code>scope</code>（范围）存在，那么这个东西就会存在。在上面的代码中，只要文件存在，变量<code>one</code>就存在。也就是说只要程序运行，变量<code>one</code>就存在，因为它是全局的。但是在<code>Manny</code>顶层声明的实例变量只有在<code>Manny</code>实例存在时才会有效。</p>
<p>代码中的<font color=red>事物都有生命周期，实际上等同于它们的作用域</font>。变量声明、函数声明和对象类型声明可以出现在任何的大括号中。一般来说，在<font color=Blue>更深层次声明的东西生命周期更短</font>，对于下面这段代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">silly</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">true</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Cat</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Cat实现...</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">var</span> one = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        one = one <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果函数<code>silly</code>被调用，执行路径就会进入到<code>if</code>结构中。在这里，类<code>Cat</code>被声明，然后变量<code>one</code>被声明并生成，接着可执行语句<code>one = one + 1</code>被执行，最后作用域结束，此时类<code>Cat</code>和变量<code>one</code>都会自动消失。在它们短暂的生命中，<em><font color=red>类<code>Cat</code>和变量<code>one</code>对于代码的其它部分来说是完全不可见的</font></em>。</p>
<h2 id="object-members">Object Members</h2>
<p>在对象类型（类，结构体和枚举）的声明中，<em><font color=LightSeaGreen>顶层声明的常量和变量被称为属性，顶层声明的函数叫做方法</font></em>。在一个对象类型声明时，<font color=Blue>顶层声明的属性和方法统称对象成员</font>。对象成员具有特殊的意义，因为它定义了可以向该对象发送的消息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Manny</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> name = <span style="color:#e6db74">&#34;manny&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sayName</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(name)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Klass</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Struct</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Enum</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="namespaces">Namespaces</h2>
<p>命名空间是指程序的一个命名区域。对于命名空间外的事物，如果想访问命名空间内的事物，<font color=Blue>就需要先使用该命名区域的名字，以破除该区域的障碍</font>，否则就不能访问该命名区域内的事物。</p>
<p>这是一件好事，因为<font color=red>这样允许相同名字的事物在不同的地方使用而不发生冲突</font>。显然，命名空间和作用域是密切相关的概念。</p>
<p>命名空间有助于解释在一个对象的顶层声明内嵌另一个对象声明的意义。下面的代码在<code>Manny</code>以内嵌的方式声明了<code>Klass</code>，它有效地 将<code>Klass</code>隐藏在<code>Manny</code>里面：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Manny</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> name = <span style="color:#e6db74">&#34;manny&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sayName</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// print name</span>
</span></span><span style="display:flex;"><span>        debugPrint(name)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Klass</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 内部类实现</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Struct</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 内部结构体实现</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Enum</span> {
</span></span><span style="display:flex;"><span>       <span style="color:#75715e">// 内部枚举实现</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在上面的代码中，类<code>Manny</code>是一个命名空间，类<code>Klass</code>声明在其中，在类<code>Manny</code>内部的代码可以直接看到类<code>Klass</code>，但在<code>Manny</code>之外的代码不能直接看到类<code>Klass</code>。</p>
<p>如果想要看到在<code>Manny</code>内部声明的<code>Klass</code>，必须明确地使用命名空间的名字，以解除命名空间所代表的障碍。要做到这一点，需要先使用<code>Manny</code>的名字（它代表命名空间），然后是一个点，最后是<code>Klass</code>。简而言之，现在必须使用<code>Manny.Klass</code>来访问类<code>Manny</code>内部声明的<code>Klass</code>类：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Manny</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> name = <span style="color:#e6db74">&#34;manny&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sayName</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(name)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Klass</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test</span>() {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Struct</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 内部结构体实现</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Enum</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 内部枚举实现</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Moe</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> name = <span style="color:#e6db74">&#34;moe&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sayName</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(name)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Klass</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test</span>() {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 使用命名空间来访问Klass</span>
</span></span><span style="display:flex;"><span>            Manny.Klass().test() 
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Struct</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 内部结构体实现</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Enum</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 内部枚举实现</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>命名空间<font color=LightSeaGreen>本身不提供秘密和隐私，它只提供一种便利性</font>。在上面的代码中，类<code>Manny</code>中定义了一个<code>Klass</code>类，同时在结构体<code>Moe</code>中也定义了一个<code>Klass</code>类。但它们并不冲突，因为它们是<font color=LightSeaGreen>定义在不同的命名空间中的</font>，如果有必要，可以使用<code>Manny.Klass</code>和<code>Moe.Klass</code>来进行区分。</p>
<p>默认情况下，结构体<code>Moe</code>里面的代码<font color=Blue>不能直接</font>看到<code>Manny</code>里面声明的<code>Klass</code>，但可以通过一个简单的步骤看到它，即<code>Manny.Klass</code>。这是因为<code>Moe</code>里的代码能看到类<code>Manny</code>，而<code>Manny</code>是在`Moe<font color=Blue>内部代码能看到的层次上声明的</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Klass</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test</span>() {
</span></span><span style="display:flex;"><span>        Manny.Klass().test()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="modules">Modules</h2>
<p>顶层的命名空间是<code>module</code>（模块）。<code>App</code>是一个<code>module</code>，因此也是一个命名空间，该命名空间的名称<font color=LightSeaGreen>默认为应用程序的名字</font>。若应用程序的名称为<code>MyApp</code>，并且在文件顶层声明一个类<code>Manny</code>，这个类的真实名字是<code>MyApp.Manny</code>。但通常不需要使用这个带前缀的真实名字，因为应用程序中的代码<font color=Blue>已经在同一个命名空间内，可以直接看到类</font><code>Manny</code>。</p>
<p>在当前文件中导入一个模块后，<font color=red>该模块内的所有顶层声明对于当前文件的代码都是可见的</font>，因此不必显式地使用模块的名字来引用。例如，<code>Cocoa</code>的<code>Foundation</code>框架是一个<code>module</code>，<code>NSString</code>是在<code>Foundation</code>顶层声明的。因此，当在代码中<code>import Foundation</code>后，可以直接使用<code>NSString</code>而不必使用<code>Foundation.NSString</code>这样带命名空间的真实名字。</p>
<p>实际上<code>Swift</code>本身也是在一个模块中定义的，即<code>Swift module</code>。但我们不必手动导入它，因为编译器总是<font color=red>隐含地导入</font>了<code>Swift module</code>。也可以在文件中加入<code>import Swift</code>来显式地导入，但没必要这样做，因为编译器会提示<code>module swift is already imported</code>。</p>
<p>上面这个事实非常重要，因为它解释了一个重要的谜题：像<code>debugPrint</code>和<code>print</code>这样的函数到底是从哪里来的，为什么在任何地方都可以使用它们。<code>debugPrint</code>和<code>print</code>实际上是在<code>Swift module</code>顶层声明的一个函数，因为编译器已经隐含地导入了<code>Swift</code>模块，所以我们的代码可以直接看到<code>Swift module</code>所有的顶层声明，当然也包括<code>debugPrint</code>和<code>print</code>。</p>
<p>因此，<code>debugPrint</code>函数如同当前文件的其它顶层函数一样，也<font color=Blue>变成了一个普通的顶层函数</font>，它对我们的代码来说是全局的。因此，可以直接使用它而不需要指定命名空间，也可以在使用的时候明确指定它的命名空间，即使用<code>Swift.debugPrint(&quot;hello&quot;)</code>，但通常不这样做，因为这样很冗余。</p>
<p>但是，你自己应用程序模块会掩盖导入的任何其它模块。也就是说，如果声明一个与导入模块中同名的东西，就<font color=red>会失去直接使用导入的东西而不用指定命名空间的神奇能力</font>。假如在代码中声明一个同名的<code>debugPrint</code>函数，那么编译器将会自动隐藏<code>Swift module</code>中的<code>debugPrint</code>函数，即自定义代码中声明的<code>debugPrint</code>函数<font color=red>具有更高的优先级</font>，为了调用<code>Swift</code>的<code>debugPrint</code>函数，现在<font color=LightSeaGreen>必须明确地使用有命名空间</font>，即<code>Swift.debugPrint</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>Swift.debugPrint(<span style="color:#e6db74">&#34;test&#34;</span>)
</span></span></code></pre></div><h2 id="instances">Instances</h2>
<p>对象类型（类、结构和枚举）有一个重要的共同特点：它们可以被实例化。实际上，声明一个对象类型时，只是定义了一个类型，实例化是为了生成该类型的实例。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;woof&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面的代码只是声明了<code>Dog</code>类型，即描述了如果有一只狗，它应该是什么样的，实际上目前还没有任何<code>Dog</code>实例。为了得到一只真正的<code>Dog</code>，必须制造一只，而制造一只真正的<code>Dog</code>的过程就是实例化<code>Dog</code>的过程。</p>
<p>在<code>Swift</code>中，实例的生成可以通过<font color=red>使用对象类型的名称作为函数名并调用该函数来实现（被称为初始化器）</font>。当在一个对象类型的名称上加上圆括号时，就是在<font color=Blue>向该对象类型发送一种非常特殊的信息———实例化你自己（生成一个该类型的实例）</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> fido = Dog()
</span></span></code></pre></div><p>上面这段代码做了两件事，首先是实例化了<code>Dog</code>，得到了一个<code>Dog</code>实例。同时还把这个实例放到了一个名叫<code>fido</code>的盒子中（声明了一个变量，并通过把<code>Dog</code>的实例分配给它来初始化这个变量，现在<code>fido</code>是一个<code>Dog</code>的实例）。</p>
<p>现在有一个<code>Dog</code>的实例，可以向它发送<code>instance messages</code>（实例消息），实例消息包括<font color=LightSeaGreen>实例属性和实例方法</font>。<font color=red>在对象类型的声明中，属性和方法默认是实例属性和实例方法，不能把它们作为该对象类型的消息来使用</font>。如果想要发送实例消息，就必须先生成一个实例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> fido = Dog()
</span></span><span style="display:flex;"><span>fido.bark()
</span></span></code></pre></div><p>如果想要发送类型消息，则需要声明为<code>static</code>或<code>class</code>函数，或者声明<code>static</code>或<code>class</code>属性。下面代码中声明了<code>static</code>和<code>class</code>属性和方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Test</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// static属性</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">var</span> test = <span style="color:#e6db74">&#34;test&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// class属性，不能为存储属性</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">var</span> name: String {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;name&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// static方法</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">testFunc</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// class 方法</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">func</span> nameFunc() {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在上面代码中用<code>class</code>声明<code>name</code>属性时<font color=red>只能为计算属性，不能声明为存储属性</font>，否则会出现编译错误：<code>Class stored properties not supported in classes; did you mean 'static'?</code>。</p>
<p>即使没有实例这样的东西，<font color=LightSeaGreen>对象类型本身也是一个对象</font>，因为可以向对象类型发送消息（<code>Manny.Klass</code>就是一个很好的例子）。为什么会需要实例呢？这主要与实例属性的性质有关，<font color=LightSeaGreen>实例属性的值是针对特定实例定义的</font>，这就是实例真正有用和强大的地方。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name = <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;woof&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>对于上面的声明，可以生成多个<code>Dog</code>实例，每一个<code>Dog</code>实例都有自己的<code>name</code>值。但多个实例的行为是相似的，它们都可以调用<code>bark</code>方法。</p>
<img src="https://s2.loli.net/2022/01/09/ocSZHNe2lYI6bWD.png" alt="ocSZHNe2lYI6bWD" style="zoom:80%;" />
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> dog1 = Dog()
</span></span><span style="display:flex;"><span>dog1.name = <span style="color:#e6db74">&#34;Fido&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> dog2 = Dog()
</span></span><span style="display:flex;"><span>dog2.name = <span style="color:#e6db74">&#34;Rover&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(dog1.name) <span style="color:#75715e">// &#34;Fido&#34;</span>
</span></span><span style="display:flex;"><span>print(dog2.name) <span style="color:#75715e">// &#34;Rover&#34; </span>
</span></span><span style="display:flex;"><span>dog2 = dog1
</span></span><span style="display:flex;"><span>print(dog2.name) <span style="color:#75715e">// &#34;Fido&#34;</span>
</span></span></code></pre></div><p>一个实例**<font color=LightSeaGreen>不仅对其属性的值负责，而且对其属性的生命周期负责</font>**。假设创建了一个<code>Dog</code>实例，并为它的<code>name</code>属性赋值为<code>Fido</code>。只要不将属性<code>name</code>的值替换为其它值，并且此实例一直存在，这个实例就会使字符串<code>Fido</code>保持活跃状态。</p>
<p>也就是说一个<font color=red>实例既是代码又是数据</font>。实例的代码指的是它的类型声明，与该类型的所有实例共享。但数据只属于实例，只要实例持续存在，数据就可以持续存在，<font color=red>实例在每个时刻都有一个状态，即实例属性值完整集合</font>。</p>
<p>一个类的声明实际上定义了一个命名空间。这个命名空间**<font color=Blue>要求其它对象使用额外的点标记来引用该空间内的内容</font>**。<font color=red>命名空间本身并没有关闭任何可见性的大门，但访问权限<code>private</code>关键字可以。</font></p>
<h2 id="the-keyword-self">The Keyword self</h2>
<p>一个实例是一个对象，而对象是消息的接收者。因此，一个实例需要一种向自己发送消息的方法，可以通过使用关键字<code>self</code>来实现。<code>self</code>关键字可以用在预期有适当类型实例的地方：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name = <span style="color:#e6db74">&#34;name&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> whatADogSays = <span style="color:#e6db74">&#34;woof&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#66d9ef">self</span>.whatADogSays)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">speak</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.bark()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面代码中<code>self</code>仅出现在实例方法中，当在一个实例代码中使用<code>self</code>时，它指的是当前这个实例，也就是<font color=red>此时代码正在运行的那个</font>。如果表达式<code>self.name</code>出现在<code>Dog</code>实例方法中，它意味着当前<code>Dog</code>实例的<code>name</code>属性。</p>
<p>在实例方法中使用<code>self</code>关键字是可选的，即是可以省略的。如果省略了信息接收者，而要发送的信息又可以发送给<code>self</code>，那么<font color=Blue>编译器默认会把<code>self</code>作为信息的接收者</font>。作为一个编码风格问题，明确地使用<code>self</code>或许是一个好习惯，因为省略<code>self</code>的代码更难阅读和理解。而且<font color=LightSeaGreen>在有些情况下，必须显式使用<code>self</code></font>。</p>
<h2 id="privacy">Privacy</h2>
<p>命名空间<font color=red>本身并未关闭任何可见性的大门，但这种可见性屏障有时是十分需要的</font>。因为并非所有由实例存储的数据都是为了被另一个实例改变，甚至有时要求对其它实例是不可见的。</p>
<p>也不是每个实例的方法都想要被其它实例调用。基于对象的编程语言通常都需要一种方法来赋予其对象成员以隐私——<font color=red>一种使其它对象更难看到这些属性和方法的方式</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name = <span style="color:#e6db74">&#34;name&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> whatADogSays = <span style="color:#e6db74">&#34;woof&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#66d9ef">self</span>.whatADogSays)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">speak</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#66d9ef">self</span>.whatADogSays)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在上面的声明中，其它对象都可以更改实例属性<code>whatADogSays</code>。并且<code>bark</code>和<code>speak</code>方法都使用该属性，一旦改变属性<code>whatADogSays</code>的值，则<code>bark</code>和<code>speak</code>使用的值也会跟着变化。为了避免<code>whatADogSays</code>被随意更改，可以将其用<code>private</code>限定<font color=Blue>只能方法能够修改，不能被实例直接修改</font>。</p>
<p>一个类声明定义了一个命名空间。这个命名空间要求其他对象使用额外的点符号来引用命名空间内的内容，命名空间本身并不会关闭任何可见性之门。<font color=LightSeaGreen><code>private</code>关键字可以关闭这些可见性大门</font>。</p>
<p>在上面的代码中，其它的实例也能够访问和修改属性<code>whatADogSays</code>。因为方法<code>bark</code>和<code>speak</code>都能修改属性<code>whatADogSays</code>的值。当使用一个<code>Dog</code>实例调用<code>bark</code>时，它却说<code>meow</code>，这似乎有点不可取：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> fido = Dog()
</span></span><span style="display:flex;"><span>fido.whatADogSays = <span style="color:#e6db74">&#34;meow&#34;</span>
</span></span><span style="display:flex;"><span>fido.bark() <span style="color:#75715e">// meow</span>
</span></span></code></pre></div><p>此时，我们可能想到把属性<code>whatADogSays</code>声明为常量，这样就没人可以修改它了。但这个带来了两个问题。第一，假设想要<code>Dog</code>实例本身可以修改属性<code>whatADogSays</code>，此时需要将其声明为<code>var</code>，否则连实例本身也不能修改。</p>
<p>另外，假设不希望任何其它对象知道这只<code>Dog</code>在说什么，除非通过调用<code>bark</code>和<code>speak</code>。即使使用<code>let</code>声明，其他对象仍然可以读取<code>whatADogSays</code>的值。为了解决这个问题，<code>Swift</code>提供了<code>private</code>关键字：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name = <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> whatADogSays = <span style="color:#e6db74">&#34;woof&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        print(<span style="color:#66d9ef">self</span>.whatADogSays)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">speak</span>() {
</span></span><span style="display:flex;"><span>        print(<span style="color:#66d9ef">self</span>.whatADogSays)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>现在<code>whatADogSays</code>是私有属性，它不能被其他类型的对象看到。<code>Dog</code>实例可以访问<code>whatADogSays</code>，但<code>Cat</code>实例中使用<code>Dog</code>实例时，不能访问属性<code>whatADogSays</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Cat</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">tryToChangeWhatADogSays</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> fido = Dog()
</span></span><span style="display:flex;"><span>        fido.whatADogSays = <span style="color:#e6db74">&#34;meow&#34;</span> <span style="color:#75715e">// compile error </span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="reserved-words">Reserved Words</h2>
<p>某些术语，如<code>class</code>和<code>func</code>和<code>var</code>和<code>let</code>和<code>if</code>以及<code>private</code>和<code>import</code>，在<code>Swift</code>中是保留的关键字。这意味着不能将它们用作标识符——例如作为类、函数或变量的名字。如果尝试这样做，将会出现编译错误。如果需要强制将保留字成作为标识符，需要反引号(`)将其括起来，下面这个代码看起来非常混乱，但是是合法的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> `<span style="color:#66d9ef">func</span>` {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> `<span style="color:#66d9ef">if</span>`() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> `<span style="color:#66d9ef">class</span>` = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>实例不是凭空产生的，<font color=Blue>必须实例化一个类型才能获得这个类型的一个实例。</font>通常说来，程序中很大一部分操作是实例化类型。当然，你会希望这些实例持续存在，因此将每个新创建的实例分配给一个变量，以保存、命名并赋予它生命周期。该实例将根据引用它的变量的生命周期持续存在。</p>
<h1 id="functions-1">functions</h1>
<p>没有什么比声明和调用函数更能说明<code>Swift</code>的语法特点了。下面是一个简单有效的函数声明，它期望有两个<code>Int</code>入参，然后把它们加在一起：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sum</span>(<span style="color:#66d9ef">_</span> x: Int, <span style="color:#66d9ef">_</span> y: Int) -&gt; Int {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> result = x <span style="color:#f92672">+</span> y
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> result
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>函数声明的语法是非常严格和明确的，除非完全理解它，否则也就无法使用<code>Swift</code>。把上面函数的第一行拆分成几个部分，这样就可以单独地标记它们：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sum</span>                     <span style="color:#960050;background-color:#1e0010">①</span>
</span></span><span style="display:flex;"><span>     (<span style="color:#66d9ef">_</span> x:Int, <span style="color:#66d9ef">_</span> y:Int)      <span style="color:#960050;background-color:#1e0010">②③</span>
</span></span><span style="display:flex;"><span>      -&gt; Int {               <span style="color:#960050;background-color:#1e0010">④⑤</span>
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">let</span> result = x <span style="color:#f92672">+</span> y <span style="color:#960050;background-color:#1e0010">⑥</span>
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">return</span> result      <span style="color:#960050;background-color:#1e0010">⑦</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol>
<li>
<p>函数定义以关键字<code>func</code>开始，后面跟着函数名，上面示例中的函数名是<code>sum</code>。函数名是函数调用必须使用的名称，即为了<font color=red>运行函数中所包含的代码必须使用函数名</font>。</p>
</li>
<li>
<p>函数名后面紧跟着参数列表，<font color=LightSeaGreen>参数列表至少由一对圆括号组成</font>。如果定义的函数需要参数，它们以逗号隔开列在圆括号内。每个参数都有严格的格式：<code>外部参数名，空格，内部参数名，冒号，参数类型</code>。</p>
</li>
<li>
<p>上面的函数在参数名前有一个下划线和空格，下划线表示调用该函数时可以省略外部参数名。</p>
</li>
<li>
<p>如果函数有返回值，在圆括号后面紧跟的将会是箭头运算符<code>-&gt;</code>，在其后跟着的是函数返回类型。</p>
</li>
<li>
<p>使用花括号把函数体（实际的可执行代码）括起来。</p>
</li>
<li>
<p>在花括号里面，参数已经生效，其类型在参数列表中已经被指定。</p>
</li>
<li>
<p>如果函数要返回一个值，它需要在函数体中使用关键字<code>return</code>（函数中仅有一行可以省略<code>return</code>语句），其后紧跟着返回值。该值的类型必须与先前在函数声明时的返回值类型相匹配。</p>
</li>
</ol>
<h2 id="parameters">Parameters</h2>
<p>上面定义的<code>sum</code>函数有两个参数：第一个是<code>Int</code>类型，名字是<code>x</code>，第二个也是<code>Int</code>类型，名字为<code>y</code>。事实上，参数<code>x</code>和<code>y</code>的定义只是为了让参数值在函数体中使用。</p>
<p>函数体中的代码不会运行，除非其它地方的代码<font color=Blue>调用此函数并为其参数传递指定类型的值</font>。如果调用这个函数时没有传递参数，或者提供的值都不是<code>Int</code>，编译器将报错。</p>
<p>参数声明的意思大概是：我们正在声明<code>x</code>和<code>y</code>，以便在函数中使用它们。<font color=red>这些变量是函数的局部变量（或称为内部变量），只有在当前函数体中才可以看到它们</font>，函数外便无法再使用，它们与可能在其他函数或更高层次范围内使用的任何其它同名的<code>x</code>和<code>y</code>均不同。</p>
<h2 id="return-value">Return Value</h2>
<p>在函数体中的关键字<code>return</code>其实做了两件事，<font color=LightSeaGreen>首先是返回其后跟着的值，其次是结束当前函数的执行</font>。虽然<code>return</code>语句之后可以包含其它代码，但这些代码不会被执行，并且还会产生编译警告。</p>
<p>在<code>Swift 5.1</code>前，在有返回值的函数中<font color=Blue>即使只有一条语句也必须显式使用<code>return</code>语句</font>。但从<code>Swift 5.1</code>开始，有返回值的函数中如果只有一条语句时可以省略<code>return</code>关键字，这个特性主要是方便<code>SwiftUI</code>。</p>
<p>在<font color=red>函数声明花括号前的那一部分可以看成是一种契约，用于约定当前函数的输入和输出是怎么样的</font>。根据这个契约，该函数期望有一定数量的入参，每个参数都有特定的类型，并产生一定类型的结果。因此，在函数调用时必须遵守这个契约。</p>
<p>花括号内的函数体将函数参数作为局部变量使用，关键字<code>return</code>后面的返回值类型必须与函数声明时的返回类型一致，<font color=red>否则会出现编译错误</font>。</p>
<p>如果想要忽略函数的返回值，可以将函数调用的返回值分配给<code>_</code>（没有名称的变量）来消除编译器警告。例如，上面的<code>sum</code>调用可以如下使用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">_</span> = sum(<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">5</span>)
</span></span></code></pre></div><p>如果被调用的函数是自定义的，可以在函数声明的时候使用<code>@discardableResult</code>标记，表明这个返回值可以不处理，以消除编译警告：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>@discardableResult  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sum</span>(<span style="color:#66d9ef">_</span> x: Int, <span style="color:#66d9ef">_</span> y: Int) -&gt; Int {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> result = x <span style="color:#f92672">+</span> y
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> result
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="void-return-type-and-parameters">Void Return Type and Parameters</h2>
<p>函数定义时<font color=LightSeaGreen>没有规定一定需要返回值</font>，如果一个函数定义时没有返回值，下面<code>3</code>种写法都是可行的，但是<font color=red>推荐使用第三种写法，即去掉<code>Void</code>或者<code>()</code></font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">say1</span>(<span style="color:#66d9ef">_</span> s: String) -&gt; Void {
</span></span><span style="display:flex;"><span>    debugPrint(s)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">say2</span>(<span style="color:#66d9ef">_</span> s: String) -&gt; () {
</span></span><span style="display:flex;"><span>    debugPrint(s)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">say3</span>(<span style="color:#66d9ef">_</span> s: String) {
</span></span><span style="display:flex;"><span>    debugPrint(s)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>若一个函数没有返回值，那么它的函数体中就不需要包含<code>return</code>语句。如果包含了<code>return</code>语句，那么它只能由<code>return</code>这个词单独组成，其目的<font color=Blue>纯粹是在当前位置上结束当前函数的执行</font>。</p>
<p>函数定义时也没有规定一定需要参数。<font color=LightSeaGreen>如果函数没有参数则参数列表为空，但此时也不能省略参数列表括号并且在函数调用时也不能省略括号</font>（实际上<font color=red>有一种特殊情况可以省略函数调用时的圆括号</font>）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">greet</span>() -&gt; String {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;howdy&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>因此，函数声明的时候可以同时没有参数和返回值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">greet1</span>() -&gt; Void {
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;howdy&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">greet2</span>() -&gt; () {
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;howdy&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">greet3</span>() {
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;howdy&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="function-signature">Function Signature</h2>
<p>如果函数声明的时候忽略外部和内部参数名，<font color=red>可以通过输入和输出类型来完全描述一个函数的特征</font>。为此，把参数类型写在参数列表括号里，后面是箭头运算符和输出类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>(Int, Int) -&gt; Int
</span></span></code></pre></div><p>上面是一个合法的表达式，表示接收两个<code>Int</code>类型参数并返回一个<code>Int</code>类型函数的签名。这个签名描述了<font color=Blue>所有具有这种顺序和数量的参数、类型、并返回这种类型的结果的函数</font>。<font color=LightSeaGreen>一个函数的签名实际上就是它的类型&mdash;函数的类型</font>。</p>
<p>一个函数的签名必须包括参数列表（不带内外参数名，只有参数类型）和返回类型，其中的参数列表和返回值都可以为空。一个不带参数和没有返回值的函数签名可以写成<code>()-&gt; Void</code>或<code>()-&gt;()</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">newTest</span>(completion: @escaping () -&gt; ()) {
</span></span><span style="display:flex;"><span>    completion()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">newTest2</span>(completion: @escaping () -&gt; Void) {
</span></span><span style="display:flex;"><span>    completion()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="external-parameter-names">External Parameter Names</h2>
<p>一个函数可以<font color=red>外化其参数名称，在调用函数的时候使用这个参数名称，这个名称被称为外部参数名或外部参数标签</font>。<font color=Blue>外部参数名称也是函数名称的一部分</font>，并且必须作为参数的标签出现在对该函数的调用中。外部参数标签有如下作用：</p>
<ul>
<li>
<p>它阐明了每个参数的目的，<font color=Blue>一个参数标签（外部参数）可以提供一个线索，说明该参数如何影响该函数</font>。</p>
</li>
<li>
<p>它将一个函数与另一个函数区分开来：<font color=red>两个在圆括号前具有相同名称和相同签名的函数，但具有不同的外部参数名称，是两个不同的函数</font>「这个有待考证😂」。</p>
</li>
<li>
<p>外部参数标签有助于<code>Swift</code>与<code>Objective-C</code>和<code>Cocoa</code>对接，在这两个地方，方法的参数几乎都有外部名称。</p>
</li>
</ul>
<p>外部参数名在<code>Swift</code>中非常常见，以至于有一条规则：<font color=Blue>默认情况下，所有参数名都会自动外部化，即使用内部名称作为其外部名称</font>。如果想改变这种默认行为，有两种方式：</p>
<ul>
<li>
<p>如果想要参数的外部名称和内部名称不同，需要<font color=LightSeaGreen>在内部名称前加一个外部名称并以空格分隔开</font>，调用的时候就可以使用此外部参数名。</p>
</li>
<li>
<p>如果需要去除一个参数的外部名称，则需要<font color=LightSeaGreen>在内部名称前加上下划线和一个空格</font>，此表示不使用外部参数，调用该函数时可以省略该参数名。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">echoString</span>(<span style="color:#66d9ef">_</span> s: String, times: Int) -&gt; String {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> result = <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">_</span> <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1.</span>..times {
</span></span><span style="display:flex;"><span>        result <span style="color:#f92672">+=</span> s
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> result
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面的函数中，第一个参数只有内部名称，第二个参数既有内部名称也有外部名称，并且他们的名称相同，即<code>times</code>。</p>
</li>
</ul>
<p>外部名称的存在**<font color=red>并不意味着调用可以使用与声明不同的参数顺序</font>**。下面的<code>echo(string:times:)</code>需要一个<code>String</code>参数和一个<code>Int</code>参数，必须按此顺序调用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">echo</span>(string s: String, times n: Int) -&gt; String {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> result = <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">_</span> <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1.</span>..n {
</span></span><span style="display:flex;"><span>        result <span style="color:#f92672">+=</span> s
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> result
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="overloading">Overloading</h2>
<p>在<code>Swift</code>中函数重载是合法的，这意味着两个函数具有相同的名字（<font color=Blue>包括相同的外部参数名称</font>），但有着不同的函数签名是可以共存的。需要注意的是，<font color=red>两个基本名称（函数名）相同但外部参数名称不同的函数并不构成重载，它们是两个名称不同的函数</font>「<font color=Blue>有些地方说这也是一种重载，个人看来也是合理的</font>」。</p>
<p>重载之所以有效是因为<code>Swift</code>进行严格的类型区分。<code>Swift</code>可以在函数声明和函数调用时把重载函数区分出来。因此，<code>Swift</code>清楚地知道<code>say(&quot;what&quot;)</code>和<code>say(1)</code>是不同的。</p>
<p>需要注意的是<font color=red>重载也适用于函数的返回类型</font>。两个具有相同名称和参数的函数可以有不同的返回类型。但调用时的上下文必须明确，即<font color=red>必须清楚调用者期望的返回类型</font>，否则编译器会报错。下面两个重载函数是可以并存的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">say</span>() -&gt; String {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;one&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">say</span>() -&gt; Int {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果在调用的时候直接使用<code>let result = say()</code>会发生编译错误，因为编译器还不知道要调用哪个函数。因此，<font color=LightSeaGreen>如果有返回类型重载的函数调用时必须明确指定返回类型</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> result: String = say()
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> test: Int = say()
</span></span></code></pre></div><p>上下文本身可能会消除歧义。假设有另一个没有重载的函数，它需要一个字符串参数，那么就可以直接使用<code>giveMeAString(say())</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">giveMeAString</span>(<span style="color:#66d9ef">_</span> s: String) {
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;thanks!&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>giveMeAString(say())
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> result = say() <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;two&#34;</span>
</span></span></code></pre></div><p>在<code>say() + &quot;two&quot;</code>中，因为只有字符串才能和字符串相加，所以此时<code>say()</code>只能返回字符串。也可以在函数调用时使用方法名和关键字<code>as</code>以及所需方法的签名来明确区分重载。这个语法看起来有点奇怪，因为**<font color=red>整个表达式必须用两对圆括号括起来，其中第一对圆括号表示类型转换，最后的一对圆括号表明这是一个函数调用</font>**:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> result = (say <span style="color:#66d9ef">as</span> () -&gt; String)()
</span></span></code></pre></div><h2 id="default-parameter-values">Default Parameter Values</h2>
<p>参数可以有默认值（缺省值），这意味着对于**<font color=red>有默认值的参数调用者可以完全省略该参数，不提供任何值</font>**。如果有默认值的参数在调用时省略该参数，表示使用默认值。如果要在函数声明中指定一个缺省值，只需在参数类型后面追加上<code>=和缺省值</code>即可：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">say</span>(<span style="color:#66d9ef">_</span> s: String, times: Int = <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">_</span> <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1</span> ... times {
</span></span><span style="display:flex;"><span>            debugPrint(s)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>实际上，上面的<code>say</code>相当于两个函数。其中一个只有一个未标记的参数<code>func say(_ s: String)</code>，并且在函数体中<code>times=1</code>；另一个既有未标记的参数也有一个<code>times</code>参数<code>func say(_ s: String, times: Int)</code>。</p>
<h2 id="variadic-parameters">Variadic Parameters</h2>
<p>在函数中同类型的参数个数是可变的，即调用者可以根据需要提供<font color=LightSeaGreen>该参数类型的多个值，用逗号隔开</font>。实际上，<font color=red>函数体将以数组形式接收这些值</font>。要在函数声明中表明一个参数是可变的，只需要在类型后面加上三个点：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sayStrings</span>(<span style="color:#66d9ef">_</span> arrayOfStrings: String ...) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> s <span style="color:#66d9ef">in</span> arrayOfStrings {
</span></span><span style="display:flex;"><span>        debugPrint(s)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>sayStrings(<span style="color:#e6db74">&#34;34&#34;</span>,<span style="color:#e6db74">&#34;456&#34;</span>,<span style="color:#e6db74">&#34;678&#34;</span>,<span style="color:#e6db74">&#34;9899&#34;</span>)
</span></span></code></pre></div><p>其它参数可以跟在可变参数后面，但它必须有一个外部标签来标识可变参数在调用中的结束位置。全局的<code>print</code>和<code>debugPrint</code>函数第一个参数实际上是可变的，所以可以一次打印多个值。<code>debugPrint</code>函数中还有一些默认参数，这些参数确定了输出的细节：默认的分隔符(输出多个值时的分隔符号)是一个空格，默认的终止符是一个换行符，可以在调用的时候改变其中之一或全部：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">print</span>(<span style="color:#66d9ef">_</span> items: Any..., separator: String = <span style="color:#e6db74">&#34; &#34;</span>, terminator: String = <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">debugPrint</span>(<span style="color:#66d9ef">_</span> items: Any..., separator: String = <span style="color:#e6db74">&#34; &#34;</span>, terminator: String = <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>)
</span></span></code></pre></div><p>在<code>Swift 5.3</code>之前，一个函数至多可以声明一个可变参数，<strong><font color=red>但从<code>Swift 5.4</code>开始这个限制被移除了,一个函数可以有多个可变参数</font></strong>。</font>下面的<code>testVariadicParameters</code>有<code>4</code>个可变参数。因为每个可变参数在函数内部都以数组的形式接受的，所以打印出来也是数组形式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">testVariadicParameters</span>(first: String..., second: String..., third: Int..., forth: [String]...) {
</span></span><span style="display:flex;"><span>    debugPrint(first)
</span></span><span style="display:flex;"><span>    debugPrint(second)
</span></span><span style="display:flex;"><span>    debugPrint(third)
</span></span><span style="display:flex;"><span>    debugPrint(forth)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>testVariadicParameters(first: <span style="color:#e6db74">&#34;1&#34;</span>, <span style="color:#e6db74">&#34;2&#34;</span>, <span style="color:#e6db74">&#34;3&#34;</span>, second: <span style="color:#e6db74">&#34;name&#34;</span>, <span style="color:#e6db74">&#34;This&#34;</span>, <span style="color:#e6db74">&#34;true&#34;</span>, third: <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">45</span>, <span style="color:#ae81ff">89</span>, forth: [<span style="color:#e6db74">&#34;TT&#34;</span>], [<span style="color:#e6db74">&#34;KK&#34;</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>[<span style="color:#e6db74">&#34;1&#34;</span>, <span style="color:#e6db74">&#34;2&#34;</span>, <span style="color:#e6db74">&#34;3&#34;</span>]
</span></span><span style="display:flex;"><span>[<span style="color:#e6db74">&#34;name&#34;</span>, <span style="color:#e6db74">&#34;This&#34;</span>, <span style="color:#e6db74">&#34;true&#34;</span>]
</span></span><span style="display:flex;"><span>[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">45</span>, <span style="color:#ae81ff">89</span>]
</span></span><span style="display:flex;"><span>[[<span style="color:#e6db74">&#34;TT&#34;</span>], [<span style="color:#e6db74">&#34;KK&#34;</span>]]
</span></span></code></pre></div><p>如果第2个可变参数没有和第一个可变参数相邻，那么可以不需要外部参数名：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sayStrings</span>(<span style="color:#66d9ef">_</span> array: String..., other: String, <span style="color:#66d9ef">_</span> array2: String...) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> s <span style="color:#66d9ef">in</span> array {
</span></span><span style="display:flex;"><span>        print(s)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    print(other)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> s <span style="color:#66d9ef">in</span> array2 {
</span></span><span style="display:flex;"><span>        print(s)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>sayStrings(<span style="color:#e6db74">&#34;Manny&#34;</span>, <span style="color:#e6db74">&#34;Moe&#34;</span>, <span style="color:#e6db74">&#34;Jack&#34;</span>, other: <span style="color:#e6db74">&#34;Matt&#34;</span>, <span style="color:#e6db74">&#34;Groucho&#34;</span>, <span style="color:#e6db74">&#34;Harpo&#34;</span>, <span style="color:#e6db74">&#34;Chico&#34;</span>)
</span></span></code></pre></div><p>不幸的是，<code>Swift</code>语言中存在一个漏洞：无法将数组转换为以逗号分隔的参数列表（类似于<code>Ruby</code>中的 <code>splatting</code>）。如果使用的是某种类型的数组，那么不能在需要该类型的可变参数的地方使用它。</p>
<h2 id="ignored-parameters">Ignored Parameters</h2>
<p>如同外部参数一样，如果**<font color=Blue>内部参数名称为下划线，则说明该内部参数名称会被忽略</font>**。即使省略了内部参数，函数调用者也必须提供实参，但它在函数体中没有内部名字。在下面的例子中，内部参数名字已经省略，也就是说无法使用这个参数，因此<font color=red>使用外部参数名会出现编译错误</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">say</span>(<span style="color:#66d9ef">_</span> s: String, test times: Int, loudly <span style="color:#66d9ef">_</span>: Bool) {
</span></span><span style="display:flex;"><span>    debugPrint(s)
</span></span><span style="display:flex;"><span>    debugPrint(times)
</span></span><span style="display:flex;"><span>    debugPrint(loudly) <span style="color:#75715e">// Cannot find &#39;loudly&#39; in scope</span>
</span></span><span style="display:flex;"><span>    debugPrint(test)   <span style="color:#75715e">// Cannot find &#39;test&#39; in scope</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>say(<span style="color:#e6db74">&#34;test&#34;</span>, test:<span style="color:#ae81ff">12</span>, loudly: <span style="color:#66d9ef">false</span>)
</span></span></code></pre></div><h2 id="modifiable-parameters">Modifiable Parameters</h2>
<p>在函数内的参数，本质上是一个局部变量。默认情况下（不声明为<code>inout</code>时）函数参数是用<code>let</code>隐式声明的常量。因为<font color=red>函数内的参数是常量，所以不能对它进行赋值操作</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">say</span>(<span style="color:#66d9ef">_</span> s: String, times: Int, loudly: Bool) {
</span></span><span style="display:flex;"><span>    loudly = <span style="color:#66d9ef">true</span> <span style="color:#75715e">// compile error </span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果在函数体内需要对参数进行赋值，你可能想到的一种方式是声明一个同名的变量，然后将参数的值赋值给刚定义的变量，这样就可以改变值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">say</span>(<span style="color:#66d9ef">_</span> s: String, times: Int, loudly: Bool) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> loudly = loudly 
</span></span><span style="display:flex;"><span>    loudly = <span style="color:#66d9ef">true</span> <span style="color:#75715e">// local var</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>但上面只是改变新定义的本地<code>loudly</code>变量，不会改变传进来入参<code>loudly</code>的值。如果想要改变函数传进来实参的值，需要按如下方式进行：</p>
<ul>
<li>
<p>参数的类型必须声明为<code>inout</code>，关键字<code>inout</code><font color=red>放在类型前面</font>。</p>
</li>
<li>
<p>调用函数时，<font color=red>传入的实参必须是用<code>var</code>声明的，而不能是<code>let</code>声明，因为只有用<code>var</code>声明的变量才能被改变</font>。</p>
</li>
<li>
<p>调用函数时，传入的<font color=red>必须是实参的地址</font>，而不是实参本身，即需要在变量名前加<code>&amp;</code>符号。</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">say</span>(<span style="color:#66d9ef">_</span> s: String, times: Int, loudly: <span style="color:#66d9ef">inout</span> Bool) {
</span></span><span style="display:flex;"><span>    loudly = <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> loudly = <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>say(<span style="color:#e6db74">&#34;test&#34;</span>, times: <span style="color:#ae81ff">1</span>, loudly: &amp;loudly)
</span></span></code></pre></div><p>当调用带有<code>inout</code>参数的函数时，始终设置其地址作为参数传递给该参数的变量，即使该函数没有对该参数进行任何更改。</p>
<p>有一种常见的情况是，在函数体中可以修改参数的值而不必把它声明为<code>inout</code>。当<font color=LightSeaGreen>参数是一个类的实例时，可以直接修改实例的值，这是类的一个特殊功能，与其他两种对象类型（枚举和结构体）不同</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name = <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">changeName</span>(of d: Dog, to newName: String) {
</span></span><span style="display:flex;"><span>    d.name = newName
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> d = Dog()
</span></span><span style="display:flex;"><span>d.name = <span style="color:#e6db74">&#34;Fido&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>debugPrint(d.name) <span style="color:#75715e">// &#34;Fido&#34;</span>
</span></span><span style="display:flex;"><span>changeName(of: d, to: <span style="color:#e6db74">&#34;Rover&#34;</span>)
</span></span><span style="display:flex;"><span>debugPrint(d.name) <span style="color:#75715e">// &#34;Rover&#34;</span>
</span></span></code></pre></div><p>在上面的例子中<code>changeName</code>函数的第一个参数并没有声明为<code>inout</code>，但在函数体中确实改变了<code>Dog</code>的实例<code>d</code>的属性。虽然传入的实参是用<code>let</code>声明的，但也能改变类实例的属性<code>name</code>，这说明**<font color=red>类的实例本身是可变的</font>**。</p>
<p>从技术上讲，我们说<font color=red>类是引用类型，而其他类型的对象则是值类型</font>。当把一个结构体的实例作为参数传递给一个函数时，<font color=LightSeaGreen>实际上是得到了该结构体实例的一个副本</font>。但是，当把一个类的实例作为参数传递给一个函数时，传递的是该类实例本身的引用。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name = <span style="color:#e6db74">&#34;A&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">B</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name = <span style="color:#e6db74">&#34;B&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> a: A = A() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">didSet</span> {
</span></span><span style="display:flex;"><span>        debugPrint(oldValue)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> b: B = B() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">didSet</span> {
</span></span><span style="display:flex;"><span>        debugPrint(oldValue)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>a.name = <span style="color:#e6db74">&#34;aaa&#34;</span>
</span></span><span style="display:flex;"><span>b.name = <span style="color:#e6db74">&#34;bbb&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Command.B(name: &#34;B&#34;)</span>
</span></span></code></pre></div><p>上面代码改变类的实例<code>a</code>的<code>name</code>属性时<code>didSet</code>没有调用，而改变结构体的实例<code>b</code>的属性<code>name</code>时，<code>didSet</code>调用了，说明<font color=LightSeaGreen>生成了一个结构体实例副本</font>。</p>
<h2 id="calling-objective-c-with-modifiable-parameters">Calling Objective-C with Modifiable Parameters</h2>
<p>当使用<code>Cocoa</code>时，可能会遇到该模式的变化。<code>Cocoa API</code>是用<code>C</code>和<code>Objective-C</code>编写的，因此可能会看到一些神秘的类型，例如<code>UnsafeMutablePointer</code>，而不是<code>Swift</code>中的<code>inout</code>。然而，作为调用者的角度来看，这是同一件事：你将准备一个<code>var</code>变量并传递其地址。</p>
<p>例如，<code>UIColor</code>的<code>RGBA</code>成分的问题，它由四个成分：红色、绿色、蓝色和<code>alpha</code>值。给定<code>UIColor</code>的函数返回该颜色的成分，需要一次返回四个值——这是<code>Objective-C</code>无法做到的。<code>UIColor</code>方法<code>getRed(_:green:blue:alpha:)</code>返回一个布尔值，以说明是否提取成功：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">getRed</span>(<span style="color:#66d9ef">_</span> red: UnsafeMutablePointer&lt;CGFloat&gt;, green: UnsafeMutablePointer&lt;CGFloat&gt;, blue: UnsafeMutablePointer&lt;CGFloat&gt;, alpha: UnsafeMutablePointer&lt;CGFloat&gt;) -&gt; Bool
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> c = UIColor.purple 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> r : CGFloat = <span style="color:#ae81ff">0</span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> g : CGFloat = <span style="color:#ae81ff">0</span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> b : CGFloat = <span style="color:#ae81ff">0</span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> a : CGFloat = <span style="color:#ae81ff">0</span> 
</span></span><span style="display:flex;"><span>c.getRed(&amp;r, green: &amp;g, blue: &amp;b, alpha: &amp;a) <span style="color:#75715e">// now r, g, b, a are 0.5, 0.0, 0.5, 1.0</span>
</span></span></code></pre></div><h2 id="called-by-objective-c-with-modifiable-parameters">Called by Objective-C with Modifiable Parameters</h2>
<p>有时<code>Cocoa</code>想要使用<code>UnsafeMutablePointer</code>参数调用<code>Swift</code>函数，用到的技术是赋值<code>UnsafeMutablePointer</code>的指针属性。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">popoverPresentationController</span>(<span style="color:#66d9ef">_</span> popoverPresentationController: UIPopoverPresentationController, willRepositionPopoverTo rect: UnsafeMutablePointer&lt;CGRect&gt;, <span style="color:#66d9ef">in</span> view: AutoreleasingUnsafeMutablePointer&lt;UIView&gt;) {
</span></span><span style="display:flex;"><span>    view.pointee = <span style="color:#66d9ef">self</span>.button2
</span></span><span style="display:flex;"><span>    rect.pointee = <span style="color:#66d9ef">self</span>.button2.bounds
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="function-in-function">Function in Function</h2>
<p>函数可以在任何地方声明，在<font color=Blue>函数体中声明函数也是合法的</font>。声明在函数内的函数称为本地函数（内部函数），它<font color=LightSeaGreen>可以被同一范围内的后续（本地函数声明后）代码所调用，但在其它地方完全不可见</font>。</p>
<p>对于那些唯一目的是协助另一个函数的函数来说，内部函数是一种优雅的架构。如果只有函数<code>A</code>需要调用函数<code>B</code>，那么函数<code>B</code>还不如打包在函数<code>A</code>里面。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">checkPair</span>(<span style="color:#66d9ef">_</span> p1: Piece, and p2: Piece) -&gt; Path? {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">addPathIfValid</span>(<span style="color:#66d9ef">_</span> midpt1: Point, <span style="color:#66d9ef">_</span> midpt2: Point) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>    } 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> y <span style="color:#66d9ef">in</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> ... _yct {
</span></span><span style="display:flex;"><span>        addPathIfValid((p1.x, y), (p2.x, y))
</span></span><span style="display:flex;"><span>    } 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> x <span style="color:#66d9ef">in</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> ... _xct {
</span></span><span style="display:flex;"><span>        addPathIfValid((x, p1.y), (x, p2.y))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>     <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>内部函数<font color=red>实际上是一个局部变量，其类型是函数类型</font>。因此，一个**<font color=LightSeaGreen>局部函数不能与同一作用域中的局部变量同名，并且两个局部函数也不能在同一作用域中同名</font>**。此限制已经被移除，两个同名的内部函数，但签名不同时可以共存：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test1</span>() {
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;test1&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test1</span>(x: Int) {
</span></span><span style="display:flex;"><span>    debugPrint(x)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="recursion">Recursion</h2>
<p>在函数中调用自己的函数被称为递归函数。递归可能会产生无限循环，所以需要在递归函数中<font color=red>写出正确的终止逻辑，防止无限递归下去</font>，导致内存占用过高，手机发烫：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">countDownFrom</span>(<span style="color:#66d9ef">_</span> ix: Int) {
</span></span><span style="display:flex;"><span>    debugPrint(ix)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ix <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> { <span style="color:#75715e">// stopper</span>
</span></span><span style="display:flex;"><span>        countDownFrom(ix <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#75715e">// recurse</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>countDownFrom(<span style="color:#ae81ff">5</span>) <span style="color:#75715e">// 5, 4, 3, 2, 1, 0</span>
</span></span></code></pre></div><h2 id="function-as-value">Function as Value</h2>
<p>在<code>Swift</code>中函数是一等公民，<font color=red>这意味着任何使用值的地方都可以使用函数</font>。即一个函数可以被赋值给一个变量，能够将一个函数作为另一个函数调用的参数被传递，也可以将其作为另一个函数的返回值。</p>
<p><code>Swift</code>是强类型的语言，当<font color=LightSeaGreen>函数作为值传递时，必须类型相匹配，实际上函数的签名就是它的类型</font>。为了使函数类型更简洁，可以使用<code>typealias</code>给一个函数类型起个别名，这个名字可以是描述性的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#75715e">// 函数类型别名</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typealias</span> VoidVoidFunction = () -&gt; Void
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">doTest</span>(test: VoidVoidFunction) {
</span></span><span style="display:flex;"><span>    test()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>doTest {
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;doTest 1&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>doTest() {
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;doTest 2&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>使用一个函数作为值的主要目的是**<font color=red>可以在尚不确定函数具体是什么的情况下调用该函数</font>**。下面示例代码是一个极简单的例子，只是为了展示函数作为值使用时的结构和语法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">doThis</span>(<span style="color:#66d9ef">_</span> f: () -&gt; Void) {
</span></span><span style="display:flex;"><span>    f()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面<code>doThis</code>函数接受一个参数，未返回任何值。它通过<code>f()</code>来调用它接受的函数参数。所以<code>doThis</code>仅是一个调用另一个函数的简单函数。<font color=LightSeaGreen>但它这样做时事先并不知道要调用什么函数，这就是函数作为一等公民的力量</font>。在声明了<code>doThis</code>这个函数后，需要把一个函数作为参数传给它才能调用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">typealias</span> VoidVoidFunction = () -&gt; Void
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">dothis</span>(<span style="color:#66d9ef">_</span> f: VoidVoidFunction) {
</span></span><span style="display:flex;"><span>    f()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">doThis</span>(<span style="color:#66d9ef">_</span> f: () -&gt; Void) {
</span></span><span style="display:flex;"><span>    f()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">whatToDo</span>() {
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;I did it&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>doThis(whatToDo) <span style="color:#75715e">//I did it</span>
</span></span></code></pre></div><p>为了使函数类型更清晰，可以利用<code>Swift</code>的<font color=red>类型别名特性为函数类型命名</font>。该名称可以是描述性的，并且避免了可能令人困惑的箭头运算符：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">typealias</span> VoidVoidFunction = () -&gt; ()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">dothis</span>(<span style="color:#66d9ef">_</span> f: VoidVoidFunction) {
</span></span><span style="display:flex;"><span>    f()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="anonymous-functions">Anonymous Functions</h2>
<p>下面代码中，声明函数<code>whatToAnimate</code>和<code>whatToDoLater</code>只是为了调用<code>UIView.animate</code>时作为参数传递。其实并不一定需要<code>whatToAnimate</code>和<code>whatToDoLater</code>这两个函数名字，因为它们只是在代码最后一行使用了，之后便没有再使用了：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">whatToAnimate</span>() { 
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;animations&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">whatToDoLater</span>(finished: Bool) {
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;finished: </span><span style="color:#e6db74">\(</span>finished<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>UIView.animate(withDuration: <span style="color:#ae81ff">0.4</span>, animations: whatToAnimate, completion: whatToDoLater)
</span></span><span style="display:flex;"><span><span style="color:#75715e">//open class func animate(withDuration duration: TimeInterval, animations: @escaping () -&gt; Void, completion: ((Bool) -&gt; Void)? = nil)</span>
</span></span></code></pre></div><p>在调用<code>UIView.animate(withDuration:animations:completion:)</code>方法时如果只传递函数体，不专门声明一个带名字的函数，将会更简洁。</p>
<p>一个*<font color=red>无名的函数体被称为匿名函数</font>*，这在<code>Swift</code>中匿名函数十分常见。要形成一个匿名函数，需要做以下两件事：</p>
<ul>
<li>首先，创建一个函数体，即一对花括号(<font color=red>此时无需加函数声明，即不使用<code>func xxx</code></font>)。</li>
<li>接着，如果有必要，将函数的参数列表和返回类型作为花括号内的第一件事来表达，然后是关键字<code>in</code>：</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>{ () -&gt; () <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;animations&#34;</span>)
</span></span><span style="display:flex;"><span>} 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>{ (finished: Bool) -&gt; () <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;finished: </span><span style="color:#e6db74">\(</span>finished<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="using-anonymous-functions-inline">Using Anonymous Functions Inline</h3>
<p>知道怎么创建匿名函数，就可以使用它们了。在<code>UIView.animate</code>调用时可以创建匿名函数，并作为参数传递：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>UIView.animate(withDuration: <span style="color:#ae81ff">0.4</span>,
</span></span><span style="display:flex;"><span>        animations: { () -&gt; () <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">self</span>.myButton.frame.origin.y <span style="color:#f92672">+=</span> <span style="color:#ae81ff">20</span>
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        completion: {
</span></span><span style="display:flex;"><span>            (finished: Bool) -&gt; () <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">&#34;finished: </span><span style="color:#e6db74">\(</span>finished<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>)
</span></span></code></pre></div><p>对于<code>imageOfSize</code>函数，也可以使用匿名函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">drawing</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> p = UIBezierPath(roundedRect: CGRect(x: <span style="color:#ae81ff">0</span>, y: <span style="color:#ae81ff">0</span>, width: <span style="color:#ae81ff">45</span>, height: <span style="color:#ae81ff">20</span>), cornerRadius: <span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>    p.stroke()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> image = imageOfSize(CGSize(width: <span style="color:#ae81ff">45</span>, height: <span style="color:#ae81ff">20</span>), drawing)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> image = imageOfSize(CGSize(width: <span style="color:#ae81ff">45</span>, height: <span style="color:#ae81ff">20</span>), { () -&gt; () <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> p = UIBezierPath(roundedRect: CGRect(x: <span style="color:#ae81ff">0</span>, y: <span style="color:#ae81ff">0</span>, width: <span style="color:#ae81ff">45</span>, height: <span style="color:#ae81ff">20</span>), cornerRadius: <span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>    p.stroke()
</span></span><span style="display:flex;"><span>})
</span></span></code></pre></div><h3 id="anonymous-function-abbreviated-syntax">Anonymous Function Abbreviated Syntax</h3>
<p>匿名函数在<code>Swift</code>中很常见，也很重要，所以<code>Swift</code>提供了一些创建匿名函数的便捷方式。</p>
<h4 id="省略返回值类型和箭头操作符">省略返回值类型和箭头操作符</h4>
<p>如果<font color=LightSeaGreen>编译器已经知道匿名函数的返回值，则可以省略箭头操作符和返回值类型</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>UIView.animate(withDuration: <span style="color:#ae81ff">0.4</span>, animations: { () <span style="color:#66d9ef">in</span>  <span style="color:#75715e">// 省略了箭头操作符和返回值类型Void</span>
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;animations&#34;</span>)
</span></span><span style="display:flex;"><span>}, completion: { (finished: Bool) <span style="color:#66d9ef">in</span>  <span style="color:#75715e">// 省略了箭头操作符和返回值类型</span>
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;finished: </span><span style="color:#e6db74">\(</span>finished<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">testName</span>(count: Int, test: (Int) -&gt; String) {
</span></span><span style="display:flex;"><span>    debugPrint(test(count))
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>testName(count: <span style="color:#ae81ff">3</span>) { (count: Int) <span style="color:#66d9ef">in</span> <span style="color:#75715e">// 省略了箭头操作符和返回值类型String</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;test:</span><span style="color:#e6db74">\(</span>count<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>debugPrint({ (count: Int) <span style="color:#66d9ef">in</span> <span style="color:#75715e">// 省略了箭头操作符和返回值类型String，这里使用了define&amp;call</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">\(</span>count<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>}(<span style="color:#ae81ff">13</span>))  <span style="color:#75715e">// 13</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">doThis</span>(completion: @escaping () -&gt; String) {
</span></span><span style="display:flex;"><span>    completion()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>doThis() { () <span style="color:#66d9ef">in</span> <span style="color:#75715e">// 省略了箭头操作符和返回值类型String</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;doThis&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>编译器有时可能无法准确推断出匿名函数的返回类型，此时会出现编译错误。如果出现这种情况，就不能使用这种省略箭头操作符和返回值的便捷方式，而应该提供一个具有箭头和返回值类型的<code>in</code>表达式。</p>
<h4 id="无参数时省略in关键字">无参数时省略in关键字</h4>
<p>如果一个<font color=red>匿名函数没有参数，并且箭头操作符和返回类型（是一起的）可以省略</font>，那么关键字<code>in</code>也可以省略。下面代码中传递给<code>animations</code>的匿名函数省略了返回类型和<code>in</code>关键字:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>UIView.animate(withDuration: <span style="color:#ae81ff">0.4</span>, animations: {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 没有参数省略了箭头操作符和返回值类型以及in关键字</span>
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;animations&#34;</span>)
</span></span><span style="display:flex;"><span>}, completion: { (finished: Bool) <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;finished: </span><span style="color:#e6db74">\(</span>finished<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">doThis</span>(completion: @escaping () -&gt; String) {
</span></span><span style="display:flex;"><span>    completion()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>doThis() { () <span style="color:#75715e">// 无参数，有返回值 省略了关键关键字in</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;doThis&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="省略参数类型">省略参数类型</h4>
<p>如果匿名函数有参数，并且*<font color=LightSeaGreen>编译器已经知道参数的类型，则匿名函数中参数的类型可以省略</font>*。下面代码中传递给<code>completion</code>的匿名函数省略了参数类型，即<code>Bool</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>UIView.animate(withDuration: <span style="color:#ae81ff">0.4</span>, animations: {
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;animations&#34;</span>)
</span></span><span style="display:flex;"><span>}, completion: { (finished) <span style="color:#66d9ef">in</span>  <span style="color:#75715e">// 省略了参数类型</span>
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;finished: </span><span style="color:#e6db74">\(</span>finished<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">testName</span>(count: Int, test: (Int) -&gt; String) {
</span></span><span style="display:flex;"><span>    debugPrint(test(count))
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>testName(count: <span style="color:#ae81ff">2</span>) { (count)  <span style="color:#66d9ef">in</span> <span style="color:#75715e">// 省略了参数类型和返回值类型</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;test:</span><span style="color:#e6db74">\(</span>count<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>debugPrint({ (count) <span style="color:#66d9ef">in</span> <span style="color:#75715e">// 省略了参数类型和返回值类型</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">\(</span>count<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>}(<span style="color:#ae81ff">13</span>))  <span style="color:#75715e">// 13</span>
</span></span></code></pre></div><h4 id="省略参数列表圆括号">省略参数列表圆括号</h4>
<p>如果*<font color=LightSeaGreen>匿名函数的参数类型可以省略，那么参数列表的圆括号也可以省略</font>*。下面代码中传递给<code>completion</code>的匿名函数，既省略了参数类型也省略了圆括号：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>UIView.animate(withDuration: <span style="color:#ae81ff">0.4</span>, animations: {
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;animations&#34;</span>)
</span></span><span style="display:flex;"><span>}, completion: { finished <span style="color:#66d9ef">in</span> <span style="color:#75715e">// 省略了参数类型和参数列表圆括号以及返回值类型</span>
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;finished: </span><span style="color:#e6db74">\(</span>finished<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">testName</span>(count: Int, test: (Int) -&gt; String) {
</span></span><span style="display:flex;"><span>    debugPrint(test(count))
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>testName(count: <span style="color:#ae81ff">2</span>) { count  <span style="color:#66d9ef">in</span> <span style="color:#75715e">// 省略了参数类型和参数列表圆括号以及返回值类型</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;test:</span><span style="color:#e6db74">\(</span>count<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>debugPrint({ count <span style="color:#66d9ef">in</span> <span style="color:#75715e">// 省略了参数类型和参数列表圆括号以及返回值类型</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">\(</span>count<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>}(<span style="color:#ae81ff">13</span>))  <span style="color:#75715e">// 13</span>
</span></span></code></pre></div><h4 id="有参数列表省略in表达式">有参数列表省略in表达式</h4>
<p>如果<font color=red>匿名函数的返回类型可以省略，并且编译器已经知道参数的类型</font>，也可以省略<code>in</code>表达式。在匿名函数体中可以直接引用参数，<code>$0</code>表示第一个参数，<code>$1</code>表示第二个参数，依此类推：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>UIView.animate(withDuration: <span style="color:#ae81ff">0.4</span>, animations: {
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;animations&#34;</span>)
</span></span><span style="display:flex;"><span>}, completion: {
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;finished: </span><span style="color:#e6db74">\(</span>$0<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">testName</span>(count: Int, test: (Int) -&gt; String) {
</span></span><span style="display:flex;"><span>    debugPrint(test(count))
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>testName(count: <span style="color:#ae81ff">2</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;test:</span><span style="color:#e6db74">\(</span>$0<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>debugPrint({ 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">\(</span>$0<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>}(<span style="color:#ae81ff">13</span>))  <span style="color:#75715e">// 13</span>
</span></span></code></pre></div><h4 id="省略参数名">省略参数名</h4>
<p>如果匿名函数不需要使用参数，则可以在<code>in</code>表达式的参数列表中*<font color=Blue>用下划线代替其名称，表示在匿名函数中不使用该参数</font>*。下面代码中，传递给<code>completion</code>的匿名函数，使用下划线代替了参数名：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>UIView.animate(withDuration: <span style="color:#ae81ff">0.4</span>, animations: {
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;animations&#34;</span>)
</span></span><span style="display:flex;"><span>}, completion: { <span style="color:#66d9ef">_</span> <span style="color:#66d9ef">in</span> <span style="color:#75715e">// *</span>
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;finished!&#34;</span>)
</span></span><span style="display:flex;"><span>})
</span></span></code></pre></div><p>如果一个匿名函数有参数，可以省略<code>in</code>表达式，使用<code>$0,$1...</code>来使用参数。或者可以保留<code>in</code>表达式，给参数命名，或者用下划线忽略它们。但<font color=red>不能省略<code>in</code>表达式而不使用参数的魔法名称</font><code>$0,$1</code>，一旦这样做了，代码将无法通过编译。</p>
<h4 id="省略函数标签">省略函数标签</h4>
<p>如果<font color=LightSeaGreen>匿名函数是函数调用中传递的最后一个参数</font>。可以*<font color=red>在最后一个参数之前用右括号来关闭函数调用，然后只放匿名函数体，不放任何标签</font>*，这就是尾部闭包语法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>UIView.animate(withDuration: <span style="color:#ae81ff">0.4</span>, animations: {
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;animations&#34;</span>)
</span></span><span style="display:flex;"><span>}) { <span style="color:#66d9ef">_</span> <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;finished!&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在上面代码中，因为<code>completion:</code>是方法中的最后一个参数，所以<font color=Blue>可以在调用的括号外传递匿名函数</font>，使用不带标签的尾部闭包语法。但是，实际上<code>animate</code>函数中接受两个函数参数，<code>animations</code>也是匿名函数，但它依然在括号里。</p>
<p>从<code>Swift 5.3</code>开始，多个匿名函数参数可以使用尾部闭包语法。当这样做时，<font color=LightSeaGreen>第一个匿名函数不需要标签，但其余的函数都需要它们的标签</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>UIView.animate(withDuration: <span style="color:#ae81ff">0.4</span>) {
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;animations&#34;</span>)
</span></span><span style="display:flex;"><span>} completion: { <span style="color:#66d9ef">_</span> <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;finished!&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="省略函数调用圆括号">省略函数调用圆括号</h4>
<p>如果使用了尾部闭包，并且如果所调用的函数<font color=red>除了传递给它的函数之外没有其它函数参数</font>，可以从调用中省略圆括号。这是<font color=red>唯一可以从函数调用中省略圆括号的情况</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#75715e">// 只有一个参数，该参数是函数类型</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">doThis</span>(<span style="color:#66d9ef">_</span> f: () -&gt; Void) {
</span></span><span style="display:flex;"><span>    f()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>doThis { <span style="color:#75715e">// 省略调用圆括号</span>
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;Howdy&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 有其它非函数类型参数，并最后一个参数是函数类型</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">doThis</span>(name: String, <span style="color:#66d9ef">_</span> f: () -&gt; Void) {
</span></span><span style="display:flex;"><span>    f()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>doThis(name: <span style="color:#e6db74">&#34;trr&#34;</span>) { <span style="color:#75715e">// 省略调用圆括号</span>
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;Howdy&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="省略return关键字">省略return关键字</h4>
<p>如果匿名函数体<font color=Blue>恰好只由一个语句组成</font>，并且该语句包含返回一个带有关键字<code>return</code>的值，实际上关键字<code>return</code>是可以省略的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">greeting</span>() -&gt; String {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;Howdy&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">performAndPrint</span>(<span style="color:#66d9ef">_</span> f: () -&gt; String) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> s = f()
</span></span><span style="display:flex;"><span>    print(s)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>performAndPrint {
</span></span><span style="display:flex;"><span>    greeting() <span style="color:#75715e">// meaning: return greeting()</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在编写匿名函数时，会经常发现已经利用了所有允许的省略写法。此外，有时会通过将整个匿名函数与函数调用放在一行中来缩短代码行数。因此，涉及匿名函数的<code>Swift</code>代码可以非常紧凑：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> arr = [<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">8</span>]
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> arr2 = arr.map {$0<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>}
</span></span></code></pre></div><h2 id="define-and-call">Define and Call</h2>
<p>在<code>Swift</code>中，常见的模式是<font color=red>定义一个匿名函数并调用它</font>。如下所示，花括号定义了一个匿名函数体，<font color=LightSeaGreen>圆括号表示调用该匿名函数</font>，此结构被称为定义和调用（<code>define-and-call</code>）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#75715e">// ... code goes here</span>
</span></span><span style="display:flex;"><span>}()
</span></span></code></pre></div><p>使用<code>define-and-call</code>，可以在真正需要的时候采取行动，而不是事先做一系列准备工作。例如，有一个常见场景，创建和配置<code>NSMutableParagraphStyle</code>实例，然后将它作为参数调用<code>NSMutableAttributedString</code>的实例方法<code>addAttribute(_:value:range:)</code>，如下所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> para = NSMutableParagraphStyle()
</span></span><span style="display:flex;"><span>para.headIndent = <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>para.firstLineHeadIndent = <span style="color:#ae81ff">10</span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e">// ... more configuration of para ...</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// content is an NSMutableAttributedString</span>
</span></span><span style="display:flex;"><span>content.addAttribute(
</span></span><span style="display:flex;"><span>        .paragraphStyle,
</span></span><span style="display:flex;"><span>        value: para,
</span></span><span style="display:flex;"><span>        range: NSRange(location: <span style="color:#ae81ff">0</span>, length: <span style="color:#ae81ff">1</span>))
</span></span></code></pre></div><p>上面的代码看起来很丑。实际上，<code>para</code>是在调用<code>addAttribute(_:value:range:)</code>时将它作为<code>value:</code>参数传递进去的，因此在<font color=LightSeaGreen>调用时再创建和配置会更好</font>。这看起来像是需要使用匿名函数的场景，除了<code>value:</code>参数不是一个函数，而是一个<code>NSMutableParagraphStyle</code>对象。</p>
<p>可以使用<code>define-and-call</code>解决上面问题，即使用一个产生<code>NSMutableParagraphStyle</code>对象的匿名函数，并立即调用它传递作为<code>value</code>的实参：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> content = NSMutableAttributedString()
</span></span><span style="display:flex;"><span>content.addAttribute(.paragraphStyle, value: {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> para = NSMutableParagraphStyle()
</span></span><span style="display:flex;"><span>    para.headIndent = <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>    para.firstLineHeadIndent = <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ... more configuration of para ... return para</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> para
</span></span><span style="display:flex;"><span>}(), range: NSRange(location: <span style="color:#ae81ff">0</span>, length: content.length))
</span></span></code></pre></div><h2 id="closures">Closures</h2>
<p><em>Just like functions, <a href="https://www.swiftbysundell.com/basics/closures/">closures</a> enable us to define a group of code statements that can be called as one unit, which can both accept input and produce output. The difference, however, is that closures can be defined inline — right at the point where we want to use them —which is incredibly useful in a number of different situations.</em></p>
<p><em>Closures can both be stored as properties and local variables, and can also be passed as arguments to functions (or other closures).</em></p>
<p><code>Swift</code>的<font color=LightSeaGreen>函数都是闭包</font>，这意味着在**<font color=red>函数内可以捕获在函数体外的外部变量</font>**。下面代码中，函数<code>bark</code>可以<font color=LightSeaGreen>看到在其函数体外声明的变量和函数</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> whatThisDogSays = <span style="color:#e6db74">&#34;woof&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        print(<span style="color:#66d9ef">self</span>.whatThisDogSays)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>对于上面的<code>bark</code>函数来说，<code>whatThisDogSays</code>是一个外部变量，因为它是在<code>bark</code>函数体之外声明的，但*<font color=red>它的作用域仍在<code>bark</code>函数体内</font>*，因此<code>bark</code>函数内的代码可以看到它。</li>
<li>函数体内的代码引用了外部变量<code>whatThisDogSays</code>。</li>
</ul>
<p>函数<code>bark</code>是可以作为值传递的。也就是说，<font color=LightSeaGreen>它可以从一种环境传递到另一种环境</font>。当这种事情发生时，对于<code>whatThisDogSays</code>的引用会发生什么？先来看一下下面代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">doThis</span>(<span style="color:#66d9ef">_</span> f: () -&gt; ()) {
</span></span><span style="display:flex;"><span>    f()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> d = Dog()
</span></span><span style="display:flex;"><span>d.whatThisDogSays = <span style="color:#e6db74">&#34;arf&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> barkFunction = d.bark
</span></span><span style="display:flex;"><span>doThis(barkFunction) <span style="color:#75715e">// 打印结果arf</span>
</span></span></code></pre></div><p>上面打印的结果看起来是正常的，但是我们没有直接调用<code>d.dark</code>，而是创建了一个<code>Dog</code>的实例，并把它的<code>bark</code>方法作为值传<code>doThis</code>函数作为参数，在<code>doThis</code>中，方法<code>bark</code>被调用。</p>
<p><code>whatThisDogSays</code>是<code>Dog</code>的实例属性，在函数<code>doThis</code>中并没有<code>whatThisDogSays</code>引用。事实上，在<code>doThis</code>函数中也没有<code>Dog</code>的实例，但<code>f()</code>调用仍然正常。<font color=red>函数<code>d.bark</code>，当它被传递的时候，显然是把变量<code>whatThisDogSays</code>一起传递的</font>。</p>
<p>更进一步，改变上面这个例子，把设置<code>d.whatThisDogSays</code>的那一行移到把<code>d.bark</code>赋值给变量<code>barkFunction</code>之后，如下所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">doThis</span>(<span style="color:#66d9ef">_</span> f: () -&gt; ()) {
</span></span><span style="display:flex;"><span>    f()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> d = Dog()
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> barkFunction = d.bark
</span></span><span style="display:flex;"><span>doThis(barkFunction) <span style="color:#75715e">// woof</span>
</span></span><span style="display:flex;"><span>d.whatThisDogSays = <span style="color:#e6db74">&#34;arf&#34;</span>
</span></span><span style="display:flex;"><span>doThis(barkFunction) <span style="color:#75715e">// arf</span>
</span></span></code></pre></div><p>当创建了<code>Dog</code>的实例<code>d</code>和变量<code>barkFunction</code>，更改<code>d</code>的属性也会改变<code>barkFunction</code>的输出。显然当<code>d.bark</code>赋值给<code>barkFunction</code>后，<font color=LightSeaGreen>实例<code>d</code>和<code>barkFunction</code>都持有对同一个<code>Dog</code>实例的引用</font>。</p>
<p>这是因为*<font color=red>赋值给<code>barkFunction</code>的<code>d.bark</code>引用了<code>self</code>，也就是<code>Dog</code>实例</font>*。当说函数是一个闭包并且捕获在函数体中引用的外部变量时，就是上面的意思。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">delay</span>(by seconds: TimeInterval,
</span></span><span style="display:flex;"><span>           on queue: DispatchQueue = .main,
</span></span><span style="display:flex;"><span>           closure: @escaping () -&gt; Void) {
</span></span><span style="display:flex;"><span>    queue.asyncAfter(
</span></span><span style="display:flex;"><span>        deadline: .now() <span style="color:#f92672">+</span> seconds,
</span></span><span style="display:flex;"><span>        execute: closure
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="how-closures-improve-code">How Closures Improve Code</h2>
<p>可以<font color=red>使用函数是闭包这一事实</font>让代码变得更通用。为了说明函数是闭包，使用之前的一个示例，它接受绘图指令并执行以生成图像：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">imageOfSize</span>(<span style="color:#66d9ef">_</span> size: CGSize, <span style="color:#66d9ef">_</span> whatToDraw: () -&gt; ()) -&gt; UIImage {
</span></span><span style="display:flex;"><span>    UIGraphicsBeginImageContextWithOptions(size, <span style="color:#66d9ef">false</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    whatToDraw()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> result = UIGraphicsGetImageFromCurrentImageContext()<span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span>    UIGraphicsEndImageContext()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> result
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>以尾闭包的方式调用上面的函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> image = imageOfSize(CGSize(width: <span style="color:#ae81ff">45</span>, height: <span style="color:#ae81ff">20</span>)) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> p = UIBezierPath(roundedRect: CGRect(x: <span style="color:#ae81ff">0</span>, y: <span style="color:#ae81ff">0</span>, width: <span style="color:#ae81ff">45</span>, height: <span style="color:#ae81ff">20</span>), cornerRadius: <span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>    p.stroke()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面代码调用创建了给定大小的并包含指定大小圆角的图片。但上面包含了重复代码，即<code>CGSize(width:45, height:20)</code>重复了两次。为了防止重复，可以在一开始就把<code>size</code>放到一个变量中：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> sz = CGSize(width: <span style="color:#ae81ff">45</span>, height: <span style="color:#ae81ff">20</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> image = imageOfSize(sz) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> p = UIBezierPath(roundedRect: CGRect(origin: CGPoint.zero, size: sz), cornerRadius: <span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>    p.stroke()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在上面的代码中，常量<code>sz</code>是<font color=Blue>在比匿名函数更高层次声明的，因此在匿名函数中能够看见和引用它</font>。但需要注意的是，匿名函数只是一个函数体，如果<code>imageOfSize</code>不调用，匿名函数就不会被执行。</p>
<p>当在函数体内的表达式<code>CGRect(origin:CGPoint.zero, size:sz)</code>中引用<code>sz</code>时，因为函数体是一个闭包，现在捕获了它的值。</p>
<p>当函数<code>imageOfSize</code>调用<code>whatToDraw</code>时，<code>whatToDraw</code>变成了一个函数，函数体内引用了变量<code>sz</code>，这是没有问题，尽管在<code>imageOfSize</code>附近没有<code>sz</code>。</p>
<p>再进一步，到目前为止我们一直在硬编码所需圆角矩形的大小。不过，我们经常要创建各种大小的圆角矩形图像。那么将上面代码打包成一个函数是有意义的，其中<code>sz</code>不是一个固定值，而是一个入参，然后该函数将返回一个图像：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">makeRoundedRectangle</span>(<span style="color:#66d9ef">_</span> sz: CGSize) -&gt; UIImage {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> image = imageOfSize(sz) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> p = UIBezierPath(roundedRect: CGRect(origin: CGPoint.zero, size: sz), cornerRadius: <span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>        p.stroke()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> image
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在上面的<code>makeRoundedRectangle</code>函数中，参数<code>sz</code>不再是硬编码值（固定值），事先我们并不知道它将会是什么。当调用<code>makeRoundedRectangle</code>时，<code>sz</code>将会有一个值，并且在<font color=LightSeaGreen>匿名函数会捕获<code>sz</code>，所以当<code>imageOfSize</code>调用匿名函数时，匿名函数内的<code>sz</code>的值和传递给<code>makeRoundedRectangle</code>的值一样</font>。</p>
<p>上面的代码变得非常紧凑。要调用<code>makeRoundedRectangle</code>，先提供<code>size</code>，然后返回图像。可以一次完成调用、获取图像并显示该图像：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">self</span>.iv.image = makeRoundedRectangle(CGSize(width:<span style="color:#ae81ff">45</span>, height:<span style="color:#ae81ff">20</span>))
</span></span></code></pre></div><h2 id="function-returning-function">Function Returning Function</h2>
<p>实际上可以更进一步，相比于返回一个图像，函数可以返回一个生成指定大小圆角矩形图片的函数。函数可以用作值，我们已经将一个函数作为参数传递给另一个函数。</p>
<p>相似地，函数也可以返回函数，现在我们将从函数调用后接收一个函数作为其结果，也就是返回一个生成指定大小圆角矩形图片的函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">makeRoundedRectangleMaker</span>(<span style="color:#66d9ef">_</span> sz: CGSize) -&gt; () -&gt; UIImage { <span style="color:#960050;background-color:#1e0010">①</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">f</span>() -&gt; UIImage { <span style="color:#960050;background-color:#1e0010">②</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> im = imageOfSize(sz) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> p = UIBezierPath(roundedRect: CGRect(origin: CGPoint.zero, size: sz), cornerRadius: <span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>            p.stroke()
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> im
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> f <span style="color:#960050;background-color:#1e0010">③</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol>
<li>
<p>函数<code>makeRoundedRectangleMaker</code>的类型（签名）到底是什么？它是<code>(CGSize) -&gt; () -&gt; UIImage</code>。该表达式有两个箭头运算符，需要注意的是<font color=red>每个箭头运算符之后的所有内容都是一个返回值类型</font>。因此上面的函数接受一个参数<code>CGSize</code>，并且返回一个签名为<code>() -&gt; UIImage</code>的函数。</p>
</li>
<li>
<p>在函数<code>makeRoundedRectangleMaker</code>内第一步是定义一个函数（内部函数），这个内部函数没有入参，返回一个<code>UIImage</code>，并将这个函数命名为<code>f</code>。这个函数的工作方式既简单又熟悉：它调用<code>imageOfSize</code>，传递给它一个匿名函数，该函数生成一个圆角矩形的图像，然后返回该图像。</p>
</li>
<li>
<p>最后，返回内部函数<code>f</code>。也就是履行了之前的约定：<code>makeRoundedRectangleMaker</code>将返回一个不带参数并返回一个<code>UIImage</code>的函数。</p>
</li>
</ol>
<p>但是，也许你仍然会对<code>makeRoundedRectangleMaker</code>感到惊讶，不知道该怎么使用它，如果调用他们会得到什么。让我们尝试一下，如果按照下面这样做会得到什么：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> maker = makeRoundedRectangleMaker(CGSize(width:<span style="color:#ae81ff">45</span>, height:<span style="color:#ae81ff">20</span>)) 
</span></span></code></pre></div><p>该代码运行后的变量<code>maker</code>的是什么？它是一个函数，是一个不带参数的函数，当它被调用时，会生成一个大小为<code>(45,20)</code>的圆角矩形的图像。可以通过调用<code>maker</code>来证实这一点：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> maker = makeRoundedRectangleMaker(CGSize(width:<span style="color:#ae81ff">45</span>, height:<span style="color:#ae81ff">20</span>)) 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">self</span>.iv.image = maker()
</span></span></code></pre></div><p>再次将注意力转向<code>makeRoundedRectangleMaker</code>函数的实现，编写<code>makeRoundedRectangleMaker</code>不是为了说明一个函数可以返回一个函数。而是为了说明闭包，让我们思考一下<code>environment</code>是如何被捕获的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">makeRoundedRectangleMaker</span>(<span style="color:#66d9ef">_</span> sz: CGSize) -&gt; () -&gt; UIImage {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">f</span>() -&gt; UIImage {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> im = imageOfSize(sz) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> p = UIBezierPath(roundedRect: CGRect(origin: CGPoint.zero, size: sz),
</span></span><span style="display:flex;"><span>                    cornerRadius: <span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>            p.stroke()
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> im
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> f
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>函数<code>f</code>没有参数。但是，在<code>f</code>的函数体内却两次引用了<code>sz</code>。在函数<code>f</code>内部可以看到<code>sz</code>，即外部函数<code>makeRoundedRectangleMaker</code>的入参。函数<code>f</code>在<code>makeRoundedRectangleMaker</code>被调用时捕获了<code>sz</code>，<strong>并在<code>f</code>返回并赋值给<code>maker</code>时保留该引用</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> maker = makeRoundedRectangleMaker(CGSize(width:<span style="color:#ae81ff">45</span>, height:<span style="color:#ae81ff">20</span>)) 
</span></span></code></pre></div><p>这就是为什么<code>maker</code>现在是一个函数，当它被调用时，创建和返回了<code>size</code>为<code>(45,20)</code>的图片，生成图像大小值已被纳入到<code>maker</code>中。</p>
<p>从另一角度，<code>makeRoundedRectangleMaker</code>是一个工厂函数，用于创建类似于<code>maker</code>的系列函数，每个函数都生成一个特定大小的图像。这个函数说明了闭包的力量。</p>
<p>实际上，可以以更<code>Swiftier</code>的方式重写<code>makeRoundedRectangleMaker</code>，在函数<code>f</code>中，没有必要创建<code>im</code>变量，可以直接返回<code>imageOfSize</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">makeRoundedRectangleMaker</span>(<span style="color:#66d9ef">_</span> sz: CGSize) -&gt; () -&gt; UIImage {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">f</span>() -&gt; UIImage {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> imageOfSize(sz) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> p = UIBezierPath(roundedRect: CGRect(origin: CGPoint.zero, size: sz), cornerRadius: <span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>            p.stroke()
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> f
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>实际上也没有必要声明<code>f</code>，然后再返回<code>f</code>，可以直接返回匿名函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">makeRoundedRectangleMaker</span>(<span style="color:#66d9ef">_</span> sz: CGSize) -&gt; () -&gt; UIImage {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> imageOfSize(sz) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> p = UIBezierPath(roundedRect: CGRect(origin: CGPoint.zero, size: sz), cornerRadius: <span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>            p.stroke()
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>但在上面的匿名函数中除了一个<code>return</code>语句，没有其它语句。<code>imageOfSize</code>中的匿名函数参数由多个语句组成，但<code>imageOfSize</code>调用本身仍然只是一个语句。因此可以省略<code>imageOfSize</code>前的<code>return</code>关键字：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">makeRoundedRectangleMaker</span>(<span style="color:#66d9ef">_</span> sz: CGSize) -&gt; () -&gt; UIImage {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> {
</span></span><span style="display:flex;"><span>        imageOfSize(sz) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> p = UIBezierPath(roundedRect: CGRect(origin: CGPoint.zero, size: sz), cornerRadius: <span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>            p.stroke()
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>实际上，也可以省略最后的那个<code>return</code>，但不建议这样做，因为这样看起来很不直观：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">makeRoundedRectangleMaker</span>(<span style="color:#66d9ef">_</span> sz: CGSize) -&gt; () -&gt; UIImage {
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        imageOfSize(sz) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> p = UIBezierPath(roundedRect: CGRect(origin: CGPoint.zero, size: sz), cornerRadius: <span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>            p.stroke()
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="closure-setting-a-captured-variable">Closure Setting a Captured Variable</h2>
<p>闭包通过其捕捉环境的能力所获得的力量比目前为止所展示的还要强大。<font color=LightSeaGreen>如果闭包能够捕获一个外部变量的引用，并且该变量是可设置的，则闭包可以设置该变量</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">pass100</span>(<span style="color:#66d9ef">_</span> f: (Int) -&gt; ()) {
</span></span><span style="display:flex;"><span>    f(<span style="color:#ae81ff">100</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> x = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>print(x) <span style="color:#75715e">// 0</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">setX</span>(newX: Int) {
</span></span><span style="display:flex;"><span>    x = newX
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>pass100(setX)
</span></span><span style="display:flex;"><span>print(x) <span style="color:#75715e">// 100</span>
</span></span></code></pre></div><p>上面的代码中，因为传入到<code>pass100</code>中的函数<code>setX</code>包含了<code>x</code>，不仅包含它，而且能够捕获它，并且修改了<code>x</code>的值。函数<code>pass100</code>函数能够像直接调用<code>setX</code>一样轻松地设置<code>x</code>。</p>
<h2 id="closure-preserving-captured-environment">Closure Preserving Captured Environment</h2>
<p><em>When a closure captures its environment, it preserves that environment even if nothing else does.</em></p>
<p>当一个闭包捕获它所在的环境，即使其它什么都不做，闭包也会保留该环境。下面是一个让你大吃一惊的例子：<font color=red>一个修改函数的函数</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">countAdder</span>(<span style="color:#66d9ef">_</span> f: @escaping () -&gt; ()) -&gt; () -&gt; () {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> ct = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> {
</span></span><span style="display:flex;"><span>        ct = ct <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;count is </span><span style="color:#e6db74">\(</span>ct<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>        f()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面的函数<code>countAdder</code>接受一个函数入参（使用<code>@escaping</code>标记），并且返回一个函数作为调用它的结果。它<font color=Blue>返回的函数调用它接收的函数参数</font>，并做了额外工作：它增加一个变量并报告结果。所以现在试着猜测当运行下面这段代码时会发生什么：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">greet</span>() {
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;howdy&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> countedGreet = countAdder(greet)
</span></span><span style="display:flex;"><span>countedGreet() 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>countedGreet() 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>countedGreet() 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 运行结果</span>
</span></span><span style="display:flex;"><span>count <span style="color:#66d9ef">is</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>howdy
</span></span><span style="display:flex;"><span>count <span style="color:#66d9ef">is</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>howdy
</span></span><span style="display:flex;"><span>count <span style="color:#66d9ef">is</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>howdy
</span></span></code></pre></div><p>上面定义了一个函数<code>greet</code>，在这个函数中打印<code>howdy</code>。函数<code>countAdder</code>返回一个新函数，我们将其命名为<code>countedGreet</code>。然后调用<code>countedGreet</code> 三次，以下是控制台打印的内容：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>count <span style="color:#66d9ef">is</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>howdy
</span></span><span style="display:flex;"><span>count <span style="color:#66d9ef">is</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>howdy
</span></span><span style="display:flex;"><span>count <span style="color:#66d9ef">is</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>howdy
</span></span></code></pre></div><p>显然，<code>countAdder</code>已经为传递给它的函数<font color=red>添加了报告调用次数的能力</font>。维持这个计数的变量到底在哪里？在<code>countAdder</code>中，<code>ct</code>是一个局部变量，它并未声明在匿名函数内部，这是故意的。如果它在匿名函数中声明，那么每次调用<code>countedGreet</code>时<code>ct</code>将被设置为<code>0</code>，将不会正常计数。</p>
<p>相反<code>ct</code>声明在匿名函数外，只被初始化为<code>0</code>一次，然后被匿名函数捕获。这个变量作为<code>countedGreet</code>环境的一部分被保存下来（它在<code>countedGreet</code>之外的某个神秘的保留变量的环境世界中），所以每次<code>countedGreet</code>被调用时它都能被递增。</p>
<p>一个值在闭包中被捕获，这意味着在代码块被执行前，代码块都能引用这些值。</p>
<h2 id="escaping-closures">Escaping Closures</h2>
<p><em>A closure is supposed to be no escaping when the closure is passed as an argument to the function, and is called before the function returns. The closure isn’t used outside of the function.</em></p>
<p><em>A closure is said to escape a function when the closure is passed as an argument to the function, but is called after the function returns.</em></p>
<p>如果将一个作为值传递的函数<font color=red>被保存供以后某个时刻执行，而不是立即调用它，那么它是一个随时间推移捕获并保存其环境的闭包</font>。这样的闭包被称为逃逸闭包(<code>escaping closure</code>)。</p>
<p><a href="https://www.avanderlee.com/swift/weak-self/">换句话说</a>，说一个闭包逃逸了，就是在传入闭包的方法结束之前该闭包还没有被调用。在编写异步代码时经常会出现这种情况。</p>
<p>在某些情况下，闭包的类型必须标记为<code>escaping</code>。编译器会检测违反这个规则的情况，如果对于是否需要加<code>escaping</code>有疑惑，不必担心，只要让编译器检查并提示添加就可以了。</p>
<p>下面函数是合法的，无需标记为<code>escaping</code>。因为**<font color=red>它接受一个函数作为参数，并且在函数内直接调用了这个函数</font>**，即<code>funcCaller</code>方法结束之前会调用<code>f</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">funcCaller</span>(f: () -&gt; ()) {
</span></span><span style="display:flex;"><span>    f()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>下面函数也是合法的，尽管它返回一个稍后执行的函数，但**<font color=red>它是在函数内部创建了那个匿名函数</font>**，而不是作为参数传递进来的。它返回的函数是一个逃逸闭包，但<font color=Blue>函数返回值的类型不必标记为<code>@escaping</code></font>，也就是说<code>@escaping</code>标记只针对于入参：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">funcMaker</span>() -&gt; () -&gt; () {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 内部创建的匿名函数</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> {
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;hello world&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>但是，下面的函数是不合法的，会出现编译错误。因为它接受了一个函数作为入参，并且返回了这个函数供后续某个时刻执行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">funcPasser</span>(f: () -&gt; ()) -&gt; () -&gt; () { 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> f
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 出现如下的编译错误</span>
</span></span><span style="display:flex;"><span>Using non<span style="color:#f92672">-</span>escaping parameter <span style="color:#960050;background-color:#1e0010">&#39;</span>f<span style="color:#960050;background-color:#1e0010">&#39;</span> <span style="color:#66d9ef">in</span> a context expecting an @escaping closure
</span></span></code></pre></div><p>解决方案是将函数入参标<code>f</code>记为<code>@escaping</code>，编译器也会提醒需要这样做：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">funcPasser</span>(f: @escaping () -&gt; ()) -&gt; () -&gt; () { 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> f
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>逃逸闭包的第二个特点是当在函数体内引用<code>self</code>的<font color=red>属性或方法时</font>，编译器会坚持需要明确地使用<code>self</code>。<strong><font color=red>那是因为这样的引用捕获了<code>self</code>，编译器希望通过使用<code>self</code>来承认这个事实</font></strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> f1 = funcPasser {
</span></span><span style="display:flex;"><span>    print(view.bounds) <span style="color:#75715e">// Implicit use of &#39;self&#39; in closure; use &#39;self.&#39; to make capture semantics explicit</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> f2 = funcPasser {
</span></span><span style="display:flex;"><span>    print(<span style="color:#66d9ef">self</span>.view.bounds) <span style="color:#75715e">// ok</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="capture-lists">Capture Lists</h2>
<p>有时，可能希望一个函数引用外部的变量，<font color=Blue>只是为了获取它的值，但不捕获该变量</font>。<code>Swift</code>提供了一种巧妙的语法来做到这一点，但这种方式**<font color=red>仅限于函数是匿名函数时</font>**才能使用。在匿名函数体的开头，放置方括号，里面包含对外部环境中变量的引用的逗号分隔列表，这称为捕获列表。</p>
<p>如果在匿名函数中有一个捕获列表，那么<font color=LightSeaGreen>必须在它后面加上关键字<code>in</code>。</font>如果已经存在<code>in</code>表达式，则<font color=red>捕获列表位于参数名称之前</font>即可。</p>
<p>捕获列表就好像<font color=red>这些值已作为参数而不是通过闭包捕获传递给匿名函数一样</font>。这就像是用<code>let</code>声明的参数一样。首先看一下没有捕获列表的情况：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> x = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> f: () -&gt; () = {
</span></span><span style="display:flex;"><span>    print(x)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>f() <span style="color:#75715e">// 0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>x = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>f() <span style="color:#75715e">// 1</span>
</span></span></code></pre></div><p>在上面的函数中，由于捕获到了变量的值，那么打印的值分别是<code>0</code>和<code>1</code>。而在下面的代码中，因为<font color=red>添加了捕获列表</font>，下面代码执行两次打印的值均为<code>0</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> x = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> f: () -&gt; () = { [x] <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>    print(x)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>f() <span style="color:#75715e">// 0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>x = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>f() <span style="color:#75715e">// 0</span>
</span></span></code></pre></div><p>因为使用了捕获列表，<code>f</code>在声明时已经将变量<code>x</code>的值捕获为<code>0</code>。实际上，<code>x</code>的行为类似于传递给<code>f</code>的普通参数，它是一个常量。</p>
<p>另一种方式去验证这个，就是如果<code>f</code>尝试设置<code>x</code>的值，编译器会出现：<em>Cannot assign to value: &lsquo;x&rsquo; is an immutable capture</em>错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> x = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> f: () -&gt; () = { [x] <span style="color:#66d9ef">in</span> 
</span></span><span style="display:flex;"><span>    x = <span style="color:#ae81ff">5</span> <span style="color:#75715e">// Cannot assign to value: &#39;x&#39; is an immutable capture</span>
</span></span><span style="display:flex;"><span>    print(x)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>对捕获列表中的值<font color=red>重命名也是合法的</font>。捕获列表可以使用<code>[y=x]</code>来重命名捕获的值，这种方式好像将<code>x</code>作为参数传递给匿名函数，但现在该参数的名称为<code>y</code>。当原始名称有问题时，或者当要传入的值是需要在赋值的时候被计算时，这种方式很有用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> x = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> f: () -&gt; () = { [ y = x] <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>    print(x0)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>f() <span style="color:#75715e">// 0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>x = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>f() <span style="color:#75715e">// 0</span>
</span></span></code></pre></div><p>下面代码中，使用捕获的变量计算出一个新的常量<code>y</code>，计算的时机发生在<code>f</code>定义时，因此不管在定义后<code>x</code>是否被重新赋值，<code>y</code>的计算都是在<code>f</code>定义的时候：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> x = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> f: () -&gt; () = { [ y = x <span style="color:#f92672">+</span> <span style="color:#ae81ff">5</span>] <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>    print(x0)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>f() <span style="color:#75715e">// 5</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>x = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>f() <span style="color:#75715e">// 5</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> x = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 函数f定义的时候就捕获到了x的值</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> f: () -&gt; () = { [ y = x <span style="color:#f92672">+</span> <span style="color:#ae81ff">5</span>] <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>    print(x0)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 此时改变x的值，对闭包没有作用</span>
</span></span><span style="display:flex;"><span>x = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>f() <span style="color:#75715e">// 5</span>
</span></span></code></pre></div><p>作为参数传递给<code>registerUndo</code>的匿名函数是一个逃逸闭包。捕获列表声明了一个常量<code>oldCenter</code>并将其值设置为<code>self.center</code>。因此，<code>self.center</code>的值<font color=red>在闭包定义时就立即进行求值，而不是稍后在调用匿名函数本身时再进行求值</font>（此时 <code>self.center</code>的值可能已经被更改了）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">self</span>.undoer.registerUndo(withTarget: <span style="color:#66d9ef">self</span>) { [oldCenter = <span style="color:#66d9ef">self</span>.center] myself <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>    myself.setCenterUndoably(oldCenter)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>捕获列表的另一个用途是<font color=red>解决在逃逸闭包中需要明确添加<code>self</code>关键字的硬性要求</font>。下面代码中，需要明确地添加<code>self</code>，因为这是一个逃逸闭包。但是很多人不喜欢明确地使用<code>self</code>，如果这个匿名函数多次隐含地使用<code>self</code>，则可能需要多次明确地使用<code>self</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> f2 = funcPasser {
</span></span><span style="display:flex;"><span>    print(<span style="color:#66d9ef">self</span>.view.bounds)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>从<code>Swift 5.3</code>开始，可以把<code>self</code>放在捕获列表中，这能够满足编译器的要求，并且也不必明确使用<code>self</code>来访问属性和方法，即可以省略<code>self</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> f2 = funcPasser { [<span style="color:#66d9ef">self</span>] <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>    print(view.bounds) <span style="color:#75715e">// ok </span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在闭包中也可以直接使用<code>weak</code>接收<a href="https://www.avanderlee.com/swift/weak-self/">外部变量</a> ，不仅仅是<code>self</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>download(imageURL, completion: { [<span style="color:#66d9ef">weak</span> imageViewController] result <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>download(imageURL, completion: { [<span style="color:#66d9ef">weak</span> imageViewController, <span style="color:#66d9ef">weak</span> imageFinalizer] result <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>})
</span></span></code></pre></div><h2 id="weak-strong-unowned">weak strong unowned</h2>
<p><code>ARC</code>是一个编译时功能，它是苹果的自动内存管理工具，代表的是自动引用计数<em>Automatic Reference Counting</em>，这意味着只有<font color=red>当对象的强引用计数为零时，对象才能被释放出内存</font>。</p>
<p>强引用<font color=Blue>本质上是一个普通的引用</font>，但它本身很特别，因为它通过增加引用计数来保护被引用的对象不被释放。强引用在<code>Swift</code>中几乎随处可见。</p>
<p>事实上，<font color=red>声明一个属性默认就是强引用的</font>。 一般来说，<font color=red>当对象的层次关系是线性的，使用强引用就是安全的</font>。也就是说，当强引用的层次结构总是从上到下时，使用强引用总是安全的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Kraken</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// strong reference to child.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> tentacle = Tentacle() 
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Tentacle</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// strong reference to child</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> sucker = Sucker()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Sucker</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例是一个线性层次结构。<code>Kraken</code>的定义中对<code>Tentacle</code>实例的引用是一个强引用，并且<code>Tentacle</code>对<code>Sucker</code>实例的引用也是强引用。这个层次结构从<code>Kraken</code>一直到<code>Sucker</code>。</p>
<p>同样地，在动画的<code>blocks</code>中，引用的层次也是相似的。因为<code>animateWithDuration</code>是<code>UIView</code>静态方法，<font color=red>下面的闭包是<code>parent</code>，<code>self</code>是<code>child</code></font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>UIView.animate(withDuration: <span style="color:#ae81ff">0.3</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">self</span>.view.alpha = <span style="color:#ae81ff">0.0</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>弱引用只是一个指向对象的指针，<font color=Blue>它不保护指向的对象不被<code>ARC</code>释放</font>。强引用会使对象的引用计数增加<code>1</code>，但<font color=red>弱引用不会</font>增加计数。</p>
<p>此外，当对象被成功被释放时，弱引用会自动被置为<code>nil</code>。这确保了当访问弱引用时，要么访问的是一个有效的对象，要么是<code>nil</code>。</p>
<p>在<code>Swift</code>中，所有的弱引用都不是常量，并且是<code>optional</code>的，因为当不再有任何强引用这个对象时，弱引用终将被置为<code>nil</code>。下面代码编译时会出现<code>'weak' must be a mutable variable, because it may change at runtime</code>错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Kraken</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// let is a constant! All weak variables MUST be mutable.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">weak</span> <span style="color:#66d9ef">let</span> tentacle = Tentacle()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面代码中<code>tentacle</code>被定义为一个常量，它在初始化后不能再被赋值。因为如果没有持有这个对象的强引用后，那么弱引用就会被置为<code>nil</code>，所以<code>Swift</code>编译器要求在定义弱变量时使用<code>var</code>，而不能使用<code>let</code>。</p>
<p>在可能存在循环引用（<code>retain cycles</code>）的场景，应当使用弱变量。<font color=red>循环引用是指两个对象相互强引用对方</font>。如果两个对象之间存在强引用，<code>ARC</code>将不会在每个实例上生成适当的释放信息代码，因为它们在保持彼此的生命：</p>
<img src="https://s2.loli.net/2023/04/15/7NiY1z5gtUrGPkF.png" style="zoom:50%;" />
<p><font color=red>如果变量是在闭包的作用域之外声明的，那么在闭包的作用域内引用该变量就会对该对象产生另一个强引用</font>。唯一的例外是使用值语义的变量，如<code>Swift</code>中的<code>Int</code>、<code>String</code>、<code>Array</code>和<code>Dictionary</code>。</p>
<p>首先来看下面代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Kraken</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> notificationObserver: ((Notification) -&gt; Void)?
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>() {
</span></span><span style="display:flex;"><span>        notificationObserver = NotificationCenter.<span style="color:#66d9ef">default</span>.addObserver(forName: <span style="color:#e6db74">&#34;humanEnteredKrakensLair&#34;</span>, object: <span style="color:#66d9ef">nil</span>, queue: .main) { notification <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">self</span>.eatHuman()
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">deinit</span> {            
</span></span><span style="display:flex;"><span>        NotificationCenter.<span style="color:#66d9ef">default</span>.removeObserver(notificationObserver)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面代码产生了一个循环引用。<code>notificationObserver</code>持有闭包，当调用<code>eatHuman</code>时，在这个闭包中会捕获到<code>self</code>，并强持有它。最好的方法是在<code>deinit</code>函数中清理通知观察者，但<code>deinit</code>不会被<code>ARC</code>调用，因为闭包中有一个对<code>Kraken</code>实例的强引用。</p>
<p>其它可能发生这种情况是<font color=red>在使用<code>NSTimers</code>和<code>NSThread</code>的地方</font>。修复方法是在闭包的捕获列表中使用一个对<code>self</code>的弱引用，这能够打破强引用循环：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> closure = { [<span style="color:#66d9ef">weak</span> <span style="color:#66d9ef">self</span>] <span style="color:#66d9ef">in</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">self</span>?.doSomething() <span style="color:#75715e">//Remember, all weak variables are Optionals!</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>为什么对<code>self</code>的弱引用在方括号内，这看起来很奇怪。在<code>Swift</code>中，看到方括号就会想到数组。可以在闭包中指定多个捕获值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#75715e">//Look at that sweet, sweet Array of capture values.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> closure = { [<span style="color:#66d9ef">weak</span> <span style="color:#66d9ef">self</span>, <span style="color:#66d9ef">unowned</span> krakenInstance] <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// weak variables are Optionals!</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">self</span>?.doSomething() 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// unowned variables are not.</span>
</span></span><span style="display:flex;"><span>    krakenInstance.eatMoreHumans() 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这看起来更像一个数组。所以，现在理解为什么捕获值要放在方括号里了。通过在闭包的捕获列表中添加<code>[weak self]</code>可以修复上面的循环引用问题：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>NotificationCenter.<span style="color:#66d9ef">default</span>.addObserver(forName: <span style="color:#e6db74">&#34;humanEnteredKrakensLair&#34;</span>, object: <span style="color:#66d9ef">nil</span>, queue: .main) { [<span style="color:#66d9ef">weak</span> <span style="color:#66d9ef">self</span>] notification <span style="color:#66d9ef">in</span> <span style="color:#75715e">//The retain cycle is fixed by using capture lists!</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">self</span>?.eatHuman() <span style="color:#75715e">//self is now an optional!</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>需要使用<code>weak</code>和<code>unowned</code>的另一个地方是使用协议在类之间应用代理，因为类是引用类型，所以可能出现循环引用。在<code>Swift</code>中结构体和枚举也可以遵循协议，但它们是值语义，不会出现循环引用。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Kraken</span>: LossOfLimbDelegate {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> tentacle = Tentacle()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>() {
</span></span><span style="display:flex;"><span>        tentacle.delegate = <span style="color:#66d9ef">self</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">limbHasBeenLost</span>() {
</span></span><span style="display:flex;"><span>        startCrying()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">startCrying</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">deinit</span> {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;Kraken&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">protocol</span> <span style="color:#a6e22e">LossOfLimbDelegate</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">limbHasBeenLost</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Tentacle</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> delegate: LossOfLimbDelegate?
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">cutOffTentacle</span>() {
</span></span><span style="display:flex;"><span>        delegate?.limbHasBeenLost()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">deinit</span> {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;Tentacle&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>lef f = {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> k1 = Kraken()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在上面代码中，<code>Tentacle</code>以代理属性的方式强持有了<code>Kraken</code>。与此同时，<code>Kraken</code>中也以属性的方式强引用了<code>Tentacle</code>实例。在上面的场景中，定义<code>delegate</code>属性时，使用<code>weak</code>即可破解这种循环引用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">weak</span> <span style="color:#66d9ef">var</span> delegate: LossOfLimbDelegate?
</span></span></code></pre></div><p>但是，加上<code>weak</code>后会编译出现错误<code>'weak' must not be applied to non-class-bound 'any LossOfLimbDelegate'; consider adding a protocol conformance that has a class bound</code>。这种情况，必须限定协议的遵循者，让协议继承<code>class</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#75715e">// The protocol now inherits class</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">protocol</span> <span style="color:#a6e22e">LossOfLimbDelegate</span>: <span style="color:#66d9ef">class</span> { 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">limbHasBeenLost</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Using <span style="color:#960050;background-color:#1e0010">&#39;</span><span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010">&#39;</span> keyword to define a <span style="color:#66d9ef">class</span><span style="color:#f92672">-</span>constrained <span style="color:#66d9ef">protocol</span> <span style="color:#a6e22e">is</span> deprecated; use <span style="color:#960050;background-color:#1e0010">&#39;</span>AnyObject<span style="color:#960050;background-color:#1e0010">&#39;</span> instead
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">protocol</span> <span style="color:#a6e22e">LossOfLimbDelegate</span>: AnyObject {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">limbHasBeenLost</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><em>Use a class-only protocol when the behavior defined by that protocol’s requirements assumes or requires that a conforming type has reference semantics rather than value semantics</em></p>
<p>使用<code>weak</code>和<code>unowned</code>大致相同，但还是有些区别。<code>unowned</code>和<code>weak</code>引用，都不会增加引用对象的强引用计数。在<code>Swift</code>中<code>unowned</code>引用有一个额外的好处，它<font color=red>确保捕获的引用的对象不是一个可选对象</font>，这使得在使用捕获的引用前不用判断它是否为<code>nil</code>。</p>
<p>此外，<code>unowned</code>引用是不会被置为<code>nil</code>的，这意味着当对象被释放时，不会将引用自动置为<code>nil</code>。也就是说在某些情况下，使用<code>unowned</code>引用，<font color=red>可能会导致指针悬空的情况</font>。</p>
<p>弱引用和无主引用都不会增加强引用次数。它们都可以被用来打破循环引用。那么，我们什么时候使用它们呢？根据苹果的文档：</p>
<p><em>Use a weak reference whenever it is valid for that reference to become nil at some point during its lifetime. Conversely, use an unowned reference when you know that the reference will never be nil once it has been set during initialization.</em></p>
<p>如同隐式解包<code>optional</code>类型，如果能够<font color=red>保证引用在使用的时候不会被置为<code>nil</code></font>，就可以使用<code>unowned</code>来解除循环引用，否则就需要使用<code>weak</code>来解除循环引用。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">RetainCycle</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> closure: (() -&gt; Void)<span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> string = <span style="color:#e6db74">&#34;Hello&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>() {
</span></span><span style="display:flex;"><span>        closure = {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">self</span>.string = <span style="color:#e6db74">&#34;Hello, World!&#34;</span>
</span></span><span style="display:flex;"><span>            debugPrint(<span style="color:#66d9ef">self</span>.string)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">deinit</span> {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;deinit RetainCycle&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> f1 = {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Initialize the class and activate the retain cycle.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> retainCycleInstance = RetainCycle()
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// At this point we can guarantee the captured self inside the closure will not be nil.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Any further code after this (especially code that alters self&#39;s reference) needs to be judged on whether or not unowned still works here.</span>
</span></span><span style="display:flex;"><span>    retainCycleInstance.closure()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>f1()
</span></span></code></pre></div><p>在上面例子中，闭包中捕获了<code>self</code>，并且是强引用的。而在<code>RetainCycle</code>中，强引用了<code>closure</code>闭包。此时，可以使用<code>[unowned self]</code>来打破循环引用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>closure = { [<span style="color:#66d9ef">unowned</span> <span style="color:#66d9ef">self</span>] <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">self</span>.string = <span style="color:#e6db74">&#34;Hello, World!&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面这种情况我们假设了<code>self</code>不会被置为<code>nil</code>，这是因为生成<code>RetainCycle</code>实例后，<font color=Blue>立即调用了它的属性<code>closure</code>闭包</font>。</p>
<p><em>Define a capture in a closure as an unowned reference when the closure and the instance it captures will always refer to each other, and will always be deallocated at the same time</em></p>
<p>如果知道这个引用将被正确清除，并且两个引用彼此相互依赖（一个不能没有另一个），那么应该优先选择<code>unowned</code>而不是<code>weak</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Kraken</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> petName = <span style="color:#e6db74">&#34;Krakey-poo&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">lazy</span> <span style="color:#66d9ef">var</span> businessCardName: () -&gt; String = { [<span style="color:#66d9ef">unowned</span> <span style="color:#66d9ef">self</span>] <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;Mr. Kraken AKA &#34;</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">self</span>.petName
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在上面代码中，使用<code>unowned self</code> 解决循环引用问题。<code>Kraken</code>在它的生命周期内持有<code>businessCardName</code>闭包，同时<code>businessCardName</code>闭包在它的生命周期内也持有<code>Karaken</code>。它们是相互依赖的，所以它们总是在同一时间被删除。但千万不能与<code>lazy</code>属性中使用<code>define-and-call</code>相混淆：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Kraken</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> petName = <span style="color:#e6db74">&#34;Krakey-poo&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">lazy</span> <span style="color:#66d9ef">var</span> businessCardName: String = {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;Mr. Kraken AKA &#34;</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">self</span>.petName
</span></span><span style="display:flex;"><span>    }()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在上面定义中，<code>unowned self</code>是不需要的。因为实际上没有任何东西持有生成<code>lazy</code>属性的闭包，只是将闭包生成的结果赋值给属性，并在第一次使用后立即清除闭包（并会减去捕获<code>self</code>的强引用计数）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Kraken2</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> petName = <span style="color:#e6db74">&#34;Krakey-poo&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">lazy</span> <span style="color:#66d9ef">var</span> businessCardName: String = {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;Mr. Kraken AKA &#34;</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">self</span>.petName
</span></span><span style="display:flex;"><span>    }()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;Create Kraken2&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">deinit</span> {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;Kraken2&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> kraken: Kraken2? = Kraken2()
</span></span><span style="display:flex;"><span>kraken = Kraken2()
</span></span><span style="display:flex;"><span>kraken?.businessCardName
</span></span><span style="display:flex;"><span>kraken = <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行后的结果，两个实例都正常释放了</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;Create Kraken2&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;Create Kraken2&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;Kraken2&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;Kraken2&#34;</span>
</span></span></code></pre></div><p><a href="https://krakendev.io/blog/weak-and-unowned-references-in-swift#:~:text=To%20use%20weak%20and%20unowned%20variables%20in%20a,self%3F.doSomething%28%29%20%2F%2FRemember%2C%20all%20weak%20variables%20are%20Optionals%21%20%7D">参考资料</a></p>
<h2 id="implicit-capturing">Implicit capturing</h2>
<p>当定义一个逃逸闭包时，即<font color=red>一个闭包要么被存储在一个属性中，要么被另一个逃逸闭包所捕获</font>。逃逸闭包<font color=LightSeaGreen>将隐含地捕获任何在其内被引用的对象、值和函数</font>。由于这样的闭包可能会在后面某个时间点被执行，它们<font color=red>需要保持对其所有依赖关系的强引用，以防止它们在此期间被释放</font>。</p>
<p><em>Whenever we’re defining an escaping closure — that is, a closure that either gets stored in a property, or captured by another escaping closure — it’ll implicitly capture any objects, values and functions that are referenced within it. Since such closures may be executed at a later time, they need to maintain strong references to all of their dependencies in order to prevent them from being deallocated in the meantime.</em></p>
<p>在下面代码中，延迟了几秒钟执行闭包，所以当闭包实际运行时，<code>presenter</code>视图控制器<font color=Blue>有可能已经从应用程序的视图层次中删除了</font>。虽然在这种情况下，这不会是一场灾难，但可以说，只有当视图控制器仍然被其它对象（大概是其父视图控制器或窗口）保留时，才应该显示确认按钮。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">presentDelayedConfirmation</span>(<span style="color:#66d9ef">in</span> presenter: UIViewController) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> queue = DispatchQueue.main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    queue.asyncAfter(deadline: .now() <span style="color:#f92672">+</span> <span style="color:#ae81ff">3</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> alert = UIAlertController(
</span></span><span style="display:flex;"><span>            title: <span style="color:#e6db74">&#34;...&#34;</span>,
</span></span><span style="display:flex;"><span>            message: <span style="color:#e6db74">&#34;...&#34;</span>,
</span></span><span style="display:flex;"><span>            preferredStyle: .alert
</span></span><span style="display:flex;"><span>        )
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// By simply refering to &#39;presenter&#39; here, our closure</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// will automatically capture that instance, and retain</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// it until the closure itself gets released from memory:</span>
</span></span><span style="display:flex;"><span>        presenter.present(alert, animated: <span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这就是捕获列表的作用，它使我们能够<font color=red>自定义一个给定的闭包如何捕获它所指向的任何对象或值</font>。使用捕获列表，可以指示上面的闭包以弱引用方式捕获<code>presenter</code>视图控制器，而不是强方式（这是默认的）。</p>
<p>这样，如果<code>presenter</code>不被代码中的其它部分引用，视图控制器就会被释放，从而使内存更快地被释放，并且也不会有非必要的操作被执行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">presentDelayedConfirmation</span>(<span style="color:#66d9ef">in</span> presenter: UIViewController) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> queue = DispatchQueue.main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// A capture list is defined using a set of square brackets</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// directly following a closure&#39;s opening curly bracket:</span>
</span></span><span style="display:flex;"><span>    queue.asyncAfter(deadline: .now() <span style="color:#f92672">+</span> <span style="color:#ae81ff">3</span>) { [<span style="color:#66d9ef">weak</span> presenter] <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Here we verify that our presenter is still in memory,</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// otherwise we can return early:</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">guard</span> <span style="color:#66d9ef">let</span> presenter = presenter <span style="color:#66d9ef">else</span> { <span style="color:#66d9ef">return</span> }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> alert = UIAlertController(
</span></span><span style="display:flex;"><span>            title: <span style="color:#e6db74">&#34;...&#34;</span>,
</span></span><span style="display:flex;"><span>            message: <span style="color:#e6db74">&#34;...&#34;</span>,
</span></span><span style="display:flex;"><span>            preferredStyle: .alert
</span></span><span style="display:flex;"><span>        )
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        presenter.present(alert, animated: <span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>当需要引用<code>self</code>时，捕获列表也许更加有用，特别是在闭包中引用<code>self</code>会导致循环引用时。循环引用是指两个对象或闭包互相引用，这会导致它们都被释放（因为它们不能达到强引用计数为零）。</p>
<p>在下面代码中使用捕获列表来避免在闭包中强引用<code>self</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">UserModelController</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> storage: UserStorage
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">var</span> user: User { <span style="color:#66d9ef">didSet</span> { userDidChange() } }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(user: User, storage: UserStorage) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.storage = storage
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.user = user
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        storage.addObserver(forID: user.id) { [<span style="color:#66d9ef">weak</span> <span style="color:#66d9ef">self</span>] user <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">self</span>?.user = user
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果不使用<code>weak</code>捕获<code>self</code>，上述的闭包最终会导致一个循环引用。因为<code>self</code>持有了<code>storage</code>，在<code>storage</code>中也持有了<code>self</code>。</p>
<h3 id="weak-references-are-not-always-the-answer">Weak references are not always the answer</h3>
<p>虽然上面的两个示例代码可能会让人觉得使用<code>[weak self]</code>总是正确的方式，但事实绝对不是这样。像其它的内存管理一样，必须仔细考虑在每种情况下如何使用<code>self</code>，以及<font color=red>希望每个逃逸的闭包在内存中保留多长时间</font>。</p>
<p>如果处理的是非常短暂的闭包，比如传递给<code>UIView.animate</code> 的闭包（这些代码只是为了执行动画，然后被释放），捕获<code>self</code>不是问题，而且代码也更容易阅读：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">extension</span> <span style="color:#a6e22e">ProductViewController</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">expandImageView</span>() {
</span></span><span style="display:flex;"><span>        UIView.animate(withDuration: <span style="color:#ae81ff">0.3</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">self</span>.imageView.frame = <span style="color:#66d9ef">self</span>.view.bounds
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">self</span>.showImageCloseButton()
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>请注意，当在<font color=red>一个逃逸闭包中访问实例方法和属性时，总是需要明确地引用<code>self</code></font>。这是一件好事，因为它要求我们做出明确的决定来捕获<code>self</code>，并考虑这样做可能产生的后果。</p>
<p>还有许多种情况，我们可能希望保留<code>self</code>甚至更长的时间。例如，如果当前对象被要求执行一个闭包的工作，就像下面这样：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">extension</span> <span style="color:#a6e22e">NetworkingController</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">makeImageUploadingTask</span>(<span style="color:#66d9ef">for</span> image: Image) -&gt; Task {
</span></span><span style="display:flex;"><span>        Task { handler <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> request = Request(
</span></span><span style="display:flex;"><span>                endpoint: .imageUpload,
</span></span><span style="display:flex;"><span>                payload: image
</span></span><span style="display:flex;"><span>            )
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// The current NetworkingController is required here,</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// so for as long the returned task is retained,</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// we&#39;ll also retain its underlying controller:</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">self</span>.perform(request, then: handler)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上述代码不会导致任何循环引用，因为<code>NetworkingController</code>引用它所创建的任务。</p>
<p>还可以直接捕获一个闭包的每个依赖项，而不只是捕获<code>self</code>（同样使用捕获列表）。例如，在这里我们捕获了一个图片加载器的缓存属性，以便在图片被成功下载后能够使用它：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ImageLoader</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">let</span> cache = Cache&lt;URL, Image&gt;()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">loadImage</span>(
</span></span><span style="display:flex;"><span>        from url: URL,
</span></span><span style="display:flex;"><span>        then handler: @escaping (Result&lt;Image, Error&gt;) -&gt; Void
</span></span><span style="display:flex;"><span>    ) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Here we capture our image loader&#39;s cache without</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// capturing &#39;self&#39;, and without having to deal with</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// any optionals or weak references:</span>
</span></span><span style="display:flex;"><span>        request(url) { [cache] result <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> image = <span style="color:#66d9ef">try</span> result.decodedAsImage()
</span></span><span style="display:flex;"><span>                cache.insert(image, forKey: url)
</span></span><span style="display:flex;"><span>                handler(.success(image))
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">catch</span> {
</span></span><span style="display:flex;"><span>                handler(.failure(error))
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>当涉及到闭包捕获列表时，值类型的处理有时会比较复杂，因为<font color=red>它们是作为副本而不是作为引用传递给外部作用域的</font>。尽管这正是 <code>Swift</code> 值类型的强大之处，但在下面这种情况下，它可能会产生一些意想不到的后果。在下面代码，一个按钮的<code>handler</code>赋值一个闭包时会捕获<code>sender</code>和<code>message</code>属性：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MessageComposerViewController</span>: UIViewController {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">let</span> sender: MessageSender
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">var</span> message = Message()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">lazy</span> <span style="color:#66d9ef">var</span> sendButton = ActionButton()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">viewDidLoad</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">super</span>.viewDidLoad()
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        sendButton.handler = { [sender, message] <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>            sender.send(message)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>乍一看，上面代码没什么问题。然而，<code>Message</code>类型是作为一个结构体来实现的，所以它是值语义的。这意味着我们在将其添加到捕获列表时<font color=red>只是捕获其当前值</font>。因此，即使该值在视图控制器的生命周期中可能发生变化，一旦<code>sendButton</code>被点击，仍然会使用捕获到的原始值。</p>
<p>解决上述问题的一个方法，同时仍然避免任何额外的防护语句，就是只捕获<code>self</code>，以便能够访问它的<code>message</code>属性，然后将该值直接映射到发送方的发送方法，像下面这样：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>sendButton.handler = { [<span style="color:#66d9ef">weak</span> <span style="color:#66d9ef">self</span>, sender] <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> message = <span style="color:#66d9ef">self</span>?.message
</span></span><span style="display:flex;"><span>    message.map(sender.send)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>但是，上面实际上只有在处理可变值时才会出现问题。如果只是处理常量，像下面的例子一样，那么可以毫无问题地将这些属性添加到任何闭包的捕获列表中（因为它们的值不会改变）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ProductViewController</span>: UIViewController {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">let</span> productManager: ProductManager
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">let</span> product: Product
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">viewDidLoad</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">super</span>.viewDidLoad()
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        buyButton.handler = { [productManager, product] <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>            productManager.startCheckout(<span style="color:#66d9ef">for</span>: product)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>最后，让我们来看看当涉及到局部变量时，值是如何被捕获的。<font color=red>与基于值的属性捕获方式相反，局部变量在被同一作用域内的闭包捕获时，仍然保持着与原始声明的联系</font>。这对于跟踪各种状态来说是非常有用的。</p>
<p>例如，假设想扩展 <code>Swift</code> 的 <code>Collection</code> 协议，使我们能够使用由当前元素和下一个元素组成的缓冲区来迭代任何集合。这可以通过将标准库的<code>AnySequence</code>和<code>AnyIterator</code>类型与本地捕获的值相结合来实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">extension</span> <span style="color:#a6e22e">Collection</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">typealias</span> Buffer = (current: Element, next: Element?)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> buffered: AnySequence&lt;Buffer&gt; {
</span></span><span style="display:flex;"><span>        AnySequence { () -&gt; AnyIterator&lt;Buffer&gt; <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// We define our state as local variables:</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">var</span> iterator = <span style="color:#66d9ef">self</span>.makeIterator()
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">var</span> next: Element?
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> AnyIterator { () -&gt; Buffer? <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// We can then use our state to make decisions by</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// capturing them within our iterator&#39;s closure:</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">guard</span> <span style="color:#66d9ef">let</span> current = next ?? iterator.next() <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                next = iterator.next()
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> (current, next)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>也就是说，<font color=red>当使用捕获列表捕获时，数值会被复制，而当直接引用时，它们不会被复制</font>。例如，当作为属性访问时，或者当一个局部变量在它被定义的同一范围内被捕获时。</p>
<p>如同弱引用一样，<code>unowned</code>也只能应用于引用类型。它的效果与强制解包<code>optional</code>类型一样，因为它让我们把弱引用当作非<code>optional</code>的，如果相应的对象被释放了，再通过<code>unowned</code>访问会出现闪退。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">UserModelController</span> {
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(user: User, storage: UserStorage) {
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        storage.addObserver(forID: user.id) { [<span style="color:#66d9ef">unowned</span> <span style="color:#66d9ef">self</span>] user <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">self</span>.user = user
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>虽然使用<code>unowned</code>可以让我们摆脱<code>optional</code>的<code>nil</code>判断，某种程度上来说也是非常方便的。但当引用悬空的时候，会出现闪退。这就使得它相当危险。</p>
<p><a href="https://www.swiftbysundell.com/articles/swifts-closure-capturing-mechanics/#implicit-capturing">参考资料</a></p>
<h2 id="curried-function">curried function</h2>
<p>当一个函数<font color=red>返回一个带参数的函数</font>，那么它被称为<code>curried</code>函数（以计算机科学家<code>Haskell Curry</code>命名）。下面是一个<code>curried</code>函数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">makeRoundedRectangleMaker</span>(<span style="color:#66d9ef">_</span> sz: CGSize) -&gt; (CGFloat) -&gt; UIImage {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> { r <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>        imageOfSize(sz) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> p = UIBezierPath(roundedRect: CGRect(origin: CGPoint.zero, size: sz), cornerRadius: r)
</span></span><span style="display:flex;"><span>            p.stroke()
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在上面的<code>curried</code>函数中，返回一个入参为<code>CGFloat</code>类型，返回类型为<code>UIImage</code>的方法。如果使用一个变量来接收该函数，调用该函数的时候需要传入一个参数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> maker = makeRoundedRectangleMaker(CGSize(width:<span style="color:#ae81ff">45</span>, height:<span style="color:#ae81ff">20</span>)) 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">self</span>.iv.image = maker(<span style="color:#ae81ff">8</span>)
</span></span></code></pre></div><p>如果上面定义的<code>maker</code>没有在其它地方使用，上面的代码可以合并为一行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">self</span>.iv.image = makeRoundedRectangleMaker(CGSize(width:<span style="color:#ae81ff">45</span>, height:<span style="color:#ae81ff">20</span>))(<span style="color:#ae81ff">8</span>)
</span></span></code></pre></div><h2 id="function-references-and-selectors">Function References and Selectors</h2>
<p>如果想通过名字引用一个函数，可能是为了将其作为参数传递给另一个函数。在Swift中，通常可以使用函数的裸名<code>bare name</code>来实现这一点。函数的<code>bare name</code>指的是函数名字（只包括函数名字不包含其它）。下面代码中<code>whatToAnimate</code>和<code>whatToDoLater</code>都是函数的<code>bare name</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">whatToAnimate</span>() { 
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;animations&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">whatToDoLater</span>(finished: Bool) {
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;finished: </span><span style="color:#e6db74">\(</span>finished<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>UIView.animate(withDuration: <span style="color:#ae81ff">0.4</span>, animations: whatToAnimate, completion: whatToDoLater) 
</span></span></code></pre></div><p>在上面的代码中<code>whatToAnimate</code>和<code>whatToDoLater</code>也是函数的引用。它只由函数的名字组成，也就是<code>func</code>关键字后，参数列表括号前的那个函数名。<font color=Blue>没有圆括号表明这是一个引用，而不是一个调用</font>。</p>
<p>在没有歧义的情况下，使用<code>bare name</code>作为函数的引用是合法的。上面的代码中，在这个特定的上下文中只有一个叫<code>whatToDoLater</code>的函数，因此能在一个参数类型已知的函数调用中使用<code>bare name</code>作为参数。</p>
<p>我们<font color=LightSeaGreen>既可以将函数作为参数传递，也可以将函数赋值给一个变量或者常量</font>。下面的代码中，定义了两个相同名字的函数，一个接受参数，一个不接受参数，直接使用<code>bark</code>可能会产生歧义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;woof&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>(<span style="color:#66d9ef">_</span> loudly: Bool) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> loudly {
</span></span><span style="display:flex;"><span>            debugPrint(<span style="color:#e6db74">&#34;WOOF&#34;</span>)
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            bark()
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> barkFunction = bark <span style="color:#75715e">// compile error </span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面的代码将会出现编译错误，因为同时存在两个名为<code>bark</code>的函数，此时编译器不清楚到底要引用哪个。为了解决这个问题，<code>Swift</code>提供了一种表示法，它可以更精确地引用函数，标注包含两个部分：</p>
<ul>
<li>
<p><code>full name</code>:此处翻译为全名，对于有参数的函数的全名包括函数的名字，一对圆括号，以及<font color=red>外部参数列表</font>，其中**<font color=LightSeaGreen>外部参数列表使用冒号(<font color=red>没有逗号或空格</font>)</font>**。如果外部参数被<code>suppressed</code>（即定义的时候使用下划线），则使用下划线代替。对于没有参数的函数的全名就是它的<code>bare name</code>。</p>
</li>
<li>
<p>签名: 一个函数的签名可以用关键字<code>as</code>作用到其<code>bare name</code>或<code>full name</code>上。</p>
</li>
</ul>
<p>例如，函数<code>func say(_ s:String, times:Int) {...}</code>可以使用全名<code>say(_:times:)</code>来标注，也可使用<code>bare name</code>和签名:<code>say as (String, Int) -&gt; ()</code>来标注。</p>
<p>在上面的代码中，如果使用<code>let barkFunction = bark(_:) </code>编译器就不会报错，因为已经指定了函数<code>bark</code>为接受一个参数的那个。</p>
<p>但如果要引用无参数的<code>bark</code>函数，因为无参的那个函数的裸名和全名均为<code>bark</code>（不包括圆括号，无参数的函数加上圆括号就是函数调用了），直接使用仍然会报错，因为编译器无法区分要引用哪个函数，此时应该使用<code>as</code>和函数签名：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;woof&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>(<span style="color:#66d9ef">_</span> loudly: Bool) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> loudly {
</span></span><span style="display:flex;"><span>            debugPrint(<span style="color:#e6db74">&#34;WOOF&#34;</span>)
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            bark()
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> barkFunction = bark <span style="color:#66d9ef">as</span> () -&gt; ()  <span style="color:#75715e">// 使用函数签名</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>下面的代码中，定义了三个<code>bark</code>函数，其中有两个都接受一个参数，并且外部参数名都被省略了。如果此时使用<code>let barkFunction = bark(_:)</code>仍然会出现编译错误，因为编译器无法确定要调用哪个<code>bark</code>，因为此时有两个带参数的<code>bark</code>，它们的<code>fullname</code>均为<code>bark(_:)</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>(<span style="color:#66d9ef">_</span> loudly: Bool) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>(<span style="color:#66d9ef">_</span> times: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> barkFunction = bark(<span style="color:#66d9ef">_</span>:) <span style="color:#75715e">// compile error</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>此时需要使用<code>as</code>和函数签名才能确定到底要使用哪个<code>bark</code>，即<code>let barkFunction = bark as (Int) -&gt; ()</code>转换为接受<code>Int</code>的那个<code>bark</code>，编译才不会报错。或者直接指定<code>barkFunction</code>为<code>(Int) -&gt; ()</code>类型。</p>
<h2 id="function-reference-scope">Function Reference Scope</h2>
<p>在前面的代码中，在使用函数引用时，没有告知编译器函数是在哪定义的，<font color=LightSeaGreen>这是因为函数定义和函数引用在同一个作用域内</font>。也就是说，如果<font color=LightSeaGreen>可以在不提供进一步信息的情况下调用该函数，就可以在不提供进一步信息的情况下形成函数引用</font>。</p>
<p>函数引用可以提供关于函数在哪定义的更多信息，而且有时必须这样做。这可以通过在函数引用前<font color=red>加一个实例或类，然后后面紧接着点操作符来实现</font>。有些情况下，编译器会强制要求使用<code>self</code>来引用一个函数，在这些情况下必须这样做：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;bark&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>(<span style="color:#66d9ef">_</span> loudly: Bool) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> loudly {
</span></span><span style="display:flex;"><span>            debugPrint(<span style="color:#e6db74">&#34;WOOF&#34;</span>)
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            debugPrint(<span style="color:#e6db74">&#34;woof&#34;</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> f = {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 使用了self</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">self</span>.bark(<span style="color:#66d9ef">_</span>:) <span style="color:#75715e">// self required here</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// f是一个函数，无参数，但是返回一个函数</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> tmpBark = f() <span style="color:#75715e">// 执行函数，得到一个新的函数</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 传入参数调用新的函数</span>
</span></span><span style="display:flex;"><span>        tmpBark(<span style="color:#66d9ef">false</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> tmpDog = Dog()
</span></span><span style="display:flex;"><span>tmpDog.test() <span style="color:#75715e">// woof</span>
</span></span></code></pre></div><p>如果要形成对<font color=LightSeaGreen>另一个类型实例方法的函数引用</font>，可以有两个方法。如果当前有一个该类型的实例，可以**<font color=red>使用点操作符实现对该实例的引用</font>**：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Cat</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">purr</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;purr&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> cat = Cat()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> purrFunction = cat.purr
</span></span><span style="display:flex;"><span>        purrFunction()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>下面代码，先定义了一个<code>Test</code>类，然后生成一个新的实例，使用该实例来引用函数，将其赋值给一个常量，再使用该常量直接调用函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Test</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">var</span> test = <span style="color:#e6db74">&#34;test&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">testFunc</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">var</span> name: String {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;name&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">func</span> nameFunc() {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">testNew</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;testNew&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> test = Test()
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> test1 = test.testNew
</span></span><span style="display:flex;"><span>test1()
</span></span></code></pre></div><p>另一种可能的方式是使用**<font color=red>类型和点操作符来获取函数的引用，即使函数是实例方法也是适用的</font>**。但是下面的代码需要使用函数签名来消除歧义。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Cat</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">purr</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;purr&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>       debugPrint(<span style="color:#e6db74">&#34;bark&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> barkFunction = Dog.bark <span style="color:#75715e">// legal but not necessary </span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> purrFunction = Cat.purr
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面的<code>barkFunction</code>和<code>purrFunction</code>方法并不能直接调用，必须借助一个<code>Dog</code>或<code>Cat</code>实例才可以调用该方法，如下所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Swift" data-lang="Swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Cat</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">purr</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;purr&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;bark&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> barkFunction = Dog.bark
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> purrFunction = Cat.purr
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        barkFunction(<span style="color:#66d9ef">self</span>)()
</span></span><span style="display:flex;"><span>        purrFunction(Cat())()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果使用类型和点操作符来获取函数引用，并且<font color=LightSeaGreen>需要借助函数签名来消除函数引用的歧义时，那么函数签名必须是描述实例方法的柯里化静态/类版本</font>(<code>the signature must describe the curried static/class version of the instance method</code>)：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Cat</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">purr</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;purr&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">purr</span>(<span style="color:#66d9ef">_</span> loudly: Bool) {
</span></span><span style="display:flex;"><span>         debugPrint(<span style="color:#e6db74">&#34;loudly </span><span style="color:#e6db74">\(</span>loudly<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> cat = Cat()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> purrFunc = Cat.purr <span style="color:#66d9ef">as</span> (Cat) -&gt; () -&gt; Void <span style="color:#75715e">// 柯里版本，参数为类型，返回一个函数</span>
</span></span><span style="display:flex;"><span>        debugPrint(purrFunc)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> tmpFunc = purrFunc(cat)
</span></span><span style="display:flex;"><span>        tmpFunc() <span style="color:#75715e">// 调用purr方法</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="selectors">Selectors</h2>
<p>在<code>Objective-C</code>中<code>selector</code>是一种方法引用。在<code>iOS</code>编程中，可能会调用一个<code>Cocoa</code>方法，这个方法需要一个<code>selector</code>作为它的某个参数。通常，此参数被命名为<code>selector:</code>或<code>action:</code>。</p>
<p>通常这样的<code>Cocoa</code>方法也需要提供一个<code>target</code>（一个对象的引用）。运行时可以<font color=red>将<code>selector</code>变成一个消息，并将该消息发送给这个<code>target</code>以调用该方法</font>。</p>
<p>为了形成<code>selector</code>，需要构建一个代表方法的<code>Objective-C</code>字符串。这种方式是十分危险的，如果错误地构建了代表方法的字符串，那么向<code>target</code>发送消息时，<font color=Blue>因为<code>target</code>没有这样的方法，运行时将发现<code>target</code>不能处理这个消息</font>，此时应用程序会突然<code>crash</code>，并向控制台发送<code>unrecognized selector</code>消息。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ViewController</span>: UIViewController {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">@IBOutlet</span> <span style="color:#66d9ef">var</span> button: UIButton!
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">viewDidLoad</span>() {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">super</span>.viewDidLoad()
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// prepare to crash</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.button.addTarget(<span style="color:#66d9ef">self</span>, action: <span style="color:#e6db74">&#34;buttonPressed&#34;</span>, <span style="color:#66d9ef">for</span>: .touchUpInside)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">@objc</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">buttonPressed</span>(<span style="color:#66d9ef">_</span> sender: Any) {
</span></span><span style="display:flex;"><span>         debugPrint(<span style="color:#e6db74">&#34;buttonPressed&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在上面的代码中<code>self.button</code>是界面上的一个按钮，通过调用<code>addTarget(action:for:)</code>来设置按钮的响应事件，使得当按钮点击时可以调用<code>buttonPressed</code>方法。</p>
<p>但是，上面的方法字符串是错误的，因为<code>buttonPressed</code>不是<code>Objective-C</code>的方法字符串，正确的方法名称字符串应该是<code>buttonPressed:</code>。如果运行上面代码会导致按钮点击的时候发生崩溃。</p>
<p>如果不知道形成<code>selector</code>字符串的规则，或者即使知道，但输入时不注意犯了一个小错误，都有可能导致<code>unrecognized selector</code>崩溃。人在输入时是很容易犯错，因此<code>unrecognized selector</code>崩溃历来在<code>iOS</code>程序员中极为常见。</p>
<p><code>Swift</code>编译器在这方面并不容易出错，它提供了一种方法，即通过<code>#selector(...)</code>语法可以生成一个<code>Objective-C</code>的<code>selector</code>，<strong><font color=red>括号里面的是函数的引用</font></strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ViewController</span>: UIViewController {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">@IBOutlet</span> <span style="color:#66d9ef">var</span> button: UIButton!
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">viewDidLoad</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">super</span>.viewDidLoad()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.button.addTargett(<span style="color:#66d9ef">self</span>, action: <span style="color:#66d9ef">#selector</span>(buttonPressed), <span style="color:#66d9ef">for</span>: .touchUpInside)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">@objc</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">buttonPressed</span>(<span style="color:#66d9ef">_</span> sender: Any) {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;buttonPressed&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面的代码中使用<code>#selector(...)</code>时，编译器会做两件事情：</p>
<ul>
<li>
<p>编译器会检查函数引用是否合法，如果不合法则会出现编译错误。<strong><font color=red>同时会检查这个函数是否暴露给<code>Objective-C</code></font></strong>。为一个<code>Objective-C</code>看不到的方法形成一个<code>selector</code>是没有意义的，因为如果<code>Objective-C</code>试图调用这样一个方法，应用程序会崩溃。在<code>Swift</code>为了确保对<code>Objective-C</code>是可见的，该方法需要标记为<code>@objc</code>。</p>
</li>
<li>
<p>如果使用<code>#selector</code>的代码能够编译，将保证将传递给此参数的实际选择器是正确的。手动写方法字符串可能会形成错误的选择器，但编译器不会，它所产生的<code>selector</code>不可能与方法不匹配，也不可能出现<code>unrecognized selector</code>崩溃。</p>
</li>
</ul>
<p>尽管十分少见，但在某些情况下，可能需要手动创建一个选择器。要做到这一点可以使用一个方法字符串，或者可以用字符串作为参数来实例化<code>Selector</code>类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>Selector(<span style="color:#e6db74">&#34;woohoo:&#34;</span>)
</span></span></code></pre></div><p>使用<code>#selector(...)</code>语法，仍然*<font color=red>可能通过向错误的<code>target</code>发送<code>action</code>信息而发送崩溃</font>*。在前面的例子中，如果把<code>addTarget</code>调用的第一个参数<code>self</code>改为<code>self.button</code>，将会在运行时以<code>unrecognized selector</code>崩溃。因为<code>buttonPressed</code>方法是在<code>ViewController</code>中声明的，而不是在<code>UIButton</code>类型中声明的。</p>
<h1 id="variables-and-simple-types">Variables and Simple Types</h1>
<p>变量是一个具名的<code>shoebox</code>，其包含的值<font color=red>必须是单一的并且是已经定义好的类型</font>，每个变量都必须事先明确且正式地声明。如果想要将值放入<code>shoebox</code>中，以使用变量名引用该值，那么可以将值赋给该变量。此后，<font color=Blue>这个变量名便成为该值的引用</font>。</p>
<p>一个变量不仅给它所指对象一个名字，还根据声明的位置赋予它所指对象特定的作用域（可见性）和生命周期。给变量赋值是一种确保这个值能被需要看到它的代码能看到它的一种方式。作用域和生命周期分为三个层次：全局变量，属性，局部变量。</p>
<p>全局变量声明在<code>Swift</code>文件顶部，它的生命周期和所在文件一样长。一个全局变量默认（<code>internal</code>访问权限）<font color=red>在它声明所在<code>module</code>任何地方都是可见的</font>，这就是全局的意思。它对同一文件中的所有代码都是可见的，因为它处于最高级别。</p>
<p>此外，默认情况下全局变量对于<font color=Blue>同一模块中任何其它文件中的所有代码也都是可见的</font>，因为同一模块中的<code>Swift</code>文件可以自动看到彼此，所以也可以看到彼此顶层声明的全局变量：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#75715e">// File1:</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> globalVariable = <span style="color:#e6db74">&#34;global&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">debugPrintGlobal</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(globalVariable) 
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// File2: </span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Cat</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">debugPrintGlobal</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(globalVariable) 
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>属性是在对象类型声明（枚举、结构或类）的<font color=red>顶层中声明的变量</font>。有两种类型属性，一种是实例属性，另一种是静态/类属性。如果属性声明时未加<code>static</code>或<code>class</code>关键字，就是实例属性，也就是说属性默认是实例属性。</p>
<p><font color=LightSeaGreen>实例属性的值对于每个实例来说都可以是不同的，它的生命周期和实例的生命周期相同</font>。一个实例是对一个对象类型实例化而来，该实例以及其属性的生命周期主要取决于赋值的变量的生命周期。</p>
<p>如果一个属性在声明时加上<code>static</code>或<code>class</code>，就是静态/类属性，它的生命周期和该<font color=red>对象类型的生命周期相同</font>。如果对象类型声明在一个文件的顶层，那么<font color=red>只要该静态/类属性使用过一次，那么该属性就会一直存在</font>。</p>
<p>属性<font color=red>只能通过对象才能看到</font>，<font color=Blue>对象的方法能够直接看到属性</font>，在方法内部可以使用<code>self.x</code>这种方式访问实例属性。默认情况下，实例属性对于其它代码也是可见的，前提是要有这个实例的引用。同样地，默认情况下，一个静态/类属性对其它可以看到这个对象类型的代码也都是可见的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#75715e">// File1:</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> staticProperty = <span style="color:#e6db74">&#34;staticProperty&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> instanceProperty = <span style="color:#e6db74">&#34;instanceProperty&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">debugPrintInstanceProperty</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#66d9ef">self</span>.instanceProperty)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// File2: </span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Cat</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">debugPrintDogStaticProperty</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(Dog.staticProperty) 
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">debugPrintDogInstanceProperty</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> dog = Dog()
</span></span><span style="display:flex;"><span>        debugPrint(dog.instanceProperty) 
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>局部变量是指<font color=red>声明在花括号内部的变量，它的生命周期与包含它的花括号一样长</font>。当程序执行到局部变量声明的范围时，局部变量才会真正生成，当程序执行离开这个范围时，局部变量就会自动消失。</p>
<p>有时，<font color=red>局部变量也被称为自动变量，以表示它们会自动出现和消失</font>。一个局部变量只能被同一作用域中的后续代码看到（也包括同一作用域中后续更深层次的作用域）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">printLocalVariable</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> localVariable = <span style="color:#e6db74">&#34;local&#34;</span>
</span></span><span style="display:flex;"><span>        print(localVariable)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="variable-declaration">Variable Declaration</h2>
<p>变量声明时使用关键字<code>let</code>或者<code>var</code>。使用<code>let</code>声明的是常量，常量的意思是<font color=red>当第一次被赋值之后就不再允许被修改</font>。<font color=LightSeaGreen>使用<code>var</code>声明的变量是真正的变量</font>，它的值可以通过后续赋值来改变。</p>
<p>一个变量的声明常常伴随着初始化，即使用操作符<code>=</code>赋一个值给变量。但在<code>Swift</code>中**<font color=Blue>变量声明时没有强制立即初始化，即使使用<code>let</code>关键字声明也一样</font>**。</p>
<p>对于<code>let x : Int</code>这样的声明是完全合法的。可以后面再给这个变量分配一个初始值，因为这个特殊的变量是一个常量，<font color=LightSeaGreen>所以一旦有了初始值，那么这个初始值将是它以后的唯一值，不能再被改变</font>。</p>
<p>声明一个变量而没有指定类型是不合法的，<font color=red>变量必须从一开始就具有一个类型，并且永远不能更改该类型</font>。用<code>var</code>声明的变量可以通过赋值改变它的值，但新值必须同变量的类型一样。</p>
<h3 id="explicit-variable-type-declaration">Explicit variable type declaration</h3>
<p>变量声明时，在名称之后添加一个冒号和类型的名称，就是显式变量类型声明：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> x : Int
</span></span></code></pre></div><h3 id="implicit-variable-type-by-initialization">Implicit variable type by initialization</h3>
<p>如果将变量初始化为声明的一部分，并且没有提供明确的类型，<code>Swift</code>会根据它被初始化的值来推断变量的类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> x = <span style="color:#ae81ff">1</span> <span style="color:#75715e">// and now x is an Int</span>
</span></span></code></pre></div><p>完全可以一次性显式声明变量的类型并为其分配初始值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> x : Int = <span style="color:#ae81ff">1</span>
</span></span></code></pre></div><p>在上面的代码中，显式的类型声明是多余的，因为<font color=red>大多数情况变量类型可以从初始值推断出来</font>。但有些情况，即使在有初始值的情况下显式声明一个类型也不是多余的。</p>
<p>第一种场景是<code>Swift</code>推断出来的类型是错误的。一种常见的场景是使用数字字面量作为初始值，<code>Swift</code>编译器会将它们推断为<code>Int</code>或<code>Double</code>类型（区别为是否有小数点），但实际上有很多数字类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> value : Float = <span style="color:#ae81ff">2.0</span>  <span style="color:#75715e">// 带小数点的数字字面量2.0默认是Double类型</span>
</span></span></code></pre></div><p>另一种场景是如果不明确地告诉编译器变量的类型，编译器就无法通过初始值推断出类型。一个常见的场景是<code>options</code>集合：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> opts = [.autoreverse, .<span style="color:#66d9ef">repeat</span>] <span style="color:#75715e">// compile error: Reference to member &#39;autoreverse&#39; cannot be resolved without a contextual type</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> opts : UIView.AnimationOptions = [.autoreverse, .<span style="color:#66d9ef">repeat</span>]
</span></span></code></pre></div><p>即使编译器<font color=red>可以从变量的初始值正确推断出变量的类型，这种推断也是需要时间的</font>。因此，在变量声明时提供显式类型可以<font color=Blue>减少编译时间</font>。</p>
<p>如前所述，即使声明的变量是常量，也不必在声明时对其进行初始化，即下面的写法是合法的，不会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> x : Int
</span></span></code></pre></div><p>现在<code>x</code>是一个空的<code>shoebox</code>，即没有初始值的<code>Int</code>变量，<font color=LightSeaGreen>可以稍后为该变量分配一个初始值</font>。由于这个特定的变量是一个常量，从赋值那刻起，该初始值将是它的唯一值，之后不能再被改变。</p>
<p>对于<font color=Blue>属性来说，先声明后初始化是很常见的</font>，因为属性的初始化可以通过对象类型的初始化函数来实现。但对于局部变量来说，通常是声明的时候同时初始化。</p>
<p>当局部变量遇到需要<code>conditional initialization</code>时，也可以先声明后初始化。这是因为，有时在进行某种条件测试之前，并不知道某个变量的初始值。因为变量只能声明一次，所以它必须提前声明，之后再进行条件初始化：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> timed: Bool
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> val == <span style="color:#ae81ff">1</span> {
</span></span><span style="display:flex;"><span>    timed = <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    timed = <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果<font color=red>一个变量的地址被当作参数传递给一个函数时</font>，这个变量必须在传递之前先声明并且在传递之前已经被初始化，也就是说<font color=LightSeaGreen>即使初始化值是假的占位符也必须先给一个初始值</font>，否则会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> r: CGFloat = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> g: CGFloat = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> b: CGFloat = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> a: CGFloat = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>c.getRed(&amp;r, green: &amp;g, blue: &amp;b, alpha: &amp;a)
</span></span></code></pre></div><p>在上面的代码中，<code>4</code>个<code>CGFloat</code>传入到<code>getRed</code>中后，它们的值可能会被改变。而<font color=Blue>给定的初始值只是临时占位符</font>，用以满足编译器的要求。</p>
<p>特别需要注意的是：<font color=red>传入到函数的普通参数，也必须先初始化</font>，否则编译器也会报错。下面代码中<code>tt1</code>未初始化就传入到<code>oneParameter</code>会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">oneParameter</span>(test: String)
</span></span><span style="display:flex;"><span>    debugPrint(test)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> tt1: String
</span></span><span style="display:flex;"><span>oneParameter(test: tt1) <span style="color:#75715e">// 出现编译错误：Variable &#39;tt1&#39; used before being initialized</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">oneParameter</span>(test: String) {
</span></span><span style="display:flex;"><span>    debugPrint(test)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> tt2: String = <span style="color:#e6db74">&#34;name&#34;</span> <span style="color:#75715e">// 传递给函数前进行了初始化，不再出现编译错误</span>
</span></span><span style="display:flex;"><span>oneParameter(test: tt2)
</span></span></code></pre></div><p>如果一个变量需要传入到以<code>inout</code>修饰的函数参数中，必须使用<code>var</code>声明，并且传入前也必须先初始化（与变量地址传入那一类相似）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">testMain</span>(test: <span style="color:#66d9ef">inout</span> String) {
</span></span><span style="display:flex;"><span>    test = <span style="color:#e6db74">&#34;name&#34;</span>
</span></span><span style="display:flex;"><span>    debugPrint(test)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> newTest :String
</span></span><span style="display:flex;"><span>testMain(test: &amp;newTest) <span style="color:#75715e">// 编译错误：Variable &#39;newTest&#39; passed by reference before being initialized</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> newTest1 :String = <span style="color:#e6db74">&#34;name&#34;</span>
</span></span><span style="display:flex;"><span>testMain(test: &amp;newTest1)
</span></span></code></pre></div><p>极少数情况下，会遇到这样一种情况：调用一个有返回值的<code>Cocoa</code>方法，然后在传递给这个方法的函数参数中又要使用这个返回值。<code>Cocoa</code>有一个<code>UIApplication</code>实例方法是下面这样声明的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">beginBackgroundTask</span>(expirationHandler handler: (() -&gt; Void)? = <span style="color:#66d9ef">nil</span>) -&gt; UIBackgroundTaskIdentifier
</span></span></code></pre></div><p>上面的<code>beginBackgroundTask(expirationHandler:)</code>会返回一个<code>UIBackgroundTaskIdentifier</code>对象，然后会在<code>expirationHandler</code>函数中使用这个对象。<code>Swift</code>的安全规则<font color=Blue>不允许在一条语句中声明变量，同时又在声明语句中的匿名函数中使用它</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> bti = UIApplication.shared.beginBackgroundTask {
</span></span><span style="display:flex;"><span>    UIApplication.shared.endBackgroundTask(bti)
</span></span><span style="display:flex;"><span>} 
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Closure captures &#39;bti&#39; before it is declared</span>
</span></span></code></pre></div><p>因此，需要提前声明变量。在上面的代码中，如果只是提前声明变量，依然会有问题，编译时会报<code>variable captured by a closure before being initialized</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> bti: UIBackgroundTaskIdentifier
</span></span><span style="display:flex;"><span>bti = UIApplication.shared.beginBackgroundTask {
</span></span><span style="display:flex;"><span>    UIApplication.shared.endBackgroundTask(bti)
</span></span><span style="display:flex;"><span>} 
</span></span><span style="display:flex;"><span><span style="color:#75715e">// error: variable captured by a closure before being initialized</span>
</span></span></code></pre></div><p>一种解决方案是提前声明变量，并且<font color=LightSeaGreen>声明时给变量一个假的初始值作为占位符</font>。如下所示，给了变量<code>bti</code>一个假的初始值<code>.invalid</code>用来占位：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> bti: UIBackgroundTaskIdentifier = .invalid
</span></span><span style="display:flex;"><span>bti = UIApplication.shared.beginBackgroundTask() {
</span></span><span style="display:flex;"><span>    UIApplication.shared.endBackgroundTask(bti)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这里真正的问题是<code>beginBackgroundTask</code>相当古老了，更现代的方法是将返回值直接传递给函数作为参数。<code>Cocoa</code>的<code>UIAction</code>初始化方法<code>init(title:handler:)</code>就是一个例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> myAction = UIAction(title: <span style="color:#e6db74">&#34;Hello&#34;</span>) { action <span style="color:#66d9ef">in</span> 
</span></span><span style="display:flex;"><span>      print(action)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在上面的代码中，<code>action</code>就是<code>myAction</code>，因此在匿名函数参数<code>handler:</code>中可以直接引用<code>action</code>，而不使用<code>myAction</code>（<font color=red>这种方法还可以防止可能的循环引用</font>）。</p>
<p>在<code>UIAction</code>初始化器中的<code>handler</code>参数中使用<code>myAction</code>是非法的，下面代码会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> myAction = UIAction(title: <span style="color:#e6db74">&#34;Hello&#34;</span>) { action <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> myAction === action {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;test&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    print(action)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Closure captures &#39;myAction&#39; before it is declared</span>
</span></span></code></pre></div><h2 id="computed-variable-initialization">Computed Variable Initialization</h2>
<p>有时需要先执行一些代码去才能获得变量的初始值，一个简洁的解决方案是<font color=red>定义和调用匿名函数来进行初始化</font>，这种方式称为<code>define-and-call initializer</code>。下面代码中定义了一个匿名函数并立即执行来初始化常量<code>timed</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> val = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> timed: Bool = {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> val == <span style="color:#ae81ff">1</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}()
</span></span></code></pre></div><p>当一个实例属性也需要执行一些代码去获得初始值时，也可以使用<code>define-and-call initializer</code>进行初始化。下面的<code>cellBackgroundImage</code>属性需要用到多次，但初始化时需要执行一些其它代码，因此通过定义和调用一个匿名函数来初始化这个属性：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">RootViewController</span>: UITableViewController {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> cellBackgroundImage: UIImage = {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> imageOfSize(CGSize(width: <span style="color:#ae81ff">320</span>, height: <span style="color:#ae81ff">44</span>)) { 
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// ... drawing goes here ...</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }() 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>你可能会好奇，与其使用<code>define-and-call initializer</code>，<font color=red>为什么不直接定义一个实例方法来初始化实例属性</font>。因为定义一个实例方法来初始化实例属性是非法的，将会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">RootViewController</span>: UITableViewController {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Cannot use instance member &#39;self&#39; within property initializer; property initializers run before &#39;self&#39; is available</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> cellBackgroundImage: UIImage = <span style="color:#66d9ef">self</span>.makeTheImage() 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">makeTheImage</span>() -&gt; UIImage {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> imageOfSize(CGSize(width: <span style="color:#ae81ff">320</span>, height: <span style="color:#ae81ff">44</span>)) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// ... drawing goes here ...</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>因为<font color=red>实例属性声明初始化时，此时实例尚未生成</font>。因此，<font color=LightSeaGreen>不能在属性声明初始时引用<code>self</code></font>。但定义和调用匿名函数是合法的，需要注意的是<font color=Blue>定义和调用匿名函数仍然不能在函数体中隐式或显式引用<code>self</code></font>，否则也会出现编译错误，如果需要在函数体中使用<code>self</code>，需要将属性声明为<code>lazy</code>。</p>
<h2 id="computed-variables">Computed Variables</h2>
<p>除了正常的存储变量，<code>Swift</code>中的变量还可以是计算的。这意味着变量不是一个值，而是一个函数。计算变量中包括<code>setter</code>和<code>getter</code>函数，<code>setter</code>函数在变量被赋值自动调用，<code>getter</code>函数在变量被引用时自动调用:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> now: String { <span style="color:#75715e">// ①</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">get</span> { <span style="color:#75715e">// ② </span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Date().description <span style="color:#75715e">// ③</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">set</span> { <span style="color:#75715e">// ④</span>
</span></span><span style="display:flex;"><span>        debugPrint(newValue) <span style="color:#75715e">// ⑤</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol>
<li>变量<font color=red>必须使用<code>var</code>声明（不能使用<code>let</code>），并且变量类型必须显式声明</font>，类型后面紧跟花括号。</li>
<li>其中的<code>getter</code>函数被称为<code>get</code>。<code>getter</code>函数没有正式的函数声明，<code>get</code>这个词后面紧跟着花括号中的函数体。</li>
<li>其中的<code>getter</code>函数必须返回一个与该变量类型相同的值。<font color=red>从<code>Swift 5.1</code>开始，当<code>getter</code>只有一个单一语句时，省略关键字<code>return</code>是合法的</font>。</li>
<li>其中的<code>setter</code>函数被称为<code>set</code>。<code>setter</code>函数也没有正式的函数声明，<code>set</code>这个词后面紧跟着函数体。</li>
<li>其中<code>setter</code>函数就像接受一个参数的函数。默认情况下，该参数以<code>newValue</code>这个名字进入<code>setter</code>函数体中。</li>
</ol>
<p>对待计算变量可以与任何其它变量相同。如果要赋值给变量，能够直接赋值给它；如果要使用变量，能够直接引用它。但是，在幕后是调用了<code>setter</code>和<code>getter</code>函数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>now = <span style="color:#e6db74">&#34;Howdy&#34;</span> <span style="color:#75715e">// Howdy</span>
</span></span><span style="display:flex;"><span>print(now) <span style="color:#75715e">// 2022-08-07 04:03:21 +0000</span>
</span></span></code></pre></div><ul>
<li>赋值给<code>now</code>时，<code>setter</code>函数将被自动被调用，参数就是将要赋的值。在上面的代码就是<code>Howdy</code>，该值作为参数<code>newValue</code>的实参传到<code>set</code>函数。</li>
<li>获取<code>now</code>的值时，<code>getter</code>将被自动调用。</li>
</ul>
<p>对于<code>setter</code>函数来说，默认的参数名可以不是<code>newValue</code>。如果需要指定一个不同的名称，<font color=Blue>把新名字放在<code>set</code>后面的括号里就可以</font>，下面代码用新名字<code>val</code>代替默认的<code>newValue</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> nowTest: String = <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> now: String {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">get</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;test&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">set</span>(val) {
</span></span><span style="display:flex;"><span>        nowTest = val
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果<code>setter</code>函数省略，那么这个计算变量就成为了一个只读变量，等同于一个<code>let</code>常量，一旦试图去改变这个变量的值就会出现编译错误:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> newDate: String {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> Date().description
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>newDate = <span style="color:#e6db74">&#34;ddd&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Cannot assign to property: &#39;newDate&#39; is a get-only property</span>
</span></span></code></pre></div><p>即使只有一个<code>getter</code>函数，<font color=red>计算变量声明时也必须使用<code>var</code></font>。计算变量<font color=red>必须有一个<code>getter</code>函数。如果计算变量中没有<code>setter</code>函数</font>，<code>get</code>这个词和它后面的花括号可以省略。如果<code>get</code>中只有一行，<code>return</code>也可以省略：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> now: String {
</span></span><span style="display:flex;"><span>    Date().description
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="computed-properties">Computed Properties</h2>
<p>在实际的编程中，对于<font color=LightSeaGreen>计算变量的使用场景几乎都是实例属性</font>。当一个值在每次需要使用时可以<font color=red>很容易地计算</font>出来，将其表达为一个只读的计算变量往往更简单，实际上<font color=Blue>这是对一个较长表达式的速记法</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> mp: MPMusicPlayerController {
</span></span><span style="display:flex;"><span>    MPMusicPlayerController.systemMusicPlayer
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> nowPlayingItem: MPMediaItem? {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">self</span>.mp.nowPlayingItem
</span></span><span style="display:flex;"><span>}   
</span></span></code></pre></div><p>一个计算变量的<code>getter</code>函数<font color=red>可以封装多行代码，其实质是把一个方法变成了一个属性</font>。下面是从<code>xml</code>文件中提取作者信息，本可以将其声明为方法<code>func authorOfItem() -&gt; String?</code>，但方法表达了一个过程，而计算属性则能更直观地描述它是一个事物：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> authorOfItem: String? {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">guard</span> <span style="color:#66d9ef">let</span> authorNodes = <span style="color:#66d9ef">self</span>.extensionElements(withXMLNamespace: <span style="color:#e6db74">&#34;http://www.tidbits.com/dummy&#34;</span>, elementName: <span style="color:#e6db74">&#34;app_author_name&#34;</span>) <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">guard</span> <span style="color:#66d9ef">let</span> authorNode = authorNodes.last <span style="color:#66d9ef">as</span>? FPExtensionNode <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> authorNode.stringValue
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>一个计算变量可以位于一个或多个存储变量的前面，<font color=Blue>充当这些存储变量设置和获取时的守门员</font>，这与<code>Objective-C</code>的的访问器类似。通常，一个计算变量由一个私有的存储变量来支持：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">var</span> _pp: Int = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> pp: Int {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">get</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>._pp
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">set</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>._pp = newValue
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面代码是合法的，但是毫无意义。当在获取或设置存储变量的同时做其它事情的时候，存储变量的幌子变得有用了。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">var</span> _pp: Int = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> pp: Int {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">get</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>._pp
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">set</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>._pp = max(min(newValue, <span style="color:#ae81ff">5</span>), <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>一个实例的<font color=LightSeaGreen>计算属性<code>getter</code>函数或<code>setter</code>函数可以引用其它实例成员</font>。这一点很重要，因为一般来说，存储属性的初始化时不能引用<code>self</code>。对于一个计算属性来说，隐式或显式使用<code>self</code>合法的，<em><font color=red>因为<code>getter</code>或<code>setter</code>函数在实例实际生成前不会被调用</font></em>。</p>
<h2 id="property-wrappers">Property Wrappers</h2>
<p>如果有几个带有存储变量幌子的计算属性实际上做了同样的事情，那么最终将会有大量的重复代码。如果能把这些共同的功能移到一个地方就更好了。实际上，可以用一个属性包装器来实现。</p>
<p>一个属性包装器是在声明结构体时标记<code>@propertyWrapper</code>，并且必须有一个<code>wrappedValue</code>的计算属性。下面是一个实现<code>&quot;clamped&quot;</code>模式的属性包装器。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>@propertyWrapper <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Clamped</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">var</span> _i: Int = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> wrappedValue: Int {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">get</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">self</span>._i
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">set</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">self</span>._i = Swift.max(Swift.min(newValue, <span style="color:#ae81ff">5</span>), <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面声明的结果是，现在可以声明一个用自定义属性标记的计算属性，该属性的名称与该结构(<code>@Clamped</code>) 相同，没有<code>getter</code>或<code>setter</code>函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>@Clamped <span style="color:#66d9ef">var</span> p
</span></span></code></pre></div><p>上面的属性<code>p</code>不需要被初始化，因为它是一个计算属性，也不需要<code>getter</code>或<code>setter</code>函数。实际上，它都不需要类型声明，因为<code>Clamped</code>结构体的<code>wrappedValue</code>计算属性提供了类型。</p>
<p>多亏了属性包装器，我们封装了计算属性，这意味着可以声明另外一个<code>@Clamped</code>属性。此外，这个模式现在有了一个名字：声明<code>@Clamped var</code>告诉我们这个计算属性的行为将会是什么。</p>
<h2 id="setter-observers">Setter Observers</h2>
<p>计算变量并不经常需要作为一个存储变量的幌子。这是因为<code>Swift</code>有另一个功能，可以在<font color=red>存储变量</font>的<code>setter</code>函数中注入<code>setter observers</code>功能。</p>
<p><code>setter observers</code>是<font color=Blue>在设置存储变量之前和之后调用的函数</font>。即在存储变量中添加一个<code>willSet</code>函数，或一个<code>didSet</code>函数，或两者均有：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> s = <span style="color:#e6db74">&#34;whatever&#34;</span> { <span style="color:#75715e">// ①</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">willSet</span> { <span style="color:#75715e">// ②</span>
</span></span><span style="display:flex;"><span>        debugPrint(newValue) <span style="color:#75715e">// ③</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">didSet</span> { <span style="color:#75715e">// ④</span>
</span></span><span style="display:flex;"><span>        debugPrint(oldValue) <span style="color:#75715e">// ⑤</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// self.s = &#34;something else&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol>
<li>
<p>变量<font color=red>必须使用<code>var</code>声明</font>，不能使用<code>let</code>声明，并且可以被赋予一个初始值。</p>
</li>
<li>
<p>如果<code>willSet</code>函数存在的话，就是单词<code>willSet</code>后面紧跟着函数体。当在其它地方设置该变量时，在该变量收到其新值之前<code>willSet</code>函数被调用。</p>
</li>
<li>
<p>默认情况下，<code>willSet</code>函数接受即将设置的新值，这个新值的名字是<code>newValue</code>。也可以通过在<code>willSet</code>后面的<font color=Blue>括号里写一个不同的名字来自定义接受到新值名字</font>。旧值仍然在存储变量中，<code>willSet</code>函数中依然可以访问旧值。</p>
</li>
<li>
<p>如果在<code>willSet</code>中<font color=red>将存储变量设置为不同的值时，不会生效</font>，并会收到编译警告：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> newStr: String = <span style="color:#e6db74">&#34;new&#34;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">willSet</span> {
</span></span><span style="display:flex;"><span>        debugPrint(newValue)
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Attempting to store to property &#39;s&#39; within its own willSet, which is about to be overwritten by the new value</span>
</span></span><span style="display:flex;"><span>        newStr = <span style="color:#e6db74">&#34;test&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>newStr = <span style="color:#e6db74">&#34;name&#34;</span>
</span></span><span style="display:flex;"><span>debugPrint(newStr)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// name</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// name</span>
</span></span></code></pre></div></li>
<li>
<p>如果<code>didSet</code>函数存在的话，就是<code>didSet</code>这个词后面紧跟着函数体。当其它代码设置该变量时，<font color=LightSeaGreen>在该变量实际收到其新值之后被调用</font>。</p>
</li>
<li>
<p>默认情况下，<code>didSet</code>函数接收旧的值，名字为<code>oldValue</code>，此时新值已经完成替换。可以通过在<code>didSet</code>后面的括号里写一个不同的名字以自定义接收到的旧值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> now1: String = <span style="color:#e6db74">&#34;now1&#34;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">willSet</span>(val) {
</span></span><span style="display:flex;"><span>        debugPrint(now1)
</span></span><span style="display:flex;"><span>        debugPrint(val)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">didSet</span>(val) {
</span></span><span style="display:flex;"><span>        debugPrint(val)
</span></span><span style="display:flex;"><span>        debugPrint(now1)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>debugPrint(now1 = <span style="color:#e6db74">&#34;133&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">//&#34;now1&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//&#34;133&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//&#34;now1&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//&#34;133&#34;</span>
</span></span></code></pre></div></li>
<li>
<p>新的值已经在存储的变量中，<code>didSet</code>函数中可以访问新值。此外，在<code>didSet</code>函数中<font color=red>将存储变量设置为不同的值也是合法的</font>，但不会再次调用<code>Setter Observers</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> newStr: String = <span style="color:#e6db74">&#34;new&#34;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">willSet</span> {
</span></span><span style="display:flex;"><span>        debugPrint(newValue)
</span></span><span style="display:flex;"><span>        newStr = <span style="color:#e6db74">&#34;test&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">didSet</span> {
</span></span><span style="display:flex;"><span>        newStr = <span style="color:#e6db74">&#34;dddd&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>newStr = <span style="color:#e6db74">&#34;name&#34;</span>
</span></span><span style="display:flex;"><span>debugPrint(newStr)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// name</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// dddd</span>
</span></span></code></pre></div></li>
</ol>
<p>需要特别注意的是，当<font color=red>存储变量初始化时或<code>didSet</code>函数中再次改变存储变量的值时，不会调用<code>setter observers</code>函数</font>，否则会产生死循环。</p>
<p>在实际的<code>iOS</code>编程中，可能想要可见的界面反应对象的状态。一个<code>setter</code>观察器是一种简单而强大的方式，可以使界面与一个属性同步。</p>
<p>在下面这个例子中，有一个<code>view</code>类的实例属性，决定了该视图应该被旋转多少。每次这个实例属性发生变化时，我们都会改变界面来反映它，即设置<code>self.transform</code>使视图被旋转相应的角度：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> angle: CGFloat = <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">didSet</span> { <span style="color:#75715e">// modify interface to match </span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.transform = CGAffineTransform(rotationAngle: <span style="color:#66d9ef">self</span>.angle)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><font color=red>计算变量不能有<code>setter observers</code></font>，因为它已经有了<code>setter</code>函数，任何在设置过程中需要发生的额外事情都可以直接写入<code>setter</code>函数中。但<font color=LightSeaGreen>一个被属性包装器包裹的计算变量可以有<code>setter observers</code></font>。</p>
<h2 id="lazy-initialization">Lazy Initialization</h2>
<p>如果一个<font color=red>存储变量声明</font>时赋了一个初始值，并且使用了<code>Lazy Initialization</code>（懒初始化），那么在运行代码访问该变量的值之前，初始值实际上还不会有。在<code>Swift</code>中，有三种类型的变量可以被懒初始化。</p>
<ul>
<li>
<p>全局变量。全局变量是自动<code>Lazy Initialization</code>的，一个全局变量的初始化在<font color=red>其他代码首次引用该全局变量时才会发生</font>，这种初始化只会执行一次，同时又是<font color=red>线程安全</font>的。</p>
</li>
<li>
<p>静态属性。静态属性也是自动<code>Lazy Initialization</code>的，它的行为和全局变量完全一样，而且原因也基本相同。所以在<code>Swift</code>中类属性不能再加<code>lazy</code>关键字。</p>
</li>
<li>
<p>实例属性默认不是<code>lazy</code>的，但可以在声明的时候显式加上关键字<code>lazy</code>。此时，这个属性必须使用<code>var</code>来声明而不能用<code>let</code>。如果没有任何代码获取属性的值，属性的初始化器可能永远不会执行。</p>
</li>
<li>
<p>从<code>Swift 5.5</code>开始，<font color=red>局部变量可以使用<code>lazy var</code>声明了</font>。下面代码中，<code>dog</code>并不会被实例化。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">lazy</span> <span style="color:#66d9ef">var</span> dog = Dog(name: <span style="color:#e6db74">&#34;123&#34;</span>, license: <span style="color:#ae81ff">456</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
</ul>
<p>如果代码从未引用懒初始化的变量，那么这个变量的初始化器永远不会运行。显然，如果初始值的生成成本很高时，那么这个特性很有用。</p>
<p>如果懒惰初始化变量的第一个引用重新设置了该变量会怎么样？<font color=red>对于全局变量或静态属性，初始值会被计算，然后立即被新设置的值所取代。</font>下面代码执行后，控制台打印了<code>firstStatic</code>和<code>secondStatic</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Assist</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> value: String
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(value: String) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.value = value
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#66d9ef">self</span>.value)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NewTest</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">var</span> staticTest = Assist(value: <span style="color:#e6db74">&#34;firstStatic&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>NewTest.staticTest = Assist(value: <span style="color:#e6db74">&#34;secondStatic&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// firstStatic</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// secondStatic</span>
</span></span></code></pre></div><p>但是对于<font color=red>懒加载的实例属性或局部变量的初始化器将永远不会赋初始值，如果该变量在被获取之前被重新设置</font>。下面的代码执行后，控制台只打印了一个<code>secondTime</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Assist</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> value: String
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(value: String) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.value = value
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#66d9ef">self</span>.value)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NewTest</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">lazy</span> <span style="color:#66d9ef">var</span> test = Assist(value: <span style="color:#e6db74">&#34;firstTime&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">changeTest</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.test = Assist(value: <span style="color:#e6db74">&#34;secondTime&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 下面代码执行完后，只会打印secondTime，不会打印firstTime</span>
</span></span><span style="display:flex;"><span>NewTest().changeTest() 
</span></span></code></pre></div><h2 id="singleton">Singleton</h2>
<p><code>Lazy Initialization</code>常用于实现单例。单例是一种设计模式，所有的代码都能够访问某个类的单一共享实例。下面代码就是一个最简单的单例实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClass</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> shared = MyClass()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">init</span>() {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在代码第一次使用<code>MyClass.shared</code>前，单例不会被创建。只要单例创建成功后，无论其它代码多少次使用<code>MyClass.shared</code>，返回的实例总是同一个实例。如果使用的是一个只读计算属性，其<code>getter</code>函数调用<code>MyClass()</code>并返回该实例，那么每次返回的是不同的实例。</p>
<p>通常，我们希望实例属性是<code>Lazy Initialization</code>的。因为实例属性初始值的生成所花费的代价可能是昂贵的，所以除非确实需要用到的时候，<font color=LightSeaGreen>一般会避免提前生成</font>。</p>
<p>还有另一个原因更重要，<font color=red>懒初始化可以做普通初始化器不能做的事情</font>，即<font color=Blue>懒初始化可以访问实例本身</font>，而普通的初始化器是不能这样做的，因为在普通初始化器运行的时候，实例尚未生成。</p>
<p>下面的代码中，如果<code>arrow</code>属性不声明为<code>lazy</code>，将会出现编译错误<code>Cannot use instance member 'self' within property initializer; property initializers run before 'self' is available</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyView</span>: UIView {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">lazy</span> <span style="color:#66d9ef">var</span> arrow = <span style="color:#66d9ef">self</span>.arrowImage() <span style="color:#75715e">// legal</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">arrowImage</span>() -&gt; UIImage {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// ... big image-generating code goes here ...</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>一个常见的习惯是定义和调用匿名函数来初始化一个<code>lazy</code>实例属性。<font color=Blue>一旦加上<code>lazy</code>，那么在这个匿名函数中就可以引用实例本身<code>self</code></font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyView</span>: UIView {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">lazy</span> <span style="color:#66d9ef">var</span> prog: UIProgressView = {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> p = UIProgressView(progressViewStyle: .<span style="color:#66d9ef">default</span>)
</span></span><span style="display:flex;"><span>        p.alpha = <span style="color:#ae81ff">0.7</span>
</span></span><span style="display:flex;"><span>        p.trackTintColor = UIColor.clear
</span></span><span style="display:flex;"><span>        p.progressTintColor = UIColor.black
</span></span><span style="display:flex;"><span>        p.frame = CGRect(x: <span style="color:#ae81ff">0</span>, y: <span style="color:#ae81ff">0</span>, width: <span style="color:#66d9ef">self</span>.view.bounds.size.width, height: <span style="color:#ae81ff">20</span>) <span style="color:#75715e">// legal </span>
</span></span><span style="display:flex;"><span>        p.progress = <span style="color:#ae81ff">1.0</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> p
</span></span><span style="display:flex;"><span>    }()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>与自动<code>lazy</code>的全局变量和静态变量不同，<font color=red>标记为<code>lazy</code>的实例属性是线程不安全的</font>。当在多线程环境中使用时，<code>lazy</code>的<font color=red>实例属性可能会导致多次初始化，甚至闪退</font>。</p>
<p>因为<font color=red>不能将<code>lazy</code>加在用<code>let</code>声明的属性上，所以不能让一个<code>lazy</code>的实例属性成为只读的</font>。没有<code>lazy let</code>实例属性是不幸的，因为有一些常见的情况会从这样的功能中受益。</p>
<p>假设想用一个<code>helper</code>属性添加到<code>self</code>中，它持有一个<code>Helper</code>类实例，并需要一个对<code>self</code>的引用。我们还想让这个<code>Helper</code>实例在<code>self</code>的整个生命周期内持续存在。可以通过让<code>helper</code>成为一个<code>let</code>属性并在其声明中初始化它来执行这一规则。</p>
<p>但是不能把<code>self</code>传递给<code>Helper</code>的初始化器，因为不能在属性声明中引用<code>self</code>。可以通过声明<code>helper</code>属性为<code>lazy</code>来解决这个问题。但是必须使用<code>var</code>来声明<code>helper</code>，也就是说这个<code>helper</code>可能被其它代码改变。当然，可以尽量不让这种情况发生，但问题是<code>lazy var</code>这样的表达方式无法执行我们真正所需的策略。</p>
<h2 id="built-in-simple-types">Built-In Simple Types</h2>
<p>每一个变量和每一个字面量都必须有一个类型。<code>Swift</code>内置的简单类型有<code>Bool,Numbers，String，Character，Range，Tuple</code>等。其中<code>Bool</code>类型<font color=red>是一个结构体</font>，只有两个值，一个是<code>true</code>，一个是<code>false</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>@frozen <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Bool</span> : Sendable {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">init</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    @inlinable <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">init</span>(<span style="color:#66d9ef">_</span> value: Bool)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    @inlinable <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">random</span>&lt;T&gt;(using generator: <span style="color:#66d9ef">inout</span> T) -&gt; Bool <span style="color:#66d9ef">where</span> T : RandomNumberGenerator
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    @inlinable <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">random</span>() -&gt; Bool
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>与许多计算机语言不同，<code>Swift</code>中<font color=red>没有任何其它东西能被隐式地转换为<code>Bool</code>类型</font>。例如，在<code>C</code>语言中，布尔值实际上是一个数字，<code>0</code>代表<code>false</code>，非<code>0</code>代表<code>true</code>。而在<code>Swift</code>中，只有<code>false</code>是<code>false</code>，<code>true</code>为<code>true</code>。</p>
<p>一个常见的情况：一个存储在某个<code>var</code>变量中的<code>Bool</code>，我们想反转它的值。即如果它是<code>false</code>的就变成<code>true</code>，如果它是<code>true</code>就变成<code>false</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>v.isUserInteractionEnabled = <span style="color:#f92672">!</span>v.isUserInteractionEnabled
</span></span></code></pre></div><p>上面的方式很麻烦，也容易忘记加取非符号<code>!</code>。有一个更简单的方法，即在<code>Bool</code>变量上调用<code>toggle</code>方法:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>v.isUserInteractionEnabled.toggle()
</span></span></code></pre></div><p>主要的数字类型是<code>Int</code>和<code>Double</code>，我们一般会使用这些类型。<font color=LightSeaGreen>其它数字类型的存在主要是为了与<code>C</code>和<code>Objective-C API</code>兼容</font>。</p>
<p><code>Int</code>对象类型<font color=red>也是一个结构体类型</font>，表示<code>Int.min</code>和<code>Int.max</code>之间的一个整数。实际限制值取决于应用程序运行的平台和架构，它们并不是绝对的。</p>
<p>表示一个<code>Int</code>值最简单的方法是使用一个字面量。没有小数点的数字字面量默认为<code>Int</code>。<font color=Blue>内部下划线也是合法的，内部下划线对长数字的可读性很有用</font>。前导零也是合法的，这对于在代码中填充和对齐数值很有用。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> x = <span style="color:#ae81ff">1000_000_000</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> y = <span style="color:#ae81ff">00001</span>
</span></span></code></pre></div><p>可以用二进制、八进制或十六进制的字面量来表示<code>Int</code>。要做到这一点，需要分别以<code>0b、0o</code>或<code>0x</code>开始。例如，<code>0x10</code>是十六进制表示，代表十进制的<code>16</code>。</p>
<p>负数以二进制补码格式存储。可以写一个看起来像底层存储的二进制字面量，但要使用它，必须通过<code>Int(bitPattern:)</code>初始化器。</p>
<p>在<code>Swift</code>中<font color=red><code>Double</code>是一个结构体类型</font>，表示一个精度约为<code>15</code>位小数的浮点数（使用<code>64</code>位存储）。含有小数点的数字默认为<code>Double</code>类型，并且<code>Double</code>类型的<font color=red>内部下划线和前导零也是合法的</font>。</p>
<p><code>Double</code>字面量<font color=Blue>不能以小数点开头</font>（与<code>C</code>和<code>Objective-C</code>不同）。如果要表示的值介于<code>0</code>和<code>1</code>之间，则以<code>0</code>开头。<code>Double</code>有静态属性<code>Double.infinity</code>和<code>Double.pi</code>，<font color=red>也有一个实例属性<code>isZero</code></font>。</p>
<p>可以使用科学计数法写<code>Double</code>字面量，字母<code>e</code>之后的所有内容都是<code>10</code>的指数。如果小数位为零，则可以省略小数点。例如，<code>3e2</code> 是<code>300</code>。</p>
<p>可以用十六进制数字写一个<code>Double</code>字面量。要这样做，需要以<code>0x</code>开头。也可以在使用指数法（同样，可以省略小数点，字母<code>p</code>后面的所有内容都是<code>2</code>的指数。 例如，<code>0x10p2</code>是十进制<code>64</code>。</p>
<h2 id="numeric-coercion">Numeric coercion</h2>
<p>强制转换是指从一种类型转换为另一种类型。<font color=LightSeaGreen><code>Swift</code>并没有显式的类型强制转换，但它使用实例化能够完成同样的效果</font>。<code>Swift</code>的数字类型提供了初始化器，这些初始化器将另一个数字类型实例作为参数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> i = <span style="color:#ae81ff">10</span> <span style="color:#75715e">//an Int</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> x = Double(i)
</span></span><span style="display:flex;"><span>debugPrint(x) <span style="color:#75715e">// 10.0, a Double</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> y = <span style="color:#ae81ff">3.8</span> <span style="color:#75715e">//a Double</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> j = Int(y)
</span></span><span style="display:flex;"><span>debugPrint(j) <span style="color:#75715e">// 3, an Int</span>
</span></span></code></pre></div><p>当数值被赋值给变量或作为参数传递给函数时，<code>Swift</code><font color=red>只对字面数字量进行隐式强制转换</font>。下面这段代码是合法的，虽然<code>10</code>默认是<code>Int</code>类型，但因为它是字面量，因此能够隐式地转换为<code>Double</code>类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> d : Double = <span style="color:#ae81ff">10</span>
</span></span></code></pre></div><p>但下面这段代码是不合法的，编译器会报错。<font color=red>因为所赋值的是一个不同类型的变量，而不是字面量数字</font>。问题的根源是<code>i</code>为<code>Int</code>实例，<code>d</code>是一个<code>Double</code>实例，二者不能自动进行隐式转换：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> i = <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> d : Double = i <span style="color:#75715e">// Cannot convert value of type &#39;Int&#39; to specified type &#39;Double&#39;</span>
</span></span></code></pre></div><p>解决方案是在赋值或传递变量时进行显式强制类型转换（即实例化）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> i = <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> d : Double = Double(i)
</span></span></code></pre></div><p>当数字字面量被算术运算组合时，同样的规则也适用。<code>Swift</code><font color=red>只对字面数字量进行隐式强制转换</font>。例如，一个<code>Int</code>字面量与一个<code>Double</code>字面量运算时，<code>Int</code>字面量会隐式地转换为<code>Double</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> x = <span style="color:#ae81ff">10</span><span style="color:#f92672">/</span><span style="color:#ae81ff">3.0</span>
</span></span><span style="display:flex;"><span>debugPrint(x) <span style="color:#75715e">// 3.33333333333333</span>
</span></span></code></pre></div><p>但是，如果想在算术运算中组合<font color=red>不同类型的数字类型变量</font>，则必须显式强制转换以保证它们是相同的类型。如下所示，因为<code>i</code>和<code>n</code>是不同类型的变量，会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> i = <span style="color:#ae81ff">10</span> <span style="color:#75715e">// Int类型</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> n = <span style="color:#ae81ff">3.0</span> <span style="color:#75715e">// Double类型</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> x = i <span style="color:#f92672">/</span> n <span style="color:#75715e">// compile error:Binary operator &#39;/&#39; cannot be applied to operands of type &#39;Int&#39; and &#39;Double&#39;</span>
</span></span></code></pre></div><p>解决方案是将变量<code>i</code>的类型强制转换为<code>Double</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> i = <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> n = <span style="color:#ae81ff">3.0</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> x = Double(i) <span style="color:#f92672">/</span> n
</span></span></code></pre></div><p>这些规则都是<code>Swift</code>强类型的结果。对于现代计算机语言来说，它们构成了对数值不同寻常的处理，而且可能会在短时间内把你逼疯。</p>
<p>到目前为止，所举的例子很容易解决，但如果算术表达式较长，事情就会变得更加复杂，而且这个问题会因为其它数字类型的存在而变得更加复杂，这些数字类型是与<code>Cocoa</code>兼容所需要的。</p>
<h3 id="other-numeric-types">Other numeric types</h3>
<p>如果只是在某个孤立的、抽象的世界中使用<code>Swift</code>，可能只使用<code>Int</code>和<code>Double</code>就能完成所有必要的算术运算。但是，如果是在进行<code>iOS</code>编程，就会遇到<code>Cocoa</code>，<font color=Blue>它里面包含了许多其它的数字类型，而<code>Swift</code>中都有与之相匹配的类型</font>。</p>
<p>除了<code>Int</code>，还有各种大小的有符号整数类型—<code>Int8、Int16、Int32、Int64</code>。加上无符号整数类型<code>UInt、UInt8、UInt16、UInt32</code>和<code>UInt64</code>。除了<code>Double</code>，还有低精度<code>Float</code>（<code>32</code>位存储，大约<code>6</code>或<code>7</code>个小数位精度）、更低精度的<code>Float16</code>、扩展精度<code>Float80</code> 和来自<code>Core Graphics</code>框架的<code>CGFloat</code>。</p>
<p>在尝试与<code>C</code>语言<code>API</code>对接时，也可能遇到<code>C</code>语言的数字类型。就<code>Swift</code>而言，这些类型只是类型别名，例如<code>CDouble</code>（对应<code>C</code>语言的<code>double</code>）只是<code>Double</code>的另一个名字，<code>CLong</code>（<code>C</code>语言的<code>long</code>）是<code>Int</code>。</p>
<p>在各种<code>Cocoa</code>框架中会出现许多其它数字类型的别名，例如，<code>TimeInterval</code>（<code>Objective-C</code>的<code>NSTimeInterval</code>）只是<code>Double</code>的类型别名。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> percentage = pt.x <span style="color:#f92672">/</span> s.bounds.size.width
</span></span></code></pre></div><p>在变量赋值、参数传递或操作符组合不同类型的数值时，必须将这些值显式强制转换为正确的类型。<code>Cocoa</code>有很多数值类型，但<code>Cocoa</code>通常会给你一个既不是<code>Int</code>也不是<code>Double</code>的数值。</p>
<p>但我们不一定能意识到这一点，直到编译器因为某种类型不匹配而出现报错，我们才会意识到。然后，弄清楚哪个类型错误了，并将所有内容强制转换为同一类型。</p>
<p>下面是一个典型示例。界面中滑块是一个<code>UISlider</code>，它的<code>minimumValue</code>和<code>maximumValue</code>是<code>Floats</code>。下面代码中<code>s</code>是<code>UISlider</code>，<code>g</code>是<code>UIGestureRecognizer</code>，尝试使用手势识别器将滑块移动到用户在滑块内点击的任何位置：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> pt = g.location(<span style="color:#66d9ef">in</span>:s) 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> percentage = pt.x <span style="color:#f92672">/</span> s.bounds.size.width 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> delta = percentage <span style="color:#f92672">*</span> (s.maximumValue <span style="color:#f92672">-</span> s.minimumValue) <span style="color:#75715e">// compile error</span>
</span></span></code></pre></div><p>上面代码会发生编译错误，因为<code>pt.x</code>的类型是<code>CGFloat，s.bounds.size.width</code>也是<code>CGFloat</code>，因此<code>percentage</code>的类型也是<code>CGFloat</code>，但是<code>maximumValue</code>和<code>minimumValue</code>是<code>Float</code>。所以<code>percentage</code>和<code>(s.maximumValue - s.minimumValue)</code>为不同类型。在<code>Swift</code>中<code>Float</code>和<code>CGFloat</code>是不同类型，必须进行显式强制类型转换：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> delta = Float(percentage) <span style="color:#f92672">*</span> (s.maximumValue <span style="color:#f92672">-</span> s.minimumValue)
</span></span></code></pre></div><p><code>CGFloat</code>是一个特殊的例子。<font color=red>它根据架构的位数（<code>32</code>位或<code>64</code>位）解析为<code>Float</code>或<code>Double</code>的位数大小</font>。但这种区别已经不那么重要了，因为现在<code>32</code>位架构已经很少了，而且无论如何它都能有效地处理<code>Doubles</code>。</p>
<p><font color=red>从<code>Swift 5.5</code>开始，<code>Double</code>和<code>CGFloat</code>是可以互换的</font>。在它们被期望的地方可以互换，而不需要强制类型转换，这使<code>iOS</code>程序员减少了相当多的不便性：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> cfg : CGFloat = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> d1 : Double = <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>cfg = d1 <span style="color:#75715e">// legal</span>
</span></span><span style="display:flex;"><span>d1 = cfg <span style="color:#f92672">+</span> d1 <span style="color:#75715e">//  legal</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> x2 = cfg <span style="color:#f92672">+</span> d1 <span style="color:#75715e">// x is inferred as Double</span>
</span></span></code></pre></div><p>不是所有的数值都能够强制转换为另一个类型的数值。特别是，不同整数类型转换时可能会超出范围。例如，<code>Int8.max</code>是<code>127</code>，如果尝试将<code>&gt;=128</code>的字面量赋值给<code>Int8</code>是不合法的，下面将会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> tx: Int8 = <span style="color:#ae81ff">128</span> <span style="color:#75715e">// Integer literal &#39;128&#39; overflows when stored into &#39;Int8&#39;</span>
</span></span></code></pre></div><p>上面的例子中，因为<code>128</code>是一个数字字面量，所以编译器能够提前判断溢出了。但进行类型强制转换时，编译器无法事先判断是否出溢出，所以在运行时才会崩溃：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> i : Int16 = <span style="color:#ae81ff">128</span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> i1 = Int8(i)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Swift/Integers.swift:3564: Fatal error: Not enough bits to represent the passed value</span>
</span></span></code></pre></div><p>对于上面的情况，解决方案是调用一个<font color=red>可失败的初始化器</font>。下面代码在运行时虽然不会发生崩溃，但是需要测试转换是否成功：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> i : Int16 = <span style="color:#ae81ff">128</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> i1 = Int8(exactly: i)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> i = i1 {
</span></span><span style="display:flex;"><span>    debugPrint(i1)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>另外一种解决方案是使用<code>clamping</code>初始化器，<font color=red>这个初始化器总是会成功的</font>，因为超出范围的值会强制落入正常范围内，下面代码执行后打印的结果为<code>127</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> i : Int16 = <span style="color:#ae81ff">128</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> i1 = Int8(clamping: i)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>debugPrint(i1) <span style="color:#75715e">//127</span>
</span></span></code></pre></div><p>当浮点类型（例如<code>Double</code>）被强制转换为整数类型时，<font color=red>小数点后的内容会先被丢弃，然后再尝试强制转换</font>。例如，<code>Int8(127.9)</code> 会转换成功，因为<code>127</code>在界限内。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>debugPrint(Int8(<span style="color:#ae81ff">127.9</span>))
</span></span></code></pre></div><h3 id="arithmetic-operations">Arithmetic operations</h3>
<p>从技术上讲，如果整数是无符号的，<font color=red>移位运算符执行逻辑移位，如果整数是有符号的，则执行算术移位</font>。整数上溢或下溢是运行时错误（应用程序将崩溃）例如，两个<code>Int</code>值的和超过<code>Int.max</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> i = Int.max <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> j = i <span style="color:#f92672">+</span> <span style="color:#ae81ff">12</span><span style="color:#f92672">/</span><span style="color:#ae81ff">2</span> <span style="color:#75715e">// 会发生crash</span>
</span></span></code></pre></div><p>在某些情况下，我们可能想要强制此类操作成功，因此<font color=red>提供了特殊的上溢/下溢方法</font>。这些方法返回一个元组，下面代码中<code>over</code>打印的值为<code>true</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> i = Int.max <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> (j, over) = i.addingReportingOverflow(<span style="color:#ae81ff">12</span><span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>debugPrint(over)
</span></span></code></pre></div><p>上面的代码执行后，<code>j</code>的值变成了<code>Int.min+3</code>，因为该值已从<code>Int.max</code>环绕到<code>Int.min</code>。如果不关心是否存在上溢/下溢，可以使用特殊的算术运算符来抑制错误：<code>&amp;+、&amp;-、&amp;*</code>。</p>
<p>经常希望将现有变量的值与另一个值进行算术组合，并将结果存储在同一个变量中。为此，需要将变量声明为<code>var</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> i = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>i = i <span style="color:#f92672">+</span> <span style="color:#ae81ff">7</span>
</span></span></code></pre></div><p>实际上有个速记法，提供了一次执行算术运算和赋值的运算符：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> i = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">7</span>
</span></span></code></pre></div><p>速记（复合）赋值算术运算符有<code>+=, -=, *=, /=, %=, &amp;=,|=, ^=, &lt;&lt;=, &gt;&gt;=</code>。</p>
<h3 id="comparison">Comparison</h3>
<p>对于两个不同类型的整数，<font color=red>虽然不能在算术运算中组合它们，但可以比较不同整数类型的值</font>，如下所示i是<code>Int</code>，i2是<code>UInt8</code>类型，但它们可以比较：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> i: Int = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> i2: UInt8 = <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> ok = i <span style="color:#f92672">&lt;</span> i2 <span style="color:#75715e">// true</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> ok2 = i == i2 <span style="color:#75715e">// false</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>debugPrint(ok2) <span style="color:#75715e">//false</span>
</span></span></code></pre></div><p>由于计算机存储数字的方式，<code>Double</code>数值的相等比较可能不会像我们期望的那样。举一个经典的例子，将<code>0.1</code>加十次与<code>0.1</code>乘以<code>10</code>的结果不同：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> f2 = <span style="color:#ae81ff">0.1</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> sum = <span style="color:#ae81ff">0.0</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> <span style="color:#66d9ef">_</span> <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">0.</span>.&lt;<span style="color:#ae81ff">10</span> {
</span></span><span style="display:flex;"><span>    sum <span style="color:#f92672">+=</span> f2
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> product = f2 <span style="color:#f92672">*</span> <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> ok3 = sum == product <span style="color:#75715e">// false</span>
</span></span><span style="display:flex;"><span>debugPrint(ok3) <span style="color:#75715e">//false</span>
</span></span></code></pre></div><p>解决这类问题并不容易。通常的方法是<font color=red>检查两个值是否足够接近</font>，但又引出了该怎么判断足够接近的问题。一个有用的公式为:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> ok = sum <span style="color:#f92672">&gt;=</span> product.nextDown <span style="color:#f92672">&amp;&amp;</span> sum <span style="color:#f92672">&lt;=</span> product.nextUp <span style="color:#75715e">// true</span>
</span></span></code></pre></div><h2 id="string">String</h2>
<p>在<code>Swift</code>中，字符串<code>String</code>也<font color=red>是结构体类型</font>。表示字符串值最简单方法是使用字符串字面量，即使用双引号分隔：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> greeting = <span style="color:#e6db74">&#34;hello&#34;</span>
</span></span></code></pre></div><p><code>Swift</code>中的字符串是完全现代的，它使用<code>Unicode</code>编码，可以在字符串字面量中包含任何字符（如表情符）。如果知道一个字符的<code>Unicode</code>码点，并且不嫌麻烦，可以使用<code>\u{...}</code>，需要注意的是<font color=red>在花括号的内容至多为八位十六进制数字</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> leftTripleArrow = <span style="color:#e6db74">&#34;\u{21DA}&#34;</span>
</span></span></code></pre></div><p>该字符串中的反斜杠是转义字符。它的意思是，*“我不是一个真正的反斜杠，紧接着的下一个字符需要特殊处理。”*有很多不可打印的字符作为转义字符，最常见的是以下这些：</p>
<ul>
<li><code>\n</code>：一个<code>Unix</code>换行符。</li>
<li><code>\t</code>：制表符。</li>
<li><code>\&quot;</code>：引号（转义以表明这不是字符串文字的结尾）。</li>
<li><code>\\</code>：反斜杠（因为单独的反斜杠是转义字符）。</li>
</ul>
<p>转义的引号和反斜线会使字符串字面意义变得难看和难以辨认，尤其在正则表达式中。例如，模式<code>\b\d\d\b</code>（由两个数字组成的单词）必须写成<code>&quot;\\b\\d\\d\\b&quot;</code>。可以在引号和反斜杠之前省略转义字符，用一个或多个哈希字符（<code>#</code>）围住字面量，下面这些都是相同的字符串：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> pattold = <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">b</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">d</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">d</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">b&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> pattnew = #<span style="color:#e6db74">&#34;\b\d\d\b&#34;</span># <span style="color:#75715e">// same thing</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> pattnew2 = ##<span style="color:#e6db74">&#34;\b\d\d\b&#34;</span>## <span style="color:#75715e">// same thing</span>
</span></span></code></pre></div><p>这称为原始字符串字面量。缺点是，如果想在原始字符串字面量中使用反斜杠作为转义字符，则必须在反斜杠后面加上用于包围字符串字面量相同数量的<code>#</code>字符。字符串<code>#&quot;hello\nthere&quot;#</code>不包含换行符<code>(\n)</code>，但<code>#&quot;hello\#nthere&quot;#</code>包含。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> hello = #<span style="color:#e6db74">&#34;hello</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">there&#34;</span>#
</span></span><span style="display:flex;"><span>debugPrint(hello)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// &#34;hello\\nthere&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> hello = #<span style="color:#e6db74">&#34;hello\#nthere&#34;</span>#
</span></span><span style="display:flex;"><span>debugPrint(hello)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// &#34;hello\nthere&#34;</span>
</span></span></code></pre></div><p>可以将包含换行符的字符串字面量输入为多行，而不是包含<code>\n</code>字符的单行表达式，这称为多行字符串字面量。使用的规则如下：</p>
<ul>
<li>多行字符串字面量必须在开始和结束处用三重引号 (<code>&quot;&quot;&quot;</code>) 分隔。</li>
<li>任何字符都不能跟在同一行的开头分隔符后面。</li>
<li>除了空格之外，其它任何字符都不能与结束分隔符出现在同一行。</li>
<li>结束分隔符之前的<font color=red>最后一个隐式换行符会被忽略</font>。</li>
<li>结束分隔符的缩进决定了文本行的缩进，它必须至少缩进到结束分隔符（整个空行除外）。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">ff</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> s = <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            Line 1 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                Line 2 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            Line 3 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            &#34;&#34;&#34;</span> <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在上面字符串<code>s</code>包含<code>3</code>行字符串，第1和第3行没有以空格开始，第2行以4个空格开始，第1行和第2行后面包含换行符。如果要在第3行后添加换行，可以输入一个空行，或者添加一个转义的<code>\n</code>。</p>
<p>在多行字符串字面量中，双引号不需要转义。<font color=red>以反斜杠结尾的一行与下一行相连</font>。在下面这段代码中，字符串<code>s</code>仅由两行文字组成，第二行由四个空格开始，后面紧跟着 <code>&quot;Line 2 and this is still line 2&quot;</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">f</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> s = <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            Line &#34;</span><span style="color:#ae81ff">1</span><span style="color:#e6db74">&#34; 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">               Line 2 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            and this is still Line 2 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>           <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>    debugPrint(s)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>可以使用<code>#</code>包住多行字符串字面量，使之成为一个原始的多行字符串字头，但通常不这样做。</p>
<p>字符串插值允许在字符串字面量中嵌入任何值，即使这个值本身不是字符串，也可以使用转义圆括号来实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> n = <span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s = <span style="color:#e6db74">&#34;You have </span><span style="color:#e6db74">\(</span>n<span style="color:#e6db74">)</span><span style="color:#e6db74"> widgets.&#34;</span>
</span></span></code></pre></div><p>如果<font color=red>是在一个字符串中插值，那么字符串中的引号不需要被转义</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s = <span style="color:#e6db74">&#34;You have </span><span style="color:#e6db74">\(</span><span style="color:#e6db74">&#34;numerous&#34;</span>.uppercased<span style="color:#e6db74">())</span><span style="color:#e6db74"> widgets&#34;</span>
</span></span><span style="display:flex;"><span>debugPrint(s)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// &#34;You have NUMEROUS widgets&#34;</span>
</span></span></code></pre></div><p>字符串插值在多行字符串是合法的。在以#包围的原始字符串中插值也是合法的，但反斜杠后面<font color=red>必须有相同数量的#字符</font>，以表明它是转义字符。</p>
<p>字符串插值的语法可以定制以接受额外的参数，重定义第一个参数应该如何转换。下面这种形式的表达式是合法的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> n = <span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s = <span style="color:#e6db74">&#34;You have </span><span style="color:#e6db74">\(</span>n, roman: <span style="color:#66d9ef">true</span><span style="color:#e6db74">)</span><span style="color:#e6db74"> widgets&#34;</span>
</span></span><span style="display:flex;"><span>debugPrint(s)
</span></span></code></pre></div><p>连接两个字符串，最简单的方式是使用<code>+</code>操作符：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s = <span style="color:#e6db74">&#34;hello&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s2 = <span style="color:#e6db74">&#34; world&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> greeting = s <span style="color:#f92672">+</span> s2
</span></span><span style="display:flex;"><span>debugPrint(greeting)
</span></span></code></pre></div><p>这种便捷的标识可以成为可能，是因为操作符<code>+</code>是重载的。所有的运算符都可以被重载，可以重载某个操作符，以某种适当的方式对自己的类型进行操作。</p>
<p>字符串和<code>Int</code>之间的强制转换是可能的。要创建一个代表<code>Int</code>的字符串，只需使用字符串插值就可以了。或者使用以<code>Int</code>为参数的<code>String</code>初始化器：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> i = <span style="color:#ae81ff">7</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s = String(i) <span style="color:#75715e">// &#34;7&#34;</span>
</span></span><span style="display:flex;"><span>debugPrint(s)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 7</span>
</span></span></code></pre></div><p>字符串也可以代表其它基数的<code>Int</code>，只需在初始化器中提供一个表示基数的<code>radix:</code> 参数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> i = <span style="color:#ae81ff">31</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s = String(i, radix: <span style="color:#ae81ff">16</span>) <span style="color:#75715e">// &#34;1f&#34;</span>
</span></span><span style="display:flex;"><span>debugPrint(s)
</span></span></code></pre></div><p>一个代表数字的字符串，可以强制转换为数值类型，一个整数类型能接受一个表达基数的<code>radix:</code> 参数。强制类型转换可能会失败，因为字符串可能不代表数字。所以，转换的结果不是一个数字，而是一个包裹着数字的<code>Optional</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s = <span style="color:#e6db74">&#34;31&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> i = Int(s) <span style="color:#75715e">// Optional(31)</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s2 = <span style="color:#e6db74">&#34;1f&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> i2 = Int(s2, radix: <span style="color:#ae81ff">16</span>) <span style="color:#75715e">// Optional(31)</span>
</span></span><span style="display:flex;"><span>debugPrint(i, i2)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Optional(31) Optional(31)</span>
</span></span></code></pre></div><p>表示字符串长度的属性是<code>count</code>，而不是<code>length</code>。字符串由<code>Unicode</code>码点序列组成，但多个<code>Unicode</code>码点可以组合成一个字符。为了知道这样一个码点序列代表多少个字符，实际上必须遍历这个序列并将其分解成所代表的字符。</p>
<p>同样地，我们也可以遍历字符串中的字符，最简单的方式是使用<code>for in</code>结构：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s = <span style="color:#e6db74">&#34;hello&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> c <span style="color:#66d9ef">in</span> s {
</span></span><span style="display:flex;"><span>    print(c) <span style="color:#75715e">// print each Character on its own line }</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在更深的层次上，可以使用<code>utf8</code>和<code>utf16</code>属性，将一个字符串分解成<code>UTF-8</code>码点或<code>UTF-16</code>码点：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s = <span style="color:#e6db74">&#34;\u{BF}Qui\u{E9}n?&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> s.utf8 {
</span></span><span style="display:flex;"><span>    debugPrint(i) <span style="color:#75715e">// 194, 191, 81, 117, 105, 195, 169, 110, 63</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> s.utf16 {
</span></span><span style="display:flex;"><span>    debugPrint(i) <span style="color:#75715e">// 191, 81, 117, 105, 233, 110, 63</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>debugPrint(s)
</span></span></code></pre></div><p>还有一个<code>unicodeScalars</code>属性，代表一个以<code>UnicodeScalar</code>结构表示的字符串<code>UTF-32</code>码点的集合（<code>String.UnicodeScalarView</code>）。为了说明问题，下面定义了一个实用的函数，可以将两个字母的国家缩写变成国旗表情符号表示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">flag</span>(country: String) -&gt; String {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> base: UInt32 = <span style="color:#ae81ff">127397</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> s = <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> v <span style="color:#66d9ef">in</span> country.unicodeScalars {
</span></span><span style="display:flex;"><span>        s.unicodeScalars.append(UnicodeScalar(base <span style="color:#f92672">+</span> v.value)<span style="color:#f92672">!</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> String(s)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>debugPrint(flag(country:<span style="color:#e6db74">&#34;CN&#34;</span>))
</span></span></code></pre></div><p>奇怪的是，没有更多的方法用于标准的字符串操作。将一个字符串变成大写，或者判断一个字符串是否包含一个给定的子串？大多数现代编程语言都会有一个紧凑、方便的方法来做这样的事情，但<code>Swift</code>没有。</p>
<p>原因是缺失的功能是由<code>Foundation</code>框架提供的，在现实生活中，总与<code>Foundation</code>挂钩（导入<code>UIKit</code>也会导入<code>Foundation</code>）。</p>
<p>一个<code>Swift</code>字符串被桥接到一个<code>Foundation</code> 的<code>NSString</code>。这意味着，在很大程度上，只要使用<code>Swift</code>字符串，<code>Foundation NSString</code>的属性和方法就会神奇地涌现出来：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s = <span style="color:#e6db74">&#34;hello world&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s2 = s.capitalized <span style="color:#75715e">// &#34;Hello World&#34;</span>
</span></span><span style="display:flex;"><span>debugPrint(s2)
</span></span></code></pre></div><p>字符串的<code>capitalized</code>属性来自于<code>Foundation</code>框架，由<code>Cocoa</code>提供，而不是<code>Swift</code>提供，它实际上是<code>NSString</code>的属性。</p>
<h2 id="range">Range</h2>
<p><code>Range</code>对象类型<font color=red>是一个结构体</font>，代表一对端点。形成<code>Range</code>字面量的操作符有两个，提供一个开始值和一个结束值，在它们之间有一个<code>Range</code>操作符：</p>
<ul>
<li>
<p><code>...</code>闭<code>range</code>操作符：<code>a...b</code>意味着<code>a</code>到<code>b</code>的一切，包括<code>b</code>。</p>
</li>
<li>
<p><code>..&lt;</code>半开<code>range</code>操作符：<code>a..&lt;b</code>意味着<code>a</code>到<code>b</code>的一切，但不包括<code>b</code>。</p>
</li>
</ul>
<p>在<code>Range</code>操作符<font color=LightSeaGreen>两边同时添加空格是合法的</font>，例如<code>1...3</code>或<code>1 ... 3</code>都是合法的。一个<code>Range</code>的端点的类型通常是某种数字，最常见的是整型。但是如果只有一边添加空格，则会报错：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> r = <span style="color:#ae81ff">1.</span>..<span style="color:#ae81ff">3</span> <span style="color:#75715e">// 正常</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> range = <span style="color:#ae81ff">1.</span>.. <span style="color:#ae81ff">3</span> <span style="color:#75715e">// 编译错误 Consecutive statements on a line must be separated by &#39;;&#39;</span>
</span></span></code></pre></div><p>如果<font color=red>结束值是一个负数，它必须用圆括号括起来或在操作符前面加上空格</font>。<code>let r = -1000 ... -1</code>和<code>let r = -1000...(-1)</code>都是可以的。<code>Range</code>的常用场景是<code>for ... in</code>语句:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>debugPrint(<span style="color:#f92672">-</span><span style="color:#ae81ff">1000.</span>..<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#75715e">// compile error: Ambiguous missing whitespace between unary and binary operators</span>
</span></span><span style="display:flex;"><span>debugPrint(<span style="color:#f92672">-</span><span style="color:#ae81ff">1000.</span>..(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span>debugPrint(<span style="color:#f92672">-</span><span style="color:#ae81ff">1000</span> ... <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>debugPrint(<span style="color:#ae81ff">1</span> ... <span style="color:#ae81ff">1000</span>)
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> ix <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1.</span>..<span style="color:#ae81ff">3</span> {
</span></span><span style="display:flex;"><span>    debugPrint(ix) <span style="color:#75715e">// 1, then 2, then 3 </span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1.</span>..<span style="color:#ae81ff">1</span> {
</span></span><span style="display:flex;"><span>    debugPrint(i)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在<code>Swift</code>中，没有反向的<code>Range</code>，即<code>Range</code>的<font color=red>起始值不能大于结束值</font>。一旦出现这种情况，<font color=red>编译器不会报错，但运行的时候会发生崩溃</font>。在实际的编程上，可以使用<code>Range</code>的<code>reversed()</code>方法来实现相同的效果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1</span> ... <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> {
</span></span><span style="display:flex;"><span>    debugPrint(i) <span style="color:#75715e">// 运行时发生崩溃 Fatal error: Range requires lowerBound &lt;= upperBound</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> ix <span style="color:#66d9ef">in</span> (<span style="color:#ae81ff">1.</span>..<span style="color:#ae81ff">3</span>).reversed() {
</span></span><span style="display:flex;"><span>    debugPrint(ix) <span style="color:#75715e">// 3，2，1</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在实际编程中，可以使用<code>Range</code>的<code>contains(_:)</code>实例方法来测试一个值是否在给定的范围内。例如，可以测试某个数字是否在某个范围内：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> ix = <span style="color:#ae81ff">2</span> <span style="color:#75715e">// ... an Int ...</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#ae81ff">1.</span>..<span style="color:#ae81ff">3</span>).contains(ix) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果只是想测试<code>Range</code>中是否包含某个数字，<font color=red><code>Range</code>的端点数值可以为<code>Double</code>类型</font>。下面的代码中，测试变量<code>d</code>是否在<code>(0.1...0.9)</code>中是可行的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> d = <span style="color:#ae81ff">0.3</span> <span style="color:#75715e">// ... a Double ...</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#ae81ff">0.1</span>...<span style="color:#ae81ff">0.9</span>).contains(d) {
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;contains </span><span style="color:#e6db74">\(</span>d<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// &#34;contains 0.3&#34;</span>
</span></span></code></pre></div><p><code>Range</code>的另一个常见用途是对一个序列进行索引。下面是获取一个字符串的第二、第三和第四个字符的一种方法。如果把字符串转换为一个字符数组，可以用一个<code>Int Range</code>作为该数组的索引：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s = <span style="color:#e6db74">&#34;hello&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> arr = Array(s)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> result = arr[<span style="color:#ae81ff">1.</span>..<span style="color:#ae81ff">3</span>]
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s2 = String(result) <span style="color:#75715e">// &#34;ell&#34;</span>
</span></span><span style="display:flex;"><span>debugPrint(arr) <span style="color:#75715e">// [&#34;h&#34;, &#34;e&#34;, &#34;l&#34;, &#34;l&#34;, &#34;o&#34;]</span>
</span></span><span style="display:flex;"><span>debugPrint(s2)  <span style="color:#75715e">// &#34;ell&#34;</span>
</span></span></code></pre></div><p>字符串本身是一个字符序列，所以可以使用<code>Range</code>来直接索引字符串，但必须是一个<code>String.Index</code>的<code>Range</code>，但是它很难获取。通过操作<code>String.Index</code>值，可以形成一个适当类型的<code>Range</code>，并使用它通过下标提取一个子字符串：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s = <span style="color:#e6db74">&#34;hello&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> ix1 = s.index(s.startIndex, offsetBy:<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> ix2 = s.index(ix1, offsetBy:<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s2 = s[ix1...ix2] <span style="color:#75715e">// 闭区间，结果是&#34;ell&#34;</span>
</span></span><span style="display:flex;"><span>debugPrint(s2)
</span></span></code></pre></div><p>可以在<code>Range</code>字面常量上省略一个端点，形成一个部分<code>Range</code>。有三种形式部分<code>Range</code>表达式，对应三种类型的<code>Range</code>结构，分别是省略前端点的的<code>..&lt;</code>,省略前端点的<code>...</code>以及省略后端点的<code>...</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> str = <span style="color:#e6db74">&#34;hello&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> range1 = str.startIndex..&lt;str.endIndex <span style="color:#75715e">// Range注意endIndex</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> range2 = ..&lt;str.endIndex <span style="color:#75715e">// PartialRangeUpTo</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> range3 = ...str.index(before: str.endIndex) <span style="color:#75715e">// PartialRangeUpThrough</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> range4 = str.startIndex... <span style="color:#75715e">// PartialRangeFrom</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>debugPrint(str)
</span></span><span style="display:flex;"><span>debugPrint(str[range1])
</span></span><span style="display:flex;"><span>debugPrint(str[range2])
</span></span><span style="display:flex;"><span>debugPrint(str[range3])
</span></span><span style="display:flex;"><span>debugPrint(str[range4])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;hello&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;hello&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;hello&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;hello&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;hello&#34;</span>
</span></span></code></pre></div><p>如果需要将一个部分<code>Range</code>转换为一个<code>Range</code>，可以调用<code>relative(to:)</code>方法。但一般来说，不需要这样做，因为部分<code>Range</code>可以用在任何需要使用<code>Range</code>的地方：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s = <span style="color:#e6db74">&#34;hello&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> ix2 = s.index(before: s.endIndex)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s2 = s[..&lt;ix2] <span style="color:#75715e">// &#34;hell&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>debugPrint(s2) <span style="color:#75715e">// &#34;hell&#34;</span>
</span></span><span style="display:flex;"><span>debugPrint(s[s.startIndex..&lt;s.endIndex]) <span style="color:#75715e">//&#34;hello&#34;</span>
</span></span><span style="display:flex;"><span>debugPrint((..&lt;s.endIndex).relative(to: s) == s.startIndex ..<span style="color:#f92672">&lt;</span> s.endIndex) <span style="color:#75715e">// true</span>
</span></span></code></pre></div><h2 id="tuple">Tuple</h2>
<p>元组是一个<font color=Blue>由多个值组成的轻量级自定义有序集合</font>。作为一种类型，它的表达方式是用圆括号包围所含类型，用逗号分隔开各种类型。下面是一个元组变量的声明，其类型是一个<code>Int</code>和一个<code>String</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> pair : (Int, String)
</span></span></code></pre></div><p>元组字面量也以同样的方式表达，用圆括号包含值，每个值以逗号隔开。但这些值的类型也可以由编译器推断出来，无需显式声明：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> pair1 : (Int, String) = (<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;Two&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> pair2 = (<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;Two&#34;</span>)
</span></span></code></pre></div><p>元组是<code>Swift</code>语言特有的，与<code>Cocoa</code>和<code>Objective-C</code>不兼容。元组是<font color=red>解决一个函数只能返回一个值这个问题的好方法</font>。元组是一个特殊的值，它里面包含了多个值，所以可以使用元组作为一个函数的返回类型以返回多个值。</p>
<p>元组也提供了很多语言上便利性，可以一次<font color=LightSeaGreen>同时赋值多个不同类型的变量，也可以一次同时声明和初始化多个不同类型的变量</font>，如下所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> ix: Int
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s: String
</span></span><span style="display:flex;"><span>(ix, s) = (<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;Two&#34;</span>)
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> (ix, s) = (<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;Two&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> (ix1, s1) = (<span style="color:#ae81ff">12</span>, <span style="color:#e6db74">&#34;name&#34;</span>)
</span></span></code></pre></div><p>如果要将元组中的值赋给某些变量，但又要<font color=LightSeaGreen>忽略元组中的某个值的时候，可以在对应位置使用下划线</font>。下面的代码就是只取元组中的第二个值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> pair = (<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;Two&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> (<span style="color:#66d9ef">_</span>, s) = pair <span style="color:#75715e">// now s is &#34;Two</span>
</span></span></code></pre></div><p>使用元组<font color=Blue>可以不借助临时变量来交换两个变量的值</font>，<font color=red>同时也是安全的</font>。使用元组来交换两个变量时，只需要交换元组中变量的位置即可：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> s1 = <span style="color:#e6db74">&#34;hello&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> s2 = <span style="color:#e6db74">&#34;world&#34;</span>
</span></span><span style="display:flex;"><span>(s1, s2) = (s2, s1) <span style="color:#75715e">// now s1 is &#34;world&#34; and s2 is &#34;hello&#34;</span>
</span></span></code></pre></div><p>访问元组中的值有两种方式。第一种是使用索引来访问元组中的值。例如，上面的<code>pair</code>元组中的第一个值可以使用<code>pair.0</code>来访问，第二个可以使用<code>pair.1</code>来访问。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> pair = (<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;Two&#34;</span>)
</span></span><span style="display:flex;"><span>pair.<span style="color:#ae81ff">0</span> = <span style="color:#ae81ff">2</span> <span style="color:#75715e">// now pair is (2, &#34;Two&#34;)</span>
</span></span></code></pre></div><p>第二种方式是<font color=LightSeaGreen>使用标签来访问元组中的值</font>。但在元组声明的时候就需要先加上标签。<font color=red>元组的标签和函数的参数一样，必须作为类型声明的一部分出现</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> pair : (first:Int, second:String) = (<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;Two&#34;</span>)
</span></span></code></pre></div><p>上面的例子也可以使用<code>let pair = (first:1, second:&quot;Two&quot;)</code>这种简单的方式声明。之后便能使用标签来访问元组中的值，此时仍然可以通过索引访问：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> pair = (first: <span style="color:#ae81ff">1</span>, second: <span style="color:#e6db74">&#34;Two&#34;</span>)
</span></span><span style="display:flex;"><span>debugPrint(pair.first, pair.second)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> x = pair.first <span style="color:#75715e">// 1</span>
</span></span><span style="display:flex;"><span>pair.first = <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> y = pair.<span style="color:#ae81ff">0</span> <span style="color:#75715e">// 2</span>
</span></span></code></pre></div><p>在序列中使用<code>enumerated</code>方法既可以遍历元素也可以获得对应的索引。在下面的代码中，第一个<code>for in</code>中使用元组获取索引和元素，第二个<code>for in</code>中通过<code>offset</code>和<code>element</code>来获取：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s = <span style="color:#e6db74">&#34;hello&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (index, c) <span style="color:#66d9ef">in</span> s.enumerated() {
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;character </span><span style="color:#e6db74">\(</span>index<span style="color:#e6db74">)</span><span style="color:#e6db74"> is </span><span style="color:#e6db74">\(</span>c<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//character 0 is h</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//character 1 is e</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//character 2 is l</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//character 3 is l</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//character 4 is o</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> t <span style="color:#66d9ef">in</span> s.enumerated() {
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;character </span><span style="color:#e6db74">\(</span>t.offset<span style="color:#e6db74">)</span><span style="color:#e6db74"> is </span><span style="color:#e6db74">\(</span>t.element<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//character 0 is h</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//character 1 is e</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//character 2 is l</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//character 3 is l</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//character 4 is o</span>
</span></span></code></pre></div><p>需要特别注意的是，可以<font color=LightSeaGreen>将一个没有标签的元组赋值给一个有标签的对应元组</font>。相反，<font color=Blue>也可以将一个有标签的元组赋值给一个没有标签的元组</font>，下面代码都是可行的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> pair = (<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;Two&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> pairWithNames: (first: Int, second: String) = pair
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> ix = pairWithNames.first <span style="color:#75715e">// 1</span>
</span></span><span style="display:flex;"><span>pair = pairWithNames
</span></span></code></pre></div><p>但是，<font color=red>如果两个元组包含的相同的类型，但声明的标签不同，则不能相互赋值</font>。如下所示，虽然<code>pair1</code>和<code>pair2</code>的类型相同，但标签不同，会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> pair1 = (first: <span style="color:#ae81ff">1</span>, second: <span style="color:#e6db74">&#34;test&#34;</span>)
</span></span><span style="display:flex;"><span>debugPrint(pair1.first, pair1.<span style="color:#ae81ff">0</span>, pair1.second, pair1.<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> pair2 = (test1: <span style="color:#ae81ff">1</span>, test2: <span style="color:#e6db74">&#34;test2&#34;</span>)
</span></span><span style="display:flex;"><span>debugPrint(pair1.first, pair1.<span style="color:#ae81ff">0</span>, pair1.second, pair1.<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>pair1 = pair2 <span style="color:#75715e">// Cannot assign value of type &#39;(test1: Int, test2: String)&#39; to type &#39;(first: Int, second: String)&#39;</span>
</span></span></code></pre></div><p>可以在函数中传递元组，也可以在一个函数中返回一个没有标签的元组，<font color=LightSeaGreen>即使这个函数声明的返回值是带标签的元组</font>，如下所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">tupleMaker</span>() -&gt; (first: Int, second: String) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;Two&#34;</span>) <span style="color:#75715e">// no labels here</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> tuple = tupleMaker()
</span></span><span style="display:flex;"><span>debugPrint(tuple.first, tuple.second, tuple.<span style="color:#ae81ff">0</span>, tuple.<span style="color:#ae81ff">1</span>) <span style="color:#75715e">// 1 &#34;Two&#34; 1 &#34;Two&#34;</span>
</span></span></code></pre></div><h2 id="optional">Optional</h2>
<p>可选对象类型（<font color=red>实质上是一个枚举</font>）包裹着另一个对象，这个被包裹的对象的类型可以为任何类型。可以使用<code>Optional</code>声明或者赋值一个可选变量：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> stringMaybe = Optional(<span style="color:#e6db74">&#34;howdy&#34;</span>)
</span></span><span style="display:flex;"><span>debugPrint(stringMaybe)
</span></span><span style="display:flex;"><span>stringMaybe = Optional(<span style="color:#e6db74">&#34;fareWell&#34;</span>)
</span></span><span style="display:flex;"><span>debugPrint(stringMaybe)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> stringMaybe1: String? = Optional(<span style="color:#e6db74">&#34;test&#34;</span>) <span style="color:#75715e">// optional可选值</span>
</span></span><span style="display:flex;"><span>debugPrint(stringMaybe1)
</span></span><span style="display:flex;"><span>stringMaybe1 = <span style="color:#e6db74">&#34;name&#34;</span>
</span></span><span style="display:flex;"><span>debugPrint(stringMaybe1)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//Optional(&#34;howdy&#34;)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//Optional(&#34;fareWell&#34;)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//Optional(&#34;test&#34;)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//Optional(&#34;name&#34;)</span>
</span></span></code></pre></div><p>声明可选值，通常不使用<code>Optional</code>初始化器，而是将某种类型的值分配或传递给一个已经声明成<code>Optional</code>的引用。在上面代码中，一旦<code>stringMaybe</code>被类型化为一个包裹着<code>String</code>的<code>Optional</code>，那么直接向其赋一个<code>String</code>是合法的，赋值的字符串被自动包装成一个<code>Optional</code>。</p>
<p>从形式上看，<code>Optional</code>是一个泛型，所以包裹一个字符串的<code>Optional</code>是一个<code>Optional&lt;String&gt;</code>。实际上，不必这样写，<code>Swift</code>语言支持用<font color=red>语法糖</font>来表达一个<code>Optional</code>类型：被包装类型的名称后面跟一个问号：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> stringMaybe : String?
</span></span></code></pre></div><p>如果期望是一个<code>Optional</code>包装的某种类型，可以传递一个包装类型的值来代替。这是因为参数传递就像赋值一样：<font color=red>一个未被包裹的值会被隐含地包裹起来</font>。如果一个函数期望一个包裹着字符串的<code>Optional</code>参数，可以直接传递一个字符串参数，它将自动地转换成<code>Optional</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">optionalExpecter</span>(<span style="color:#66d9ef">_</span> s: String?) { <span style="color:#75715e">// ... here, s will be an Optional wrapping a String ... </span>
</span></span><span style="display:flex;"><span>    debugPrint(s)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>optionalExpecter(<span style="color:#e6db74">&#34;howdy&#34;</span>) <span style="color:#75715e">// console debugPrints: Optional(&#34;howdy&#34;)</span>
</span></span></code></pre></div><p>如果期望的是一个非<code>Optional</code>的类型，实际上却传递了一个<code>Optional</code>的类型，那么编译器将会报错。下面代码将会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">realStringExpecter</span>(<span style="color:#66d9ef">_</span> s: String) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> stringMaybe: String? = <span style="color:#e6db74">&#34;howdy&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// compile error: Value of optional type &#39;String?&#39; must be unwrapped to a value of type &#39;String&#39;</span>
</span></span><span style="display:flex;"><span>realStringExpecter(stringMaybe) 
</span></span></code></pre></div><p>如果想使用一个<code>Optional</code>，它所包裹的东西的类型是预期的，必须解开这个<code>Optional</code>。也就是说，<font color=red>必须进入它的内部，取出它所包裹的实际东西</font>。</p>
<h3 id="unwrapping-an-optional">Unwrapping an Optional</h3>
<p>已经看到了不止一种将一个对象包裹在一个<code>Optional</code>中的方法。但是相反的过程呢？如何解开一个<code>Optional</code>来获取它里面包裹的对象呢？一种方法是使用<code>unwrap</code>操作符（或强制<code>unwrap</code>操作符），它是一个后缀的感叹号：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">realStringExpecter</span>(<span style="color:#66d9ef">_</span> s: String) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> stringMaybe: String? = <span style="color:#e6db74">&#34;howdy&#34;</span>
</span></span><span style="display:flex;"><span>realStringExpecter(stringMaybe!)
</span></span></code></pre></div><p>在上面这段代码中，<code>stringMaybe！</code>语法表达了在<code>Optional stringMaybe</code>内部的操作，即获取被包裹的值。由于<code>stringMaybe</code>是一个包裹着<code>String</code>的<code>Optional</code>，它里面的东西就是一个<code>String</code>。这正是<code>realStringExpecter</code>函数想要的实参。<code>stringMaybe</code>是一个包裹着字符串 <code>&quot;howdy &quot;</code>的<code>Optional</code>，但<code>stringMaybe！</code>是字符串 <code>&quot;howdy&quot;</code>。</p>
<p>如果<code>Optional</code>包裹着某个类型，不能直接向它发送这个类型的消息，必须先解开这个<code>Optional</code>，也就是要解开<code>stringMaybe</code>取它里面的<code>String</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> stringMaybe : String? = <span style="color:#e6db74">&#34;howdy&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> upper = stringMaybe.uppercased() <span style="color:#75715e">// compile error</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Value of optional type &#39;String?&#39; must be unwrapped to refer to member &#39;uppercased&#39; of wrapped base type &#39;String&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> stringMaybe: String? = <span style="color:#e6db74">&#34;howdy&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> upper = stringMaybe!.uppercased() <span style="color:#75715e">// compile error</span>
</span></span></code></pre></div><h3 id="implicitly-unwrapped-optional">Implicitly unwrapped Optional</h3>
<p><code>Swift</code>提供了另一种使用<code>Optional</code>的方式，即在预期使用包裹的类型是的地方使用隐式解包类型。隐式解包类型也是一种<code>Optional</code>，但是编译器允许它直接在期望包裹类型的地方。</p>
<p>实际上，也可以对一个隐式解包类型进行解包，但没必要这样做，因为如果试图在期望解包类型的地方使用它，将自动解包。</p>
<p>请记住，一个隐式解包的<code>Optional</code>仍然是一个<code>Optional</code>。通过将某些东西声明为隐式解包的<code>Optional</code>，就是在请求编译器，如果碰巧在预期的包装类型中使用这个值，请原谅并自动解包这个值。</p>
<p>实际上，<font color=red>一个隐式解包的<code>Optional</code>类型并不是一个真正的独立类型</font>。它只是一个以特殊方式标记的<code>Optional</code>，允许它在预期解包类型的地方被使用。由于这个原因，<font color=red>隐式解包并不通过赋值传播</font>。</p>
<p>如果<code>self</code>是一个<code>UIViewController</code>，那么<code>self.view</code>的类型就是<code>UIView！</code>。因此，下面这个表达式是合法的（假设<code>v</code>是一个<code>UIView</code>）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">self</span>.view.addSubview(v)
</span></span></code></pre></div><p>但是，下面是不合法的，因为<font color=red>隐式解包并不通过赋值传播</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> mainview = <span style="color:#66d9ef">self</span>.view
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> v = UIView()
</span></span><span style="display:flex;"><span>mainview.addSubview(v) <span style="color:#75715e">// compile error</span>
</span></span></code></pre></div><p>也可以在一开始就显式地解开隐式解包的<code>Optional</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> mainview = <span style="color:#66d9ef">self</span>.view! 
</span></span><span style="display:flex;"><span>mainview.addSubview(v)
</span></span></code></pre></div><h3 id="the-keyword-nil">The keyword nil</h3>
<p>在与<code>nil</code>以外的东西进行相等比较时，<code>Optional</code>得到了特殊的待遇：<font color=LightSeaGreen>真正被比较的是被包裹的值</font>，而不是<code>Optional</code>本身被比较：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s: String? = <span style="color:#e6db74">&#34;Howdy&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> s == <span style="color:#e6db74">&#34;Howdy&#34;</span> { <span style="color:#75715e">// ... they _are_ equal!</span>
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面的例子中，<code>Swift</code>不会将<code>Optional</code>本身与<code>&quot;Howdy&quot;</code>进行比较，<font color=red>而是自动地（安全地）将其包装值（如果有）与<code>&quot;Howdy&quot;</code>进行比较</font>。如果包裹的值是<code>&quot;Howdy&quot;</code>，则比较成功。如果被包装的值不是<code>&quot;Howdy&quot;</code>，则比较失败。如果没有被包装的值（也就是为<code>nil</code>），那么比较也会安全地失败。</p>
<p>能够使用<code>==</code>操作符，则被包裹的类型必须遵循<code>Equatable</code>协议。如果没有遵守这个协议，编译器会阻止一个<code>Optional</code>类型使用<code>==</code>进行比较。</p>
<h1 id="object-types">Object Types</h1>
<p><code>Swift</code>中有三种对象（<code>object</code>）类型，它们分别是<code>enum,struct,class</code>。<font color=Blue>对象类型的作用域取决于类型声明所在的位置</font>，可能出现的位置有三种：</p>
<ul>
<li>
<p>顶层声明：声明在文件顶部，默认情况下对同一个<code>module</code>中所有文件都是可见的。</p>
</li>
<li>
<p>另一个类型声明中内嵌：在另一个类型的声明中内嵌声明一个类型是很有用的，相当于给这个内嵌类型一个命名空间。</p>
</li>
<li>
<p>函数体中：在函数体中声明的对象类型的生命周期只存在于包含它的花括号内，这样的声明是合法的，但使用场景较少。</p>
</li>
</ul>
<p>对于任何对象类型声明时都可以在其花括号内包含以下五个方面的内容：</p>
<ol>
<li>初始化器：初始化器是一个函数，以一种特殊的方式声明和调用，以生成对象实例。</li>
<li>属性：在对象类型声明的顶层声明的变量是一个属性。</li>
<li>方法：在对象类型声明的顶层声明的函数是一个方法。</li>
<li>下标：下标是一种特殊的方法，通过在实例引用或类型名称后面加上方括号来调用。</li>
<li>内嵌类型：一个对象类型声明可以包含另一个对象类型声明（内嵌类型）。</li>
</ol>
<h2 id="initializers">Initializers</h2>
<p>初始化器是一个用于产生对象实例的函数。严格地说，<font color=red>初始化器是一个静态/类方法，因为它是被对象类型调用的</font>。它通过特殊的语法来调用的：类型的名字后面直接加上圆括号。当一个初始化器被调用时，一个新的实例被创建并作为结果返回：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> dog = Dog()
</span></span></code></pre></div><p>上面的代码中，<code>Dog()</code>调用了一个初始化器，尽管<code>Dog</code>类没有声明任何初始化器，但并没有编译错误。这是因为，<font color=LightSeaGreen>如果没有自定义初始化器，则编译器会自动生成一个无参数的初始化器</font>。</p>
<p>除了使用编译器自动生成的初始化器，也可以编写自己的初始化器。初始化器是一种特殊的函数，有特殊的声明语法，<font color=red>不需要使用<code>func</code>关键字、箭头符号以及返回值类型</font>。</p>
<p>自定义初始化器的声明使用关键字<code>init</code>和一个参数列表，然后紧跟函数体。一个对象类型可以有多个初始化器，以其参数（个数和类型以及顺序）来区分：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name = <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> license = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(name: String) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.license = license
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(name: String, license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.license = license
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面自定义了三个初始化器，即提供了三种方式创建<code>Dog</code>实例。但现在已经不能使用没有参数的初始化器了，<font color=red>因为一旦有了自定义的初始化器，编译器就不会再自动生成无参的初始化器了</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> fido = Dog(name: <span style="color:#e6db74">&#34;Fido&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> rover = Dog(license: <span style="color:#ae81ff">1234</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> spot = Dog(name: <span style="color:#e6db74">&#34;Spot&#34;</span>, license: <span style="color:#ae81ff">1357</span>)
</span></span></code></pre></div><p>也可以显式声明一个无参的自定义初始化器，以避免使用使用无参初始化器时出现编译报错。下面代码声明了一个无参初始化器<code>init()</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name = <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> license = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>() {
</span></span><span style="display:flex;"><span>       <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(name: String) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.license = license
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(name: String, license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.license = license
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>当实例生成时，如果实例属性还没有初始值，则编译器会报错。因此，<font color=LightSeaGreen>一个属性可以作为其声明的一部分被初始化，或被其中的每个初始化器初始化</font>，否则会出现编译错误。</p>
<p><code>Swift</code>编译器<font color=red>强制要求所有的实例属性都要正确地初始化</font>，这是<code>Swift</code>的一个重要特征。相比之下，<code>Objective-C</code>的实例属性可以不初始化，而且经常会这样，导致可能出现奇怪的错误。</p>
<p>因为在初始化器中设置一个实例属性也算作初始化，<font color=red>所以即使实例属性是用<code>let</code>声明的常量也是合法的</font>。下面代码将<code>name</code>和<code>license</code>都声明为常量属性，在初始化器中再初始化也是合法的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> name: String
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> license: Int
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(name: String, license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.license = license
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="deferred-initialization-of-properties">Deferred initialization of properties</h3>
<p>有时，在初始化时还不能初始化一个实例属性为有意义的值。也许这个属性的初始值要在这个实例生成后的某个时间点才能得到。这种情况<font color=red>与所有实例属性在其声明中初始化或通过初始化器进行初始化的要求相冲突</font>。</p>
<p>可以通过分配一个默认的初始值来规避这个问题，但此时无法向你自己的代码传达这样一个事实：这个默认值不是<code>real</code>的值。</p>
<p>一个常见的解决方案是将实例属性声明为<code>Optional</code>类型的<code>var</code>。<code>Optional</code>类型有一个值<code>nil</code>，表示没有提供<code>real</code>的值，并且<font color=LightSeaGreen>一个<code>Optional var</code>会自动初始化为`nil</font>。</p>
<p>因此，代码中可以用<code>nil</code>来测试这个<code>Optional</code>实例属性，如果它是<code>nil</code>，就暂时不要使用这个属性。该属性会在某个时刻被赋予<code>real</code>值，这个值是被包裹在<code>Optional</code>中的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#75715e">// this property will be set automatically when the nib loads</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">@IBOutlet</span> <span style="color:#66d9ef">var</span> myButton: UIButton!
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// this property will be set after time-consuming gathering of data </span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> albums : [MPMediaItemCollection]?
</span></span></code></pre></div><h3 id="referring-to-self">Referring to self</h3>
<p>一个初始化器<font color=red>可以引用一个已经初始化的实例属性，也可以引用一个未初始化的实例属性，以便初始化它</font>。<font color=LightSeaGreen>除了这种情况，在所有实例属性被初始化之前，初始化器不得显式或隐式地引用<code>self</code></font>。这条规则保证了实例在使用之前已经完全生成。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Cat</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name: String
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> license: Int
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(name: String, license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name
</span></span><span style="display:flex;"><span>        meow() <span style="color:#75715e">// too soon - compile error</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.license = license
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">meow</span>() {
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;meow&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面代码会出现编译错误<code>'self' used before all stored properties are initialized</code>，因为<code>license</code>属性还未初始化前就已经调用了<code>meow</code>。</p>
<h3 id="delegating-initializers">Delegating initializers</h3>
<p>在初始化器中，<font color=Blue>如果调用了另一个初始化器，那这个初始化器被称为代理初始化器</font>。代理初始化器<font color=red>调用的其它初始化器必须已经将所有的存储属性初始化</font>，否则会出现编译错误。</p>
<p>当一个初始化器进行委托时，另一个初始化器（它所委托的那个），必须先完全初始化实例，然后委托的初始化器可以对完全初始化的实例进行处理，可能会再次设置已经被它所委托的初始化器设置的<code>var</code>属性。</p>
<p>代理初始化器看起来是过早使用<code>self</code>调用函数的一个反例，但事实并不是这样，代理初始化使用<code>self</code>调用函数是为了初始化储存属性。</p>
<p>代理初始化器在<font color=red>调用其它初始化器之前不能使用<code>self</code>，即使是给存储属性赋初值也不行</font>。下面代理初始化器中，第一行是初始化<code>meaningOfLife</code>，会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Digit</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> number: Int
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> meaningOfLife: Bool
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(number: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.number = number
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.meaningOfLife = <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>() { <span style="color:#75715e">// this is a delegating initializer</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.meaningOfLife = <span style="color:#66d9ef">false</span> <span style="color:#75715e">//&#39;self&#39; used before &#39;self.init&#39; call or assignment to &#39;self&#39;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.<span style="color:#66d9ef">init</span>(number: <span style="color:#ae81ff">42</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在代理初始化器中，不能再对<code>let</code>常量属性赋值，因为<font color=red>调用其它初始化器时已经将常量属性赋了初始值，如果再次对其赋值会出现编译错误</font>。因为在代理初始化器中可以调用其它初始化器，千万不要形成递归调用，下面代码就会产生递归引用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#75715e">// do not do this!</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Digit</span> {  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> number: Int = <span style="color:#ae81ff">100</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(value: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.<span style="color:#66d9ef">init</span>(number: value)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(number: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.<span style="color:#66d9ef">init</span>(value: number)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>也就是说在一个初始化器中，一旦出现了另一个初始化器，那么这个初始化器必须在第一行，否则将会出现编译错误！</p>
<h3 id="failable-initializers">Failable initializers</h3>
<p>一个<font color=red>初始化器可以返回一个可选的新实例</font>，返回<code>nil</code>表示初始化失败，这种初始化器被称为可失败的初始化器。声明可失败的初始化器很简单，只要在<code>init</code>后面添加一个<code>?</code>即可:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> name: String
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> license: Int
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>?(name: String, license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> name.isEmpty {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>  <span style="color:#75715e">// 返回nil</span>
</span></span><span style="display:flex;"><span>        } 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> license <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>        } 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.license = license
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="properties">Properties</h2>
<h4 id="property-initialization-and-self">Property initialization and self</h4>
<p>实例属性在声明的同时可以进行初始化，但<font color=red>初始化某个实例属性时不能获取其它实例属性或调用一个实例方法，因为此时实例尚未生成</font>。下面代码中<code>whole</code>初始化时获取了其他属性，所以会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Moi</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> first = <span style="color:#e6db74">&#34;Matt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> last = <span style="color:#e6db74">&#34;Neuburg&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> whole = <span style="color:#66d9ef">self</span>.first <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">self</span>.last <span style="color:#75715e">// compile error: Cannot find &#39;self&#39; in scope</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>解决上面编译错误有三种方法，第一种是把<code>whole</code>声明为计算属性而非存储属性，因为<font color=red>计算属性是在实例初始化完成之后才会被调用的</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Moi</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> first = <span style="color:#e6db74">&#34;Matt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> last = <span style="color:#e6db74">&#34;Neuburg&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> whole: String {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.first <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">self</span>.last
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>第二种方法是把<code>whole</code>声明为<code>lazy</code>的<code>var</code>变量。同计算变量一样，<code>lazy</code>变量<font color=red>也是要等实例初始化完成之后才会被调用</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Moi</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> first = <span style="color:#e6db74">&#34;Matt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> last = <span style="color:#e6db74">&#34;Neuburg&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">lazy</span> <span style="color:#66d9ef">var</span> whole = <span style="color:#66d9ef">self</span>.first <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">self</span>.last
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>第三种方法就是使用匿名函数的<code>define-and-call</code>进行初始化。因为要在匿名函数中使用<code>self</code>，所以也需要把实例属性声明为<code>lazy</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Moi</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> first = <span style="color:#e6db74">&#34;Matt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> last = <span style="color:#e6db74">&#34;Neuburg&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">lazy</span> <span style="color:#66d9ef">var</span> whole: String = {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">var</span> s = <span style="color:#66d9ef">self</span>.first
</span></span><span style="display:flex;"><span>        s.append(<span style="color:#e6db74">&#34; &#34;</span>)
</span></span><span style="display:flex;"><span>        s.append(<span style="color:#66d9ef">self</span>.last)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> s
</span></span><span style="display:flex;"><span>    }()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>不像实例属性，<font color=red>静态属性可以在初始化的时候引用其他静态属性</font>，因为<font color=red>静态属性初始化器本身就是<code>lazy</code>的</font>。下面的代码不会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Greeting</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> friendly = <span style="color:#e6db74">&#34;hello there&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> hostile = <span style="color:#e6db74">&#34;go away&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> ambivalent = friendly <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; but &#34;</span> <span style="color:#f92672">+</span> hostile
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>debugPrint(Greeting.ambivalent)
</span></span></code></pre></div><p>上面的代码中，静态属性进行初始化的时候省略了<code>self</code>，这是因为它隐含地包含了<code>self</code>，但是上面代码中不能显式使用<code>self</code>（自认为是编译器的一个<code>bug</code>）。</p>
<p>对于静态属性来说，大写开头的<code>Self</code>表示类型本身。实际上在静态属性初始化时，如果要引用其它静态属性，前面加上自身的类型会有更好的可读性：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Greeting</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> friendly = <span style="color:#e6db74">&#34;hello there&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> hostile = <span style="color:#e6db74">&#34;go away&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> ambivalent = Greeting.friendly <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; but &#34;</span> <span style="color:#f92672">+</span> Greeting.hostile
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Greeting</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> friendly = <span style="color:#e6db74">&#34;hello there&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> hostile = <span style="color:#e6db74">&#34;go away&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> ambivalent = <span style="color:#66d9ef">Self</span>.friendly <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; but &#34;</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">Self</span>.hostile
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>需要特别注意的是，在声明静态计算变量时，<font color=red>如果使用匿名函数的<code>define-and-call</code>初始化，不能在匿名函数中使用<code>self</code>（自认为这是一个系统<code>bug</code>）</font>，而是应该使用大写的<code>S</code>开头的<code>Self</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Greeting</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> friendly = <span style="color:#e6db74">&#34;hello there&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> hostile = <span style="color:#e6db74">&#34;go away&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">var</span> ambivalent: String = {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.friendly <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; but &#34;</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">self</span>.hostile <span style="color:#75715e">// compile error: Cannot find &#39;self&#39; in scope</span>
</span></span><span style="display:flex;"><span>    }()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Greeting</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> friendly = <span style="color:#e6db74">&#34;hello there&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> hostile = <span style="color:#e6db74">&#34;go away&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">var</span> ambivalent: String = {
</span></span><span style="display:flex;"><span>        friendly <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; but &#34;</span> <span style="color:#f92672">+</span> hostile <span style="color:#75715e">// 省略self才不会报错</span>
</span></span><span style="display:flex;"><span>    }()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Greeting</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> friendly = <span style="color:#e6db74">&#34;hello there&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> hostile = <span style="color:#e6db74">&#34;go away&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">var</span> ambivalent: String = {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">Self</span>.friendly <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; but &#34;</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">Self</span>.hostile <span style="color:#75715e">// 或者使用大写开头Selfscope</span>
</span></span><span style="display:flex;"><span>    }()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="methods">Methods</h2>
<p>在静态/类成员和实例成员之间存在着一种隔阂，尽管它们被声明在同一个对象类型中，但属于不同的世界。一个静态/类方法不能引用<code>instance</code>，因为在静态方法中没有实例。</p>
<p>因此，一个静态/类方法<font color=red>不能直接引用任何实例属性或调用任何实例方法</font>。另一方面，一个实例方法可以引用类型，因此可以访问静态/类的属性，能调用静态/类方法。</p>
<h4 id="the-secret-life-of-instance-methods">The Secret Life of Instance Methods</h4>
<p>实际上，实例方法也是静态/类方法。在下面的代码中，尽管<code>store</code>是一个实例方法，但可以通过类型来调用，<font color=LightSeaGreen>只需把一个实例参数传进去</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClass</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> s = <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">store</span>(<span style="color:#66d9ef">_</span> s: String) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.s = s
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;MyClass test&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> m = MyClass()
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> f = MyClass.store(m) <span style="color:#75715e">// what just happened!?</span>
</span></span><span style="display:flex;"><span>f(<span style="color:#e6db74">&#34;s&#34;</span>)
</span></span><span style="display:flex;"><span>debugPrint(m.s)
</span></span></code></pre></div><p>原因是，<font color=red>一个实例方法实际上是一个柯里化的静态/类函数</font>。一个函数接受一个实例，另一个函数接受实例方法的参数。在上面代码中，<code>f</code>是第二个函数，并可以作为传递参数给实例<code>m</code>的<code>store</code>方法的一种方式被调用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>f(<span style="color:#e6db74">&#34;howdy&#34;</span>)
</span></span><span style="display:flex;"><span>debugPrint(m.s)
</span></span></code></pre></div><h2 id="subscripts">Subscripts</h2>
<p>下标是一种方法，它通过将包含参数的方括号直接附加到一个对象的引用上来调用。可以把这个功能用于任何你喜欢的地方，但它特别适用于这样的情况：一个对象类型，<font color=Blue>其元素可以通过键或索引来访问</font>。</p>
<p>声明下标方法有点像普通函数的声明又有点像计算属性的声明。它<font color=red>可以接受参数，当下标方法被调用时，参数可以出现在方括号中</font>。一个下标就像一个计算属性，它的调用就像引用一个属性，可以获取它的值，也可以向它赋值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Digit</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> number: Int
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(<span style="color:#66d9ef">_</span> n: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.number = n
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">subscript</span>(ix: Int) -&gt; Int { <span style="color:#75715e">// ① ②</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">get</span> { <span style="color:#75715e">// ③</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> s = String(<span style="color:#66d9ef">self</span>.number)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> Int(String(s[s.index(s.startIndex, offsetBy: ix)]))<span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol>
<li>
<p>关键字<code>sbuscript</code>后面紧跟参数列表，说明方括号内要出现哪些参数。<font color=red>默认情况下，参数名不会被外化</font>。如果要外化参数名，需要在内部参数前外化，即使它们的名字是相同的<code>subscript(ix ix:Int)</code>，<font color=red>这一点和普通函数的参数外化十分不同</font>。</p>
</li>
<li>
<p>然后箭头后面紧跟的传出（调用<code>getter</code>函数时）或传入（调用<code>setter</code>函数时）值的类型。</p>
</li>
<li>
<p>最后是花括号，其内容与计算属性的内容完全一样。可以用<code>get</code>和花括号表示<code>getter</code>函数，用<code>set</code>和花括号表示<code>setter</code>函数。<code>setter</code>函数可以被省略，在这种情况下，<code>get</code>这个词和它的花括号可以一同被省略。如果<code>getter</code>函数<font color=Blue>只由一条语句组成，可以省略关键字<code>return</code></font>。<code>setter</code>函数接收的新值是<code>newValue</code>，但可以通过在<code>set</code>这个词后面的圆括号里提供一个不同的名字来实现自定义名字。</p>
</li>
</ol>
<p>下面代码调用了<code>subscript</code>中的<code>getter</code>的方法。在<code>Digit</code>实例后面跟着方括号，方括号里面有<code>Int</code>参数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> d = Digit(<span style="color:#ae81ff">1234</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> aDigit = d[<span style="color:#ae81ff">1</span>]
</span></span></code></pre></div><p>下面代码中<code>Digit</code>类型中包含了<code>subscript</code>下标方法，并且下标方法中也包含了<code>setter</code>，可以使用<code>d[0] = 2</code>这样的语句来访问下标的<code>setter</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Digit</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> number: Int
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(<span style="color:#66d9ef">_</span> n: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.number = n
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">subscript</span>(ix: Int) -&gt; Int {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">get</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> s = String(<span style="color:#66d9ef">self</span>.number)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> Int(String(s[s.index(s.startIndex, offsetBy: ix)]))<span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">set</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">var</span> s = String(<span style="color:#66d9ef">self</span>.number)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> i = s.index(s.startIndex, offsetBy: ix)
</span></span><span style="display:flex;"><span>            s.replaceSubrange(i...i, with: String(newValue))
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">self</span>.number = Int(s)<span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>一种类型中可以声明多个<code>subscript</code>方法，以参数个数和类型进行区分。<font color=red>从<code>Swift 5.1</code>开始，<code>subscript</code>方法可以是静态的。从<code>Swift 5.2</code>开始，<code>subscript</code>方法可以有默认参数</font>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">NewDigit</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> number: Int
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(<span style="color:#66d9ef">_</span> n: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.number = n
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">subscript</span>(ix: Int) -&gt; Int {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">get</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> s = String(<span style="color:#66d9ef">self</span>.number)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> Int(String(s[s.index(s.startIndex, offsetBy: ix)]))<span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">set</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">var</span> s = String(<span style="color:#66d9ef">self</span>.number)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> i = s.index(s.startIndex, offsetBy: ix)
</span></span><span style="display:flex;"><span>            s.replaceSubrange(i...i, with: String(newValue))
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">self</span>.number = Int(s)<span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">subscript</span>(index: String) -&gt; Int {
</span></span><span style="display:flex;"><span>        debugPrint(index)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">subscript</span>(index: Double = <span style="color:#ae81ff">0</span>) -&gt; Int {
</span></span><span style="display:flex;"><span>        debugPrint(index)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>需要注意的是对于下标的重载来说，<em><font color=red>如果均没有使用外部参数，并且只是内部参数名不同，参数的个数、类型以及顺序都相同的话，会出现编译错误</font></em>，这是因为没有外部参数时仅使用方括号调用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">subscript</span>(ix: Int) -&gt; Int {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">get</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> s = String(<span style="color:#66d9ef">self</span>.number)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Int(String(s[s.index(s.startIndex, offsetBy: ix)]))<span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">set</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">var</span> s = String(<span style="color:#66d9ef">self</span>.number)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> i = s.index(s.startIndex, offsetBy: ix)
</span></span><span style="display:flex;"><span>        s.replaceSubrange(i...i, with: String(newValue))
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.number = Int(s)<span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">subscript</span>(newIndex: Int) -&gt; Int {
</span></span><span style="display:flex;"><span>    debugPrint(newIndex)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果<font color=red>只是外部参数不同，内部参数个数和类型都相同，则不会出现编译错误</font>，因为编译器会认为这是不同的<code>subscript</code>方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name: String
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> license: Int
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>?(name: String, license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> name.isEmpty {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>  <span style="color:#75715e">// 返回nil</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> license <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.license = license
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">subscript</span>(at index: Int) -&gt; String {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">get</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">self</span>.name
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">set</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">self</span>.name = newValue
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">subscript</span>(<span style="color:#66d9ef">for</span> index: Int) -&gt; String {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">get</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">self</span>.name
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">set</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">self</span>.name = newValue
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> dog = Dog(name: <span style="color:#e6db74">&#34;test&#34;</span>, license: <span style="color:#ae81ff">1345</span>)
</span></span><span style="display:flex;"><span>dog?[at: <span style="color:#ae81ff">123</span>]
</span></span><span style="display:flex;"><span>dog?[<span style="color:#66d9ef">for</span>: <span style="color:#ae81ff">134</span>]
</span></span></code></pre></div><h2 id="nested-object-types">Nested Object Types</h2>
<p>一个类型声明在另一个类型里面，就会形成内嵌类型。嵌套的对象类型与其它对象类型没有什么不同，但是从外部引用内嵌类型的规则发生了变化，<em><font color=LightSeaGreen>外部的对象类型作为一个命名空间，必须明确地被引用才能访问嵌套的对象类型</font></em>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Noise</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">var</span> noise = <span style="color:#e6db74">&#34;woof&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(Dog.Noise.noise)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 访问静态属性</span>
</span></span><span style="display:flex;"><span>Dog.Noise.noise = <span style="color:#e6db74">&#34;arf&#34;</span>
</span></span></code></pre></div><p>在上面的代码中，结构体<code>Noise</code>定义在类<code>Dog</code>中，它并不是自由的，而是明确地与<code>Dog</code>类相关联，属于<code>Dog</code>中的类型。不同的命名空间允许有相同的<code>Noise</code>类型存在，而不会产生冲突。</p>
<p>在<code>Swift</code>的内置类型中，经常使用命名空间来解决类型冲突。例如，<code>String</code>结构体是包含<code>Index</code>结构体的几个结构体之一，但它们并没有名字冲突。</p>
<p>嵌套的内部类型<font color=red>不能直接访问其外部类型的实例成员，但是能直接访问其静态/类成员</font>。在下面的代码中，<code>Noise</code>类型不能直接访问<code>Dog</code>类型的实例方法<code>bark</code>，但是能直接访问它的静态属性<code>sound</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> sound = <span style="color:#e6db74">&#34;ruff&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Noise</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">var</span> noise = <span style="color:#e6db74">&#34;woof&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">barkTheDog</span>() {
</span></span><span style="display:flex;"><span>            bark()  <span style="color:#75715e">// compile error: Instance member &#39;bark&#39; of type &#39;Dog&#39; cannot be used on instance of nested type &#39;Dog.Noise&#39;</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">var</span> othernoise = sound <span style="color:#75715e">// fine</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(Dog.Noise.noise)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在上面的代码中，内嵌类型<code>Noise</code>能直接访问静态属性<code>sound</code>，而不需要使用<code>Dog.sound</code>，因为外层定义的静态属性<code>sound</code>，对于内嵌类型来说是全局的。</p>
<h1 id="enums">Enums</h1>
<p>枚举是一种对象类型，它的实例代表不同的预定义可选择值，可以将这些预定义值看作是<font color=LightSeaGreen>一个已知可能值列表</font>，<font color=red>枚举是表达一组常量值的<code>Swift</code>方式</font>。枚举声明包含<code>case</code>语句，每个<code>case</code>是一个可选择值的名称，一个枚举实例准确地代表一种选择：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Filter</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> albums
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> playlists
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> podcasts
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> books
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面定义的枚举<code>Filter</code>没有初始化器，实际上是可以自定义枚举类型的初始化器。但有一个默认的初始化器，可能在大多数时候都会使用它，即枚举的名称后面加上点号和其中一个<code>case</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> type = Filter.albums
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> type: Filter = .albums
</span></span></code></pre></div><p>有相同<code>case</code>枚举实例被认为是相同的。可以将一个枚举实例与一个<code>case</code>进行比较：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">filterExpecter</span>(<span style="color:#66d9ef">_</span> type: Filter) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> type == .albums {
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;it is albums&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>filterExpecter(.albums) <span style="color:#75715e">// &#34;it is albums&#34;</span>
</span></span></code></pre></div><h2 id="raw-values">Raw Values</h2>
<p>在使用<code>enum</code>声明枚举类型时，可以添加一个类型声明，但<font color=red>这种类型只限于数值型和字符串</font>。如果增加的类型是整数类型，每个<code>case</code>都有默认值，默认值从<code>0</code>开始：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">PepBoy</span>: Int {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> manny
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> moe
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> jack
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在上面的代码中，<code>.manny</code>的默认值是<code>0</code>，<code>.moe</code>的值是<code>1</code>，以此类推。如果类型是字符串，在定义的时候如果不设置<code>case</code>对应的字符串，<font color=red>则默认值是每个<code>case</code>对应的名字</font>。下面代码中，<code>.albums</code>的默认值是<code>&quot;albums&quot;</code>，<code>.playlists</code>的值是<code>&quot;playlists&quot;</code>，以此类推：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Filter</span>: String {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> albums
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> playlists
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> podcasts
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> books
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果在声明带类型的枚举时，不管声明枚举时使用的是哪种类型，如果不想使用默认值，实际上可以为每个<code>case</code>显式赋值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Normal</span>: Double {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> fahrenheit = <span style="color:#ae81ff">98.6</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> centigrade = <span style="color:#ae81ff">37</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">PepBoy</span>: Int {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> manny = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> moe <span style="color:#75715e">// 2 implicitly</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> jack = <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Filter</span>: String {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> albums = <span style="color:#e6db74">&#34;Albums&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> playlists = <span style="color:#e6db74">&#34;Playlists&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> podcasts = <span style="color:#e6db74">&#34;Podcasts&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> books = <span style="color:#e6db74">&#34;Audiobooks&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>case</code>所携带的值称为<code>raw value</code>。<font color=red>一个有类型声明的枚举隐含地遵循了<code>RawRepresentable</code>协议，这意味着它有一个<code>init(rawValue:)</code>初始化器和一个<code>rawValue</code>属性</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Normal</span>: Double {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> fahrenheit = <span style="color:#ae81ff">98.6</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> centigrade = <span style="color:#ae81ff">37</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">PepBoy</span>: Int {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> manny = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> moe <span style="color:#75715e">// 2 implicitly: 默认为2</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> jack = <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Filter</span>: String {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> albums = <span style="color:#e6db74">&#34;Albums&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> playlists = <span style="color:#e6db74">&#34;Playlists&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> podcasts = <span style="color:#e6db74">&#34;Podcasts&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> books = <span style="color:#e6db74">&#34;Audiobooks&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> type = Filter.albums 
</span></span><span style="display:flex;"><span>print(type.rawValue) <span style="color:#75715e">// Albums</span>
</span></span></code></pre></div><p>带类型的枚举声明时，每个<code>case</code>的<code>raw value</code><font color=Blue>必须保证是唯一的，否则会出现编译错误</font>。因此，可以使用<code>raw value</code>实例化一个枚举：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> type = Filter(rawValue:<span style="color:#e6db74">&#34;Albums&#34;</span>)
</span></span></code></pre></div><p>但使用<code>init(rawValue:)</code>可能失败，因为用户传入的<code>raw value</code>可能与<code>case</code>不匹配，所以它实际上是可失败的初始化器<code>init?(rawValue:)</code>。</p>
<h2 id="associated-values">Associated Values</h2>
<p>上面说的<code>raw value</code>对于每个<code>case</code>来说<font color=LightSeaGreen>都是固定的，在枚举类型声明的时候就已经确定了</font>。有一种方法可以构造一个<code>case</code>，使得<font color=red>其常量值可以在实例创建时才被设置</font>，此时设置的附加值被称为<code>associated value</code>。</p>
<p>声明带<code>associated value</code>的枚举类型时，<font color=red>不能为整个枚举类型声明任何原始值类型</font>。而是在有需要的<code>case</code>上附加一个看起来像元组的表达式，即括号里包含一个可能的标记类型列表。与<code>rawValue</code>不同，<code>associated value</code>无类型上的限制：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">MyError</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> number(Int)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> message(String)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> fatal
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面声明的含义为：在<code>MyError</code>实例化时，一个<code>.number case</code>的<code>MyError</code>实例必须被设置一个<code>Int</code>值，一个<code>.message case</code>的<code>MyError</code>实例必须设置一个<code>String</code>值，而一个<code>.fatal case</code>的<code>MyError</code>实例不用设置任何值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> err1 : MyError = .number(<span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> num = <span style="color:#ae81ff">4</span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> err2 : MyError = .number(num)
</span></span></code></pre></div><p>如果一个<code>case</code>的<code>associated value</code>类型有标签，<font color=red>标签必须在初始化的时候使用</font>。下面代码中，枚举中的<code>case fetal</code>有标签，需要在初始化时使用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">MyError2</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> number(Int)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> message(String)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> fatal(n: Int, s: String)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> err: MyError2 = .fatal(n: <span style="color:#f92672">-</span><span style="color:#ae81ff">12</span>, s: <span style="color:#e6db74">&#34;Oh the horror&#34;</span>)
</span></span></code></pre></div><p>默认情况<font color=red><code>==</code>操作符不能直接用于比较带有<code>associated value</code>的枚举</font>，否则会出现编译错误。下面代码中，因为直接比较两个枚举值，会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">MyError2</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> number(Int)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> message(String)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> fatal(n: Int, s: String)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> err: MyError2 = .fatal(n: <span style="color:#f92672">-</span><span style="color:#ae81ff">12</span>, s: <span style="color:#e6db74">&#34;Oh the horror&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// operator &#39;==&#39; cannot be applied to operands of type &#39;MyError2&#39; and &#39;(Int, String) -&gt; MyError2&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> err == MyError2.fatal { <span style="color:#75715e">// compile error</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果声明带<code>associated value</code>枚举时<font color=red>显式地遵循<code>Equatable</code>协议</font>，<code>==</code>操作符就能正常工作了。但<font color=red>前提是所有<code>associated value</code>中的类型本身都是遵循<code>Equatable</code>协议</font>，否则也会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">MyError</span>: Equatable {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> number(Int)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> message(String)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> fatal
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> error: MyError = .fatal
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> error == .fatal {
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="optional-1">Optional</h3>
<p>现在可以揭露<code>Optional</code>是如何工作的。一个<code>Optional</code>只是一个有两个<code>case</code>的枚举：<code>.none</code>和<code>.some</code>。如果它是<code>.none</code>，它没有关联值，相当于<code>nil</code>。如果它是<code>.some</code>，它就会携带包装好的值作为其关联值。</p>
<h2 id="inference-of-type-name-with-staticclass-members">Inference of Type Name with Static/Class Members</h2>
<p>如同在枚举实例被期望的地方可以使用点和枚举<code>case</code>一样，<font color=red>当引用一个类型的静态/类成员的值是该类型的一个实例时</font>，可以做同样的事情。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>p.trackTintColor = .red <span style="color:#75715e">// instead of UIColor.red</span>
</span></span></code></pre></div><p>例如，<code>UIColor</code>有许多由<code>UIColor</code>实例生成的类属性，所以可以在预期有<code>UIColor</code>的地方省略<code>UIColor</code>前缀。从<code>Swift 5.4</code>开始，可以在静态/类成员后附加一个属性或方法调用，同时产生预期的类型</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>p.trackTintColor = .red.withAlphaComponent(<span style="color:#ae81ff">0.5</span>)
</span></span></code></pre></div><p>类似地，假设有一个带有静态常量的结构体<code>Thing</code>，其值是<code>Thing</code>的实例。那么在声明<code>Thing</code>变量或者常量时可以使用点操作符来引用该静态常量：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Thing</span>: RawRepresentable {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> rawValue: Int
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 静态成员</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> one: Thing = Thing(rawValue: <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 静态成员</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> two: Thing = Thing(rawValue: <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> thing1: Thing = .one
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> thing2: Thing = .two
</span></span></code></pre></div><p>同样地，当一个类型有一个<font color=red>静态/类方法</font>产生该类型的实例时，在<font color=red>期望有一个该类型实例的地方，可以省略类型名，初始化器就是这样的方法</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> name: String
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">same</span>(text: String) -&gt; Dog {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Dog(name: text)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">dogExpecter</span>(<span style="color:#66d9ef">_</span> dog: Dog) {
</span></span><span style="display:flex;"><span>    debugPrint(dog.name)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>dogExpecter(.<span style="color:#66d9ef">init</span>(name: <span style="color:#e6db74">&#34;Fido&#34;</span>))
</span></span><span style="display:flex;"><span>dogExpecter(.same(text: <span style="color:#e6db74">&#34;Foo&#34;</span>))
</span></span></code></pre></div><h2 id="enum-case-iteration">Enum Case Iteration</h2>
<p>如果声明的枚举类型<font color=red>遵循了<code>CaseIterable</code>协议，那么它就会有一个<code>allCases</code>静态属性</font>，这个属性包含了该枚举的所有<code>case</code>值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Filter</span>: String, CaseIterable {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> albums = <span style="color:#e6db74">&#34;Albums&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> playlists = <span style="color:#e6db74">&#34;Playlists&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> podcasts = <span style="color:#e6db74">&#34;Podcasts&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> books = <span style="color:#e6db74">&#34;Audiobooks&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>debugPrint(Filter.allCases) <span style="color:#75715e">// [Command.Filter.albums, Command.Filter.playlists, Command.Filter.podcasts, Command.Filter.books]</span>
</span></span></code></pre></div><h2 id="enum-initializers">Enum Initializers</h2>
<p>一个<font color=red>自定义枚举初始化器必须做默认初始化所做的事，即必须返回枚举的一个<code>case</code></font>。要做到这一点，需要将<code>self</code>设置为该<code>case</code>。在下面的代码中，声明了枚举初始化器，以便它可以用一个数字参数进行初始化：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Filter</span>: String, CaseIterable {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> albums = <span style="color:#e6db74">&#34;Albums&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> playlists = <span style="color:#e6db74">&#34;Playlists&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> podcasts = <span style="color:#e6db74">&#34;Podcasts&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> books = <span style="color:#e6db74">&#34;Audiobooks&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>?(<span style="color:#66d9ef">_</span> ix: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span>Filter.allCases.indices.contains(ix) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span> = Filter.allCases[ix]
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>现在有三种方式可以创建一个<code>Filter</code>实例。第一种是使用<code>Filter</code>类型<code>+</code>点操作符，第二种是使用<code>rawValue</code>，第三种方式是使用上面自定义的初始化器：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> type1 = Filter.albums
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> type2 = Filter(rawValue: <span style="color:#e6db74">&#34;Playlists&#34;</span>)<span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> type3 = Filter(<span style="color:#ae81ff">2</span>) <span style="color:#75715e">// .podcasts</span>
</span></span><span style="display:flex;"><span>debugPrint(Filter.allCases) <span style="color:#75715e">// [Command.Filter.albums, Command.Filter.playlists, Command.Filter.podcasts, Command.Filter.books]</span>
</span></span><span style="display:flex;"><span>debugPrint(type1, type2, type3) <span style="color:#75715e">// Command.Filter.albums Command.Filter.playlists Optional(Command.Filter.podcasts)</span>
</span></span></code></pre></div><p>一个枚举类型可以有多个初始化器，枚举初始化器可以通过调用<code>self.init(...)</code>委托其它初始化器来完成初始化。唯一的要求是在调用链的某个时刻，<code>self</code>必须设置为某个<code>case</code>，否则会出现编译错误。下面代码新增了一个可失败的初始化器，在其中调用了另一个初始化器：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Filter</span>: String, CaseIterable {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> albums = <span style="color:#e6db74">&#34;Albums&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> playlists = <span style="color:#e6db74">&#34;Playlists&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> podcasts = <span style="color:#e6db74">&#34;Podcasts&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> books = <span style="color:#e6db74">&#34;Audiobooks&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>?(<span style="color:#66d9ef">_</span> ix: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span>Filter.allCases.indices.contains(ix) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span> = Filter.allCases[ix]
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// 代理初始化器</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>?(<span style="color:#66d9ef">_</span> rawValue: String) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.<span style="color:#66d9ef">init</span>(rawValue: rawValue)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在上面的代码中，改进了<code>Filter</code>枚举，以便它可以用一个字符串的原始值进行初始化，而不必在调用中使用<code>rawValue：</code>。因此，声明了一个带有字符串参数可失败的初始化器，该参数委托给内置的可失败的<code>rawValue:</code>初始化器。</p>
<h2 id="enum-properties">Enum Properties</h2>
<p>枚举类型既可以有实例属性也可以有静态属性，但<font color=red>实例属性只能是计算属性不能是存储属性</font>，计算实例属性可以根据<code>self</code>值变化而变化：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Filter</span>: String {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> albums = <span style="color:#e6db74">&#34;Albums&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> playlists = <span style="color:#e6db74">&#34;Playlists&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> podcasts = <span style="color:#e6db74">&#34;Podcasts&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> books = <span style="color:#e6db74">&#34;Audiobooks&#34;</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> query: MPMediaQuery {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">switch</span> <span style="color:#66d9ef">self</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> .albums:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> .albums()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> .playlists:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> .playlists()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> .podcasts:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> .podcasts()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> .books:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> .audiobooks()
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果一个枚举实例计算属性有<code>setter</code>方法，则其它代码可以赋值这个属性，但是<font color=red>更改这个计算属性的枚举实例本身必须是<code>var</code>而不是<code>let</code>声明的，否则会出现编译错误</font>（因为<code>let</code>声明的常量不可以再被赋值，<code>Cannot assign to property: 'silly' is a 'let' constant</code>）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Silly</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> one
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> sillyProperty: String {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">get</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;Howdy&#34;</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">set</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//        </span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// do nothing</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 必须使用var声明</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> silly = Silly.one
</span></span><span style="display:flex;"><span>silly.sillyProperty = <span style="color:#e6db74">&#34;silly&#34;</span>
</span></span></code></pre></div><p>枚举类型的<font color=red>静态属性可以有一个<code>property wrapper</code>，但实例属性不能</font>，因为枚举类型的实例属性必须都是计算属性，无法满足<code>property wrapper</code>底层存储属性的要求。</p>
<h2 id="enum-methods">Enum Methods</h2>
<p>枚举类型既可以有实例方法（包括下标）也可以有静态方法。下面代码中声明的枚举类型<code>Shape</code>定义了一个实例方法<code>addShape</code>，它根据<code>self</code>的值完成对应的操作：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Shape</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> rectangle
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> ellipse
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> diamond
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">addShape</span>(to p: CGMutablePath, <span style="color:#66d9ef">in</span> r: CGRect) -&gt; () {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">switch</span> <span style="color:#66d9ef">self</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> .rectangle:
</span></span><span style="display:flex;"><span>            p.addRect(r)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> .ellipse:
</span></span><span style="display:flex;"><span>            p.addEllipse(<span style="color:#66d9ef">in</span>: r)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> .diamond:
</span></span><span style="display:flex;"><span>            p.move(to: CGPoint(x: r.minX, y: r.midY))
</span></span><span style="display:flex;"><span>            p.addLine(to: CGPoint(x: r.midX, y: r.minY))
</span></span><span style="display:flex;"><span>            p.addLine(to: CGPoint(x: r.maxX, y: r.midY))
</span></span><span style="display:flex;"><span>            p.addLine(to: CGPoint(x: r.midX, y: r.maxY)) p.closeSubpath()
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在前面说过<code>subscript</code>可以是静态方法，因此可以定义一个静态的<code>subscript</code>来获取遵循<code>CaseIterable</code>协议的某个<code>case</code>，代码如下所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Filter</span>: String, CaseIterable {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> albums = <span style="color:#e6db74">&#34;Albums&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> playlists = <span style="color:#e6db74">&#34;Playlists&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> podcasts = <span style="color:#e6db74">&#34;Podcasts&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> books = <span style="color:#e6db74">&#34;Audiobooks&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">subscript</span>(ix: Int) -&gt; Filter {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">guard</span> ix <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> ix <span style="color:#f92672">&lt;</span> Filter.allCases.count <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> .albums
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Filter.allCases[ix]
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>debugPrint(Filter[<span style="color:#ae81ff">2</span>])
</span></span></code></pre></div><p>如果枚举的某个实例方法<font color=red>想要修改枚举实例本身，则声明的时候要标记为<code>mutating</code>，因为它也是一种值类型</font>。例如，一个枚举的实例方法可能会赋值给<code>self</code>的一个实例属性，<font color=red>即使这是一个计算属性，这种赋值也是非法的，除非该方法被标记为<code>mutating</code></font>，需要注意的是调用<code>mutating</code>方法的实例变量也必须声明为<code>var</code>。</p>
<p>在一个<code>mutating</code>枚举实例方法中，可以改变自身，方法是将另一个实例分配给<code>self</code>。下面的代码在<code>advance</code>方法中改变了自身：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Filter</span>: String, CaseIterable {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> albums = <span style="color:#e6db74">&#34;Albums&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> playlists = <span style="color:#e6db74">&#34;Playlists&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> podcasts = <span style="color:#e6db74">&#34;Podcasts&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> books = <span style="color:#e6db74">&#34;Audiobooks&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">subscript</span>(ix: Int) -&gt; Filter {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">guard</span> ix <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> ix <span style="color:#f92672">&lt;</span> Filter.allCases.count <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> .albums
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Filter.allCases[ix]
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">mutating</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">advance</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> cases = Filter.allCases
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">guard</span> <span style="color:#66d9ef">var</span> ix = cases.firstIndex(of: <span style="color:#66d9ef">self</span>) <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        		<span style="color:#66d9ef">return</span> 
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        ix = (ix <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> cases.count
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span> = cases[ix]
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> type = Filter.books 
</span></span><span style="display:flex;"><span>type.advance() <span style="color:#75715e">// type is now Filter.albums</span>
</span></span></code></pre></div><p>在上面代码中，<code>type</code>声明时使用<code>var</code>，如果使用<code>let</code>声明会出现编译错误。<font color=red>下标或计算属性的<code>setter</code>默认是<code>mutating</code>的，不需要特殊标记</font>。如果一个计算属性的<code>getter</code>中设置另一个属性，那么必须标记为<code>mutating</code>。</p>
<h1 id="structs">structs</h1>
<p>结构体是<code>Swift</code>对象类型中的佼佼者，而枚举由固定的<code>case</code>集合组成，是一种简化的、特化的对象。在另一个极端，类往往会被证明是过度的，它包含了一些结构体所缺乏的功能，但如果是不需要这些功能的场景，结构体可能是更好的选择。</p>
<p>在<code>Swift</code>头文件中声明的<code>200</code>多种对象类型中，可能有半打是类，有几十个是枚举，其余的都是结构体。<code>String</code>是一个结构体，<code>Int</code>是结构体，<code>Range</code>是结构体，<code>Array</code>也是结构体。</p>
<h2 id="struct-initializers">Struct Initializers</h2>
<p>如果结构体<font color=LightSeaGreen>没有存储属性或者全部的存储属性在声明的时候已经有默认值，则会自动生成一个无参的初始化器<code>init()</code></font>。下面代码中，编译器会为<code>Digit</code>结构体自动生成一个无参初始化器<code>init()</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Digit</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> number = <span style="color:#ae81ff">42</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><font color=red>一旦在代码中增加了新的自定义初始化器，编译器将不会自动生成无参的初始化器</font>。下面代码中，已经在<code>Digit</code>增加一个有参的初始化器，则编译器不会生成无参的初始化器：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Digit</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> number = <span style="color:#ae81ff">42</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(number: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.number = number
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>此时，如果想要使用<code>Digit()</code>生成新的实例，将会出现编译报错。需要手动再声明一个无参的初始化器，才能通过编译：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Digit</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> number = <span style="color:#ae81ff">42</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>() {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(number: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.number = number
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>有<font color=LightSeaGreen>存储属性且没有显式初始化器的结构体会自动获得一个从其实例属性派生的隐式初始化器</font>，这称为<code>memberwise initializer</code>(成员初始化器)：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Test</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> number = <span style="color:#ae81ff">42</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name: String
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> age: Int
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> greeting = <span style="color:#e6db74">&#34;Hello&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面代码是合法，虽然看起来没有履行在声明或者初始化器中初始化所有储存属性的契约。实际上，因为没有自定义初始化器，编译器会根据实例属性自动生成一个隐式初始化器，这个初始化器被称为<code>memberwise initializer</code>(成员初始化器)，这个<code>memberwise initializer</code><font color=Blue>初始化了所有未初始化的属性</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Test</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> number = <span style="color:#ae81ff">42</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name: String
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> age: Int
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> greeting = <span style="color:#e6db74">&#34;Hello&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> t1 = Test(number: <span style="color:#ae81ff">42</span>, name: <span style="color:#e6db74">&#34;matt&#34;</span>, age: <span style="color:#ae81ff">65</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> t2 = Test(name: <span style="color:#e6db74">&#34;matt&#34;</span>, age: <span style="color:#ae81ff">65</span>)
</span></span></code></pre></div><p>上面自动生成的<code>memberwise initializer</code>包含了<code>number,name,age</code>，不包括<code>greeting</code>。这是因为<code>greeting</code>是<font color=red>使用<code>let</code>声明的，在声明的时候已经初始化了</font>。</p>
<p>因为<code>number</code>使用<code>var</code>声明，并且在声明的同时已经被初始化了，从<code>Swift 5.1</code>后调用<code>memberwise initializer</code>时<font color=Blue>可以省略这种用<code>var</code>声明并且已经初始化了的属性</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> t2 = Test(name: <span style="color:#e6db74">&#34;matt&#34;</span>, age: <span style="color:#ae81ff">65</span>)
</span></span></code></pre></div><p>如果在结构体声明的时候，<font color=red>声明了自定义的初始化器或者属性声明为<code>private</code>(使用<code>let</code>声明并且已经初始化的属性除外)</font>，则编译器不会自动生成<code>memberwise initializer</code>。下面代码中，因为声明了<code>private</code>实例属性，所以没有自动生成成员初始化器：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">MoTest</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">var</span> age = <span style="color:#ae81ff">18</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name: String
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>debugPrint(MoTest(name: <span style="color:#e6db74">&#34;test&#34;</span>).name)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// &#39;MoTest&#39; initializer is inaccessible due to &#39;private&#39; protection level</span>
</span></span></code></pre></div><p>下面虽然有<code>private</code>的属性，但因为是<code>let</code>声明的，所以还是会自动生成成员初始化器：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">MoTest</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">let</span> age = <span style="color:#ae81ff">18</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name: String
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>debugPrint(MoTest(name: <span style="color:#e6db74">&#34;test&#34;</span>).name)
</span></span></code></pre></div><p>结构体中声明的<font color=LightSeaGreen>存储属性必须全部初始化</font>，不管是声明的时候初始化还是在所有的初始化器中初始化。如果一个结构体有多个初始化器，则可以在初始化器中通过<code>self.init()</code>调用其它初始化器。</p>
<h2 id="struct-properties">Struct Properties</h2>
<p>结构体可以有实例属性或者静态属性，二者均可以声明为存储或者计算属性。如果代码中想重新设置一个结构体实例属性的值，则该实例变量必须使用<code>var</code>声明，否则会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> d = Test(name: <span style="color:#e6db74">&#34;ddd&#34;</span>,age: <span style="color:#ae81ff">34</span>)
</span></span><span style="display:flex;"><span>d.name = <span style="color:#e6db74">&#34;new test&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Digit1</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> number: Int
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(<span style="color:#66d9ef">_</span> n: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.number = n
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> digit1 = Digit1(<span style="color:#ae81ff">123</span>)
</span></span><span style="display:flex;"><span>digit1.number = <span style="color:#ae81ff">345</span>
</span></span><span style="display:flex;"><span>debugPrint(digit1.number)
</span></span></code></pre></div><h2 id="struct-methods">Struct Methods</h2>
<p>结构体可以有实例方法和静态方法，包括<code>subscript</code>(下标)，<font color=red>如果一个实例方法想要设置结构体中某个属性的值，那么这个方法一定要声明为<code>mutating</code>，并且调用这个方法的实例也必须使用<code>var</code>声明</font>，否则会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Digit</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">var</span> number: Int
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(<span style="color:#66d9ef">_</span> n: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.number = n
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">mutating</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">changeNumberTo</span>(<span style="color:#66d9ef">_</span> n: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.number = n
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> d = Digit(<span style="color:#ae81ff">123</span>)
</span></span><span style="display:flex;"><span>d.changeNumberTo(<span style="color:#ae81ff">42</span>)
</span></span></code></pre></div><p>获取一个懒加载实例属性的值可能会导致该属性的初始化器运行，设置该属性的值，也就是这是一个可变的属性。因此，如果一个实例方法获取了一个懒加载的实例属性的值，那么它必须被声明为<code>mutating</code>的:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Person</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">lazy</span> <span style="color:#66d9ef">var</span> name = <span style="color:#e6db74">&#34;matt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">mutating</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">getName</span>() -&gt; String {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">self</span>.name
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>结构体<font color=red><code>subscript</code>或者计算属性的<code>setter</code>方法默认认为是<code>mutating</code>，</font>不必显式地声明为<code>mutating</code>。但是<font color=LightSeaGreen>如果在它们的<code>get</code>方法中要设置其它属性的值，必须显式地声明为<code>mutating</code></font>。声明为<code>mutating</code>的方法中可以使用该类型的另一个实例设置<code>self</code>的方式来改变自身。</p>
<h2 id="constant-namespaces">Constant Namespaces</h2>
<p>经常使用<code>degenerate struct</code>作为常量的便捷命名空间，之所以称为<code>degenerate</code>，是因为结构体中<font color=red>全部为静态成员，并且不打算使用这种对象类型来制造任何其它实例</font>。</p>
<p><code>UserDefaults</code>是一种字典，每个值可以通过一个键来访问。这些键通常是字符串，一个常见的错误是使用键时拼错了键的名字，虽然在编译时不会报错，但代码将不能正常工作。</p>
<p>更好的方法是将这些键用带名字的常量字符串来表示。此时，如果错误地输入了一个名称，编译器会报错。<font color=red>带有静态成员的结构是定义常量字符串并将其名称集中到一个命名空间的好方法</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Default</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> rows = <span style="color:#e6db74">&#34;rows&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> columns = <span style="color:#e6db74">&#34;columns&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> hazyStripy = <span style="color:#e6db74">&#34;hazyStripy&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>现在就可以使用<code>Default</code>中的静态成员作为<code>UserDefaults</code>的键来引用，例如使用<code>Default.rows</code>可以就代表<code>rows</code>字符串。</p>
<h1 id="classes">Classes</h1>
<p>虽然类和结构体相似，但和结构体还有一些关键区别：</p>
<ol>
<li>
<p>类是引用类型。这一意味着类的实例有两个相比于结构体或枚举实例来说是截然不同的显著特征。</p>
<ul>
<li>
<p>可变的：类的实例是<font color=red>原地是可变的</font>。即使一个类实例变量是用<code>let</code>声明的，也可以通过这个引用来改变一个实例属性的值。因此，类的实例方法<font color=LightSeaGreen>从来不需要被标记为可变的（也不能使用<code>mutating</code>标记）</font>。</p>
</li>
<li>
<p>多引用：当一个类的实例被赋值给多个变量或作为参数传递给一个函数时，可能出现多个引用指向<font color=red>一个相同的对象</font>。</p>
</li>
</ul>
</li>
<li>
<p>继承：一个类可以有一个父类并继承父类的成员。类类型可以形成一个层次结构树，而<font color=red>结构体不能继承</font>。</p>
</li>
</ol>
<p>在<code>Objective-C</code>中，类是唯一的对象类型。一些内置的<code>Swift</code>结构体类型可以神奇地与<code>Objective-C</code>的类桥接，但<font color=red>自定义结构类型却没有这种魔力</font>。因此，在用<code>Swift</code>进行<code>iOS</code>编程时，声明类而不是结构的一个原因是类能够和<code>Objective-C</code>或<code>Cocoa</code>转换。</p>
<h2 id="value-types-and-reference-types">Value Types and Reference Types</h2>
<p>在<code>Swift</code>中，<font color=red>结构体和枚举类型都是值类型，类是引用类型</font>。<strong><font color=LightSeaGreen>值类型不能就地可变，而类的实例是能够就地可变</font></strong>。在下面的例子中，因为结构体是值类型，所以更改结构体实例的属性时，要将结构体实例用<code>var</code>声明，而不能用<code>let</code>声明：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Digit</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> number: Int
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(<span style="color:#66d9ef">_</span> n: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.number = n
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;number:</span><span style="color:#e6db74">\(</span>number<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> d = Digit(<span style="color:#ae81ff">23</span>)
</span></span><span style="display:flex;"><span>d.number = <span style="color:#ae81ff">45</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 打印结果</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;number:23&#34;</span>
</span></span></code></pre></div><p>实际上，<font color=red>当改变一个值类型的实例时，实际上是用一个不同的实例替换该实例</font>。为了证明这一点，可以为<code>digit</code>实例添加一个<code>setter</code>观察器。下面代码中，<font color=red>虽然改变的只是属性<code>number</code>的值，但是<code>didSet</code>依然调用了，这说明该实例已经被替换了</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Digit</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> number: Int
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(<span style="color:#66d9ef">_</span> n: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.number = n
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> d: Digit = Digit(<span style="color:#ae81ff">234</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">didSet</span> {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;d was set&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>d.number = <span style="color:#ae81ff">456</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// &#34;d was set&#34;</span>
</span></span></code></pre></div><p>下面代码中，实际上需要用另一个<code>Digit</code>实例改变<code>digit</code>指向的<code>Digit</code>实例，但因为<code>digit</code>是使用<code>let</code>声明的，下面代码会出现编译错误，也能够解释<font color=LightSeaGreen>如果值类型的实例引用是用<code>let</code>关键字声明的，那么就不能对该实例进行就地改变</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> digit = Digit(<span style="color:#ae81ff">123</span>) <span style="color:#75715e">// Digit is a struct</span>
</span></span><span style="display:flex;"><span>digit.number = <span style="color:#ae81ff">42</span> <span style="color:#75715e">// compile error: Cannot assign to property: &#39;dd&#39; is a &#39;let&#39; constant</span>
</span></span></code></pre></div><p>这也解释了结构体或枚举的的实例方法如果需要设置属性值，必须将方法显式地用<code>mutating</code>标记。这种标记的意思：这样的方法有可能用另一个对象替换当前对象，所以<font color=red>对这个对象的引用必须是<code>var</code>，而不是<code>let</code></font>。</p>
<p>但类不是值类型，它们是引用类型。如果想通过引用改变一个属性的值，在声明该引用变量时无需使用<code>var</code>，即使是使用<code>let</code>声明的变量，也可以通过该引用更改其<code>var</code>属性的值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name: String = <span style="color:#e6db74">&#34;Fido&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> rover = Dog()
</span></span><span style="display:flex;"><span>rover.name = <span style="color:#e6db74">&#34;Rover&#34;</span> <span style="color:#75715e">// fine</span>
</span></span></code></pre></div><p>上面代码的最后一行，<code>rover</code>所指向的类实例被就地改变了。这里并没有涉及到对<code>rover</code>的隐式赋值，所以使用<code>let</code>声明是合法的。实际上，当属性被设置时，<code>Dog</code>变量上的<code>setter observer</code> 没有被调用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name: String = <span style="color:#e6db74">&#34;Fido&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> rover: Dog = Dog() { <span style="color:#75715e">// Dog is a class</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">didSet</span> {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;rover did set rover&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>rover.name = <span style="color:#e6db74">&#34;Rover&#34;</span> <span style="color:#75715e">// nothing in console</span>
</span></span></code></pre></div><p>上面的<code>didSet</code>观察器代码没有执行，说明没有生成新的实例。如果显式地重新赋值<code>rover</code>，就会调用上面的<code>setter</code>观察器。但是，类实例的<font color=red><code>didSet</code>不会在仅改变了被<code>rover</code>指向<code>Dog</code>实例的一个属性而调用</font>。</p>
<p>值类型和引用类型之间的区别也可以在函数调用的参数中看到。当接收一个值类型的实例作为参数进入到函数体时，并在函数体内试图给这个实例属性赋值，将会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">digitChanger</span>(<span style="color:#66d9ef">_</span> d: Digit) { <span style="color:#75715e">// Digit is a struct</span>
</span></span><span style="display:flex;"><span>    d.number = <span style="color:#ae81ff">42</span> <span style="color:#75715e">// compile error</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>因为函数参数默认是用<code>let</code>隐式声明的，又因为<code>Digit</code>是结构体，所以会出现编译错误：<code>Cannot assign to property: 'd' is a 'let' constant</code>。下面函数中，因为<code>Dog</code>是引用类型，所以<code>dog</code>能就地改变，下面代码不会出现编译报错：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">dogChanger</span>(<span style="color:#66d9ef">_</span> d: Dog) { <span style="color:#75715e">// Dog is a class</span>
</span></span><span style="display:flex;"><span>    d.name = <span style="color:#e6db74">&#34;Rover&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="mutating-captured-self">Mutating Captured Self</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Digit</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> number: Int
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(<span style="color:#66d9ef">_</span> n: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.number = n
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">mutating</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">changeNumberTo</span>(<span style="color:#66d9ef">_</span> n: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.number = n
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">otherFunction</span>(<span style="color:#66d9ef">_</span> f: () -&gt; ()) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">mutating</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">callAnotherFunction</span>() {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        otherFunction {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">self</span>.changeNumberTo(<span style="color:#ae81ff">345</span>) 
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面的代码是否合法取决于<code>otherFunction</code>是否将它的函数参数声明为<code>@escaping</code>（逃逸闭包）。如果声明了参数<code>f</code>为<code>escaping</code>逃逸的，则编译器会报<code>Escaping closure captures mutating 'self' parameter</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">otherFunction</span>(<span style="color:#66d9ef">_</span> f: @escaping ()-&gt;()) { 
</span></span><span style="display:flex;"><span>   	<span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>现在<code>otherFunction</code>是逃逸的，这意味着存在潜在的威胁：可能会在以后的某个时间点改变捕获的<code>self</code>。<code>Digit</code>是一个结构体，所以这将涉及到用一个不同的<code>Digit</code>实例来替换捕获的<code>self</code>，这是不被允许的（即使<code>otherFunction</code>是用<code>mutating</code>标记）。如果<code>Digit</code>是一个类，就不会出现这样的问题，因为捕获的<code>self</code>可以被<code>mutated in place</code>。</p>
<h3 id="class-instance-references-are-pointers">Class instance references are pointers</h3>
<p>在引用类型中，在对<font color=LightSeaGreen>实例的引用和实例本身之间有一个隐蔽的层次</font>。引用实际上持有一个指向实例的指针，这意味着当一个类的实例赋值给一个变量或作为一个函数的参数或作为一个函数的结果时，可能会出现对同一个对象的多个引用。</p>
<p>而结构体和枚举不是这样的，在<font color=red>枚举或者结构体实例被赋值或被传递时，本质上被赋值或者被传递的是该实例的副本</font>。而类实例被赋值或传递时是指向同一个实例的引用，下面代码能说明这种区别：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> d1 = Digit(<span style="color:#ae81ff">123</span>) <span style="color:#75715e">// Digit is a struct</span>
</span></span><span style="display:flex;"><span>debugPrint(d1.number) <span style="color:#75715e">// 123</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> d2 = d1 <span style="color:#75715e">// assignment!</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>d2.number = <span style="color:#ae81ff">42</span>
</span></span><span style="display:flex;"><span>debugPrint(d1.number) <span style="color:#75715e">// 123</span>
</span></span></code></pre></div><p>上面的代码中，改变了<code>d2</code>的属性<code>number</code>，因为d2是结构体实例，所以不会影响到<code>d</code>的<code>number</code>属性。但在下面代码中，改变了类实例<code>rov</code>的<code>name</code>属性，因为<code>Dog</code>是引用类型，这种改变也会影响到<code>fido</code>，因为它们指向同一个对象：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> fido = Dog() <span style="color:#75715e">// Dog is a class</span>
</span></span><span style="display:flex;"><span>debugPrint(fido.name) <span style="color:#75715e">// Fido</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> rov = fido <span style="color:#75715e">// assignment!</span>
</span></span><span style="display:flex;"><span>rov.name = <span style="color:#e6db74">&#34;Rover&#34;</span>
</span></span><span style="display:flex;"><span>debugPrint(fido.name) <span style="color:#75715e">// Rover</span>
</span></span></code></pre></div><p>同样地，当在函数中传递类实例时，传递的是指向同一个实例的引用。在下面代码中，当在函数<code>doChanger</code>中修改<code>d</code>的属性<code>name</code>后，会影响其指向的实例:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">dogChanger</span>(<span style="color:#66d9ef">_</span> d: Dog) { <span style="color:#75715e">// Dog is a class</span>
</span></span><span style="display:flex;"><span>    d.name = <span style="color:#e6db74">&#34;Rover&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> fido = Dog(name: <span style="color:#e6db74">&#34;name&#34;</span>, license: <span style="color:#ae81ff">123</span>)
</span></span><span style="display:flex;"><span>debugPrint(fido.name) <span style="color:#75715e">// &#34;Fido&#34;</span>
</span></span><span style="display:flex;"><span>dogChanger(fido)
</span></span><span style="display:flex;"><span>debugPrint(fido.name) <span style="color:#75715e">// &#34;Rover&#34;</span>
</span></span></code></pre></div><p>当在函数中传递枚举和结构体实例时，实际上传递是它们的副本，所以不会影响传入的实例。此时，如果想在函数中修改传入的参数，需要使用用<code>inout</code>标记待传入的值形参。</p>
<h3 id="advantages-of-value-types-vs-reference-types">Advantages of value types vs. reference types</h3>
<p>在基于对象的编程世界中，<font color=red>产生指向同一实例的多个引用的能力是非常重要的</font>。因为对象会持续存在，并且可以有与之一起持续存在的属性。</p>
<p>如果对象<code>A</code>和对象<code>B</code>都是长存的，并且它们都有一个类类型的<code>Dog</code>属性。如果它们都指向同一个<code>Dog</code>实例，那么对象<code>A</code>或对象<code>B</code>都可以改变它们指向的<code>Dog</code>实例，而这种改变将会同时影响<code>A</code>和<code>B</code>。因此，对于类来说，可能正指向一个对象，却发现它已经被别人改变了。如果这种情况意外地发生，可能会使我们的程序进入非正常状态。</p>
<p>类实例在幕后也更加复杂，<code>Swift</code>必须管理类实例的内存，正是因为对同一个对象可能有多个引用，这种管理可能涉及相当多的开销。</p>
<p>因此，应当尽可能地选择一个值类型（如结构体）而不是引用类型（类）。结构体实例不在引用之间共享，因此不必担心实例在其它地方被改变。结构体的存储和内存管理也要简单得多，并且值类型也更容易被推断。</p>
<p><code>Swift</code>语言本身会帮助使用结构体类型，在许多<code>Cocoa Foundation</code>的引用类型面前强加值类型。例如，<code>Objective-C</code>中的<code>NSDate</code>和<code>NSData</code>是类类型，但<code>Swift</code>会引导使用结构类型<code>Date</code>和<code>Data</code>来代替。</p>
<p>但不要搞错了，就想当然地认为类是不好的。首先，类实例的传递非常有效，因为<font color=red>所传递的只是一个指针</font>。无论一个类的实例有多大、多复杂，无论它的属性包含多大量的数据，传递实例都是非常快速和高效的。</p>
<p>尽管一个类可能是一个引用类型，但一个特定的类可以<font color=red>以特殊方式实现，以表现出它的值语义</font>。一个类的<code>API</code>可以拒绝对该类进行原地改变。<code>Cocoa</code>的<code>NSString、NSArray、NSDictionary、NSDate、NSIndexSet、NSParagraphStyle</code>等等都是这样的。</p>
<p>两个对象可以持有对同一个<code>NSArray</code>的引用而不用担心它在其它地方被改变，<font color=red>这不是因为它是一个值类型，而是因为它在设计上是不可变的</font>。实际上，这种架构结合了值类型的易用性和引用类型的指针高效性。</p>
<p>此外，只有一个类的实例能成功的代表<code>independent reality</code>。例如，<code>UIView</code>是一个类，因一个单独的<code>UIView</code>实例就能在运行的应用程序的界面中一直代表同一个真实的、持久的视图。</p>
<p>另外，喜欢类而不是结构体或枚举的另一个原因是当需要递归引用时，一个值类型不能在结构上递归：即一个值类型的存储实例属性不能是同一类型的实例。下面这段代码是无法编译的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Dog</span> {  
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> puppy : Dog?  <span style="color:#75715e">// compile error: Value type &#39;Dog&#39; cannot have a stored property that recursively contains it</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>奇怪的是，<font color=red>可以将<code>puppy</code>定义为<code>Dog</code>数组来解除这个限制</font>。对于值类型来说，更复杂的循环链，比如循环引用是非法的。例如，<code>Dog</code>机构体有一个<code>Puppy</code>结构体类型的实例属性，<code>Puppy</code>有一个<code>Dog</code>类型属性也是非法的，但如果<code>Dog</code>是类类型，这就是合法的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Dog</span> { 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> puppy: [Dog]?
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>关联值类型的枚举<code>case</code>可以是当前枚举的实例，一个枚举<code>case</code>的关联值可以是该枚举的一个实例，只要该案例（或整个枚举）被标记为<code>indirect</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Node</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#66d9ef">none</span>(Int)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">indirect</span> <span style="color:#66d9ef">case</span> <span style="color:#66d9ef">left</span>(Int, Node)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">indirect</span> <span style="color:#66d9ef">case</span> <span style="color:#66d9ef">right</span>(Int, Node)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">indirect</span> <span style="color:#66d9ef">case</span> both(Int, Node, Node)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="subclass-and-superclass">subclass and superclass</h2>
<p>在<code>Swift</code>中，一个类可能有多个子类，但<font color=red>一个类至多只能有一个直接父类</font>。就<code>Swift</code>本身而言，并没有要求一个类一定要有父类，或者说一个类如果有父类，也<font color=red>没有要求它最终应该是由特定父类派生</font>。</p>
<p>一个<code>Swift</code>程序可以有许多没有父类的类，也可以有许多独立的层次子类树，每一个都是从不同的基类派生而来。但在<code>Cocoa</code>中，不是这样的。在<code>Cocoa</code>中实际上只有一个<code>base class</code>即<code>NSObject</code>，它表明了一个类所必需的所有功能，而所有其它类在某种层次上是这个基类的子类。</p>
<h3 id="inheritance">Inheritance</h3>
<p>之所以有父类和子类关系，首先是为了共享功能。下面的定义中，因为<code>Dog</code>和<code>Cat</code>都是<code>Quadruped</code>的子类，所以它们都能调用父类的<code>walk</code>方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Quadruped</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">walk</span>() {
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;walk walk walk&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span>: Quadruped {
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Cat</span>: Quadruped {
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> fido = Dog1()
</span></span><span style="display:flex;"><span>fido.walk()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 打印结果</span>
</span></span><span style="display:flex;"><span>walk walk walk
</span></span></code></pre></div><p>在类的声明时加上<code>final</code>关键字可以防止其它类来继承当前类。</p>
<h3 id="additional-functionality">Additional functionality</h3>
<p>子类化不仅可以继承父类的方法，也可以自定义方法。下面定义的<code>Dog</code>类不仅继承了<code>walk()</code>方法，而且自定义了<code>bark()</code>方法:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Quadruped</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">walk</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;walk walk walk&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span>: Quadruped {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;woof&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> fido  = Dog()
</span></span><span style="display:flex;"><span>fido.walk()
</span></span><span style="display:flex;"><span>fido.bark()
</span></span></code></pre></div><p>无论方法是在类中自定义的，还是从父类中继承的，都有同样的效果。下面代码中<code>Dog</code>继承了<code>Quadruped</code>的<code>walk</code>方法，并自定义了<code>bark</code>方法，在自定义的<code>walkAndBark</code>方法中调用<code>walk</code>和<code>bark</code>方法的时候没有差别：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Quadruped</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">walk</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;walk walk walk&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span>: Quadruped {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;woof&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">walkAndBark</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.walk()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.bark()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> fido = Dog()
</span></span><span style="display:flex;"><span>fido.walk()
</span></span><span style="display:flex;"><span>fido.bark()
</span></span><span style="display:flex;"><span>fido.walkAndBark()
</span></span></code></pre></div><h3 id="overriding">Overriding</h3>
<p>在<code>Swift</code>中允许对从父类继承的方法进行重定义（也被称为覆写，重写）。如果重定义在父类定义的方法，必须显式在重定义的方法前添加<code>override</code>关键字作为标记。下面代码在子类<code>Dog</code>中对继承了<code>Quadruped</code>的<code>walk</code>方法进行了重写：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Quadruped</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">walk</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;walk walk walk&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span>: Quadruped {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;woof&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">walkAndBark</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.walk()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.bark()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">walk</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;dog walk&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NoisyDog</span>: Dog {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;woof woof woof&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>一个与父类同名的子类方法不一定是<code>override</code>，在<code>Swift</code>中两个同名的函数是通过签名来区别的。只有当子类重新定义它从父类继承的同一个方法时才存在<code>override</code>的情况：<font color=red>相同的名称，包括外部参数名称，以及相同的签名</font>。</p>
<p>但是，<code>override</code>一个方法<font color=Blue>并不需要和被覆盖的父类方法有完全相同的签名</font>。在覆盖一个方法时，<font color=red>参数的类型可以用父类或父类的<code>optional</code>类型来代替</font>。下面代码中，<code>Kitten</code>是<code>Cat</code>的子类，因此代码是合法的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Cat</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Kitten</span>: Cat {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">barkAt</span>(cat: Kitten) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NoisyDog</span>: Dog {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">barkAt</span>(cat: Cat) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在<code>override</code>时用一个父类的<code>Optional</code>参数也是合法的。即在<code>NoisyDog</code>中覆盖<code>barkAt</code>时，参数<code>cat</code>的类型可以是<code>Cat</code>或<code>Cat?</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NoisyDog</span>: Dog {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">barkAt</span>(cat: Cat?) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>此外，在<code>override</code>时，参数可以用对应类型的<code>Optional</code>。下面代码中，<code>Dog</code>中定义的方法<code>barkAt</code>参数类型为<code>Cat</code>，而在<code>NoisyDog</code>中<code>override</code>该方法时，参数类型为<code>Cat?</code>也是合法的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">barkAt</span>(cat: Cat) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NoisyDog</span>: Dog {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">barkAt</span>(cat: Cat?) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>而一个<code>Optional</code>的参数可以用其父类的<code>Optional</code>来覆盖。下面的代码中，在<code>override</code>方法<code>barkAt</code>时<code>Kitten?</code>类型可以使用<code>Cat?</code>来代替：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">barkAt</span>(cat: Kitten?) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NoisyDog</span>: Dog {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">barkAt</span>(cat: Cat?) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>还有一些类似的规则，但不一一列出了。因为我们可能不需要利用它们，而且在任何情况下，编译器都会告诉我们覆盖是否非法。</p>
<p>除了方法之外，子类还继承了父类的属性。当然，子类也可以声明它定义的属性。覆盖一个继承的属性是可能的（有一些限制，将在后面讲到）。</p>
<h3 id="the-keyword-super">The keyword super</h3>
<p>经常发生的情况是，如果想在一个子类中覆盖一些父类的东西，但又想访问父类中被覆盖的东西，这可以通过向关键字<code>super</code>发送消息来实现。</p>
<p>在<code>NoisyDog</code>中的<code>bark</code>方法实现就是一个例子。<code>NoisyDog</code>在<code>bark</code>中真正做的事情与<code>Dog</code>在<code>bark</code>时做的事情相同，但调用次数更多。若想在<code>NoisyDog</code>中覆盖<code>bark</code>方法中实现这种效果，可以在实现时向父类发送<code>bark</code>消息，而不是向自己发送<code>bark</code>消息（这将形成死循环）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span>: Quadruped {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;woof&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NoisyDog</span>: Dog {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">_</span> <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1.</span>..<span style="color:#ae81ff">3</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">super</span>.bark()
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> fido = Dog() 
</span></span><span style="display:flex;"><span>fido.bark() <span style="color:#75715e">// woof </span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> rover = NoisyDog() 
</span></span><span style="display:flex;"><span>rover.bark() <span style="color:#75715e">// woof woof woof</span>
</span></span></code></pre></div><p>下标函数也是一个方法。如果父类声明了一个下标函数，子类可以声明一个具有相同签名的下标，只要它用<code>override</code>关键字来标明即可。为了调用父类的下标方法，子类可以在关键字<code>super</code>后面使用方括号（例如：<code>super[3]</code>）。</p>
<h2 id="class-initializers">class initializers</h2>
<p>由于类的继承性，类实例的初始化比结构体和枚举实例的初始化要复杂得多。<font color=red>初始化器的主要任务是确保所有的属性都有一个初始值</font>。初始化器可能还有其他任务要执行，这些任务对这个实例的初始状态和完整性至关重要。</p>
<p>一个类可能有一个父类，它可能有自己的属性和初始化器。因此，<font color=red>必须以某种方式确保当一个子类被初始化时，其父类的属性均被初始化</font>，除了子类本身的任务外，其初始化器的任务也被按部就班地执行。</p>
<p><code>Swift</code>通过对类的初始化器必须做的事情制定了一些清晰明确的规则，连贯而可靠地解决了这个问题，而且很巧妙地解决了这个问题。</p>
<h3 id="kinds-of-class-initializer">Kinds of class initializer</h3>
<p>类的初始化分为两类：<code>Designated initializer</code>和<code>Convenience initializer</code>。类的初始化器默认为<code>Designated initializer</code>。每个<code>Designated initializer</code>初始化器<font color=Blue>必须保证所有的存储属性都被初始化</font>。它不能委托给类中的另一个初始化器，也就是在<font color=red>一个指定初始化器中使用<code>self.init(...)</code>是非法的</font>。</p>
<h4 id="designated-initializer">Designated initializer</h4>
<p>对于一个类，若存在任何一个存储属性，它没有作为其声明的一部分被初始化，则必须至少有一个明确的指定初始化器。一个没有存储属性的类，或者所有存储属性都作为声明的一部分被初始化的类，如果没有显式指定的初始化器，就有一个隐式的指定初始化器<code>init()</code>。</p>
<h4 id="convenience-initializer">Convenience initializer</h4>
<p>如果类的初始化器在声明的时候使用关键字<code>convenience</code>标记，那么它就是<code>Convenience initializer</code>。一个便利初始化器是一个委托初始化器，它<font color=red>必须包含<code>self.init(...)</code>，也就是它必须调用同一个类中的指定初始化器</font>。或者如果<font color=Blue>它调用同一个类中的另一个便利初始化器，便利初始化器链必须以调用同一个类中的指定初始化器结束</font>。</p>
<p>下面定义的类<code>class</code><font color=LightSeaGreen>没有存储属性，并且未自定义初始化器</font>，此时此编译器自动生成了一个无参的<code>init()</code>，因此使用<code>Dog()</code>生成新的实例不会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> dog = Dog()
</span></span></code></pre></div><p>如果类的<font color=red>所有存储属性在声明的时候都有初始值</font>，并且如果未自定义任何初始化器，编译器会生成一个无参指定初始化器<code>init()</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name = <span style="color:#e6db74">&#34;Fido&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> dog = Dog()
</span></span></code></pre></div><p>在下面的例子中，虽然所有的存储属性都已经在声明的时候初始化了，但是已经有一个自定义的<code>Designated initializer</code>，那么就不会生成无参的初始化器<code>init()</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name = <span style="color:#e6db74">&#34;Fido&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(name: String) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> dog = Dog() <span style="color:#75715e">//compile error</span>
</span></span></code></pre></div><p>在下面的例子中，所有的存储属性都有默认值，并且自定义了一个<code>Convenience initializer</code>，但无任何<code>Designated initializer</code>。此时，仍然会自动生成一个无参的<code>init()</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name = <span style="color:#e6db74">&#34;Fido&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">convenience</span> <span style="color:#66d9ef">init</span>(name: String) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.<span style="color:#66d9ef">init</span>() <span style="color:#75715e">//默认的无参初始化器</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> dog1 = Dog(name: <span style="color:#e6db74">&#34;Rover&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> dog2 = Dog()
</span></span></code></pre></div><p>也就是说，<font color=red>当一个类中无<code>Designated initializer</code>，但存在有参的<code>Convenience initializer</code>时，编译器会自动生成一个无参的<code>init()</code></font>。同时还要注意的是，不能再声明一个无参的便利初始化器<code>convenience init()</code>，否则将会出现编译错误:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name = <span style="color:#e6db74">&#34;Fido&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Invalid redeclaration of synthesized &#39;init()&#39;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">convenience</span> <span style="color:#66d9ef">init</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// </span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><font color=red>如果类的存储属性在声明的时候并未全部初始化，并且如果有自定义的<code>Designated initializer</code></font>。那么,在所有自定义的初始器中必须将所有存储属性都初始化：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name: String
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> license: Int
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(name: String, license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.license = license
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> dog = Dog(name: <span style="color:#e6db74">&#34;Rover&#34;</span>, license: <span style="color:#ae81ff">42</span>)
</span></span></code></pre></div><p>类的<code>Designated initializer</code>和<code>Convenience initializer</code>有较大的区别：</p>
<ul>
<li>
<p>一个指定的初始化器中除非为了初始化一个属性（或获取一个已经被初始化的属性的值），否则在这个类的所有属性都被初始化之前不能隐式或显式地使用<code>self</code>。</p>
</li>
<li>
<p>一个便利初始化器是一个委托初始化器，所以在<font color=red>它直接或间接地调用一个指定初始化器之前</font>，在其中不能出于任何目的使用<code>self</code>（也不能设置一个常量属性）。</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name: String
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> license: Int
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(name: String, license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.license = license
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">convenience</span> <span style="color:#66d9ef">init</span>(license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.<span style="color:#66d9ef">init</span>(name: <span style="color:#e6db74">&#34;Fido&#34;</span>, license: license)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">convenience</span> <span style="color:#66d9ef">init</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.<span style="color:#66d9ef">init</span>(license: <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> dog = Dog()
</span></span></code></pre></div><p>上面明确了<code>Designated initializer</code>和<code>Convenience initializer</code>的区别，在子类的初始化时，也有一些需要注意的地方：</p>
<ul>
<li>
<p>如果一个子类不需要自定义的初始化器，那么<font color=red>它的初始化器都继承自它的父类</font>。此时子类是否有隐藏的无参初始化器<code>init()</code>，取决于它的父类是否有<code>init()</code>。</p>
</li>
<li>
<p>如果一个子类尚无自定义的初始化器，则它可以声明<code>Convenience initializer</code>。子类的便利初始化器的工作方式与父类便利初始化器的工作方式完全一样。因为子类继承了父类的指定初始化器，便利初始化器<font color=red>必须通过使用<code>self.init(...)</code>来调用初始化器</font>。</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name: String
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> license: Int
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(name: String, license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.license = license
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">convenience</span> <span style="color:#66d9ef">init</span>(license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.<span style="color:#66d9ef">init</span>(name: <span style="color:#e6db74">&#34;Fido&#34;</span>, license: license)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">convenience</span> <span style="color:#66d9ef">init</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.<span style="color:#66d9ef">init</span>(license: <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyDog</span>: Dog {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">convenience</span> <span style="color:#66d9ef">init</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.<span style="color:#66d9ef">init</span>(license: <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// super.init(name: &#34;test&#34;, license: 1) // compile error</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>如果一个子类声明了任何自己的<code>Designated initializer</code>，那么<font color=red>将不会继承任何来自父类的初始化器</font>。并且在子类自定义的每个<code>Designated initializer</code>都必须调用一个父类的<code>Designated initializer</code>（通过使用<code>super.init(...)</code>实现）。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name: String
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> license: Int
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(name: String, license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.license = license
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">convenience</span> <span style="color:#66d9ef">init</span>(license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.<span style="color:#66d9ef">init</span>(name: <span style="color:#e6db74">&#34;Fido&#34;</span>, license: license)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">convenience</span> <span style="color:#66d9ef">init</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.<span style="color:#66d9ef">init</span>(license: <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyDog</span>: Dog {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(name: String) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// self.init(license: 1) // compile error</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">super</span>.<span style="color:#66d9ef">init</span>(name: name, license: <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> dog = Dog()
</span></span></code></pre></div><p>子类的<code>Designated initializer</code>中，必须按如下顺序进行初始化：</p>
<ol>
<li>
<p>必须确保自己的所有的属性都被初始化。</p>
</li>
<li>
<p>接着必须调用<code>super.init()</code>。</p>
</li>
<li>
<p>最后才能使用<code>self</code>继承自父类的实例方法或属性。</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyDog</span>: Dog {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(name: String) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// self.name = &#34;test&#34; // compile error</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">super</span>.<span style="color:#66d9ef">init</span>(name: <span style="color:#e6db74">&#34;name&#34;</span>, license: <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果一个子类既有<code>Designated initializer</code>又有<code>Convenience initializer</code>。那么在便利初始化器中必须使用<code>self.init()</code>来直接或者间接调用<code>Designated initializer</code>。</p>
<p>子类也可以重写父类的初始化器。<font color=LightSeaGreen>一个初始化器的参数与父类的方便初始化器相匹配时，子类的初始化器可以是指定的初始化器或便利初始化器，并且不被标记为<code>override</code></font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name: String
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> license: Int
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(name: String, license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.license = license
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">convenience</span> <span style="color:#66d9ef">init</span>(license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.<span style="color:#66d9ef">init</span>(name: <span style="color:#e6db74">&#34;Fido&#34;</span>, license: license)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">convenience</span> <span style="color:#66d9ef">init</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.<span style="color:#66d9ef">init</span>(license: <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyDog</span>: Dog {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">super</span>.<span style="color:#66d9ef">init</span>(name: <span style="color:#e6db74">&#34;name&#34;</span>, license: <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 或者</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//convenience init(license: Int) {</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//     self.init(license: 1)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//}</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>子类的初始化器参数与父类的指定初始化器相匹配时，子类的初始化器可以是指定的初始化器或方便初始化器，并且必须标记为<code>override</code>。并且<code>override</code>的指定初始化器必须通过<code>super.init(...)</code>调用父类的指定初始化器。</p>
<p>如果一个子类<code>override</code>父类<font color=LightSeaGreen>所有的指定初始化器，那么子类将继承父类所有的便利初始化器(这是一个例外，因为一个子类有任何指定的初始化器，则不继承初始化器)。</font></p>
<p>下面的代码是合法的，因为类<code>NoiseDog</code>继承了<code>Dog</code>的所有初始化器。但是不能使用<code>let nd3=NoiseDog()</code>，因为<code>Dog</code>里没有<code>init()</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name: String
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> license: Int
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(name: String, license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.license = license
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">convenience</span> <span style="color:#66d9ef">init</span>(license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.<span style="color:#66d9ef">init</span>(name: <span style="color:#e6db74">&#34;Fido&#34;</span>, license: license)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NoisyDog</span>: Dog {
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> nd1 = NoisyDog(name: <span style="color:#e6db74">&#34;Fido&#34;</span>, license: <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> nd2 = NoisyDog(license: <span style="color:#ae81ff">2</span>)
</span></span></code></pre></div><p>在下面的代码中，因为<code>NoiseDog</code>没有指定初始化器，只有便利初始化器，所以它继承了<code>Dog</code>的所有初始化器。因此，在便利初始化器中调用<code>self.init(name: &quot;Fido&quot;, license: license)</code>也是合法的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name: String
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> license: Int
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(name: String, license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.license = license
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">convenience</span> <span style="color:#66d9ef">init</span>(license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.<span style="color:#66d9ef">init</span>(name: <span style="color:#e6db74">&#34;Fido&#34;</span>, license: license)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NoisyDog</span>: Dog {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">convenience</span> <span style="color:#66d9ef">init</span>(name: String) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.<span style="color:#66d9ef">init</span>(name: name, license: <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在下面的代码中，因为<code>NoisyDog</code>声明了指定初始化器，因此不再继承父类<code>Dog</code>的所有初始化器。如果调用父类的指定初始化器需要使用<code>super</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name: String
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> license: Int
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(name: String, license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.license = license
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">convenience</span> <span style="color:#66d9ef">init</span>(license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.<span style="color:#66d9ef">init</span>(name: <span style="color:#e6db74">&#34;Fido&#34;</span>, license: license)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NoisyDog</span>: Dog {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(name: String) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">super</span>.<span style="color:#66d9ef">init</span>(name: name, license: <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在下面的例子中，因为<code>NoiseDog</code>已经覆写父类<code>Dog</code>的所有<code>designated initializers</code>，所以它继承了父类的<code>convenience initializers</code>，所以它能调用<code>NoisyDog(license:2)</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name: String
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> license: Int
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(name: String, license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.license = license
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">convenience</span> <span style="color:#66d9ef">init</span>(license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.<span style="color:#66d9ef">init</span>(name: <span style="color:#e6db74">&#34;Fido&#34;</span>, license: license)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NoisyDog</span>: Dog {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">init</span>(name: String, license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">super</span>.<span style="color:#66d9ef">init</span>(name: name, license: license)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> nd1 = NoisyDog(name:<span style="color:#e6db74">&#34;Rover&#34;</span>, license:<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> nd2 = NoisyDog(license:<span style="color:#ae81ff">2</span>)
</span></span></code></pre></div><p>一个类的初始化器前面可以有一个关键字<code>required</code>，这意味着一个子类不能缺少这个初始化器。这又意味着，如果一个子类实现了指定初始化器，从而阻断了继承，它必须覆写这个初始化器，并标记为<code>required</code>。在下面的例子中，如果<code>NoisyDog</code>中的初始化器<code>required init(name: String)</code>缺少关键字<code>required</code>将会出现编译错误。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name: String
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">required</span> <span style="color:#66d9ef">init</span>(name: String) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NoisyDog</span>: Dog {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> obedient = <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(obedient: Bool) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.obedient = obedient
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">super</span>.<span style="color:#66d9ef">init</span>(name: <span style="color:#e6db74">&#34;Fido&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">required</span> <span style="color:#66d9ef">init</span>(name: String) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">super</span>.<span style="color:#66d9ef">init</span>(name: name)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在上面的代码中，虽然在<code>NoisyDog</code>中已经覆写了<code>init(name: String)</code>，但并未标记为<code>override</code>，而是标记了为了<code>required</code>，这是因为<code>'override' is implied when overriding a required initializer</code>。并且<code>required</code>保证了向下传递。</p>
<h2 id="class-deinitializer">class deinitializer</h2>
<p>类的析构器是用关键字<code>deinit</code>声明的函数，后面是包含函数主体的花括号。但不能手动调用这个函数，当这个类的实例不存在时，它会自动被调用。如果一个类有一个父类，子类的<code>deinit</code>会在父类的<code>deinit</code>之前被调用。</p>
<p>只有类有<code>deinit</code>方法，<code>struct</code>和<code>enum</code>没有<code>deinit</code>方法，这是因为类是一种引用类型。我们的想法是，你可能想进行一些清理。类的<code>deinit</code>的另一个好用途是记录到控制台，向你自己证明你的实例是以良好的秩序消失的。在<code>deinit</code>过程中，属性观察者不被调用。</p>
<h2 id="class-properties">class properties</h2>
<p>子类可以覆写继承父类的属性，此时必须保持和父类属性同名以及同类型，而且必须使用<code>override</code>标记。覆写的属性不能为存储属性，更具体地说：</p>
<ul>
<li>
<p>如果父类的属性是可写的（一个存储属性或者有<code>setter</code>的计算属性），子类的覆写可以包括为这个属性添加设置器观察者。</p>
</li>
<li>
<p>或者子类覆写可以是计算属性。（1）如果父类的属性是存储的，那么子类使用计算属性来覆写时，一定要同时有<code>getter</code>和<code>setter</code>。（2）如果父类的属性是计算的，那么子类覆写的计算属性，至少需要<code>getter</code>（如果父类的计算属性有<code>setter</code>那么子类重写的方法必须有<code>setter</code>；如果父类的计算属性没有<code>setter</code>，那么子类可以添加一个）。</p>
</li>
</ul>
<p>覆写属性的函数可以通过<code>super</code>关键字对继承的属性进行读写。</p>
<h2 id="staticclass-members">Static/Class Members</h2>
<p>一个类可以有静态成员，标记为<code>static</code>，就像一个结构或枚举。它也可以有类成员，标记为<code>class</code>。静态成员和类成员都可以被子类所继承。</p>
<p>静态方法和类方法的主要区别在于，<font color=red>静态方法不能被重写，就好像静态方法是<code>class final</code>的同义词一样</font>。下面的代码会编译报错，并提示<code>Cannot override static method</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">whatDogsSay</span>() -&gt; String {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;woof&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(Dog.whatDogsSay())
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NoisyDog</span>: Dog {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">whatDogsSay</span>() -&gt; String {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;noisy&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在上面的代码中，任何继承<code>Dog</code>的子类都会继承它的静态方法<code>whatDogsSay</code>，但是不能包含任何具有相同签名的静态方法或者类方法。但如果在<code>Dog</code>中使用<code>class</code>来声明<code>whatDogsSay</code>，则可以在子类中<code>override</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">func</span> whatDogsSay() -&gt; String {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;woof&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(Dog.whatDogsSay())
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NoisyDog</span>: Dog {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">whatDogsSay</span>() -&gt; String {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;noisy&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 或者</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">func</span> whatDogsSay() -&gt; String {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;woof&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(Dog.whatDogsSay())
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NoisyDog</span>: Dog {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">func</span> whatDogsSay() -&gt; String {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;noisy&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>静态属性和类属性的区别类似于静态方法和类方法的区别。但有一个额外的、相当戏剧性的限定：<font color=red>静态属性可以被存储，但类属性必须是一个计算的属性</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">var</span> whatDogsSay = <span style="color:#e6db74">&#34;woof&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(Dog.whatDogsSay)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面定义的<code>Dog</code>有静态的存储属性，但是它不能被任何子类所<code>override</code>。如果要能被子类覆写，那么必须使用<code>class</code>来声明，并且必须声明为计算属性：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">var</span> whatDogsSay: String {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;woof&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(Dog.whatDogsSay)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NoisyDog</span>: Dog {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">var</span> whatDogsSay: String {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;WOOF&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="多态">多态</h2>
<p>替换原则：声明类的引用时指定某种类型，但<font color=red>实际的对象可能是该类型的一个子类</font>。在下面的代码中，<code>dog</code>虽然声明为<code>Dog</code>类型，但是赋值给它的是<code>Dog</code>的子类<code>NoisyDog</code>的实例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NoisyDog</span>: Dog {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> dog: Dog = NoisyDog()
</span></span></code></pre></div><p>内部身份规则：一个对象的实际类型是其内部性质的问题，与该对象如何被提及无关。也就是说，当一个消息被发送时，重要的不是该消息的接收者是如何通过这个或那个引用被输入的，而是该接收者实际上是什么类型。在下面的代码中虽然<code>tellToBark</code>函数期望的类型为<code>Dog</code>，但实际传递的是<code>NoisyDog</code>类型实例，因此调用<code>bark</code>方法时，调用的是<code>NoisyDog</code>的<code>bark</code>方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;woof&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NoisyDog</span>: Dog {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">_</span> <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1.</span>..<span style="color:#ae81ff">3</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">super</span>.bark()
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">tellToBark</span>(<span style="color:#66d9ef">_</span> d: Dog) {
</span></span><span style="display:flex;"><span>    d.bark()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> nd = NoisyDog()
</span></span><span style="display:flex;"><span>tellToBark(nd)  <span style="color:#75715e">// woof woof woof</span>
</span></span></code></pre></div><p>关键词<code>self</code>的含义是多态性的另一个重要体现。<code>self</code>的含义取决于实际实例的类型，即使<code>self</code>这个词出现在父的代码中。在下面代码中，在<code>Dog</code>中的<code>speak</code>方法中使用<code>self</code>调用了<code>bark</code>方法，因为<code>NoiseDog</code>继承自<code>Dog</code>，所以也继承了<code>speak</code>方法，又因为它覆写了<code>bark</code>，所以<code>speak</code>中调用的<code>bark</code>变成了<code>NosieDog</code>中的<code>bark</code>方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;woof&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">speak</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.bark()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NoisyDog</span>: Dog {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">_</span> <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1.</span>..<span style="color:#ae81ff">3</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">super</span>.bark()
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> nd = NoisyDog() 
</span></span><span style="display:flex;"><span>nd.speak() <span style="color:#75715e">// woof woof woof</span>
</span></span></code></pre></div><p>多态对于可选类型也是适用的。假设有一个<code>Optional</code>类型的引用，包裹着<code>Dog</code>。你已经知道可以给它赋值<code>Dog</code>的实例，也可以赋值<code>NoisyDog</code>的实例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> dog : Dog?
</span></span><span style="display:flex;"><span>dog = Dog() 
</span></span><span style="display:flex;"><span>dog = NoisyDog() 
</span></span><span style="display:flex;"><span>dog = Optional(NoisyDog())
</span></span></code></pre></div><p>多态性很酷，但从总体上看，<font color=red>它也是比较慢的，因为它需要动态调度，这意味着编译器不能进行某些优化</font>，而且运行时必须考虑给类实例的信息意味着什么。可以通过声明一个类或一个类成员为<code>final</code>或<code>private</code>来减少对动态调度的需求。或者使用一个结构，结构不需要动态调度。</p>
<h2 id="casting">Casting</h2>
<p><code>Swift</code>是一种严格类型的语言，允许向对象引用发送的消息取决于引用的类型。但是，多态性的内部身份原则说，一个对象可能有一个不同于其引用的声明类型的实际类型。在下面的代码中，在<code>tellToHush</code>中调用<code>beQuit</code>是非法的，会出现<code>Value of type 'Dog' has no member 'beQuiet'</code>报错信息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;woof&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NoisyDog</span>: Dog {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">super</span>.bark()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">beQuiet</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.bark()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">tellToHush</span>(<span style="color:#66d9ef">_</span> d: Dog) {
</span></span><span style="display:flex;"><span>    d.beQuiet() <span style="color:#75715e">// compile error </span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面的代码编译报错是因为<code>Dog</code>类型中没有<code>beQuiet</code>方法，该方法是子类<code>NoisyDog</code>特有的。而当将<code>NoisyDog</code>实例传给<code>tellToHush</code>时，实际上可以使用<code>beQuiet</code>方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">tellToHush</span>(<span style="color:#66d9ef">_</span> d: Dog) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> d = d <span style="color:#66d9ef">as</span>! NoisyDog <span style="color:#75715e">// crash </span>
</span></span><span style="display:flex;"><span>    d.beQuiet()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在上面的例子中，相当于告诉编译器，对象<code>d</code>可能是<code>NoiseDog</code>类型的，但是使用<code>as!</code>可能会发生崩溃，因为<code>d</code>不一定是<code>NoiseDog</code>类型。也可以先使用关键字<code>is</code>来判断是否为<code>NoiseDog</code>类型，然后使用<code>as!</code>; 或者使用<code>as?</code>进行转换，或者使用<code>if let </code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">tellToHush</span>(<span style="color:#66d9ef">_</span> d: Dog) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> d <span style="color:#66d9ef">is</span> NoisyDog {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> d = d <span style="color:#66d9ef">as</span>! NoisyDog 
</span></span><span style="display:flex;"><span>        d.beQuiet()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">tellToHush</span>(<span style="color:#66d9ef">_</span> d: Dog) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> d = d <span style="color:#66d9ef">as</span>? NoisyDog <span style="color:#75715e">// an Optional wrapping a NoisyDog </span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> d <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        d!.beQuiet()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">tellToHush</span>(<span style="color:#66d9ef">_</span> d: Dog) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> d = d <span style="color:#66d9ef">as</span>? NoisyDog <span style="color:#75715e">// an Optional wrapping a NoisyDog </span>
</span></span><span style="display:flex;"><span>    d?.beQuiet()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">tellToHush</span>(<span style="color:#66d9ef">_</span> d: Dog) {
</span></span><span style="display:flex;"><span>    (d <span style="color:#66d9ef">as</span>? NoisyDog)?.beQuiet()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">tellToHush</span>(<span style="color:#66d9ef">_</span> d: Dog) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> d = d <span style="color:#66d9ef">as</span>? NoisyDog {
</span></span><span style="display:flex;"><span>        d.beQuiet()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>对于<code>is, as!</code>和<code>as?</code>操作符来说，它们对于<code>Optional</code>类型的工作方式与<code>==</code>比较操作符相同：会自动解包<code>Optional</code>对象，然后进行比较：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> dog: Dog? = NoisyDog()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> dog <span style="color:#66d9ef">is</span> NoisyDog {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;true&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在上面的例子中，<code>is</code>关键字首先检查<code>dog</code>是否为<code>nil</code>，如果<code>dog</code>不为<code>nil</code>，则检查<code>dog</code>包裹的类型是否为<code>NoiseDog</code>。</p>
<p>可以对一个<code>optional</code>类型使用<code>as!</code>操作符。当<code>as!</code>操作符左边是一个<code>optional</code>类型时，<code>Swift</code>会先解包，然后再进行转换，下面这段代码是有效的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> dog1: Dog? = NoisyDog()
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> dog2 = dog1 <span style="color:#66d9ef">as</span>! NoisyDog
</span></span><span style="display:flex;"><span>dog2.beQuiet()
</span></span></code></pre></div><p>但是上面的代码是不安全的，如果<code>dog1</code>为<code>nil</code>或者执行<code>Dog</code>类型的实例，则<code>dog1 as! NoisyDog</code>转换失败而发生崩溃，使用<code>as?</code>会更安全：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> dog1: Dog? = NoisyDog()
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> dog2 = dog1 <span style="color:#66d9ef">as</span>? NoisyDog
</span></span><span style="display:flex;"><span>dog2?.beQuiet()
</span></span></code></pre></div><p>在上面的代码中，<code>as?</code>首先会检查<code>dog1</code>是为<code>nil</code>，如果为<code>nil</code>则<code>dog2</code>的结果为<code>nil</code>。如果<code>dog1</code>不为<code>nil</code>，但不是<code>NoisyDog</code>的实例，则转换失败，<code>dog2</code>为<code>nil</code>，否则转换成功，<code>dog2</code>为<code>NoisyDog?</code>。</p>
<p>使用强制转换的另一种方式是当<code>Swift</code>和<code>Objective-C</code>两种类型等效时进行值交换。例如，可以将<code>Swift String </code>转换为<code>Cocoa NSString</code>，反之亦然。这不是因为一个是另一个的子类，而是因为它们是相互桥接的；在非常真实的意义上，它们是同一种类型。当从<code>String</code>转换为<code>NSString</code>时，不是向下转换，并且所做的事情并不危险，因此使用<code>as</code>运算符，没有感叹号或问号。</p>
<p>一般来说，要从<code>Swift</code>类型过渡到桥接的<code>Objective-C</code>类型，需要显式转换（字符串文字常量除外。在下面的代码中，<code>Swift</code>的<code>String</code>类型和<code>Objective-C</code>的<code>NSString</code>等价，<code>Int</code>和<code>NSNumber</code>等价：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s : NSString = <span style="color:#e6db74">&#34;howdy&#34;</span> <span style="color:#75715e">// string literal to NSString</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s2 = <span style="color:#e6db74">&#34;howdy&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s3 : NSString = s2 <span style="color:#66d9ef">as</span> NSString <span style="color:#75715e">// String to NSString</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> i : NSNumber = <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">as</span> NSNumber <span style="color:#75715e">// Int to NSNumber</span>
</span></span></code></pre></div><p>上面的这种代码是相当人为的。在现实生活中，不会经常进行强制转换，因为<code>Cocoa API</code>会以<code>Swift</code>类型的形式呈现给出来。这是合法的，没有强制转换：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> name = <span style="color:#e6db74">&#34;MyNib&#34;</span> <span style="color:#75715e">// Swift String </span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> vc = ViewController(nibName:name, bundle:<span style="color:#66d9ef">nil</span>)
</span></span></code></pre></div><p>类<code>UIViewController</code>来自于<code>Cocoa</code>，它的<code>NibName</code>属性是<code>Objective-C</code>的<code>NSString</code>类型，而不是<code>Swift</code>字符串。但不必通过强制转换来帮助<code>Swift String name</code>过桥，因为在<code>Swift</code>世界中，<code>nibName:</code>被输入为一个<code>Swift String</code>（实际上是一个可选字符串）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span> <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">init</span>(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?)
</span></span></code></pre></div><p>在下面的代码中，不必通过强制转换来帮助<code>Swift String</code>类型的<code>s</code>桥接，因为<code>set(_:forKey:)</code>的第一个参数为<code>Swift</code>的<code>Any</code>类型（实际上是一个<code>Optional</code>包装的<code>Any</code>）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> ud = UserDefaults.standard
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s = <span style="color:#e6db74">&#34;howdy&#34;</span>
</span></span><span style="display:flex;"><span>ud.<span style="color:#66d9ef">set</span>(s, forKey: <span style="color:#e6db74">&#34;greeting&#34;</span>)
</span></span></code></pre></div><p>反过来说，你有可能从<code>Objective-C</code>收到一个值，而<code>Swift</code>并不了解这个值的真正底层类型。在这种情况下，你可能希望显式转换为底层类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> ud = UserDefaults.standard 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> test = ud.object(forKey:<span style="color:#e6db74">&#34;greeting&#34;</span>) <span style="color:#66d9ef">as</span>! String
</span></span></code></pre></div><p>当调用<code>ud.object(forKey:)</code>时，<code>Swift</code>并不知道真正的底层类型信息，因为结果是一个<code>Any</code>（实际上是一个包裹<code>Any</code>的<code>Optional</code>）。但是我们知道这个特定的调用应该产生一个字符串&ndash;因为那是一开始就输入的东西。所以我们可以把这个值强行转换为一个字符串&ndash;而且它还能工作。然而，如果<code>ud.object(forKey: &quot;greeting&quot;)</code>不是一个字符串（或者它是<code>nil</code>），就会发生崩溃。如果你不确定你的立场，为了安全起见，使用<code>is</code>或<code>as?</code>。</p>
<h2 id="type-references">Type References</h2>
<p>有时我们获取到了一个实例，此时并知道这个实例的类型，可能只是出于调试目的将其类型记录到控制台，或者可能需要使用类型作为值。此时，可以使用全局函数<code>type(of:)</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> dogTest: Dog = NoisyDog()
</span></span><span style="display:flex;"><span>debugPrint(type(of: dogTest)) <span style="color:#75715e">// xxx.NoisyDog</span>
</span></span></code></pre></div><p>对于一个实例来说，能够引用它自己的类型尤为重要。通常，<font color=LightSeaGreen>这是为了向该类型发送消息</font>。例如，假设一个实例想要向它的类发送一个类消息。在前面的例子中，<code>Dog</code>实例方法通过向<code>Dog</code>类型发送消息来获取<code>Dog</code>类属性，实际上就是使用<code>Dog</code>这个词：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">var</span> whatDogsSay: String {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;woof&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(Dog.whatDogsSay)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>表达式<code>Dog.whatDogsSay</code>看起来笨拙并且不灵活，它在一个类型当中，按理说应该知道它是什么。可以使用关键字<code>Self</code>（首字母大写大）来引用当前类型——<code>self</code>的类型:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">var</span> whatDogsSay: String {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;woof&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#66d9ef">Self</span>.whatDogsSay)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在代码中使用<code>Self</code>而不是具体的类型名字，不仅是因为更简单，而且它更强大，<font color=red>因为<code>Self</code>和<code>self</code>一样，也遵循多态性</font>。在下面的代码中，当<code>NoisyDog</code>类型的实例调用<code>bark</code>时，它的<code>Self</code>就是<code>NoisyDog</code>。因此，取到的<code>whatDogsSay</code>就是<code>&quot;woof woof woof&quot;</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NoisyDog</span>: Dog {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">var</span> whatDogsSay: String {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;woof woof woof&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> dogTest: Dog = NoisyDog()
</span></span><span style="display:flex;"><span>debugPrint(type(of: dogTest)) <span style="color:#75715e">// xxx.NoisyDog</span>
</span></span><span style="display:flex;"><span>debugPrint(dogTest.bark()) <span style="color:#75715e">// &#34;woof woof woof&#34;</span>
</span></span></code></pre></div><p><code>Self</code>是<code>Swift 5.1</code>引入的，在那之前只能使用<code>type(of:self)</code>。多态<code>Self</code>的另一个重要用途是作为返回类型。为了说明为什么这很有价值，将介绍工厂方法的概念。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NewDog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name: String
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(name: String) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">func</span> makeAndName() -&gt; NewDog {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> d = <span style="color:#66d9ef">Self</span>(name: <span style="color:#e6db74">&#34;Fido&#34;</span>) <span style="color:#75715e">// compile error</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> d
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面的代码会发生编译错误，这是因为编译器怀疑<code>init(name:)</code>初始化器对于<code>NewDog</code>的每个可能的子类型实现。为了让它放心，我们必须使用<code>required</code>关键字声明该初始化器：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NewDog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name: String
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">required</span> <span style="color:#66d9ef">init</span>(name: String) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">func</span> makeAndName() -&gt; NewDog {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> d = <span style="color:#66d9ef">Self</span>(name: <span style="color:#e6db74">&#34;Fido&#34;</span>) <span style="color:#75715e">// compile error</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> d
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NewNoisyDog</span>: NewDog {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>required</code>声明可以让编译器放心: <code>NewDog</code>的每个子类都必须继承或重新实现<code>init(name:)</code>，所以在一个可能指向<code>Dog</code>或<code>Dog</code>的某个子类的类型引用上调用<code>init(name:)</code>信息是合法的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> newDog1 = NewDog.makeAndName() <span style="color:#75715e">// d is a Dog named Fido</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> newDog2 = NewNoisyDog.makeAndName() <span style="color:#75715e">// d2 is a NoisyDog named Fido</span>
</span></span></code></pre></div><p>但是上面的代码还有外一个问题，尽管<code>newDog2</code>事实上是<code>NewNoisyDog</code>，但是<code>makeAndName</code>返回的是<code>NewDog</code>。实际上我们要声明这个方法返回一个与最初发送<code>makeAndName</code>消息的类相同类型的实例。换句话说，我们需要一个多态的类型声明，可以使用<code>Self</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NewDog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name: String
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">required</span> <span style="color:#66d9ef">init</span>(name: String) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">func</span> makeAndName() -&gt; <span style="color:#66d9ef">Self</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> d = <span style="color:#66d9ef">Self</span>(name: <span style="color:#e6db74">&#34;Fido&#34;</span>) <span style="color:#75715e">// compile error</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> d
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NewNoisyDog</span>: NewDog {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> newDog1 = NewDog.makeAndName() <span style="color:#75715e">// d is a Dog named Fido</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> newDog2 = NewNoisyDog.makeAndName() <span style="color:#75715e">// d2 is a NoisyDog named Fido</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>debugPrint(type(of: newDog2))
</span></span></code></pre></div><p><code>Self</code>类型作为返回类型时表示<code>这是运行时任何类型的实例</code>，因此当<code>NewNoisyDog</code>调用<code>NewNoisyDog.makeAndName()</code>得到的是<code>NewNoisyDog</code>实例。<code>Self</code>也可以用户实例方法的声明中。因此，可以编写工厂方法的实例方法版本。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NewDog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name: String
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">required</span> <span style="color:#66d9ef">init</span>(name: String) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">func</span> makeAndName() -&gt; <span style="color:#66d9ef">Self</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> d = <span style="color:#66d9ef">Self</span>(name: <span style="color:#e6db74">&#34;Fido&#34;</span>) <span style="color:#75715e">// compile error</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> d
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">havePuppy</span>(name: String) -&gt; <span style="color:#66d9ef">Self</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">Self</span>(name: name)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NewNoisyDog</span>: NewDog {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> newDog1 = NewDog.makeAndName() <span style="color:#75715e">// d is a Dog named Fido</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> newDog2 = NewNoisyDog.makeAndName() <span style="color:#75715e">// d2 is a NoisyDog named Fido</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>debugPrint(type(of: newDog2))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> newDog11 = newDog1.havePuppy(name: <span style="color:#e6db74">&#34;test1&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> newDog22 = newDog2.havePuppy(name: <span style="color:#e6db74">&#34;test2&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>debugPrint(type(of: newDog11))
</span></span><span style="display:flex;"><span>debugPrint(type(of: newDog22))
</span></span></code></pre></div><p>在某些情况下，可能希望将对象类型视为值，那是合法的。对象类型本身就是一种对象，这就是<code>Swift</code>所说的元类型。因此<font color=red>对象类型可以分配给变量或作为参数传递</font>：</p>
<ul>
<li>
<p>声明一个对象的类型是可以接受的。如在声明一个变量或参数的类型时&ndash;使用点状符号与类型的名称和关键字<code>Type</code>。</p>
</li>
<li>
<p>使用一个对象类型作为一个值。比如当把一个类型分配给一个变量或作为一个参数传递时，把对象交给<code>type(of:)</code>，或者用类型的名称和关键字<code>self</code>来点注。(在后一种情况下，类型的名称可能是<code>Self</code>，在这种情况下，可以使用<code>Self.self</code>)。</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">dogTypeExpecter</span>(<span style="color:#66d9ef">_</span> whatType: NewDog.<span style="color:#66d9ef">Type</span>) {
</span></span><span style="display:flex;"><span>    debugPrint(whatType)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>dogTypeExpecter(NewDog.<span style="color:#66d9ef">self</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> dog = NewDog(name: <span style="color:#e6db74">&#34;test&#34;</span>)
</span></span><span style="display:flex;"><span>dogTypeExpecter(type(of: dog))
</span></span><span style="display:flex;"><span>dogTypeExpecter(NewNoisyDog.<span style="color:#66d9ef">self</span>)
</span></span></code></pre></div><p>为了更实际地说明问题，将把<code>Dog</code>工厂方法重写为一个全局工厂函数，它将接受一个<code>Dog</code>类型作为参数，并从该类型创建一个实例。可以使用一个类型的变量引用（元类型）来实例化该类型，但不能只是在一个变量引用上加上括号，必须使用<code>init</code>方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">dogMakerAndNamer</span>(<span style="color:#66d9ef">_</span> whatType: NewDog.<span style="color:#66d9ef">Type</span>) -&gt; NewDog {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> d = whatType(name: <span style="color:#e6db74">&#34;Fido&#34;</span>) <span style="color:#75715e">// compile error: Initializing from a metatype value must reference &#39;init&#39; explicitly</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> d
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">dogMakerAndNamer</span>(<span style="color:#66d9ef">_</span> whatType: NewDog.<span style="color:#66d9ef">Type</span>) -&gt; NewDog {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> d = whatType.<span style="color:#66d9ef">init</span>(name: <span style="color:#e6db74">&#34;Fido&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> d
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> d11 = dogMakerAndNamer(NewDog.<span style="color:#66d9ef">self</span>) <span style="color:#75715e">// d11 is a Dog named Fido </span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> d12 = dogMakerAndNamer(NewNoisyDog.<span style="color:#66d9ef">self</span>) <span style="color:#75715e">// d12 is a NoisyDog named Fido</span>
</span></span></code></pre></div><p>不幸的是，即使底层的真正类型是<code>NewNoisyDog</code>，全局工厂函数<code>dogMakerAndNamer</code>返回的也是一个<code>NewDog</code>对象。因为是全局函数，这里不能使用<code>Self</code>来解决这个问题，但是可以使用泛型。</p>
<ul>
<li><code>type(of:)</code>应用于一个对象：对象的多态（内部）类型，与引用的类型无关。</li>
<li><code>Self</code>：在方法主体中，或者在方法声明中指定返回类型时，这个类型或这个实例的类型，多态性。</li>
<li><code>.Type</code>：附加在类型声明中的一个类型上，以指定该类型本身（或一个子类型）被期望。</li>
<li><code>.self</code>：发送给一个类型以生成一个元类型，适合于传递一个类型（<code>.Type</code>）被期望的地方。</li>
</ul>
<h2 id="comparing-types">Comparing Types</h2>
<p>类型引用之间可以相互比较。在<code>==</code>比较符的右边，可以用<code>.self</code>来表示一个类型的名称。而在<code>is</code>关键字的右边，可以用<code>.Type</code>来表示一个类型的名称。区别在于：<code>==</code>操作符<font color=red>测试的是绝对相同的类型，而<code>is</code>则允许子类型</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">dogTypeExpecter</span>(<span style="color:#66d9ef">_</span> whatType: NewDog.<span style="color:#66d9ef">Type</span>) {
</span></span><span style="display:flex;"><span>    debugPrint(whatType)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> equality = whatType == NewDog.<span style="color:#66d9ef">self</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> typology = whatType <span style="color:#66d9ef">is</span> NewDog.<span style="color:#66d9ef">Type</span>
</span></span><span style="display:flex;"><span>    debugPrint(equality,typology)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>dogTypeExpecter(NewDog.<span style="color:#66d9ef">self</span>) <span style="color:#75715e">// true,true</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> dog = NewDog(name: <span style="color:#e6db74">&#34;test&#34;</span>)
</span></span><span style="display:flex;"><span>dogTypeExpecter(type(of: dog)) <span style="color:#75715e">// true,true</span>
</span></span><span style="display:flex;"><span>dogTypeExpecter(NewNoisyDog.<span style="color:#66d9ef">self</span>) <span style="color:#75715e">// false, true</span>
</span></span></code></pre></div><p>在上面的例子中，<code>whatType</code>放在比较操作符的左边，它可能被<code>type(of:)</code>替换，或者<code>.self</code>替换。同时<code>==</code>操作符右边的<code>NewDog.self</code>也可能被<code>whatType</code>和<code>type(of:)</code>替换。但是<code>is</code>关键字的右边不能出现<code>whatType</code>和<code>type(of:)</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>debugPrint(type(of: dog) == NewDog.<span style="color:#66d9ef">self</span>, type(of: dog) == NewNoisyDog.<span style="color:#66d9ef">self</span>) <span style="color:#75715e">// true,false</span>
</span></span></code></pre></div><h2 id="available属性">available属性</h2>
<p>有个类涉及到的属性只能在<code>iOS 13.0</code>以上系统使用，为了将该类定义为其它类的属性，必须加上<code>available</code>和<code>lazy</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>@available(iOS <span style="color:#ae81ff">13.0</span>, <span style="color:#f92672">*</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">HapticManager</span> {
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">VibrationService</span> {
</span></span><span style="display:flex;"><span>    @available(iOS <span style="color:#ae81ff">13.0</span>, <span style="color:#f92672">*</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span>(<span style="color:#66d9ef">set</span>) <span style="color:#66d9ef">lazy</span> <span style="color:#66d9ef">var</span> hapticManager = HapticManager()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="xcframework">xcframework</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>xcodebuild clean archive -workspace CMBMPGMK.xcworkspace -scheme CMBMPGMK -configuration release -sdk iphoneos -destination &#39;generic/platform=iOS&#39; -archivePath &#39;./build/iphonedevice.xcarchive&#39;  SKIP_INSTALL=NO BUILD_LIBRARIES_FOR_DISTRIBUTION=YES
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>xcodebuild clean archive -workspace CMBMPGMK.xcworkspace -scheme CMBMPGMK -configuration release -sdk iphonesimulator -destination &#39;generic/platform=iOS Simulator&#39; -archivePath &#39;./build/iphonesimulator.xcarchive&#39; SKIP_INSTALL=NO BUILD_LIBRARIES_FOR_DISTRIBUTION=YES
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>xcodebuild -create-xcframework -framework ./iphonesimulator.xcarchive/Products/Library/Frameworks/CMBMPGMK.framework -framework ./iphonedevice.xcarchive/Products/Library/Frameworks/CMBMPGMK.framework -output CMBMPGMK.xcframework
</span></span></code></pre></div><ul>
<li>静态库</li>
<li>BUILD_LIBRARIES_FOR_DISTRIBUTION=YES</li>
<li>头文件放到public，以及要将头文件放出来</li>
<li>bitcode=no</li>
<li>exclude simulator arm64</li>
</ul>

    </div>
    <footer class="post-footer">
        
 
<div class="post-tags">     
     
    <a href="https://iihui.github.io/tags/ios" rel="tag" title="iOS">#iOS#</a>
    
</div>



        <div class="post-nav">
    <div class="post-nav-next post-nav-item">
    
        <a href="https://iihui.github.io/post/tool-rider/" rel="next" title="Rider 使用">
        <i class="fa fa-chevron-left"></i> Rider 使用
        </a>
    
    </div>

    <div class="post-nav-prev post-nav-item">
    
        <a href="https://iihui.github.io/post/ios-protocol/" rel="prev" title="Swift协议">
        Swift协议 <i class="fa fa-chevron-right"></i>
        </a>
    
    </div>
</div>
      
        <div class="post-nav">
    <div style="border: 1px dashed #e0e0e0; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
        <div style="float:left;margin-top:0px;">
            <img src="https://i.loli.net/2020/02/09/SvhUdz4XJsOr9Vk.jpg" width="128px" height="128px"/>
            <div style="text-align:center;">谢谢支持!</div>
        </div>
        <div>
            <p style="margin-top:10px;">
                标题：iOS 14 编程基础
                <br />作者：阿呆<a target="_blank" href="https://iihui.github.io/"></a>
                
                <br />地址：https://iihui.github.io/post/ios-fundamentals/
                <br />声明：自由转载-非商用-保持署名（创作共享4.0许可证）
            </p>
        </div>
    </div>
    <div class="clear"></div>
</div>
        
        
        




    </footer>
  </article>
</section>

          </div>
        </div>
        <div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>
<aside id="sidebar" class="sidebar">
  <div class="sidebar-inner">

  <ul class="sidebar-nav motion-element">
    <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
      文章目录
    </li>
    <li class="sidebar-nav-overview" data-target="site-overview">
      站点概览
    </li>
  </ul>

    <section class="site-overview sidebar-panel ">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
        src="https://i.loli.net/2020/02/07/dVFzrvZkHRNq2lL.jpg"
        alt="" />
    <p class="site-author-name" itemprop="name"></p>
    <p class="site-description motion-element" itemprop="description"> 
        coder &amp; cook</p>
</div>
      <nav class="site-state motion-element">
    <div class="site-state-item site-state-posts">
      <a href="https://iihui.github.io/post/">
        <span class="site-state-item-count">140</span>
        <span class="site-state-item-name">日志</span>
      </a>
    </div>
    <div class="site-state-item site-state-categories">    
        <a href="https://iihui.github.io/categories/">      
         
        <span class="site-state-item-count">18</span>
        
        <span class="site-state-item-name">分类</span>
        
        </a>
    </div>

    <div class="site-state-item site-state-tags">
        <a href="https://iihui.github.io/tags/">
         
        <span class="site-state-item-count">29</span>
        
        <span class="site-state-item-name">标签</span>
        </a>
    </div>
</nav>
      
      
<div class="links-of-author motion-element">
    
        <span class="links-of-author-item">
        <a href="https://coolshell.cn" target="_blank" title="皓 大">
            <i class="fa fa-fw fa-globe"></i>
            皓 大
        </a>
        </span>
    
        <span class="links-of-author-item">
        <a href="http://www.ruanyifeng.com" target="_blank" title="阮 大">
            <i class="fa fa-fw fa-globe"></i>
            阮 大
        </a>
        </span>
    
        <span class="links-of-author-item">
        <a href="https://juejin.im/" target="_blank" title="掘 金">
            <i class="fa fa-fw fa-globe"></i>
            掘 金
        </a>
        </span>
    
</div>


      

      <div class="links-of-blogroll motion-element inline">
<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=&amp;m=0&amp;s=220&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;bv=35" async="async"></script>
</div>

    </section>
    
<section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
    <div class="post-toc">
        <div class="post-toc-content"><nav id="TableOfContents">
  <ul>
    <li><a href="#object">Object</a>
      <ul>
        <li><a href="#variables">Variables</a></li>
        <li><a href="#functions">Functions</a></li>
        <li><a href="#the-structure-of-a-swift-file">The Structure of a Swift File</a></li>
        <li><a href="#scope-and-lifetime">Scope and Lifetime</a></li>
        <li><a href="#object-members">Object Members</a></li>
        <li><a href="#namespaces">Namespaces</a></li>
        <li><a href="#modules">Modules</a></li>
        <li><a href="#instances">Instances</a></li>
        <li><a href="#the-keyword-self">The Keyword self</a></li>
        <li><a href="#privacy">Privacy</a></li>
        <li><a href="#reserved-words">Reserved Words</a></li>
      </ul>
    </li>
    <li><a href="#functions-1">functions</a>
      <ul>
        <li><a href="#parameters">Parameters</a></li>
        <li><a href="#return-value">Return Value</a></li>
        <li><a href="#void-return-type-and-parameters">Void Return Type and Parameters</a></li>
        <li><a href="#function-signature">Function Signature</a></li>
        <li><a href="#external-parameter-names">External Parameter Names</a></li>
        <li><a href="#overloading">Overloading</a></li>
        <li><a href="#default-parameter-values">Default Parameter Values</a></li>
        <li><a href="#variadic-parameters">Variadic Parameters</a></li>
        <li><a href="#ignored-parameters">Ignored Parameters</a></li>
        <li><a href="#modifiable-parameters">Modifiable Parameters</a></li>
        <li><a href="#calling-objective-c-with-modifiable-parameters">Calling Objective-C with Modifiable Parameters</a></li>
        <li><a href="#called-by-objective-c-with-modifiable-parameters">Called by Objective-C with Modifiable Parameters</a></li>
        <li><a href="#function-in-function">Function in Function</a></li>
        <li><a href="#recursion">Recursion</a></li>
        <li><a href="#function-as-value">Function as Value</a></li>
        <li><a href="#anonymous-functions">Anonymous Functions</a>
          <ul>
            <li><a href="#using-anonymous-functions-inline">Using Anonymous Functions Inline</a></li>
            <li><a href="#anonymous-function-abbreviated-syntax">Anonymous Function Abbreviated Syntax</a>
              <ul>
                <li><a href="#省略返回值类型和箭头操作符">省略返回值类型和箭头操作符</a></li>
                <li><a href="#无参数时省略in关键字">无参数时省略in关键字</a></li>
                <li><a href="#省略参数类型">省略参数类型</a></li>
                <li><a href="#省略参数列表圆括号">省略参数列表圆括号</a></li>
                <li><a href="#有参数列表省略in表达式">有参数列表省略in表达式</a></li>
                <li><a href="#省略参数名">省略参数名</a></li>
                <li><a href="#省略函数标签">省略函数标签</a></li>
                <li><a href="#省略函数调用圆括号">省略函数调用圆括号</a></li>
                <li><a href="#省略return关键字">省略return关键字</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#define-and-call">Define and Call</a></li>
        <li><a href="#closures">Closures</a></li>
        <li><a href="#how-closures-improve-code">How Closures Improve Code</a></li>
        <li><a href="#function-returning-function">Function Returning Function</a></li>
        <li><a href="#closure-setting-a-captured-variable">Closure Setting a Captured Variable</a></li>
        <li><a href="#closure-preserving-captured-environment">Closure Preserving Captured Environment</a></li>
        <li><a href="#escaping-closures">Escaping Closures</a></li>
        <li><a href="#capture-lists">Capture Lists</a></li>
        <li><a href="#weak-strong-unowned">weak strong unowned</a></li>
        <li><a href="#implicit-capturing">Implicit capturing</a>
          <ul>
            <li><a href="#weak-references-are-not-always-the-answer">Weak references are not always the answer</a></li>
          </ul>
        </li>
        <li><a href="#curried-function">curried function</a></li>
        <li><a href="#function-references-and-selectors">Function References and Selectors</a></li>
        <li><a href="#function-reference-scope">Function Reference Scope</a></li>
        <li><a href="#selectors">Selectors</a></li>
      </ul>
    </li>
    <li><a href="#variables-and-simple-types">Variables and Simple Types</a>
      <ul>
        <li><a href="#variable-declaration">Variable Declaration</a>
          <ul>
            <li><a href="#explicit-variable-type-declaration">Explicit variable type declaration</a></li>
            <li><a href="#implicit-variable-type-by-initialization">Implicit variable type by initialization</a></li>
          </ul>
        </li>
        <li><a href="#computed-variable-initialization">Computed Variable Initialization</a></li>
        <li><a href="#computed-variables">Computed Variables</a></li>
        <li><a href="#computed-properties">Computed Properties</a></li>
        <li><a href="#property-wrappers">Property Wrappers</a></li>
        <li><a href="#setter-observers">Setter Observers</a></li>
        <li><a href="#lazy-initialization">Lazy Initialization</a></li>
        <li><a href="#singleton">Singleton</a></li>
        <li><a href="#built-in-simple-types">Built-In Simple Types</a></li>
        <li><a href="#numeric-coercion">Numeric coercion</a>
          <ul>
            <li><a href="#other-numeric-types">Other numeric types</a></li>
            <li><a href="#arithmetic-operations">Arithmetic operations</a></li>
            <li><a href="#comparison">Comparison</a></li>
          </ul>
        </li>
        <li><a href="#string">String</a></li>
        <li><a href="#range">Range</a></li>
        <li><a href="#tuple">Tuple</a></li>
        <li><a href="#optional">Optional</a>
          <ul>
            <li><a href="#unwrapping-an-optional">Unwrapping an Optional</a></li>
            <li><a href="#implicitly-unwrapped-optional">Implicitly unwrapped Optional</a></li>
            <li><a href="#the-keyword-nil">The keyword nil</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#object-types">Object Types</a>
      <ul>
        <li><a href="#initializers">Initializers</a>
          <ul>
            <li><a href="#deferred-initialization-of-properties">Deferred initialization of properties</a></li>
            <li><a href="#referring-to-self">Referring to self</a></li>
            <li><a href="#delegating-initializers">Delegating initializers</a></li>
            <li><a href="#failable-initializers">Failable initializers</a></li>
          </ul>
        </li>
        <li><a href="#properties">Properties</a>
          <ul>
            <li>
              <ul>
                <li><a href="#property-initialization-and-self">Property initialization and self</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#methods">Methods</a>
          <ul>
            <li>
              <ul>
                <li><a href="#the-secret-life-of-instance-methods">The Secret Life of Instance Methods</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#subscripts">Subscripts</a></li>
        <li><a href="#nested-object-types">Nested Object Types</a></li>
      </ul>
    </li>
    <li><a href="#enums">Enums</a>
      <ul>
        <li><a href="#raw-values">Raw Values</a></li>
        <li><a href="#associated-values">Associated Values</a>
          <ul>
            <li><a href="#optional-1">Optional</a></li>
          </ul>
        </li>
        <li><a href="#inference-of-type-name-with-staticclass-members">Inference of Type Name with Static/Class Members</a></li>
        <li><a href="#enum-case-iteration">Enum Case Iteration</a></li>
        <li><a href="#enum-initializers">Enum Initializers</a></li>
        <li><a href="#enum-properties">Enum Properties</a></li>
        <li><a href="#enum-methods">Enum Methods</a></li>
      </ul>
    </li>
    <li><a href="#structs">structs</a>
      <ul>
        <li><a href="#struct-initializers">Struct Initializers</a></li>
        <li><a href="#struct-properties">Struct Properties</a></li>
        <li><a href="#struct-methods">Struct Methods</a></li>
        <li><a href="#constant-namespaces">Constant Namespaces</a></li>
      </ul>
    </li>
    <li><a href="#classes">Classes</a>
      <ul>
        <li><a href="#value-types-and-reference-types">Value Types and Reference Types</a>
          <ul>
            <li><a href="#mutating-captured-self">Mutating Captured Self</a></li>
            <li><a href="#class-instance-references-are-pointers">Class instance references are pointers</a></li>
            <li><a href="#advantages-of-value-types-vs-reference-types">Advantages of value types vs. reference types</a></li>
          </ul>
        </li>
        <li><a href="#subclass-and-superclass">subclass and superclass</a>
          <ul>
            <li><a href="#inheritance">Inheritance</a></li>
            <li><a href="#additional-functionality">Additional functionality</a></li>
            <li><a href="#overriding">Overriding</a></li>
            <li><a href="#the-keyword-super">The keyword super</a></li>
          </ul>
        </li>
        <li><a href="#class-initializers">class initializers</a>
          <ul>
            <li><a href="#kinds-of-class-initializer">Kinds of class initializer</a>
              <ul>
                <li><a href="#designated-initializer">Designated initializer</a></li>
                <li><a href="#convenience-initializer">Convenience initializer</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#class-deinitializer">class deinitializer</a></li>
        <li><a href="#class-properties">class properties</a></li>
        <li><a href="#staticclass-members">Static/Class Members</a></li>
        <li><a href="#多态">多态</a></li>
        <li><a href="#casting">Casting</a></li>
        <li><a href="#type-references">Type References</a></li>
        <li><a href="#comparing-types">Comparing Types</a></li>
        <li><a href="#available属性">available属性</a></li>
        <li><a href="#xcframework">xcframework</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
    </div>
</section>

  </div>
</aside>

      </div>
    </main>
   
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  <span itemprop="copyrightYear">  &copy; 
  2017 - 2023</span>
  <span class="with-love"><i class="fa fa-heart"></i></span>
  <span class="author" itemprop="copyrightHolder">Keep It Simple</span>
</div>




      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      <span id="scrollpercent"><span>0</span>%</span>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/jquery/index.js?v=2.1.3"></script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script> 
<script type="text/javascript" src="https://iihui.github.io/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/velocity/velocity.min.js?v=1.2.1"></script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="https://iihui.github.io/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>

<script src="https://iihui.github.io/js/vendor/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>

<script type="text/javascript" src="https://iihui.github.io/js/utils.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/motion.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/affix.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/schemes/pisces.js"></script>

<script type="text/javascript" src="https://iihui.github.io/js/scrollspy.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/post-details.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/toc.js"></script>

<script type="text/javascript" src="https://iihui.github.io/js/bootstrap.js"></script>

<script type="text/javascript" src="https://iihui.github.io/js/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
</body>
</html>