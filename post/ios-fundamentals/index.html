<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
    <title>iOS 14 编程基础 - Keep It Simple</title>
    <meta name="keywords" content="博客,思考,读书,笔记,技术,分享">
    
    <meta property="og:title" content="iOS 14 编程基础">
    <meta property="og:site_name" content="Keep It Simple">
    <meta property="og:image" content="/img/author.jpg"> 
    <meta name="title" content="iOS 14 编程基础 - Keep It Simple" />
    <meta name="description" content="Swift | Go | C&#43;&#43; "> 
    <link rel="shortcut icon" href="https://iihui.github.io/img/favicon.ico" />
    <link rel="apple-touch-icon" href="https://iihui.github.io/img/apple-touch-icon.png" />
    <link rel="apple-touch-icon-precomposed" href="https://iihui.github.io/img/apple-touch-icon.png" />
    <link href="https://iihui.github.io/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />
    <link href="https://iihui.github.io/js/vendor/fancybox/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />
    <link href="https://iihui.github.io/css/main.css" rel="stylesheet" type="text/css" />
    <link href="https://iihui.github.io/css/syntax.css" rel="stylesheet" type="text/css" />

    <script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
     fancybox: true, 
    motion: true
  };
</script>

    <link href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/monokai-sublime.min.css" rel="stylesheet">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/go.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/swift.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/objectivec.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/clojure.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/kotlin.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/yaml.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<div class="container one-collumn sidebar-position-left page-home  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-meta  custom-logo ">

  <div class="custom-logo-site-title">
    <a href="https://iihui.github.io/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Keep It Simple</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">靡不有初，鲜克有终</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
    <ul id="menu" class="menu">
      
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/tags/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-tag"></i> <br />标签
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/post/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/categories/%E7%BE%8E%E9%A3%9F/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-fire"></i> <br />美食
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/categories/%E5%90%8E%E6%9C%9F/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-edit"></i> <br />后期
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/categories/%E6%97%85%E8%A1%8C/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-leaf"></i> <br />旅行
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/about/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于
          </a>
        </li>
      
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger"> <i class="menu-item-icon fa fa-search fa-fw"></i> <br /> 搜索</a>
      </li>
    </ul>
    <div class="site-search">
      <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>

    </div>
</nav>
<script type="text/javascript"
        async
        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
		<!-- src = "http://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> <\!--  -\-> -->
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>

<!DOCTYPE html>
<html lang="en">


<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css" integrity="sha384-D+9gmBxUQogRLqvARvNLmA9hS2x//eK1FhVb9PiU86gmcrBrJAQT8okdJ4LMp2uv" crossorigin="anonymous">

    
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js" integrity="sha384-483A6DwYfKeDa0Q52fJmxFXkcPCFfnXMoXblOkJ4JcA8zATN6Tm78UNL72AKk+0O" crossorigin="anonymous"></script>
</head>
<body>

</body>
</html>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
<section id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="https://iihui.github.io/post/ios-fundamentals/" itemprop="url">
        iOS 14 编程基础
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">创建: </span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2021-08-28">
    2021-08-28
</time>
</span>
&nbsp; | &nbsp;
<span class="post-updated-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-check-o"></i>
</span>
<span class="post-meta-item-text">更新: </span>
<time itemprop="dateUpdated" content="2021-08-29">
    2021-08-29
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类: </span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="https://iihui.github.io/categories/ios" itemprop="url" rel="index">
        <span itemprop="name">iOS</span>
      </a>
      &nbsp; 
    </span>
  
</span>


      <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-file-word-o"></i>
</span>
<span class="post-meta-item-text">字数: </span>
<span class="leancloud-visitors-count">58153</span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-coffee"></i>
</span>
<span class="post-meta-item-text">阅读: </span>
<span class="leancloud-visitors-count">117 分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <h2 id="object">Object</h2>
<p>在<code>Swift</code>中，万物皆为对象，这是什么意思呢？这取决于所说的「对象」是什么，以及所说的「万物」是指什么。简单地说，对象就是可以向其发送消息的东西，而消息指的是一个命令式的指令。在<code>Swift</code>中，发送消息的语法是点表示法：<font color=red>以对象开始，然后紧跟一个点，最后紧跟消息</font>。</p>
<p>万物皆为对象是一种暗示：即使是「最原始的」语言实体也可以接收消息。例如，<code>1</code>在多数编程语言中仅仅是字面意义上的含义，而在<code>Swift</code>中可以按如下方式使用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#ae81ff">1.</span>description
</span></span></code></pre></div><p>从上面的代码可以看出，<code>1</code>确实是一个对象，因为它可以接收<code>description</code>这样的消息。在表达式<code>1+2</code>中，如同<code>1</code>是一个对象一样，<code>+</code>实际上是一个消息（运算符语法消息）。在<code>Swift</code>中，<font color=red>每个名词都是一个对象，而每个动词都是一个消息</font>。</p>
<p>在<code>Swift</code>中，<font color=Blue>检验一个东西是否为对象的最终标准是看能否修改它</font>。一个对象类型可以在<code>Swift</code>中被扩展，这意味着<font color=LightSeaGreen>可以在这个类型上定义自己的消息，即该对象类型是可以被修改的</font>。例如，通常不能向一个数字发送<code>sayHello</code>消息，但可以通过扩展来改变一个数字类型，使得可以向其实例发送<code>sayHello</code>消息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">extension</span> <span style="color:#a6e22e">Int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sayHello</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;Hello, I&#39;m </span><span style="color:#e6db74">\(</span><span style="color:#66d9ef">self</span><span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在<code>Swift</code>中，<code>1</code>是对象，在<code>Objective-C</code>中，它是<strong>标量内置类型</strong>。但在<code>Swift</code>中，<strong>不存在标量类型</strong>，<font color=red>所有类型最终都是对象类型</font>，<font color=Blue>这就是「万物皆为对象」的真正含义</font>。</p>
<p>在许多其它语言中，对象是类或者类的实例。在<code>Swift</code>中，也有类的概念，但字面量<code>1</code>既不是类，也不是类的实例。在<code>Swift</code>中，<font color=red>字面量<code>1</code>的类型是<code>Int</code>，它是一个结构体</font>。</p>
<p>在<code>Swift</code>中有三种对象类型，它们依次是<font color=LightSeaGreen>类，结构体以及枚举类型</font>。它们都是非常明确的对象类型，并且它们之间的相似性远大于差异性。实际上，在<code>Swift 5.5</code>中，还有第<code>4</code>种对象类型，那就是<code>actors</code>。</p>
<p>一个完整的<code>Swift</code>命令为一条语句，一般使用换行来分隔语句。一个<code>Swift</code>文件一般由多行文本组成，通常一行一条语句。如果想要一行包含多条语句，则需要使用分号分隔：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;hello&#34;</span>); print(<span style="color:#e6db74">&#34;world&#34;</span>)
</span></span></code></pre></div><p>如果一个语句太长，实际上是可以拆成多行的，但是拆分的位置尽量在合理的地方。如下代码所示，左括号是一个较好的位置：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>print(
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;world&#34;</span>)
</span></span></code></pre></div><p>在<code>Swift</code>编码习惯中，花括号后都是紧跟换行符，并且为了使代码更清晰，通常会进行缩进，<code>Xcode</code>中也会强化这种约定：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;woof&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>但实际上这只是一种编码惯例，<code>Swift</code>编译器并不在乎这些，像下面将代码写在一行也是合法的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> { <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() { print(<span style="color:#e6db74">&#34;woof&#34;</span>) }}
</span></span></code></pre></div><p><code>Swift</code>是一种编译语言，这意味着代码必须先编译，<font color=LightSeaGreen>通过编译器将语句转换为计算机可以理解的较低级别的形式，然后才能运行并实际执行这些代码所包含的意义</font>。</p>
<h2 id="variables">Variables</h2>
<p>变量是对象的名称，严格地说，<font color=red>变量指向一个对象，是这个对象的引用</font>。变量所指向的对象就是变量的值。非严格地说，变量就是一个存放对象的盒子，<font color=LightSeaGreen>这个对象可能会发生变化或盒子的对象可能被另一个对象取代，但盒子的名字不会发生变化</font>。</p>
<p>在<code>Swift</code>中，所有的变量都<font color=LightSeaGreen>必须先声明再使用</font>。变量声明通常伴随着初始化，即作为声明的一部分增加一个等号，并且立即给变量一个初始值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> two = <span style="color:#ae81ff">2</span>
</span></span></code></pre></div><p>用<code>let</code>声明的是一个常量，<font color=red>它的值只能分配一次（可以先声明后面再初始化一次，或者声明的同时初始化，但必须保证只赋值一次）</font>。一旦初始化后，如果试图再次改变<code>let</code>声明的常量的值，就会出现编译错误。</p>
<p>变量都有一个类型，这个类型是在变量声明时就确定了的，并且不能被更改。在下面的例子中，变量<code>two</code>声明时的类型是<code>Int</code>，因此不能使用<code>String</code>类型来覆盖它：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> two = <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>two = <span style="color:#e6db74">&#34;hello&#34;</span> <span style="color:#75715e">// 编译错误：Cannot assign value of type &#39;String&#39; to type &#39;Int&#39;</span>
</span></span></code></pre></div><h2 id="functions">Functions</h2>
<p>一般来说，<font color=red>可执行代码必须放在一个函数体内</font>。但有一个例外，在<code>main.swift</code>文件中，<font color=LightSeaGreen>可以在其顶层（在任何函数体之外）放置可执行代码</font>。</p>
<p>一个<font color=Blue>函数是一批可执行语句的集合</font>，可以作为一个批次来运行。函数体由大括号包围，通常一个函数有一个名字，通过函数声明获得这个名字:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sum</span>(a: Int, b: Int) -&gt; Int {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> a <span style="color:#f92672">+</span> b
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="文件结构">文件结构</h2>
<p>一个<code>Swift</code>程序可以由一个或多个文件组成。在<code>Swift</code>中，一个文件是一个有意义的单元，而且对于可以放在文件里的代码结构有明确的规定。通常来说，只有下面的东西可以放在文件的顶层：</p>
<ul>
<li>
<p>模块导入语句，例如：<code>import UIKit</code></p>
</li>
<li>
<p>全局变量和常量声明：文件顶层声明的变量，被称为全局变量，包括以<code>let</code>和<code>var</code>声明的变量:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> str = <span style="color:#e6db74">&#34;test&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> cons = <span style="color:#ae81ff">13</span>
</span></span></code></pre></div></li>
<li>
<p>全局函数声明：在文件顶层声明的函数为全局函数，默认情况下，同一个模块中的<font color=red>任何文件中的代码都可以看到并访问它</font>，而无需依赖任何对象。</p>
</li>
<li>
<p>对象类型声明：包括<code>class,struct,enum,protocol</code>等对象类型的声明。</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">import</span> <span style="color:#a6e22e">UIKit</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> one = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> constant = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">changeOne</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Manny</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Moe</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Jack</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在上面的例子中，花括号里的内容可以是<font color=LightSeaGreen>变量声明、函数声明和对象类型声明</font>。事实上，<font color=red>任何花括号里面都可以包含变量声明、函数声明和对象类型的声明</font>。</p>
<p>像<code>one = two</code>或<code>debugPrint(&quot;hello&quot;)</code>这样的语句是可执行语句，<font color=LightSeaGreen>一般不能放在文件的顶层，而是将其放在函数体中</font>（除了<code>main.swift</code>中的顶层可以有可执行语句）。在下面的代码中，<code>func changeOne()</code>是一个函数声明，可执行代码放在花括号中以形成函数体:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> one = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">changeOne</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> two = <span style="color:#ae81ff">2</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 可执行语句</span>
</span></span><span style="display:flex;"><span>    one = two 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>同样地，<strong>可执行代码不能直接放在类<code>Manny</code>声明的花括号内</strong>，<font color=LightSeaGreen>因为那是类声明的顶层，而不是函数体内</font>。但是一个类声明可以包含一个函数声明，并且该函数声明中可以包含可执行代码。</p>
<h2 id="scope-and-lifetime">Scope and Lifetime</h2>
<p>在<code>Swift</code>程序中，所有事物都有一个作用域。<font color=red>作用域指的是能够被其它事物看到的能力</font>。事物可以嵌套在其它事物内部，形成嵌套层次结构。作用域的可见规则：<font color=LightSeaGreen>事物可以看到它们自己所在的层次和包含它们的更高层次的事物</font>，这些层次依次是：</p>
<ul>
<li><code>module</code>：模块</li>
<li><code>file</code>：文件</li>
<li><code>{}</code>：花括号</li>
</ul>
<p>当某事物被声明时，它一定是在层次结构中的某个级别声明的。它在层次结构中的位置（它的范围）决定了是否可以被其它事物看到。作用域是<font color=red>共享信息的一种非常重要方式</font>，首先来看一下下面的代码段：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> one = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">changeOne</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> two = <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> 		<span style="color:#75715e">// 内部函数</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sayTwo</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(two)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Klass</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 内部类实现</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Struct</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 内部结构体实现</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Enum</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 内部枚举实现</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    one = two
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Manny</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> name = <span style="color:#e6db74">&#34;manny&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sayName</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(name)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Klass</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 内部类实现</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Struct</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 内部结构体实现</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Enum</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 内部枚举实现</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Moe</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> name = <span style="color:#e6db74">&#34;moe&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sayName</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(name)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Klass</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 内部类实现</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Struct</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 内部结构体实现</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Enum</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 内部枚举实现</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Jack</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name: String {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;jack&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sayName</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(name)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Klass</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 内部类实现</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Struct</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 内部结构体实现</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Enum</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 内部枚举实现</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在上面代码中，类<code>Manny</code>中声明的所有函数都可以看到<code>Manny</code>顶层声明的<code>name</code>。类<code>Manny</code>、<code>Jack</code>和<code>Moe</code>中的代码都能看到文件顶层声明的函数、变量和常量。</p>
<p>一个东西只要包含它的<code>scope</code>（范围）存在，那么这个东西就会存在。在上面的代码中，只要文件存在，变量<code>one</code>就存在———即只要程序运行，它就存在，因为它是全局的。但是在<code>Manny</code>顶层声明的实例变量只有在<code>Manny</code>实例存在时才会存在。</p>
<p>代码中的事物都有生命周期，实际上等同于它们的作用域。变量声明、函数声明和对象类型声明可以出现在任何的大括号中。一般来说，在<font color=red>更深层次声明的东西生命周期更短</font>，对于下面这段代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">silly</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">true</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Cat</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Cat实现...</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">var</span> one = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        one = one <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果函数<code>silly</code>被调用，执行路径就会进入到<code>if</code>结构中。在这里，类<code>Cat</code>被声明，然后变量<code>one</code>被声明并生成，接着可执行语句<code>one = one + 1</code>被执行，最后作用域结束，此时类<code>Cat</code>和变量<code>one</code>都会自动消失。在它们短暂的生命中，<font color=Blue>类<code>Cat</code>和变量<code>one</code>对于代码的其它部分是完全不可见的</font>。</p>
<h2 id="object-members">Object Members</h2>
<p>在对象类型（类，结构体和枚举）的声明中，<font color=LightSeaGreen>顶层声明的常量和变量被称为属性，顶层声明的函数叫做方法</font>。在一个对象类型声明时，<font color=Blue>顶层声明的属性和方法以及任何在顶层声明的对象统称对象成员</font>。对象成员具有特殊的意义，因为它定义了可以向该对象发送的消息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Manny</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> name = <span style="color:#e6db74">&#34;manny&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sayName</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(name)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Klass</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Struct</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Enum</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="namespaces">Namespaces</h2>
<p>命名空间是指程序的一个命名区域。对于命名空间外的事物，如果想访问命名空间内的事物，<font color=Blue>如果不先使用该命名区域的名字，以破除该区域的障碍，就不能被在它以外的事物所访问</font>。这是一件好事，因为<font color=red>这样允许相同名字的事物在不同的地方使用而不发生冲突</font>。显然，命名空间和作用域是密切相关的概念。</p>
<p>命名空间有助于解释在一个对象的顶层声明内嵌另一个对象声明的意义。下面的代码在<code>Manny</code>以内嵌的方式声明了<code>Klass</code>，它有效地将<code>Klass</code>隐藏在<code>Manny</code>里面：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Manny</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> name = <span style="color:#e6db74">&#34;manny&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sayName</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// print name</span>
</span></span><span style="display:flex;"><span>        debugPrint(name)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Klass</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 内部类实现</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Struct</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 内部结构体实现</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Enum</span> {
</span></span><span style="display:flex;"><span>       <span style="color:#75715e">// 内部枚举实现</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在上面的代码中，类<code>Manny</code>是一个命名空间，类<code>Klass</code>声明在其中，在类<code>Manny</code>内部的代码可以直接看到类<code>Klass</code>，但在<code>Manny</code>之外的代码不能直接看到类<code>Klass</code>。</p>
<p>如果想要看到在<code>Manny</code>内部声明的<code>Klass</code>，必须明确地使用命名空间的名字，以解除命名空间所代表的障碍。要做到这一点，需要先使用<code>Manny</code>的名字（它代表命名空间），然后是一个点，最后是<code>Klass</code>。简而言之，现在必须使用<code>Manny.Klass</code>来访问类<code>Manny</code>内部声明的<code>Klass</code>类：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Manny</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> name = <span style="color:#e6db74">&#34;manny&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sayName</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(name)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Klass</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test</span>() {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Struct</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 内部结构体实现</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Enum</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 内部枚举实现</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Moe</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> name = <span style="color:#e6db74">&#34;moe&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sayName</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(name)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Klass</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test</span>() {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 使用命名空间来访问Klass</span>
</span></span><span style="display:flex;"><span>            Manny.Klass().test() 
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Struct</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 内部结构体实现</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Enum</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 内部枚举实现</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>命名空间<font color=LightSeaGreen>本身不提供秘密和隐私，它只提供一种便利性</font>。在上面的代码中，类<code>Manny</code>中定义了一个<code>Klass</code>类，同时在结构体<code>Moe</code>中也定义了一个<code>Klass</code>类。但它们并不冲突，因为它们是<font color=LightSeaGreen>定义在不同的命名空间中的</font>，如果有必要，可以使用<code>Manny.Klass</code>和<code>Moe.Klass</code>来进行区分。</p>
<p>默认情况下，类<code>Moe</code>里面的代码<font color=Blue>不能直接</font>看到<code>Manny</code>里面声明的<code>Klass</code>，但可以通过一个简单的步骤看到它，即<code>Manny.Klass</code>。这是因为<code>Moe</code>里的代码能看到类<code>Manny</code>，因为<code>Manny</code>是在<code>Moe</code><font color=LightSeaGreen>内部代码能看到的层次上声明的</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Klass</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test</span>() {
</span></span><span style="display:flex;"><span>        Manny.Klass().test()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="modules">Modules</h2>
<p>顶层的命名空间是<code>module</code>（模块）。<code>App</code>是一个<code>module</code>，因此也是一个命名空间，该命名空间的名称<font color=LightSeaGreen>默认为应用程序的名字</font>。若应用程序的名称为<code>MyApp</code>，并且在文件顶层声明一个类<code>Manny</code>，这个类的真实名字是<code>MyApp.Manny</code>。但通常不需要使用这个带前缀的真实名字，因为应用程序中的代码<font color=Blue>已经在同一个命名空间内，可以直接看到类</font><code>Manny</code>。</p>
<p>在当前文件中导入一个模块后，<font color=red>该模块内的所有顶层声明对于当前文件的代码都是可见的</font>，因此不必显式地使用模块的名字来引用。例如，<code>Cocoa</code>的<code>Foundation</code>框架是一个<code>module</code>，<code>NSString</code>是在<code>Foundation</code>顶层声明的。因此，当在代码中<code>import Foundation</code>后，可以直接使用<code>NSString</code>而不必使用<code>Foundation.NSString</code>这样带命名空间的真实名字。</p>
<p>实际上<code>Swift</code>本身也是在一个模块中定义的，即<code>Swift module</code>。但我们不必手动导入它，因为编译器总是<font color=red>隐含地导入</font>了<code>Swift module</code>。也可以在文件中加入<code>import Swift</code>来显式地导入，但没必要这样做，因为编译器会提示<code>module swift is already imported</code>。</p>
<p>上面这个事实非常重要，因为它解释了一个重要的谜题：像<code>debugPrint</code>和<code>print</code>这样的函数到底是从哪里来的，为什么在任何地方都可以使用它们。<code>debugPrint</code>和<code>print</code>实际上是在<code>Swift module</code>顶层声明的一个函数，因为编译器已经隐含地导入了<code>Swift</code>模块，所以我们的代码可以直接看到<code>Swift module</code>所有的顶层声明，当然也包括<code>debugPrint</code>和<code>print</code>。</p>
<p>因此，<code>debugPrint</code>函数如同当前文件的其它顶层函数一样，也<font color=Blue>变成了一个普通的顶层函数</font>，它对我们的代码来说是全局的。因此，可以直接使用它而不需要指定命名空间，也可以在使用的时候明确指定它的命名空间，即使用<code>Swift.debugPrint(&quot;hello&quot;)</code>，但通常不这样做，因为这样很冗余。</p>
<p>但是，你自己应用程序模块会掩盖导入的任何其它模块。也就是说，如果声明一个与导入模块中同名的东西，就<font color=red>会失去直接使用导入的东西而不用指定命名空间的神奇能力</font>。假如在代码中声明一个同名的<code>debugPrint</code>函数，那么编译器将会自动隐藏<code>Swift module</code>中的<code>debugPrint</code>函数，即自定义代码中声明的<code>debugPrint</code>函数<font color=red>具有更高的优先级</font>，为了调用<code>Swift</code>的<code>debugPrint</code>函数，现在<font color=LightSeaGreen>必须明确地使用有命名空间</font>，即<code>Swift.debugPrint</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>Swift.debugPrint(<span style="color:#e6db74">&#34;test&#34;</span>)
</span></span></code></pre></div><h2 id="instances">Instances</h2>
<p>对象类型（类、结构和枚举）有一个重要的共同特点：它们可以被实例化。实际上，声明一个对象类型时，只是定义了一个类型，实例化是为了生成该类型的实例。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;woof&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面的代码只是声明了<code>Dog</code>类型，即描述了如果有一只狗，它应该是什么样的，实际上还没有任何<code>Dog</code>对象。为了得到一个真正的<code>Dog</code>，必须制造一只，而制造一只真正的<code>Dog</code>对象过程就是实例化<code>Dog</code>的过程。</p>
<p>在<code>Swift</code>中，实例的生成可以通过<font color=red>使用对象类型的名称作为函数名并调用该函数来实现（被称为初始化器）</font>。当在一个对象类型的名称上加上圆括号时，就是在<font color=Blue>向该对象类型发送一种非常特殊的信息———实例化你自己（生成一个该类型的实例）</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> fido = Dog()
</span></span></code></pre></div><p>上面这段代码做了两件事，首先是实例化了<code>Dog</code>，得到了一个<code>Dog</code>实例。同时还把这个实例放到了一个名叫<code>fido</code>的盒子中（声明了一个变量，并通过把<code>Dog</code>的实例分配给它来初始化这个变量，现在<code>fido</code>是一个<code>Dog</code>的实例）。</p>
<p>现在有一个<code>Dog</code>的实例，可以向它发送<code>instance messages</code>（实例消息），实例消息包括<font color=LightSeaGreen>实例属性和方法</font>。<font color=red>在对象类型的声明中，属性和方法默认都是实例属性和方法，不能把它们作为该对象类型的消息来使用</font>。如果想要发送实例消息，就必须先生成一个实例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> fido = Dog()
</span></span><span style="display:flex;"><span>fido.bark()
</span></span></code></pre></div><p>如果想要发送类型消息，则需要声明为<code>static</code>或<code>class</code>函数，或者声明<code>static</code>或<code>class</code>属性。下面代码中声明了<code>static</code>和<code>class</code>属性和方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Test</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// static属性</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">var</span> test = <span style="color:#e6db74">&#34;test&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// class属性，不能为存储属性</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">var</span> name: String {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;name&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// static方法</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">testFunc</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// class 方法</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">func</span> nameFunc() {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在上面代码中用<code>class</code>声明<code>name</code>属性时<font color=red>只能为计算属性，不能声明为存储属性</font>，否则会出现报错：<code>Class stored properties not supported in classes; did you mean 'static'?</code>。</p>
<p>即使没有实例这样的东西，<font color=LightSeaGreen>对象类型本身也是一个对象</font>，因为可以向对象类型发送消息（<code>Manny.Klass</code>就是一个很好的例子）。为什么会需要实例呢？这主要与实例属性的性质有关，<font color=LightSeaGreen>实例属性的值是针对特定实例定义的</font>，这就是实例真正有用和强大的地方。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name = <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;woof&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>对于上面的声明，我们可以生成多个<code>Dog</code>实例，每一个<code>Dog</code>实例都有自己的<code>name</code>值。但多个实例的行为是相似的，它们都可以调用<code>bark</code>方法。</p>
<img src="https://s2.loli.net/2022/01/09/ocSZHNe2lYI6bWD.png" alt="ocSZHNe2lYI6bWD" style="zoom:80%;" />
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> dog1 = Dog()
</span></span><span style="display:flex;"><span>dog1.name = <span style="color:#e6db74">&#34;Fido&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> dog2 = Dog()
</span></span><span style="display:flex;"><span>dog2.name = <span style="color:#e6db74">&#34;Rover&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(dog1.name) <span style="color:#75715e">// &#34;Fido&#34;</span>
</span></span><span style="display:flex;"><span>print(dog2.name) <span style="color:#75715e">// &#34;Rover&#34; </span>
</span></span><span style="display:flex;"><span>dog2 = dog1
</span></span><span style="display:flex;"><span>print(dog2.name) <span style="color:#75715e">// &#34;Fido&#34;</span>
</span></span></code></pre></div><p>一个实例<font color=LightSeaGreen>不仅对其属性的值负责，而且对其属性的生命周期负责</font>。假设创建了一个<code>Dog</code>实例，并为它的<code>name</code>属性赋值为<code>Fido</code>。只要不将属性<code>name</code>的值替换为其它值，并且此实例一直存在，这个实例就会使字符串<code>Fido</code>保持活跃状态。</p>
<p>也就是说一个<font color=red>实例既是代码又是数据</font>。实例的代码指的是它的类型声明，与该类型的所有实例共享。但数据只属于实例，只要实例持续存在，数据就可以持续存在，<font color=red>实例在每个时刻都有一个状态，即实例属性值完整集合</font>。</p>
<p>一个类的声明实际上定义了一个命名空间。这个命名空间<font color=Blue>要求其它对象使用额外的点标记来引用该空间内的内容</font>。<font color=red>命名空间本身并没有关闭任何可见性的大门，但访问权限<code>private</code>关键字可以。</font></p>
<h2 id="the-keyword-self">The Keyword self</h2>
<p>一个实例是一个对象，而对象是消息的接收者。因此，一个实例需要一种向自己发送消息的方法，这通过使用关键字<code>self</code>来实现。<code>self</code>关键字可以用在预期有适当类型实例的地方：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name = <span style="color:#e6db74">&#34;name&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> whatADogSays = <span style="color:#e6db74">&#34;woof&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#66d9ef">self</span>.whatADogSays)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">speak</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.bark()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面代码中<code>self</code>仅出现在实例方法中，当在一个实例的代码中使用<code>self</code>时，它指的是当前这个实例。如果表达式<code>self.name</code>出现在<code>Dog</code>实例方法中，它意味着当前这个<code>Dog</code>实例的<code>name</code>，也就是<font color=red>此时代码正在运行的那个</font>。</p>
<p>在实例方法中使用<code>self</code>是可选的，即是可以省略的。如果省略了信息接收者，要发送的信息又可以发送给<code>self</code>，那么<font color=Blue>编译器默认会把<code>self</code>作为信息的接收者</font>。</p>
<p>作为一个编码风格问题，明确地使用<code>self</code>或许是一个好习惯，因为省略<code>self</code>的代码更难阅读和理解。而且在有些情况下，必须显式使用<code>self</code>。</p>
<h2 id="privacy">Privacy</h2>
<p>命名空间<font color=red>本身并未关闭任何可见性的大门，但这种可见性屏障有时是需要的</font>。因为并非所有由实例存储的数据都是为了被另一个实例改变，甚至有时要求对其它实例是不可见的。</p>
<p>也不是每个实例的方法都想要被其它实例调用。基于对象的编程语言通常都需要一种方法来赋予其对象成员以隐私&ndash;<font color=red>一种使其他对象更难看到这些成员的方法</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name = <span style="color:#e6db74">&#34;name&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> whatADogSays = <span style="color:#e6db74">&#34;woof&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#66d9ef">self</span>.whatADogSays)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">speak</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#66d9ef">self</span>.whatADogSays)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在上面的声明中，其它对象都可以更改实例属性<code>whatADogSays</code>。并且<code>bark</code>和<code>speak</code>方法都使用该属性，一旦改变属性<code>whatADogSays</code>的值，则<code>bark</code>和<code>speak</code>使用的值也会跟着变化。为了避免<code>whatADogSays</code>被随意更改，可以将其用<code>private</code>限定只能方法能够修改，不能被实例直接修改。</p>
<p>一个类声明定义了一个命名空间。这个命名空间要求其他对象使用额外的点符号来引用命名空间内的内容，命名空间本身并不会关闭任何可见性之门。<font color=LightSeaGreen><code>private</code>关键字可以关闭这些可见性大门</font>。</p>
<p>在上面的代码中，其它的实例也能够访问和修改属性<code>whatADogSays</code>。因为方法<code>bark</code>和<code>speak</code>都访问属性<code>whatADogSays</code>，因此很容易得到一个<code>Dog</code>，当它被告知要<code>bark</code>时，它说<code>meow</code>，这似乎有点不可取：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> fido = Dog()
</span></span><span style="display:flex;"><span>fido.whatADogSays = <span style="color:#e6db74">&#34;meow&#34;</span>
</span></span><span style="display:flex;"><span>fido.bark() <span style="color:#75715e">// meow</span>
</span></span></code></pre></div><p>此时，我们可能想到把属性<code>whatADogSays</code>声明为常量，这样就没人可以修改它了。但这个带来了两个问题，假设想要<code>Dog</code>实例本身可以修改属性<code>whatADogSays</code>，此时需要将其声明为<code>var</code>，否则连实例本身也不能修改。</p>
<p>另外，假设不希望任何其他对象知道这只<code>Dog</code>在说什么，除非通过调用<code>bark</code>和<code>speak</code>。即使使用<code>let</code>声明，其他对象仍然可以读取<code>whatADogSays</code>的值。为了解决这个问题，<code>Swift</code>提供了<code>private</code>关键字：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name = <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> whatADogSays = <span style="color:#e6db74">&#34;woof&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        print(<span style="color:#66d9ef">self</span>.whatADogSays)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">speak</span>() {
</span></span><span style="display:flex;"><span>        print(<span style="color:#66d9ef">self</span>.whatADogSays)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>现在<code>whatADogSays</code>是私有属性，它不能被其他类型的对象看到。<code>Dog</code>实例可以访问<code>whatADogSays</code>，但<code>Cat</code>实例中使用<code>Dog</code>实例时，不能访问属性<code>whatADogSays</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Cat</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">tryToChangeWhatADogSays</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> fido = Dog()
</span></span><span style="display:flex;"><span>        fido.whatADogSays = <span style="color:#e6db74">&#34;meow&#34;</span> <span style="color:#75715e">// compile error </span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="reserved-words">Reserved Words</h2>
<p>某些术语，如<code>class</code>和<code>func</code>和<code>var</code>和<code>let</code>和<code>if</code>以及<code>private</code>和<code>import</code>，在<code>Swift</code>中是保留的关键字。这意味着不能将它们用作标识符———例如类、函数或变量的名称。如果你尝试这样做，会得到一个编译错误。要强制将保留字成为标识符，请用反引号(`)将其括起来。下面这个非常混乱的代码是合法的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> `<span style="color:#66d9ef">func</span>` {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> `<span style="color:#66d9ef">if</span>`() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> `<span style="color:#66d9ef">class</span>` = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>实例不是凭空产生的，必须实例化一个类型才能获得一个实例。我们程序的大部分操作将包括实例化类型。当然，你会希望这些实例持续存在，因此还将每个新创建的实例分配给一个变量，以保存它、命名它并赋予它生命周期。该实例将根据引用它的变量的生命周期持续存在，在变量的作用域内该实例对其它实例可见性。</p>
<h1 id="functions-1">functions</h1>
<p>没有什么比声明和调用函数更能说明<code>Swift</code>的语法特点了。下面是一个简单有效的函数声明，它期望有两个<code>Int</code>入参值，然后把它们加在一起产生它们的和：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sum</span>(<span style="color:#66d9ef">_</span> x: Int, <span style="color:#66d9ef">_</span> y: Int) -&gt; Int {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> result = x <span style="color:#f92672">+</span> y
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> result
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>函数声明的语法是非常严格和明确的，除非你完全理解它，否则也就无法使用<code>Swift</code>。把第一行拆分成几个部分，这样就可以单独地标记它们：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sum</span>                     <span style="color:#960050;background-color:#1e0010">①</span>
</span></span><span style="display:flex;"><span>     (<span style="color:#66d9ef">_</span> x:Int, <span style="color:#66d9ef">_</span> y:Int)      <span style="color:#960050;background-color:#1e0010">②③</span>
</span></span><span style="display:flex;"><span>      -&gt; Int {               <span style="color:#960050;background-color:#1e0010">④⑤</span>
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">let</span> result = x <span style="color:#f92672">+</span> y <span style="color:#960050;background-color:#1e0010">⑥</span>
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">return</span> result      <span style="color:#960050;background-color:#1e0010">⑦</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol>
<li>
<p>函数定义以关键字<code>func</code>开始，后面跟着函数名，上面代码中函数名是<code>sum</code>。<font color=Blue>函数名是函数调用必须使用的名称</font>，即为了运行函数中所包含的代码必须使用函数名。</p>
</li>
<li>
<p>函数名后面紧跟着参数列表，<font color=LightSeaGreen>参数列表至少由一对圆括号组成</font>。如果定义的函数需要参数，它们用逗号隔开列在圆括号内。每个参数都有严格的格式：<code>外部参数名，空格，内部参数名，冒号，参数类型</code>。</p>
</li>
<li>
<p>上面的函数在参数名前有一个下划线和空格，下划线表示调用该函数时可以省略外部参数名。</p>
</li>
<li>
<p>如果函数有返回值，在圆括号后面紧跟的将会是箭头运算符<code>-&gt;</code>，在其后跟着的是函数返回类型。</p>
</li>
<li>
<p>用花括号把函数体（实际的可执行代码）括起来。</p>
</li>
<li>
<p>在花括号里面，参数已经生效，其类型在参数列表中已经被指定。</p>
</li>
<li>
<p>如果函数要返回一个值，它需要在函数体中使用关键字<code>return</code>，其后紧跟着返回值。该值的类型必须与先前在函数声明时的返回值类型相匹配。</p>
</li>
</ol>
<h2 id="参数">参数</h2>
<p>上面定义的<code>sum</code>函数有两个参数：第一个是<code>Int</code>类型，名字是<code>x</code>，第二个也是<code>Int</code>类型，名字为<code>y</code>。事实上，参数<code>x</code>和<code>y</code>的定义只是为了让参数值在函数体中使用。</p>
<p>函数体中的代码不会运行，除非其他地方的代码调用此函数并其参数传递指定类型的值。如果调用这个函数的时候没有传递参数，或者提供的任何一个值都不是<code>Int</code>，编译器将阻止并显示错误。</p>
<p>参数声明的意思大概是：我们正在声明<code>x</code>和<code>y</code>，以便在函数中使用它们。<font color=red>这些变量是函数的局部变量（或称为内部变量），只有在当前函数体中才可以看到它们</font>，函数外便无法再使用，它们与可能在其他函数或更高层次范围内使用的任何其他<code>x</code>和<code>y</code>均不同。</p>
<h2 id="返回值">返回值</h2>
<p>在函数体中的关键字<code>return</code>其实做了两件事，<font color=LightSeaGreen>首先是返回其后跟着的值，其次是结束当前函数的执行</font>。虽然<code>return</code>语句之后可以包含其它代码，但这些代码不会被执行，并且会产生编译警告。</p>
<p>在<code>Swift 5.1</code>前，在有返回值的函数体中<font color=red>即使只有一条语句也必须显式使用<code>return</code>语句。但从<code>Swift 5.1</code>开始，有返回值的函数体中只有一条语句时可以省略<code>return</code>关键字</font>，这个特性主要是方便<code>SwiftUI</code>。</p>
<p>在<font color=red>函数声明花括号前的那一部分可以看成是一种契约，即约定当前函数的输入和输出是怎么样的</font>。根据这个契约，该函数期望有一定数量的入参，每个参数都有特定的类型，并产生一定类型的结果。因此，在函数调用时必须遵守这个契约。</p>
<p>花括号内的函数体将函数参数作为局部变量使用，关键字<code>return</code>后面的返回值类型必须与函数声明时的返回类型一致，否则会出现编译错误。</p>
<p>如果想要忽略函数的返回值，可以将函数调用的返回值分配给<code>_</code>（没有名称的变量）来消除编译器警告。例如，上面的sum调用可以如下使用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">_</span> = sum(<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">5</span>)
</span></span></code></pre></div><p>或者，如果被调用的函数是你自己的，可以通过使用<code>@discardableResult</code>标记函数声明来防止警告：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>@discardableResult  <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sum</span>(<span style="color:#66d9ef">_</span> x: Int, <span style="color:#66d9ef">_</span> y: Int) -&gt; Int {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> result = x <span style="color:#f92672">+</span> y
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> result
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="空返回值和参数">空返回值和参数</h2>
<p>函数定义时<font color=LightSeaGreen>没有规定一定需要返回值</font>，如果一个函数定义时没有返回值，下面<code>3</code>种写法都是可行的，但是<font color=red>推荐使用第三种写法，即去掉<code>Void</code>或者<code>()</code></font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">say1</span>(<span style="color:#66d9ef">_</span> s: String) -&gt; Void {
</span></span><span style="display:flex;"><span>    debugPrint(s)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">say2</span>(<span style="color:#66d9ef">_</span> s: String) -&gt; () {
</span></span><span style="display:flex;"><span>    debugPrint(s)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">say3</span>(<span style="color:#66d9ef">_</span> s: String) {
</span></span><span style="display:flex;"><span>    debugPrint(s)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>若一个函数没有返回值，那么它的函数体中就不需要包含<code>return</code>语句。如果包含了<code>return</code>语句，那么它只能由<code>return</code>这个词单独组成，其目的<font color=Blue>纯粹是在当前位置上结束函数的执行</font>。</p>
<p>函数定义时也没有规定一定需要参数。<font color=LightSeaGreen>如果函数没有参数则参数列表为空，但此时也不能省略参数列表括号并且在函数调用时也不能省略括号</font>（实际上<font color=Blue>有一种特殊情况可以省略函数调用时的圆括号</font>）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">greet</span>() -&gt; String {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;howdy&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>因此，函数声明的时候可以同时没有参数和返回值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">greet1</span>() -&gt; Void {
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;howdy&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">greet2</span>() -&gt; () {
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;howdy&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">greet3</span>() {
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;howdy&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="函数签名">函数签名</h2>
<p>如果函数声明的时候忽略外部参数名和内部参数名，<font color=red>可以通过输入和输出类型来完全描述一个函数的特征</font>。为此，把参数类型写在参数列表括号里，后面是箭头运算符和输出类型，像下面这样：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>(Int, Int) -&gt; Int
</span></span></code></pre></div><p>上面是一个合法的表达式，表示接收两个<code>Int</code>类型参数并返回一个<code>Int</code>类型函数的签名。这个签名描述了<font color=Blue>所有具有这种顺序和数量的参数、类型、并返回这种类型的结果的函数</font>。<font color=LightSeaGreen>一个函数的签名实际上就是它的类型&mdash;函数的类型</font>。</p>
<p>一个函数的签名必须包括参数列表（不带参数名，只有参数类型）和返回类型，其中的参数列表和返回值都可以为空。一个不带参数和没有返回值的函数签名可以写成<code>()-&gt; Void</code>或<code>()-&gt;()</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">newTest</span>(completion: @escaping () -&gt; ()) {
</span></span><span style="display:flex;"><span>    completion()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">newTest2</span>(completion: @escaping () -&gt; Void) {
</span></span><span style="display:flex;"><span>    completion()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="外部参数名">外部参数名</h2>
<p>一个函数可以<font color=red>外化其参数名称，在调用函数的时候使用这个参数名称，这个名称被称为外部参数名或外部参数标签</font>。<font color=Blue>外部参数名称也是函数名称的一部分</font>，并且必须作为参数的标签出现在对该函数的调用中。外部参数标签有如下作用：</p>
<ul>
<li>
<p>它阐明了每个参数的目的，<font color=Blue>一个参数标签（外部参数）可以提供一个线索，说明该参数如何影响该函数</font>。</p>
</li>
<li>
<p>它将一个函数与另一个函数区分开来：<font color=red>两个在圆括号前具有相同名称和相同签名的函数，但具有不同的外部参数名称，是两个不同的函数</font>「这个有待考证😂」。</p>
</li>
<li>
<p>外部参数标签有助于<code>Swift</code>与<code>Objective-C</code>和<code>Cocoa</code>对接，在这两个地方，方法的参数几乎都有外部名称。</p>
</li>
</ul>
<p>外部参数名在<code>Swift</code>中非常常见，以至于有一条规则：<font color=Blue>默认情况下，所有参数名都会自动外部化，即使用内部名称作为其外部名称</font>。如果想改变这种默认行为，有两种方式：</p>
<ul>
<li>
<p>如果想要参数的外部名称和内部名称不同，需要<font color=LightSeaGreen>在内部名称前加一个外部名称并以空格分隔开</font>，调用的时候就可以使用此外部参数名。</p>
</li>
<li>
<p>如果需要去除一个参数的外部名称，则需要<font color=LightSeaGreen>在内部名称前加上下划线和一个空格</font>，此表示不使用外部参数，调用该函数时可以省略该参数名。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">echoString</span>(<span style="color:#66d9ef">_</span> s: String, times: Int) -&gt; String {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> result = <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">_</span> <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1.</span>..times {
</span></span><span style="display:flex;"><span>        result <span style="color:#f92672">+=</span> s
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> result
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面的函数中，第一个参数只有内部名称，第二个参数既有内部名称也有外部名称，并且他们的名称相同，即<code>times</code>。</p>
</li>
</ul>
<p>外部名称的存在<font color=red>并不意味着调用可以使用与声明不同的参数顺序</font>。下面的<code>echo(string:times:)</code>需要一个<code>String</code>参数和一个<code>Int</code>参数，必须按此顺序调用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">echo</span>(string s: String, times n: Int) -&gt; String {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> result = <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">_</span> <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1.</span>..n {
</span></span><span style="display:flex;"><span>        result <span style="color:#f92672">+=</span> s
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> result
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="函数重载">函数重载</h2>
<p>在<code>Swift</code>中函数重载是合法的，这意味着两个函数具有相同的名字（<font color=Blue>包括相同的外部参数名称</font>），但有着不同的函数签名是可以共存的。需要注意的是，<font color=red>两个基本名称（函数名）相同但外部参数名称不同的函数并不构成重载，它们是两个名称不同的函数</font>「有些地方说这也是一种重载，个人看来也是合理的」。</p>
<p>重载之所以有效是因为<code>Swift</code>进行严格的类型区分。<code>Swift</code>可以在函数声明和函数调用时把重载函数区分出来。因此，<code>Swift</code>清楚地知道<code>say(&quot;what&quot;)</code>和<code>say(1)</code>是不同的。</p>
<p>需要注意的是<font color=red>重载也适用于函数的返回类型</font>。两个具有相同名称和参数的函数可以有不同的返回类型。但调用时的上下文必须明确，即<font color=red>必须清楚调用者期望的返回类型</font>，否则编译器会报错。下面两个重载函数是可以并存的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">say</span>() -&gt; String {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;one&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">say</span>() -&gt; Int {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果在调用的时候直接使用<code>let result = say()</code>会发生编译错误，因为编译器还不知道要调用哪个函数。因此，<font color=LightSeaGreen>如果有返回类型重载的函数调用时必须明确指定返回类型</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> result: String = say()
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> test: Int = say()
</span></span></code></pre></div><p>上下文本身可能会消除歧义。假设有另一个没有重载的函数，它需要一个字符串参数，那么就可以直接使用<code>giveMeAString(say())</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">giveMeAString</span>(<span style="color:#66d9ef">_</span> s: String) {
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;thanks!&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>giveMeAString(say())
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> result = say() <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;two&#34;</span>
</span></span></code></pre></div><p>在<code>say() + &quot;two&quot;</code>中，因为只有字符串才能和字符串添加，所以此时<code>say()</code>只能返回字符串。也可以在函数调用时使用方法名和关键字<code>as</code>以及所需方法的签名来明确区分重载。这个语法看起来有点奇怪，因为<font color=red>整个表达式必须用两对圆括号括起来，其中第一对圆括号表示类型转换，最后的一对圆括号表明这是一个函数调用</font>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> result = (say <span style="color:#66d9ef">as</span> () -&gt; String)()
</span></span></code></pre></div><h2 id="默认值">默认值</h2>
<p>参数可以有默认值（缺省值），这意味着对于<font color=red>有默认值的参数调用者可以完全省略该参数，不提供任何值</font>。如果有默认值的参数在调用时省略该参数，表示使用默认值。如果要在函数声明中指定一个缺省值，只需在参数类型后面追加上<code>=和缺省值</code>即可：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">say</span>(<span style="color:#66d9ef">_</span> s: String, times: Int = <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">_</span> <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1</span> ... times {
</span></span><span style="display:flex;"><span>            debugPrint(s)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>实际上，上面的<code>say</code>相当于两个函数。其中一个只有一个未标记的参数<code>func say(_ s: String)</code>，并且在函数体中<code>times=1</code>；另一个既有未标记的参数也有一个<code>times</code>参数<code>func say(_ s: String, times: Int)</code>。</p>
<h2 id="可变参数">可变参数</h2>
<p>在函数中同类型的参数个数可以是可变的，即调用者可以根据需要提供<font color=LightSeaGreen>该参数类型的多个值，用逗号隔开</font>。实际上，<font color=red>函数体将以数组形式接收这些值</font>。要在函数声明中表明一个参数是可变的，只需要在类型后面加上三个点：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sayStrings</span>(<span style="color:#66d9ef">_</span> arrayOfStrings: String ...) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> s <span style="color:#66d9ef">in</span> arrayOfStrings {
</span></span><span style="display:flex;"><span>        debugPrint(s)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>sayStrings(<span style="color:#e6db74">&#34;34&#34;</span>,<span style="color:#e6db74">&#34;456&#34;</span>,<span style="color:#e6db74">&#34;678&#34;</span>,<span style="color:#e6db74">&#34;9899&#34;</span>)
</span></span></code></pre></div><p>其它参数可以可以跟在可变参数后面，但它必须有一个外部标签来标识可变参数在调用中的结束位置。全局的<code>print</code>和<code>debugPrint</code>函数第一个参数实际上是可变的，所以可以一次打印多个值。<code>debugPrint</code>函数中还有一些默认参数，这些参数确定了输出的细节：默认的分隔符(输出多个值时的分隔符号)是一个空格，默认的终止符是一个换行符，可以在调用的时候改变其中之一或全部：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">print</span>(<span style="color:#66d9ef">_</span> items: Any..., separator: String = <span style="color:#e6db74">&#34; &#34;</span>, terminator: String = <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">debugPrint</span>(<span style="color:#66d9ef">_</span> items: Any..., separator: String = <span style="color:#e6db74">&#34; &#34;</span>, terminator: String = <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>)
</span></span></code></pre></div><p>在<code>Swift 5.3</code>之前，一个函数至多可以声明一个可变参数，但从<code>Swift 5.4</code>开始这个限制被移除了。一个函数<font color=red>可以有多个可变参数</font>，下面的<code>testVariadicParameters</code>有<code>4</code>个可变参数。因为每个可变参数在函数内部都以数组的形式接受的，所以打印出来的是数组形式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">testVariadicParameters</span>(first: String..., second: String..., third: Int..., forth: [String]...) {
</span></span><span style="display:flex;"><span>    debugPrint(first)
</span></span><span style="display:flex;"><span>    debugPrint(second)
</span></span><span style="display:flex;"><span>    debugPrint(third)
</span></span><span style="display:flex;"><span>    debugPrint(forth)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>testVariadicParameters(first: <span style="color:#e6db74">&#34;1&#34;</span>, <span style="color:#e6db74">&#34;2&#34;</span>, <span style="color:#e6db74">&#34;3&#34;</span>, second: <span style="color:#e6db74">&#34;name&#34;</span>, <span style="color:#e6db74">&#34;This&#34;</span>, <span style="color:#e6db74">&#34;true&#34;</span>, third: <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">45</span>, <span style="color:#ae81ff">89</span>, forth: [<span style="color:#e6db74">&#34;TT&#34;</span>], [<span style="color:#e6db74">&#34;KK&#34;</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>[<span style="color:#e6db74">&#34;1&#34;</span>, <span style="color:#e6db74">&#34;2&#34;</span>, <span style="color:#e6db74">&#34;3&#34;</span>]
</span></span><span style="display:flex;"><span>[<span style="color:#e6db74">&#34;name&#34;</span>, <span style="color:#e6db74">&#34;This&#34;</span>, <span style="color:#e6db74">&#34;true&#34;</span>]
</span></span><span style="display:flex;"><span>[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">45</span>, <span style="color:#ae81ff">89</span>]
</span></span><span style="display:flex;"><span>[[<span style="color:#e6db74">&#34;TT&#34;</span>], [<span style="color:#e6db74">&#34;KK&#34;</span>]]
</span></span></code></pre></div><p>如果第2个可变参数没有和第一个可变参数相邻，那么可以不需要外部参数名：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sayStrings</span>(<span style="color:#66d9ef">_</span> array: String..., other: String, <span style="color:#66d9ef">_</span> array2: String...) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> s <span style="color:#66d9ef">in</span> array {
</span></span><span style="display:flex;"><span>        print(s)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    print(other)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> s <span style="color:#66d9ef">in</span> array2 {
</span></span><span style="display:flex;"><span>        print(s)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>sayStrings(<span style="color:#e6db74">&#34;Manny&#34;</span>, <span style="color:#e6db74">&#34;Moe&#34;</span>, <span style="color:#e6db74">&#34;Jack&#34;</span>, other: <span style="color:#e6db74">&#34;Matt&#34;</span>, <span style="color:#e6db74">&#34;Groucho&#34;</span>, <span style="color:#e6db74">&#34;Harpo&#34;</span>, <span style="color:#e6db74">&#34;Chico&#34;</span>)
</span></span></code></pre></div><p>不幸的是，<code>Swift</code>语言中存在一个漏洞：无法将数组转换为以逗号分隔的参数列表（类似于<code>Ruby</code>中的 <code>splatting</code>）。如果开始使用的是某种类型的数组，那么不能在需要该类型的可变参数的地方使用它。</p>
<h2 id="忽略的参数">忽略的参数</h2>
<p>如同外部参数一样，如果<font color=Blue>内部参数名称为下划线，则说明该内部参数名称会被忽略</font>。即使省略了内部参数，函数调用者也必须提供实参，但它在函数体中没有内部名字。在下面的例子中，内部参数名字已经省略，也就是说无法使用这个参数，因此使用外部参数名会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">say</span>(<span style="color:#66d9ef">_</span> s: String, test times: Int, loudly <span style="color:#66d9ef">_</span>: Bool) {
</span></span><span style="display:flex;"><span>    debugPrint(s)
</span></span><span style="display:flex;"><span>    debugPrint(times)
</span></span><span style="display:flex;"><span>    debugPrint(loudly) <span style="color:#75715e">// Cannot find &#39;loudly&#39; in scope</span>
</span></span><span style="display:flex;"><span>    debugPrint(test)   <span style="color:#75715e">// Cannot find &#39;test&#39; in scope</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>say(<span style="color:#e6db74">&#34;test&#34;</span>, test:<span style="color:#ae81ff">12</span>, loudly: <span style="color:#66d9ef">false</span>)
</span></span></code></pre></div><h2 id="可修改参数">可修改参数</h2>
<p>在函数内的参数，本质上是一个局部变量。默认情况下（不声明为<code>inout</code>时）函数参数是用<code>let</code>隐式声明的常量。因为<font color=red>函数内的参数是常量，所以不能对它进行赋值操作</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">say</span>(<span style="color:#66d9ef">_</span> s: String, times: Int, loudly: Bool) {
</span></span><span style="display:flex;"><span>    loudly = <span style="color:#66d9ef">true</span> <span style="color:#75715e">// compile error </span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果在函数体内需要对参数进行赋值，你可能想到的一种方式是声明一个同名的变量，然后将参数的值赋值给刚定义的变量，这样就可以改变值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">say</span>(<span style="color:#66d9ef">_</span> s: String, times: Int, loudly: Bool) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> loudly = loudly 
</span></span><span style="display:flex;"><span>    loudly = <span style="color:#66d9ef">true</span> <span style="color:#75715e">// local var</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>但上面只是改变新定义的本地<code>loudly</code>变量，不会改变传进来入参<code>loudly</code>的值。如果想要改变函数传进来实参的值，需要按如下方式进行：</p>
<ul>
<li>
<p>参数的类型必须声明为<code>inout</code>，关键字<code>inout</code><font color=red>放在类型前面</font>。</p>
</li>
<li>
<p>调用函数时，<font color=red>传入的实参必须是用<code>var</code>声明的，而不能是<code>let</code>声明，因为只有用<code>var</code>声明的变量才能被改变</font>。</p>
</li>
<li>
<p>调用函数时，传入的<font color=red>必须是实参的地址</font>，而不是实参本身，即需要在变量名前加<code>&amp;</code>符号。</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">say</span>(<span style="color:#66d9ef">_</span> s: String, times: Int, loudly: <span style="color:#66d9ef">inout</span> Bool) {
</span></span><span style="display:flex;"><span>    loudly = <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> loudly = <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>say(<span style="color:#e6db74">&#34;test&#34;</span>, times: <span style="color:#ae81ff">1</span>, loudly: &amp;loudly)
</span></span></code></pre></div><p>当调用带有<code>inout</code>参数的函数时，始终设置其地址作为参数传递给该参数的变量，即使该函数没有对该参数进行任何更改。</p>
<p>有一种常见的情况是，在函数体中可以修改参数的值而不必把它声明为<code>inout</code>。当<font color=LightSeaGreen>参数是一个类的实例时，可以直接修改实例的值，这是类的一个特殊功能，与其他两种对象类型（枚举和结构体）不同</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name = <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">changeName</span>(of d: Dog, to newName: String) {
</span></span><span style="display:flex;"><span>    d.name = newName
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> d = Dog()
</span></span><span style="display:flex;"><span>d.name = <span style="color:#e6db74">&#34;Fido&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>debugPrint(d.name) <span style="color:#75715e">// &#34;Fido&#34;</span>
</span></span><span style="display:flex;"><span>changeName(of: d, to: <span style="color:#e6db74">&#34;Rover&#34;</span>)
</span></span><span style="display:flex;"><span>debugPrint(d.name) <span style="color:#75715e">// &#34;Rover&#34;</span>
</span></span></code></pre></div><p>在上面的例子中<code>changeName</code>函数的第一个参数并没有声明为<code>inout</code>，但在函数体中确实改变了<code>Dog</code>的实例<code>d</code>的属性。虽然传入的实参是用<code>let</code>声明的，但也能改变类实例的属性<code>name</code>，这说明<font color=red>类的实例本身是可变的</font>。</p>
<p>从技术上讲，我们说<font color=red>类是引用类型，而其他类型的对象则是值类型</font>。当把一个结构体的实例作为参数传递给一个函数时，<font color=LightSeaGreen>实际上是得到了该结构体实例的一个副本</font>。但是，当把一个类的实例作为参数传递给一个函数时，传递的是该类实例本身的引用。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name = <span style="color:#e6db74">&#34;A&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">B</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name = <span style="color:#e6db74">&#34;B&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> a: A = A() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">didSet</span> {
</span></span><span style="display:flex;"><span>        debugPrint(oldValue)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> b: B = B() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">didSet</span> {
</span></span><span style="display:flex;"><span>        debugPrint(oldValue)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>a.name = <span style="color:#e6db74">&#34;aaa&#34;</span>
</span></span><span style="display:flex;"><span>b.name = <span style="color:#e6db74">&#34;bbb&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Command.B(name: &#34;B&#34;)</span>
</span></span></code></pre></div><p>上面代码改变类的实例<code>a</code>的<code>name</code>属性时<code>didSet</code>没有调用，而改变结构体的实例<code>b</code>的属性<code>name</code>时，<code>didSet</code>调用了，说明生成了一个结构体实例副本。</p>
<h2 id="使用可修改参数调用oc">使用可修改参数调用OC</h2>
<p>当使用<code>Cocoa</code>时，可能会遇到该模式的变化。<code>Cocoa API</code>是用C和<code>Objective-C</code>编写的，因此可能会看到一些神秘的类型，例如<code>UnsafeMutablePointer</code>，而不是<code>Swift</code>中的<code>inout</code>。然而，作为调用者的角度来看，这是同一件事：您将准备一个<code>var</code>变量并传递其地址。</p>
<p>例如，<code>UIColor</code>的<code>RGBA</code>成分的问题，它由四个成分：颜色的红色、绿色、蓝色和<code>alpha</code>值。给定<code>UIColor</code>的函数返回该颜色的成分，需要一次返回四个值——这是<code>Objective-C</code>无法做到的。<code>UIColor</code>方法<code>getRed(_:green:blue:alpha:)</code>返回一个布尔值，以说明是否提取成功：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">getRed</span>(<span style="color:#66d9ef">_</span> red: UnsafeMutablePointer&lt;CGFloat&gt;, green: UnsafeMutablePointer&lt;CGFloat&gt;, blue: UnsafeMutablePointer&lt;CGFloat&gt;, alpha: UnsafeMutablePointer&lt;CGFloat&gt;) -&gt; Bool
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> c = UIColor.purple 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> r : CGFloat = <span style="color:#ae81ff">0</span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> g : CGFloat = <span style="color:#ae81ff">0</span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> b : CGFloat = <span style="color:#ae81ff">0</span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> a : CGFloat = <span style="color:#ae81ff">0</span> 
</span></span><span style="display:flex;"><span>c.getRed(&amp;r, green: &amp;g, blue: &amp;b, alpha: &amp;a) <span style="color:#75715e">// now r, g, b, a are 0.5, 0.0, 0.5, 1.0</span>
</span></span></code></pre></div><h2 id="被可修改参数的oc调用">被可修改参数的OC调用</h2>
<p>有时<code>Cocoa</code>想要使用<code>UnsafeMutablePointer</code>参数调用<code>Swift</code>函数，用到的技术是赋值<code>UnsafeMutablePointer</code>的指针属性。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">popoverPresentationController</span>(<span style="color:#66d9ef">_</span> popoverPresentationController: UIPopoverPresentationController, willRepositionPopoverTo rect: UnsafeMutablePointer&lt;CGRect&gt;, <span style="color:#66d9ef">in</span> view: AutoreleasingUnsafeMutablePointer&lt;UIView&gt;) {
</span></span><span style="display:flex;"><span>    view.pointee = <span style="color:#66d9ef">self</span>.button2
</span></span><span style="display:flex;"><span>    rect.pointee = <span style="color:#66d9ef">self</span>.button2.bounds
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="内部函数">内部函数</h2>
<p>函数可以在任何地方声明，在<font color=Blue>函数体中声明函数也是合法的</font>。声明在函数内的函数称为本地函数（内部函数），它<font color=LightSeaGreen>可以被在同一范围内本地函数声明后的同级代码所调用，但在其它地方完全不可见</font>。</p>
<p>对于那些唯一目的是协助另一个函数的函数来说，内部函数是一种优雅的架构。如果只有函数<code>A</code>需要调用函数<code>B</code>，那么函数<code>B</code>还不如打包在函数<code>A</code>里面。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">checkPair</span>(<span style="color:#66d9ef">_</span> p1: Piece, and p2: Piece) -&gt; Path? {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">addPathIfValid</span>(<span style="color:#66d9ef">_</span> midpt1: Point, <span style="color:#66d9ef">_</span> midpt2: Point) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>    } 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> y <span style="color:#66d9ef">in</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> ... _yct {
</span></span><span style="display:flex;"><span>        addPathIfValid((p1.x, y), (p2.x, y))
</span></span><span style="display:flex;"><span>    } 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> x <span style="color:#66d9ef">in</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> ... _xct {
</span></span><span style="display:flex;"><span>        addPathIfValid((x, p1.y), (x, p2.y))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>     <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>内部函数<font color=red>实际上是一个局部变量，其类型是函数类型</font>。因此，一个<font color=LightSeaGreen>局部函数不能与同一作用域中的局部变量同名，并且两个局部函数也不能在同一作用域中同名</font>。</p>
<h2 id="递归">递归</h2>
<p>在函数中调用自己的函数被称为递归函数。递归可能会产生无限循环，所以需要在递归函数中写出正确的终止逻辑，防止函数无限递归下去，导致内存占用过高，手机发烫：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">countDownFrom</span>(<span style="color:#66d9ef">_</span> ix: Int) {
</span></span><span style="display:flex;"><span>    debugPrint(ix)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ix <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> { <span style="color:#75715e">// stopper</span>
</span></span><span style="display:flex;"><span>        countDownFrom(ix <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#75715e">// recurse</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>countDownFrom(<span style="color:#ae81ff">5</span>) <span style="color:#75715e">// 5, 4, 3, 2, 1, 0</span>
</span></span></code></pre></div><h2 id="函数作为值">函数作为值</h2>
<p>在<code>Swift</code>中函数是一等公民，这<font color=Blue>意味着任何使用值的地方都可以使用函数</font>。一个函数可以被赋值给一个变量，也可以作为一个函数调用的参数被传递，也可以作为函数返回值。</p>
<p><code>Swift</code>是强类型的语言，当<font color=LightSeaGreen>函数作为值传递的，必须类型相匹配，函数的签名就是它的类型</font>。为了使函数类型更简洁，可以使用<code>typealias</code>给一个函数类型起个别名，这个名字可以是描述性的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">typealias</span> VoidVoidFunction = () -&gt; Void
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">doTest</span>(test: VoidVoidFunction) {
</span></span><span style="display:flex;"><span>    test()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>doTest {
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;doTest 1&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>doTest() {
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;doTest 2&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>使用一个函数作为值的主要目的是<font color=red>可以在不确定函数具体是什么的情况下调用该函数</font>。下面代码是一个极简单的例子，只是为了展示函数作为值使用的结构和语法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">doThis</span>(<span style="color:#66d9ef">_</span> f: () -&gt; Void) {
</span></span><span style="display:flex;"><span>    f()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面<code>doThis</code>函数通过<code>f()</code>来调用它接受的函数参数。所以<code>doThis</code>仅是一个调用另一个函数的简单函数。<font color=LightSeaGreen>但它这样做时事先并不知道要调用什么函数，这就是函数作为一等公民的力量</font>。在声明了<code>doThis</code>这个函数后，需要把一个函数作为参数传给它才能调用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">typealias</span> VoidVoidFunction = () -&gt; Void
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">dothis</span>(<span style="color:#66d9ef">_</span> f: VoidVoidFunction) {
</span></span><span style="display:flex;"><span>    f()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">doThis</span>(<span style="color:#66d9ef">_</span> f: () -&gt; Void) {
</span></span><span style="display:flex;"><span>    f()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">whatToDo</span>() {
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;I did it&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>doThis(whatToDo) <span style="color:#75715e">//I did it</span>
</span></span></code></pre></div><p>为了使函数类型更清晰，我们可以利用<code>Swift</code>的类型别名特性为函数类型命名。该名称可以是描述性的，并且避免了可能令人困惑的箭头运算符符号：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">typealias</span> VoidVoidFunction = () -&gt; ()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">dothis</span>(<span style="color:#66d9ef">_</span> f: VoidVoidFunction) {
</span></span><span style="display:flex;"><span>    f()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="匿名函数">匿名函数</h2>
<p>在下面的代码中，声明函数<code>whatToAnimate</code>和<code>whatToDoLater</code>只是为了在<code>UIView.animate</code>中传递函数参数。其实并不一定需要<code>whatToAnimate</code>和<code>whatToDoLater</code>这两个函数名字，因为他们只是在代码最后一行使用了，之后便没有再使用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">whatToAnimate</span>() { 
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;animations&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">whatToDoLater</span>(finished: Bool) {
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;finished: </span><span style="color:#e6db74">\(</span>finished<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>UIView.animate(withDuration: <span style="color:#ae81ff">0.4</span>, animations: whatToAnimate, completion: whatToDoLater)
</span></span><span style="display:flex;"><span><span style="color:#75715e">//open class func animate(withDuration duration: TimeInterval, animations: @escaping () -&gt; Void, completion: ((Bool) -&gt; Void)? = nil)</span>
</span></span></code></pre></div><p>如果在<code>UIView.animate(withDuration:animations:completion:)</code>调用时能够只传递函数体，不专门声明一个函数，并将其名字传递进去，将会更简洁。</p>
<p>一个<font color=red>无名的函数体被称为匿名函数</font>，在<code>Swift</code>中匿名函数是合法且常见的。要形成一个匿名函数，需要做两件事。首先，需要创建一个函数体，即一对花括号(此时无需加<code>func xxx</code>)。接着，如果有必要，将函数的参数列表和返回类型作为花括号内的第一件事来表达，然后是关键字<code>in</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>{ () -&gt; () <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;animations&#34;</span>)
</span></span><span style="display:flex;"><span>} 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>{ (finished: Bool) -&gt; () <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;finished: </span><span style="color:#e6db74">\(</span>finished<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="匿名函数缩写">匿名函数缩写</h3>
<h4 id="省略返回类型和箭头">省略返回类型和箭头</h4>
<p>匿名函数在<code>Swift</code>中很常见，也非常重要，所以<code>Swift</code>提供了一些编写匿名函数的便捷方式。<font color=LightSeaGreen>如果编译器已经知道匿名函数的返回值，则可以省略箭头操作符和返回值类型</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>UIView.animate(withDuration: <span style="color:#ae81ff">0.4</span>, animations: { () <span style="color:#66d9ef">in</span>  <span style="color:#75715e">// 省略了箭头操作符和返回值类型</span>
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;animations&#34;</span>)
</span></span><span style="display:flex;"><span>}, completion: { (finished: Bool) <span style="color:#66d9ef">in</span>  <span style="color:#75715e">// 省略了箭头操作符和返回值类型</span>
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;finished: </span><span style="color:#e6db74">\(</span>finished<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">testName</span>(count: Int, test: (Int) -&gt; String) {
</span></span><span style="display:flex;"><span>    debugPrint(test(count))
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>testName(count: <span style="color:#ae81ff">3</span>) { (count: Int) <span style="color:#66d9ef">in</span> <span style="color:#75715e">// 省略了箭头操作符和返回值类型</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;test:</span><span style="color:#e6db74">\(</span>count<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>debugPrint({ (count: Int) <span style="color:#66d9ef">in</span> <span style="color:#75715e">// 省略了箭头操作符和返回值类型</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">\(</span>count<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>}(<span style="color:#ae81ff">13</span>))  <span style="color:#75715e">// 13</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">doThis</span>(completion: @escaping () -&gt; String) {
</span></span><span style="display:flex;"><span>    completion()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>doThis() { ()  <span style="color:#66d9ef">in</span> <span style="color:#75715e">// 省略了箭头操作符和返回值类型</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;doThis&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>偶尔编译器也会无法推断出匿名函数的返回类型，并且会出现编译错误。如果发生这种情况，就不能使用这种便捷方式，而应该提供一个具有明确返回类型的<code>in</code>表达式。</p>
<h4 id="省略in关键字">省略in关键字</h4>
<p>如果一个<font color=red>匿名函数没有参数，并且箭头操作符和返回类型（一起的）可以省略</font>，那么<code>in</code>也可以省略。在下面的代码中传递给<code>animations</code>的匿名函数省略了返回类型和<code>in</code>关键字:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>UIView.animate(withDuration: <span style="color:#ae81ff">0.4</span>, animations: {  <span style="color:#75715e">// 没有参数省略了箭头操作符和返回值类型以及 in</span>
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;animations&#34;</span>)
</span></span><span style="display:flex;"><span>}, completion: { (finished: Bool) <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;finished: </span><span style="color:#e6db74">\(</span>finished<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">doThis</span>(completion: @escaping () -&gt; String) {
</span></span><span style="display:flex;"><span>    completion()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>doThis() { () <span style="color:#75715e">// 无参数，有返回值 省略了关键关键字in</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;doThis&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="省略参数类型">省略参数类型</h4>
<p>如果匿名函数有参数，并且编译器已经知道参数的类型，则匿名函数中参数的类型可以省略。在下面的代码中传递给<code>completion</code>的匿名函数省略了参数类型，即<code>Bool</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>UIView.animate(withDuration: <span style="color:#ae81ff">0.4</span>, animations: {
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;animations&#34;</span>)
</span></span><span style="display:flex;"><span>}, completion: { (finished) <span style="color:#66d9ef">in</span>  <span style="color:#75715e">// 省略了参数类型</span>
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;finished: </span><span style="color:#e6db74">\(</span>finished<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">testName</span>(count: Int, test: (Int) -&gt; String) {
</span></span><span style="display:flex;"><span>    debugPrint(test(count))
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>testName(count: <span style="color:#ae81ff">2</span>) { (count)  <span style="color:#66d9ef">in</span> <span style="color:#75715e">// 省略了参数类型和返回值类型</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;test:</span><span style="color:#e6db74">\(</span>count<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>debugPrint({ (count) <span style="color:#66d9ef">in</span> <span style="color:#75715e">// 省略了参数类型和返回值类型</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">\(</span>count<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>}(<span style="color:#ae81ff">13</span>))  <span style="color:#75715e">// 13</span>
</span></span></code></pre></div><h4 id="省略参数列表圆括号">省略参数列表圆括号</h4>
<p>如果<font color=LightSeaGreen>匿名函数的参数类型可以省略，那么参数列表的圆括号也可以省略</font>。在下面的代码中传递给<code>completion</code>的匿名函数，既省略了参数类型也省略了圆括号：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>UIView.animate(withDuration: <span style="color:#ae81ff">0.4</span>, animations: {
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;animations&#34;</span>)
</span></span><span style="display:flex;"><span>}, completion: { finished <span style="color:#66d9ef">in</span> <span style="color:#75715e">// 省略了参数类型和参数列表圆括号以及返回值类型</span>
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;finished: </span><span style="color:#e6db74">\(</span>finished<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">testName</span>(count: Int, test: (Int) -&gt; String) {
</span></span><span style="display:flex;"><span>    debugPrint(test(count))
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>testName(count: <span style="color:#ae81ff">2</span>) { count  <span style="color:#66d9ef">in</span> <span style="color:#75715e">// 省略了参数类型和参数列表圆括号以及返回值类型</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;test:</span><span style="color:#e6db74">\(</span>count<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>debugPrint({ count <span style="color:#66d9ef">in</span> <span style="color:#75715e">// 省略了参数类型和参数列表圆括号以及返回值类型</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">\(</span>count<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>}(<span style="color:#ae81ff">13</span>))  <span style="color:#75715e">// 13</span>
</span></span></code></pre></div><h4 id="有参数列表省略in表达式">有参数列表省略in表达式</h4>
<p>如果<font color=LightSeaGreen>匿名函数的返回类型可以省略，并且编译器已经知道参数的类型</font>，也可以省略<code>in</code>表达式。在匿名函数体中可以直接引用参数，<code>$0</code>表示第一个参数，<code>$1</code>表示第二个参数，依此类推：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>UIView.animate(withDuration: <span style="color:#ae81ff">0.4</span>, animations: {
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;animations&#34;</span>)
</span></span><span style="display:flex;"><span>}, completion: {
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;finished: </span><span style="color:#e6db74">\(</span>$0<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">testName</span>(count: Int, test: (Int) -&gt; String) {
</span></span><span style="display:flex;"><span>    debugPrint(test(count))
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>testName(count: <span style="color:#ae81ff">2</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;test:</span><span style="color:#e6db74">\(</span>$0<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>debugPrint({ 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">\(</span>$0<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>}(<span style="color:#ae81ff">13</span>))  <span style="color:#75715e">// 13</span>
</span></span></code></pre></div><h4 id="省略参数名">省略参数名</h4>
<p>如果匿名函数不需要引用参数，则可以在<code>in</code>表达式的参数列表中用下划线代替其名称。下面的代码中，传递给<code>completion</code>的匿名函数，使用下划线代替了参数名：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>UIView.animate(withDuration: <span style="color:#ae81ff">0.4</span>, animations: {
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;animations&#34;</span>)
</span></span><span style="display:flex;"><span>}, completion: { <span style="color:#66d9ef">_</span> <span style="color:#66d9ef">in</span> <span style="color:#75715e">// *</span>
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;finished!&#34;</span>)
</span></span><span style="display:flex;"><span>})
</span></span></code></pre></div><p>如果一个匿名函数有参数，可以省略<code>in</code>表达式，使用<code>$0,$1</code>来获取参数。或者可以保留<code>in</code>表达式，给参数命名，或者用下划线忽略它们。但<font color=red>不能省略<code>in</code>表达式而不使用参数的魔法名称</font><code>$0,$1</code>，一旦这样做了，代码将无法通过编译。</p>
<h4 id="省略函数标签">省略函数标签</h4>
<p>如果匿名函数是<font color=Blue>函数调用中传递的最后一个参数</font>。可以在最后一个参数之前用右括号来关闭函数调用，然后只放匿名函数体，不放标签，这就是尾部封闭语法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>UIView.animate(withDuration: <span style="color:#ae81ff">0.4</span>, animations: {
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;animations&#34;</span>)
</span></span><span style="display:flex;"><span>}) { <span style="color:#66d9ef">_</span> <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;finished!&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在上面的代码中，<code>completion:</code>参数是最后一个，因此可以在调用的括号外传递匿名函数参数，使用不带标签的尾随闭包语法。但是，实际上<code>animate</code>函数中接受两个函数参数，<code>animations</code>也是匿名函数，但它依然在括号里。</p>
<p>从<code>Swift 5.3</code>开始，多个匿名函数参数可以使用尾部闭包语法。当这样做时，<font color=LightSeaGreen>第一个匿名函数不需要标签，但其余的函数都需要它们的标签</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>UIView.animate(withDuration: <span style="color:#ae81ff">0.4</span>) {
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;animations&#34;</span>)
</span></span><span style="display:flex;"><span>} completion: { <span style="color:#66d9ef">_</span> <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;finished!&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="省略函数调用圆括号">省略函数调用圆括号</h4>
<p>如果使用了尾部闭包，并且如果所调用的函数<font color=red>除了传递给它的函数之外没有其他函数参数</font>，可以从调用中省略空括号。这是<font color=red>唯一可以从函数调用中省略括号的情况</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">doThis</span>(<span style="color:#66d9ef">_</span> f: () -&gt; Void) {
</span></span><span style="display:flex;"><span>    f()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>doThis { <span style="color:#75715e">// 没有使用调用圆括号</span>
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;Howdy&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">doThis</span>(name: String, <span style="color:#66d9ef">_</span> f: () -&gt; Void) {
</span></span><span style="display:flex;"><span>    f()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>doThis(name: <span style="color:#e6db74">&#34;trr&#34;</span>) { <span style="color:#75715e">// 没有使用调用圆括号</span>
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;Howdy&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="省略return关键字">省略return关键字</h4>
<p>如果匿名函数体恰好由一个语句组成，该语句包含返回一个带有关键字<code>return</code>的值，则关键字<code>return</code>可以省略：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">greeting</span>() -&gt; String {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;Howdy&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">performAndPrint</span>(<span style="color:#66d9ef">_</span> f: () -&gt; String) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> s = f()
</span></span><span style="display:flex;"><span>    print(s)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>performAndPrint {
</span></span><span style="display:flex;"><span>    greeting() <span style="color:#75715e">// meaning: return greeting()</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在编写匿名函数时，会经常发现自己利用了所有允许的省略。此外，有时会通过将整个匿名函数与函数调用放在一行中来缩短代码的布局（尽管不是代码本身）。因此，涉及匿名函数的<code>Swift</code>代码可以非常紧凑。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> arr = [<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">8</span>]
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> arr2 = arr.map {$0<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>}
</span></span></code></pre></div><h2 id="define-adn-call">Define adn Call</h2>
<p>在<code>Swift</code>中，非常常见的模式是定义一个匿名函数并调用它，一步到位。如下所示，花括号定义了一个匿名函数体，圆括号调用该匿名函数，此构造称为定义和调用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#75715e">// ... code goes here</span>
</span></span><span style="display:flex;"><span>}()
</span></span></code></pre></div><p>使用<code>define-and-call</code>，可以在需要的地方采取行动。例如，有一个常见的<code>Cocoa</code>情况，我们创建和配置<code>NSMutableParagraphStyle</code>，然后将其作为参数调用<code>NSMutableAttributedString</code>的方法<code>addAttribute(_:value:range:)</code>，如下所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> para = NSMutableParagraphStyle()
</span></span><span style="display:flex;"><span>para.headIndent = <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>para.firstLineHeadIndent = <span style="color:#ae81ff">10</span> <span style="color:#75715e">// ... more configuration of para ...</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>content.addAttribute(<span style="color:#75715e">// content is an NSMutableAttributedString</span>
</span></span><span style="display:flex;"><span>        .paragraphStyle,
</span></span><span style="display:flex;"><span>        value: para,
</span></span><span style="display:flex;"><span>        range: NSRange(location: <span style="color:#ae81ff">0</span>, length: <span style="color:#ae81ff">1</span>))
</span></span></code></pre></div><p>但是上面的代码看起来很丑。实际上<code>para</code>是在<code>addAttribute(_:value:range:)</code>调用中将它作为<code>value:</code>参数传递，因此在调用时创建和配置它会更好。这听起来像是一个匿名函数——除了<code>value:</code>参数不是一个函数，而是一个<code>NSMutableParagraphStyle</code>对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>content.addAttribute(
</span></span><span style="display:flex;"><span>        .paragraphStyle, value: {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> para = NSMutableParagraphStyle()
</span></span><span style="display:flex;"><span>    para.headIndent = <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>    para.firstLineHeadIndent = <span style="color:#ae81ff">10</span> <span style="color:#75715e">// ... more configuration of para ... return para </span>
</span></span><span style="display:flex;"><span>}(), range: NSRange(location: <span style="color:#ae81ff">0</span>, length: <span style="color:#ae81ff">1</span>))
</span></span></code></pre></div><h2 id="closures">Closures</h2>
<p><code>Swift</code>的函数都是闭包，这意味他们可以捕获对函数主体范围内的外部变量的引用。这是什么意思呢，下面这段代码可中，函数<code>bark</code>可以“看到”在其周围范围内声明的变量和函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> whatThisDogSays = <span style="color:#e6db74">&#34;woof&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        print(<span style="color:#66d9ef">self</span>.whatThisDogSays)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>对于上面的<code>bark</code>函数来说，<code>whatThisDogSays</code>是外部变量，因为它在<code>bark</code>函数体之外声明，但它的作用域仍在<code>bark</code>函数体内，因此<code>bark</code>函数体内部的代码可以看到它。</li>
<li>函数体内的代码引用了外部变量<code>whatThisDogSays</code>——它明确地使用<code>whatThisDogSays</code>。</li>
</ul>
<p>到现在为止还挺好，但是我们现在知道函数<code>bark</code>可以作为值传递。实际上，它可以从一种环境传播到另一种环境。当它发生时，对<code>whatThisDogSays</code>的引用会发生什么？让我们来了解一下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">doThis1</span>(<span style="color:#66d9ef">_</span> f: () -&gt; ()) {
</span></span><span style="display:flex;"><span>    f()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> d = Dog()
</span></span><span style="display:flex;"><span>d.whatThisDogSays = <span style="color:#e6db74">&#34;arf&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> barkFunction = d.bark
</span></span><span style="display:flex;"><span>doThis1(barkFunction) <span style="color:#75715e">// arf</span>
</span></span></code></pre></div><p>上面的结果看起来是正常的，但是我们没有直接调用<code>d.dark</code>，我们创建了一个<code>Dog</code>的实例，并把它的<code>bark</code>函数作为值传给函数<code>doThis</code>函数。在那里，<code>bark</code>函数被调用。<code>whatThisDogSays</code>是<code>Dog</code>的实例属性，在函数<code>doThis</code>中并没有<code>whatThisDogSays</code>属性。事实上，在<code>doThis</code>函数中也没有<code>Dog</code>的实例。然而，调用<code>f()</code>仍然正常。函数<code>d.bark</code>，当它被传递的时候，显然是把变量<code>whatThisDogSays</code>一起传递的。</p>
<p>当我们创建了<code>Dog</code>的实例<code>d</code>和<code>barkFunction</code>，更改<code>d</code>的属性会更改调用<code>barkFunction</code>的输出，怎么会这样？显然当<code>d.bark</code>赋值给<code>barkFunction</code>后，实例<code>d</code>和<code>barkFunction</code>都持有对同一个<code>Dog</code>实例的引用。这是因为我们赋值给<code>barkFunction</code>的<code>d.bark</code>引用了<code>self</code>，也就是<code>Dog</code>实例。当我们说函数是一个闭包并且它捕获在其主体中引用的外部变量时，这就是我们的意思。</p>
<h2 id="how-closures-improve-code">How Closures Improve Code</h2>
<p>可以<font color=red>使用函数是闭包这一事实来使你的代码更通用，从而更有用</font>。为了说明作用，使用之前的一个函数示例，它接受绘图指令并执行它们以生成图像：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">imageOfSize</span>(<span style="color:#66d9ef">_</span> size: CGSize, <span style="color:#66d9ef">_</span> whatToDraw: () -&gt; ()) -&gt; UIImage {
</span></span><span style="display:flex;"><span>    UIGraphicsBeginImageContextWithOptions(size, <span style="color:#66d9ef">false</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    whatToDraw()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> result = UIGraphicsGetImageFromCurrentImageContext()<span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span>    UIGraphicsEndImageContext()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> result
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>可以以尾闭包的方式调用上面的函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> image = imageOfSize(CGSize(width: <span style="color:#ae81ff">45</span>, height: <span style="color:#ae81ff">20</span>)) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> p = UIBezierPath(roundedRect: CGRect(x: <span style="color:#ae81ff">0</span>, y: <span style="color:#ae81ff">0</span>, width: <span style="color:#ae81ff">45</span>, height: <span style="color:#ae81ff">20</span>), cornerRadius: <span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>    p.stroke()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>但是上面包含了重复代码，即<code>CGSize(width:45, height:20)</code>重复了两次：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> sz = CGSize(width: <span style="color:#ae81ff">45</span>, height: <span style="color:#ae81ff">20</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> image = imageOfSize(sz) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> p = UIBezierPath(roundedRect: CGRect(origin: CGPoint.zero, size: sz), cornerRadius: <span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>    p.stroke()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在上面的代码中，<code>sz</code>是在比匿名函数更高层次声明的，因此在匿名函数中能够看见和引用它。需要注意的是，匿名函数只是一个函数体，如果<code>imageOfSize</code>不调用，匿名函数就不会执行。</p>
<p>然而，当函数体内部的表达式<code>CGRect(origin:CGPoint.zero, size:sz)</code>中引用<code>sz</code>时，我们现在捕获它的值（因为函数体是一个闭包）。当<code>imageOfSize</code>调用<code>whatToDraw</code>时，<code>whatToDraw</code>是一个函数体，它引用了一个变量<code>sz</code>，即使在<code>imageOfSize</code>附近没有<code>sz</code>也是没问题的。</p>
<p>到目前为止，我们一直在硬编码所需圆角矩形的大小。不过，想象一下，创建各种大小的圆角矩形图像是我们经常做的事情。将这段代码打包成一个函数是有意义的，其中<code>sz</code>不是一个固定值，而是一个参数，然后该函数将返回图像：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">makeRoundedRectangle</span>(<span style="color:#66d9ef">_</span> sz: CGSize) -&gt; UIImage {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> image = imageOfSize(sz) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> p = UIBezierPath(roundedRect: CGRect(origin: CGPoint.zero, size: sz), cornerRadius: <span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>        p.stroke()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> image
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在上面的<code>makeRoundedRectangle</code>的函数中，参数<code>sz</code>不再是硬编码值，我们不知道它会是什么。当调用<code>makeRoundedRectangle</code>时，<code>sz</code>会有一个值，并且匿名函数会捕获<code>sz</code>，所以当<code>imageOfSize</code>调用匿名函数时，该函数内部的<code>sz</code>将具有传递给<code>makeRoundedRectangle</code>的<code>sz</code>值。</p>
<h2 id="function-returning-function">Function Returning Function</h2>
<p>但函数可以用作值，我们已经将一个函数作为函数调用中的参数传递给函数。函数可以返回函数，现在我们将从函数调用中接收一个函数作为其结果，也就是返回一个生成指定大小的圆角矩形的函数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">makeRoundedRectangleMaker</span>(<span style="color:#66d9ef">_</span> sz: CGSize) -&gt; () -&gt; UIImage { <span style="color:#960050;background-color:#1e0010">①</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">f</span>() -&gt; UIImage { <span style="color:#960050;background-color:#1e0010">②</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> im = imageOfSize(sz) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> p = UIBezierPath(roundedRect: CGRect(origin: CGPoint.zero, size: sz), cornerRadius: <span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>            p.stroke()
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> im
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> f <span style="color:#960050;background-color:#1e0010">③</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol>
<li>
<p>函数<code>makeRoundedRectangleMaker</code>的类型（签名）到底是什么？它是<code>(CGSize) -&gt; () -&gt; UIImage</code>。该表达式有两个箭头运算符，每个箭头运算符之后的所有内容都是返回值的类型。因此上面的函数接受一个参数<code>CGSize</code>，并且返回<code>() -&gt; UIImage</code>。<code>() -&gt; UIImage</code>表示一个无参数返回<code>UIIamge</code>的函数签名。</p>
</li>
<li>
<p>在函数体内定义一个内部函数，这个内部函数没有入参，返回一个<code>UIImage</code>。我们将这个函数命名为<code>f</code>。这个函数的工作方式既简单又熟悉：它调用<code>imageOfSize</code>，传递给它一个匿名函数，该函数生成一个圆角矩形<code>(im)</code>的图像——然后它返回该图像。</p>
</li>
<li>
<p>最后，我们返回内部函数<code>f</code>。我们已经履行了约定：我们说过将返回一个不带参数的函数并返回一个<code>UIImage</code>，我们就这样做了。</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> maker = makeRoundedRectangleMaker(CGSize(width:<span style="color:#ae81ff">45</span>, height:<span style="color:#ae81ff">20</span>)) 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">self</span>.iv.image = maker()
</span></span></code></pre></div><p>我们再次将注意力转向<code>makeRoundedRectangleMaker</code>函数的实现，编写<code>makeRoundedRectangleMaker</code>不是为了告诉你一个函数可以产生一个函数。编写它是为了说明闭包，让我们考虑一下上下文是如何被捕获的。</p>
<p>函数<code>f</code>没有参数。然而，在<code>f</code>的函数体中两次引用了<code>sz</code>。函数<code>f</code>内部可以看到<code>sz</code>，即外部函数<code>makeRoundedRectangleMaker</code>的参数。函数<code>f</code>在<code>makeRoundedRectangleMaker</code>被调用时捕获了<code>sz</code>，并在<code>f</code>在函数中返回并赋值给<code>maker</code>时保留该引用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> maker = makeRoundedRectangleMaker(CGSize(width:<span style="color:#ae81ff">45</span>, height:<span style="color:#ae81ff">20</span>)) 
</span></span></code></pre></div><p>这就是为什么<code>maker</code>现在是一个函数，当它被调用时，创建和返回了特定大小的图片。另一方面，<code>makeRoundedRectangleMaker</code>是一个工厂，用于创建类似于<code>maker</code>的整个函数系列，每个函数都生成一个特定大小的图像。这是闭包力量的戏剧性例证。</p>
<p>实际上，在<code>makeRoundedRectangleMaker</code>中，没有必要创建<code>im</code>变量，可以直接返回<code>imageOfSize</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">makeRoundedRectangleMaker</span>(<span style="color:#66d9ef">_</span> sz: CGSize) -&gt; () -&gt; UIImage {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">f</span>() -&gt; UIImage {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> imageOfSize(sz) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> p = UIBezierPath(roundedRect: CGRect(origin: CGPoint.zero, size: sz), cornerRadius: <span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>            p.stroke()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> f
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>实际上也没有必要生成和返回<code>f</code>，可以直接返回匿名函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">makeRoundedRectangleMaker</span>(<span style="color:#66d9ef">_</span> sz: CGSize) -&gt; () -&gt; UIImage {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> {
</span></span><span style="display:flex;"><span>        imageOfSize(sz) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> p = UIBezierPath(roundedRect: CGRect(origin: CGPoint.zero, size: sz), cornerRadius: <span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>            p.stroke()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="closure-setting-a-captured-variable">Closure Setting a Captured Variable</h2>
<p>闭包通过其捕捉环境的能力所获得的力量甚至比我到目前为止所展示的还要大。如果闭包能够捕获一个自身外部变量的引用，并且该变量是可设置的，则闭包可以设置该变量。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">pass100</span>(<span style="color:#66d9ef">_</span> f: (Int) -&gt; ()) {
</span></span><span style="display:flex;"><span>    f(<span style="color:#ae81ff">100</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> x = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>print(x) <span style="color:#75715e">// 0</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">setX</span>(newX: Int) {
</span></span><span style="display:flex;"><span>    x = newX
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>pass100(setX)
</span></span><span style="display:flex;"><span>print(x) <span style="color:#75715e">// 100</span>
</span></span></code></pre></div><p>在上面的代码中，因为传入到<code>pass100</code>中的函数<code>setX</code>包含了引用<code>x</code>，不仅包含它，而且捕获它，并且修改了<code>x</code>的值。函数<code>pass100</code>函数能够像直接调用<code>setX</code>一样轻松地设置<code>x</code>。</p>
<h2 id="closure-preserving-captured-environment">Closure Preserving Captured Environment</h2>
<p>当一个闭包捕获它所在的环境，它会保留该环境，即使没有其他方法。这是一个让你大吃一惊的例子——一个修改函数的函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">countAdder</span>(<span style="color:#66d9ef">_</span> f: @escaping () -&gt; ()) -&gt; () -&gt; () {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> ct = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> {
</span></span><span style="display:flex;"><span>        ct = ct <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;count is </span><span style="color:#e6db74">\(</span>ct<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>        f()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面的函数<code>countAdder</code>接受一个函数参数，并且返回一个函数值。它返回的函数调用它接受的函数，并添加一点：它增加一个变量并报告结果。所以现在试着猜测当我们运行这段代码时会发生什么：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">greet</span>() {
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;howdy&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> countedGreet = countAdder(greet)
</span></span><span style="display:flex;"><span>countedGreet() <span style="color:#75715e">// count is 1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>countedGreet() <span style="color:#75715e">// count is 2</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>countedGreet() <span style="color:#75715e">// count is 3</span>
</span></span></code></pre></div><p>函数<code>countAdder</code>返回一个新函数，我们将其命名为<code>countedGreet</code>。然后我们调用<code>countedGreet</code> 三次。以下是控制台中显示的内容：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>count <span style="color:#66d9ef">is</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>howdy
</span></span><span style="display:flex;"><span>count <span style="color:#66d9ef">is</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>howdy
</span></span><span style="display:flex;"><span>count <span style="color:#66d9ef">is</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>howdy
</span></span></code></pre></div><p>显然，<code>countAdder</code>已经为传递给它的函数添加了报告调用次数的能力。维持这个计数的变量到底在哪里？在<code>countAdder</code>中，<code>ct</code>是一个局部变量，它并未声明在匿名函数中，这是故意的。如果它是在匿名函数中声明的，那么每次调用<code>countedGreet</code>时我们都会将<code>ct</code>设置为<code>0</code>——我们不会计数。相反，<code>ct</code>被初始化为<code>0</code>一次，然后被匿名函数捕获。</p>
<p>这个变量作为<code>countedGreet</code>环境的一部分被保留下来&ndash;它在<code>countedGreet</code>之外的某个神秘的环境保护世界中，所以每次<code>countedGreet</code>被调用时它都能被递增。</p>
<h2 id="escaping-closures">Escaping Closures</h2>
<p>如果作为值传递的函数将被保留以供以后执行，而不是直接调用，它是一个随时间捕获并保留其环境的闭包。这被称为逃逸闭包(<code>escaping closure</code>)。在某些场景下，函数的类型必须标记为<code>escaping</code>。编译器会检测到对这一规则的违反，所以如果你觉得这一规则令人困惑，不用担心，只要让编译器为你执行就可以了。</p>
<p>下面这个函数是合法的，因为它接受一个函数作为参数，并且直接调用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">funcCaller</span>(f: () -&gt; ()) {
</span></span><span style="display:flex;"><span>    f()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>而下面这个函数是合法的，即使它返回一个稍后执行的函数，因为它也在内部创建了那个函数。它返回的函数是一个逃逸闭包，但函数返回值的类型不必标记为<code>@escaping</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">funcMaker</span>() -&gt; () -&gt; () {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> {
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;hello world&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>但是，下面的函数是违法的。它接受了一个函数参数，并且随后返回了这个函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">funcPasser</span>(f: () -&gt; ()) -&gt; () -&gt; () { <span style="color:#75715e">// compile error</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> f
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>解决的方案是将函数参数标记为<code>@escaping</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">funcPasser</span>(f: @escaping () -&gt; ()) -&gt; () -&gt; () { 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> f
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>逃逸闭包的第二个特点是当你在函数体内引用<code>self</code>的属性或方法时，编译器可能会坚持要明确地使用<code>self</code>。那是因为这样的引用捕获了<code>self</code>，编译器希望你通过说<code>self</code>来承认这个事实：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> f1 = funcPasser {
</span></span><span style="display:flex;"><span>    print(view.bounds) <span style="color:#75715e">// compile error, because self.view is implied</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> f2 = funcPasser {
</span></span><span style="display:flex;"><span>    print(<span style="color:#66d9ef">self</span>.view.bounds) <span style="color:#75715e">// ok</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="capture-lists">Capture Lists</h2>
<p>有时，可能希望函数引用自身外部的变量，只是为了获取其值，但不捕获该变量。<code>Swift</code>提供了一种巧妙的语法来做到这一点——但<font color=red>仅限于函数是匿名函数</font>时。在匿名函数体的开头，放置方括号，其中包含对周围环境中变量的引用的逗号分隔列表，这称为捕获列表。</p>
<p>如果你有一个捕获列表，你必须在它后面加上关键字<code>in</code>。如果已经存在<code>in</code>表达式，则捕获列表位于任何参数名称之前。</p>
<p>结果就好像<font color=red>该值已作为参数而不是通过闭包捕获传递给匿名函数，就像参数一样</font>。它的行为就像是用<code>let</code>声明的一样：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> x1 = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> f1: () -&gt; () = {
</span></span><span style="display:flex;"><span>    print(x1)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>f1() <span style="color:#75715e">// 0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>x1 = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>f1() <span style="color:#75715e">// 1</span>
</span></span></code></pre></div><p>在上面的函数中，由于捕获到了变量的值，那么打印的值分别是0和1。而在下面的代码中，因为添加了捕获列表，两次打印的值均为0:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> x1 = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> f1: () -&gt; () = { [x1] <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>    print(x1)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>f1() <span style="color:#75715e">// 0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>x1 = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>f1() <span style="color:#75715e">// 0</span>
</span></span></code></pre></div><p>由于捕获列表，<code>f</code>在声明时已经将<code>x</code>的值捕获为0。实际上，x的行为类似于传递给f的普通参数，这是一个常数。另一种理解方式是，如果f尝试设置<code>x</code>的值，编译器会报错：“无法分配给值：x是不可变的捕获。”</p>
<p>将捕获列表表达式分配给另一个名称也是合法的。例如，捕获列表可以使用<code>[y=x1]</code>，这种方式好像将<code>x1</code>作为参数传递给匿名函数，但现在该参数称为<code>y</code>。当原始名称有问题时，或者当要传入的值是需要在赋值时计算时，这很有用。这是代码中的一个示例（不解释上下文）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">self</span>.undoer.registerUndo(withTarget: <span style="color:#66d9ef">self</span>) {
</span></span><span style="display:flex;"><span>    [oldCenter = <span style="color:#66d9ef">self</span>.center] myself <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>    myself.setCenterUndoably(oldCenter)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>作为参数传递给<code>registerUndo</code>的匿名函数是一个逃逸函数。捕获列表声明了一个常量<code>oldCenter</code>并将其值设置为 <code>self.center</code>。因此，<code>self.center</code>的值现在在调用<code>registerUndo</code>时进行求值，而不是稍后在调用匿名函数本身时进行评估（此时 <code>self.center</code>的值可能已更改）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> f2 = funcPasser {
</span></span><span style="display:flex;"><span>    print(<span style="color:#66d9ef">self</span>.view.bounds)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>捕获列表的另一个用途是解决在逃逸闭包中明确表示<code>self</code>的要求。下面的代码中，需要明确地使用<code>self</code>，因为这是一个逃逸闭包。但是很多人不喜欢明确地使用<code>self</code>，如果这个匿名函数多次隐含的使用<code>self</code>，则可能需要多次明确地使用<code>self</code>。从<code>Swift 5.3</code>开始，有一个风格上的替代方案：如果你把<code>self</code>放在捕获列表中，这会满足编译器的要求，并且你不必将<code>self</code>写为函数体中的隐式目标：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> f2 = funcPasser { [<span style="color:#66d9ef">self</span>] <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>    print(view.bounds) <span style="color:#75715e">// ok </span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="curried-function">curried function</h2>
<p>当一个函数<font color=red>返回一个带参数的函数</font>，那么它被称为<code>curried</code>函数（以计算机科学家<code>Haskell Curry</code>命名）。下面是一个简单的<code>curried</code>函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">makeRoundedRectangleMaker</span>(<span style="color:#66d9ef">_</span> sz: CGSize) -&gt; (CGFloat) -&gt; UIImage {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> { r <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>        imageOfSize(sz) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> p = UIBezierPath(roundedRect: CGRect(origin: CGPoint.zero, size: sz), cornerRadius: r)
</span></span><span style="display:flex;"><span>            p.stroke()
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="函数引用">函数引用</h2>
<p>如果通过名字引用一个函数（或传递给另外一个函数作为参数），通常可以使用函数的<code>bare name</code>（裸名）。函数的<code>bare name</code>指的是函数的名字（只包括函数名字不包含其它）。下面代码中<code>whatToAnimate</code>和<code>whatToDoLater</code>都是函数的<code>bare name</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">whatToAnimate</span>() { 
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;animations&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">whatToDoLater</span>(finished: Bool) {
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;finished: </span><span style="color:#e6db74">\(</span>finished<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>UIView.animate(withDuration: <span style="color:#ae81ff">0.4</span>, animations: whatToAnimate, completion: whatToDoLater) 
</span></span></code></pre></div><p>在上面的代码中<code>whatToAnimate</code>和<code>whatToDoLater</code>也是函数的引用。它只由函数的名字组成，也就是<code>func</code>关键字后，参数列表括号前的那个函数名。<font color=Blue>没有圆括号表明这是一个引用，而不是一个调用</font>。</p>
<p>在没有歧义的情况下，使用<code>bare name</code>作为函数的引用是合法的。上面的代码中，在这个特定的上下文中只有一个叫<code>whatToDoLater</code>的函数，因此能在一个参数类型已知的函数调用中使用<code>bare name</code>作为参数。</p>
<p>既可以将函数作为参数传递，也可以将函数赋值给一个变量或者常量。下面的代码中，定义了两个相同名字的函数，一个接受参数，一个不接受参数，直接使用<code>bark</code>可能会产生歧义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;woof&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>(<span style="color:#66d9ef">_</span> loudly: Bool) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> loudly {
</span></span><span style="display:flex;"><span>            debugPrint(<span style="color:#e6db74">&#34;WOOF&#34;</span>)
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            bark()
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> barkFunction = bark <span style="color:#75715e">// compile error </span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面的代码将会出现编译错误，因为同时存在两个名为<code>bark</code>的函数，此时编译器不清楚到底要引用哪个。为了解决这个问题，<code>Swift</code>提供了标注，它可以更精确地引用函数，标注包含两个部分：</p>
<ul>
<li>
<p><code>full name</code>:此处翻译为全名，对于有参数的函数的全名包括函数的名字，一对圆括号，以及<font color=red>外部参数列表</font>，其中<font color=LightSeaGreen>外部参数列表使用冒号(<font color=red>没有逗号或者空格</font>)</font>。如果外部参数被<code>suppressed</code>（即定义的时候使用下划线），则使用下划线代替。对于没有参数的函数的全名就是它的<code>bare name</code>。</p>
</li>
<li>
<p>签名: 一个函数的签名可以用关键字<code>as</code>作用到其<code>bare name</code>或<code>full name</code>上。</p>
</li>
</ul>
<p>例如，函数<code>func say(_ s:String, times:Int) {...}</code>可以使用全名<code>say(_:times:)</code>来标注，也可使用<code>bare name</code>和签名:<code>say as (String, Int) -&gt; ()</code>来标注。</p>
<p>在上面的代码中，如果使用<code>let barkFunction = bark(_:) </code>编译器就不会报错，因为已经指定了函数<code>bark</code>为接受一个参数的那个。</p>
<p>但如果要引用无参数的<code>bark</code>函数，因为无参的那个函数的裸名和全名均为<code>bark</code>（不包括圆括号，无参数的函数加上圆括号就是函数调用了），直接使用仍然会报错，因为编译器无法区分要引用哪个函数，此时应该使用<code>as</code>和函数签名：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;woof&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>(<span style="color:#66d9ef">_</span> loudly: Bool) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> loudly {
</span></span><span style="display:flex;"><span>            debugPrint(<span style="color:#e6db74">&#34;WOOF&#34;</span>)
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            bark()
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> barkFunction = bark <span style="color:#66d9ef">as</span> () -&gt; ()  <span style="color:#75715e">// 使用函数签名</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>下面的代码中，定义了三个<code>bark</code>函数，其中有两个都接受一个参数，并且外部参数名都被省略了。如果此时使用<code>let barkFunction = bark(_:)</code>仍然会出现编译错误，因为编译器无法确定要调用哪个<code>bark</code>，因为此时有两个带参数的<code>bark</code>，它们的<code>fullname</code>均为<code>bark(_:)</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>(<span style="color:#66d9ef">_</span> loudly: Bool) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>(<span style="color:#66d9ef">_</span> times: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> barkFunction = bark(<span style="color:#66d9ef">_</span>:) <span style="color:#75715e">// compile error</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>此时需要使用<code>as</code>和函数签名才能确定到底要使用哪个<code>bark</code>，即<code>let barkFunction = bark as (Int) -&gt; ()</code>转换为接受<code>Int</code>的那个<code>bark</code>，编译才不会报错。或者直接指定<code>barkFunction</code>为<code>(Int) -&gt; ()</code>类型。</p>
<h2 id="函数引用的作用域">函数引用的作用域</h2>
<p>在前面的代码中，使用函数引用时，并未告知编译器函数是在哪定义的，<font color=LightSeaGreen>这是因为函数定义和函数引用在同一个作用域内</font>。也就是说，如果<font color=LightSeaGreen>可以在不提供进一步信息的情况下调用该函数，就可以在不提供进一步信息的情况下形成函数引用</font>。</p>
<p>函数引用可以提供关于函数在哪定义的进一步信息，而且有时必须这样做。这可以通过在函数引用前<font color=red>加一个实例或类，然后后面紧接着点操作符来实现</font>。有些情况下，编译器会强制要求使用<code>self</code>来引用一个函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;bark&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>(<span style="color:#66d9ef">_</span> loudly: Bool) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> loudly {
</span></span><span style="display:flex;"><span>            debugPrint(<span style="color:#e6db74">&#34;WOOF&#34;</span>)
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            debugPrint(<span style="color:#e6db74">&#34;woof&#34;</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> f = {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 使用了self</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">self</span>.bark(<span style="color:#66d9ef">_</span>:) <span style="color:#75715e">// self required here</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// f是一个函数，无参数，但是返回一个函数</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> tmpBark = f() <span style="color:#75715e">// 执行函数，得到一个新的函数</span>
</span></span><span style="display:flex;"><span>        tmpBark(<span style="color:#66d9ef">false</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> tmpDog = Dog()
</span></span><span style="display:flex;"><span>tmpDog.test() <span style="color:#75715e">// woof</span>
</span></span></code></pre></div><p>如果要形成对另一个类型实例方法的函数引用，可以有两个方法。如果当前有一个该类型的实例，可以使用点操作符实现对该实例的引用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Cat</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">purr</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;purr&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> cat = Cat()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> purrFunction = cat.purr
</span></span><span style="display:flex;"><span>        purrFunction()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Test</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">var</span> test = <span style="color:#e6db74">&#34;test&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">testFunc</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">var</span> name: String {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;name&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">func</span> nameFunc() {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">testNew</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;testNew&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> test = Test()
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> test1 = test.testNew
</span></span><span style="display:flex;"><span>test1()
</span></span></code></pre></div><p>另一种可能的方式是使用<font color=red>类型和点操作符来获取函数的引用</font>，即使函数是实例方法也是适用的。但是下面的代码需要使用函数签名来消除歧义。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Cat</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">purr</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;purr&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>       debugPrint(<span style="color:#e6db74">&#34;bark&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> barkFunction = Dog.bark <span style="color:#75715e">// legal but not necessary </span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> purrFunction = Cat.purr
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果使用类型和点操作符来获取函数引用，并且<font color=LightSeaGreen>需要借助函数签名来消除函数引用的歧义时，那么函数签名必须是描述实例方法的静态/类的柯里版本</font>(<code>the signature must describe the curried static/class version of the instance method</code>)：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Cat</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">purr</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;purr&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">purr</span>(<span style="color:#66d9ef">_</span> loudly: Bool) {
</span></span><span style="display:flex;"><span>         debugPrint(<span style="color:#e6db74">&#34;loudly </span><span style="color:#e6db74">\(</span>loudly<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> cat = Cat()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> purrFunc = Cat.purr <span style="color:#66d9ef">as</span> (Cat) -&gt; () -&gt; Void <span style="color:#75715e">// 柯里版本</span>
</span></span><span style="display:flex;"><span>        debugPrint(purrFunc)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> tmpFunc = purrFunc(cat)
</span></span><span style="display:flex;"><span>        tmpFunc() <span style="color:#75715e">// 调用purr方法</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> test2 = Test.testNew(test)
</span></span><span style="display:flex;"><span>test2()
</span></span></code></pre></div><h2 id="selectors">Selectors</h2>
<p>在<code>Objective-C</code>中<code>selector</code>是一种方法引用。在<code>iOS</code>编程中，可能会调用一个<code>Cocoa</code>方法，这个方法需要一个<code>selector</code>作为它的某个参数。</p>
<p>通常这样的<code>Cocoa</code>方法需要提供一个<code>target</code>（对象的引用）。运行时可以将<code>selector</code>变成一个消息，并将该消息发送给<code>target</code>以调用该方法。</p>
<p>为了形成<code>selector</code>，需要构建一个代表方法的<code>Objective-C</code>字符串。这种方式是十分危险的，如果错误地构建了这个代表方法的字符串，那么向<code>target</code>发送消息时，<font color=Blue>因为<code>target</code>没有这样的方法，运行时将发现<code>target</code>不能处理这个消息</font>，此时应用程序会<code>crash</code>，并向控制台打印<code>未识别的选择器</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ViewController</span>: UIViewController {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">@IBOutlet</span> <span style="color:#66d9ef">var</span> button: UIButton!
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">viewDidLoad</span>() {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">super</span>.viewDidLoad()
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// prepare to crash</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.button.addTarget(<span style="color:#66d9ef">self</span>, action: <span style="color:#e6db74">&#34;buttonPressed&#34;</span>, <span style="color:#66d9ef">for</span>: .touchUpInside)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">@objc</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">buttonPressed</span>(<span style="color:#66d9ef">_</span> sender: Any) {
</span></span><span style="display:flex;"><span>         debugPrint(<span style="color:#e6db74">&#34;buttonPressed&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在上面的代码中<code>self.button</code>是界面上的一个按钮，通过调用<code>addTarget(action:for:)</code>来设置按钮的响应事件，使得当按钮点击时可以调用<code>buttonPressed</code>方法。</p>
<p>但是，上面设置的方法字符串是错误的，因为<code>buttonPressed</code>不是<code>Objective-C</code>的方法字符串，正确的方法名称字符串应该是<code>buttonPressed:</code>。这样会导致按钮点击的时候发生崩溃。</p>
<p>如果不知道形成<code>selector</code>字符串的规则，或者即使知道，但输入时不注意犯了一个小错误，都可能导致出现<code>未识别的选择器</code>崩溃。</p>
<p><code>Swift</code>编译器在这方面并不容易出错，它提供了一种方法，即通过<code>#selector(...)</code>语法可以生成一个<code>Objective-C</code>的<code>selector</code>，括号里面的是函数引用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ViewController</span>: UIViewController {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">@IBOutlet</span> <span style="color:#66d9ef">var</span> button: UIButton!
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">viewDidLoad</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">super</span>.viewDidLoad()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.button.addTargett(<span style="color:#66d9ef">self</span>, action: <span style="color:#66d9ef">#selector</span>(buttonPressed), <span style="color:#66d9ef">for</span>: .touchUpInside)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">@objc</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">buttonPressed</span>(<span style="color:#66d9ef">_</span> sender: Any) {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;buttonPressed&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面的代码中使用<code>#selector(...)</code>时，编译器会做两件事情：</p>
<ul>
<li>
<p>编译器会检查函数引用是否合法，如果不合法则会出现编译错误。同时会检查这个函数是否暴露给<code>Objective-C</code>。为一个<code>Objective-C</code>看不到的方法形成一个选择器是没有意义的，因为如果<code>Objective-C</code>试图调用这样一个方法，应用程序会崩溃。在<code>Swift</code>为了确保对<code>Objective-C</code>是可见的，该方法需要标记为<code>@objc</code>。</p>
</li>
<li>
<p>如果使用<code>#selector</code>的代码能够编译，实际的<code>selector</code>将被传递到它的参数中，并保证它是正确的。手动写方法字符串可能会形成错误的选择器，但编译器不会，它所产生的<code>selector</code>不可能与方法不匹配，也不可能出现<code>未识别的选择器</code>崩溃。</p>
</li>
</ul>
<p>在某些情况下，可能需要手动创建一个选择器。要做到这一点可以使用一个方法字符串，或者可以用字符串作为参数来实例化选择器：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>Selector(<span style="color:#e6db74">&#34;woohoo:&#34;</span>)
</span></span></code></pre></div><p>使用<code>#selector(...)</code>语法，仍然<font color=red>可能通过向错误的<code>target</code>发送<code>action</code>信息而发送崩溃</font>。在前面的例子中，如果把<code>addTarget</code>调用的第一个参数<code>self</code>改为<code>self.button</code>，将会在运行时以<code>未识别的选择器</code>崩溃。因为<code>buttonPressed</code>方法是在<code>ViewController</code>中声明的，而不是在<code>UIButton</code>中。</p>
<h1 id="变量和简单类型">变量和简单类型</h1>
<p>变量的作用域和生命周期分为三个层次：全局变量，属性，局部变量。全局变量声明在<code>Swift</code>文件顶部，它的生命周期和所在的文件一样长。</p>
<p>一个全局变量默认（默认是<code>internal</code>访问权限）在它声明所在<code>module</code>任何地方都是可见的，这就是<code>全局</code>的意思。它对同一文件中的所有代码都是可见的，因为它处于最高级别。</p>
<p>此外，默认情况下全局变量对于<font color=Blue>同一模块中任何其他文件中的所有代码也都是可见的</font>，因为同一模块中的<code>Swift</code>文件可以自动看到彼此，所以也可以看到彼此顶层声明的全局变量：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#75715e">// File1:</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> globalVariable = <span style="color:#e6db74">&#34;global&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">debugPrintGlobal</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(globalVariable) 
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// File2: </span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Cat</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">debugPrintGlobal</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(globalVariable) 
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>属性是指在对象类型声明时在其<font color=red>顶层声明的变量</font>。有两种类型的属性，一种的是实例属性，另一种是类属性（或称为静态属性）。如果属性声明时未加<code>static</code>或<code>class</code>关键字，就是实例属性。<font color=LightSeaGreen>实例属性的值对于每个实例都可以是不同的，它的生命周期和实例的生命周期相同</font>。</p>
<p>如果一个属性在声明的时候加上<code>static</code>或者<code>class</code>，那就是类属性（或称为静态属性），它的生命周期和类型的生命周期相同。</p>
<p>属性只能通过对象才能看到，<font color=Blue>对象的方法能够直接看到属性</font>。默认情况下，实例属性对于其他代码也是可见的，前提是要有这个实例的引用。同样地，默认情况下，一个静态/类属性对其他可以看到这个对象类型的代码也是可见的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#75715e">// File1:</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> staticProperty = <span style="color:#e6db74">&#34;staticProperty&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> instanceProperty = <span style="color:#e6db74">&#34;instanceProperty&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">debugPrintInstanceProperty</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#66d9ef">self</span>.instanceProperty)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// File2: </span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Cat</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">debugPrintDogStaticProperty</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(Dog.staticProperty) 
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">debugPrintDogInstanceProperty</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> dog = Dog()
</span></span><span style="display:flex;"><span>        debugPrint(dog.instanceProperty) 
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>局部变量是指<font color=red>声明在花括号内部的变量</font>，它的生命周期与包含它的花括号一样长。当程序执行到局部变量声明的范围时，局部变量才会真正生成，当程序执行离开这个范围时，局部变量就会自动消失。<font color=Blue>局部变量有时被称为自动变量，以表示它们会自动出现和消失</font>。一个局部变量只能被同一作用域中的后续代码看到，包括同一作用域中后续更深层次的作用域。</p>
<h2 id="声明">声明</h2>
<p>变量声明时使用<code>let</code>或者<code>var</code>。使用<code>let</code>声明的是常量，常量的意思是<font color=red>当第一次被赋值之后就不再允许被改变</font>。使用<code>var</code>声明的变量是真正可变的，随时都可以改变值。</p>
<p>在<code>Swift</code>中<font color=Blue>变量声明时没有强制初始化，即使用<code>let</code>声明也一样</font>。对于<code>let x : Int</code>这样的声明是完全合法的。可以后面再给这个变量分配一个初始值，因为这个特殊的变量是一个常量，<font color=LightSeaGreen>所以一旦有了初始值，那么这个初始值将是它以后的唯一值，不能再被改变</font>。</p>
<p>对于属性来说，先声明后初始化是很常见的，因为属性的初始化可以通过对象类型的初始化函数来实现。但对于局部变量来说，通常是声明的时候同时初始化。</p>
<p>当局部变量遇到需要<code>条件性初始化</code>时，也可以先声明后初始化。有时，在进行某种条件测试之前，并不知道某个变量的初始值。因为变量只能被声明一次，所以它必须被提前声明，之后再进行初始化：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> timed: Bool
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> val == <span style="color:#ae81ff">1</span> {
</span></span><span style="display:flex;"><span>    timed = <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    timed = <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果<font color=LightSeaGreen>一个变量的地址被当作参数传递给一个函数时，这个变量必须在传递之前先声明并且在传递之前已经被初始化</font>，也就是说<font color=red>即使初始化值是假的占位符也必须先给一个初始值</font>，否则会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> r: CGFloat = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> g: CGFloat = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> b: CGFloat = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> a: CGFloat = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>c.getRed(&amp;r, green: &amp;g, blue: &amp;b, alpha: &amp;a)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">oneParameter</span>(test: String) {
</span></span><span style="display:flex;"><span>    debugPrint(test)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> tt1:String
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>oneParameter(test: tt1) <span style="color:#75715e">// Variable &#39;tt1&#39; used before being initialized</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">testMain</span>(test: <span style="color:#66d9ef">inout</span> String) {
</span></span><span style="display:flex;"><span>    test = <span style="color:#e6db74">&#34;name&#34;</span>
</span></span><span style="display:flex;"><span>    debugPrint(test)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> newTest :String
</span></span><span style="display:flex;"><span>testMain(test: &amp;newTest) <span style="color:#75715e">// Variable &#39;newTest&#39; passed by reference before being initialized</span>
</span></span></code></pre></div><p>极少数情况下，会遇到这样一种情况：调用一个立即返回一个值的<code>Cocoa</code>方法，然后在传递给这个方法的函数参数中又要使用这个返回值。<code>Cocoa</code>有一个<code>UIApplication</code>实例方法是下面这样声明的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">beginBackgroundTask</span>(expirationHandler handler: (() -&gt; Void)? = <span style="color:#66d9ef">nil</span>) -&gt; UIBackgroundTaskIdentifier
</span></span></code></pre></div><p>上面的<code>beginBackgroundTask(expirationHandler:)</code>返回一个<code>UIBackgroundTaskIdentifier</code>对象，然后在<code>expirationHandler</code>函数中使用这个对象。<code>Swift</code>的安全规则<font color=Blue>不允许在一条语句中声明变量，同时又在声明语句中的匿名函数中使用它</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> bti = UIApplication.shared.beginBackgroundTask {
</span></span><span style="display:flex;"><span>    UIApplication.shared.endBackgroundTask(bti)
</span></span><span style="display:flex;"><span>} <span style="color:#75715e">// error: variable used within its own initial value</span>
</span></span></code></pre></div><p>因此，需要提前声明变量。在上面的代码中，如果只是提前声明变量，依然会有问题，编译时会报<code>variable captured by a closure before being initialized</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> bti: UIBackgroundTaskIdentifier
</span></span><span style="display:flex;"><span>bti = UIApplication.shared.beginBackgroundTask {
</span></span><span style="display:flex;"><span>    UIApplication.shared.endBackgroundTask(bti)
</span></span><span style="display:flex;"><span>} <span style="color:#75715e">// error: variable captured by a closure before being initialized</span>
</span></span></code></pre></div><p>一种解决方案是提前声明变量，并且<font color=LightSeaGreen>声明时给变量一个假的初始值作为占位符</font>。如下所示，给了变量<code>bti</code>一个假的初始值<code>.invalid</code>用来占位：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> bti: UIBackgroundTaskIdentifier = .invalid
</span></span><span style="display:flex;"><span>bti = UIApplication.shared.beginBackgroundTask {
</span></span><span style="display:flex;"><span>    UIApplication.shared.endBackgroundTask(bti)
</span></span><span style="display:flex;"><span>} 
</span></span></code></pre></div><h2 id="计算初始化">计算初始化</h2>
<p>有时需要先执行一些代码去才能获得变量的初始值，一个简洁的解决方案是<font color=red>定义和调用匿名函数来进行初始化</font>，这种方式称为<code>define-and-call initializer</code>。下面的代码中定义了一个匿名函数并立即执行来初始化常量<code>timed</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> val = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> timed: Bool = {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> val == <span style="color:#ae81ff">1</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}()
</span></span></code></pre></div><p>当一个实例属性也需要执行一些代码去获得初始值时，也可以使用<code>define-and-call initializer</code>方法进行初始化。下面的<code>cellBackgroundImage</code>属性需要用到多次，但初始化时需要执行一些其它代码，因此通过定义和调用一个匿名函数来初始化这个属性：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">RootViewController</span>: UITableViewController {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> cellBackgroundImage: UIImage = {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> imageOfSize(CGSize(width: <span style="color:#ae81ff">320</span>, height: <span style="color:#ae81ff">44</span>)) { 
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// ... drawing goes here ...</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }() 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>你可能会好奇，与其使用<code>define-and-call initializer</code>，为什么不直接定义一个实例方法来初始化实例属性。因为定义一个实例方法来初始化实例属性是非法的，会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">RootViewController</span>: UITableViewController {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> cellBackgroundImage: UIImage = <span style="color:#66d9ef">self</span>.makeTheImage() <span style="color:#75715e">// compile error </span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">makeTheImage</span>() -&gt; UIImage {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> imageOfSize(CGSize(width: <span style="color:#ae81ff">320</span>, height: <span style="color:#ae81ff">44</span>)) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// ... drawing goes here ...</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这是因为<font color=Blue>实例属性声明初始化时，实例尚未生成</font>。因此，<font color=LightSeaGreen>不能在属性声明的初始化器中引用自己</font>。定义和调用匿名函数是合法的，但需要注意的是<font color=Blue>定义和调用匿名函数仍然不能在函数体中引用<code>self</code></font>，否则也会出现编译错误，如果需要在函数体中使用<code>self</code>，需要将属性声明为<code>lazy</code>。</p>
<h2 id="计算变量">计算变量</h2>
<p>除了正常的存储变量，<code>Swift</code>中的变量还可以是计算的。这意味着变量不是一个简单值，而是包含计算函数。计算变量中包括<code>setter</code>和<code>getter</code>函数，<code>setter</code>函数在变量被赋值自动调用，<code>getter</code>函数在变量被引用时被自动调用:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> now: String { <span style="color:#75715e">// ①</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">get</span> { <span style="color:#75715e">// ② </span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Date().description <span style="color:#75715e">// ③</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">set</span> { <span style="color:#75715e">// ④</span>
</span></span><span style="display:flex;"><span>        debugPrint(newValue) <span style="color:#75715e">// ⑤</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol>
<li>
<p>变量<font color=red>必须使用<code>var</code>声明，同时类型必须显式声明</font>，类型后面紧跟花括号。</p>
</li>
<li>
<p><code>getter</code>函数被称为<code>get</code>。<code>getter</code>函数没有正式的函数声明，<code>get</code>这个词后面紧跟着函数体。</p>
</li>
<li>
<p><code>getter</code>函数必须返回一个与该变量类型相同的值。从<code>Swift 5.1</code>开始，当<code>getter</code>只有一个单一语句时，省略关键字<code>return</code>是合法的。</p>
</li>
<li>
<p><code>setter</code>函数被称为<code>set</code>。<code>setter</code>函数也没有正式的函数声明，<code>set</code>这个词后面紧跟着函数体。</p>
</li>
<li>
<p><code>setter</code>的行为就像接受一个参数的函数。默认情况下，该参数以<code>newValue</code>这个名字进入<code>setter</code>函数体。</p>
</li>
</ol>
<p>对于<code>set</code>函数来说，默认的参数可以不是<code>newValue</code>。如果需要指定一个不同的名称，把新名字放在<code>set</code>后面的括号里就可以，下面就是用新名字<code>val</code>代替默认的<code>newValue</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> nowTest: String = <span style="color:#e6db74">&#34;first&#34;</span> <span style="color:#75715e">// 需要先初始化，否则报错</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> now: String {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">get</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;test&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">set</span>(val) {
</span></span><span style="display:flex;"><span>        nowTest = val
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果<code>setter</code>函数省略，那么这个计算变量就成为了一个只读变量，等同于一个<code>let</code>常量，一旦试图去改变这个变量的值就会出现编译错误。即使只有一个<code>get</code>函数，计算变量声明的时候也必须使用<code>var</code>。</p>
<p>计算变量必须有一个<code>getter</code>函数。如果计算变量中没有<code>setter</code>函数，<code>get</code>这个词和它后面的花括号可以省略。下面是一个合法的只读计算变量的声明：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> now: String {
</span></span><span style="display:flex;"><span>    Date().description
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="计算属性">计算属性</h2>
<p>在实际的编程中，对于<font color=LightSeaGreen>计算变量的使用场景几乎都是实例属性</font>。当一个值在每次需要的时候都可以<font color=red>很容易地计算时</font>，将其表达为一个只读的计算变量往往更简单，实际上<font color=Blue>这是对一个较长表达式的速记法</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> mp: MPMusicPlayerController {
</span></span><span style="display:flex;"><span>    MPMusicPlayerController.systemMusicPlayer
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> nowPlayingItem: MPMediaItem? {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">self</span>.mp.nowPlayingItem
</span></span><span style="display:flex;"><span>}   
</span></span></code></pre></div><p>一个计算变量的<code>getter</code>函数<font color=red>可以封装多行代码，其实质是把一个方法变成了一个属性</font>。下面的例子是从<code>xml</code>文件中提取作者信息，本可以将其声明为方法<code>func authorOfItem() -&gt; String?</code>，但方法表达了一个过程，而计算属性则能更直观地描述：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> authorOfItem: String? {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">guard</span> <span style="color:#66d9ef">let</span> authorNodes = <span style="color:#66d9ef">self</span>.extensionElements(withXMLNamespace: <span style="color:#e6db74">&#34;http://www.tidbits.com/dummy&#34;</span>, elementName: <span style="color:#e6db74">&#34;app_author_name&#34;</span>) <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">guard</span> <span style="color:#66d9ef">let</span> authorNode = authorNodes.last <span style="color:#66d9ef">as</span>? FPExtensionNode <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> authorNode.stringValue
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>一个计算变量可以位于一个或多个存储变量的前面，<font color=Blue>充当这些存储变量的设置和获取时的守门员</font>。通常，一个计算变量由一个私有的存储变量来支持：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">var</span> _pp: Int = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> pp: Int {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">get</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>._pp
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">set</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>._pp = max(min(newValue, <span style="color:#ae81ff">5</span>), <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>一个实例的<font color=LightSeaGreen>计算属性<code>getter</code>函数或<code>setter</code>函数可以引用其他实例成员</font>。这很重要，因为一般来说，存储属性的初始化器不能这样做。对于一个计算的属性来说，它是合法的，<font color=red>因为<code>getter</code>和<code>setter</code>函数在实例实际存在之前不会被调用</font>。</p>
<h2 id="setter-observers">Setter Observers</h2>
<p>计算变量并不经常需要作为一个存储变量的<code>立面</code>。这是因为<code>Swift</code>有另一个功能，可以让你在<font color=red>存储变量</font>的<code>setter</code>中注入<code>setter observers</code>功能。<code>setter observers</code>是<font color=Blue>在设置存储变量之前和之后调用的函数</font>，可以有一个<code>willSet</code>函数，或一个<code>didSet</code>函数，或两者均有：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> s = <span style="color:#e6db74">&#34;whatever&#34;</span> { <span style="color:#75715e">// ①</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">willSet</span> { <span style="color:#75715e">// ②</span>
</span></span><span style="display:flex;"><span>        debugPrint(newValue) <span style="color:#75715e">// ③</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">didSet</span> { <span style="color:#75715e">// ④</span>
</span></span><span style="display:flex;"><span>        debugPrint(oldValue) <span style="color:#75715e">// ⑤</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// self.s = &#34;something else&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol>
<li>
<p>变量<font color=red>必须使用<code>var</code>声明</font>，不能使用<code>let</code>声明，并且它可以被赋予一个初始值。</p>
</li>
<li>
<p>如果<code>willSet</code>函数存在的话，就是单词<code>willSet</code>后面紧跟着函数体。当其他代码设置该变量时，在该变量实际收到其新值之前<code>willSet</code>函数被调用。</p>
</li>
<li>
<p>默认情况下，<code>willSet</code>函数接受即将设置的新值，这个新值的名字是<code>newValue</code>。也可以通过在<code>willSet</code>后面的括号里写一个不同的名字来自定义接受到的新值名字。旧值仍然在存储变量中，<code>willSet</code>函数中依然可以访问旧值。</p>
</li>
<li>
<p>如果在<code>willSet</code>中将存储变量设置为不同的值时，不会生效：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> newStr: String = <span style="color:#e6db74">&#34;new&#34;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">willSet</span> {
</span></span><span style="display:flex;"><span>        debugPrint(newValue)
</span></span><span style="display:flex;"><span>        newStr = <span style="color:#e6db74">&#34;test&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>newStr = <span style="color:#e6db74">&#34;name&#34;</span>
</span></span><span style="display:flex;"><span>debugPrint(newStr)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// name</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// name</span>
</span></span></code></pre></div></li>
<li>
<p>如果<code>didSet</code>函数存在的话，就是<code>didSet</code>这个词后面紧跟着函数体。当其他代码设置该变量时，在该变量实际收到其新值之后被调用。</p>
</li>
<li>
<p>默认情况下，<code>didSet</code>函数接收旧的值，名字为<code>oldValue</code>，此时新值已经完成替换。可以通过在<code>didSet</code>后面的括号里写一个不同的名字来来自定义接受到的旧值名字。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> now1: String = <span style="color:#e6db74">&#34;now1&#34;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">willSet</span>(val) {
</span></span><span style="display:flex;"><span>        debugPrint(now1)
</span></span><span style="display:flex;"><span>        debugPrint(val)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">didSet</span>(val) {
</span></span><span style="display:flex;"><span>        debugPrint(val)
</span></span><span style="display:flex;"><span>        debugPrint(now1)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>debugPrint(now1 = <span style="color:#e6db74">&#34;133&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">//&#34;now1&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//&#34;133&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//&#34;now1&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//&#34;133&#34;</span>
</span></span></code></pre></div></li>
<li>
<p>新的值已经在存储的变量中，<code>didSet</code>函数中可以访问新值。此外，在<code>didSet</code>函数中<font color=red>将存储变量设置为不同的值也是合法的</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> newStr: String = <span style="color:#e6db74">&#34;new&#34;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">willSet</span> {
</span></span><span style="display:flex;"><span>        debugPrint(newValue)
</span></span><span style="display:flex;"><span>        newStr = <span style="color:#e6db74">&#34;test&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">didSet</span> {
</span></span><span style="display:flex;"><span>        newStr = <span style="color:#e6db74">&#34;dddd&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>newStr = <span style="color:#e6db74">&#34;name&#34;</span>
</span></span><span style="display:flex;"><span>debugPrint(newStr)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// name</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// dddd</span>
</span></span></code></pre></div></li>
</ol>
<p>需要特别注意的是，当<font color=red>存储变量初始化时或<code>didSet</code>函数中再次改变存储变量的值时，不会调用<code>setter observers</code>函数</font>，否则会产生无限循环。</p>
<p>计算变量或者属性不能有<code>setter observers</code>，因为它已经有了<code>setter</code>函数，任何在设置过程中需要发生的额外事情都可以直接写入<code>setter</code>函数中。但<font color=LightSeaGreen>一个被属性包装器包裹的计算变量可以有`setter observers</font>。</p>
<h2 id="懒初始化">懒初始化</h2>
<p>如果一个存储变量声明的时候分配了一个初始值，并且如果它使用了<code>Lazy Initialization</code>（懒初始化），那么在运行代码访问该变量的值之前，初始值实际上还不会有。在<code>Swift</code>中，有三种类型的变量可以被懒初始化<code>Lazy Initialization</code>。</p>
<ul>
<li>
<p>全局变量。全局变量是自动<code>Lazy Initialization</code>的，一个全局变量的初始化在<font color=red>其他代码首次引用该全局变量时才会发生</font>，这种初始化只会执行一次，同时又是线程安全的。</p>
</li>
<li>
<p>静态属性。静态属性也是自动的<code>Lazy Initialization</code>的，它的行为和全局变量完全一样，而且原因也基本相同。所以在<code>Swift</code>中类属性不能再加<code>lazy</code>关键字。</p>
</li>
<li>
<p>实例属性默认不是<code>lazy</code>的，但可以在声明的时候显式加上关键字<code>lazy</code>。此时，这个属性必须使用<code>var</code>来声明而不能用<code>let</code>。如果没有任何代码获取属性的值，属性的初始化器可能永远不会执行。</p>
</li>
</ul>
<h2 id="单例">单例</h2>
<p><code>Lazy Initialization</code>常用于实现单例。单例是一种设计模式，所有的代码都能够访问某个类的单一共享实例。下面代码就是一个简单的单例实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClass</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> shared = MyClass()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">init</span>() {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>通常，我们希望实例属性是<code>Lazy Initialization</code>的。因为实例属性初始值的生成所花费的代价可能是昂贵的，所以除非确实需要用到的时候，一般会避免提前生成。但还有另一个原因更重要，<font color=red>懒初始化可以做普通初始化器不能做的事情</font>。</p>
<p>最重要的是<font color=Blue>懒初始化器可以访问实例本身</font>，而正常的初始化器是不能这样做的，因为在正常初始化器需要运行的时候，实例尚未生成。在下面的代码中，如果<code>arrow</code>属性不声明为<code>lazy</code>，将会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyView</span>: UIView {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">lazy</span> <span style="color:#66d9ef">var</span> arrow = <span style="color:#66d9ef">self</span>.arrowImage() <span style="color:#75715e">// legal</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">arrowImage</span>() -&gt; UIImage {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// ... big image-generating code goes here ...</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>一个常见的场景是定义和调用匿名函数来初始化一个<code>lazy</code>的实例属性。<font color=Blue>一旦加上<code>lazy</code>，那么在这个匿名函数中是可以引用实例本身的</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyView</span>: UIView {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">lazy</span> <span style="color:#66d9ef">var</span> prog: UIProgressView = {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> p = UIProgressView(progressViewStyle: .<span style="color:#66d9ef">default</span>)
</span></span><span style="display:flex;"><span>        p.alpha = <span style="color:#ae81ff">0.7</span>
</span></span><span style="display:flex;"><span>        p.trackTintColor = UIColor.clear
</span></span><span style="display:flex;"><span>        p.progressTintColor = UIColor.black
</span></span><span style="display:flex;"><span>        p.frame = CGRect(x: <span style="color:#ae81ff">0</span>, y: <span style="color:#ae81ff">0</span>, width: <span style="color:#66d9ef">self</span>.view.bounds.size.width, height: <span style="color:#ae81ff">20</span>) <span style="color:#75715e">// legal </span>
</span></span><span style="display:flex;"><span>        p.progress = <span style="color:#ae81ff">1.0</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> p
</span></span><span style="display:flex;"><span>    }()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>因为<font color=LightSeaGreen>不能将<code>lazy</code>加在<code>let</code>声明的属性上，所以不要让一个<code>lazy</code>的实例属性成为只读的。与自动<code>lazy</code>的全局变量和静态变量不同，标记为<code>lazy</code>的实例属性是线程不安全的</font>。<font color=Blue>当在多线程环境中使用时，<code>lazy</code>的实例属性可能会导致多次初始化，甚至闪退</font>。</p>
<h2 id="内置简单类型">内置简单类型</h2>
<p>每一个变量和每一个字面量都必须有一个类型。<code>Swift</code>内置的简单类型有<code>Bool,Numbers，String，Character，Range，Tuple</code>等。</p>
<p>与许多计算机语言不同，<code>Swift</code>中<font color=red>没有任何其它东西能被隐含地转换为<code>Bool</code></font>。例如，在<code>C</code>语言中，布尔值实际上是一个数字，<code>0</code>代表<code>false</code>，非<code>0</code>代表<code>true</code>。而在<code>Swift</code>中，只有<code>false</code>是<code>false</code>，<code>true</code>为<code>true</code>。</p>
<p>一个常见的情况：有一个存储在某个<code>var</code>变量中的<code>Bool</code>，我们想反转它的值。即如果它是<code>false</code>的就变成<code>true</code>，如果它是<code>true</code>就变成<code>false</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>v.isUserInteractionEnabled = <span style="color:#f92672">!</span>v.isUserInteractionEnabled
</span></span></code></pre></div><p>上面的方式很麻烦，也容易忘记加<code>!</code>。有一个更简单的方法，即在<code>Bool</code>变量上调用<code>toggle</code>方法。上面的代码可以直接使用<code>v.isUserInteractionEnabled.toggle()</code>实现。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>v.isUserInteractionEnabled.toggle()
</span></span></code></pre></div><p>在<code>Swift</code>中<code>Double</code>是一个结构体类型，表示一个精度约为<code>15</code>位小数的浮点数（使用<code>64</code>位存储）。含有小数点的数字默认为<code>Double</code>类型，并且<code>Double</code>类型的<font color=red>内部下划线和前导零是合法的</font>。<code>Double</code>有静态属性<code>Double.infinity</code>和<code>Double.pi</code>，也有一个实例属性<code>isZero</code>。</p>
<h2 id="数值强制转换">数值强制转换</h2>
<p>强制转换是指从一种类型转换为另一种类型。<font color=LightSeaGreen><code>Swift</code>并没有显式的类型强制转换，但它使用实例化能够完成同样的效果</font>。<code>Swift</code>的数字类型提供了初始化器，这些初始化器将另一个数字类型实例作为参数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> i = <span style="color:#ae81ff">10</span> <span style="color:#75715e">//an Int</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> x = Double(i)
</span></span><span style="display:flex;"><span>debugPrint(x) <span style="color:#75715e">// 10.0, a Double</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> y = <span style="color:#ae81ff">3.8</span> <span style="color:#75715e">//a Double</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> j = Int(y)
</span></span><span style="display:flex;"><span>debugPrint(j) <span style="color:#75715e">// 3, an Int</span>
</span></span></code></pre></div><p>当数值被赋值给变量或作为参数传递给函数时，<code>Swift</code><font color=red>只对字面数字量进行隐式强制转换</font>。下面这段代码是合法的，虽然<code>10</code>默认是<code>Int</code>类型，但是因为它是字面数字量，因此能够隐式地转换为<code>Double</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> d : Double = <span style="color:#ae81ff">10</span>
</span></span></code></pre></div><p>但下面这段代码是不合法的，编译器会报错。<font color=red>因为所赋值的是一个不同类型的变量，而不是字面数字</font>。问题的根源是<code>i</code>为<code>Int</code>实例，<code>d</code>是一个<code>Double</code>实例，二者不能自动进行隐式转换：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> i = <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> d : Double = i
</span></span></code></pre></div><p>当数字值被算术运算合并时，同样的规则也适用。<code>Swift</code><font color=red>只对字面数字量进行隐式转换</font>。例如，一个<code>Int</code>字面量与一个<code>Double</code>字面量运算时，<code>Int</code>字面量会隐式地转换为<code>Double</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> x = <span style="color:#ae81ff">10</span><span style="color:#f92672">/</span><span style="color:#ae81ff">3.0</span>
</span></span><span style="display:flex;"><span>debugPrint(x) <span style="color:#75715e">// 3.33333333333333</span>
</span></span></code></pre></div><h2 id="string">String</h2>
<p><code>Swift</code>中的字符串是完全现代的，它使用<code>Unicode</code>编码，可以在字符串字面量中直接包含任何字符（如表情符号）。如果知道一个字符的<code>Unicode</code>码点，并且不嫌麻烦，可以使用<code>\u{...}</code>，需要注意的是在<font color=LightSeaGreen>花括号的内容至多为八位十六进制数字</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> leftTripleArrow = <span style="color:#e6db74">&#34;\u{21DA}&#34;</span>
</span></span></code></pre></div><h2 id="range">Range</h2>
<p><code>Range</code>对象类型是一个结构体，代表一对端点。形成<code>Range</code>字面量的操作符有两个，提供一个开始值和一个结束值，在它们之间有一个<code>Range</code>操作符：</p>
<ul>
<li>
<p><code>...</code>闭<code>range</code>操作符：<code>a...b</code>意味着<code>a</code>到<code>b</code>的一切，包括<code>b</code>。</p>
</li>
<li>
<p><code>..&lt;</code>半开<code>range</code>操作符：<code>a..&lt;b</code>意味着<code>a</code>到<code>b</code>的一切，但不包括<code>b</code>。</p>
</li>
</ul>
<p>在<code>Range</code>操作符<font color=LightSeaGreen>两边添加空格是合法的</font>，例如<code>1...3</code>或<code>1 ... 3</code>都是合法的。一个<code>Range</code>的端点的类型通常是某种数字，最常见的是整型。</p>
<p>如果<font color=red>结束值是一个负数，它必须用括号括起来或在操作符前面加上空格</font>。<code>let r = -1000 ... -1</code>和<code>let r = (-1000...-1)</code>都是可以的。<code>Range</code>的常用场景是<code>for ... in</code>语句:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>debugPrint(<span style="color:#f92672">-</span><span style="color:#ae81ff">1000.</span>..<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#75715e">// compile error: Ambiguous missing whitespace between unary and binary operators</span>
</span></span><span style="display:flex;"><span>debugPrint(<span style="color:#f92672">-</span><span style="color:#ae81ff">1000</span> ... <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>debugPrint(<span style="color:#ae81ff">1</span> ... <span style="color:#ae81ff">1000</span>)
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> ix <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1.</span>..<span style="color:#ae81ff">3</span> {
</span></span><span style="display:flex;"><span>    debugPrint(ix) <span style="color:#75715e">// 1, then 2, then 3 </span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在<code>Swift</code>中，没有反向的<code>Range</code>，即<code>Range</code>的<font color=Blue>起始值不能大于结束值</font>。一旦出现这种情况，<font color=LightSeaGreen>编译器不会报错，但运行的时候会发生崩溃</font>。在实际的编程上，可以使用<code>Range</code>的<code>reversed()</code>方法来实现相同的效果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1</span> ... <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> {
</span></span><span style="display:flex;"><span>    debugPrint(i) <span style="color:#75715e">// 运行时发生崩溃</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> ix <span style="color:#66d9ef">in</span> (<span style="color:#ae81ff">1.</span>..<span style="color:#ae81ff">3</span>).reversed() {
</span></span><span style="display:flex;"><span>    debugPrint(ix) <span style="color:#75715e">// 3，2，1</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在实际编程中，可以使用<code>Range</code>的<code>contains(_:)</code>实例方法来测试一个值是否在给定的范围内。例如，可以测试某个数字是否在某个范围内：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> ix = <span style="color:#ae81ff">2</span> <span style="color:#75715e">// ... an Int ...</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#ae81ff">1.</span>..<span style="color:#ae81ff">3</span>).contains(ix) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果只是想测试<code>Range</code>中是否包含某个数字，<code>Range</code>的端点数值可以为<code>Double</code>类型。下面的代码中，测试变量<code>d</code>是否在<code>(0.1...0.9)</code>中是可行的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> d = <span style="color:#ae81ff">0.3</span> <span style="color:#75715e">// ... a Double ...</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#ae81ff">0.1</span>...<span style="color:#ae81ff">0.9</span>).contains(d) {
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;contains </span><span style="color:#e6db74">\(</span>d<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// &#34;contains 0.3&#34;</span>
</span></span></code></pre></div><p><code>Range</code>的另一个常见用途是对一个序列进行索引。下面是获取一个字符串的第二、第三和第四个字符的一种方法。如果把字符串转换为一个字符数组，可以用一个<code>Int Range</code>作为该数组的索引：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s = <span style="color:#e6db74">&#34;hello&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> arr = Array(s)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> result = arr[<span style="color:#ae81ff">1.</span>..<span style="color:#ae81ff">3</span>]
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s2 = String(result) <span style="color:#75715e">// &#34;ell&#34;</span>
</span></span><span style="display:flex;"><span>debugPrint(arr) <span style="color:#75715e">// [&#34;h&#34;, &#34;e&#34;, &#34;l&#34;, &#34;l&#34;, &#34;o&#34;]</span>
</span></span><span style="display:flex;"><span>debugPrint(s2) <span style="color:#75715e">// &#34;ell&#34;</span>
</span></span></code></pre></div><p>字符串本身是一个字符序列，所以可以使用<code>Range</code>来直接索引字符串，但是它必须是一个<code>String.Index</code>的<code>Range</code>，但是很难获取：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s = <span style="color:#e6db74">&#34;hello&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> ix1 = s.index(s.startIndex, offsetBy:<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> ix2 = s.index(ix1, offsetBy: <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s2 = s[ix1...ix2] <span style="color:#75715e">// &#34;ell&#34;</span>
</span></span></code></pre></div><p>可以在<code>Range</code>字面常量上省略一个端点，形成一个部分<code>Range</code>。有三种部分<code>Range</code>表达式，对应于三种类型的<code>Range</code>结构，分别是省略前端点的的<code>..&lt;</code>,省略前端点的<code>...</code>以及省略后端点的<code>...</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> str = <span style="color:#e6db74">&#34;hello&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> range1 = str.startIndex..&lt;str.endIndex <span style="color:#75715e">// Range</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> range2 = ..&lt;str.endIndex <span style="color:#75715e">// PartialRangeUpTo</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> range3 = ...str.index(before: str.endIndex) <span style="color:#75715e">// PartialRangeUpThrough</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> range4 = str.startIndex... <span style="color:#75715e">// PartialRangeFrom</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>debugPrint(str)
</span></span><span style="display:flex;"><span>debugPrint(str[range1])
</span></span><span style="display:flex;"><span>debugPrint(str[range2])
</span></span><span style="display:flex;"><span>debugPrint(str[range3])
</span></span><span style="display:flex;"><span>debugPrint(str[range4])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;hello&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;hello&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;hello&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;hello&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;hello&#34;</span>
</span></span></code></pre></div><p>如果需要将一个部分<code>Range</code>转换为一个<code>Range</code>，可以调用<code>relative(to:)</code>方法。但一般来说，不需要这样做，因为部分<code>Range</code>可以用在任何需要使用<code>Range</code>的地方：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s = <span style="color:#e6db74">&#34;hello&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> ix2 = s.index(before: s.endIndex)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s2 = s[..&lt;ix2] <span style="color:#75715e">// &#34;hell&#34;</span>
</span></span><span style="display:flex;"><span>debugPrint(s2) <span style="color:#75715e">// &#34;hell&#34;</span>
</span></span><span style="display:flex;"><span>debugPrint(s[s.startIndex..&lt;s.endIndex]) <span style="color:#75715e">//&#34;hello&#34;</span>
</span></span><span style="display:flex;"><span>debugPrint((..&lt;s.endIndex).relative(to: s) == s.startIndex ..<span style="color:#f92672">&lt;</span> s.endIndex) <span style="color:#75715e">// true</span>
</span></span></code></pre></div><h2 id="元组">元组</h2>
<p>元组是一个<font color=Blue>由多个值组成的轻量级自定义有序集合</font>。作为一种类型，它的表达方式是用圆括号包围所含数值的类型，用逗号隔开。下面是一个元组变量的声明，其类型是一个<code>Int</code>和一个<code>String</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> pair : (Int, String)
</span></span></code></pre></div><p>元组字面值也是以同样的方式表达，用圆括号包含值，每个值以逗号隔开。但这些值的类型也可以由编译器推断出来，无需显式声明：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> pair1 : (Int, String) = (<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;Two&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> pair2 = (<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;Two&#34;</span>)
</span></span></code></pre></div><p>元组是<code>Swift</code>语言特有的，与<code>Cocoa</code>和<code>Objective-C</code>不兼容。元组是<font color=red>解决一个函数只能返回一个值这个问题的好方法</font>。元组是一个特殊的值，但在它里面包含了多个值，所以可以使用元组作为一个函数的返回类型以返回多个值。</p>
<p>元组也提供了很多便利性，可以一次<font color=LightSeaGreen>同时赋值多个不同类型的变量，也可以一次同时声明和初始化多个不同类型的变量</font>，如下所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> ix: Int
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s: String
</span></span><span style="display:flex;"><span>(ix, s) = (<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;Two&#34;</span>)
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> (ix, s) = (<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;Two&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> (ix1, s1) = (<span style="color:#ae81ff">12</span>, <span style="color:#e6db74">&#34;name&#34;</span>)
</span></span></code></pre></div><p>如果要将元组中的值赋给某些变量，但又要<font color=LightSeaGreen>忽略元组中的某个值的时候，可以在对应位置使用下划线</font>。下面的代码就是只取元组中的第二个值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> pair = (<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;Two&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> (<span style="color:#66d9ef">_</span>, s) = pair <span style="color:#75715e">// now s is &#34;Two</span>
</span></span></code></pre></div><p>使用元组<font color=Blue>可以不借助临时变量来交换两个变量的值</font>，同时也是安全的。使用元组来交换两个变量时，只需要交换元组中变量的位置即可：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> s1 = <span style="color:#e6db74">&#34;hello&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> s2 = <span style="color:#e6db74">&#34;world&#34;</span>
</span></span><span style="display:flex;"><span>(s1, s2) = (s2, s1) <span style="color:#75715e">// now s1 is &#34;world&#34; and s2 is &#34;hello&#34;</span>
</span></span></code></pre></div><p>访问元组中的值有两种方式。第一种是使用索引来访问元组中的值。例如，上面的<code>pair</code>元组中的第一个值可以使用<code>pair.0</code>来访问，第二个可以使用<code>pair.1</code>来访问。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> pair = (<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;Two&#34;</span>)
</span></span><span style="display:flex;"><span>pair.<span style="color:#ae81ff">0</span> = <span style="color:#ae81ff">2</span> <span style="color:#75715e">// now pair is (2, &#34;Two&#34;)</span>
</span></span></code></pre></div><p>第二种方式是<font color=LightSeaGreen>使用标签来访问元组中的值</font>。但在元组声明的时候就需要先加上标签。元组的标签和函数的参数一样，必须作为类型声明的一部分出现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> pair : (first:Int, second:String) = (<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;Two&#34;</span>)
</span></span></code></pre></div><p>上面的例子也可以使用<code>let pair = (first:1, second:&quot;Two&quot;)</code>这种简单的方式声明。之后便能使用标签来访问元组中的值（此时仍然可以通过索引访问）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> pair = (first:<span style="color:#ae81ff">1</span>, second:<span style="color:#e6db74">&#34;Two&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> x = pair.first <span style="color:#75715e">// 1</span>
</span></span><span style="display:flex;"><span>pair.first = <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> y = pair.<span style="color:#ae81ff">0</span> <span style="color:#75715e">// 2</span>
</span></span></code></pre></div><p>在序列中使用<code>enumerated</code>方法既可以遍历元素也可以获得对应的索引。在下面的代码中，第一个<code>for in</code>中使用元组获取索引和元素，第二个<code>for in</code>中通过<code>offset</code>和<code>element</code>来获取：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s = <span style="color:#e6db74">&#34;hello&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (index, c) <span style="color:#66d9ef">in</span> s.enumerated() {
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;character </span><span style="color:#e6db74">\(</span>index<span style="color:#e6db74">)</span><span style="color:#e6db74"> is </span><span style="color:#e6db74">\(</span>c<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//character 0 is h</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//character 1 is e</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//character 2 is l</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//character 3 is l</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//character 4 is o</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> t <span style="color:#66d9ef">in</span> s.enumerated() {
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;character </span><span style="color:#e6db74">\(</span>t.offset<span style="color:#e6db74">)</span><span style="color:#e6db74"> is </span><span style="color:#e6db74">\(</span>t.element<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//character 0 is h</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//character 1 is e</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//character 2 is l</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//character 3 is l</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//character 4 is o</span>
</span></span></code></pre></div><p>需要特别注意的是，可以<font color=LightSeaGreen>将一个没有标签的元组赋值给一个有标签的对应元组</font>。相反，<font color=Blue>也可以将一个有标签的元组赋值给一个没有标签的元组</font>，下面代码都是可行的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> pair = (<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;Two&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> pairWithNames : (first:Int, second:String) = pair
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> ix = pairWithNames.first <span style="color:#75715e">// 1</span>
</span></span><span style="display:flex;"><span>pair = pairWithNames
</span></span></code></pre></div><p>但是，<font color=Blue>如果两个元组包含的相同的类型，但声明的标签不同，则不能相互赋值</font>。如下所示，虽然<code>pair1</code>和<code>pair2</code>的类型相同，但标签不同，会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> pair1 = (first: <span style="color:#ae81ff">1</span>, second: <span style="color:#e6db74">&#34;test&#34;</span>)
</span></span><span style="display:flex;"><span>debugPrint(pair1.first, pair1.<span style="color:#ae81ff">0</span>, pair1.second, pair1.<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> pair2 = (test1: <span style="color:#ae81ff">1</span>, test2: <span style="color:#e6db74">&#34;test2&#34;</span>)
</span></span><span style="display:flex;"><span>debugPrint(pair1.first, pair1.<span style="color:#ae81ff">0</span>, pair1.second, pair1.<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>pair1 = pair2 <span style="color:#75715e">// Cannot assign value of type &#39;(test1: Int, test2: String)&#39; to type &#39;(first: Int, second: String)&#39;</span>
</span></span></code></pre></div><p>可以在函数中传递元组，也可以在一个函数中返回一个没有标签的元组，<font color=LightSeaGreen>即使这个函数声明的返回值是带标签的元组</font>，如下所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">tupleMaker</span>() -&gt; (first: Int, second: String) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;Two&#34;</span>) <span style="color:#75715e">// no labels here</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> tuple = tupleMaker()
</span></span><span style="display:flex;"><span>debugPrint(tuple.first, tuple.second, tuple.<span style="color:#ae81ff">0</span>, tuple.<span style="color:#ae81ff">1</span>) <span style="color:#75715e">// 1 &#34;Two&#34; 1 &#34;Two&#34;</span>
</span></span></code></pre></div><h2 id="可选类型">可选类型</h2>
<p>可选的对象类型（实质上是一个枚举）包裹着另一个对象，这个被包裹的对象的类型可以为任何类型。可以使用<code>Optional</code>声明或者赋值一个可选变量：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> stringMaybe = Optional(<span style="color:#e6db74">&#34;howdy&#34;</span>)
</span></span><span style="display:flex;"><span>debugPrint(stringMaybe)
</span></span><span style="display:flex;"><span>stringMaybe = Optional(<span style="color:#e6db74">&#34;fareWell&#34;</span>)
</span></span><span style="display:flex;"><span>debugPrint(stringMaybe)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> stringMaybe1: String? = Optional(<span style="color:#e6db74">&#34;test&#34;</span>)
</span></span><span style="display:flex;"><span>debugPrint(stringMaybe1)
</span></span><span style="display:flex;"><span>stringMaybe1 = <span style="color:#e6db74">&#34;name&#34;</span>
</span></span><span style="display:flex;"><span>debugPrint(stringMaybe1)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//Optional(&#34;howdy&#34;)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//Optional(&#34;fareWell&#34;)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//Optional(&#34;test&#34;)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//Optional(&#34;name&#34;)</span>
</span></span></code></pre></div><p>声明可选值，通常不使用<code>Optional</code>初始化器，而是将某种类型的值分配或传递给一个已经声明成<code>Optional</code>的引用。在上面代码中，一旦<code>stringMaybe</code>被类型化为一个包裹着<code>String</code>的<code>Optional</code>，那么直接向其赋一个<code>String</code>是合法的，赋值的字符串被自动包装成一个<code>Optional</code>。</p>
<p>从形式上看，<code>Optional</code>是一个泛型，所以包裹一个字符串的<code>Optional</code>是一个<code>Optional&lt;String&gt;</code>。实际上，不必这样写，<code>Swift</code>语言支持用<font color=red>语法糖</font>来表达一个<code>Optional</code>类型：被包装类型的名称后面跟一个问号即可。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> stringMaybe : String?
</span></span></code></pre></div><p>如果期望是一个<code>Optional</code>包装的某种类型，可以传递一个包装类型的值来代替。这是因为参数传递就像赋值一样：<font color=red>一个未被包裹的值会被隐含地包裹起来</font>。如果一个函数期望一个包裹着字符串的<code>Optional</code>参数，可以直接传递一个字符串参数，它将自动地转换成<code>Optional</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">optionalExpecter</span>(<span style="color:#66d9ef">_</span> s: String?) { <span style="color:#75715e">// ... here, s will be an Optional wrapping a String ... </span>
</span></span><span style="display:flex;"><span>    debugPrint(s)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>optionalExpecter(<span style="color:#e6db74">&#34;howdy&#34;</span>) <span style="color:#75715e">// console debugPrints: Optional(&#34;howdy&#34;)</span>
</span></span></code></pre></div><p>如果期望的是一个非<code>Optional</code>的类型，实际上却传递了一个<code>Optional</code>的类型，那么编译器将会报错。下面的代码会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">realStringExpecter</span>(<span style="color:#66d9ef">_</span> s: String) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> stringMaybe: String? = <span style="color:#e6db74">&#34;howdy&#34;</span>
</span></span><span style="display:flex;"><span>realStringExpecter(stringMaybe) <span style="color:#75715e">// compile error: Value of optional type &#39;String?&#39; must be unwrapped to a value of type &#39;String&#39;</span>
</span></span></code></pre></div><p>在与<code>nil</code>以外的东西进行相等比较时，<code>Optional</code>得到了特殊的待遇：<font color=LightSeaGreen>真正被比较的是被包裹的值</font>，而不是<code>Optional</code>本身被比较：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s: String? = <span style="color:#e6db74">&#34;Howdy&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> s == <span style="color:#e6db74">&#34;Howdy&#34;</span> { <span style="color:#75715e">// ... they _are_ equal!</span>
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面的例子中，<code>Swift</code>不会将<code>Optional</code>本身与<code>&quot;Howdy&quot;</code>进行比较，<font color=red>而是自动地（安全地）将其包装值（如果有）与<code>&quot;Howdy&quot;</code>进行比较</font>。如果包裹的值是<code>&quot;Howdy&quot;</code>，则比较成功。如果被包装的值不是<code>&quot;Howdy&quot;</code>，则比较失败。如果没有被包装的值（也就是为<code>nil</code>），那么比较也会安全地失败。</p>
<p>能够使用<code>==</code>操作符，则被包裹的类型必须遵循<code>Equatable</code>协议。如果没有遵守这个协议，编译器会阻止一个<code>Optional</code>类型使用<code>==</code>进行比较。</p>
<h1 id="对象类型">对象类型</h1>
<p><code>Swift</code>中有三种对象（<code>object</code>）类型，它们分别是<code>enum,struct,class</code>。对象类型的作用域取决于它声明所在的位置，可能出现的位置有三种：</p>
<ul>
<li>
<p>顶层声明：声明在文件顶部，默认情况下对于同一个<code>module</code>中的所有文件都是可见的。</p>
</li>
<li>
<p>另一个类型中内嵌：在另一个类型的声明中内嵌声明一个类型是很有用的，相当于给这个内嵌类型一个命名空间。</p>
</li>
<li>
<p>函数体中：在函数体中声明的对象类型的生命周期只存在于包含它的花括号内，这样的声明是合法的，但使用场景较少。</p>
</li>
</ul>
<p>对于任何对象类型声明时都可以在其花括号内包含以下五个方面的内容：</p>
<ol>
<li>初始化器：初始化器是一个函数，以一种特殊的方式声明和调用，以生成对象实例。</li>
<li>属性：在对象类型声明的顶层声明的变量是一个属性。</li>
<li>方法：在对象类型声明的顶层声明的函数是一个方法。</li>
<li>下标：下标是一种特殊的方法，通过在实例引用或类型名称后面加上方括号来调用。</li>
<li>内嵌类型：一个对象类型声明可以包含另一个对象类型声明（内嵌类型）。</li>
</ol>
<h2 id="初始化器">初始化器</h2>
<p>初始化器是一个用于产生对象实例的函数。严格地说，<font color=LightSeaGreen>初始化器是一个静态方法，因为它是被对象类型调用的</font>。它是通过特殊的语法来调用的：类型的名字后面直接加上括号。当一个初始化器被调用时，一个新的实例被创建并作为结果返回：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> dog = Dog()
</span></span></code></pre></div><p>上面的代码中<code>Dog()</code>调用了一个初始化器，尽管<code>Dog</code>类没有声明任何初始化器，但并没有编译错误。这是因为，<font color=LightSeaGreen>如果没有自定义初始化器，则编译器会自动生成一个无参数的初始化器</font>。</p>
<p>除了使用编译器自动生成的初始化器，也可以编写自己的初始化器。初始化器是一种特殊的函数，有特殊的声明语法，不需要使用<code>func</code>关键字、箭头符号以及返回值类型。</p>
<p>自定义初始化器的声明使用关键字<code>init</code>和一个参数列表，然后紧跟函数体。一个对象类型可以有多个初始化器，以其参数（个数和类型）来区分：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name = <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> license = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(name: String) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.license = license
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(name: String, license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.license = license
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面自定义了三个初始化器，即提供了三种方式创建<code>Dog</code>实例。现在已经不能使用没有初始化参数的初始化器了，<font color=red>因为一旦有自定义的初始化器，编译器就不会再自动生成无参的初始化器了</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> fido = Dog(name: <span style="color:#e6db74">&#34;Fido&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> rover = Dog(license: <span style="color:#ae81ff">1234</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> spot = Dog(name: <span style="color:#e6db74">&#34;Spot&#34;</span>, license: <span style="color:#ae81ff">1357</span>)
</span></span></code></pre></div><p>也可以显式声明无参的自定义初始化器，以避免使用没有参数的初始化器时编译报错。下面的代码中声明了无参的初始化器<code>init()</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name = <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> license = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>() {
</span></span><span style="display:flex;"><span>       <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(name: String) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.license = license
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(name: String, license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.license = license
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>当实例生成时，如果实例属性还没有初始值，则编译器会报错。因此，<font color=LightSeaGreen>一个属性可以作为其声明的一部分被初始化，或被其中的每个初始化器初始化</font>。</p>
<p><code>Swift</code>编译器<font color=LightSeaGreen>强制要求所有的实例属性都要正确地初始化</font>，这是<code>Swift</code>的一个重要特征。相比之下，<code>Objective-C</code>的实例属性可以不初始化，而且经常会这样，导致可能出现奇怪的错误。</p>
<p>因为在初始化器中设置一个实例属性也算作初始化，所以即使实例属性是用<code>let</code>声明的常量，也是合法的。下面的代码将<code>name</code>和<code>license</code>都声明为常量属性，在初始化器中再初始化也是合法的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> name: String
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> license: Int
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(name: String, license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.license = license
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>有时，在初始化过程中，暂时不能初始化一个实例属性为有意义的值。也许这个属性的初始值要在这个实例出现后的某个时间点才能得到。这种情况<font color=red>与所有实例属性在其声明中或通过初始化器进行初始化的要求相冲突</font>。可以通过分配一个默认的初始值来规避这个问题，但此时无法向你自己的代码传达这样一个事实：这个默认值不是<code>真实有效</code>的值。</p>
<p>一个常见的解决方案是将实例属性声明为一个<code>Optional</code>类型的<code>var</code>。<code>Optional</code>类型有一个值<code>nil</code>，表示没有提供<code>真实有效</code>的值，并且一个<code>Optional var</code>会自动初始化为<code>nil</code>。</p>
<p>因此，代码中可以用<code>nil</code>来测试这个<code>Optional</code>的实例属性，如果它是<code>nil</code>，就暂时不要使用这个属性。该属性会在某个时候被赋予<code>真实有效</code>的值，这个值是被包裹在<code>Optional</code>中的。</p>
<p>一个初始化器<font color=red>可以引用一个已经初始化的实例属性，也可以引用一个未初始化的实例属性，以便初始化它</font>。<font color=LightSeaGreen>除了这种情况，在所有实例属性被初始化之前，初始化器不得显式或隐式地引用自己</font>。这条规则保证了实例在使用之前已经完全形成。</p>
<h3 id="代理初始化器">代理初始化器</h3>
<p>在初始化器中，<font color=Blue>如果调用了另一个初始化器，那这个初始化器被称为代理初始化器</font>。代理初始化器<font color=LightSeaGreen>调用的其它初始化器必须已经将所有的存储属性初始化</font>，否则会出现编译错误。</p>
<p>代理初始化器似乎是过早使用<code>self</code>调用函数的一个反例，但事实并不是这样，它使用<code>self</code>调用函数是为了初始化储存属性。而且代理初始化器在<font color=red>调用其它初始化器之前不能使用<code>self</code>，即使是给存储属性赋初值也不行</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Digit</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> number: Int
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> meaningOfLife: Bool
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(number: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.number = number
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.meaningOfLife = <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>() { <span style="color:#75715e">// this is a delegating initializer</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.meaningOfLife = <span style="color:#66d9ef">false</span> <span style="color:#75715e">//&#39;self&#39; used before &#39;self.init&#39; call or assignment to &#39;self&#39;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.<span style="color:#66d9ef">init</span>(number: <span style="color:#ae81ff">42</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.meaningOfLife = <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在代理初始化器中，不能再对<code>let</code>常量属性赋值，因为<font color=red>调用其它初始化器时已经将常量属性赋了初始值，如果再次对其赋值会出现编译错误</font>。因为在代理初始化器中可以调用其它初始化器，千万不要形成递归调用，下面代码就会产生递归引用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Digit</span> {  <span style="color:#75715e">// do not do this!</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> number: Int = <span style="color:#ae81ff">100</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(value: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.<span style="color:#66d9ef">init</span>(number: value)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(number: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.<span style="color:#66d9ef">init</span>(value: number)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="可失败的初始化器">可失败的初始化器</h3>
<p>一个初始化器可以返回一个可选的新实例，如果返回<code>nil</code>表示初始化失败，这种初始化器被称为可失败的初始化器。声明可失败的初始化器很简单，只要在<code>init</code>后面添加一个<code>?</code>即可:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> name: String
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> license: Int
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>?(name: String, license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> name.isEmpty {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>  <span style="color:#75715e">// 返回nil</span>
</span></span><span style="display:flex;"><span>        } 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> license <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>        } 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.license = license
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="属性">属性</h2>
<p>实例属性在声明的同时可以进行初始化，但<font color=red>初始化某个实例属性时不能获取其它实例属性或调用一个实例方法，因为此时实例尚未生成</font>。下面代码会产生编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Moi</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> first = <span style="color:#e6db74">&#34;Matt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> last = <span style="color:#e6db74">&#34;Neuburg&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> whole = <span style="color:#66d9ef">self</span>.first <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">self</span>.last <span style="color:#75715e">// compile error: Cannot find &#39;self&#39; in scope</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>解决上面的编译报错有三种方法，第一种是把<code>whole</code>声明为计算属性而非存储属性，因为<font color=red>计算属性是在实例初始化完成之后才会被调用的</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Moi</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> first = <span style="color:#e6db74">&#34;Matt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> last = <span style="color:#e6db74">&#34;Neuburg&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> whole: String {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.first <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">self</span>.last
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>第二种方法是把<code>whole</code>声明为<code>lazy</code>的<code>var</code>变量。同计算变量一样，<code>lazy</code>变量也是要等实例初始化完成之后才会被调用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Moi</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> first = <span style="color:#e6db74">&#34;Matt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> last = <span style="color:#e6db74">&#34;Neuburg&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">lazy</span> <span style="color:#66d9ef">var</span> whole = <span style="color:#66d9ef">self</span>.first <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">self</span>.last
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>第三种方法就是使用匿名函数的<code>define-and-call</code>进行初始化。因为要在匿名函数中使用<code>self</code>，所以也需要把实例属性声明为<code>lazy</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Moi</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> first = <span style="color:#e6db74">&#34;Matt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> last = <span style="color:#e6db74">&#34;Neuburg&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">lazy</span> <span style="color:#66d9ef">var</span> whole: String = {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">var</span> s = <span style="color:#66d9ef">self</span>.first
</span></span><span style="display:flex;"><span>        s.append(<span style="color:#e6db74">&#34; &#34;</span>)
</span></span><span style="display:flex;"><span>        s.append(<span style="color:#66d9ef">self</span>.last)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> s
</span></span><span style="display:flex;"><span>    }()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>不像实例属性，<font color=red>静态属性可以在初始化的时候引用其他静态属性</font>，因为静态属性初始化器本身就是<code>lazy</code>的。下面的代码不会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Greeting</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> friendly = <span style="color:#e6db74">&#34;hello there&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> hostile = <span style="color:#e6db74">&#34;go away&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> ambivalent = friendly <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; but &#34;</span> <span style="color:#f92672">+</span> hostile
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>debugPrint(Greeting.ambivalent)
</span></span></code></pre></div><p>上面的代码中，静态属性进行初始化的时候省略了<code>self</code>，这是因为它隐含地包含了<code>self</code>。对于静态属性来说，它的<code>self</code>表示类型本身。实际上在静态属性初始化时，如果要引用其它静态属性，前面加上自身的类型会有更好的可读性：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Greeting</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> friendly = <span style="color:#e6db74">&#34;hello there&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> hostile = <span style="color:#e6db74">&#34;go away&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> ambivalent = Greeting.friendly <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; but &#34;</span> <span style="color:#f92672">+</span> Greeting.hostile
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>需要特别注意的是，在声明静态计算变量时，<font color=LightSeaGreen>如果使用匿名函数的<code>define-and-call</code>初始化，不能在匿名函数中使用<code>self</code>（认为这是一个系统<code>bug</code>）</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Greeting</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> friendly = <span style="color:#e6db74">&#34;hello there&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> hostile = <span style="color:#e6db74">&#34;go away&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">var</span> ambivalent: String = {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.friendly <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; but &#34;</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">self</span>.hostile <span style="color:#75715e">// compile error: Cannot find &#39;self&#39; in scope</span>
</span></span><span style="display:flex;"><span>    }()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Greeting</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> friendly = <span style="color:#e6db74">&#34;hello there&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> hostile = <span style="color:#e6db74">&#34;go away&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">var</span> ambivalent: String = {
</span></span><span style="display:flex;"><span>        friendly <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; but &#34;</span> <span style="color:#f92672">+</span> hostile <span style="color:#75715e">// 省略self才不会报错</span>
</span></span><span style="display:flex;"><span>    }()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="方法">方法</h2>
<p>在静态/类成员和实例成员之间存在着一种隔阂，尽管它们被声明在同一个对象类型中，但属于不同的世界。一个静态/类方法不能引用<code>实例</code>，因为静态方法中没有实例。因此，一个静态/类方法<font color=red>不能直接引用任何实例属性或调用任何实例方法</font>。另一方面，一个实例方法可以引用类型，因此可以访问静态/类的属性，能调用静态/类方法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClass</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> s = <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">store</span>(<span style="color:#66d9ef">_</span> s: String) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.s = s
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;MyClass test&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> m = MyClass()
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> f = MyClass.store(m) <span style="color:#75715e">// what just happened!?</span>
</span></span><span style="display:flex;"><span>f(<span style="color:#e6db74">&#34;s&#34;</span>)
</span></span><span style="display:flex;"><span>debugPrint(m.s)
</span></span></code></pre></div><p>实际上，<font color=red>实例方法也是一种静态/类方法</font>。在上面的代码中，尽管<code>store</code>是一个实例方法，但可以通过类型来调用，<font color=LightSeaGreen>只需把一个实例参数传进去</font>。</p>
<h2 id="下标">下标</h2>
<p>下标是一种方法，它通过将包含参数的方括号直接附加到一个对象的引用上来调用。可以把这个功能用于任何你喜欢的地方，但它特别适用于这样的情况：一个对象类型，<font color=Blue>其元素可以通过键或索引来访问</font>。</p>
<p>声明下标方法有点像普通函数的声明又有点像计算属性的声明。它<font color=red>可以接受参数，当下标方法被调用时，参数可以出现在方括号中</font>。一个下标就像一个计算属性，它的调用就像对一个属性的引用：你可以获取它的值，也可以向它赋值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Digit</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> number: Int
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(<span style="color:#66d9ef">_</span> n: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.number = n
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">subscript</span>(ix: Int) -&gt; Int { <span style="color:#75715e">// ① ②</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">get</span> { <span style="color:#75715e">// ③</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> s = String(<span style="color:#66d9ef">self</span>.number)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> Int(String(s[s.index(s.startIndex, offsetBy: ix)]))<span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol>
<li>
<p>关键字<code>sbuscript</code>后面紧跟参数列表，说明方括号内要出现哪些参数。默认情况下，参数名不会被外化。如果要外化参数名，需要在内部参数前外化。</p>
</li>
<li>
<p>然后是传出（调用<code>getter</code>函数时）或传入（调用<code>setter</code>函数时）值的类型。</p>
</li>
<li>
<p>最后是花括号，其内容与计算属性的内容完全一样。可以用<code>get</code>和花括号表示<code>getter</code>函数，用<code>set</code>和花括号表示<code>setter</code>函数。<code>setter</code>函数可以被省略，在这种情况下，<code>get</code>这个词和它的花括号可以被省略。如果<code>getter</code>函数<font color=Blue>只由一条语句组成，可以省略关键字<code>return</code></font>。<code>setter</code>函数接收的新值是<code>newValue</code>，但可以通过在<code>set</code>这个词后面的小括号里提供一个不同的名字来实现自定义名字。</p>
</li>
</ol>
<p>下面代码调用了<code>subscript</code>中的<code>getter</code>的方法。在<code>Digit</code>实例后面跟着方括号，方括号里面有<code>Int</code>参数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> d = Digit(<span style="color:#ae81ff">1234</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> a Digit = d[<span style="color:#ae81ff">1</span>]
</span></span></code></pre></div><p>下面的代码中<code>Digit</code>类型中包含了<code>subscript</code>下标方法，并且下标方法中也包含了<code>setter</code>，可以使用<code>d[0] = 2</code>这样的语句来访问下标的<code>setter</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Digit</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> number: Int
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(<span style="color:#66d9ef">_</span> n: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.number = n
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">subscript</span>(ix: Int) -&gt; Int {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">get</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> s = String(<span style="color:#66d9ef">self</span>.number)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> Int(String(s[s.index(s.startIndex, offsetBy: ix)]))<span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">set</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">var</span> s = String(<span style="color:#66d9ef">self</span>.number)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> i = s.index(s.startIndex, offsetBy: ix)
</span></span><span style="display:flex;"><span>            s.replaceSubrange(i...i, with: String(newValue))
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">self</span>.number = Int(s)<span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>一种类型中可以声明多个<code>subscript</code>方法，以参数个数和类型进行区分。从<code>Swift 5.1</code>开始，<font color=LightSeaGreen><code>subscript</code>方法可以是静态的。从<code>Swift 5.2</code>开始，<code>subscript</code>方法可以有默认参数</font>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">NewDigit</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> number: Int
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(<span style="color:#66d9ef">_</span> n: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.number = n
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">subscript</span>(ix: Int) -&gt; Int {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">get</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> s = String(<span style="color:#66d9ef">self</span>.number)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> Int(String(s[s.index(s.startIndex, offsetBy: ix)]))<span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">set</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">var</span> s = String(<span style="color:#66d9ef">self</span>.number)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> i = s.index(s.startIndex, offsetBy: ix)
</span></span><span style="display:flex;"><span>            s.replaceSubrange(i...i, with: String(newValue))
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">self</span>.number = Int(s)<span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">subscript</span>(index: String) -&gt; Int {
</span></span><span style="display:flex;"><span>        debugPrint(index)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">subscript</span>(index: Double = <span style="color:#ae81ff">0</span>) -&gt; Int {
</span></span><span style="display:flex;"><span>        debugPrint(index)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>需要注意的是对于下标的重载来说，<font color=red>如果均没有使用外部参数，并且只是内部参数名不同，参数的个数、类型以及顺序都相同的话，会出现编译错误</font>，这是因为没有外部参数时仅使用方括号调用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">subscript</span>(ix: Int) -&gt; Int {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">get</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> s = String(<span style="color:#66d9ef">self</span>.number)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Int(String(s[s.index(s.startIndex, offsetBy: ix)]))<span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">set</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">var</span> s = String(<span style="color:#66d9ef">self</span>.number)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> i = s.index(s.startIndex, offsetBy: ix)
</span></span><span style="display:flex;"><span>        s.replaceSubrange(i...i, with: String(newValue))
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.number = Int(s)<span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">subscript</span>(newIndex: Int) -&gt; Int {
</span></span><span style="display:flex;"><span>    debugPrint(newIndex)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果只是外部参数不同，内部参数个数和类型都相同，则不会出现编译错误，因为编译器会认为这是不同的<code>subscript</code>方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name: String
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> license: Int
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>?(name: String, license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> name.isEmpty {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>  <span style="color:#75715e">// 返回nil</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> license <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.license = license
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">subscript</span>(at index: Int) -&gt; String {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">get</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">self</span>.name
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">set</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">self</span>.name = newValue
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">subscript</span>(<span style="color:#66d9ef">for</span> index: Int) -&gt; String {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">get</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">self</span>.name
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">set</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">self</span>.name = newValue
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> dog = Dog(name: <span style="color:#e6db74">&#34;test&#34;</span>, license: <span style="color:#ae81ff">1345</span>)
</span></span><span style="display:flex;"><span>dog?[at: <span style="color:#ae81ff">123</span>]
</span></span><span style="display:flex;"><span>dog?[<span style="color:#66d9ef">for</span>: <span style="color:#ae81ff">134</span>]
</span></span></code></pre></div><h2 id="内嵌类型">内嵌类型</h2>
<p>一个类型在声明在另一个类型里面，就会形成内嵌类型。嵌套的对象类型与其他对象类型没有什么不同，但是从外部引用内嵌类型的规则发生了变化，<font color=LightSeaGreen>外部的对象类型作为一个命名空间，必须明确地被引用才能访问嵌套的对象类型</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Noise</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">var</span> noise = <span style="color:#e6db74">&#34;woof&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(Dog.Noise.noise)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 访问静态属性</span>
</span></span><span style="display:flex;"><span>Dog.Noise.noise = <span style="color:#e6db74">&#34;arf&#34;</span>
</span></span></code></pre></div><p>在上面的代码中，结构体<code>Noise</code>定义在类<code>Dog</code>中，它不是自由的，明确地与<code>Dog</code>类相关联，属于<code>Dog</code>中的类型。不同的命名空间允许有相同的<code>Noise</code>类型存在，而不会产生冲突。</p>
<p>在<code>Swift</code>的内置类型中，经常使用命名空间来解决类型冲突。例如，<code>String</code>结构体是包含<code>Index</code>结构体的几个结构体之一，但它们并没有名字冲突。</p>
<p>嵌套的内部类型不能直接访问其外部类型的<font color=LightSeaGreen>实例成员，但是能直接访问其静态/类成员</font>。在下面的代码中，<code>Noise</code>类型不能直接访问<code>Dog</code>类型的实例方法<code>bark</code>，但是能直接访问它的静态属性<code>sound</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> sound = <span style="color:#e6db74">&#34;ruff&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Noise</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">var</span> noise = <span style="color:#e6db74">&#34;woof&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">barkTheDog</span>() {
</span></span><span style="display:flex;"><span>            bark()  <span style="color:#75715e">// compile error: Instance member &#39;bark&#39; of type &#39;Dog&#39; cannot be used on instance of nested type &#39;Dog.Noise&#39;</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">var</span> othernoise = sound <span style="color:#75715e">// fine</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(Dog.Noise.noise)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在上面的代码中，内嵌类型<code>Noise</code>能直接访问静态属性<code>sound</code>，而不需要使用<code>Dog.sound</code>，因为外层定义的静态属性<code>sound</code>，对于内嵌类型来说是全局的。</p>
<h1 id="枚举">枚举</h1>
<p>枚举是一种对象类型，其实例代表不同的预定义值，可以将这些预定义值看作是<font color=LightSeaGreen>一个已知可能性的列表</font>，枚举是表达一组常量的<code>Swift</code>方式。枚举声明包含<code>case</code>语句，一个<code>case</code>是一个可选值的名称，一个枚举实例准确地代表一种选择：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Filter</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> albums
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> playlists
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> podcasts
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> books
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面定义的枚举<code>Filter</code>没有初始化器，实际上可以自定义枚举初始化器。但有一个默认的初始化器，可能在大多数时候都会使用它&ndash;枚举的名称后面加上点号和其中一个<code>case</code>。</p>
<p>在使用<code>enum</code>声明枚举类型时，可以添加一个类型声明，但<font color=red>这种类型只限于数值型和字符串</font>。如果增加的类型是数值型，每个<code>case</code>都有默认值，默认值从<code>0</code>开始：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">PepBoy</span>: Int {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> manny
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> moe
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> jack
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在上面的代码中，<code>.manny</code>的默认值是<code>0</code>，<code>.moe</code>的值是<code>1</code>，以此类推。如果类型是字符串，在定义的时候如果不设置<code>case</code>对应的字符串，则默认值是每个<code>case</code>对应的名字。下面的代码中，<code>.albums</code>的默认值是<code>&quot;albums&quot;</code>，<code>.playlists</code>的值是<code>&quot;playlists&quot;</code>，依此类推：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Filter</span>: String {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> albums
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> playlists
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> podcasts
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> books
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="rawvalue">rawValue</h2>
<p>如果在声明带类型的枚举时，不想使用默认值，可以为每个<code>case</code>赋值。<code>case</code>所携带的值称为<code>raw value</code>。一个有类型声明的枚举隐含地遵循了<code>RawRepresentable</code>协议，这意味着它有一个<code>init(rawValue:)</code>初始化器和一个<code>rawValue</code>属性。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Normal</span>: Double {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> fahrenheit = <span style="color:#ae81ff">98.6</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> centigrade = <span style="color:#ae81ff">37</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">PepBoy</span>: Int {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> manny = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> moe <span style="color:#75715e">// 2 implicitly: 默认为2</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> jack = <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Filter</span>: String {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> albums = <span style="color:#e6db74">&#34;Albums&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> playlists = <span style="color:#e6db74">&#34;Playlists&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> podcasts = <span style="color:#e6db74">&#34;Podcasts&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> books = <span style="color:#e6db74">&#34;Audiobooks&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>带类型的枚举声明时，每个<code>case</code>的<code>raw value</code>必须保证是唯一的，否则会出现编译错误。因此，可以使用<code>raw value</code>实例化一个枚举，但使用<code>init(rawValue:)</code>时也可能失败，因为传入的<code>raw value</code>可能与<code>case</code>不匹配，所以它实际上是可失败的<code>init?(rawValue:)</code>。</p>
<h2 id="associated-values">Associated Values</h2>
<p>上面说的<code>raw value</code>对于每个<code>case</code>来说<font color=LightSeaGreen>都是固定的，在枚举类型声明的时候就已经确定了</font>。有一种方法可以构造一个<code>case</code>，使得其常量值可以在实例创建时才被设置，此时设置的值被称为<code>associated value</code>。</p>
<p>声明带<code>associated value</code>的枚举类型时，<font color=red>不能为整个枚举类型声明任何原始值类型</font>。而是在有需要的<code>case</code>上附加一个看起来像元组的表达式，即包含一个可能标记的类型列表的括号。与<code>rawValue</code>不同，<code>associated value</code>无类型上的限制：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">MyError</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> number(Int)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> message(String)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> fatal
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面代码的含义是：在实例化的时候，一个<code>.number case</code>的<code>MyError</code>实例必须被设置一个<code>Int</code>值，一个<code>.message case</code>的<code>MyError</code>实例必须被设置一个<code>String</code>值，而一个<code>.fatal case</code>的<code>MyError</code>实例不用设置任何值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> err1 : MyError = .number(<span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> num = <span style="color:#ae81ff">4</span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> err2 : MyError = .number(num)
</span></span></code></pre></div><p>如同在枚举实例被期望的地方使用点和枚举<code>case</code>一样，<font color=LightSeaGreen>当引用一个类型的静态/类成员的值是该类型的一个实例时</font>，可以做同样的事情。例如，<code>UIColor</code>有许多由<code>UIColor</code>实例生成的类属性，所以可以在预期有<code>UIColor</code>的地方省略<code>UIColor</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>p.trackTintColor = .red <span style="color:#75715e">// instead of UIColor.red</span>
</span></span></code></pre></div><p>类似地，假设有一个带有静态常量的结构体<code>Thing</code>，其值是<code>Thing</code>的实例。那么在声明<code>Thing</code>变量或者常量时可以使用点操作符来引用该静态常量：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Thing</span>: RawRepresentable {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> rawValue: Int
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> one: Thing = Thing(rawValue: <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> two: Thing = Thing(rawValue: <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> thing1: Thing = .one
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> thing2: Thing = .two
</span></span></code></pre></div><p>同样地，当一个类型有一个静态/类方法产生该类型的实例时，在<font color=LightSeaGreen>期望有一个该类型的实例时的地方，可以省略类型名，初始化器也是这样的方法</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> name: String
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">same</span>(text: String) -&gt; Dog {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Dog(name: text)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">dogExpecter</span>(<span style="color:#66d9ef">_</span> dog: Dog) {
</span></span><span style="display:flex;"><span>    debugPrint(dog.name)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>dogExpecter(.<span style="color:#66d9ef">init</span>(name: <span style="color:#e6db74">&#34;Fido&#34;</span>))
</span></span><span style="display:flex;"><span>dogExpecter(.same(text: <span style="color:#e6db74">&#34;Foo&#34;</span>))
</span></span></code></pre></div><p>实际上，一个<code>Optional</code>只是有两个<code>case</code>的枚举：<code>.none</code>和<code>.some</code>。如果它是<code>.none</code>，表示没有相关的值，相当于<code>nil</code>。如果它是<code>.some</code>，它就会携带包装好的值作为其关联值。</p>
<p>如果一个<code>case</code>的<code>associated value</code>类型有标签，<font color=LightSeaGreen>标签必须在初始化的时候使用</font>。在下面的代码中，<code>case fetal</code>有标签，需要在初始化时使用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">MyError2</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> number(Int)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> message(String)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> fatal(n: Int, s: String)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> err: MyError2 = .fatal(n: <span style="color:#f92672">-</span><span style="color:#ae81ff">12</span>, s: <span style="color:#e6db74">&#34;Oh the horror&#34;</span>)
</span></span></code></pre></div><p>默认情况<code>==</code>操作符不能直接用于比较带有<code>associated value</code>的枚举，否则会出现编译错误。下面代码中，因为直接比较两个枚举值，将出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">MyError2</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> number(Int)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> message(String)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> fatal(n: Int, s: String)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> err: MyError2 = .fatal(n: <span style="color:#f92672">-</span><span style="color:#ae81ff">12</span>, s: <span style="color:#e6db74">&#34;Oh the horror&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// operator &#39;==&#39; cannot be applied to operands of type &#39;MyError2&#39; and &#39;(Int, String) -&gt; MyError2&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> err == MyError2.fatal { <span style="color:#75715e">// compile error</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果声明带<code>associated value</code>枚举时显式地遵循<code>Equatable</code>协议，<code>==</code>操作符就能正常工作了。但前提是所有<code>associated value</code>类型本身都是遵循<code>Equatable</code>，否则也会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">MyError</span>: Equatable {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> number(Int)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> message(String)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> fatal
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> error: MyError = .fatal
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> error == .fatal {
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="enum-case-iteration">Enum Case Iteration</h2>
<p>如果声明的枚举类型遵循了<code>CaseIterable</code>协议，那么它就会有一个<code>allCases</code><font color=red>静态属性</font>，这个属性包含了该枚举的所有<code>case</code>值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Filter</span>: String, CaseIterable {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> albums = <span style="color:#e6db74">&#34;Albums&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> playlists = <span style="color:#e6db74">&#34;Playlists&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> podcasts = <span style="color:#e6db74">&#34;Podcasts&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> books = <span style="color:#e6db74">&#34;Audiobooks&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>debugPrint(Filter.allCases) <span style="color:#75715e">// [Command.Filter.albums, Command.Filter.playlists, Command.Filter.podcasts, Command.Filter.books]</span>
</span></span></code></pre></div><h2 id="enum-initializers">Enum Initializers</h2>
<p>一个显式枚举初始化器必须做默认初始化所做的事情：它必须返回枚举的一个<code>case</code>。要做到这一点，需要将<code>self</code>设置为该<code>case</code>。在下面的代码中，声明了枚举初始化器，以便它可以用一个数字参数进行初始化：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Filter</span>: String, CaseIterable {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> albums = <span style="color:#e6db74">&#34;Albums&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> playlists = <span style="color:#e6db74">&#34;Playlists&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> podcasts = <span style="color:#e6db74">&#34;Podcasts&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> books = <span style="color:#e6db74">&#34;Audiobooks&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>?(<span style="color:#66d9ef">_</span> ix: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span>Filter.allCases.indices.contains(ix) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span> = Filter.allCases[ix]
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>现在有三种方式可以创建一个<code>Filter</code>实例。第一种是使用<code>Filter</code>类型<code>+</code>点操作符，第二种是使用<code>rawValue</code>，第三种方式是使用上面自定义的初始化器：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> type1 = Filter.albums
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> type2 = Filter(rawValue: <span style="color:#e6db74">&#34;Playlists&#34;</span>)<span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> type3 = Filter(<span style="color:#ae81ff">2</span>) <span style="color:#75715e">// .podcasts</span>
</span></span><span style="display:flex;"><span>debugPrint(Filter.allCases) <span style="color:#75715e">// [Command.Filter.albums, Command.Filter.playlists, Command.Filter.podcasts, Command.Filter.books]</span>
</span></span><span style="display:flex;"><span>debugPrint(type1, type2, type3) <span style="color:#75715e">// Command.Filter.albums Command.Filter.playlists Optional(Command.Filter.podcasts)</span>
</span></span></code></pre></div><p>一个枚举类型可以有多个初始化器，枚举初始化器可以通过调用<code>self.init(...)</code>委托其他初始化器来完成初始化。唯一的要求是某个时刻，<code>self</code>必须设置为某个<code>case</code>。下面代码新增了一个可失败的初始化器，在其中调用了另一个初始化器：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Filter</span>: String, CaseIterable {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> albums = <span style="color:#e6db74">&#34;Albums&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> playlists = <span style="color:#e6db74">&#34;Playlists&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> podcasts = <span style="color:#e6db74">&#34;Podcasts&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> books = <span style="color:#e6db74">&#34;Audiobooks&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>?(<span style="color:#66d9ef">_</span> ix: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span>Filter.allCases.indices.contains(ix) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span> = Filter.allCases[ix]
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>?(<span style="color:#66d9ef">_</span> rawValue: String) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.<span style="color:#66d9ef">init</span>(rawValue: rawValue)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在上面的代码中，改进了<code>Filter</code>枚举，以便它可以用一个字符串的原始值进行初始化，而不必在调用中使用<code>rawValue：</code>。因此，声明了一个带有字符串参数可失败的初始化器，该参数委托给内置的可失败的<code>rawValue:</code>初始化器。</p>
<h2 id="enum-properties">Enum Properties</h2>
<p>枚举类型既可以有实例属性也可以有静态属性，但<font color=red>实例属性只能是计算属性不能是存储属性</font>，计算实例属性可以根据<code>self</code>的值变化而变化：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Filter</span>: String {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> albums = <span style="color:#e6db74">&#34;Albums&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> playlists = <span style="color:#e6db74">&#34;Playlists&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> podcasts = <span style="color:#e6db74">&#34;Podcasts&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> books = <span style="color:#e6db74">&#34;Audiobooks&#34;</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> query: MPMediaQuery {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">switch</span> <span style="color:#66d9ef">self</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> .albums:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> .albums()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> .playlists:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> .playlists()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> .podcasts:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> .podcasts()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> .books:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> .audiobooks()
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果一个枚举实例计算属性有<code>setter</code>方法，则其他代码可以赋值这个属性，但是<font color=red>更改这个计算属性的枚举实例本身必须是<code>var</code>而不是<code>let</code>声明的，否则会出现编译错误</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Silly</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> one
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> sillyProperty: String {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">get</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;Howdy&#34;</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">set</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//        </span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// do nothing</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> silly = Silly.one
</span></span><span style="display:flex;"><span>silly.sillyProperty = <span style="color:#e6db74">&#34;silly&#34;</span>
</span></span></code></pre></div><p>枚举类型的<font color=red>静态属性可以是一个<code>property wrapper</code>，但实例计算属性不能</font>，因为枚举类型的实例属性必须都是计算属性。</p>
<h2 id="method">method</h2>
<p>枚举类型既可以有实例方法也可以有静态方法。下面代码中声明的枚举类型<code>Shape</code>定义了一个实例方法<code>addShape</code>，它根据<code>self</code>的值完成对应的操作：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Shape</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> rectangle
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> ellipse
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> diamond
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">addShape</span>(to p: CGMutablePath, <span style="color:#66d9ef">in</span> r: CGRect) -&gt; () {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">switch</span> <span style="color:#66d9ef">self</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> .rectangle:
</span></span><span style="display:flex;"><span>            p.addRect(r)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> .ellipse:
</span></span><span style="display:flex;"><span>            p.addEllipse(<span style="color:#66d9ef">in</span>: r)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> .diamond:
</span></span><span style="display:flex;"><span>            p.move(to: CGPoint(x: r.minX, y: r.midY))
</span></span><span style="display:flex;"><span>            p.addLine(to: CGPoint(x: r.midX, y: r.minY))
</span></span><span style="display:flex;"><span>            p.addLine(to: CGPoint(x: r.maxX, y: r.midY))
</span></span><span style="display:flex;"><span>            p.addLine(to: CGPoint(x: r.midX, y: r.maxY)) p.closeSubpath()
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在前面说过<code>subscript</code>可以是静态方法，因此可以定义一个静态的<code>subscript</code>来获取遵循<code>CaseIterable</code>协议的某个<code>case</code>，代码如下所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Filter</span>: String, CaseIterable {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> albums = <span style="color:#e6db74">&#34;Albums&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> playlists = <span style="color:#e6db74">&#34;Playlists&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> podcasts = <span style="color:#e6db74">&#34;Podcasts&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> books = <span style="color:#e6db74">&#34;Audiobooks&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">subscript</span>(ix: Int) -&gt; Filter {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">guard</span> ix <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> ix <span style="color:#f92672">&lt;</span> Filter.allCases.count <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> .albums
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Filter.allCases[ix]
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>debugPrint(Filter[<span style="color:#ae81ff">2</span>])
</span></span></code></pre></div><p>如果枚举实例方法<font color=LightSeaGreen>想要修改枚举实例本身，则声明的时候要标记为<code>mutating</code></font>，因为它也是一种值类型。例如，一个枚举实例方法可能会赋值给<code>self</code>的一个实例属性，<font color=red>即使这是一个计算属性，这种赋值也是非法的，除非该方法被标记为<code>mutating</code></font>。调用<code>mutating</code>方法的实例变量必须声明为<code>var</code>。</p>
<p>在一个<code>mutating</code>枚举实例方法中，可以改变自身，方法是将另一个实例分配给<code>self</code>。下面的代码在<code>advance</code>方法中改变了自身：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Filter</span>: String, CaseIterable {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> albums = <span style="color:#e6db74">&#34;Albums&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> playlists = <span style="color:#e6db74">&#34;Playlists&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> podcasts = <span style="color:#e6db74">&#34;Podcasts&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> books = <span style="color:#e6db74">&#34;Audiobooks&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">subscript</span>(ix: Int) -&gt; Filter {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">guard</span> ix <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> ix <span style="color:#f92672">&lt;</span> Filter.allCases.count <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> .albums
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Filter.allCases[ix]
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">mutating</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">advance</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> cases = Filter.allCases
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">var</span> ix = cases.firstIndex(of: <span style="color:#66d9ef">self</span>)<span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span>        ix = (ix <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> cases.count
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span> = cases[ix]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="结构体">结构体</h1>
<p>结构体是<code>Swift</code>对象类型中的佼佼者。枚举由固定的<code>case</code>集合组成，是一种缩小的、专门的对象。在另一个极端，类往往会被证明是多余的，它有一些结构体所缺乏的功能，但如果不需要这些功能，结构体可能是更好的选择。</p>
<p>在<code>Swift</code>标头中声明的<code>200</code>多种对象类型中，可能有一半是类，有几十个是枚举，其余的都是结构体。<code>String</code>是一个结构体，<code>Int</code>是结构体，<code>Range</code>是结构体，<code>Array</code>也是一个结构体。</p>
<h2 id="init">init</h2>
<p>如果结构体<font color=LightSeaGreen>没有存储属性或者全部的存储属性在声明的时候已经有默认值，则会自动生成一个无参的初始化器<code>init()</code></font>。下面的代码中，编译器会为<code>Digit</code>自动生成一个无参初始化器<code>Digit()</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Digit</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> number = <span style="color:#ae81ff">42</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>一旦在代码中增加了新的初始化器，编译器将不会自动生成无参的初始化器。在下面的代码中，已经在<code>Digit</code>增加一个有参的初始化器，则无参的初始化器<code>Digit()</code>将会失效：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Digit</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> number = <span style="color:#ae81ff">42</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(number: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.number = number
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>此时，如果想要使用<code>Digit()</code>进行初始化，会出现编译报错。需要手动声明一个无参的初始化器，才能通过编译：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Digit</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> number = <span style="color:#ae81ff">42</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>() {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(number: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.number = number
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>有<font color=LightSeaGreen>存储属性且没有显式初始化器的结构体会自动获得一个从其实例属性派生的隐式初始化器</font>，这称为<code>memberwise initializer</code>(成员式初始化器)：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Test</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> number = <span style="color:#ae81ff">42</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name: String
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> age: Int
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> greeting = <span style="color:#e6db74">&#34;Hello&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面的代码是合法，虽然看起来没有履行在声明或者初始化器中初始化所有储存属性的契约。但实际上，因为没有自定义的初始化器，这个结构体会自动生成一个<code>memberwise initializer</code>(成员式初始化器)，在这个<code>memberwise initializer</code>初始化了所有未初始化的属性：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Test</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> number = <span style="color:#ae81ff">42</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name: String
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> age: Int
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> greeting = <span style="color:#e6db74">&#34;Hello&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> t1 = Test(number: <span style="color:#ae81ff">42</span>, name: <span style="color:#e6db74">&#34;matt&#34;</span>, age: <span style="color:#ae81ff">65</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> t2 = Test(name: <span style="color:#e6db74">&#34;matt&#34;</span>, age: <span style="color:#ae81ff">65</span>)
</span></span></code></pre></div><p>上面自动生成的<code>memberwise initializer</code>包含了<code>number,name,age</code>，不包括<code>greeting</code>。这是因为<code>greeting</code>是<font color=LightSeaGreen>使用<code>let</code>声明的，在声明的时候已经初始化了</font>。</p>
<p>因为<code>number</code>使用<code>var</code>声明，并且在声明的同时已经被初始化了，因此从<code>Swift 5.1</code>后在调用<code>memberwise initializer</code>时可以省略这种用<code>var</code>声明并且同时已经初始化属性：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> t2 = Test(name: <span style="color:#e6db74">&#34;matt&#34;</span>, age: <span style="color:#ae81ff">65</span>)
</span></span></code></pre></div><p>如果在结构体声明的时候，<font color=red>有自定义的初始化器或者属性声明为<code>private</code>(使用<code>let</code>声明并且已经初始化的属性除外)</font>，则编译器不会自动生成的<code>memberwise initializer</code>。</p>
<p>结构体中声明的<font color=LightSeaGreen>存储属性必须全部初始化</font>，不管是声明的时候初始化还是在所有的初始化器中初始化。如果一个结构体有多个初始化器，则可以在初始化器中通过<code>self.init()</code>调用其他初始化器。</p>
<h2 id="properties">Properties</h2>
<p>结构体可以有实例属性或者静态属性，二者都可以声明为存储或者计算属性。如果代码中想重新设置一个结构体实例属性的值，则该实例变量必须使用<code>var</code>声明，否则会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> d = Test(name: <span style="color:#e6db74">&#34;ddd&#34;</span>,age: <span style="color:#ae81ff">34</span>)
</span></span><span style="display:flex;"><span>d.name = <span style="color:#e6db74">&#34;new test&#34;</span>
</span></span></code></pre></div><h2 id="method-1">method</h2>
<p>结构体可以有实例方法和静态方法，包括<code>subscript</code>(下标)，<font color=LightSeaGreen>如果一个实例方法想要设置结构体中某个属性的值，那么这个方法一定要声明为<code>mutating</code>，并且调用这个方法的实例也必须使用<code>var</code>声明</font>，否则会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Digit</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">var</span> number: Int
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(<span style="color:#66d9ef">_</span> n: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.number = n
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">mutating</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">changeNumberTo</span>(<span style="color:#66d9ef">_</span> n: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.number = n
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> d = Digit(<span style="color:#ae81ff">123</span>)
</span></span><span style="display:flex;"><span>d.changeNumberTo(<span style="color:#ae81ff">42</span>)
</span></span></code></pre></div><p><code>subscript</code>下标或者计算属性的<code>set</code>方法默认认为是<code>mutating</code>，不必显式地声明为<code>mutating</code>。但是<font color=LightSeaGreen>如果在它们的<code>set</code>方法中要设置其他属性的值，必须显式地声明为<code>mutating</code></font>。声明为<code>mutating</code>的方法中可以使用该类型的另一个实例设置<code>self</code>的方式来改变自身。</p>
<h2 id="struct-as-namespace">Struct as Namespace</h2>
<p>经常使用<code>退化的结构体</code>作为常量的便利命名空间，之所以称为<code>退化的</code>，是因为结构体中全部为静态成员，并不打算使用这种对象类型来制造任何其它实例。</p>
<p><code>UserDefaults</code>是一种字典，每个值可以通过一个键来访问。这些键通常是字符串，一个常见的错误是使用键时拼错了键的名字，虽然在编译时不会报错，但代码将不能正常工作。</p>
<p>更好的方法是将这些键体现为常量字符串，并使用字符串的名称，如果错误地输入了一个名称，编译器会报错。<font color=red>带有静态成员的结构是定义常量字符串并将其名称集中到一个命名空间的好方法</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Default</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> rows = <span style="color:#e6db74">&#34;rows&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> columns = <span style="color:#e6db74">&#34;columns&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> hazyStripy = <span style="color:#e6db74">&#34;hazyStripy&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>现在就可以使用，<code>Default</code>中的静态成员作为<code>UserDefaults</code>的键来引用，例如使用<code>Default.rows</code>可以就代表<code>rows</code>字符串。</p>
<h1 id="classes">Classes</h1>
<p>虽然类和结构体有些相似，但类和结构体还是有一些关键区别：</p>
<ol>
<li>
<p>类是引用类型，类的实例有两个显著的特征，而这些特征对于结构体或枚举的实例来说是截然不同的。</p>
<ul>
<li>
<p>类的实例是<font color=red>原地是可变的</font>。即使一个类的实例的引用是用<code>let</code>声明的，也可以通过这个引用来改变一个实例属性的值。类的实例方法<font color=LightSeaGreen>从来不需要被标记为可变的（也不能被标记）</font>。</p>
</li>
<li>
<p>当一个给定的类的实例被分配给多个变量或作为参数传递给一个函数时，你会得到<font color=red>对一个相同对象的多个引用</font>。</p>
</li>
</ul>
</li>
<li>
<p>一个类可以有一个父类，它继承其父类的成员，类的继承层次可以形成一个分层的树结构。而<font color=red>结构体不能继承</font>。</p>
</li>
</ol>
<p>在<code>Objective-C</code>中，类是唯一的对象类型。一些内置的<code>Swift</code>结构类型可以神奇地与<code>Objective-C</code>的类类型衔接，但<font color=red>自定义结构类型却没有这种魔力</font>。因此，在用<code>Swift</code>进行<code>iOS</code>编程时，声明类而不是结构的一个原因是作为一种与<code>Objective-C</code>和<code>Cocoa</code>的互换形式。</p>
<h2 id="value-types-and-reference-types">Value Types and Reference Types</h2>
<p>在<code>Swift</code>中，<font color=red>结构体和枚举类型都是值类型，类是引用类型</font>。值类型不能就地可变，而类的实例是就地可变的。在下面的例子中，因为结构体是值类型，所以更改结构体实例的属性时，要将结构体实例用<code>var</code>声明，而不能用<code>let</code>声明：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Digit</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> number: Int
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(<span style="color:#66d9ef">_</span> n: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.number = n
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> d = Digit(<span style="color:#ae81ff">23</span>)
</span></span><span style="display:flex;"><span>d.number = <span style="color:#ae81ff">45</span>
</span></span></code></pre></div><p>实际上，当改变一个值类型的实例时，是在用一个不同的实例替换该实例。为了证明这一点，可以添加一个<code>setter</code>观察器。在下面的代码中，虽然改变的是只是属性<code>number</code>的值，但是<code>didSet</code>依然调用了，这说明该实例被替换了：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Digit</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> number: Int
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(<span style="color:#66d9ef">_</span> n: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.number = n
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> d: Digit = Digit(<span style="color:#ae81ff">234</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">didSet</span> {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;d was set&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>d.number = <span style="color:#ae81ff">456</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// &#34;d was set&#34;</span>
</span></span></code></pre></div><p>下面的代码解释了，如果值类型的实例引用是用<code>let</code>声明的，那么就不能对该实例进行改变。下面的代码将会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> d = Digit(<span style="color:#ae81ff">123</span>) <span style="color:#75715e">// Digit is a struct</span>
</span></span><span style="display:flex;"><span>d.number = <span style="color:#ae81ff">42</span> <span style="color:#75715e">// compile error</span>
</span></span></code></pre></div><p>但类不是值类型，它们是引用类型。对一个类实例的引用不一定要用<code>var</code>来声明，即使是使用<code>let</code>声明的，也可以通过该引用设置<code>var</code>属性：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name: String = <span style="color:#e6db74">&#34;Fido&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> rover = Dog()
</span></span><span style="display:flex;"><span>rover.name = <span style="color:#e6db74">&#34;Rover&#34;</span> <span style="color:#75715e">// fine</span>
</span></span></code></pre></div><p>在上面代码的最后一行，<code>rover</code>所指向的类实例被就地改变了。没有涉及到对<code>rover</code>的隐式赋值，所以<code>let</code>声明无力阻止这种变化。当属性被设置时，<code>Dog</code>变量上的<code>setter observer</code> 没有被调用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name: String = <span style="color:#e6db74">&#34;Fido&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> rover: Dog = Dog() { <span style="color:#75715e">// Dog is a class</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">didSet</span> {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;rover did set rover&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>rover.name = <span style="color:#e6db74">&#34;Rover&#34;</span> <span style="color:#75715e">// nothing in console</span>
</span></span></code></pre></div><p>上面的<code>didSet</code>观察器的代码没有执行，说明没有生成新的实例。如果显式地重新设置<code>rover</code>，就会调用<code>setter</code>观察器，但是它不会仅仅因为我们改变了已经被<code>rover</code>指向的狗的实例的一个属性而被调用。</p>
<p>值类型和引用类型之间的区别也可以在一个函数调用的参数中看到。当接收一个值类型的实例作为参数进入一个函数体时，如果试图赋值给它的实例属性，编译器将会报错：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">digitChanger</span>(<span style="color:#66d9ef">_</span> d: Digit) { <span style="color:#75715e">// Digit is a struct</span>
</span></span><span style="display:flex;"><span>    d.number = <span style="color:#ae81ff">42</span> <span style="color:#75715e">// compile error</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>因为<code>Digit</code>是结构体，上面的代码会报错<code>Cannot assign to property: 'd' is a 'let' constant</code>，因为函数参数默认是用<code>let</code>隐式声明的。但<code>Dog</code>是引用类型，可以就地改变，所以下面的代码不会报错：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">dogChanger</span>(<span style="color:#66d9ef">_</span> d: Dog) { <span style="color:#75715e">// Dog is a class</span>
</span></span><span style="display:flex;"><span>    d.name = <span style="color:#e6db74">&#34;Rover&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="mutating-captured-self">Mutating Captured Self</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Digit</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> number: Int
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(<span style="color:#66d9ef">_</span> n: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.number = n
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">mutating</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">changeNumberTo</span>(<span style="color:#66d9ef">_</span> n: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.number = n
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">otherFunction</span>(<span style="color:#66d9ef">_</span> f: () -&gt; ()) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">mutating</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">callAnotherFunction</span>() {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        otherFunction {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">self</span>.changeNumberTo(<span style="color:#ae81ff">345</span>) 
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面的代码是否合法取决于<code>otherFunction</code>是否将它的函数参数声明为<code>@escaping</code>（逃逸闭包）。如果它声明了<code>escaping</code>逃逸的，编译器会报<code>Escaping closure captures mutating 'self' parameter</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">otherFunction</span>(<span style="color:#66d9ef">_</span> f: @escaping ()-&gt;()) { 
</span></span><span style="display:flex;"><span>   	<span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>现在 <code>otherFunction</code>是逃逸的，这意味着存在威胁：可能在以后的某个时间点改变捕获的<code>self</code>。<code>Digit</code>是一个结构体，所以这将涉及到用一个不同的<code>Digit</code>实例来替换捕获的<code>self</code>。如果<code>Digit</code>是一个类，就不会出现这样的问题，因为捕获的<code>self</code>可以被<code>就地改变</code>。</p>
<h2 id="类引用是指针">类引用是指针</h2>
<p>在引用类型中，在对<font color=LightSeaGreen>实例的引用和实例本身之间有一个隐蔽的层次</font>。引用实际上持有一个指向实例的指针，这意味着当一个类的实例被分配给一个变量或作为一个函数的参数或作为一个函数的结果传递时，可能会出现对同一个对象的多个引用，而结构体和枚举则不是这样的。</p>
<p>在枚举或者结构体实例被赋值或者传递时，本质上是被赋值或者被传递的是该实例的副本。而类实例被赋值或传递时是实例本身，下面的代码能说明这种区别：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> d1 = Digit(<span style="color:#ae81ff">123</span>) <span style="color:#75715e">// Digit is a struct</span>
</span></span><span style="display:flex;"><span>debugPrint(d.number) <span style="color:#75715e">// 123</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> d2 = d <span style="color:#75715e">// assignment!</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>d2.number = <span style="color:#ae81ff">42</span>
</span></span><span style="display:flex;"><span>debugPrint(d1.number) <span style="color:#75715e">// 123</span>
</span></span></code></pre></div><p>在下面的代码中，改变了类实例<code>rov</code>的<code>name</code>属性，因为<code>Dog</code>是引用类型，这种改变也会影响到<code>fido</code>，因为它们指向同一个对象：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> fido = Dog() <span style="color:#75715e">// Dog is a class</span>
</span></span><span style="display:flex;"><span>debugPrint(fido.name) <span style="color:#75715e">// Fido</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> rov = fido <span style="color:#75715e">// assignment!</span>
</span></span><span style="display:flex;"><span>rov.name = <span style="color:#e6db74">&#34;Rover&#34;</span>
</span></span><span style="display:flex;"><span>debugPrint(fido.name) <span style="color:#75715e">// Rover</span>
</span></span></code></pre></div><p>在基于对象的编程世界中，产生对同一实例的多个引用的能力是非常重要的，因为在这个世界中，对象会持续存在，并且可以有与之一起持续存在的属性。</p>
<p>如果对象<code>A</code>和对象<code>B</code>都是长期存在的，如果它们都有一个属性为<code>Dog</code>类型，并且<code>Dog</code>是一个类。如果它们都指向同一个<code>Dog</code>实例，那么对象<code>A</code>或对象<code>B</code>都可以改变它们指向的<code>Dog</code>实例，而这种改变将会同时影响<code>A</code>和<code>B</code>。因此，对于类来说，你可能正抓着一个对象，却发现它已经被别人改变了，如果这种情况意外发生，会使你的程序进入无效状态。</p>
<p>因此，应该尽可能地选择一个值类型（如结构体）而不是“引用”类型（类）。结构实例不在引用之间共享，因此不必担心实例被其他突然改变。结构体的存储和内存管理也要简单得多，并且值类型也更容易推理。<code>Swift</code>语言本身会帮助你，在许多<code>Cocoa Foundation</code>的引用类型面前强加值类型。<code>Objective-C</code>的<code>NSDate</code>和<code>NSData</code>是类，但<code>Swift</code>会引导使用结构类型<code>Date</code>和<code>Data</code>来代替。</p>
<p>类实例的传递非常有效，因为<font color=red>所传递的只是一个指针</font>。无论一个类的实例有多大、多复杂，无论它有多少包含大量数据的属性，传递实例都是非常快速和高效的。</p>
<p>一个类的<code>API</code>可以拒绝对该类进行原地改变。<code>Cocoa</code>的<code>NSString、NSArray、NSDictionary、NSDate、NSIndexSet、NSParagraphStyle</code>等等都是这样的，因为它们在设计上是不可变的。</p>
<p>两个对象可以持有对同一个<code>NSArray</code>的引用而不用担心它在他们背后被改变，这不是因为它是一个值类型，而是因为它是不可变的。实际上，这种架构结合了值类型的易用性和引用类型的指针效率。</p>
<h2 id="subclass-and-superclass">subclass and superclass</h2>
<p>在<code>Swift</code>中，一个类可能会有多个子类，但<font color=red>一个类至多有一个直接父类</font>。在<code>Cocoa</code>中，实际上只有一个<code>root class</code>&ndash;<code>NSObject</code>，它首先体现了一个类成为一个类所必需的所有功能，而所有其他类在某种程度上都是这个基类的子类。</p>
<p>在类的声明前面加上<code>final</code>关键字可以防止其他类来继承。子类化不仅可以继承父类的方法，也可以自定义方法。下面定义的<code>Dog</code>不仅继承了<code>walk()</code>方法，而且自定义了<code>bark()</code>方法:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Quadruped</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">walk</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;walk walk walk&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span>: Quadruped {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;woof&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> fido  = Dog()
</span></span><span style="display:flex;"><span>fido.walk()
</span></span><span style="display:flex;"><span>fido.bark()
</span></span></code></pre></div><p>无论方法是在类中自定义的，还是从父类中继承的，都有同样的效果。下面代码中<code>Dog</code>继承了<code>Quadruped</code>的<code>walk</code>方法，调用的时候没有差别：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Quadruped</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">walk</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;walk walk walk&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span>: Quadruped {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;woof&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">walkAndBark</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.walk()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.bark()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> fido = Dog()
</span></span><span style="display:flex;"><span>fido.walk()
</span></span><span style="display:flex;"><span>fido.bark()
</span></span><span style="display:flex;"><span>fido.walkAndBark()
</span></span></code></pre></div><p>在<code>Swift</code>中允许对从父类继承的方法进行重定义（也被称为覆写，重写），需要在重定义的方法前添加<code>override</code>关键字。下面代码对对<code>Dog</code>继承了<code>Quadruped</code>的<code>walk</code>方法进行了重写：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Quadruped</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">walk</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;walk walk walk&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span>: Quadruped {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;woof&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">walkAndBark</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.walk()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.bark()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">walk</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;dog walk&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NoisyDog</span>: Dog {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;woof woof woof&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>一个与父类同名的方法不一定是<code>override</code>，在<code>Swift</code>中两个同名的函数是通过签名来区别的。只有当子类重新定义它从父类继承的同一个方法时，才存在覆盖的情况：<font color=red>相同的名称，包括外部参数名称，以及相同的签名</font>。</p>
<p>但是，<code>override</code>一个方法并不需要和被覆盖的父类方法有完全相同的签名。在覆盖一个方法时，<font color=LightSeaGreen>参数的类型可以用父类来代替</font>。下面的代码中，<code>Kitten</code>是<code>Cat</code>的子类，因此代码是合法的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Cat</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Kitten</span>: Cat {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">barkAt</span>(cat: Kitten) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NoisyDog</span>: Dog {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">barkAt</span>(cat: Cat) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在<code>override</code>时用一个<code>Optional</code>父类的参数也是合法的。即在<code>NoisyDog</code>中覆盖<code>barkAt</code>时，参数<code>cat</code>的类型可以是<code>Cat</code>或者<code>Cat?</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NoisyDog</span>: Dog {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">barkAt</span>(cat: Cat?) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>此外，在<code>override</code>时，一个参数可以用对应的<code>Optional</code>来覆盖。在下面的代码中，<code>Dog</code>中定义的方法<code>barkAt</code>参数类型为<code>Cat</code>，而在<code>NoisyDog</code>中<code>override</code>时参数为<code>Cat?</code>也是合法的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">barkAt</span>(cat: Cat) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NoisyDog</span>: Dog {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">barkAt</span>(cat: Cat?) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>而一个<code>Optional</code>的参数可以用其父类的<code>Optional</code>来覆盖。下面的代码中，使用<code>override</code>时<code>Kitten?</code>类型可以使用<code>Cat?</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">barkAt</span>(cat: Kitten?) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NoisyDog</span>: Dog {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">barkAt</span>(cat: Cat?) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>一个下标函数是一个方法。如果一个父类声明了一个下标，子类可以声明一个具有相同签名的下标，只要它用<code>override</code>关键字来指定它。为了调用父类的下标实现，子类可以在关键字<code>super</code>后面使用方括号（例如：<code>super[3]</code>）。</p>
<h2 id="class-initializers">class initializers</h2>
<p>由于类的继承性，类实例的初始化比结构或枚举实例的初始化要复杂得多。初始化器的主要任务是确保所有的属性都有一个初始值。初始化器可能还有其他任务要执行，这些任务对这个实例的初始状态和完整性至关重要。</p>
<p>然而，一个类可能有一个父类，它可能有自己的属性和初始化器。因此，必须以某种方式确保当一个子类被初始化时，其父类的属性被初始化，除了子类本身的任务外，其初始化器的任务也被按部就班地执行。</p>
<p>类的初始化分为两类：<code>Designated initializer</code>和<code>Convenience initializer</code>。类的初始化器默认为<code>Designated initializer</code>。<code>Designated initializer</code>初始化器必须保证所有的存储属性都被初始化。它不能委托给同一个类中的另一个初始化器，<font color=red>一个指定的初始化器使用<code>self.init(...)</code>是非法的</font>。</p>
<p>一个有任何存储属性的类，如果没有作为其声明的一部分被初始化，必须至少有一个明确的指定初始化器。一个没有存储属性的类，或者所有存储属性都作为声明的一部分被初始化的类，如果没有显式指定的初始化器，就有一个隐式的指定初始化器<code>init()</code>。</p>
<p>如果类的初始化器在声明的时候使用关键字<code>convenience</code>标记，那么它就是<code>Convenience initializer</code>。一个便利初始化器是一个委托初始化器，它<font color=red>必须包含<code>self.init(...)</code>，它必须调用同一个类中的指定初始化器</font>。或者如果它调用同一个类中的另一个便利初始化器，便利初始化器链必须以调用同一个类中的指定初始化器结束。</p>
<p>下面定义的类<code>class</code><font color=LightSeaGreen>没有存储属性，并且未自定义初始化器</font>，此时此编译器自动生成了一个无参的<code>init()</code>，因此使用<code>Dog()</code>不会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> dog = Dog()
</span></span></code></pre></div><p>如果类的<font color=red>所有存储属性在声明的时候都有初始值</font>，并且未自定义任何初始化器，编译器也会生成一个无参初始化器<code>init()</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name = <span style="color:#e6db74">&#34;Fido&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> dog = Dog()
</span></span></code></pre></div><p>在下面的例子中，虽然所有的存储属性都已经在声明的时候初始化了，但是已经有一个自定义的<code>Designated initializer</code>，那么就不会生成无参的初始化器<code>init()</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name = <span style="color:#e6db74">&#34;Fido&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(name: String) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> dog = Dog() <span style="color:#75715e">//compile error</span>
</span></span></code></pre></div><p>在下面的例子中，所有的存储属性都有默认值，并且自定义了一个<code>Convenience initializer</code>，但无任何<code>Designated initializer</code>。此时，仍然会自动生成一个无参的<code>init()</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name = <span style="color:#e6db74">&#34;Fido&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">convenience</span> <span style="color:#66d9ef">init</span>(name: String) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.<span style="color:#66d9ef">init</span>() <span style="color:#75715e">//默认的无参初始化器</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> dog1 = Dog(name: <span style="color:#e6db74">&#34;Rover&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> dog2 = Dog()
</span></span></code></pre></div><p>也就是说，<font color=red>当一个类中无<code>Designated initializer</code>，但存在有参的<code>Convenience initializer</code>时，编译器会自动生成一个无参的<code>init()</code></font>。同时还要注意的是，不能再声明<code>convenience init()</code>，否则会出现编译错误:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name = <span style="color:#e6db74">&#34;Fido&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Invalid redeclaration of synthesized &#39;init()&#39;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">convenience</span> <span style="color:#66d9ef">init</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// </span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><font color=red>如果类的存储属性在声明的时候并未全部初始化，并且如果有自定义的<code>Designated initializer</code></font>。那么,在所有自定义的初始器中必须将所有存储属性都初始化：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name: String
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> license: Int
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(name: String, license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.license = license
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> dog = Dog(name: <span style="color:#e6db74">&#34;Rover&#34;</span>, license: <span style="color:#ae81ff">42</span>)
</span></span></code></pre></div><p>类的<code>Designated initializer</code>和<code>Convenience initializer</code>有较大的区别：</p>
<ul>
<li>
<p>一个指定的初始化器中除非为了初始化一个属性（或获取一个已经被初始化的属性的值），否则在这个类的所有属性都被初始化之前不能隐式或显式地使用<code>self</code>。</p>
</li>
<li>
<p>一个便利初始化器是一个委托初始化器，所以在它直接或间接地调用一个指定初始化器之前，在其中不能出于任何目的使用<code>self</code>（也不能设置一个常量属性）。</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name: String
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> license: Int
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(name: String, license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.license = license
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">convenience</span> <span style="color:#66d9ef">init</span>(license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.<span style="color:#66d9ef">init</span>(name: <span style="color:#e6db74">&#34;Fido&#34;</span>, license: license)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">convenience</span> <span style="color:#66d9ef">init</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.<span style="color:#66d9ef">init</span>(license: <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> dog = Dog()
</span></span></code></pre></div><p>上面明确了<code>Designated initializer</code>和<code>Convenience initializer</code>的区别，在子类的初始化时，也有一些需要注意的地方：</p>
<ul>
<li>
<p>如果一个子类不需要自定义的初始化器，那么<font color=red>它的初始化器都继承自它的父类</font>。此时子类是否有隐藏的无参初始化器<code>init()</code>，取决于它的父类是否有<code>init()</code>。</p>
</li>
<li>
<p>如果一个子类尚无自定义的初始化器，则它可以声明<code>Convenience initializer</code>。子类的便利初始化器的工作方式与父类便利初始化器的工作方式完全一样。因为子类继承了父类的指定初始化器，便利初始化器<font color=red>必须通过使用<code>self.init(...)</code>来调用初始化器</font>。</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name: String
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> license: Int
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(name: String, license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.license = license
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">convenience</span> <span style="color:#66d9ef">init</span>(license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.<span style="color:#66d9ef">init</span>(name: <span style="color:#e6db74">&#34;Fido&#34;</span>, license: license)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">convenience</span> <span style="color:#66d9ef">init</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.<span style="color:#66d9ef">init</span>(license: <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyDog</span>: Dog {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">convenience</span> <span style="color:#66d9ef">init</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.<span style="color:#66d9ef">init</span>(license: <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// super.init(name: &#34;test&#34;, license: 1) // compile error</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>如果一个子类声明了任何自己的<code>Designated initializer</code>，那么<font color=red>将不会继承任何来自父类的初始化器</font>。并且在子类自定义的每个<code>Designated initializer</code>都必须调用一个父类的<code>Designated initializer</code>（通过使用<code>super.init(...)</code>实现）。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name: String
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> license: Int
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(name: String, license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.license = license
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">convenience</span> <span style="color:#66d9ef">init</span>(license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.<span style="color:#66d9ef">init</span>(name: <span style="color:#e6db74">&#34;Fido&#34;</span>, license: license)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">convenience</span> <span style="color:#66d9ef">init</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.<span style="color:#66d9ef">init</span>(license: <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyDog</span>: Dog {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(name: String) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// self.init(license: 1) // compile error</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">super</span>.<span style="color:#66d9ef">init</span>(name: name, license: <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> dog = Dog()
</span></span></code></pre></div><p>子类的<code>Designated initializer</code>中，必须按如下顺序进行初始化：</p>
<ol>
<li>
<p>必须确保自己的所有的属性都被初始化。</p>
</li>
<li>
<p>接着必须调用<code>super.init()</code>。</p>
</li>
<li>
<p>最后才能使用<code>self</code>继承自父类的实例方法或属性。</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyDog</span>: Dog {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(name: String) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// self.name = &#34;test&#34; // compile error</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">super</span>.<span style="color:#66d9ef">init</span>(name: <span style="color:#e6db74">&#34;name&#34;</span>, license: <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果一个子类既有<code>Designated initializer</code>又有<code>Convenience initializer</code>。那么在便利初始化器中必须使用<code>self.init()</code>来直接或者间接调用<code>Designated initializer</code>。</p>
<p>子类也可以重写父类的初始化器。<font color=LightSeaGreen>一个初始化器的参数与父类的方便初始化器相匹配时，子类的初始化器可以是指定的初始化器或便利初始化器，并且不被标记为<code>override</code></font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name: String
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> license: Int
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(name: String, license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.license = license
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">convenience</span> <span style="color:#66d9ef">init</span>(license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.<span style="color:#66d9ef">init</span>(name: <span style="color:#e6db74">&#34;Fido&#34;</span>, license: license)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">convenience</span> <span style="color:#66d9ef">init</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.<span style="color:#66d9ef">init</span>(license: <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyDog</span>: Dog {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">super</span>.<span style="color:#66d9ef">init</span>(name: <span style="color:#e6db74">&#34;name&#34;</span>, license: <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 或者</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//convenience init(license: Int) {</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//     self.init(license: 1)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//}</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>子类的初始化器参数与父类的指定初始化器相匹配时，子类的初始化器可以是指定的初始化器或方便初始化器，并且必须标记为<code>override</code>。并且<code>override</code>的指定初始化器必须通过<code>super.init(...)</code>调用父类的指定初始化器。</p>
<p>如果一个子类<code>override</code>父类<font color=LightSeaGreen>所有的指定初始化器，那么子类将继承父类所有的便利初始化器(这是一个例外，因为一个子类有任何指定的初始化器，则不继承初始化器)。</font></p>
<p>下面的代码是合法的，因为类<code>NoiseDog</code>继承了<code>Dog</code>的所有初始化器。但是不能使用<code>let nd3=NoiseDog()</code>，因为<code>Dog</code>里没有<code>init()</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name: String
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> license: Int
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(name: String, license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.license = license
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">convenience</span> <span style="color:#66d9ef">init</span>(license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.<span style="color:#66d9ef">init</span>(name: <span style="color:#e6db74">&#34;Fido&#34;</span>, license: license)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NoisyDog</span>: Dog {
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> nd1 = NoisyDog(name: <span style="color:#e6db74">&#34;Fido&#34;</span>, license: <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> nd2 = NoisyDog(license: <span style="color:#ae81ff">2</span>)
</span></span></code></pre></div><p>在下面的代码中，因为<code>NoiseDog</code>没有指定初始化器，只有便利初始化器，所以它继承了<code>Dog</code>的所有初始化器。因此，在便利初始化器中调用<code>self.init(name: &quot;Fido&quot;, license: license)</code>也是合法的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name: String
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> license: Int
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(name: String, license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.license = license
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">convenience</span> <span style="color:#66d9ef">init</span>(license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.<span style="color:#66d9ef">init</span>(name: <span style="color:#e6db74">&#34;Fido&#34;</span>, license: license)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NoisyDog</span>: Dog {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">convenience</span> <span style="color:#66d9ef">init</span>(name: String) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.<span style="color:#66d9ef">init</span>(name: name, license: <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在下面的代码中，因为<code>NoisyDog</code>声明了指定初始化器，因此不再继承父类<code>Dog</code>的所有初始化器。如果调用父类的指定初始化器需要使用<code>super</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name: String
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> license: Int
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(name: String, license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.license = license
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">convenience</span> <span style="color:#66d9ef">init</span>(license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.<span style="color:#66d9ef">init</span>(name: <span style="color:#e6db74">&#34;Fido&#34;</span>, license: license)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NoisyDog</span>: Dog {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(name: String) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">super</span>.<span style="color:#66d9ef">init</span>(name: name, license: <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在下面的例子中，因为<code>NoiseDog</code>已经覆写父类<code>Dog</code>的所有<code>designated initializers</code>，所以它继承了父类的<code>convenience initializers</code>，所以它能调用<code>NoisyDog(license:2)</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name: String
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> license: Int
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(name: String, license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.license = license
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">convenience</span> <span style="color:#66d9ef">init</span>(license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.<span style="color:#66d9ef">init</span>(name: <span style="color:#e6db74">&#34;Fido&#34;</span>, license: license)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NoisyDog</span>: Dog {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">init</span>(name: String, license: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">super</span>.<span style="color:#66d9ef">init</span>(name: name, license: license)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> nd1 = NoisyDog(name:<span style="color:#e6db74">&#34;Rover&#34;</span>, license:<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> nd2 = NoisyDog(license:<span style="color:#ae81ff">2</span>)
</span></span></code></pre></div><p>一个类的初始化器前面可以有一个关键字<code>required</code>，这意味着一个子类不能缺少这个初始化器。这又意味着，如果一个子类实现了指定初始化器，从而阻断了继承，它必须覆写这个初始化器，并标记为<code>required</code>。在下面的例子中，如果<code>NoisyDog</code>中的初始化器<code>required init(name: String)</code>缺少关键字<code>required</code>将会出现编译错误。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name: String
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">required</span> <span style="color:#66d9ef">init</span>(name: String) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NoisyDog</span>: Dog {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> obedient = <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(obedient: Bool) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.obedient = obedient
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">super</span>.<span style="color:#66d9ef">init</span>(name: <span style="color:#e6db74">&#34;Fido&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">required</span> <span style="color:#66d9ef">init</span>(name: String) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">super</span>.<span style="color:#66d9ef">init</span>(name: name)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在上面的代码中，虽然在<code>NoisyDog</code>中已经覆写了<code>init(name: String)</code>，但并未标记为<code>override</code>，而是标记了为了<code>required</code>，这是因为<code>'override' is implied when overriding a required initializer</code>。并且<code>required</code>保证了向下传递。</p>
<h2 id="class-deinitializer">class deinitializer</h2>
<p>类的<code>Deinitializer</code>是用关键字<code>deinit</code>声明的函数，后面是包含函数主体的花括号。不能手动调用这个函数，当这个类的一个实例不存在时，它将会自动被调用。如果一个类有一个父类，子类的<code>deinit</code>会在父类的<code>deinit</code>之前被调用。</p>
<p>只有类有<code>deinit</code>方法，<code>struct</code>和<code>enum</code>没有<code>deinit</code>方法，这是因为类是一种引用类型。我们的想法是，你可能想进行一些清理。类的<code>deinit</code>的另一个好用途是记录到控制台，向你自己证明你的实例是以良好的秩序消失的。在<code>deinit</code>过程中，属性观察者不被调用。</p>
<h2 id="class-properties">class properties</h2>
<p>子类可以覆写继承父类的属性，此时必须保持和父类属性同名以及同类型，而且必须使用<code>override</code>标记。覆写的属性不能为存储属性，更具体地说：</p>
<ul>
<li>
<p>如果父类的属性是可写的（一个存储属性或者有<code>setter</code>的计算属性），子类的覆写可以包括为这个属性添加设置器观察者。</p>
</li>
<li>
<p>或者子类覆写可以是计算属性。（1）如果父类的属性是存储的，那么子类使用计算属性来覆写时，一定要同时有<code>getter</code>和<code>setter</code>。（2）如果父类的属性是计算的，那么子类覆写的计算属性，至少需要<code>getter</code>（如果父类的计算属性有<code>setter</code>那么子类重写的方法必须有<code>setter</code>；如果父类的计算属性没有<code>setter</code>，那么子类可以添加一个）。</p>
</li>
</ul>
<p>覆写属性的函数可以通过<code>super</code>关键字对继承的属性进行读写。</p>
<h2 id="staticclass-members">Static/Class Members</h2>
<p>一个类可以有静态成员，标记为<code>static</code>，就像一个结构或枚举。它也可以有类成员，标记为<code>class</code>。静态成员和类成员都可以被子类所继承。</p>
<p>静态方法和类方法的主要区别在于，<font color=red>静态方法不能被重写，就好像静态方法是<code>class final</code>的同义词一样</font>。下面的代码会编译报错，并提示<code>Cannot override static method</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">whatDogsSay</span>() -&gt; String {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;woof&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(Dog.whatDogsSay())
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NoisyDog</span>: Dog {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">whatDogsSay</span>() -&gt; String {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;noisy&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在上面的代码中，任何继承<code>Dog</code>的子类都会继承它的静态方法<code>whatDogsSay</code>，但是不能包含任何具有相同签名的静态方法或者类方法。但如果在<code>Dog</code>中使用<code>class</code>来声明<code>whatDogsSay</code>，则可以在子类中<code>override</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">func</span> whatDogsSay() -&gt; String {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;woof&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(Dog.whatDogsSay())
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NoisyDog</span>: Dog {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">whatDogsSay</span>() -&gt; String {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;noisy&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 或者</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">func</span> whatDogsSay() -&gt; String {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;woof&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(Dog.whatDogsSay())
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NoisyDog</span>: Dog {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">func</span> whatDogsSay() -&gt; String {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;noisy&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>静态属性和类属性的区别类似于静态方法和类方法的区别。但有一个额外的、相当戏剧性的限定：<font color=red>静态属性可以被存储，但类属性必须是一个计算的属性</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">var</span> whatDogsSay = <span style="color:#e6db74">&#34;woof&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(Dog.whatDogsSay)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面定义的<code>Dog</code>有静态的存储属性，但是它不能被任何子类所<code>override</code>。如果要能被子类覆写，那么必须使用<code>class</code>来声明，并且必须声明为计算属性：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">var</span> whatDogsSay: String {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;woof&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(Dog.whatDogsSay)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NoisyDog</span>: Dog {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">var</span> whatDogsSay: String {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;WOOF&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="多态">多态</h2>
<p>替换原则：声明类的引用时指定某种类型，但<font color=red>实际的对象可能是该类型的一个子类</font>。在下面的代码中，<code>dog</code>虽然声明为<code>Dog</code>类型，但是赋值给它的是<code>Dog</code>的子类<code>NoisyDog</code>的实例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NoisyDog</span>: Dog {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> dog: Dog = NoisyDog()
</span></span></code></pre></div><p>内部身份规则：一个对象的实际类型是其内部性质的问题，与该对象如何被提及无关。也就是说，当一个消息被发送时，重要的不是该消息的接收者是如何通过这个或那个引用被输入的，而是该接收者实际上是什么类型。在下面的代码中虽然<code>tellToBark</code>函数期望的类型为<code>Dog</code>，但实际传递的是<code>NoisyDog</code>类型实例，因此调用<code>bark</code>方法时，调用的是<code>NoisyDog</code>的<code>bark</code>方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;woof&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NoisyDog</span>: Dog {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">_</span> <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1.</span>..<span style="color:#ae81ff">3</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">super</span>.bark()
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">tellToBark</span>(<span style="color:#66d9ef">_</span> d: Dog) {
</span></span><span style="display:flex;"><span>    d.bark()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> nd = NoisyDog()
</span></span><span style="display:flex;"><span>tellToBark(nd)  <span style="color:#75715e">// woof woof woof</span>
</span></span></code></pre></div><p>关键词<code>self</code>的含义是多态性的另一个重要体现。<code>self</code>的含义取决于实际实例的类型，即使<code>self</code>这个词出现在父的代码中。在下面代码中，在<code>Dog</code>中的<code>speak</code>方法中使用<code>self</code>调用了<code>bark</code>方法，因为<code>NoiseDog</code>继承自<code>Dog</code>，所以也继承了<code>speak</code>方法，又因为它覆写了<code>bark</code>，所以<code>speak</code>中调用的<code>bark</code>变成了<code>NosieDog</code>中的<code>bark</code>方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;woof&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">speak</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.bark()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NoisyDog</span>: Dog {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">_</span> <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1.</span>..<span style="color:#ae81ff">3</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">super</span>.bark()
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> nd = NoisyDog() 
</span></span><span style="display:flex;"><span>nd.speak() <span style="color:#75715e">// woof woof woof</span>
</span></span></code></pre></div><p>多态对于可选类型也是适用的。假设有一个<code>Optional</code>类型的引用，包裹着<code>Dog</code>。你已经知道可以给它赋值<code>Dog</code>的实例，也可以赋值<code>NoisyDog</code>的实例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> dog : Dog?
</span></span><span style="display:flex;"><span>dog = Dog() 
</span></span><span style="display:flex;"><span>dog = NoisyDog() 
</span></span><span style="display:flex;"><span>dog = Optional(NoisyDog())
</span></span></code></pre></div><p>多态性很酷，但从总体上看，<font color=red>它也是比较慢的，因为它需要动态调度，这意味着编译器不能进行某些优化</font>，而且运行时必须考虑给类实例的信息意味着什么。可以通过声明一个类或一个类成员为<code>final</code>或<code>private</code>来减少对动态调度的需求。或者使用一个结构，结构不需要动态调度。</p>
<h2 id="casting">Casting</h2>
<p><code>Swift</code>是一种严格类型的语言，允许向对象引用发送的消息取决于引用的类型。但是，多态性的内部身份原则说，一个对象可能有一个不同于其引用的声明类型的实际类型。在下面的代码中，在<code>tellToHush</code>中调用<code>beQuit</code>是非法的，会出现<code>Value of type 'Dog' has no member 'beQuiet'</code>报错信息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;woof&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NoisyDog</span>: Dog {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">super</span>.bark(); <span style="color:#66d9ef">super</span>.bark()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">beQuiet</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.bark()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">tellToHush</span>(<span style="color:#66d9ef">_</span> d: Dog) {
</span></span><span style="display:flex;"><span>    d.beQuiet() <span style="color:#75715e">// compile error </span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面的代码编译报错是因为<code>Dog</code>类型中没有<code>beQuiet</code>方法，该方法是子类<code>NoisyDog</code>特有的。而当将<code>NoisyDog</code>实例传给<code>tellToHush</code>时，实际上可以使用<code>beQuiet</code>方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">tellToHush</span>(<span style="color:#66d9ef">_</span> d: Dog) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> d = d <span style="color:#66d9ef">as</span>! NoisyDog <span style="color:#75715e">// crash </span>
</span></span><span style="display:flex;"><span>    d.beQuiet()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在上面的例子中，相当于告诉编译器，对象<code>d</code>可能是<code>NoiseDog</code>类型的，但是使用<code>as!</code>可能会发生崩溃，因为<code>d</code>不一定是<code>NoiseDog</code>类型。也可以先使用关键字<code>is</code>来判断是否为<code>NoiseDog</code>类型，然后使用<code>as!</code>; 或者使用<code>as?</code>进行转换，或者使用<code>if let </code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">tellToHush</span>(<span style="color:#66d9ef">_</span> d: Dog) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> d <span style="color:#66d9ef">is</span> NoisyDog {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> d = d <span style="color:#66d9ef">as</span>! NoisyDog 
</span></span><span style="display:flex;"><span>        d.beQuiet()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">tellToHush</span>(<span style="color:#66d9ef">_</span> d: Dog) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> d = d <span style="color:#66d9ef">as</span>? NoisyDog <span style="color:#75715e">// an Optional wrapping a NoisyDog </span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> d <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        d!.beQuiet()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">tellToHush</span>(<span style="color:#66d9ef">_</span> d: Dog) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> d = d <span style="color:#66d9ef">as</span>? NoisyDog <span style="color:#75715e">// an Optional wrapping a NoisyDog </span>
</span></span><span style="display:flex;"><span>    d?.beQuiet()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">tellToHush</span>(<span style="color:#66d9ef">_</span> d: Dog) {
</span></span><span style="display:flex;"><span>    (d <span style="color:#66d9ef">as</span>? NoisyDog)?.beQuiet()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">tellToHush</span>(<span style="color:#66d9ef">_</span> d: Dog) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> d = d <span style="color:#66d9ef">as</span>? NoisyDog {
</span></span><span style="display:flex;"><span>        d.beQuiet()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>对于<code>is, as!</code>和<code>as?</code>操作符来说，它们对于<code>Optional</code>类型的工作方式与<code>==</code>比较操作符相同：会自动解包<code>Optional</code>对象，然后进行比较：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> dog: Dog? = NoisyDog()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> dog <span style="color:#66d9ef">is</span> NoisyDog {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#e6db74">&#34;true&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在上面的例子中，<code>is</code>关键字首先检查<code>dog</code>是否为<code>nil</code>，如果<code>dog</code>不为<code>nil</code>，则检查<code>dog</code>包裹的类型是否为<code>NoiseDog</code>。</p>
<p>可以对一个<code>optional</code>类型使用<code>as!</code>操作符。当<code>as!</code>操作符左边是一个<code>optional</code>类型时，<code>Swift</code>会先解包，然后再进行转换，下面这段代码是有效的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> dog1: Dog? = NoisyDog()
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> dog2 = dog1 <span style="color:#66d9ef">as</span>! NoisyDog
</span></span><span style="display:flex;"><span>dog2.beQuiet()
</span></span></code></pre></div><p>但是上面的代码是不安全的，如果<code>dog1</code>为<code>nil</code>或者执行<code>Dog</code>类型的实例，则<code>dog1 as! NoisyDog</code>转换失败而发生崩溃，使用<code>as?</code>会更安全：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> dog1: Dog? = NoisyDog()
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> dog2 = dog1 <span style="color:#66d9ef">as</span>? NoisyDog
</span></span><span style="display:flex;"><span>dog2?.beQuiet()
</span></span></code></pre></div><p>在上面的代码中，<code>as?</code>首先会检查<code>dog1</code>是为<code>nil</code>，如果为<code>nil</code>则<code>dog2</code>的结果为<code>nil</code>。如果<code>dog1</code>不为<code>nil</code>，但不是<code>NoisyDog</code>的实例，则转换失败，<code>dog2</code>为<code>nil</code>，否则转换成功，<code>dog2</code>为<code>NoisyDog?</code>。</p>
<p>使用强制转换的另一种方式是当<code>Swift</code>和<code>Objective-C</code>两种类型等效时进行值交换。例如，可以将<code>Swift String </code>转换为<code>Cocoa NSString</code>，反之亦然。这不是因为一个是另一个的子类，而是因为它们是相互桥接的；在非常真实的意义上，它们是同一种类型。当从<code>String</code>转换为<code>NSString</code>时，不是向下转换，并且所做的事情并不危险，因此使用<code>as</code>运算符，没有感叹号或问号。</p>
<p>一般来说，要从<code>Swift</code>类型过渡到桥接的<code>Objective-C</code>类型，需要显式转换（字符串文字常量除外。在下面的代码中，<code>Swift</code>的<code>String</code>类型和<code>Objective-C</code>的<code>NSString</code>等价，<code>Int</code>和<code>NSNumber</code>等价：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s : NSString = <span style="color:#e6db74">&#34;howdy&#34;</span> <span style="color:#75715e">// string literal to NSString</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s2 = <span style="color:#e6db74">&#34;howdy&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s3 : NSString = s2 <span style="color:#66d9ef">as</span> NSString <span style="color:#75715e">// String to NSString</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> i : NSNumber = <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">as</span> NSNumber <span style="color:#75715e">// Int to NSNumber</span>
</span></span></code></pre></div><p>上面的这种代码是相当人为的。在现实生活中，不会经常进行强制转换，因为<code>Cocoa API</code>会以<code>Swift</code>类型的形式呈现给出来。这是合法的，没有强制转换：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> name = <span style="color:#e6db74">&#34;MyNib&#34;</span> <span style="color:#75715e">// Swift String </span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> vc = ViewController(nibName:name, bundle:<span style="color:#66d9ef">nil</span>)
</span></span></code></pre></div><p>类<code>UIViewController</code>来自于<code>Cocoa</code>，它的<code>NibName</code>属性是<code>Objective-C</code>的<code>NSString</code>类型，而不是<code>Swift</code>字符串。但不必通过强制转换来帮助<code>Swift String name</code>过桥，因为在<code>Swift</code>世界中，<code>nibName:</code>被输入为一个<code>Swift String</code>（实际上是一个可选字符串）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span> <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">init</span>(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?)
</span></span></code></pre></div><p>在下面的代码中，不必通过强制转换来帮助<code>Swift String</code>类型的<code>s</code>桥接，因为<code>set(_:forKey:)</code>的第一个参数为<code>Swift</code>的<code>Any</code>类型（实际上是一个<code>Optional</code>包装的<code>Any</code>）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> ud = UserDefaults.standard
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s = <span style="color:#e6db74">&#34;howdy&#34;</span>
</span></span><span style="display:flex;"><span>ud.<span style="color:#66d9ef">set</span>(s, forKey: <span style="color:#e6db74">&#34;greeting&#34;</span>)
</span></span></code></pre></div><p>反过来说，你有可能从<code>Objective-C</code>收到一个值，而<code>Swift</code>并不了解这个值的真正底层类型。在这种情况下，你可能希望显式转换为底层类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> ud = UserDefaults.standard 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> test = ud.object(forKey:<span style="color:#e6db74">&#34;greeting&#34;</span>) <span style="color:#66d9ef">as</span>! String
</span></span></code></pre></div><p>当调用<code>ud.object(forKey:)</code>时，<code>Swift</code>并不知道真正的底层类型信息，因为结果是一个<code>Any</code>（实际上是一个包裹<code>Any</code>的<code>Optional</code>）。但是我们知道这个特定的调用应该产生一个字符串&ndash;因为那是一开始就输入的东西。所以我们可以把这个值强行转换为一个字符串&ndash;而且它还能工作。然而，如果<code>ud.object(forKey: &quot;greeting&quot;)</code>不是一个字符串（或者它是<code>nil</code>），就会发生崩溃。如果你不确定你的立场，为了安全起见，使用<code>is</code>或<code>as?</code>。</p>
<h2 id="type-references">Type References</h2>
<p>有时我们获取到了一个实例，此时并知道这个实例的类型，可能只是出于信息或调试目的将其类型记录到控制台，或者可能需要使用类型作为值。此时，可以使用全局函数<code>type(of:)</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> dogTest: Dog = NoisyDog()
</span></span><span style="display:flex;"><span>debugPrint(type(of: dogTest)) <span style="color:#75715e">// xxx.NoisyDog</span>
</span></span></code></pre></div><p>对于一个实例来说，能够引用它自己的类型尤为重要。通常，这是为了向该类型发送消息。例如，假设一个实例想要向它的类发送一个类消息。在前面的例子中，<code>Dog</code>实例方法通过向<code>Dog</code>类型发送消息来获取<code>Dog</code>类属性，实际上就是使用<code>Dog</code>这个词：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">var</span> whatDogsSay: String {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;woof&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(Dog.whatDogsSay)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>表达式<code>Dog.whatDogsSay</code>看起来笨拙并且不灵活，它有一个类型；它应该只知道它是什么。可以使用关键字<code>Self</code>（带大写字母）来引用当前类型——<code>self</code>的类型:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">var</span> whatDogsSay: String {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;woof&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
</span></span><span style="display:flex;"><span>        debugPrint(<span style="color:#66d9ef">Self</span>.whatDogsSay)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在代码中使用<code>Self</code>而不是具体的类型名字，不仅是因为更简，而且它更强大，因为<code>Self</code>和<code>self</code>一样，也遵循多态性。在下面的代码中，当<code>NoisyDog</code>类型的实例调用<code>bark</code>时，它的<code>Self</code>就是<code>NoisyDog</code>。因此，取到的<code>whatDogsSay</code>就是<code>&quot;woof woof woof&quot;</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NoisyDog</span>: Dog {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">var</span> whatDogsSay: String {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;woof woof woof&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> dogTest: Dog = NoisyDog()
</span></span><span style="display:flex;"><span>debugPrint(type(of: dogTest)) <span style="color:#75715e">// xxx.NoisyDog</span>
</span></span><span style="display:flex;"><span>debugPrint(dogTest.bark()) <span style="color:#75715e">// &#34;woof woof woof&#34;</span>
</span></span></code></pre></div><p><code>Self</code>是<code>Swift 5.1</code>引入的，在那之前只能使用<code>type(of:self)</code>。多态<code>Self</code>的另一个重要用途是作为返回类型。为了说明为什么这很有价值，将介绍工厂方法的概念。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NewDog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name: String
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(name: String) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">func</span> makeAndName() -&gt; NewDog {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> d = <span style="color:#66d9ef">Self</span>(name: <span style="color:#e6db74">&#34;Fido&#34;</span>) <span style="color:#75715e">// compile error</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> d
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面的代码会发生编译错误，这是因为编译器怀疑<code>init(name:)</code>初始化器对于<code>NewDog</code>的每个可能的子类型实现。为了让它放心，我们必须使用<code>required</code>关键字声明该初始化器：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NewDog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name: String
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">required</span> <span style="color:#66d9ef">init</span>(name: String) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">func</span> makeAndName() -&gt; NewDog {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> d = <span style="color:#66d9ef">Self</span>(name: <span style="color:#e6db74">&#34;Fido&#34;</span>) <span style="color:#75715e">// compile error</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> d
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NewNoisyDog</span>: NewDog {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>required</code>声明可以让编译器放心: <code>NewDog</code>的每个子类都必须继承或重新实现<code>init(name:)</code>，所以在一个可能指向<code>Dog</code>或<code>Dog</code>的某个子类的类型引用上调用<code>init(name:)</code>信息是合法的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> newDog1 = NewDog.makeAndName() <span style="color:#75715e">// d is a Dog named Fido</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> newDog2 = NewNoisyDog.makeAndName() <span style="color:#75715e">// d2 is a NoisyDog named Fido</span>
</span></span></code></pre></div><p>但是上面的代码还有外一个问题，尽管<code>newDog2</code>事实上是<code>NewNoisyDog</code>，但是<code>makeAndName</code>返回的是<code>NewDog</code>。实际上我们要声明这个方法返回一个与最初发送<code>makeAndName</code>消息的类相同类型的实例。换句话说，我们需要一个多态的类型声明，可以使用<code>Self</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NewDog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name: String
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">required</span> <span style="color:#66d9ef">init</span>(name: String) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">func</span> makeAndName() -&gt; <span style="color:#66d9ef">Self</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> d = <span style="color:#66d9ef">Self</span>(name: <span style="color:#e6db74">&#34;Fido&#34;</span>) <span style="color:#75715e">// compile error</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> d
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NewNoisyDog</span>: NewDog {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> newDog1 = NewDog.makeAndName() <span style="color:#75715e">// d is a Dog named Fido</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> newDog2 = NewNoisyDog.makeAndName() <span style="color:#75715e">// d2 is a NoisyDog named Fido</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>debugPrint(type(of: newDog2))
</span></span></code></pre></div><p><code>Self</code>类型作为返回类型时表示<code>这是运行时任何类型的实例</code>，因此当<code>NewNoisyDog</code>调用<code>NewNoisyDog.makeAndName()</code>得到的是<code>NewNoisyDog</code>实例。<code>Self</code>也可以用户实例方法的声明中。因此，可以编写工厂方法的实例方法版本。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NewDog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> name: String
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">required</span> <span style="color:#66d9ef">init</span>(name: String) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">func</span> makeAndName() -&gt; <span style="color:#66d9ef">Self</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> d = <span style="color:#66d9ef">Self</span>(name: <span style="color:#e6db74">&#34;Fido&#34;</span>) <span style="color:#75715e">// compile error</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> d
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">havePuppy</span>(name: String) -&gt; <span style="color:#66d9ef">Self</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">Self</span>(name: name)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NewNoisyDog</span>: NewDog {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> newDog1 = NewDog.makeAndName() <span style="color:#75715e">// d is a Dog named Fido</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> newDog2 = NewNoisyDog.makeAndName() <span style="color:#75715e">// d2 is a NoisyDog named Fido</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>debugPrint(type(of: newDog2))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> newDog11 = newDog1.havePuppy(name: <span style="color:#e6db74">&#34;test1&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> newDog22 = newDog2.havePuppy(name: <span style="color:#e6db74">&#34;test2&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>debugPrint(type(of: newDog11))
</span></span><span style="display:flex;"><span>debugPrint(type(of: newDog22))
</span></span></code></pre></div><p>在某些情况下，可能希望将对象类型视为值，那是合法的。对象类型本身就是一种对象，这就是<code>Swift</code>所说的元类型。因此<font color=red>对象类型可以分配给变量或作为参数传递</font>：</p>
<ul>
<li>
<p>声明一个对象的类型是可以接受的。如在声明一个变量或参数的类型时&ndash;使用点状符号与类型的名称和关键字<code>Type</code>。</p>
</li>
<li>
<p>使用一个对象类型作为一个值。比如当把一个类型分配给一个变量或作为一个参数传递时，把对象交给<code>type(of:)</code>，或者用类型的名称和关键字<code>self</code>来点注。(在后一种情况下，类型的名称可能是<code>Self</code>，在这种情况下，可以使用<code>Self.self</code>)。</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">dogTypeExpecter</span>(<span style="color:#66d9ef">_</span> whatType: NewDog.<span style="color:#66d9ef">Type</span>) {
</span></span><span style="display:flex;"><span>    debugPrint(whatType)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>dogTypeExpecter(NewDog.<span style="color:#66d9ef">self</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> dog = NewDog(name: <span style="color:#e6db74">&#34;test&#34;</span>)
</span></span><span style="display:flex;"><span>dogTypeExpecter(type(of: dog))
</span></span><span style="display:flex;"><span>dogTypeExpecter(NewNoisyDog.<span style="color:#66d9ef">self</span>)
</span></span></code></pre></div><p>为了更实际地说明问题，将把<code>Dog</code>工厂方法重写为一个全局工厂函数，它将接受一个<code>Dog</code>类型作为参数，并从该类型创建一个实例。可以使用一个类型的变量引用（元类型）来实例化该类型，但不能只是在一个变量引用上加上括号，必须使用<code>init</code>方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">dogMakerAndNamer</span>(<span style="color:#66d9ef">_</span> whatType: NewDog.<span style="color:#66d9ef">Type</span>) -&gt; NewDog {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> d = whatType(name: <span style="color:#e6db74">&#34;Fido&#34;</span>) <span style="color:#75715e">// compile error: Initializing from a metatype value must reference &#39;init&#39; explicitly</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> d
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">dogMakerAndNamer</span>(<span style="color:#66d9ef">_</span> whatType: NewDog.<span style="color:#66d9ef">Type</span>) -&gt; NewDog {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> d = whatType.<span style="color:#66d9ef">init</span>(name: <span style="color:#e6db74">&#34;Fido&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> d
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> d11 = dogMakerAndNamer(NewDog.<span style="color:#66d9ef">self</span>) <span style="color:#75715e">// d11 is a Dog named Fido </span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> d12 = dogMakerAndNamer(NewNoisyDog.<span style="color:#66d9ef">self</span>) <span style="color:#75715e">// d12 is a NoisyDog named Fido</span>
</span></span></code></pre></div><p>不幸的是，即使底层的真正类型是<code>NewNoisyDog</code>，全局工厂函数<code>dogMakerAndNamer</code>返回的也是一个<code>NewDog</code>对象。因为是全局函数，这里不能使用<code>Self</code>来解决这个问题，但是可以使用泛型。</p>
<ul>
<li><code>type(of:)</code>应用于一个对象：对象的多态（内部）类型，与引用的类型无关。</li>
<li><code>Self</code>：在方法主体中，或者在方法声明中指定返回类型时，这个类型或这个实例的类型，多态性。</li>
<li><code>.Type</code>：附加在类型声明中的一个类型上，以指定该类型本身（或一个子类型）被期望。</li>
<li><code>.self</code>：发送给一个类型以生成一个元类型，适合于传递一个类型（<code>.Type</code>）被期望的地方。</li>
</ul>
<h2 id="comparing-types">Comparing Types</h2>
<p>类型引用之间可以相互比较。在<code>==</code>比较符的右边，可以用<code>.self</code>来表示一个类型的名称。而在<code>is</code>关键字的右边，可以用<code>.Type</code>来表示一个类型的名称。区别在于：<code>==</code>操作符<font color=red>测试的是绝对相同的类型，而<code>is</code>则允许子类型</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">dogTypeExpecter</span>(<span style="color:#66d9ef">_</span> whatType: NewDog.<span style="color:#66d9ef">Type</span>) {
</span></span><span style="display:flex;"><span>    debugPrint(whatType)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> equality = whatType == NewDog.<span style="color:#66d9ef">self</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> typology = whatType <span style="color:#66d9ef">is</span> NewDog.<span style="color:#66d9ef">Type</span>
</span></span><span style="display:flex;"><span>    debugPrint(equality,typology)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>dogTypeExpecter(NewDog.<span style="color:#66d9ef">self</span>) <span style="color:#75715e">// true,true</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> dog = NewDog(name: <span style="color:#e6db74">&#34;test&#34;</span>)
</span></span><span style="display:flex;"><span>dogTypeExpecter(type(of: dog)) <span style="color:#75715e">// true,true</span>
</span></span><span style="display:flex;"><span>dogTypeExpecter(NewNoisyDog.<span style="color:#66d9ef">self</span>) <span style="color:#75715e">// false, true</span>
</span></span></code></pre></div><p>在上面的例子中，<code>whatType</code>放在比较操作符的左边，它可能被<code>type(of:)</code>替换，或者<code>.self</code>替换。同时<code>==</code>操作符右边的<code>NewDog.self</code>也可能被<code>whatType</code>和<code>type(of:)</code>替换。但是<code>is</code>关键字的右边不能出现<code>whatType</code>和<code>type(of:)</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>debugPrint(type(of: dog) == NewDog.<span style="color:#66d9ef">self</span>, type(of: dog) == NewNoisyDog.<span style="color:#66d9ef">self</span>) <span style="color:#75715e">// true,false</span>
</span></span></code></pre></div><p>[](// 全局变量
static let shared = MyManager(string: someString))</p>

    </div>
    <footer class="post-footer">
        
 
<div class="post-tags">     
     
    <a href="https://iihui.github.io/tags/ios" rel="tag" title="iOS">#iOS#</a>
    
</div>



        <div class="post-nav">
    <div class="post-nav-next post-nav-item">
    
        <a href="https://iihui.github.io/post/tool-rider/" rel="next" title="Rider 使用">
        <i class="fa fa-chevron-left"></i> Rider 使用
        </a>
    
    </div>

    <div class="post-nav-prev post-nav-item">
    
        <a href="https://iihui.github.io/post/ios-protocol/" rel="prev" title="Swift协议">
        Swift协议 <i class="fa fa-chevron-right"></i>
        </a>
    
    </div>
</div>
      
        <div class="post-nav">
    <div style="border: 1px dashed #e0e0e0; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
        <div style="float:left;margin-top:0px;">
            <img src="https://i.loli.net/2020/02/09/SvhUdz4XJsOr9Vk.jpg" width="128px" height="128px"/>
            <div style="text-align:center;">谢谢支持!</div>
        </div>
        <div>
            <p style="margin-top:10px;">
                标题：iOS 14 编程基础
                <br />作者：阿呆<a target="_blank" href="https://iihui.github.io/"></a>
                
                <br />地址：https://iihui.github.io/post/ios-fundamentals/
                <br />声明：自由转载-非商用-保持署名（创作共享4.0许可证）
            </p>
        </div>
    </div>
    <div class="clear"></div>
</div>
        
        
        




    </footer>
  </article>
</section>

          </div>
        </div>
        <div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>
<aside id="sidebar" class="sidebar">
  <div class="sidebar-inner">

  <ul class="sidebar-nav motion-element">
    <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
      文章目录
    </li>
    <li class="sidebar-nav-overview" data-target="site-overview">
      站点概览
    </li>
  </ul>

    <section class="site-overview sidebar-panel ">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
        src="https://i.loli.net/2020/02/07/dVFzrvZkHRNq2lL.jpg"
        alt="" />
    <p class="site-author-name" itemprop="name"></p>
    <p class="site-description motion-element" itemprop="description"> 
        coder &amp; cook</p>
</div>
      <nav class="site-state motion-element">
    <div class="site-state-item site-state-posts">
      <a href="https://iihui.github.io/post/">
        <span class="site-state-item-count">140</span>
        <span class="site-state-item-name">日志</span>
      </a>
    </div>
    <div class="site-state-item site-state-categories">    
        <a href="https://iihui.github.io/categories/">      
         
        <span class="site-state-item-count">17</span>
        
        <span class="site-state-item-name">分类</span>
        
        </a>
    </div>

    <div class="site-state-item site-state-tags">
        <a href="https://iihui.github.io/tags/">
         
        <span class="site-state-item-count">29</span>
        
        <span class="site-state-item-name">标签</span>
        </a>
    </div>
</nav>
      
      
<div class="links-of-author motion-element">
    
        <span class="links-of-author-item">
        <a href="https://coolshell.cn" target="_blank" title="皓 大">
            <i class="fa fa-fw fa-globe"></i>
            皓 大
        </a>
        </span>
    
        <span class="links-of-author-item">
        <a href="http://www.ruanyifeng.com" target="_blank" title="阮 大">
            <i class="fa fa-fw fa-globe"></i>
            阮 大
        </a>
        </span>
    
        <span class="links-of-author-item">
        <a href="https://juejin.im/" target="_blank" title="掘 金">
            <i class="fa fa-fw fa-globe"></i>
            掘 金
        </a>
        </span>
    
        <span class="links-of-author-item">
        <a href="http://www.ideamsg.com" target="_blank" title="灵 感">
            <i class="fa fa-fw fa-globe"></i>
            灵 感
        </a>
        </span>
    
</div>


      

      <div class="links-of-blogroll motion-element inline">
<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=&amp;m=0&amp;s=220&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;bv=35" async="async"></script>
</div>

    </section>
    
<section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
    <div class="post-toc">
        <div class="post-toc-content"><nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#object">Object</a></li>
        <li><a href="#variables">Variables</a></li>
        <li><a href="#functions">Functions</a></li>
        <li><a href="#文件结构">文件结构</a></li>
        <li><a href="#scope-and-lifetime">Scope and Lifetime</a></li>
        <li><a href="#object-members">Object Members</a></li>
        <li><a href="#namespaces">Namespaces</a></li>
        <li><a href="#modules">Modules</a></li>
        <li><a href="#instances">Instances</a></li>
        <li><a href="#the-keyword-self">The Keyword self</a></li>
        <li><a href="#privacy">Privacy</a></li>
        <li><a href="#reserved-words">Reserved Words</a></li>
      </ul>
    </li>
    <li><a href="#functions-1">functions</a>
      <ul>
        <li><a href="#参数">参数</a></li>
        <li><a href="#返回值">返回值</a></li>
        <li><a href="#空返回值和参数">空返回值和参数</a></li>
        <li><a href="#函数签名">函数签名</a></li>
        <li><a href="#外部参数名">外部参数名</a></li>
        <li><a href="#函数重载">函数重载</a></li>
        <li><a href="#默认值">默认值</a></li>
        <li><a href="#可变参数">可变参数</a></li>
        <li><a href="#忽略的参数">忽略的参数</a></li>
        <li><a href="#可修改参数">可修改参数</a></li>
        <li><a href="#使用可修改参数调用oc">使用可修改参数调用OC</a></li>
        <li><a href="#被可修改参数的oc调用">被可修改参数的OC调用</a></li>
        <li><a href="#内部函数">内部函数</a></li>
        <li><a href="#递归">递归</a></li>
        <li><a href="#函数作为值">函数作为值</a></li>
        <li><a href="#匿名函数">匿名函数</a>
          <ul>
            <li><a href="#匿名函数缩写">匿名函数缩写</a>
              <ul>
                <li><a href="#省略返回类型和箭头">省略返回类型和箭头</a></li>
                <li><a href="#省略in关键字">省略in关键字</a></li>
                <li><a href="#省略参数类型">省略参数类型</a></li>
                <li><a href="#省略参数列表圆括号">省略参数列表圆括号</a></li>
                <li><a href="#有参数列表省略in表达式">有参数列表省略in表达式</a></li>
                <li><a href="#省略参数名">省略参数名</a></li>
                <li><a href="#省略函数标签">省略函数标签</a></li>
                <li><a href="#省略函数调用圆括号">省略函数调用圆括号</a></li>
                <li><a href="#省略return关键字">省略return关键字</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#define-adn-call">Define adn Call</a></li>
        <li><a href="#closures">Closures</a></li>
        <li><a href="#how-closures-improve-code">How Closures Improve Code</a></li>
        <li><a href="#function-returning-function">Function Returning Function</a></li>
        <li><a href="#closure-setting-a-captured-variable">Closure Setting a Captured Variable</a></li>
        <li><a href="#closure-preserving-captured-environment">Closure Preserving Captured Environment</a></li>
        <li><a href="#escaping-closures">Escaping Closures</a></li>
        <li><a href="#capture-lists">Capture Lists</a></li>
        <li><a href="#curried-function">curried function</a></li>
        <li><a href="#函数引用">函数引用</a></li>
        <li><a href="#函数引用的作用域">函数引用的作用域</a></li>
        <li><a href="#selectors">Selectors</a></li>
      </ul>
    </li>
    <li><a href="#变量和简单类型">变量和简单类型</a>
      <ul>
        <li><a href="#声明">声明</a></li>
        <li><a href="#计算初始化">计算初始化</a></li>
        <li><a href="#计算变量">计算变量</a></li>
        <li><a href="#计算属性">计算属性</a></li>
        <li><a href="#setter-observers">Setter Observers</a></li>
        <li><a href="#懒初始化">懒初始化</a></li>
        <li><a href="#单例">单例</a></li>
        <li><a href="#内置简单类型">内置简单类型</a></li>
        <li><a href="#数值强制转换">数值强制转换</a></li>
        <li><a href="#string">String</a></li>
        <li><a href="#range">Range</a></li>
        <li><a href="#元组">元组</a></li>
        <li><a href="#可选类型">可选类型</a></li>
      </ul>
    </li>
    <li><a href="#对象类型">对象类型</a>
      <ul>
        <li><a href="#初始化器">初始化器</a>
          <ul>
            <li><a href="#代理初始化器">代理初始化器</a></li>
            <li><a href="#可失败的初始化器">可失败的初始化器</a></li>
          </ul>
        </li>
        <li><a href="#属性">属性</a></li>
        <li><a href="#方法">方法</a></li>
        <li><a href="#下标">下标</a></li>
        <li><a href="#内嵌类型">内嵌类型</a></li>
      </ul>
    </li>
    <li><a href="#枚举">枚举</a>
      <ul>
        <li><a href="#rawvalue">rawValue</a></li>
        <li><a href="#associated-values">Associated Values</a></li>
        <li><a href="#enum-case-iteration">Enum Case Iteration</a></li>
        <li><a href="#enum-initializers">Enum Initializers</a></li>
        <li><a href="#enum-properties">Enum Properties</a></li>
        <li><a href="#method">method</a></li>
      </ul>
    </li>
    <li><a href="#结构体">结构体</a>
      <ul>
        <li><a href="#init">init</a></li>
        <li><a href="#properties">Properties</a></li>
        <li><a href="#method-1">method</a></li>
        <li><a href="#struct-as-namespace">Struct as Namespace</a></li>
      </ul>
    </li>
    <li><a href="#classes">Classes</a>
      <ul>
        <li><a href="#value-types-and-reference-types">Value Types and Reference Types</a></li>
        <li><a href="#mutating-captured-self">Mutating Captured Self</a></li>
        <li><a href="#类引用是指针">类引用是指针</a></li>
        <li><a href="#subclass-and-superclass">subclass and superclass</a></li>
        <li><a href="#class-initializers">class initializers</a></li>
        <li><a href="#class-deinitializer">class deinitializer</a></li>
        <li><a href="#class-properties">class properties</a></li>
        <li><a href="#staticclass-members">Static/Class Members</a></li>
        <li><a href="#多态">多态</a></li>
        <li><a href="#casting">Casting</a></li>
        <li><a href="#type-references">Type References</a></li>
        <li><a href="#comparing-types">Comparing Types</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
    </div>
</section>

  </div>
</aside>

      </div>
    </main>
   
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  <span itemprop="copyrightYear">  &copy; 
  2017 - 2022</span>
  <span class="with-love"><i class="fa fa-heart"></i></span>
  <span class="author" itemprop="copyrightHolder">Keep It Simple</span>
</div>




      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      <span id="scrollpercent"><span>0</span>%</span>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/jquery/index.js?v=2.1.3"></script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script> 
<script type="text/javascript" src="https://iihui.github.io/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/velocity/velocity.min.js?v=1.2.1"></script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="https://iihui.github.io/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>

<script src="https://iihui.github.io/js/vendor/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>

<script type="text/javascript" src="https://iihui.github.io/js/utils.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/motion.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/affix.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/schemes/pisces.js"></script>

<script type="text/javascript" src="https://iihui.github.io/js/scrollspy.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/post-details.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/toc.js"></script>

<script type="text/javascript" src="https://iihui.github.io/js/bootstrap.js"></script>

<script type="text/javascript" src="https://iihui.github.io/js/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
</body>
</html>