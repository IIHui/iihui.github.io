<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
    <title>selection 对象 - Keep It Simple</title>
    <meta name="keywords" content="博客,思考,读书,笔记,技术,分享">
    
    <meta property="og:title" content="selection 对象">
    <meta property="og:site_name" content="Keep It Simple">
    <meta property="og:image" content="/img/author.jpg"> 
    <meta name="title" content="selection 对象 - Keep It Simple" />
    <meta name="description" content="Swift | Go | C&#43;&#43; "> 
    <link rel="shortcut icon" href="https://iihui.github.io/img/favicon.ico" />
    <link rel="apple-touch-icon" href="https://iihui.github.io/img/apple-touch-icon.png" />
    <link rel="apple-touch-icon-precomposed" href="https://iihui.github.io/img/apple-touch-icon.png" />
    <link href="https://iihui.github.io/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />
    <link href="https://iihui.github.io/js/vendor/fancybox/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />
    <link href="https://iihui.github.io/css/main.css" rel="stylesheet" type="text/css" />
    <link href="https://iihui.github.io/css/syntax.css" rel="stylesheet" type="text/css" />

    <script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
     fancybox: true, 
    motion: true
  };
</script>

    <link href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/monokai-sublime.min.css" rel="stylesheet">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/go.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/swift.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/objectivec.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/clojure.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/kotlin.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/yaml.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<div class="container one-collumn sidebar-position-left page-home  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-meta  custom-logo ">

  <div class="custom-logo-site-title">
    <a href="https://iihui.github.io/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Keep It Simple</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">靡不有初，鲜克有终</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
    <ul id="menu" class="menu">
      
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/tags/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-tag"></i> <br />标签
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/post/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/categories/%E7%BE%8E%E9%A3%9F/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-fire"></i> <br />美食
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/categories/%E5%90%8E%E6%9C%9F/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-edit"></i> <br />后期
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/categories/%E6%97%85%E8%A1%8C/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-leaf"></i> <br />旅行
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/about/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于
          </a>
        </li>
      
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger"> <i class="menu-item-icon fa fa-search fa-fw"></i> <br /> 搜索</a>
      </li>
    </ul>
    <div class="site-search">
      <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>

    </div>
</nav>
<script type="text/javascript"
        async
        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
		<!-- src = "http://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> <\!--  -\-> -->
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>

<!DOCTYPE html>
<html lang="en">


<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css" integrity="sha384-D+9gmBxUQogRLqvARvNLmA9hS2x//eK1FhVb9PiU86gmcrBrJAQT8okdJ4LMp2uv" crossorigin="anonymous">

    
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js" integrity="sha384-483A6DwYfKeDa0Q52fJmxFXkcPCFfnXMoXblOkJ4JcA8zATN6Tm78UNL72AKk+0O" crossorigin="anonymous"></script>
</head>
<body>

</body>
</html>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
<section id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="https://iihui.github.io/post/js-selection/" itemprop="url">
        selection 对象
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">创建: </span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2018-12-17">
    2018-12-17
</time>
</span>
&nbsp; | &nbsp;
<span class="post-updated-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-check-o"></i>
</span>
<span class="post-meta-item-text">更新: </span>
<time itemprop="dateUpdated" content="2018-12-17">
    2018-12-17
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类: </span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="https://iihui.github.io/categories/code" itemprop="url" rel="index">
        <span itemprop="name">code</span>
      </a>
      &nbsp; 
    </span>
  
</span>


      <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-file-word-o"></i>
</span>
<span class="post-meta-item-text">字数: </span>
<span class="leancloud-visitors-count">38689</span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-coffee"></i>
</span>
<span class="post-meta-item-text">阅读: </span>
<span class="leancloud-visitors-count">78 分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <blockquote>
<p>在富文本编辑器中，需要控制光标的各种状态信息，位置信息。浏览器提供了<code>selection</code>对象和<code>range</code>对象来操作光标。</p>
</blockquote>
<h2 id="selection">selection</h2>
<p><code>Selection</code>对象表示<font color=red>用户选择的文本范围或插入符号的当前位置</font>。它代表页面中的<font color=red>文本选区</font>，<font color=Blue>可能横跨多个元素<code>(element)</code></font>，文本选区由用户<font color=Blue>拖拽鼠标</font>而产生。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">selection</span> <span style="color:#f92672">=</span> window.<span style="color:#a6e22e">getSelection</span>();
</span></span></code></pre></div><p>通常需要操作<code>selection</code>对象所对应的用户选择区<code>(range)</code>(俗称<font color=Blue>拖蓝</font>)，获取方式为:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">selection</span>.<span style="color:#a6e22e">rangeCount</span> <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">range</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">selection</span>.<span style="color:#a6e22e">getRangeAt</span>(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//或者
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">selection</span>.<span style="color:#a6e22e">rangeCount</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">range</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">selection</span>.<span style="color:#a6e22e">getRangeAt</span>(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="range对象">range对象</h2>
<p><code>range</code>对象代表页面上<font color=red>一段连续的区域</font>，通过<code>range</code>对象可以<font color=Blue>获取或者修改</font>页面上的任何区域，也可以通过<code>Range</code>的方法进行<font color=Blue>复制和移动</font>页面上的任何区域。</p>
<p><img src="https://i.loli.net/2018/12/18/5c18b8dbd9942.jpg" alt="-c600"></p>
<ul>
<li>
<p><code>startContainer</code>: <code>range</code>范围的起始节点。</p>
</li>
<li>
<p><code>endContainer</code>:<code>range</code> 范围的结束节点。</p>
</li>
<li>
<p><code>startOffset</code>: 如果<code>startContainer</code>是<font color=Blue>文本节点、注释节点、或者<code>CDATA</code>节点</font>，则返回起点在<code>startContainer</code>中的字符偏移量，如果<code>startContainer</code>是<font color=red>元素节点</font>，则返回起点在<code>startContainer.childNodes</code>中的次序。</p>
</li>
<li>
<p><code>endOffset</code>: 表示终点，含义与<code>startOffset</code>类似。</p>
</li>
<li>
<p><code>commonAncestorContainer</code>: 返回包含<code>startContainer</code>和<code>endContainer</code>的最近祖先节点。</p>
</li>
<li>
<p><code>collapsed</code>:返回一个用于判断<code>range</code>起始位置和终止位置<font color=LightSeaGreen>是否相同的布尔值</font>。</p>
</li>
</ul>
<p><img src="https://i.loli.net/2018/12/18/5c18ba277dc61.jpg" alt="-c600"></p>
<h2 id="range常用方法">range常用方法</h2>
<ul>
<li>
<p><code>setStart(node,offset)</code>:设置起点的位置，<code>node</code>是对<code>startContainer</code>的引用，偏移则是<code>startOffset</code>。</p>
</li>
<li>
<p><code>setEnd(node,offset)</code>: 设置的终点的位置，<code>node</code>是对<code>endContainer</code>的引用，偏移则是<code>endOffset</code>。</p>
</li>
<li>
<p><code>selectNode(referenceNode)</code>：设置<code>Range</code>的范围，包括<code>referenceNode</code>和它的所有子孙节点。</p>
</li>
<li>
<p><code>selectNodeContents(referenceNode)</code>设置<code>Range</code>的范围，包括它的<font color=Blue>所有后代节点</font>，但<font color=red>不包含</font><code>referenceNode</code>节点。与<code>selectNode</code>区别较大。</p>
</li>
<li>
<p><code>collapse(bool)</code>: 向起点<code>start</code>折叠。</p>
</li>
<li>
<p><code>insertNode(node)</code>: 在<code>range</code>的<font color=Blue>起始处</font>插入节点。</p>
</li>
<li>
<p><code>cloneRange()</code>: 返回一个当前<code>Range</code>的副本</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">resetRange</span>(<span style="color:#a6e22e">startContainer</span>, <span style="color:#a6e22e">startOffset</span>, <span style="color:#a6e22e">endContainer</span>, <span style="color:#a6e22e">endOffset</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">selection</span> <span style="color:#f92672">=</span> window.<span style="color:#a6e22e">getSelection</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">selection</span>.<span style="color:#a6e22e">removeAllRanges</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">range</span> <span style="color:#f92672">=</span> document.<span style="color:#a6e22e">createRange</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">range</span>.<span style="color:#a6e22e">setStart</span>(<span style="color:#a6e22e">startContainer</span>, <span style="color:#a6e22e">startOffset</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">range</span>.<span style="color:#a6e22e">setEnd</span>(<span style="color:#a6e22e">endContainer</span>, <span style="color:#a6e22e">endOffset</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">selection</span>.<span style="color:#a6e22e">addRange</span>(<span style="color:#a6e22e">range</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><a href="https://www.jianshu.com/p/ad2f818cc3b0">参考资料</a></p>
<h1 id="chapter-1">Chapter 1</h1>
<p>在ES6及更高版本，有一种定义函数的简洁语法。这种简洁的语法使用箭头<code>=&gt;</code>来分隔参数列表和函数体，以这种方式定义的函数被称为箭头函数。箭头函数常用于将一个未命名的函数作为参数传递给另一个函数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">plus1</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">x</span> =&gt; <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">square1</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">x</span> =&gt; <span style="color:#a6e22e">x</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">x</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">plus1</span>(<span style="color:#ae81ff">12</span>)) <span style="color:#75715e">// 13
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">square1</span>(<span style="color:#ae81ff">3</span>)) <span style="color:#75715e">// 9
</span></span></span></code></pre></div><h1 id="chapter-2">Chapter 2</h1>
<p><code>JavaScript</code>是一种<font color=red>区分大小写的语言</font>，并会忽略程序中标记之间的空格。多数情况下，也会忽略换行符（但有例外情况）。因为可以在程序中自由使用空格和换行符，所以能以整齐一致的方式格式化和缩进程序，使代码易于阅读。</p>
<p>像其它语言一样，<code>JavaScript</code>使用分号分隔不同的语句。<font color=red>若两条语句分别写在不同的行上，通常可以省略它们之间的分号</font>。</p>
<p>需要注意的是，并不是会将每一个换行符都视为分号，只有在不添加隐式分号就无法继续解析代码的情况下，才会将换行符视为分号。更确切地说（除了稍后要介绍的三种例外情况），如果下一个非空格字符不能被解释为当前语句的继续，才会将换行符视为分号。</p>
<h1 id="chapter-3">Chapter 3</h1>
<p><code>JavaScript</code>的类型被分为两大类，基础类型和对象类型。特殊值<code>null</code>和<code>undefined</code>也是基础类型值，但它们不是数值，字符串或布尔值。<font color=red>这两个值通常认为是各自类型的唯一成员</font>。</p>
<p>只要不是数字、字符串、布尔值、<code>Symbol</code>、<code>null</code>或<code>undefined</code>，其他值都是对象。对象是属性的集合，每个属性都有一个名称和一个值。普通的对象是<font color=Blue>无序的名字和值的集合</font>，函数和类也是特殊的对象。</p>
<h2 id="number">Number</h2>
<p>当一个数字直接出现在程序中时，它被称为数值字面量。可以在数字字面量中使用下划线，将较长的字面量分割成更易于阅读的字块：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">billion</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1_000_000_000</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">bytes</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x89</span><span style="color:#a6e22e">_AB_CD_EF</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">bits</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0b0001</span><span style="color:#a6e22e">_1101_0111</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">fraction</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.123</span><span style="color:#a6e22e">_456_789</span>;
</span></span></code></pre></div><p><code>JavaScript</code>的算术运算在<font color=red>溢出、下溢或除以零的情况下都不会产生错误</font>。当数值运算的结果超过最大可表示的数值（溢出）时，其结果是一个特殊的无穷大值，即<code>Infinity</code>。同样，当负数的绝对值大于负数的最大绝对值时，结果就是负无穷大，即<code>-Infinity</code>。无穷大数值的行为与我们所期望的一样，它与任何数值相加、相减、相乘或相除的结果都是无穷大数值（可能符号相反）。</p>
<p>当数值运算的结果<font color=red>比可表示的最小数字更接近零时，就会出现下溢</font>。在这种情况下，<code>JavaScript</code>返回0。如果负数出现下溢，<code>JavaScript</code>会返回一个被称为<code>negative zero</code>特殊值。这个值与普通的0几乎没有区别，很少的情况需要区别。</p>
<p>在<code>JavaScript</code>中，<font color=LightSeaGreen>除以0并不会产生一个错误</font>，它只是简单地返回正无穷或负无穷。但有一个例外，<font color=red>0除以0并不会返回一个明确定义的数值，而是返回<code>NaN</code></font>。如果尝试用无穷大除以无穷大、取负数的平方根或使用不能转换为数字的非数字操作数的算术运算符，也会得到<code>NaN</code>。</p>
<p><code>JavaScript</code>预定义了全局常量<code>Infinity</code>和<code>NaN</code>，用于保存正无穷大和非数字值，这些值也可以作为<code>Number</code>对象的属性使用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">Infinity</span>, Number.<span style="color:#a6e22e">POSITIVE_INFINITY</span>, <span style="color:#ae81ff">1</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">0</span>, Number.<span style="color:#a6e22e">MAX_VALUE</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#f92672">-</span><span style="color:#66d9ef">Infinity</span>, Number.<span style="color:#a6e22e">NEGATIVE_INFINITY</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span>Number.<span style="color:#a6e22e">MAX_VALUE</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">NaN</span>, Number.<span style="color:#66d9ef">NaN</span>, <span style="color:#ae81ff">0</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">Infinity</span> <span style="color:#f92672">/</span> <span style="color:#66d9ef">Infinity</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(Number.<span style="color:#a6e22e">MIN_VALUE</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>, <span style="color:#f92672">-</span>Number.<span style="color:#a6e22e">MIN_VALUE</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">/</span> <span style="color:#66d9ef">Infinity</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行后的结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">Infinity</span> <span style="color:#66d9ef">Infinity</span> <span style="color:#66d9ef">Infinity</span> <span style="color:#66d9ef">Infinity</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">-</span><span style="color:#66d9ef">Infinity</span> <span style="color:#f92672">-</span><span style="color:#66d9ef">Infinity</span> <span style="color:#f92672">-</span><span style="color:#66d9ef">Infinity</span> <span style="color:#f92672">-</span><span style="color:#66d9ef">Infinity</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">NaN</span> <span style="color:#66d9ef">NaN</span> <span style="color:#66d9ef">NaN</span> <span style="color:#66d9ef">NaN</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">0</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">0</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">0</span>
</span></span></code></pre></div><p><code>NaN</code>有一个不同寻常的特性：<font color=red>它不与任何其它值（包括它自己）进行比较</font>。这意味着不能使用<code>x === NAN</code>来判断<code>x</code>的值是否为<code>NaN</code>。相反，必须写成<code>x != x</code>或<code>Number.isNaN(x)</code>来判断<code>x</code>的值是否为<code>NaN</code>。当且仅当<code>x</code>的值与全局常量<code>NaN</code>相同时，这些表达式才会为<code>true</code>。</p>
<p>全局函数<code>isNaN()</code>和<code>Number.isNaN()</code>是相似的。如果参数为<code>NaN</code>，或者参数为无法转换为数字的值，则返回<code>true</code>。如果函数<code>Number.isFinite()</code>的参数是<code>NaN、Infinity</code>或<code>-Infinity</code>以外的数字，则返回<code>true</code>。如果全局函数<code>isFinite()</code>的参数是或可以转换为有限数值，则返回<code>true</code>。</p>
<p>负零值也有些不同寻常，<font color=red>它与正零比较是相等的</font>（即使是使用<code>JavaScript</code>的严格相等进行测试），这意味着这两个值几乎没有区别，除非用作除数时：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> zero = <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> negz = <span style="color:#f92672">-</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>console.log(zero === negz)
</span></span><span style="display:flex;"><span>console.log(<span style="color:#ae81ff">1</span> <span style="color:#f92672">/</span> zero, <span style="color:#ae81ff">1</span> <span style="color:#f92672">/</span> negz)
</span></span><span style="display:flex;"><span>console.log(<span style="color:#ae81ff">1</span> <span style="color:#f92672">/</span> zero === <span style="color:#ae81ff">1</span> <span style="color:#f92672">/</span> negz)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行的结果</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>Infinity <span style="color:#f92672">-</span>Infinity
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">false</span>
</span></span></code></pre></div><h3 id="binary-floating-point-and-rounding-errors">Binary Floating-Point and Rounding Errors</h3>
<p>实数有无限多个，但<code>JavaScript</code>的浮点格式只能表示其中的有限个数。也就是说，在处理实数时，<font color=LightSeaGreen>数字的表示往往是实际数字的近似值</font>。</p>
<p><code>JavaScript</code>使用的<code>IEEE-754</code>浮点表示法是一种二进制表示法。这种表示法可以精确地表示<code>1/2</code>,<code>1/8</code>和<code>1/1024</code>等，但不能精确地表示<code>0.1</code>。虽然这种表示法有足够高的精度，能够让数值非常近似地表示<code>0.1</code>，但也无法精确地表示，这可能会导致一些问题：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> x = .<span style="color:#ae81ff">3</span> <span style="color:#f92672">-</span> .<span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> y = .<span style="color:#ae81ff">2</span> <span style="color:#f92672">-</span> .<span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>console.log(x, y) <span style="color:#75715e">// 0.09999999999999998 0.1</span>
</span></span><span style="display:flex;"><span>console.log(x === y) <span style="color:#75715e">// false</span>
</span></span><span style="display:flex;"><span>console.log(x === .<span style="color:#ae81ff">1</span>, y === .<span style="color:#ae81ff">1</span>) <span style="color:#75715e">// false true</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 打印的结果</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0.09999999999999998</span> <span style="color:#ae81ff">0.1</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">false</span> <span style="color:#66d9ef">true</span>
</span></span></code></pre></div><p>上面代码中，由于舍入误差<code>.3</code>和<code>.2</code>近似值之差与<code>.2</code>和<code>.1</code>近似值之差并不相等。但这并不是<code>JavaScript</code>特有的问题，而是所有使用二进制浮点数编程语言共有的问题。</p>
<p>此外，请注意上面代码中的<code>x</code>和<code>y</code>值非常接近，也极其接近正确值。计算出来的值几乎可以满足任何需要，但当试图比较两个值是否相等时才会出现问题。</p>
<p>如果使用浮点近似值对我们的程序有问题，<font color=red>可以考虑使用缩放整数</font>。例如，可以使用整数值而不是小数值来处理货币。</p>
<h3 id="arbitrary-precision-integers-with-bigint">Arbitrary Precision Integers with BigInt</h3>
<p>在ES2020中定义的最新特性之一是一种名为<code>BigInt</code>的新数值类型。顾名思义，<code>BigInt</code>是一种数值类型，其值为整数。添加<code>BigInt</code>类型主要是为了允许表示64位整数</font>，这是与许多其他编程语言和API兼容所必需的。</p>
<p>如果需要处理比较大的数字，<code>BigInt</code>值以有数千甚至数百万位。但请注意，<font color=red><code>BigInt</code>并不适合用于加密，因为它实现时没有考虑预防时序攻击</font>。</p>
<p><code>BigInt</code>字面量是一串数字后面跟小写字母<code>n</code>。默认情况下，字面量的基数是<code>10</code>，但可以通过前置<code>0b,0o和0x</code>来表示二进制、八进制和十六进制。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#ae81ff">1234</span><span style="color:#a6e22e">n</span>, <span style="color:#ae81ff">0b11111</span><span style="color:#a6e22e">n</span>, <span style="color:#ae81ff">0o7777</span><span style="color:#a6e22e">n</span>, <span style="color:#ae81ff">0x8000000</span><span style="color:#a6e22e">n</span>) <span style="color:#75715e">// 1234n 31n 4095n 134217728n
</span></span></span></code></pre></div><p>可以使用<code>BigInt()</code>函数把普通的数值或字符串转换为<code>BigInt</code>值:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">BigInt</span>(Number.<span style="color:#a6e22e">MAX_SAFE_INTEGER</span>))
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">string</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;1&#34;</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;0&#34;</span>.<span style="color:#a6e22e">repeat</span>(<span style="color:#ae81ff">30</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">BigInt</span>(<span style="color:#a6e22e">string</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 打印的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">9007199254740991</span><span style="color:#a6e22e">n</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1000000000000000000000000000000</span><span style="color:#a6e22e">n</span>
</span></span></code></pre></div><p><code>BigInt</code>的算术运算与常规数值的算术运算类似，只不过<font color=red>除法会丢弃余数，并向下取整</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#ae81ff">1000</span><span style="color:#a6e22e">n</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">2000</span><span style="color:#a6e22e">n</span>, <span style="color:#ae81ff">2000</span><span style="color:#a6e22e">n</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">3000</span><span style="color:#a6e22e">n</span>, <span style="color:#ae81ff">3000</span><span style="color:#a6e22e">n</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">997</span><span style="color:#a6e22e">n</span>, <span style="color:#ae81ff">3000</span><span style="color:#a6e22e">n</span> <span style="color:#f92672">%</span> <span style="color:#ae81ff">997</span><span style="color:#a6e22e">n</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 打印的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">3000</span><span style="color:#a6e22e">n</span> <span style="color:#ae81ff">6000000</span><span style="color:#a6e22e">n</span> <span style="color:#ae81ff">3</span><span style="color:#a6e22e">n</span> <span style="color:#ae81ff">9</span><span style="color:#a6e22e">n</span>
</span></span></code></pre></div><p>虽然<code>+, -, *, /, %</code>和<code>**</code>运算符号均可以用于<code>BigInt</code>。但必须注意的是，<font color=LightSeaGreen>不能将<code>BigInt</code>类型的操作数与普通数字操作数混合使用</font>。</p>
<p>但是，<font color=red>比较运算符可以处理混合类型</font>。位操作数通常可以用于<code>BigInt</code>操作数，但<code>Math</code>对象的任何函数都不接收<code>BigInt</code>操作数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">timestamp</span> <span style="color:#f92672">=</span> Date.<span style="color:#a6e22e">now</span>(); <span style="color:#75715e">// The current time as a timestamp (a number).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">now</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Date(); <span style="color:#75715e">// The current time as a Date object.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">ms</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">now</span>.<span style="color:#a6e22e">getTime</span>(); <span style="color:#75715e">// Convert to a millisecond timestamp.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">iso</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">now</span>.<span style="color:#a6e22e">toISOString</span>(); <span style="color:#75715e">// Convert to a string in standard format.
</span></span></span></code></pre></div><h2 id="text">Text</h2>
<p>表示文本的类型是字符串。字符串是由<code>16bit</code>值组成的不可变有序序列，每个数值通常代表一个<code>Unicode</code>字符。字符串的长度就是它包含<code>16bit</code>值的个数。字符串（及其数组）使用基于0的索引，第一个<code>16bit</code>值的索引为0，第二个<code>16bit</code>值的索引为1，以此类推。</p>
<p>空字符串就是长度为0的字符串。 <code>JavaScript</code><font color=Blue>没有表示字符串中单个元素的特殊类型</font>。若要表示单个<code>16bit</code>值，只需使用长度为1的字符串。</p>
<p><code>JavaScript</code>使用<code>UTF-16</code>编码<code>Unicode</code>字符集 ，字符串是无符号<code>16bit</code>值序列。常见的<code>Unicode</code>字符，它的码点适合<code>16bit</code>，并且可以用字符串的一个元素来表示。若<code>Unicode</code>字符的码点不适合用<code>16bit</code>来表示的，则使用<code>UTF-16</code>规则编码为两个<code>16bit</code>值的序列（称为<code>surrogate pair</code>）。这意味着长度为2（两个<code>16bit</code>值）的<code>JavaScript</code>字符串可能只代表一个<code>Unicode</code>字符：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>euro = <span style="color:#e6db74">&#34;€&#34;</span>;
</span></span><span style="display:flex;"><span>love = <span style="color:#e6db74">&#34;😍&#34;</span>;
</span></span><span style="display:flex;"><span>console.log(euro.length, love.length)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 打印的值</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span>
</span></span></code></pre></div><p><code>JavaScript</code>定义的<font color=red>大多数字符串方法都是对<code>16bit</code>值而非字符进行操作</font>。它们不会特殊处理<code>surrogate pair</code>，不会对字符串进行归一化处理，甚至不会确保字符串是格式正确的<code>UTF-16</code>字符串。</p>
<p>在ES6中字符串是可迭代的。需要注意的是，如果对字符串使用<code>for/of</code>循环或<code>...</code>操作符，迭代的是字符而不是<code>16bit</code>值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">str</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;😍4567&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;str length:&#34;</span>, <span style="color:#a6e22e">str</span>.<span style="color:#a6e22e">length</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">item</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">str</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">item</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">str</span> <span style="color:#a6e22e">length</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">6</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">😍</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">6</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">7</span>
</span></span></code></pre></div><h3 id="string-literals">String Literals</h3>
<p>若要使用字符串字面量，可以将字符串放到<font color=red>一对匹配的单引号，双引号或者反引号中</font>。双引号和反引号字符可以出现在由单引号包含的字符串，反引号和单引号类似。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;</span> <span style="color:#75715e">// The empty string: it has zero characters 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#e6db74">&#39;testing&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;3.14&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;name=&#34;myform&#34;&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;Wouldn&#39;t you prefer O&#39;Reilly&#39;s book?&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;τ is the ratio of a circle&#39;s circumference to its radius&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">`&#34;She said &#39;hi&#39;&#34;, he said.`</span> <span style="color:#75715e">// length 25
</span></span></span></code></pre></div><p>使用<font color=red>反引号包含字符串是ES6的一大特色</font>，它允许将表达式插值到字符串字面中。最早版本的<code>JavaScript</code>要求字符串字面量写在一行上，因此可能经常看到代码通过使用<code>+</code>运算符连接单行字符串来创建长字符串。</p>
<p>但是，从ES5开始，可以在每一行（最后一行除外）的结尾使用反斜线，将字符串字面量分成多行。<font color=red>反斜线和它后面的行结束符都不是字符串字面量的一部分</font>。</p>
<p>如果需要在单引号或双引号字符串字面量中包含换行符，需要使用字符<code>\n</code>。ES6的字符串反引号语法允许将字符串分成多行，在这种情况下，行结束符是字符串字面量的一部分：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">// A string representing 2 lines written on one line:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">s1</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;two\nlines&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// A one-line string written on 3 lines:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#e6db74">&#34;one\
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">long\
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">line&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// A two-line string written on two lines:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#e6db74">`the newline character at the end of this line 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">is included literally in this string`</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">s1</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;two\nlines&#39;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">s2</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;one\
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">long\
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">line&#34;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">s3</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">`the newline character at the end of this line 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">is included literally in this string`</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">s1</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">s2</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">s3</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">two</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">lines</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">onelongline</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">the</span> <span style="color:#a6e22e">newline</span> <span style="color:#a6e22e">character</span> <span style="color:#a6e22e">at</span> <span style="color:#a6e22e">the</span> <span style="color:#a6e22e">end</span> <span style="color:#66d9ef">of</span> <span style="color:#66d9ef">this</span> <span style="color:#a6e22e">line</span> 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">is</span> <span style="color:#a6e22e">included</span> <span style="color:#a6e22e">literally</span> <span style="color:#66d9ef">in</span> <span style="color:#66d9ef">this</span> <span style="color:#a6e22e">string</span>
</span></span></code></pre></div><p>需要注意的是，在使用单引号定界字符串时，必须注意英文里的缩写和所有格形式，比如<code>can't</code>和<code>O'Reilly</code>中的单引号，此时需要使用反斜杠字符进行转义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#e6db74">&#39;You\&#39;re right, it can\&#39;t be a quote&#39;</span>
</span></span></code></pre></div><p>反斜杠在<code>JavaScript</code>字符串中有特殊作用，它与后面的字符组合在一起，可以在字符串中表示一个无法直接表示的字符，例如<code>\n</code>表示一个换行符。在上面示例代码中，之所以称为转义序列，就是<font color=red>反斜杠转换了通常意义上单引号的含义</font>，不再表示字符串定界符。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">str</span> <span style="color:#f92672">=</span>  <span style="color:#e6db74">&#39;dddt\oonnn&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">str</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 打印的结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">dddtoonnn</span>
</span></span></code></pre></div><p>拼接字符串是<code>JavaScript</code>的一个内置特性，如果对字符串使用<code>+</code>操作符，那么字符串就会拼接起来。可以使用标准的<code>===</code>或<code>!==</code>操作符比较字符串，只有当这两个字符串具有<font color=Blue>完全相同的<code>16bit</code>序列值才相等</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">msg</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Hello,&#34;</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;world&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">greeting</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Welcome to my blog&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">greeting</span>)
</span></span></code></pre></div><p>字符串也可以使用<code>&lt;,&lt;=,&gt;,&gt;=</code>操作符，字符串的比较都是<font color=red>通过比较<code>16bit</code>值来完成的</font>。要确定一个字符串的长度可以使用其<code>length</code>属性：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">length</span>
</span></span></code></pre></div><p>字符串还有其它相关API：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Hello,&#34;</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;world&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Obtaining portions of a string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">substring</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">4</span>) <span style="color:#75715e">// ell
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">slice</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">4</span>)  <span style="color:#75715e">// ell
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">slice</span>(<span style="color:#f92672">-</span><span style="color:#ae81ff">3</span>)  <span style="color:#75715e">// rld
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">split</span>(<span style="color:#e6db74">&#34;, &#34;</span>) <span style="color:#75715e">// [&#34;Hello&#34;,&#34;world&#34;]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Searching a string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">indexOf</span>(<span style="color:#e6db74">&#34;l&#34;</span>) <span style="color:#75715e">// 2: position of first letter l
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">indexOf</span>(<span style="color:#e6db74">&#34;l&#34;</span>, <span style="color:#ae81ff">3</span>) <span style="color:#75715e">// 3: position of first &#34;l&#34; at or after 3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">indexOf</span>(<span style="color:#e6db74">&#34;zz&#34;</span>)  <span style="color:#75715e">// -1: s does not include the substring &#34;zz&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">lastIndexOf</span>(<span style="color:#e6db74">&#34;l&#34;</span>) <span style="color:#75715e">// 10: position of last letter l
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Boolean searching functions in ES6 and later 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">startsWith</span>(<span style="color:#e6db74">&#34;Hell&#34;</span>) <span style="color:#75715e">// =&gt; true: the string starts with these 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">endsWith</span>(<span style="color:#e6db74">&#34;!&#34;</span>) <span style="color:#75715e">// =&gt; false: s does not end with that 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">includes</span>(<span style="color:#e6db74">&#34;or&#34;</span>) <span style="color:#75715e">// =&gt; true: s includes substring &#34;or&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Creating modified versions of a string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">replace</span>(<span style="color:#e6db74">&#34;llo&#34;</span>, <span style="color:#e6db74">&#34;ya&#34;</span>) <span style="color:#75715e">// =&gt; &#34;Heya, world&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">toLowerCase</span>()
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">toUpperCase</span>()
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">normalize</span>()   <span style="color:#75715e">// Unicode NFC normalization: ES6
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">normalize</span>(<span style="color:#e6db74">&#34;NFD&#34;</span>) <span style="color:#75715e">// NFD normalization. Also &#34;NFKC&#34;, &#34;NFKD&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Inspecting individual (16-bit) characters of a string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">charAt</span>(<span style="color:#ae81ff">0</span>) <span style="color:#75715e">// =&gt; &#34;H&#34;: the first character
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">charAt</span>(<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">length</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#75715e">// =&gt; &#34;d&#34;: the last character 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">charCodeAt</span>(<span style="color:#ae81ff">0</span>) <span style="color:#75715e">// =&gt; 72: 16-bit number at the specified position 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">codePointAt</span>(<span style="color:#ae81ff">0</span>) <span style="color:#75715e">// =&gt; 72: ES6, works for codepoints &gt; 16 bits
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// String padding functions in ES2017
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#e6db74">&#34;x&#34;</span>.<span style="color:#a6e22e">padStart</span>(<span style="color:#ae81ff">3</span>) <span style="color:#75715e">// =&gt; &#34;  x&#34;: add spaces on the left to a length of 3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#e6db74">&#34;x&#34;</span>.<span style="color:#a6e22e">padEnd</span>(<span style="color:#ae81ff">3</span>) <span style="color:#75715e">// =&gt; &#34;x  &#34;: add spaces on the right to a length of 3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#e6db74">&#34;x&#34;</span>.<span style="color:#a6e22e">padStart</span>(<span style="color:#ae81ff">3</span>, <span style="color:#e6db74">&#34;*&#34;</span>) <span style="color:#75715e">// =&gt; &#34;**x&#34;: add stars on the left to a length of 3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#e6db74">&#34;x&#34;</span>.<span style="color:#a6e22e">padEnd</span>(<span style="color:#ae81ff">3</span>, <span style="color:#e6db74">&#34;-&#34;</span>) <span style="color:#75715e">// =&gt; &#34;x--&#34;: add dashes on the right to a length of 3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Space trimming functions. trim() is ES5; others ES2019 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#e6db74">&#34; test &#34;</span>.<span style="color:#a6e22e">trim</span>() <span style="color:#75715e">// =&gt; &#34;test&#34;: remove spaces at start and end 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#e6db74">&#34; test &#34;</span>.<span style="color:#a6e22e">trimStart</span>() <span style="color:#75715e">// =&gt; &#34;test &#34;: remove spaces on left. Also trimLeft 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#e6db74">&#34; test &#34;</span>.<span style="color:#a6e22e">trimEnd</span>() <span style="color:#75715e">// =&gt; &#34; test&#34;: remove spaces at right. Also trimRight
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Miscellaneous string methods
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">concat</span>(<span style="color:#e6db74">&#34;!&#34;</span>) <span style="color:#75715e">// =&gt; &#34;Hello, world!&#34;: just use + operator instead 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#e6db74">&#34;&lt;&gt;&#34;</span>.<span style="color:#a6e22e">repeat</span>(<span style="color:#ae81ff">5</span>) <span style="color:#75715e">// =&gt; &#34;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&#34;: concatenate n copies. ES6
</span></span></span></code></pre></div><p>需要注意的是，<font color=red>字符串是不可变的</font>。字符串的<code>replace()</code>和<code>toUpperCase()</code>等方法<font color=Blue>会返回新的字符串</font>，它们不会修改原来的字符串。字符串能够被当作只读数组，可以使用方括号而不是<code>charAt()</code>访问字符串中的单个字符（<code>16bit</code>值）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello, world&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">s</span>[<span style="color:#ae81ff">0</span>], <span style="color:#a6e22e">s</span>[<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]) <span style="color:#75715e">// h d
</span></span></span></code></pre></div><h3 id="template-literals">Template Literals</h3>
<p>在 ES6及更高版本中，字符串字面量可以用反引号分隔：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">`hello world`</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">s</span>) <span style="color:#75715e">// hello world
</span></span></span></code></pre></div><p>这不仅是另一种表示字面量的方式，更是因为<code>template literals</code>能够包含任意表达式。反引号字符串字面的<font color=LightSeaGreen>最终值是先计算包含的表达式的值，然后将这些表达式计算后的值转换为字符串</font>，最后将这些计算出的字符串与反引号字符串内的字面量相结合而得出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Bill&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">greeting</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">`Hello </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">name</span><span style="color:#e6db74">}</span><span style="color:#e6db74">.`</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">greeting</span>) <span style="color:#75715e">// Hello Bill.
</span></span></span></code></pre></div><p>在<code>${}</code>中的内容被解释成表达式，而在花括号外的内容是普通的字符串字面量。模板字面量可能包含很多表达式，它<font color=red>可以包含任何普通字符串中能够出现的转义字符，也可以跨越多行而无需转义字符</font>。</p>
<p>下面的模板字面量包含四个<code>JavaScript</code> 表达式、一个<code>Unicode</code>转义序列和至少四个换行符（表达式值中也可能包含换行符）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">errorMessage</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">`\
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">\u2718 Test failure at </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">filename</span><span style="color:#e6db74">}</span><span style="color:#e6db74">:</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">linenumber</span><span style="color:#e6db74">}</span><span style="color:#e6db74">: 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#e6db74">${</span><span style="color:#a6e22e">exception</span>.<span style="color:#a6e22e">message</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> Stack trace:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#e6db74">${</span><span style="color:#a6e22e">exception</span>.<span style="color:#a6e22e">stack</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">`</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">errorMessage</span>)
</span></span></code></pre></div><p>上面字符串第一行末尾的反斜线转义了第一个换行符，因此生成的字符串以<code>Unicode </code>字符<code>✘</code>（<code>\u2718</code>）而不是换行符开始。</p>
<p>模板字面量的一个强大但不常用的功能是，如果一个函数名（或<code>tag</code>）出现在字符串开始的反引号前面，<font color=red>那么模板字面量的文本和里面表达式的值都会传递给该函数</font>。这个<code>tagged template literal</code>的值就是这个函数的返回值。</p>
<p>ES6有一个内置的<code>tag</code>函数<code>String.raw()</code>，这个函数返回反引号中未经处理的文本，即不会处理任何反斜杠转义字符：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`\n`</span>.<span style="color:#a6e22e">length</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(String.<span style="color:#a6e22e">raw</span><span style="color:#e6db74">`\n`</span>.<span style="color:#a6e22e">length</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 打印的结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span>
</span></span></code></pre></div><p>自定义模板标签函数是一个非常强大的特性，这些函数不需要返回字符串，并且可以被当成构造函数使用，就像为语言本身定义了一种新的字面量语法一样。</p>
<h3 id="pattern-matching">Pattern Matching</h3>
<p><code>JavaScript</code>定义了一种称为正则表达式（或 <code>RegExp</code>）的数据类型，用于描述和匹配文本字符串中的模式。<code>RegExp</code><font color=red>并不是基本数据类型之一</font>，但它拥有像数字和字符串一样的字面语法，因此看起来像是基本数据类型。正则表达式字面的语法很复杂，而且它们定义的<code>API</code>也不简单。</p>
<p>一对斜杠之间的文本构成了正则表达式字面量，其中<font color=Blue>第二个斜杠后面可以跟着一个或多个字母</font>，用于修改模式的含义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#e6db74">/^HTML/</span>; <span style="color:#75715e">// Match the letters HTML at the start of a string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#e6db74">/[1-9][0-9]*/</span>; <span style="color:#75715e">// Match a nonzero digit, followed by any of digits
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#e6db74">/\bjavascript\b/i</span>; <span style="color:#75715e">// Match &#34;javascript&#34; as a word, case-insensitive
</span></span></span></code></pre></div><p><code>RegExp</code>对象定义了一系列有用的方法，字符串也有方法接收<code>RegExp</code>参数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">text</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;testing: 1, 2, 3&#34;</span>; <span style="color:#75715e">// Sample text
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">pattern</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">/\d+/g</span>; <span style="color:#75715e">// Matches all instances of one or more digits
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">pattern</span>.<span style="color:#a6e22e">test</span>(<span style="color:#a6e22e">text</span>)  <span style="color:#75715e">// =&gt; true: a match exists
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">text</span>.<span style="color:#a6e22e">search</span>(<span style="color:#a6e22e">pattern</span>) <span style="color:#75715e">// =&gt; 9: position of first match
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">text</span>.<span style="color:#a6e22e">match</span>(<span style="color:#a6e22e">pattern</span>) <span style="color:#75715e">// =&gt; [&#34;1&#34;, &#34;2&#34;, &#34;3&#34;]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">text</span>.<span style="color:#a6e22e">replace</span>(<span style="color:#a6e22e">pattern</span>, <span style="color:#e6db74">&#34;#&#34;</span>) <span style="color:#75715e">// &#34;testing: #,#,#&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">text</span>.<span style="color:#a6e22e">split</span>(<span style="color:#e6db74">/\D+/</span>) <span style="color:#75715e">// [&#34;&#34;, &#34;1&#34;, &#34;2&#34;, &#34;3&#34;]  split on nondigits
</span></span></span></code></pre></div><h2 id="boolean-values">Boolean Values</h2>
<p><code>JavaScript</code>的<font color=red>任何值都可以转换为布尔值</font>，下面的值都会转为<code>false</code>。<code>false</code>和下面能转换为<code>false</code>的6个值，被称为<code>falsy</code>值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">undefined</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">null</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">-</span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">NaN</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;</span> <span style="color:#75715e">// the empty string
</span></span></span></code></pre></div><p>其它的值，包括所有对象都能转换为<code>true</code>，<code>true</code>和这些能转换为<code>true</code>的值被称为<code>truthy</code>值。假设一个变量保存一个对象，要么其值是<code>null</code>，要么保存真正的对象，可以使用下面两种方式判断：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">o</span> <span style="color:#f92672">!==</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;o is not null&#34;</span>)
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;o is null&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">o</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;o is not null&#34;</span>)
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;o is null&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>布尔值有一个<code>toString()</code>方法，可用于将自己转换为字符串<code>&quot;true&quot;</code>或<code>&quot;false&quot;</code>。除此之外，布尔值再没有其它有用的方法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">true</span>.<span style="color:#a6e22e">toString</span>(), <span style="color:#66d9ef">false</span>.<span style="color:#a6e22e">toString</span>()) <span style="color:#75715e">// true false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">true</span> <span style="color:#66d9ef">false</span>
</span></span></code></pre></div><h2 id="null-and-undefined">null and undefined</h2>
<p><code>null</code>是一个语言关键词，用于表示某个值不存在。使用<code>typeof</code>操作符作用于<code>null</code>，将会返回字符串<code>object</code>。这表明<code>null</code>是一种特殊的对象值，它表示<code>no object</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">typeof</span> <span style="color:#66d9ef">null</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 打印的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">object</span>
</span></span></code></pre></div><p>实际上，<code>null</code>通常被视为其自身类型的唯一成员，可以用来表示数字、字符串和对象的<code>&quot;no object&quot;</code>。大多数编程语言都有与<code>JavaScript</code>的<code>null</code>相对应的值，如<code>NULL、nil</code> 或<code>None</code>。</p>
<p><code>undefined</code>也表示值不存在，但它<font color=red>表示一种更深层次的不存在</font>。具体来说，以下场景都是<code>undefined</code>:</p>
<ul>
<li>变量未初始化时值为<code>undefined</code>。</li>
<li>在查询对象不存在的属性或数组元素时也会得到<code>undefined</code>。</li>
<li>没有传实参的函数参数的值是<code>undefined</code>。</li>
</ul>
<p><code>undefined</code>是一个<font color=LightSeaGreen>预定义的全局常量</font>，而非像<code>null</code>那样是语言关键字。这个常量的初始化值就是<code>undefined</code>。对<code>undefined</code>应用<code>typeof</code>操作符会返回字符串<code>undefined</code>，表示这个值是该特殊类型的唯一成员。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">typeof</span> <span style="color:#66d9ef">undefined</span>) <span style="color:#75715e">// undefined
</span></span></span></code></pre></div><p>因为<code>null</code>和<code>undefine</code>都可以表示某个值不存在，所以经常被混用。相等操作<code>==</code>认为它们相等，要区分它们必须使用全等操作符<code>===</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">null</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">undefined</span>, <span style="color:#66d9ef">null</span> <span style="color:#f92672">===</span> <span style="color:#66d9ef">undefined</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">true</span>  <span style="color:#66d9ef">false</span>
</span></span></code></pre></div><h2 id="symbols">Symbols</h2>
<p><code>Symbols</code>是ES6引入的，<font color=red>用作非字符串属性名</font>。要了解<code>Symbols</code>，需要知道基本的<code>Object</code>类型是一个无序的属性集合，其中的每个属性都有一个名称和一个值。对象的属性名通常是字符串，但在ES6及之后，<code>Symbols</code>也可以实现这个目的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">strName</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;string name&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">symName</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Symbol</span>(<span style="color:#e6db74">&#34;propName&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">strName</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">symName</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">o</span> <span style="color:#f92672">=</span> {};
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">o</span>[<span style="color:#a6e22e">strName</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">o</span>[<span style="color:#a6e22e">symName</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">o</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">Symbol</span>())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行的结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>String
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Symbol</span>
</span></span><span style="display:flex;"><span>Object {<span style="color:#a6e22e">string</span> <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">Symbol</span>(<span style="color:#a6e22e">propname</span>)<span style="color:#f92672">:</span> <span style="color:#ae81ff">2</span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Symbol</span>()
</span></span></code></pre></div><p><code>Symbol</code>没有字面量语法，要获取一个<code>Symbol</code>值，需要调用<code>Symbol()</code>函数。<font color=red>这个函数永远不会返回相同的值，即使调用时传入相同的参数</font>。</p>
<p>这意味着，调用<code>Symbol()</code>取得的值，可以<font color=Blue>安全地作为属性名以添加对象新的属性，无需担心覆盖原有的属性</font>。类似地，可以使用那些未被共享的符号属性名，可以确保程序中的其它代码不会意外的重写这个属性。</p>
<p>实践中，<code>Symbol</code>通常用作一种语言扩展机制。ES6新增了<code>for/of</code>循环可迭代对象，为此需要定义一种标准的机制让类变成可迭代的。但是，如果选择任何特定的字符串作为这个迭代器方法名，都可能破坏已有的代码，因此<code>Symbol</code>应运而生。</p>
<p><code>Symbol()</code>函数可选地接受一个字符串参数，返回唯一的符号值。如果在调用的时候传递一个字符串参数，那么调用<code>Symbol</code>的<code>toString()</code>方法得到的结果中会包含该字符串。但传入两个相同的字符串，调用<code>Symbol</code>两次获取到的<code>Symbol</code>值是不同的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Symbol</span>(<span style="color:#e6db74">&#34;sym_x&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">toString</span>()) <span style="color:#75715e">// Symbol(sym_x)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">s1</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Symbol</span>(<span style="color:#e6db74">&#34;sym_x&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">s1</span>.<span style="color:#a6e22e">toString</span>()) <span style="color:#75715e">// Symbol(sym_x)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">s1</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">s</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 打印的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">Symbol</span>(<span style="color:#a6e22e">sym_x</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Symbol</span>(<span style="color:#a6e22e">sym_x</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">false</span>
</span></span></code></pre></div><p>方法<code>toString()</code>是<code>Symbol</code>实例中唯一有趣的方法。但是，还应该了解另外两个与<code>Symbol</code>相关的函数。有时，使用<code>Symbol</code>时希望它们是私有的，这样就可以保证自定义的属性不会与其它代码使用的属性发生冲突。</p>
<p>但有时，可能希望定义一个<code>Symbol</code>值，并与其它代码共享。如果要定义某种扩展，并希望其它代码也能使用，就会出现这种情况。</p>
<p>为了满足后一种场景，<code>JavaScript</code>定义了一个全局<code>Symbol</code>注册表。<code>Symbol.for()</code>函数接收一个字符串参数，返回一个与所传字符串相关联的<code>Symbol</code>值。如果该字符串尚未关联任何<code>Symbol</code>，则会创建并返回一个新的<code>Symbol</code>。否则，将返回已存在的<code>Symbol</code>。</p>
<p>也就是说，<code>Symbol.for()</code>函数与<code>Symbol()</code>函数完全不同。 <code>Symbol()</code>两次调用不会返回相同的值，<font color=red>但<code>Symbol.for()</code>在调用相同字符串时总是返回相同的值</font>。传递给 <code>Symbol.for()</code>的字符串会出现在返回符号的 <code>toString()</code>输出中，也可以调用<code>Symbol.keyFor()</code>来获取。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Symbol</span>.<span style="color:#66d9ef">for</span>(<span style="color:#e6db74">&#34;shared&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">t</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Symbol</span>.<span style="color:#66d9ef">for</span>(<span style="color:#e6db74">&#34;shared&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">s</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">t</span>, <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">toString</span>(), <span style="color:#a6e22e">Symbol</span>.<span style="color:#a6e22e">keyFor</span>(<span style="color:#a6e22e">t</span>))  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 打印的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">true</span> <span style="color:#a6e22e">Symbol</span>(<span style="color:#a6e22e">shared</span>) <span style="color:#a6e22e">shared</span>
</span></span></code></pre></div><h2 id="the-global-object">The Global Object</h2>
<p>全局对象的属性是全局性定义的标识符，可以在程序的任何地方使用。<code>JavaScript</code><font color=LightSeaGreen>解释器启动后或每次浏览器加载新页面时</font>，都会创建一个新的全局对象，并为这个全局对象添加一组初始的属性：</p>
<ul>
<li><code>undefined、Infinity</code>和<code>NaN</code>这样的全局常量。</li>
<li><code>isNaN()</code>，<code>parseInt()</code>和<code>eval()</code>这样的全局函数。</li>
<li><code>Date()</code>，<code>RegExp()</code>，<code>String()</code>，<code>Object()</code>和<code>Array()</code>这样的构造函数。</li>
<li><code>Math</code>和<code>JSON</code>这样的全局对象。</li>
</ul>
<p><font color=red>全局对象的初始属性不是保留字</font>，但它们应该都被当成保留字。在<code>Node</code>中，全局对象有一个属性名为<code>global</code>，表示这个全局对象本身。</p>
<p>在浏览器中，<code>Window</code>对象对浏览器窗口中所有<code>JavaScript</code>代码而言，充当了全局对象的角色。这个全局的<code>Window</code>对象有一个自引用的<code>window</code>属性，可以引用全局对象。</p>
<h2 id="immutable-primitive-values-and-mutable-object-references">Immutable Primitive Values and Mutable Object References</h2>
<p>基本类型(<code>undefined</code>，<code>null</code>，布尔值，数值和字符串）和对象类型（包括数组和函数）有一个本质区别，基本类型是不可变的，对象类型是可变的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">object</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">12</span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">object</span>.<span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">13</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">object</span>.<span style="color:#a6e22e">y</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">14</span>
</span></span></code></pre></div><p>基本类型是按值比较的，而对象类型不是按值比较的。两个不同的对象即使拥有完全相同的属性和值，它们也不相等。两个不同的数组即使具有相同顺序的相同元素，也是不相等的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">12</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">o</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>}, <span style="color:#a6e22e">p</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>};
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">o</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">p</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> [], <span style="color:#a6e22e">b</span> <span style="color:#f92672">=</span> [];
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">a</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">b</span>)
</span></span></code></pre></div><p>区别于基本数据类型，对象类型也被称为引用类型。使用这种术语，对象值就是引用，对象是按引用比较的。<font color=red>两个对象相等当且仅当它们引用同一个底层对象</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">// 数组是引用类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> [];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 引用赋值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">b</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">a</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">b</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">0</span>]) <span style="color:#75715e">// 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// a和b引用同一个对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">a</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">b</span>) <span style="color:#75715e">// true
</span></span></span></code></pre></div><p>从上面代码中可以看出，将对象（或数组）赋值给变量只是赋值引用，并不会创建对象的新副本。如果要创建对象或数组的新副本，必须明确复制对象的属性或数组的元素：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;a&#34;</span>, <span style="color:#e6db74">&#34;b&#34;</span>, <span style="color:#e6db74">&#34;c&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">b</span> <span style="color:#f92672">=</span> [];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">length</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">b</span>[<span style="color:#a6e22e">i</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">i</span>];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 复制数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">c</span> <span style="color:#f92672">=</span> Array.<span style="color:#a6e22e">from</span>(<span style="color:#a6e22e">b</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span>, <span style="color:#a6e22e">c</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">a</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">b</span>, <span style="color:#a6e22e">a</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">b</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">c</span>) 
</span></span><span style="display:flex;"><span><span style="color:#75715e">// false false false
</span></span></span></code></pre></div><p>类似的，如果想比较两个不同的对象或数组，必须比较它们的所有属性或数组中的每个元素。下面函数用于比较两个不同数组的内容是否相等：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">equalArrays</span>(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">a</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">b</span>) <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">length</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">length</span>) <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">length</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">i</span>] <span style="color:#f92672">!==</span> <span style="color:#a6e22e">b</span>[<span style="color:#a6e22e">i</span>]) <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="type-conversions">Type Conversions</h2>
<p>不同于其他静态类型语言，<code>JavaScript</code>的类型非常灵活，这一点在上面介绍布尔值已经看到了。如果在需要布尔值，我们提供了一个其它类型的值，则这些值会自动转换为布尔值。</p>
<p>对于其它类型也是一样的，如果想要一个字符，传入的任何值都会转换成字符串。如果想要数值，会尝试把传递的值转换为一个数值，如果无法转换，就会转换为<code>NaN</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#ae81ff">10</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; objects&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;7&#34;</span> <span style="color:#f92672">*</span> <span style="color:#e6db74">&#34;4&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> <span style="color:#e6db74">&#34;x&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">n</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">n</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; objects&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行的结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">10</span> <span style="color:#a6e22e">objects</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">28</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">NaN</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">NaN</span> <span style="color:#a6e22e">objects</span>
</span></span></code></pre></div><p>下面表格总结了值如何从一种类型转换成另一种类型。粗体部分突出显示了可能会让我们感到吃惊的转换。空格表示不需要进行类型转换，也不执行类型转换。</p>
<img src="https://s2.loli.net/2023/10/29/8GjWVLOzS4pt2Hk.png" alt="8GjWVLOzS4pt2Hk" style="zoom:50%;" />
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">b</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">8</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span>, <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">a</span>, <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">b</span>, Number([<span style="color:#ae81ff">8</span>]) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">11</span> <span style="color:#ae81ff">81</span> <span style="color:#a6e22e">string</span> <span style="color:#a6e22e">string</span> <span style="color:#ae81ff">9</span>
</span></span></code></pre></div><h3 id="conversions-and-equality">Conversions and Equality</h3>
<p>有两种操作符测试两个值是否相等，一种是严格相等操作符<code>===</code>，<font color=red>若两个值的类型不同，则它认为它们不相等</font>。因为<code>JavaScript</code>在类型上比较灵活，所以定义了<code>==</code>操作符，这个操作符判定相等的标准相当灵活：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">null</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">undefined</span> <span style="color:#75715e">// =&gt; true: These two values are treated as equal.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#e6db74">&#34;0&#34;</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#75715e">// =&gt; true: String converts to a number before comparing. 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">0</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">false</span> <span style="color:#75715e">// =&gt; true: Boolean converts to number before comparing. 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#e6db74">&#34;0&#34;</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">false</span> <span style="color:#75715e">// =&gt; true: Both operands convert to 0 before comparing!
</span></span></span></code></pre></div><p>需要注意的是，一个值可以转换为另一种类型，但这并不意味这两个值是相等的。例如，<code>undefined</code>在需要布尔值的地方会转换为<code>false</code>，但这不意味着<code>undefined == false</code>的结果为<code>true</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">false</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">undefined</span>) <span style="color:#75715e">// false
</span></span></span></code></pre></div><p>操作符和语句期待不同的类型，因此会执行以这些目标类型的转换。<code>if</code>语句会将<code>undefined</code>转换为<code>false</code>，但<code>==</code><font color=red>操作符不会尝试将操作数转换为布尔类型</font>。</p>
<h3 id="explicit-conversions">Explicit Conversions</h3>
<p>虽然会执行很多类型自动转换，但有时需要进行显式类型转换，以保证代码清晰。显式类型转最简单的方法是使用<code>Boolean()</code>, <code>Number()</code>和<code>String()</code>函数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(Number(<span style="color:#e6db74">&#34;3&#34;</span>), String(<span style="color:#66d9ef">false</span>), Boolean([])) <span style="color:#75715e">// 3 false true
</span></span></span></code></pre></div><p>除了<code>null</code>和<code>undefined</code>，任何其它值都有<code>toString()</code>方法，并且调用<code>toString</code>方法的返回值和直接调用<code>String()</code>函数的结果一样。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">null</span>.<span style="color:#a6e22e">toString</span>())
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Uncaught TypeError: Cannot read properties of null (reading &#39;toString&#39;)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">undefined</span>.<span style="color:#a6e22e">toString</span>())
</span></span><span style="display:flex;"><span><span style="color:#75715e">//Uncaught TypeError: Cannot read properties of undefined (reading &#39;toString&#39;)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(String(<span style="color:#66d9ef">null</span>), String(<span style="color:#66d9ef">undefined</span>)) <span style="color:#75715e">// null undefined
</span></span></span></code></pre></div><p>某些操作符会进行隐式类型转换。如二元操作符<code>+</code>的一个操作数是字符串，则会将另一个操作数转换为字符串。一元操作符会把自己的操作数转换为数值。一元操作符<code>!</code>会先把它的操作数转换为布尔类型，然后再取反。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;&#34;</span> <span style="color:#75715e">// =&gt; String(x)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">+</span><span style="color:#a6e22e">x</span>   <span style="color:#75715e">// =&gt; Number(x)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">x</span><span style="color:#f92672">-</span><span style="color:#ae81ff">0</span>  <span style="color:#75715e">// =&gt; Number(x)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">!!</span><span style="color:#a6e22e">x</span>  <span style="color:#75715e">// =&gt; Boolean(x): Note double !
</span></span></span></code></pre></div><p><code>Number</code>类定义的<code>toString()</code>方法<font color=LightSeaGreen>接受一个可选参数，以指定基数或底数</font>。如果没有特殊指定这个参数，则默认基数是<code>10</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">17</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">binary</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;0b&#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">toString</span>(<span style="color:#ae81ff">2</span>); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">octal</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;0o&#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">toString</span>(<span style="color:#ae81ff">8</span>); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">hex</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;0x&#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">toString</span>(<span style="color:#ae81ff">16</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">binary</span>, <span style="color:#a6e22e">octal</span>, <span style="color:#a6e22e">hex</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 打印结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">17</span> <span style="color:#ae81ff">0b10001</span> <span style="color:#ae81ff">0o21</span> <span style="color:#ae81ff">0x11</span>
</span></span></code></pre></div><p>如果把字符串传给<code>Number()</code>函数，它会尝试把字符串转换为整数或浮点字面量。但是，<font color=LightSeaGreen>这个函数只能处理以10为基数，且末尾不能有无关字符</font>。</p>
<p>但全局的函数<code>parseInt()</code>和<code>parseFloat()</code>更灵活。若整数以<code>0x</code>或<code>0X</code>开头，<code>parseInt()</code>会将其解析为十六进制，并且<code>parseInt()</code>和<code>parseFloat()</code>都会跳过开头的空格，尽量多地解析数字字符，忽略后面的无关字符。如果第一个非空字符不是有效的数值字面量，将会返回<code>NaN</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;3 blind mice&#34;</span>) <span style="color:#75715e">// 3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(parseFloat(<span style="color:#e6db74">&#34; 3.14 meters&#34;</span>)) <span style="color:#75715e">// 3.14
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(parseInt(<span style="color:#e6db74">&#34;-12.34&#34;</span>)) <span style="color:#75715e">// -12
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(parseInt(<span style="color:#e6db74">&#34;0xFF&#34;</span>)) <span style="color:#75715e">// 255
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(parseInt(<span style="color:#e6db74">&#34;0xff&#34;</span>)) <span style="color:#75715e">// 255
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(parseInt(<span style="color:#e6db74">&#34;-0XFF&#34;</span>)) <span style="color:#75715e">//- 255
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(parseFloat(<span style="color:#e6db74">&#34;.1&#34;</span>)) <span style="color:#75715e">// 0.1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(parseInt(<span style="color:#e6db74">&#34;0.1&#34;</span>)) <span style="color:#75715e">// 0.1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(parseInt(<span style="color:#e6db74">&#34;.1&#34;</span>)) <span style="color:#75715e">// NaN
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(parseFloat(<span style="color:#e6db74">&#34;$72.47&#34;</span>)) <span style="color:#75715e">// NaN
</span></span></span></code></pre></div><p><code>parseInt()</code>接收可选的第二个参数，用于指定数值的基数，合法的值是2到36:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(parseInt(<span style="color:#e6db74">&#34;11&#34;</span>, <span style="color:#ae81ff">23</span>)) <span style="color:#75715e">// 24
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(parseInt(<span style="color:#e6db74">&#34;ff&#34;</span>, <span style="color:#ae81ff">16</span>)) <span style="color:#75715e">// 255
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(parseInt(<span style="color:#e6db74">&#34;zz&#34;</span>, <span style="color:#ae81ff">36</span>)) <span style="color:#75715e">// 1295
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(parseInt(<span style="color:#e6db74">&#34;077&#34;</span>, <span style="color:#ae81ff">8</span>)) <span style="color:#75715e">// 63
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(parseInt(<span style="color:#e6db74">&#34;077&#34;</span>, <span style="color:#ae81ff">10</span>)) <span style="color:#75715e">// 77
</span></span></span></code></pre></div><h3 id="object-to-primitive-conversions">Object to Primitive Conversions</h3>
<p>上面已经讲解了从一个基本类型到另一种基本类型的转换，这一部分讲解将对象转换为基本类型的规则。该节冗长而晦涩。</p>
<h2 id="variable-declaration-and-assignment">Variable Declaration and Assignment</h2>
<p>在使用变量和常量之前，都必须先声明它。在ES6之后，使用<code>let</code>和<code>const</code>关键字声明，在ES6之前使用<code>var</code>声明，并且使用<code>var</code>关键字更特殊一些。</p>
<h3 id="declarations-with-let-and-const">Declarations with let and const</h3>
<p>如果使用<code>let</code>声明变量时，未初始化值，则在变量被初始化之前，它的值为<code>undefined</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span>; 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">sum</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 一次定义多个变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">sum</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">message</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">j</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">k</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 初始化时可以使用之前已经声明的变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>, <span style="color:#a6e22e">y</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">x</span>; 
</span></span></code></pre></div><p>要声明常量而非变量时，需要使用<code>const</code>关键词。使用<code>const</code>声明常量时必须同时初始化（这与<code>Swift</code>有显著区别）。常量的值不能被改变，如果尝试重新赋值，则会抛出<code>TypeError</code>。声明常量的一个常见约定是全部字母大写。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">H0</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">74</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">C</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">299792.458</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">AU</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.496</span><span style="color:#a6e22e">E8</span>;
</span></span></code></pre></div><p>在同一个作用域内使用多个<code>let</code>或<code>const</code>声明同一个名字是语法错误。<font color=red>在嵌套作用域内声明同名的变量是合法的</font>，但不推荐这样做。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">x</span> <span style="color:#f92672">===</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">x</span>) <span style="color:#75715e">// 2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">x</span>) <span style="color:#75715e">// 1
</span></span></span></code></pre></div><h3 id="variable-declarations-with-var">Variable Declarations with var</h3>
<p>在ES6之前，声明变量的唯一方式是使用<code>var</code>关键词，并且不允许声明常量。使用<code>var</code>声明变量的语法和使用<code>let</code>关键词一样：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">x</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">data</span> <span style="color:#f92672">=</span> [], <span style="color:#a6e22e">count</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">data</span>.<span style="color:#a6e22e">length</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">count</span>, <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">data</span>[<span style="color:#a6e22e">i</span>])
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>虽然<code>var</code>和<code>let</code>有相同的语法，但它们也有重要的区别：</p>
<ul>
<li>使用<code>var</code>声明的变量<font color=LightSeaGreen>不具有块作用域</font>。这种变量的作用域仅限于包含变量声明的函数体，无论它在函数中嵌套层次有多深。</li>
<li>如果在函数外部使用<code>var</code>声明变量，则会声明一个全局变量。但与<code>let</code>声明的全局变量有一个重要区别，<font color=red><code>var</code>声明的全局变量被实现为全局对象的属性，全局对象可以使用<code>globalThis</code>引用</font>。</li>
<li>使用<code>var</code>多次声明同名变量是合法的。因为<code>var</code>具有函数作用域，而非块作用域，所以经常会出现声明同名变量的情况。</li>
<li>使用<code>var</code>声明变量，<font color=red>该变量会被提升到函数的顶部，但变量的初始化仍然在代码所在位置</font>。</li>
</ul>
<p>在严格模式下，如果试图使用未声明的变量，运行代码时会出现引用错误。然而，在非严格模式，如果为一个未使用<code>let、const</code>或<code>var</code>声明的名称赋值，最终会创建一个新的全局变量。无论引用的代码嵌套在函数和代码块中多深，它都将是一个全局变量，这几乎不是我们想要的，而且容易出错，也是使用严格模式的最佳原因之一。</p>
<h3 id="destructuring-assignment">Destructuring Assignment</h3>
<p>ES6实现了一种复合声明与赋值语法，叫做解构赋值。在解构赋值中，等号右边是一个数组或对象，等号左边以模拟或数组和对象的方式指定一个或多个变量名字。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> [<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>] <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>[<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>] <span style="color:#f92672">=</span> [<span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">y</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]; <span style="color:#75715e">// 同时赋值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>[<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>] <span style="color:#f92672">=</span> [<span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">x</span>]; <span style="color:#75715e">// 交换两个变量的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 打印的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">3</span> <span style="color:#ae81ff">2</span>
</span></span></code></pre></div><p>解构赋值可以让返回数组的函数变得非常便捷：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">toPolar</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> [Math.<span style="color:#a6e22e">sqrt</span>(<span style="color:#a6e22e">x</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">y</span>), Math.<span style="color:#a6e22e">atan2</span>(<span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">x</span>)];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">toCartesian</span>(<span style="color:#a6e22e">r</span>, <span style="color:#a6e22e">theta</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> [<span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span> Math.<span style="color:#a6e22e">cos</span>(<span style="color:#a6e22e">theta</span>), <span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span> Math.<span style="color:#a6e22e">sin</span>(<span style="color:#a6e22e">theta</span>)];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> [<span style="color:#a6e22e">r</span>,<span style="color:#a6e22e">theta</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">toPolar</span>(<span style="color:#ae81ff">1.0</span>, <span style="color:#ae81ff">1.0</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> [<span style="color:#a6e22e">x</span>,<span style="color:#a6e22e">y</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">toCartesian</span>(<span style="color:#a6e22e">r</span>,<span style="color:#a6e22e">theta</span>);
</span></span></code></pre></div><p>在循环中也可以使用解构赋值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">o</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">y</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">2</span>}; <span style="color:#75715e">// The object we&#39;ll loop over
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">name</span>, <span style="color:#a6e22e">value</span>] <span style="color:#66d9ef">of</span> Object.<span style="color:#a6e22e">entries</span>(<span style="color:#a6e22e">o</span>)) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">name</span>, <span style="color:#a6e22e">value</span>); 
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> ([<span style="color:#a6e22e">name</span>, <span style="color:#a6e22e">value</span>] <span style="color:#66d9ef">of</span> Object.<span style="color:#a6e22e">entries</span>(<span style="color:#a6e22e">o</span>)) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">name</span>, <span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>解构赋值时，<font color=LightSeaGreen>等号左边的变量数量不必与等号右边的数组元素个数匹配，左边多余的变量的初始值为<code>undefined</code>，右边多余的值会被忽略</font>。左边变量列表可以包含额外的逗号，用于跳过右侧某些值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> [<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>] <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>[<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>] <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>[, <span style="color:#a6e22e">x</span>, , <span style="color:#a6e22e">y</span>] <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>];
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>) <span style="color:#75715e">// 2 4
</span></span></span></code></pre></div><p>在解构赋值时，如果想把所有未使用或剩余的值收集到一个变量中，可以在左侧最后一个变量名前加上3个点：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> [<span style="color:#a6e22e">x</span>, ...<span style="color:#a6e22e">y</span>] <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>];
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">1</span> [ <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span> ]
</span></span></code></pre></div><p>解构赋值可以用于嵌套数组，此时左边也应该看起来像一个内嵌的数组字面量：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> [<span style="color:#a6e22e">a</span>, [<span style="color:#a6e22e">b</span>, <span style="color:#a6e22e">c</span>]] <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, [<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2.5</span>], <span style="color:#ae81ff">3</span>]; <span style="color:#75715e">// a == 1; b == 2; c == 2.5
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span>, <span style="color:#a6e22e">c</span>) 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">2.5</span>
</span></span></code></pre></div><p>数组解构的一个重要特性是等号右侧并不要求是数组。实际上，解构<font color=red>右侧可以使用任何可迭代对象</font>，任何可以在<code>for/of</code>循环中使用的对象都可被解构：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> [<span style="color:#a6e22e">first</span>, ...<span style="color:#a6e22e">rest</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Hello&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">first</span>, <span style="color:#a6e22e">rest</span>) <span style="color:#75715e">// first == &#34;H&#34;; rest == [&#34;e&#34;,&#34;l&#34;,&#34;l&#34;,&#34;o&#34;]
</span></span></span></code></pre></div><p>解构赋值在右侧是对象值的情况下也可以执行。此时，左侧看起来像是一个对象字面量，即一个包含在花括号内以逗号分隔的变量名列表：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">transparent</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">r</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">0.0</span>, <span style="color:#a6e22e">g</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">0.0</span>, <span style="color:#a6e22e">b</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">0.0</span>, <span style="color:#a6e22e">a</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1.0</span>}; 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> {<span style="color:#a6e22e">r</span>, <span style="color:#a6e22e">g</span>, <span style="color:#a6e22e">b</span>} <span style="color:#f92672">=</span> <span style="color:#a6e22e">transparent</span>; <span style="color:#75715e">// r == 0.0; g == 0.0; b == 0.0
</span></span></span></code></pre></div><p>下面示例展示了把<code>Math</code>对象的全局函数复制给变量，这种方式可以简化代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">// Same as const sin=Math.sin, cos=Math.cos, tan=Math.tan
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> {<span style="color:#a6e22e">sin</span>, <span style="color:#a6e22e">cos</span>, <span style="color:#a6e22e">tan</span>} <span style="color:#f92672">=</span> Math;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">sin</span>(<span style="color:#ae81ff">30</span>), <span style="color:#a6e22e">cos</span>(<span style="color:#ae81ff">30</span>), <span style="color:#a6e22e">tan</span>(<span style="color:#ae81ff">30</span>)) 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// -0.9880316240928618 0.15425144988758405 -6.405331196646276
</span></span></span></code></pre></div><p>需要注意的是，如果等号左侧不是<code>Math</code>对象的属性名，则该变量的值为<code>undefined</code>。在上面解构中，我们选择了和要解构对象的属性一致的变量名，但这不是必须的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">// Same as const cosine = Math.cos, tangent = Math.tan;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> {<span style="color:#a6e22e">cos</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">cosine</span>, <span style="color:#a6e22e">tan</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">tangent</span>} <span style="color:#f92672">=</span> Math;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">cosine</span>(<span style="color:#ae81ff">12</span>)) <span style="color:#75715e">// 0.8438539587324921
</span></span></span></code></pre></div><h1 id="chapter-4">Chapter 4</h1>
<p>表达式是一个可以被求值并产生一个值的短语，嵌入到程序中的常量是最简单的表达式之一，变量名也是一种简单的表达式，它的值为赋给该变量的值相同。</p>
<p>复杂的表达式由简单的表达式组成，例如一个数组访问表达式由一个求值为数组的表达式、一个左方括号，一个求值为整数的表达式和一个右方括号构成。</p>
<h2 id="primary-expressions">Primary Expressions</h2>
<p>最简单的表达式被称为基础表达式，是指那些独立存在，不再包含更简单表达式的表达式。基础表达式<font color=LightSeaGreen>包含常量，字面量，某些关键字和变量引用</font>。</p>
<ul>
<li>
<p>字面量是可以直接嵌入到程序中的常量值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#ae81ff">1.23</span> <span style="color:#75715e">// A number literal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#e6db74">&#34;hello&#34;</span> <span style="color:#75715e">// A string literal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#e6db74">/pattern/</span>  <span style="color:#75715e">// A regular expression literal
</span></span></span></code></pre></div></li>
<li>
<p>保留字也是基础表达式。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">null</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">this</span>
</span></span></code></pre></div></li>
<li>
<p>常量，变量或全局对象属性的引用。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">i</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">sum</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">undefined</span>
</span></span></code></pre></div><p>当程序中出现任何标识符时，都被假设为常量或变量或全局对象的属性，并查询它的值。如果不存在该名字的变量，则会抛出<code>ReferenceError</code>。</p>
</li>
</ul>
<h2 id="object-and-array-initializers">Object and Array Initializers</h2>
<p>对象和数组初始化器也是表达式，值为新创建的对象或数组。这些初始化表达式也被称为对象字面量或数组字面量。与真正的字面量不同，它们不是基础表达式。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span>[] <span style="color:#75715e">// An empty array: no expressions inside brackets means no elements
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>[<span style="color:#ae81ff">1</span><span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span><span style="color:#f92672">+</span><span style="color:#ae81ff">4</span>] <span style="color:#75715e">// A 2-element array. First element is 3, second is 7
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">matrix</span> <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>], [<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">6</span>], [<span style="color:#ae81ff">7</span>,<span style="color:#ae81ff">8</span>,<span style="color:#ae81ff">9</span>]];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">sparseArray</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>,,,,<span style="color:#ae81ff">5</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">2.3</span>, <span style="color:#a6e22e">y</span><span style="color:#f92672">:</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1.2</span> } <span style="color:#75715e">// An object with 2 properties
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">q</span> <span style="color:#f92672">=</span> {}; <span style="color:#75715e">// An empty object with no properties
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">2.3</span>; <span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">y</span> <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1.2</span>; <span style="color:#75715e">// Now q has the same properties as p
</span></span></span></code></pre></div><p>在ES6中，对象字面量有更丰富的语法，可以嵌套。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">rectangle</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">upperLeft</span><span style="color:#f92672">:</span> {<span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">2</span>, <span style="color:#a6e22e">y</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">2</span>},
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">lowerRight</span><span style="color:#f92672">:</span> {<span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">4</span>, <span style="color:#a6e22e">y</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">5</span>}
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h2 id="property-access-expressions">Property Access Expressions</h2>
<p>属性访问表达式求值对象属性或数组的元素，有两种属性访问语法。第一种是使用点操作符，另一种是使用方括号，示例如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">o</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">y</span><span style="color:#f92672">:</span> {<span style="color:#a6e22e">z</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">3</span>}};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> [<span style="color:#a6e22e">o</span>, <span style="color:#ae81ff">4</span>, [<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>]];
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">y</span>.<span style="color:#a6e22e">z</span>, <span style="color:#a6e22e">o</span>[<span style="color:#e6db74">&#34;x&#34;</span>], <span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">1</span>], <span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">2</span>][<span style="color:#e6db74">&#34;1&#34;</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">1</span> <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">4</span> <span style="color:#ae81ff">6</span>
</span></span></code></pre></div><p>无论使用哪种属性访问表达式，位于<code>.</code>或<code>[</code>前的表达式都会被求值，如果求值结果为<code>null</code>或<code>undefined</code>，表达式就会抛出<code>TypeError</code>，因为<code>null</code>或<code>undefined</code>是不能有属性的两个值。</p>
<h2 id="operator-overview">Operator Overview</h2>
<p>多数操作符都是类似<code>+</code>和<code>=</code>这样的标点符号，也有一些<code>delete</code>和<code>instanceof</code>这样的关键字操作符。关键字操作符也是常规操作符，只不过它们的语法没有那么简短而已。</p>
<p>尽管<code>typeof</code>是最高优先级的操作符，但<code>typeof</code>操作符基于属性访问，数组索引以及函数调用，这些操作的优先级全部高于操作符。</p>
<p>操作符<code>+</code>优先字符串拼接，只要操作数是字符串或可以转换为字符串的对象，另一个操作数也会被转换为字符串并执行拼接操作。只有任何操作数都不是字符串或<code>string-like</code>才会执行加法操作。</p>
<p><code>eval()</code>期待一个参数，如果传入的是非字符串参数，它会简单地返回这个值。如果传入字符串，它会尝试把这个字符串当作<code>JavaScript</code>字符串来解析，解析失败会抛出<code>SyntaxError</code>，如果解析成功，它会求值代码<font color=red>并返回该字符串中最后一个表达式或语句的值</font>，如果最后一个表达式或语句没有值则返回<code>undefined</code>。</p>
<p>操作符<code>??</code>求值其先定义的操作数，如果左边的操作数不是<code>null</code>或<code>undefined</code>，就返回该值。否则，它会返回右操作数的值。</p>
<p><code>typeof</code>是一个元操作符，放在自己的操作数前面，这个操作数可以是任意类型。<code>typeof</code>操作符的返回值是一个字符串，表明操作数的类型。</p>
<img src="https://s2.loli.net/2023/11/05/yujMxhp8W96eBKS.png" alt="yujMxhp8W96eBKS" style="zoom:50%;" />
<p>需要注意的是，如果操作数的值是<code>null</code>，<code>typeof</code>返回字符串<code>object</code>。如果想区分<code>null</code>和对象，必须显式测试这个特殊值。</p>
<p><code>delete</code>是一元操作符，它尝试删除其操作数指定的对象属性或数组元素。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">o</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">y</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">2</span>}; <span style="color:#75715e">// Start with an object 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">delete</span> <span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">x</span>; <span style="color:#75715e">// Delete one of its properties 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#e6db74">&#34;x&#34;</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">o</span> <span style="color:#75715e">// =&gt; false: the property does not exist anymore
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>]; <span style="color:#75715e">// Start with an array
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">delete</span> <span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">2</span>]; <span style="color:#75715e">// Delete the last element of the array 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">2</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">a</span> <span style="color:#75715e">// =&gt; false: array element 2 doesn&#39;t exist anymore
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">length</span> <span style="color:#75715e">// =&gt; 3: note that array length doesn&#39;t change, though
</span></span></span></code></pre></div><p>被删除的属性和数组元素会被设置为<code>undefined</code>。尝试读取删除的属性或数组元素时，会返回<code>undefined</code>值，通过<code>in</code>操作符可以测试某个属性是否存在。<font color=red>删除某个数组元素会在数组中留下一个坑，并不会改变数组长度</font>。</p>
<h1 id="chapter-5">Chapter 5</h1>
<p>表达式称为短语，语句就是句子或命令，使用分号结尾。与逗号操作符将多个表达式组合成一个表达式一样，花括号将多个语句组合成一个复合语句。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">PI</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">cx</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">cos</span>(<span style="color:#a6e22e">x</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;cos(π) = &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">cx</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>解释器在执行空语句时什么也不会做。空语句在某些情况会有用，比如创建一个空循环体：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">34</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">89</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">23</span>]
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">item</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">a</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">item</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">length</span>; <span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) ;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">item</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">a</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">item</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在<code>for (let i = 0; i &lt; a.length; a[i++] = 0) ;</code>这个循环中，所有工作都由表达式<code>a[i++] = 0</code>完成，因此不需要循环体。但是，<code>JavaScript</code>语法要求使用语句作为循环体，因此使用了一个空语句，即一个分号。</p>
<p><code>switch</code>语句首先对紧跟其后的表达式求值，然后按照顺序求值<code>case</code>表达式，直到遇到匹配的值。<font color=red>这里的匹配使用<code>===</code>全等操作符</font>，而不是<code>==</code>相等操作符，因此表达式必须在没有类型转换的情况下匹配。</p>
<h2 id="forof">for/of</h2>
<p>对<code>for</code>循环而言，3个表达式中的<font color=LightSeaGreen>任何一个都可以省略，只有两个分号是必需的</font>。ES6定义了一个新循环语句<code>for/of</code>，这种新循环虽然使用了<code>for</code>关键字，但它与常规<code>for</code>是完全不同的两种循环。<code>for/of</code>循环<font color=red>专门用于可迭代对象</font>。数组，字符串，集合和映射都是可迭代对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">data</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span>], <span style="color:#a6e22e">sum</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">element</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">data</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sum</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">element</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">sum</span>)
</span></span></code></pre></div><p>在上面代码中，<code>data</code>数组中的每个元素都会运行一次循环体。在每次执行循环体之前，都会把数组的下一个元素赋值给<code>element</code>变量，并且是按照从头到尾的顺序迭代的。</p>
<p>实际上，<font color=red>对象默认是不可迭代的</font>，运行时尝试对普通对象使用<code>for/of</code>会抛出<code>TypeError</code>。如果想要迭代对象的属性，可以使用<code>for/in</code>循环，或者使用<code>Object.keys()</code>方法和<code>for/of</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">o</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">y</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">2</span>, <span style="color:#a6e22e">z</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">3</span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">keys</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">k</span> <span style="color:#66d9ef">of</span> Object.<span style="color:#a6e22e">keys</span>(<span style="color:#a6e22e">o</span>)) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">keys</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">k</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">keys</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">xyz</span>
</span></span></code></pre></div><p>需要注意的是，对对象<code>key</code>的迭代并不像上述数组示例那样是实时的。在循环体中对对象<code>o</code>所做的更改不会对迭代产生任何影响。如果不关心对象的<code>key</code>，也可以像这样遍历其对应的<code>value</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">sum</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">v</span> <span style="color:#66d9ef">of</span> Object.<span style="color:#a6e22e">values</span>(<span style="color:#a6e22e">o</span>)) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sum</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">v</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">sum</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行的结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">6</span>
</span></span></code></pre></div><p>如果对对象属性的<code>key</code>和<code>value</code>都感兴趣，可以使用<code>for/of</code>和<code>Object.entries()</code>以及解构赋值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">pairs</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> [<span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span>] <span style="color:#66d9ef">of</span> Object.<span style="color:#a6e22e">entries</span>(<span style="color:#a6e22e">o</span>)) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pairs</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">k</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">v</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">pairs</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">x1y2z3</span>
</span></span></code></pre></div><p>字符串是按照<code>Unicode</code>码点，也就是字符，而不是<code>UTF-16</code>字符迭代的。虽然字符串<code>I😀😁</code>的长度为<code>5</code>，但使用<code>for/of</code>只会迭代3次：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">test</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;I😀😁&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">item</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">test</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">item</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 打印结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">I</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">😀</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">😀</span>
</span></span></code></pre></div><p>ES6内置的<code>Set</code>和<code>Map</code>类都是可迭代的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">text</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Na na na na na na na na Batman!&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">wordSet</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Set</span>(<span style="color:#a6e22e">text</span>.<span style="color:#a6e22e">split</span>(<span style="color:#e6db74">&#34; &#34;</span>));
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">unique</span> <span style="color:#f92672">=</span> [];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">word</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">wordSet</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">unique</span>.<span style="color:#a6e22e">push</span>(<span style="color:#a6e22e">word</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">unique</span>) <span style="color:#75715e">// [&#34;Na&#34;, &#34;na&#34;, &#34;Batman!&#34;]
</span></span></span></code></pre></div><p><code>Map</code>对象的迭代器<font color=red>并不迭代<code>key</code>或<code>value</code>，而是迭代键值对</font>。每次迭代，迭代器都会返回一个数组，第一个元素是<code>key</code>，第二个元素是<code>value</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">m</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Map</span>([[<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;one&#34;</span>]]);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> [<span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">value</span>] <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">m</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">value</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 1 one
</span></span></span></code></pre></div><p>在ES2018引入了一种新的迭代器，被称为异步迭代器，以及一种<code>for/of</code>循环的变体（称为<code>for/await</code>循环），可与异步迭代器一起工作。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">printStream</span>(<span style="color:#a6e22e">stream</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">await</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">chunk</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">stream</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">chunk</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="forin">for/in</h2>
<p>一个<code>for/in</code>循环看起来非常像<code>for/of</code>循环，只是将关键字<code>of</code>改成了<code>in</code>。<code>for/of</code>循环要求在<code>of</code>后面有一个可迭代对象，而<code>for/in</code>循环则可以在<code>in</code>后面使用任何对象。<code>for/of</code>循环是ES6的新特性，但<code>for/in</code>从一开始就是 JavaScript的一部分。for/in循环使用指定对象的属性名：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">// Assign property names of o to variable p 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">p</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">o</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Print the value of each property
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">o</span>[<span style="color:#a6e22e">p</span>]);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>要执行for/in语句，解释器首先会求值对象表达式，如果结果为null或undefined，解释器会跳过循环，继续执行下一条语句。否则，解释器会对对象的每个可枚举属性执行一次循环体。不过，在每次迭代之前，解释器都会对variable表达式进行求值，并将属性名称（字符串值）赋值给variable表达式。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#a6e22e">variable</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">object</span>) 
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">statement</span>
</span></span></code></pre></div><p>需要注意的是，for/in循环中的variable可以是任意表达式，只要它求值后适合做赋值操作符的左值。每次循环都会对该表达式求值，这意味着每次评估的结果都可能不同。例如，可以使用以下代码将所有对象属性的名称复制到数组中：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">o</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">y</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">2</span>, <span style="color:#a6e22e">z</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">3</span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> [], <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>] <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">o</span>) <span style="color:#75715e">/* empty */</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">item</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">a</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">item</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>数组只是一个特殊的对象，数组索引就是对象的属性，可以使用for/in循环枚举的。下面使用for/in遍历的是数组的索引，如果想要遍历数组元素，可以使用for/of。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">a</span>) <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">i</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">0</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#ae81ff">1</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#ae81ff">2</span>
</span></span></code></pre></div><p><code>for/in</code>循环实际上并不枚举对象的所有属性，不会枚举<code>Symbol</code>属性。在字符串属性中，<code>for/in</code>只会循环遍历可枚举的属性。<code>JavaScript</code>核心定义的各种内置方法都是不可枚举的。例如，所有对象都有一个<code>toString()</code>方法，但<code>for/in</code>循环不会枚举这个<code>toString</code>属性。除了内置方法外，内置对象的许多其它属性也是不可枚举的。默认情况下，我们用代码定义的所有属性和方法都是可枚举的。</p>
<p>可枚举的继承属性也会被<code>for/in</code>循环枚举。这意味着，如果在使用for/in循环时，还会遍历继承的属性，那么循环可能不会按照我们期望的方式运行。因此，许多程序员喜欢使用带有<code>Object.keys()</code>的<code>for/of</code>循环，而不是<code>for/in</code>循环。</p>
<p>如果在<code>for/in</code>循环体中删除了一个尚未枚举的属性，该属性将不会再被枚举。如果循环体定义了对象的新属性，这些属性可能被枚举，也可能不被枚举。</p>
<p>需要注意的是，<code>for/in</code>循环的<code>in</code>后面可以是任意对象，<code>for/of</code>循环是<code>ES6</code>新增的，而<code>for/in</code>是一开始就有的。</p>
<h1 id="chapter-6">Chapter 6</h1>
<p>对象是属性的无序集合，每个属性都有名字和值。属性名通常是字符串（也可以是<code>Symbol</code>）。因此，可以说对象是把字符串映射为值。这种把字符串映射为值有很多种叫法，如散列，字典或关联数组。但是，对象不仅仅是简单的字符串到值的映射。</p>
<p>除了维护自定义属性，对象也可以从其它对象继承属性，<font color=LightSeaGreen>这个其它对象称为其原型</font>。对象的方法通常继承自属性，这种原型继承是<code>JavaScript</code>的关键特性。</p>
<p>对象是动态的，属性通常可以添加或删除。属性有一个名字和值，属性名可以是任意字符串，包括空字符串或任意符号<code>Symbol</code>，但<font color=LightSeaGreen>对象不能包含两个同名的属性</font>。</p>
<p>不是字符串、数字、符号、布尔值或<code>null</code>或<code>undefined</code>以及<code>Symbol</code>的任何值都是对象。尽管字符串、数字和布尔值不是对象，但它们的行为却与不可变对象类似。</p>
<h2 id="creating-objects">Creating Objects</h2>
<p>可以通过对象字面量，<code>new</code>关键字和<code>Object.create()</code>函数创建对象。创建一个对象最简单的方式是在代码中直接使用对象字面量。</p>
<p>对象字面量是一个以逗号分隔的列表，其中包含以冒号分隔的<code>name:value</code>对，并用花括号括起来。<font color=red>属性名可以是标识符或字符串字面量（允许空字符串）</font>，属性值可以是任何表达式，表达式的值可能是基础值或对象值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">empty</span> <span style="color:#f92672">=</span> {};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">point</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">y</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">p2</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">point</span>.<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">point</span>.<span style="color:#a6e22e">y</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">book</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;main title&#34;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;JavaScript&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;sub-title&#34;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;The Definitive Guide&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;all audiences&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">firstname</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;David&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">surname</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Flanagan&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>对象字面量<font color=LightSeaGreen>最后一个属性后面添加逗号是合法的</font>，有些编程风格指南鼓励添加这些逗号，方便以后在对象字面量的末尾添加新属性时，不容易出现语法错误。</p>
<p>对象字面量是一个表达式，<font color=red>每次求值时会创建和初始化一个不同的对象</font>。这意味着，同一个对象字面量如果出现在循环或出现在被重复调用的函数中时，可以创建很多新对象。</p>
<h3 id="creating-objects-with-new">Creating Objects with new</h3>
<p>操作符<code>new</code>可以创建和初始化一个新对象。<code>new</code>关键字必须紧跟一个函数调用，这个跟在<code>new</code>后面的函数被称为构造器。下面是一些内建类型的构造器：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">o</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Object();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Array();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">d</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Date();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">r</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Map</span>();
</span></span></code></pre></div><h3 id="prototypes">Prototypes</h3>
<p>几乎每个对象都有一个与之关联的第二个对象，这个关联的对象被称为原型。第一个对象继承原型的属性，通过<font color=LightSeaGreen>字面量创建的对象都有同一个原型对象，可以使用<code>Object.prototype</code>引用</font>这个原型对象。</p>
<p>使用<code>new</code>关键字和构造函数创建的对象，使用构造函数的<code>prototype</code>属性值作为它们的原型。也就是说，使用<code>new Object()</code>创建的对象继承自<code>Object.prototype</code>，与通过<code>{}</code>创建的对象一样。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(Object.<span style="color:#a6e22e">prototype</span>)
</span></span></code></pre></div><p>类似地，通过<code>new Array()</code>创建的对象以<code>Array.prototype</code>为原型，通过<code>new Date()</code>创建的对象以<code>Date.prototype</code>为原型。</p>
<p>几乎所有对象都有原型，但只有少数对象有<code>prototype</code>属性，正是这些有<code>prototype</code>属性的对象为所有其它对象定义了原型。</p>
<p>需要注意的是，<code>Object.prototype</code>是少有的没有原型的对象，<font color=red>它不继承任何属性</font>。其他的原型对象都是普通的有原型的对象。多数内置构造器都有一个原型，这个原型继承自<code>Object.prototype</code>。</p>
<p>例如，<code>Date.prototype</code>继承了 <code>Object.prototype</code>的属性，因此通过<code>new Date()</code>创建的<code>Date</code>对象同时继承了<code>Date.prototype</code>和<code>Object.prototype</code>的属性。这种关联的一系列原型对象被称为原型链。</p>
<h3 id="objectcreate">Object.create()</h3>
<p>函数<code>Object.create()</code>用于创建一个新对象，使用第一个参数作为新对象的原型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">o1</span> <span style="color:#f92672">=</span> Object.<span style="color:#a6e22e">create</span>({<span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">y</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">2</span>});
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">o1</span>.<span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">o1</span>.<span style="color:#a6e22e">y</span>)
</span></span></code></pre></div><p>传入<code>null</code>可以创建一个没有原型的对象，但这样创建的新对象不会继承任何东西，连<code>toString()</code>这样的基本方法都没有。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">o2</span> <span style="color:#f92672">=</span> Object.<span style="color:#a6e22e">create</span>(<span style="color:#66d9ef">null</span>); <span style="color:#75715e">// o2 inherits no props or methods.
</span></span></span></code></pre></div><p>如果想创建一个普通的空对象(类似于<code>{}</code>或<code>new Object()</code>创建的对象)，传入<code>Object.prototype</code>即可:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">o3</span> <span style="color:#f92672">=</span> Object.<span style="color:#a6e22e">create</span>(Object.<span style="color:#a6e22e">prototype</span>); <span style="color:#75715e">// o3 is like {} or new Object().
</span></span></span></code></pre></div><p>创建具有任意原型的新对象的功能非常强大。<code>Object.create()</code>还包含一个可选的第二个参数，用于描述新对象的属性。</p>
<p>方法<code>Object.create()</code>的一种用途是防止一个无法控制的库函数对对象进行意外（但非恶意）修改。与其将对象直接传递给这个库函数，不如传递一个继承自该对象的新对象。如果函数读取该对象的属性，就会看到继承的值。但是，如果函数设置属性，这些写入将不会影响原始的对象。</p>
<h2 id="querying-and-setting-properties">Querying and Setting Properties</h2>
<p>如果要获取属性值，可以使用<code>.</code>或<code>[]</code>操作符。两个操作符左边都必须是一个值为对象的表达式，如果使用点操作符，右操作数必须是对象的属性名，而如果使用<code>[]</code>操作符，在方括号里的值必须是表达式，<font color=red>该表达式的值必须是字符串或能够转换为字符串或<code>Symbol</code></font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">author</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">book</span>.<span style="color:#a6e22e">author</span>; <span style="color:#75715e">// Get the &#34;author&#34; property of the book.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">author</span>.<span style="color:#a6e22e">surname</span>; <span style="color:#75715e">// Get the &#34;surname&#34; property of the author.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">title</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">book</span>[<span style="color:#e6db74">&#34;main title&#34;</span>]; <span style="color:#75715e">// Get the &#34;main title&#34; property of the book.
</span></span></span></code></pre></div><p>如果要创建或设置一个属性，同样可以使用点或方括号操作符，只需要把它们放到赋值表达式<code>=</code>的左边：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">book</span>.<span style="color:#a6e22e">edition</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">7</span>; <span style="color:#75715e">// Create an &#34;edition&#34; property of book.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">book</span>[<span style="color:#e6db74">&#34;main title&#34;</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;ECMAScript&#34;</span>; <span style="color:#75715e">// Change the &#34;main title&#34; property.
</span></span></span></code></pre></div><h3 id="objects-as-associative-arrays">Objects As Associative Arrays</h3>
<p>访问对象的属性，下面两个表达式返回同一个值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">object</span>.<span style="color:#a6e22e">property</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">object</span>[<span style="color:#e6db74">&#34;property&#34;</span>]
</span></span></code></pre></div><p>第二种方式使用方括号和字符串，看起来像是访问数组，只不过是以字符串而不是数值作为索引。这种数组被称为关联数组（或散列，映射、字典），对象就是关联数组。</p>
<p>在<code>C++、Java</code>以及其它类似强类型的语言中，对象只有固定数量的属性，属性名必须预先定义好。因为<code>JavaScript</code>是一种松散类型语言，可以<font color=LightSeaGreen>为任何对象创建任意数量的属性</font>。</p>
<p>使用方括号访问对象属性，属性名一般是通过字符串来表示的。因为字符串是是一种数据类型，所以可以在程序运行时创建和修改。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">customer</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">address0</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">10</span>, <span style="color:#a6e22e">address1</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">11</span>, <span style="color:#a6e22e">address2</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">333</span>, <span style="color:#a6e22e">address3</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">999</span>}  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">addr</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>;  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>) {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">addr</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">customer</span>[<span style="color:#e6db74">`address</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">i</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>] <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;\n&#34;</span>;  
</span></span><span style="display:flex;"><span>}  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">addr</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">11</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">333</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">999</span>
</span></span></code></pre></div><h3 id="inheritance">Inheritance</h3>
<p>假设从对象<code>o</code>中查询属性<code>x</code>，如果<code>o</code>没有这个名字的自有属性，则会从<code>o</code>的原型对象查询属性<code>x</code>。如果原型对象也没有这个叫<code>x</code>的自有属性，但它又有自己的原型，则会继续查询这个原型的原型。这个过程会一直持续，直到找到属性<code>x</code>，或者查到一个对象的原型为<code>null</code>为止。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">o</span> <span style="color:#f92672">=</span> {};
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">=</span> Object.<span style="color:#a6e22e">create</span>(<span style="color:#a6e22e">o</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">y</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">q</span> <span style="color:#f92672">=</span> Object.<span style="color:#a6e22e">create</span>(<span style="color:#a6e22e">p</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">z</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">f</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">toString</span>();
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">f</span>) <span style="color:#75715e">// [object Object]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">y</span>) <span style="color:#75715e">// 3
</span></span></span></code></pre></div><p>假设为对象<code>o</code>的属性<code>x</code>赋值，如果对象<code>o</code>已经有了<code>x</code>这个自有属性，那么赋值就是简单修改这个已存在的属性值。否则，赋值语句会创建一个名为<code>x</code>的属性，如果<code>o</code>已经继承了属性<code>x</code>，那么这个新创建的属性<code>x</code>就会隐藏继承的同名属性<code>x</code>。</p>
<p>属性赋值时检查原型链，只是确定赋值是否合法，如果<code>o</code>继承了一个只读属性<code>x</code>，那么赋值就是不允许的。<font color=red>如果赋值是允许的，则会新建属性或修改已存在的自有属性的值，不会修改原型链中的对象</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">unitcircle</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">r</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>};  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">c</span> <span style="color:#f92672">=</span> Object.<span style="color:#a6e22e">create</span>(<span style="color:#a6e22e">unitcircle</span>);  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">y</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">r</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">unitcircle</span>.<span style="color:#a6e22e">r</span>) <span style="color:#75715e">// 1
</span></span></span></code></pre></div><h3 id="property-access-errors">Property Access Errors</h3>
<p>查询对象不存在的属性不会报错，如果在对象的自有属性或继承属性都没找到属性<code>x</code>，则属性表达式访问<code>o.x</code>的值为<code>undefined</code>。但是，查询不存在对象的属性是会报错的，因为<code>null</code>和<code>undefined</code>的值没有属性，查询这两个值的属性是错误的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">len</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">book</span>.<span style="color:#a6e22e">subtitle</span>.<span style="color:#a6e22e">length</span>; <span style="color:#75715e">// Uncaught TypeError: Cannot read properties of undefined (reading &#39;length&#39;)
</span></span></span></code></pre></div><p>ES2020通过<code>?.</code>支持条件式属性访问，用它可以把前面的赋值表达式改成如下形式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">surname</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">book</span><span style="color:#f92672">?</span>.<span style="color:#a6e22e">author</span><span style="color:#f92672">?</span>.<span style="color:#a6e22e">surname</span>;
</span></span></code></pre></div><p>尝试在<code>null</code>或<code>undefined</code>上设置属性也会导致<code>TypeError</code>。尝试在对象<code>o</code>上设置属性<code>p</code>在以下情况下会失败：</p>
<ul>
<li>对象<code>o</code>有一个只读自有属性<code>p</code>，不可能设置只读属性。</li>
<li>对象<code>o</code>有一个只读继承属性<code>p</code>，不可能用同名自有属性隐藏该只读属性。</li>
<li>对象<code>o</code>没有自有属性<code>p</code>，<code>o</code>没有继承通过设置方法定义的属性<code>p</code>，但<code>o</code>的<code>extensible</code>特性是<code>fasle</code>。这是因为<code>p</code>在<code>o</code>上不存在，如果没有要调用的设置方法，那么<code>p</code>必须要添加到<code>o</code>上。但因为<code>o</code>不可扩展，则不能在它上面定义新属性。</li>
</ul>
<h2 id="deleting-properties">Deleting Properties</h2>
<p>操作符<code>delete</code>用于从对象中移除属性。它唯一的操作数应该是一个属性访问表达式。需要注意的是，<code>delete</code>并不操作属性的值，而是操作属性本身。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">delete</span> <span style="color:#a6e22e">book</span>.<span style="color:#a6e22e">author</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">delete</span> <span style="color:#a6e22e">book</span>[<span style="color:#e6db74">&#34;main title&#34;</span>];
</span></span></code></pre></div><p>操作符<code>delete</code><font color=red>只删除自有属性，不删除继承属性</font>。如果要删除继承来的属性，必须从定义属性的原型对象上删除，这样做会影响继承该原型的所有对象。</p>
<p>如果<code>delete</code>操作成功或操作没有影响（如删除不存在的属性），则<code>delete</code>表达式求值为<code>true</code>。对<font color=red>非属性表达式使用<code>delete</code>，同样也会求值为<code>true</code></font>。</p>
<p>操作符<code>delete</code>不会删除<code>configurable</code>为<code>false</code>的属性。与使用变量或函数声明的全局对象一样是不可配置的，内置对象的某些属性是不可<code>configurable</code>的。</p>
<p>在严格模式下，尝试删除不可配置的属性会导致<code>TypeError</code>。在非严格模式下，尝试删除不可配置的属性，直接返回<code>false</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">// In strict mode, all these deletions throw TypeError instead of returning false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">delete</span> Object.<span style="color:#a6e22e">prototype</span> <span style="color:#75715e">// =&gt; false: property is non-configurable
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">delete</span> <span style="color:#a6e22e">globalThis</span>.<span style="color:#a6e22e">x</span> <span style="color:#75715e">// =&gt; false: can&#39;t delete this property
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">f</span>() {} <span style="color:#75715e">// Declare a global function
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">delete</span> <span style="color:#a6e22e">globalThis</span>.<span style="color:#a6e22e">f</span> <span style="color:#75715e">// =&gt; false: can&#39;t delete this property either
</span></span></span></code></pre></div><p>在非严格模式下，删除全局对象<code>configurable</code>为<code>true</code>的属性时，可以省略对全局对象的引用，只在<code>delete</code>操作符后面加上属性名：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">globalThis</span>.<span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// Create a configurable global property (no let or var)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">delete</span> <span style="color:#a6e22e">x</span> <span style="color:#75715e">// =&gt; true: this property can be deleted
</span></span></span></code></pre></div><p>在严格模式下，如果<code>delete</code>的操作数是类似<code>x</code>这样的非限定标识符，就会引发语法错误，必须写出完整的属性访问表达式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">globalThis</span>.<span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// Create a configurable global property (no let or var)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">delete</span> <span style="color:#a6e22e">x</span> <span style="color:#75715e">// SyntaxError in strict mode
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">delete</span> <span style="color:#a6e22e">globalThis</span>.<span style="color:#a6e22e">x</span>;
</span></span></code></pre></div><h2 id="testing-properties">Testing Properties</h2>
<p>检查对象是否有一个给定属性的名字，可以使用<code>in</code>操作符，或<code>hasOwnProperty()</code>或<code>propertyIsEnumerable()</code>方法。操作符<code>in</code>要求左边是一个属性名字符串，右边是一个对象。<font color=LightSeaGreen>如果对象有包含相应名字的自有属性或继承属性</font>，都返回<code>true</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">o</span> <span style="color:#f92672">=</span> {};
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">=</span> Object.<span style="color:#a6e22e">create</span>(<span style="color:#a6e22e">o</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">y</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">q</span> <span style="color:#f92672">=</span> Object.<span style="color:#a6e22e">create</span>(<span style="color:#a6e22e">p</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">z</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">f</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">toString</span>();
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">y</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">x</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">o</span>) <span style="color:#75715e">// false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;x&#34;</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">o</span>, <span style="color:#e6db74">&#34;toString&#34;</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">o</span>)  <span style="color:#75715e">// true true
</span></span></span></code></pre></div><p>而<code>hasOwnProperty()</code>方法用于测试对象是否某个自有属性，如果是继承属性，则返回<code>false</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">o</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span> };
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">hasOwnProperty</span>(<span style="color:#e6db74">&#34;x&#34;</span>) <span style="color:#75715e">// =&gt; true: o has an own property x
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">hasOwnProperty</span>(<span style="color:#e6db74">&#34;y&#34;</span>) <span style="color:#75715e">// =&gt; false: o doesn&#39;t have a property y
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">hasOwnProperty</span>(<span style="color:#e6db74">&#34;toString&#34;</span>) <span style="color:#75715e">// =&gt; false: toString is an inherited property
</span></span></span></code></pre></div><p>而<code>propertyIsEnumerable()</code>方法重新定义了<code>hasOwnProperty()</code>测试。只有当指定的属性是自有属性且其<code>enumerable</code>特性为<code>true</code>时，才返回<code>true</code>。某些内置属性是不可枚举的，<font color=red>使用常规的代码创建的属性都是可枚举的</font>，除非使用相关技术将它们限制为不可枚举的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">o</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>};
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">hasOwnProperty</span>(<span style="color:#e6db74">&#34;x&#34;</span>) <span style="color:#75715e">// =&gt; true: o has an own enumerable property x
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">propertyIsEnumerable</span>(<span style="color:#e6db74">&#34;toString&#34;</span>) <span style="color:#75715e">// =&gt; false: not an own property
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Object.<span style="color:#a6e22e">prototype</span>.<span style="color:#a6e22e">propertyIsEnumerable</span>(<span style="color:#e6db74">&#34;toString&#34;</span>) <span style="color:#75715e">// =&gt; false: not enumerable
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">false</span>
</span></span></code></pre></div><p>一般情况，只需查询属性并使用<code>!==</code>来确保它不是<code>underfined</code>的，而无需使用<code>in</code>操作符：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">o</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>};
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">x</span> <span style="color:#f92672">!==</span> <span style="color:#66d9ef">undefined</span>, <span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">y</span> <span style="color:#f92672">!==</span> <span style="color:#66d9ef">undefined</span>, <span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">toString</span> <span style="color:#f92672">!==</span> <span style="color:#66d9ef">undefined</span>)
</span></span></code></pre></div><p>但有一件事<code>in</code>操作符可以做，而简单的属性访问判断做不到。操作符<code>in</code>可以区分不存在的属性和存在但设置为<code>undefind</code>的属性：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">o</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">undefined</span>}; <span style="color:#75715e">// Property is explicitly set to undefined
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">x</span> <span style="color:#f92672">!==</span> <span style="color:#66d9ef">undefined</span> <span style="color:#75715e">// =&gt; false: property exists but is undefined
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">y</span> <span style="color:#f92672">!==</span> <span style="color:#66d9ef">undefined</span> <span style="color:#75715e">// =&gt; false: property doesn&#39;t even exist
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#e6db74">&#34;x&#34;</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">o</span>  <span style="color:#75715e">// =&gt; true: the property exists
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#e6db74">&#34;y&#34;</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">o</span>  <span style="color:#75715e">// =&gt; false: the property doesn&#39;t exist
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">delete</span> <span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">x</span>; <span style="color:#75715e">// Delete the property x
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#e6db74">&#34;x&#34;</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">o</span> <span style="color:#75715e">// =&gt; false: it doesn&#39;t exist anymore
</span></span></span></code></pre></div><h2 id="enumerating-properties">Enumerating Properties</h2>
<p>有时，并不想测试单个属性是否存在，而是想遍历或获取对象所有属性列表。有几种不同的方法可以做到这一点。前面介绍的<code>for/in</code>循环可以遍历特定对象的每个可枚举（自有或继承）属性。<font color=red>对象继承的内置方法是不可枚举的，自己代码添加的属性默认是可枚举的</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">o</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">y</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">2</span>, <span style="color:#a6e22e">z</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">3</span>};  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">propertyIsEnumerable</span>(<span style="color:#e6db74">&#34;toString&#34;</span>))  <span style="color:#75715e">// false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">p</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">o</span>) {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">p</span>);  
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行的结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">x</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">y</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">z</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span>
</span></span></code></pre></div><p>为了防止通过<code>for/in</code>枚举继承的属性，可以通过在循环体内添加<code>hasOwnProperty</code>来过滤：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">o</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">y</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">2</span>, <span style="color:#a6e22e">z</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">3</span>};  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">propertyIsEnumerable</span>(<span style="color:#e6db74">&#34;toString&#34;</span>))  <span style="color:#75715e">// false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">p</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">o</span>) {  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">hasOwnProperty</span>(<span style="color:#a6e22e">p</span>)) {  
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">p</span>);  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>有4个函数可以用来获取属性名数组：</p>
<ul>
<li><code>Object.keys()</code>返回对象可枚举自有属性名的数组。它不包含不可枚举属性、继承属性或符号属性。</li>
<li><code>Object.getOwnPropertyNames()</code>返回自有属性名，包括不可枚举自有属性，只要属性名是字符串即可。</li>
<li><code>Object.getOwnPropertySymbols()</code>返回所有自有<code>Symbol</code>属性，不管是否可枚举的。</li>
<li><code>Reflect.ownKeys()</code>返回所有自有属性名，包括枚举和不可枚举，字符串或符号属性。</li>
</ul>
<h3 id="property-enumeration-order">Property Enumeration Order</h3>
<p>ES6正式定义了枚举对象的自有属性顺序。<code>Object.keys(), Object.getOwnPropertyNames(), Object.getOwnPropertySymbols(), Reflect.ownKeys(),JSON.stringify()</code>等相关方法都按照下面顺序列出属性：</p>
<ul>
<li>首先列出名字为非负整数字符串的属性，按照数值顺序从小到大。这条规则意味着数组和类数组对象的属性会按照顺序被枚举。</li>
<li>在列出类数组索引的所有属性后，再列出剩余属性名为字符串的属性。这些属性按照他们被添加到对象的先后顺序列出。对于在对象字面量中定义的属性，按照它们在字面量中出现的顺序列出。</li>
<li>最后，符号属性将按其被添加到对象中的顺序列出来。</li>
</ul>
<h2 id="extending-objects">Extending Objects</h2>
<p>在程序中，把一个对象的属性复制到另一个对象是很常见的，使用下面代码很容易做到：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">target</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>}, <span style="color:#a6e22e">source</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">y</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">2</span>, <span style="color:#a6e22e">z</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">3</span>};  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">key</span> <span style="color:#66d9ef">of</span> Object.<span style="color:#a6e22e">keys</span>(<span style="color:#a6e22e">source</span>)) {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">target</span>[<span style="color:#a6e22e">key</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">source</span>[<span style="color:#a6e22e">key</span>];  
</span></span><span style="display:flex;"><span>}  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">target</span>)
</span></span></code></pre></div><p>因为这是一种常见操作，因此不同的框架定义了不同的工具方法来执行这种操作，在ES6中，这种能力以<code>Object.assign()</code>的形式出现在了<code>JavaScript</code>核心。</p>
<p>这个函数期望两个以上的参数，它修改并返回第一个参数（目标对象），不会修改第二个以及后续的参数（源目标）。对于每个源目标，会复制可枚举的自有属性（包括符号属性）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span>Object.<span style="color:#a6e22e">assign</span>(<span style="color:#a6e22e">o</span>, <span style="color:#a6e22e">defaults</span>); <span style="color:#75715e">// overwrites everything in o with defaults
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">o</span> <span style="color:#f92672">=</span> Object.<span style="color:#a6e22e">assign</span>({}, <span style="color:#a6e22e">defaults</span>, <span style="color:#a6e22e">o</span>);
</span></span></code></pre></div><p>使用扩展操作符<code>...</code>也可以表达这种对象复制和覆盖操作：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">o</span> <span style="color:#f92672">=</span> {...<span style="color:#a6e22e">defaults</span>, ...<span style="color:#a6e22e">o</span>};
</span></span></code></pre></div><p>为了避免复制额外的创建和复制操作，可以重写一版<code>Object.assign()</code>，只复制那些不存在的属性：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">merge</span>(<span style="color:#a6e22e">target</span>, ...<span style="color:#a6e22e">sources</span>) {  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">source</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">sources</span>) {  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">key</span> <span style="color:#66d9ef">of</span> Object.<span style="color:#a6e22e">keys</span>(<span style="color:#a6e22e">source</span>)) {  
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(<span style="color:#a6e22e">key</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">target</span>)) { <span style="color:#75715e">// This is different than Object.assign()  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#a6e22e">target</span>[<span style="color:#a6e22e">key</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">source</span>[<span style="color:#a6e22e">key</span>];  
</span></span><span style="display:flex;"><span>            }  
</span></span><span style="display:flex;"><span>        }  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">target</span>;  
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Object.<span style="color:#a6e22e">assign</span>({<span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>}, {<span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">2</span>, <span style="color:#a6e22e">y</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">2</span>}, {<span style="color:#a6e22e">y</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">3</span>, <span style="color:#a6e22e">z</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">4</span>}) <span style="color:#75715e">// =&gt; {x: 2, y: 3, z: 4}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">merge</span>({<span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>}, {<span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">2</span>, <span style="color:#a6e22e">y</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">2</span>}, {<span style="color:#a6e22e">y</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">3</span>, <span style="color:#a6e22e">z</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">4</span>}) <span style="color:#75715e">// =&gt; {x: 1, y: 2, z: 4}
</span></span></span></code></pre></div><h2 id="serializing-objects">Serializing Objects</h2>
<p>对象序列化是把对象转换为字符串的过程，之后可以从字符串中恢复为对象。函数<code>JSON.stringify()</code>用于序列化对象，<code>JSON.parse()</code>用户恢复对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">o</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">y</span><span style="color:#f92672">:</span> {<span style="color:#a6e22e">z</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">false</span>, <span style="color:#66d9ef">null</span>, <span style="color:#e6db74">&#34;&#34;</span>]}}; <span style="color:#75715e">// Define a test object  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">JSON</span>.<span style="color:#a6e22e">stringify</span>(<span style="color:#a6e22e">o</span>); <span style="color:#75715e">// s == &#39;{&#34;x&#34;:1,&#34;y&#34;:{&#34;z&#34;:[false,null,&#34;&#34;]}}&#39;  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">JSON</span>.<span style="color:#a6e22e">parse</span>(<span style="color:#a6e22e">s</span>);  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">p</span>)
</span></span></code></pre></div><p>函数<code>JSON.stringify()</code>只序列化对象<font color=red>可枚举的自由属性，如果属性值无法序列化，则该属性会从输出的字符串中删除</font>。</p>
<h2 id="object-methods">Object Methods</h2>
<p>所有对象（除了那些显式创建的没有原型的）都从<code>Object.prototype</code>继承属性，这些继承属性主要是方法。因为这些方法普遍可用的，所以程序员对它们很感兴趣。例如，前面已经看到过的<code>hasOwnProperty()</code>和<code>propertyIsEnumerable()</code>方法，以及定义在<code>Object</code>构造函数上的静态方法，例如<code>Object.create()</code>和<code>Object.keys()</code>。</p>
<h3 id="the-tostring-method">The toString() Method</h3>
<p>方法<code>toString()</code>不接受参数，它返回一个字符串，以某种方式表示调用该方法的对象的值。只要在需要将对象转换为字符串的地方，就会调用对象的这个方法。例如，当使用<code>+</code>运算符将字符串与对象连接起来时，或者当将对象传递给一个需要字符串的方法时。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">y</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>}.<span style="color:#a6e22e">toString</span>(); <span style="color:#75715e">// s == &#34;[object Object]&#34;  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">s</span>)
</span></span></code></pre></div><p>由于这个默认的方法不会显示太有用的信息，很多类都会重新定义自己的<code>toString()</code>方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">point</span> <span style="color:#f92672">=</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">y</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">2</span>, <span style="color:#a6e22e">toString</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">function</span> () {  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">`(</span><span style="color:#e6db74">${</span><span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">x</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, </span><span style="color:#e6db74">${</span><span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">y</span><span style="color:#e6db74">}</span><span style="color:#e6db74">)`</span>;  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>};  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(String(<span style="color:#a6e22e">point</span>)) <span style="color:#75715e">// =&gt; &#34;(1, 2)&#34;: toString() is used for string conversions
</span></span></span></code></pre></div><h3 id="the-valueof-method">The valueOf() Method</h3>
<p>方法<code>valueOf()</code>和<code>toString()</code>类似，它是在一个对象需要转换为除了字符串的其它基础对象时调用。如果在需要基础类型的地方传入了一个对象，则<code>valueOf()</code>会自动调用。</p>
<p>默认的<code>valueOf()</code>方法没有做什么，因此一些内置的类定义了自己的<code>valueOf()</code>方法。<code>Date</code>类的<code>valueOf()</code>方法将日期转换为数字，因此可以使用<code>&lt;</code>和<code>&gt;</code>进行比较。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">point</span> <span style="color:#f92672">=</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">3</span>, <span style="color:#a6e22e">y</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">4</span>, <span style="color:#a6e22e">valueOf</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">function</span> () {  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Math.<span style="color:#a6e22e">hypot</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">x</span>, <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">y</span>);  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>};  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(Number(<span style="color:#a6e22e">point</span>))
</span></span></code></pre></div><h3 id="the-tojson-method">The toJSON() Method</h3>
<p>实际上<code>Object.prototype</code>并没有定义<code>toJSON()</code>方法，但方法<code>JSON.stringify()</code>会从要序列化的对象寻找<code>toJSON()</code>方法，如果要序列化的方法有这个<code>toJSON()</code>方法，就会调用它。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">point</span> <span style="color:#f92672">=</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">y</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">2</span>, <span style="color:#a6e22e">toString</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">function</span> () {  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">`(</span><span style="color:#e6db74">${</span><span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">x</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, </span><span style="color:#e6db74">${</span><span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">y</span><span style="color:#e6db74">}</span><span style="color:#e6db74">)`</span>;  
</span></span><span style="display:flex;"><span>    }, <span style="color:#a6e22e">toJSON</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">function</span> () {  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">toString</span>();  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>};  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">JSON</span>.<span style="color:#a6e22e">stringify</span>([<span style="color:#a6e22e">point</span>])) <span style="color:#75715e">// =&gt; &#39;[&#34;(1, 2)&#34;]&#39;
</span></span></span></code></pre></div><h2 id="extended-object-literal-syntax">Extended Object Literal Syntax</h2>
<p>最近的几个<code>JavaScript</code>版本扩展了字面量语法。假设变量<code>x</code>和<code>y</code>中保存着值，而想创建一个具有属性<code>x</code>和属性<code>y</code>，并且值也是x和y。如果使用基本的对象字面量语法，需要把每个标识符重复两次：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">y</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">o</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">y</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">o</span>)
</span></span></code></pre></div><p>在ES6及之后，可以删掉其中的分号和一份标识符，得到非常简洁的代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">y</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">o</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>};
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">y</span>) <span style="color:#75715e">// 3
</span></span></span></code></pre></div><h3 id="computed-property-names">Computed Property Names</h3>
<p>有时候属性的名字不是在编译时可以直接写在源代码中的常量，这个属性名是保存在一个变量或者通过函数调用而得到。不能对这种属性使用基本字面量，必须先创建一个对象，然后再添加这种属性。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">PROPERTY_NAME</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;p1&#34;</span>;  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">computePropertyName</span>() {  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;p&#34;</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>;  
</span></span><span style="display:flex;"><span>}  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">o</span> <span style="color:#f92672">=</span> {};  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">o</span>[<span style="color:#a6e22e">PROPERTY_NAME</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">o</span>[<span style="color:#a6e22e">computePropertyName</span>()] <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span></code></pre></div><p>使用ES6的计算属性特性可以直接使用字面量创建对象：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">PROPERTY_NAME</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;p1&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">computePropertyName</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;p&#34;</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    [<span style="color:#a6e22e">PROPERTY_NAME</span>]<span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>, [<span style="color:#a6e22e">computePropertyName</span>()]<span style="color:#f92672">:</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">p</span>)
</span></span></code></pre></div><p>有了这个语法，就可以在方括号中加入任意表达式，这个表达式的值（必要时转换为字符串）会用作属性的名字。</p>
<h3 id="symbols-as-property-names">Symbols as Property Names</h3>
<p>计算属性语法也让另一个非常重要的字面量特性成为可能。在ES6及以后，属性名可以是字符串或符号。如果赋值符号给一个变量或常量，可以使用计算属性语法将该符号作为属性名。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">extension</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Symbol</span>(<span style="color:#e6db74">&#34;my extension symbol&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">o</span> <span style="color:#f92672">=</span> {  
</span></span><span style="display:flex;"><span>    [<span style="color:#a6e22e">extension</span>]<span style="color:#f92672">:</span> { <span style="color:#75715e">/* extension data stored in this object */</span>}  
</span></span><span style="display:flex;"><span>};  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">o</span>[<span style="color:#a6e22e">extension</span>].<span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// This won&#39;t conflict with other properties of o
</span></span></span></code></pre></div><p>符号是<font color=red>不透明值</font>，除了用作属性名之外，不能用它们作任何事情。每个<code>Symbol</code>都与其它<code>Symbol</code>不同，这意味着符号非常适合用于创建唯一属性名。</p>
<h2 id="spread-operator">Spread Operator</h2>
<p>在ES2018后，可以在对象字面量中使用扩展操作符<code>...</code>，把已有对象的属性复制到新对象中。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">position</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">y</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">0</span>};  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">dimensions</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">width</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">100</span>, <span style="color:#a6e22e">height</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">75</span>};  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">rect</span> <span style="color:#f92672">=</span> {...<span style="color:#a6e22e">position</span>, ...<span style="color:#a6e22e">dimensions</span>};  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">rect</span>.<span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">rect</span>.<span style="color:#a6e22e">y</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">rect</span>.<span style="color:#a6e22e">width</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">rect</span>.<span style="color:#a6e22e">height</span> <span style="color:#75715e">// =&gt; 175
</span></span></span></code></pre></div><p>需要注意的是这个<code>...</code>语法经常被称为展开操作符，但却不是真正意义上的操作符。实际上，<font color=red>它是仅在对象字面量中有效的一种特殊语法</font>（在其它上下文中，三个点有其它用途）。如果扩展对象和被扩展对象有一个同名属性，那么这个属性的值由后面的对象决定：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">o</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span> };
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">0</span>, ...<span style="color:#a6e22e">o</span> };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">x</span> <span style="color:#75715e">// =&gt; 1: the value from object o overrides the initial value
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">q</span> <span style="color:#f92672">=</span> { ...<span style="color:#a6e22e">o</span>, <span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">2</span> };
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">x</span> <span style="color:#75715e">// =&gt; 2: the value 2 overrides the previous value from o.
</span></span></span></code></pre></div><p>另外要注意，扩展操作符只扩展对象的自有属性，不扩展任何继承属性：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">o</span> <span style="color:#f92672">=</span> Object.<span style="color:#a6e22e">create</span>({<span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>}); <span style="color:#75715e">// o inherits the property x
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">=</span> { ...<span style="color:#a6e22e">o</span> };
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">x</span>  <span style="color:#75715e">// =&gt; undefined
</span></span></span></code></pre></div><p>需要注意的是，虽然扩展操作符只有3个圆点，但它可能给解释器带来巨大工作量。如果对象有<code>n</code>个属性，把这些属性扩展到另一个对象的复杂度可能是$O(n)$。这意味着，如果在循环或递归函数中使用扩展操作符向一个的大对象不断追加属性时，很可能复杂度为$O(n^2)$。</p>
<h2 id="shorthand-methods">Shorthand Methods</h2>
<p>把函数定义成一个对象的属性时，这个函数被称为方法。在ES6以前，需要像定义对象的其他属性一样，通过函数定义表达式在对象字面量定义一个方法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">square</span> <span style="color:#f92672">=</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">area</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">function</span> () {  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">side</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">side</span>;  
</span></span><span style="display:flex;"><span>    }, <span style="color:#a6e22e">side</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">10</span>  
</span></span><span style="display:flex;"><span>};  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">square</span>.<span style="color:#a6e22e">area</span>())
</span></span></code></pre></div><p>但在ES6中，对象字面量语法经过扩展，允许一种省略<code>function</code>关键字和冒号的的简写方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">square</span> <span style="color:#f92672">=</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">area</span>() {  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">side</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">side</span>;  
</span></span><span style="display:flex;"><span>    }, <span style="color:#a6e22e">side</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">10</span>  
</span></span><span style="display:flex;"><span>};  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">square</span>.<span style="color:#a6e22e">area</span>() <span style="color:#75715e">// =&gt; 100
</span></span></span></code></pre></div><h2 id="property-getters-and-setters">Property Getters and Setters</h2>
<p>目前讨论的所有属性都是数据属性，一个属性名和普通值。除了数据属性，还支持为对象定义访问器属性，这种属性不是一个值，而是一个或者两个访问器方法，一个获取方法和一个设置方法。</p>
<p>如果一个属性既有<code>getter</code>方法又有<code>setter</code>方法，它就是一个读写属性。如果只有一个<code>getter</code>方法，它就是一个只读属性。如果只有一个<code>setter</code>方法，那它就是一个只写属性。如果试图读取只写属性，会得到<code>undefined</code>。</p>
<p>访问器属性可以通过对象字面量的扩展语法定义，<code>getter</code>和<code>setter</code>是ES5引入的，不是ES6才引入的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">o</span> <span style="color:#f92672">=</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// An ordinary data property  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">dataProp</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">value</span>,  
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// An accessor property defined as a pair of functions.   
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">get</span> <span style="color:#a6e22e">accessorProp</span>() {  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">dataProp</span>;  
</span></span><span style="display:flex;"><span>    },  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">set</span> <span style="color:#a6e22e">accessorProp</span>(<span style="color:#a6e22e">value</span>) {  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">dataProp</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">value</span>;  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>访问属性是通过一个或两个方法来定义的，方法名是属性名。除了前缀<code>get</code>和<code>set</code>，这两个方法看起来就像是用ES6简写的语法定义的普通方法一样。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">=</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// x and y are regular read-write data properties.  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1.0</span>, <span style="color:#a6e22e">y</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1.0</span>,  
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// r is a read-write accessor property with getter and setter.  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// Don&#39;t forget to put a comma after accessor methods.  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">get</span> <span style="color:#a6e22e">r</span>() {  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Math.<span style="color:#a6e22e">hypot</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">x</span>, <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">y</span>);  
</span></span><span style="display:flex;"><span>    },  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">set</span> <span style="color:#a6e22e">r</span>(<span style="color:#a6e22e">newvalue</span>) {  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">oldvalue</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">hypot</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">x</span>, <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">y</span>);  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">ratio</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">newvalue</span> <span style="color:#f92672">/</span> <span style="color:#a6e22e">oldvalue</span>;  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">x</span> <span style="color:#f92672">*=</span> <span style="color:#a6e22e">ratio</span>;  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">y</span> <span style="color:#f92672">*=</span> <span style="color:#a6e22e">ratio</span>;  
</span></span><span style="display:flex;"><span>    },  
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// theta is a read-only accessor property with getter only.  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">get</span> <span style="color:#a6e22e">theta</span>() {  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Math.<span style="color:#a6e22e">atan2</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">y</span>, <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">x</span>);  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>};  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">r</span>)  <span style="color:#75715e">// 1.4142135623730951
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">theta</span>) <span style="color:#75715e">// 0.7853981633974483
</span></span></span></code></pre></div><p>上面示例中使用了<code>this</code>关键字，表示当前对象。访问属性也是可以被继承的，可以把上面定义的对象<code>p</code>作为其他对象的原型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">// A new object that inherits getters and setters  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">q</span> <span style="color:#f92672">=</span> Object.<span style="color:#a6e22e">create</span>(<span style="color:#a6e22e">p</span>);  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;  <span style="color:#75715e">// Create q&#39;s own data properties
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">y</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">r</span>)  <span style="color:#75715e">// 5.0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">theta</span>) <span style="color:#75715e">// 0.9272952180016122
</span></span></span></code></pre></div><h1 id="chapter-7">Chapter 7</h1>
<p>数组是值的<font color=LightSeaGreen>有序集合，其中的值叫做元素</font>，每个元素有一个数值表示的位置，叫做索引。<code>JavaScript</code>的数组元素是无类型限制的，即<font color=red>同一数组中的元素可以是任意类型</font>。也就是说，<font color=LightSeaGreen>同一个数组中的元素可能有不同的类型</font>。</p>
<p><code>JavaScript</code>的数组是动态的，它们会按需增长或减少，因此创建数组时无须声明一个固定大小，也无须在大小变化时重新为它们分配空间。</p>
<p>数组可以是稀疏的，即数组中的元素不一定具有连续的索引，中间可能有间隙。每个数组都有<code>length</code>属性。对于非稀疏数组，这个属性保存数组中元素的个数，对于稀疏数组，这个属性值大于数组中元素个数。</p>
<p>数组是一种特殊的对象，数组索引更像是属性名，只不过恰巧是整数而已。在实现时通常会对数组进行特别优化，从而使得<font color=LightSeaGreen>通过数值索引访问的数组元素明显快于访问常规的对象属性</font>。</p>
<p>ES6增加了一批新的数组类，被称为定型数组。<font color=LightSeaGreen>定型数组具有固定长度和固定的元素类型，数组具有极高的性能，支持对二进制数据的字节级访问</font>。</p>
<h2 id="creating-arrays">Creating Arrays</h2>
<p>创建数组有以下几种方式：</p>
<ul>
<li>数组字面量。</li>
<li>可迭代对象使用展开操作符。</li>
<li><code>Array()</code>构造器。</li>
<li>工厂方法<code>Array.of()</code>和<code>Array.from()</code></li>
</ul>
<h3 id="array-literals">Array Literals</h3>
<p>创建数组最简单的方式是数组字面量，数组字面量只是在方括号中简单地以逗号分隔每个元素。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">emptyArr</span> <span style="color:#f92672">=</span> []; <span style="color:#75715e">// An array with no elements   
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">primes</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">11</span>]; <span style="color:#75715e">// An array with 5 numeric elements   
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">misc</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1.1</span>, <span style="color:#66d9ef">true</span>, <span style="color:#e6db74">&#34;a&#34;</span>,]; <span style="color:#75715e">// 3 elements of various types + trailing comma  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">emptyArr</span>, <span style="color:#a6e22e">primes</span>, <span style="color:#a6e22e">misc</span>,)
</span></span></code></pre></div><p>数组字面量中的元素<font color=red>不必一定是常量，可以是任意表达式</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">base</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1024</span>;  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">table</span> <span style="color:#f92672">=</span> [<span style="color:#a6e22e">base</span>, <span style="color:#a6e22e">base</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">base</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>, <span style="color:#a6e22e">base</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">3</span>];  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">table</span>) <span style="color:#75715e">// [1024, 1025, 1026, 1027]
</span></span></span></code></pre></div><p>数组字面量可以包含对象字面量或其它数组字面量：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">b</span> <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">1</span>, {<span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">y</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">2</span>}], [<span style="color:#ae81ff">2</span>, {<span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">3</span>, <span style="color:#a6e22e">y</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">4</span>}]];  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">b</span>)
</span></span></code></pre></div><p>如果一个数组字面量在一行中包含多个连续逗号，且两个连续逗号中间没有值，那么这个数组就是稀疏的。省略了值的数组元素并不存在，在查询时结果为<code>undefined</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">count</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, , <span style="color:#ae81ff">3</span>]; <span style="color:#75715e">// Elements at indexes 0 and 2. No element at index 1  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">undefs</span> <span style="color:#f92672">=</span> [, ,]; <span style="color:#75715e">// An array with no elements but a length of 2  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">count</span>,<span style="color:#a6e22e">undefs</span>[<span style="color:#ae81ff">0</span>], <span style="color:#a6e22e">undefs</span>[<span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>[ <span style="color:#ae81ff">1</span>, <span style="color:#f92672">&lt;</span><span style="color:#ae81ff">1</span> <span style="color:#a6e22e">empty</span> <span style="color:#a6e22e">item</span><span style="color:#f92672">&gt;</span>, <span style="color:#ae81ff">3</span> ] <span style="color:#66d9ef">undefined</span> <span style="color:#66d9ef">undefined</span>
</span></span></code></pre></div><p>数组字面量允许可选的尾逗号，因此数组字面量<code>[,,]</code>的长度(<code>length</code>属性)为2，而不是3。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>([, ,].<span style="color:#a6e22e">length</span>) <span style="color:#75715e">// 2
</span></span></span></code></pre></div><h4 id="the-spread-operator">The Spread Operator</h4>
<p>从ES6开始，可以使用展开操作符<code>...</code>（不是一个真正的运算符）能将一个数组的所有元素包含在一个数组字面量中，如下所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">aa</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">ab</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>, ...<span style="color:#a6e22e">aa</span>, <span style="color:#ae81ff">4</span>]; <span style="color:#75715e">// ab === [0, 1, 2, 3, 4]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">aa</span>, <span style="color:#a6e22e">ab</span>, <span style="color:#a6e22e">aa</span>.<span style="color:#a6e22e">length</span>, <span style="color:#a6e22e">ab</span>.<span style="color:#a6e22e">length</span>) 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 打印的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>] [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>] <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">a1</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, [<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>]];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">ab1</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>, ...<span style="color:#a6e22e">a1</span>, <span style="color:#ae81ff">4</span>]; <span style="color:#75715e">// b === [0, 1, 2, 3, 4]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">a1</span>, <span style="color:#a6e22e">ab1</span>, <span style="color:#a6e22e">a1</span>.<span style="color:#a6e22e">length</span>, <span style="color:#a6e22e">ab1</span>.<span style="color:#a6e22e">length</span>) <span style="color:#75715e">// ab1 === [0, [1,2,3], 4]
</span></span></span></code></pre></div><p>上面<code>3</code>个点会展开数组<code>a</code>，它所有的元素成为正在创建的数组字面量中的元素。也就是<code>...a</code>被数组<code>a</code>中的所有元素所替代，并作为外层数组字面量的一部分被列出。</p>
<p>请注意，虽然将这<code>3</code>个点称为展开运算符，但<font color=red>它并不是一个真正的运算符，因为它只能用于数组字面量和函数调用</font>。展开操作符是一种便捷的方式创建数组的副本：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">original</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">copy</span> <span style="color:#f92672">=</span> [...<span style="color:#a6e22e">original</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">copy1</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">original</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">copy</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// Modifying the copy does not change the original
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">original</span>[<span style="color:#ae81ff">0</span>], <span style="color:#a6e22e">copy</span>[<span style="color:#ae81ff">0</span>], <span style="color:#a6e22e">original</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">copy</span>, <span style="color:#a6e22e">copy1</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">original</span>) <span style="color:#75715e">// 1 0 false true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行的结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">1</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">false</span> <span style="color:#66d9ef">true</span>
</span></span></code></pre></div><p>实际上，<font color=LightSeaGreen>展开操作符对于所有可迭代的对象都是可用的</font>。字符串是可迭代的，因此可以使用展开操作符将字符串转换为字符数组：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">digits</span> <span style="color:#f92672">=</span> [...<span style="color:#e6db74">&#34;0123456789ABCDEF&#34;</span>];  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">digits</span>) <span style="color:#75715e">// [&#34;0&#34;, &#34;1&#34;, &#34;2&#34;, &#34;3&#34;, &#34;4&#34;, &#34;5&#34;, &#34;6&#34;, &#34;7&#34;, &#34;8&#34;, &#34;9&#34;, &#34;A&#34;, &#34;B&#34;, &#34;C&#34;, &#34;D&#34;, &#34;E&#34;, &#34;F&#34;]
</span></span></span></code></pre></div><p>集合对象是可迭代的，因此移除数组中重复元素的一种简单方式是将数组先转换为集合，然后使用展开操作符将集合转换回数组：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">letters</span> <span style="color:#f92672">=</span> [...<span style="color:#e6db74">&#34;hello world&#34;</span>];  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>([...<span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Set</span>(<span style="color:#a6e22e">letters</span>)]) <span style="color:#75715e">// [&#34;h&#34;, &#34;e&#34;, &#34;l&#34;, &#34;o&#34;, &#34; &#34;, &#34;w&#34;, &#34;r&#34;, &#34;d&#34;]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>[<span style="color:#e6db74">&#34;h&#34;</span>, <span style="color:#e6db74">&#34;e&#34;</span>, <span style="color:#e6db74">&#34;l&#34;</span>, <span style="color:#e6db74">&#34;o&#34;</span>, <span style="color:#e6db74">&#34; &#34;</span>, <span style="color:#e6db74">&#34;w&#34;</span>, <span style="color:#e6db74">&#34;r&#34;</span>, <span style="color:#e6db74">&#34;d&#34;</span>]
</span></span></code></pre></div><h2 id="the-array-constructor">The Array() Constructor</h2>
<p>另一种创建数组的方式是使用<code>Array()</code>构造器，我们能以三种不同方式调用<code>Array</code>构造器。第一种方式是调用构造器的时候不传任何参数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Array();
</span></span></code></pre></div><p>这种方式创建了一个空数组，里面没有任何元素，等同于数组字面量<code>[]</code>。第二种方式是调用构造器时传入一个数值参数，以指定数组的长度：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Array(<span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">length</span>)  <span style="color:#75715e">// 10
</span></span></span></code></pre></div><p>这种方式创建了一个指定长度的数组。如果事先知道需要多少元素，这种形式可用于预分配数组。但需要注意的是，数组中不会存储任何值，甚至没有为数组定义数组索引属性。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Array(<span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">length</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">undefined</span>
</span></span></code></pre></div><p>第三种方式是为数组明确指定<font color=LightSeaGreen>两个或多个数组元素或一个非数字元素</font>。在这种方式下，构造器的所有参数都成为了新数组的中的元素：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">a1</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Array(<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;testing, testing&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">a2</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Array(<span style="color:#e6db74">&#34;element&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">a1</span>, <span style="color:#a6e22e">a2</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 打印的结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>[<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;testing, testing&#34;</span>]
</span></span><span style="display:flex;"><span>[<span style="color:#e6db74">&#34;element&#34;</span>]
</span></span></code></pre></div><h3 id="arrayof">Array.of()</h3>
<p>当<code>Array()</code>构造器使用一个数字参数调用时，这个数字表示数组长度。但当多于一个参数调用<code>Array()</code>构造器时，它将这些传入的参数当成数组元素。这意味着<code>Array()</code>构造器<font color=red>不能创建只包含单个数值元素的数组</font>。</p>
<p>在ES6，函数<code>Array.of()</code>能够解决这个问题，它是一个工厂方法，以其所有参数值（不管有多少个）创建和返回一个新的数组：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span>Array.<span style="color:#66d9ef">of</span>() <span style="color:#75715e">// =&gt; []; returns empty array with no arguments 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Array.<span style="color:#66d9ef">of</span>(<span style="color:#ae81ff">10</span>)<span style="color:#75715e">// =&gt; [10]; can create arrays with a single numeric argument
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Array.<span style="color:#66d9ef">of</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>) <span style="color:#75715e">// =&gt; [1, 2, 3]
</span></span></span></code></pre></div><h3 id="arrayfrom">Array.from()</h3>
<p>另一个数组工厂方法是<code>ES6</code>引入的，<font color=LightSeaGreen>它期望一个可迭代的或类数组对象作为它的第一个参数并返回一个新的数组</font>，这个新生成的数组包含了传入对象的所有元素。对于可迭代的参数，<code>Array.from(iterable)</code>的作用如同3个点展开操作符<code>[...iterable]</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">copy</span> <span style="color:#f92672">=</span> Array.<span style="color:#a6e22e">from</span>(<span style="color:#a6e22e">original</span>);
</span></span></code></pre></div><p><code>Array.from()</code>同样重要，因为它定义了一种为<font color=LightSeaGreen>类数组对象创建真正数组副本的方法</font>。类数组对象是具长度属性的非数组对象，其存储值的属性名称恰好是整数。某些网络浏览器方法的返回值是类数组对象，如果先将它们转换为真数组，处理起来会更容易：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">trueArr</span> <span style="color:#f92672">=</span> Array.<span style="color:#a6e22e">from</span>(<span style="color:#a6e22e">arraylike</span>);
</span></span></code></pre></div><p>工厂方法<code>Array.from()</code>接受第二个可选的参数，如果传递函数作为第二个参数，那么在构建新数组时，原对象中的每个元素都将传递给这个指定的函数，函数的返回值将存储在新数组中。</p>
<h2 id="reading-and-writing-array-elements">Reading and Writing Array Elements</h2>
<p>访问数组中的某个元素使用操作符<code>[]</code>，数组的引用应出现在方括号的左侧。<font color=red>方括号内应是一个值为非负整数的任意表达式</font>，可以使用这种语法读取和写入数组元素的值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;world&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">3.14</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">i</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">i</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">3</span>]) <span style="color:#75715e">// hello
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">i</span>]] <span style="color:#f92672">=</span> <span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">length</span>, <span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">3</span>]) <span style="color:#75715e">// 4 world
</span></span></span></code></pre></div><p>数组的特殊之处在于，当使用的属性名是小于$2^{32}-1$的非负整数时，<font color=red>会自动维护数组长度属性的值</font>。例如，在上面代码中，创建了只有一个元素的数组<code>a</code>。然后在索引1、2和3处赋值，数组的<code>length</code>属性也会随之改变:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">length</span> <span style="color:#75715e">// =&gt; 4
</span></span></span></code></pre></div><p>数组是特殊类型的对象，访问数组元素时使用的方括号与访问对象属性时使用的方括号作用相同。<code>JavaScript</code>会<font color=red>将数字索引转换为字符串，然后使用该字符串作为属性名称</font>。将索引从数值转换为字符串并没有什么特别之处，普通对象也可以这样做：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">o2</span> <span style="color:#f92672">=</span> {};<span style="color:#75715e">// Create a plain object
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">o2</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;one&#34;</span>; <span style="color:#75715e">// Index it with an integer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">o2</span>[<span style="color:#e6db74">&#34;1&#34;</span>] <span style="color:#75715e">// =&gt; &#34;one&#34;; 数值和字符串属性是一样的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">o2</span>[<span style="color:#e6db74">&#34;1&#34;</span>]) <span style="color:#75715e">// one 
</span></span></span></code></pre></div><p>明确区分数组索引和对象属性名称是很有帮助的。所有索引都是属性名，但只有0到$2^{32}-2$之间的整数属性名才是索引。<font color=red>所有数组都是对象</font>，可以在数组上创建任意名称的属性。但是，如果使用的属性是数组索引，那么数组就会根据需要更新其<code>length</code>属性。</p>
<p>需要注意的是，<font color=LightSeaGreen>可以使用负数或非整数的数值为数组建立&quot;索引&quot;</font>。这样做时，数值会先被转换为字符串，字符串被用作属性名称。由于转换成字符串后该名称不是非负整数，因此会被视为常规对象属性，而不是数组索引。同样，<font color=LightSeaGreen>如果在数组中使用一个恰好是非负整数的字符串作为属性，它将被视为数组索引，而不是对象属性</font>。使用与整数相同的浮点数也是如此：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">a</span>[<span style="color:#f92672">-</span><span style="color:#ae81ff">1.23</span>] <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>; <span style="color:#75715e">// This creates a property named &#34;-1.23&#34; 当成普通的属性
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">a</span>[<span style="color:#e6db74">&#34;1000&#34;</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// This the 1001st element of the array
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">1.000</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;  <span style="color:#75715e">// Array index 1. Same as a[1] = 1; 
</span></span></span></code></pre></div><p>事实上，<font color=red>数组索引只是对象属性名称的一种特殊类型，这意味着数组没有<code>out of bounds</code>错误的概念</font>。当尝试查询对象的一个不存在的属性时，不会出现错误，只会返回<code>undefined</code>，这一点对于数组和对象都是一样的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> [<span style="color:#66d9ef">true</span>, <span style="color:#66d9ef">false</span>]; <span style="color:#75715e">// This array has elements at indexes 0 and 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">2</span>] <span style="color:#75715e">// =&gt; undefined; no element at this index.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">a</span>[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#75715e">// =&gt; undefined; no property with this name.
</span></span></span></code></pre></div><h2 id="sparse-arrays">Sparse Arrays</h2>
<p>稀疏数组是指元素没有从0开始的连续索引的数组。 通常，数组的<code>length</code>属性表示数组中元素的个数。如果数组是稀疏的，则<code>length</code>属性的值会大于所有元素个数。稀疏数组可以通过<code>Array()</code>构造函数创建，也可以通过赋值给一个大于当前数组长度的数组索引来创建。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Array(<span style="color:#ae81ff">5</span>); <span style="color:#75715e">// No elements, but a.length is 5.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">b</span> <span style="color:#f92672">=</span> []; <span style="color:#75715e">// Create an array with no elements and length = 0.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">b</span>[<span style="color:#ae81ff">1000</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// Assignment adds one element but sets length to 1001.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">length</span>) <span style="color:#75715e">// 1001
</span></span></span></code></pre></div><p>与密集数组相比，足够稀疏的数组通常以更慢、更节省内存的方式实现，在这样的数组中查找元素所需的时间与普通对象属性查找的时间差不多。</p>
<p>需要注意的是，在数组字面量中省略一个值（使用连续重复的逗号，例如<code>[1,,3]</code>），得到的数组就是稀疏的，省略的元素根本不存在的:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">a1</span> <span style="color:#f92672">=</span> [,];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">a2</span> <span style="color:#f92672">=</span> [<span style="color:#66d9ef">undefined</span>];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 属性值判断
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#ae81ff">0</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">a1</span>, <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">a2</span>) <span style="color:#75715e">// false true
</span></span></span></code></pre></div><p>了解稀疏数组是理解数组本质的重要部分。不过，在实际工作中，大多数数组都不是稀疏数组。而且，如果确实需要使用稀疏数组，代码中很可能会像处理<code>undefined</code>元素的非稀疏数组一样处理它。</p>
<h2 id="array-length">Array Length</h2>
<p>每个数组都有一个<code>length</code>属性，正是这个属性使得数组和普通的对象不同。对于密集数组（即非稀疏数组），<code>length</code>属性指定数组中的元素个数，其值比数组中的最高索引大一：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>([].<span style="color:#a6e22e">length</span>, [<span style="color:#e6db74">&#34;a&#34;</span>, <span style="color:#e6db74">&#34;b&#34;</span>, <span style="color:#e6db74">&#34;c&#34;</span>].<span style="color:#a6e22e">length</span>) <span style="color:#75715e">// 0 3
</span></span></span></code></pre></div><p>当一个<font color=LightSeaGreen>数组是稀疏数组，其属性<code>length</code>的值大于数组中的元素个数</font>。一个数组（无论是否稀疏）永远不会有索引大于或等于长度的元素。为了保持这种不变性，数组有两种特殊的行为。第一种行为：如果索引<code>i</code>大于或等于数组当前长度的数组元素赋值，则<code>length</code>属性的值将被设置为<code>i+1</code>。</p>
<p>数组为保持长度不变而实施的第二个特殊行为是，如果将<code>length</code>属性设置为一个小于其当前值的非负整数<code>n</code>，<font color=red>则任何索引大于或等于<code>n</code>的数组元素都会从数组中删除</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">5</span>]; <span style="color:#75715e">// Start with a 5-element array.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">length</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>; <span style="color:#75715e">// a is now [1,2,3].
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">a</span>) <span style="color:#75715e">// [1,2,3]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">length</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// Delete all elements. a is [].
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">a</span>) <span style="color:#75715e">// []
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">length</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>; <span style="color:#75715e">// Length is 5, but no elements, like new Array(5)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">a</span>) <span style="color:#75715e">// []
</span></span></span></code></pre></div><h2 id="adding-and-deleting-array-elements">Adding and Deleting Array Elements</h2>
<p>添加数组元素最简单的方式是赋值给新的索引：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> []; <span style="color:#75715e">// Start with an empty array.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;zero&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;one&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>[ <span style="color:#e6db74">&#39;zero&#39;</span>, <span style="color:#e6db74">&#39;one&#39;</span> ]
</span></span></code></pre></div><p>也可以使用<code>push</code>方法<font color=LightSeaGreen>添加一个或多个元素到数组尾部</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> [];
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">push</span>(<span style="color:#e6db74">&#34;zero&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">push</span>(<span style="color:#e6db74">&#34;one&#34;</span>, <span style="color:#e6db74">&#34;two&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">a</span>) <span style="color:#75715e">// [&#34;zero&#34;, &#34;one&#34;, &#34;two&#34;]
</span></span></span></code></pre></div><p>当<code>push</code>一个元素到数组<code>a</code>中，相当于赋值到<code>a[a.length]</code>。也可以使用<code>unshift()</code>方法将值插入到数组开头，并移动已经存在的元素到更高的索引。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> [];
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">push</span>(<span style="color:#e6db74">&#34;zero&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">push</span>(<span style="color:#e6db74">&#34;one&#34;</span>, <span style="color:#e6db74">&#34;two&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">unshift</span>(<span style="color:#e6db74">&#34;-1&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">a</span>) <span style="color:#75715e">// [&#34;-1&#34;, &#34;zero&#34;, &#34;one&#34;, &#34;two&#34;]
</span></span></span></code></pre></div><p>方法<code>pop()</code>移除数组的最后一个元素，并返回它，数组元素长度会减<code>1</code>。相似地，<code>shift()</code>方法移除第一个元素，并将数组长度减<code>1</code>，其它元素往前移动。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> [];
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">push</span>(<span style="color:#e6db74">&#34;zero&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">push</span>(<span style="color:#e6db74">&#34;one&#34;</span>, <span style="color:#e6db74">&#34;two&#34;</span>) <span style="color:#75715e">// [&#34;zero&#34;, &#34;one&#34;]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">shift</span>()
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">a</span>)   <span style="color:#75715e">// [&#39;one&#39;, &#39;two&#39;]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">b</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">pop</span>()
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">b</span>)  <span style="color:#75715e">// two
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">a</span>)  <span style="color:#75715e">// [&#39;one&#39;]
</span></span></span></code></pre></div><p>可以使用操作符<code>delete</code>删除数组中的元素，<font color=red>但既不会改变数组长度，也不会将索引较高的元素向下移动以填补删除属性留下的空隙</font>。如果从数组中删除一个元素，数组就会变成稀疏数组。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">delete</span> <span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">2</span>]; <span style="color:#75715e">// a now has no element at index 2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">2</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">a</span>  <span style="color:#75715e">// =&gt; false: no array index 2 is defined
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">length</span> <span style="color:#75715e">// =&gt; 3: delete does not affect array length
</span></span></span></code></pre></div><p>如上所述，只需将<code>length</code>属性设置为所需的新长度，就可以从数组末尾删除元素。最后，方法<code>splice()</code>是插入、删除或替换数组元素的通用方法。它可以改变长度属性，并根据需要将数组元素移到更高或更低的索引中。</p>
<h2 id="iterating-arrays">Iterating Arrays</h2>
<p>从 ES6开始，遍历数组（或任何可迭代对象）中每个元素的最简单方法是使用<code>for/of</code>循环：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">letters</span> <span style="color:#f92672">=</span> [...<span style="color:#e6db74">&#34;Hello world&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">string</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">letter</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">letters</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">string</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">letter</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">string</span>)
</span></span></code></pre></div><p>循环<code>for/of</code>使用的内置数组迭代器会按索引升序返回数组元素。<font color=LightSeaGreen>对于稀疏数组，迭代器没有特殊行为，对于不存在的数组元素，迭代器会简单地返回<code>undefined</code></font>。</p>
<p>如果想要对数组使用<code>for/of</code>循环，并需要知道数组每个元素的索引，可以使用数组的<code>entries()</code>方法并解构赋值，就像下面这样：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">letters</span> <span style="color:#f92672">=</span> [...<span style="color:#e6db74">&#34;Hello world&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">string</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">letter</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">letters</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">string</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">letter</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">string</span>) <span style="color:#75715e">// =&gt; &#34;Hello world&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">everyOther</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> [<span style="color:#a6e22e">index</span>, <span style="color:#a6e22e">letter</span>] <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">letters</span>.<span style="color:#a6e22e">entries</span>()) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">index</span> <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">===</span> <span style="color:#ae81ff">0</span>) <span style="color:#a6e22e">everyOther</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">letter</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">everyOther</span>)  <span style="color:#75715e">// =&gt; &#34;Hlowrd&#34;
</span></span></span></code></pre></div><p>另一种迭代数组的方式是<code>forEach()</code>。这不是<code>for</code>循环的新形式，<font color=LightSeaGreen>而是一种数组方法，提供了一种数组迭代的功能性方法</font>。可以向数组的<code>forEach()</code>方法传递一个函数，然后<code>forEach()</code>会在数组的每个元素上调用一次这个传入的函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">uppercase</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">letters</span>.<span style="color:#a6e22e">forEach</span>(<span style="color:#a6e22e">letter</span> =&gt; { <span style="color:#75715e">// Note arrow function syntax here
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">uppercase</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">letter</span>.<span style="color:#a6e22e">toUpperCase</span>();
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">uppercase</span>) <span style="color:#75715e">// HELLO WORLD
</span></span></span></code></pre></div><p>正如我们期待的，<code>forEach()</code>按照顺序迭代数组，它实际上将数组的索引传递到传入的函数中作为第二个参数，这在某些情况下是很有用的。与<code>for/of</code>循环不同，循环<font color=red><code>forEach()</code>能识别稀疏数组，不会调用函数来处理不存在的元素</font>。</p>
<p>也可以使用老式的<code>for</code>循环来遍历数组中的元素：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">vowels</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">letters</span>.<span style="color:#a6e22e">length</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>) { <span style="color:#75715e">// For each index in the array // Get the element at that index
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">letter</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">letters</span>[<span style="color:#a6e22e">i</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#e6db74">/[aeiou]/</span>.<span style="color:#a6e22e">test</span>(<span style="color:#a6e22e">letter</span>)) { <span style="color:#75715e">// Use a regular expression test
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">vowels</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">letter</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">vowels</span>) <span style="color:#75715e">// eoo
</span></span></span></code></pre></div><p>在嵌套循环或其它对性能要求较高的情况下，有时会看到这种基本数组迭代循环的写法，<font color=red>即数组长度只查询一次</font>，而不是每次迭代都查询。以下两种<code>for</code>循环形式都是惯用的，但并不常见，而且在现代解释器中，它们对性能的影响也不明显：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">// 减少数组长度只查询一次
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">len</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">letters</span>.<span style="color:#a6e22e">length</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">len</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// loop body remains the same 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Iterate backwards from the end of the array to the start 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">letters</span>.<span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">--</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// loop body remains the same 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>上面这些例子假定数组是密集的，所有元素都包含有效数据。如果情况并非如此，则应在使用数组元素前对其进行测试。如果想跳过未定义和不存在的元素：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">length</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">i</span>] <span style="color:#f92672">===</span> <span style="color:#66d9ef">undefined</span>) <span style="color:#66d9ef">continue</span>; <span style="color:#75715e">// Skip undefined + nonexistent elements
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// loop body here
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h2 id="multidimensional-arrays">Multidimensional Arrays</h2>
<p><code>JavaScript</code>不支持真正的多维数组，但可以使用数组的数组来近似多维数组。要访问二维数组中的值，只需使用<code>[]</code>操作符两次即可。例如，假设变量<code>matrix</code>是一个数组，其中的每个元素<code>matrix[x]</code>是一个数组。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">// Create a multidimensional array
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">table</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Array(<span style="color:#ae81ff">10</span>); <span style="color:#75715e">// 10 rows of the table
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">table</span>.<span style="color:#a6e22e">length</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Each row has 10 columns
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">table</span>[<span style="color:#a6e22e">i</span>] <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Array(<span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Initialize the array
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">row</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">row</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">table</span>.<span style="color:#a6e22e">length</span>; <span style="color:#a6e22e">row</span><span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">col</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">col</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">table</span>[<span style="color:#a6e22e">row</span>].<span style="color:#a6e22e">length</span>; <span style="color:#a6e22e">col</span><span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">table</span>[<span style="color:#a6e22e">row</span>][<span style="color:#a6e22e">col</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">row</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">col</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">table</span>[<span style="color:#ae81ff">5</span>][<span style="color:#ae81ff">7</span>]) <span style="color:#75715e">// 35
</span></span></span></code></pre></div><h2 id="array-methods">Array Methods</h2>
<p>迭代器方法用于遍历数组元素，通常对于其中的每个元素调用一次指定的函数。栈和队列方法用于在开头或末尾向数组中添加元素或从数组中删除元素。子数组方法用于提取、删除、插入、填充和复制更大数组的连续区域。搜索和排序方法用于在数组中查找元素和对数组元素进行排序。</p>
<h3 id="array-iterator-methods">Array Iterator Methods</h3>
<p>方法<code>forEach()</code>用于迭代数组中的每个元素，并对每个元素调用一次指定的函数。传统的<code>forEach()</code>方法的第一个参数是函数。<code>forEach</code>在调用这个函数时会给它传<code>3</code>个参数：数组元素的值，数组元素的索引值和数组本身。如果只关注数组元素的值，可以把函数写成只接受一次参数，即忽略其它参数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">data</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>], <span style="color:#a6e22e">sum</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Compute the sum of the elements of the array
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">data</span>.<span style="color:#a6e22e">forEach</span>(<span style="color:#a6e22e">value</span> =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sum</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">value</span>;
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">sum</span>) <span style="color:#75715e">// 15
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Now increment each array element
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">data</span>.<span style="color:#a6e22e">forEach</span>(<span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">a</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">i</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">v</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">data</span>) <span style="color:#75715e">// [ 2, 3, 4, 5, 6 ]
</span></span></span></code></pre></div><p>需要注意的是，<code>forEach()</code><font color=LightSeaGreen>不提供提前终止循环的方式</font>。换句话说，在这里没有与常规<code>for</code>循环中的<code>break</code>语句对等的机制。</p>
<p>方法<code>map()</code>把数组的每个元素分传递给指定的函数，返回这个函数的返回值构成的新数组。需要注意的是<code>map</code>返回一个新数组，不改变调用它的数组。<font color=LightSeaGreen>如果数组是稀疏的，则缺失的元素不会调用我们的函数，但返回的数组和原始数组一样稀疏，长度相同，缺失的元素也相同</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">map</span>(<span style="color:#a6e22e">x</span> =&gt; <span style="color:#a6e22e">x</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">x</span>)) <span style="color:#75715e">// [1, 4, 9]
</span></span></span></code></pre></div><p>方法<code>filter()</code>返回一个数组，该数组包含调用它的数组的子数组。传给这个方法的函数应该是断言函数，即返回<code>true</code>和<code>false</code>的函数。如果函数返回<code>true</code>或返回的值能转换<code>true</code>，则该元素是新数组的元素。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">filter</span>(<span style="color:#a6e22e">x</span> =&gt; <span style="color:#a6e22e">x</span> <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">3</span>)) <span style="color:#75715e">// =&gt; [2, 1]; values less than 3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">filter</span>((<span style="color:#a6e22e">x</span>,<span style="color:#a6e22e">i</span>) =&gt; <span style="color:#a6e22e">i</span><span style="color:#f92672">%</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">===</span> <span style="color:#ae81ff">0</span>)) <span style="color:#75715e">// =&gt; [5, 3, 1]; every other value
</span></span></span></code></pre></div><p>需要注意的是，方法<code>filter</code>会<font color=LightSeaGreen>跳过稀疏数组中缺失的元素，它返回的数组始终是稠密的</font>。因此，可以使用<code>filter</code>方法清理掉稀疏数组中的空隙。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">dense</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">sparse</span>.<span style="color:#a6e22e">filter</span>(() =&gt; <span style="color:#66d9ef">true</span>);
</span></span></code></pre></div><p>如果既想清理稀疏数组中的空隙，又想删除值为<code>undefined</code>和<code>null</code>的元素，则可以像下面这样写：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">filter</span>(<span style="color:#a6e22e">x</span> =&gt; <span style="color:#a6e22e">x</span> <span style="color:#f92672">!==</span> <span style="color:#66d9ef">undefined</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">!==</span> <span style="color:#66d9ef">null</span>);
</span></span></code></pre></div><p>方法<code>find()</code>和<code>findIndex()</code>与<code>filter()</code>类似，它们都遍历数组，寻找断言函数返回<code>true</code>的元素。但与<code>filter()</code>不同的是，这两个方法会在断言函数找到第一个元素时就停止。<code>find()</code>返回匹配的元素，<code>findIndex()</code>返回匹配元素的索引。如果没有找到匹配的元素，则<code>find()</code>返回<code>undefinded</code>，而<code>findIndex</code>返回<code>-1</code>。</p>
<p>方法<code>every()</code>和<code>some()</code>是数组断言方法，即它们会对数组元素调用传入的断言函数，最后返回<code>true</code>或<code>false</code>。<code>every</code>方法与数学上的全称量词类似，它只在断言函数对数组的所有元素都返回<code>true</code>才返回<code>true</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>];
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">every</span>(<span style="color:#a6e22e">x</span> =&gt; <span style="color:#a6e22e">x</span> <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span>)  <span style="color:#75715e">// true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">every</span>(<span style="color:#a6e22e">x</span> =&gt; <span style="color:#a6e22e">x</span> <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">===</span> <span style="color:#ae81ff">0</span>) <span style="color:#75715e">// =&gt; false: not all values are even.
</span></span></span></code></pre></div><p>方法<code>some()</code>类似于数学上的存在量词，只要数组元素中有一个让断言函数返回<code>true</code>，它就返回<code>true</code>，但必须数组中的所有元素对断言函数都返回<code>false</code>才返回<code>false</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>];
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">some</span>(<span style="color:#a6e22e">x</span> =&gt; <span style="color:#a6e22e">x</span> <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">===</span> <span style="color:#ae81ff">0</span>) <span style="color:#75715e">// =&gt; true; a has some even numbers.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">some</span>(isNaN)  <span style="color:#75715e">// =&gt; false; a has no non-numbers.
</span></span></span></code></pre></div><p>方法<code>reduce()</code>和<code>reduceRight()</code>使用指定的函数归并数组元素，最终产生一个值。在函数式编程中，归并是一个常见操作，有时候也被称为<code>inject</code>或<code>fold</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">a1</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">reduce</span>((<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>) =&gt; <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">a2</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">reduce</span>((<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>) =&gt; <span style="color:#a6e22e">x</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">y</span>, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">a3</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">reduce</span>((<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>) =&gt; (<span style="color:#a6e22e">x</span> <span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">y</span>) <span style="color:#f92672">?</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">:</span> <span style="color:#a6e22e">y</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">a1</span>, <span style="color:#a6e22e">a2</span>, <span style="color:#a6e22e">a3</span>) <span style="color:#75715e">// 15 120 5
</span></span></span></code></pre></div><p>方法<code>reduce()</code>接收两个参数，第一个参数是执行归并操作的函数。这个归并函数的任务就是把两个值组合或归并为一个值并返回这个值。第二个参数是可选的，是传递给归并函数的初始值。</p>
<p>在<code>reduce()</code>中使用函数与<code>forEach()</code>和<code>map()</code>中使用函数不同。<font color=red>我们熟悉的值、索引和数组本身在这里作为第二、第三和第四个参数，而第一个参数是上一次归并操作的结果值</font>。在第一次调用归并方法时，第一个参数是调用<code>reduce</code>方法时传递的第二个参数，在后续的调用中，第一个参数是上一次调用的返回值。</p>
<p>如果不指定初始值，方法<code>reduce()</code>会<font color=LightSeaGreen>使用数组的第一个元素作为初始值</font>。这意味着首次调用归并函数将以数组的第一个和第二个元素作为归并函数的第一和第二个参数。</p>
<p>如果不传入初始值，在空数组上调用<code>reduce()</code>会导致<code>TypeError</code>。如果调用它时只有一个值，比如用只包含一个元素的数组调用且不传初始值，或者用空数组调用但传了初始值，则<code>reudce()</code>直接返回这个值，不会调用归并函数。</p>
<p>方法<code>reduceRight()</code>和<code>reduce()</code>类似，只不过是从高索引向低索引（从右向左）处理数组。如果归并操作具有从右向左的结合性，那就要考虑使用<code>reduceRight()</code>。</p>
<h3 id="flattening-arrays-with-flat-and-flatmap">Flattening arrays with flat() and flatMap()</h3>
<p>在ES2019中，<code>flat()</code>方法用于创建并返回一个新数组，这个新数组包含与它调用<code>flat()</code>的数组相同的元素，只不过其中任何本身也是数组元素被打平，填充到返回的数组中。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span>[<span style="color:#ae81ff">1</span>, [<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>]].<span style="color:#a6e22e">flat</span>();
</span></span><span style="display:flex;"><span>[<span style="color:#ae81ff">1</span>, [<span style="color:#ae81ff">2</span>, [<span style="color:#ae81ff">3</span>]]].<span style="color:#a6e22e">flat</span>();
</span></span></code></pre></div><p>在不传参数调用时，方法<code>flat()</code>只会打平第一级嵌套。原始数组中本身也是数组的元素会被打平，但打平后的元素如果还是数组则不会再打平。如果想打平更多层级，需要给<code>flat()</code>传一个数值参数，表示需要打平的层级：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, [<span style="color:#ae81ff">2</span>, [<span style="color:#ae81ff">3</span>, [<span style="color:#ae81ff">4</span>]]]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">flat</span>())  <span style="color:#75715e">// =&gt; [1, 2, [3, [4]]]      
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">flat</span>(<span style="color:#ae81ff">1</span>)) <span style="color:#75715e">// =&gt; [1, 2, [3, [4]]]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">flat</span>(<span style="color:#ae81ff">2</span>)) <span style="color:#75715e">// =&gt; [1, 2, 3, [4]]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">flat</span>(<span style="color:#ae81ff">3</span>)) <span style="color:#75715e">// =&gt; [1, 2, 3, 4]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">flat</span>(<span style="color:#ae81ff">4</span>)) <span style="color:#75715e">// =&gt; [1, 2, 3, 4]
</span></span></span></code></pre></div><p>方法<code>flatMap()</code>与<code>map()</code>相似，只不过返回的数组会自动被打平，就像传给了<code>flat()</code>一样。换句话说，调用<code>a.flatMap(f)</code>等同于<code>a.map(f).flat()</code>，但执行效率较高。</p>
<p>方法<code>concat()</code>创建并返回一个新数组，新数组包含调用<code>concat()</code>方法的数组的元素，以及传递给<code>concat()</code>的参数。如果这些参数中有数组，则拼接的是它们的元素而非数组本身。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">concat</span>(<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>)) <span style="color:#75715e">// [1,2,3,4,5]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">concat</span>([<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>], [<span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>])) <span style="color:#75715e">// [1,2,3,4,5,6,7]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">concat</span>(<span style="color:#ae81ff">4</span>, [<span style="color:#ae81ff">5</span>, [<span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>]])) <span style="color:#75715e">// [1,2,3,4,5, [6,7]]
</span></span></span></code></pre></div><h1 id="chapter-8">Chapter 8</h1>
<p><code>JavaScript</code>中的函数是对象，可以把函数赋值给变量，然后再传递给其它函数。因为函数是对象，所以<font color=LightSeaGreen>可以在函数上设置属性，甚至调用函数的相关方法</font>。</p>
<p>函数可以嵌套定义在其它函数里，内嵌的函数可以访问定义在函数作用域的任何变量。这意味着，函数是闭包，基于闭包可以实现重要且强大的编辑技巧。</p>
<h2 id="defining-functions">Defining Functions</h2>
<p>定义函数最直接的方式是使用<code>function</code>关键字，这个关键字既可以作为函数声明使用，也可以作为表达式使用。函数声明由<code>function</code>关键字后面跟着如下内容：</p>
<ul>
<li>命名函数的标识符。这个名字对于函数声明是必要的部分。它作为一个变量名使用，新定义的函数对象会赋值给这个变量。</li>
<li>一对圆括号，中间包含逗号分隔的零或多个标识符。这些标识符是函数的参数名，它们就像是函数体内的局部变量。</li>
<li>一对花括号，其中包含了零个或多个语句。这些语句构成函数体，将在函数被调用时执行。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">printprops</span>(<span style="color:#a6e22e">o</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">p</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">o</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">p</span><span style="color:#e6db74">}</span><span style="color:#e6db74">: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">o</span>[<span style="color:#a6e22e">p</span>]<span style="color:#e6db74">}</span><span style="color:#e6db74">\n`</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">distance</span>(<span style="color:#a6e22e">x1</span>, <span style="color:#a6e22e">y1</span>, <span style="color:#a6e22e">x2</span>, <span style="color:#a6e22e">y2</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">dx</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">x2</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">x1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">dy</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">y2</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">y1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> Math.<span style="color:#a6e22e">sqrt</span>(<span style="color:#a6e22e">dx</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">dx</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">dy</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">dy</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>关于函数声明，需要了解的重要一点是，<font color=red>函数的名称会变成一个变量，其值就是函数本身</font>。函数声明语句会被提升到包含<code>enclosing script</code>、函数或代码块的顶部。因此，可以在函数定义之前出现的代码中调用以这种方式定义的函数。另一种说法是，代码块中声明的所有函数都将在整个代码块中定义，而且这些函数将在解释器开始执行该代码块中的任何代码之前定义。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">dis</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">distance</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">dis</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">distance</span>(<span style="color:#a6e22e">x1</span>, <span style="color:#a6e22e">y1</span>, <span style="color:#a6e22e">x2</span>, <span style="color:#a6e22e">y2</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">dx</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">x2</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">x1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">dy</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">y2</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">y1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> Math.<span style="color:#a6e22e">sqrt</span>(<span style="color:#a6e22e">dx</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">dx</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">dy</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">dy</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行的结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">2.8284271247461903</span>
</span></span></code></pre></div><p>语句<code>return</code>导致函数停止并将其表达式的值返回给调用者。如果<code>return</code>语句没有关联的表达式，则函数返回<code>undefined</code>。如果函数并不包含<code>return</code>语句，那么就简单地执行函数体内每个语句，直到最后返回<code>undefined</code>。</p>
<h3 id="function-expressions">Function Expressions</h3>
<p>函数表达式看起来像函数声明，但它们出现在复杂表达式或语句的上下文中，<font color=red>而且表达式中的函数名是可选的</font>，以下是几个函数表达式的示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">square</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">x</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">x</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 函数名是可选的，包含函数名对于递归十分有用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">f</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">fact</span>(<span style="color:#a6e22e">x</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">x</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>; <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">fact</span>(<span style="color:#a6e22e">x</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Function expressions can also be used as arguments to other functions: 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>[<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>].<span style="color:#a6e22e">sort</span>(<span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">b</span>;
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Function expressions are sometimes defined and immediately invoked
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">tensquared</span> <span style="color:#f92672">=</span> (<span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">x</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">x</span>;
</span></span><span style="display:flex;"><span>}(<span style="color:#ae81ff">10</span>));
</span></span></code></pre></div><p>需要注意的是，<font color=red>函数名对于定义为表达式的函数而言是可选</font>，多数情况下函数表达式省略函数名。函数声明实际上是声明一个变量，然后把函数对象赋值给它。而函数表达式不会声明变量，至于要把新定义的函数赋值给一个常量还是变量取决于我们，最佳实践是使用<code>const</code>把函数表达式赋值给常量，这样就不会因赋值而意外覆盖函数。</p>
<p>函数是允许有名字的，像<code>factorial</code>函数，需要引用自己。如果一个函数表达式包含名字，则该函数的本地函数作用域将包含该名称与函数对象的绑定。实际上，函数名变成了函数中的一个局部变量。大多数定义为表达式的函数都不需要名称，这使得它们的定义更加紧凑。</p>
<p>这对于在函数中使用函数声明定义一个函数<code>f()</code>与定义一个表达式，然后赋值给变量<code>f</code>。当使用声明的形式，函数对象会在包含它们的代码开始运行之前创建，定义会被悬挂起来，这样就可以在定义语句上方的代码中调用这些函数。</p>
<p>但是，定义为表达式的函数并非如此：这些函数在定义它们的表达式实际求值之前并不存在。此外，要调用一个函数，必须能够引用该函数，而以表达式定义的函数在赋值给变量之前是无法引用的，<font color=red>因此用表达式定义的函数在定义之前是无法调用的</font>。</p>
<h3 id="arrow-functions">Arrow Functions</h3>
<p>在ES6中，可以使用一种特别简洁的语法来定义函数，叫做箭头函数。因为<font color=LightSeaGreen>箭头函数是表达式而不是语句</font>，所以不必使用<code>function</code>关键字，而且也不需要函数名。</p>
<p>箭头函数的一般形式是圆括号中逗号分隔的参数列表，后面跟箭头<code>=&gt;</code>，再跟包含在花括号中的函数体：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">sum</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>) =&gt; { <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span>; };
</span></span></code></pre></div><p>如果函数体只有一个<code>return</code>语句，那么可以省略<code>return</code>语句、语句末尾的分号以及花括号，将函数体写成一个表达式，这个表达式的值将被返回：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">sum</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>) =&gt; <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span>;
</span></span></code></pre></div><p>更进一步，如果箭头函数只有一个参数，也可以省略包含参数列表的圆括号：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">polynomial</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">x</span> =&gt; <span style="color:#a6e22e">x</span><span style="color:#f92672">*</span><span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">*</span><span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">3</span>;
</span></span></code></pre></div><p>需要注意的是，对于<font color=LightSeaGreen>没有参数的箭头函数必须把空圆括号写出来</font>。还要注意的是，在写箭头函数时，不能在函数参数和箭头之间放置换行符。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">constantFunc</span> <span style="color:#f92672">=</span> () =&gt; <span style="color:#ae81ff">42</span>;
</span></span></code></pre></div><p>如果箭头函数的函数体是一个<code>return</code>语句，但要返回的表达式是对象字面量，则<font color=LightSeaGreen>必须把这个对象字面量放在一对圆括号中</font>，以避免解释器分不清花括号到底表示函数体还是对象字面量。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">f</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">x</span> =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> {<span style="color:#a6e22e">value</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">x</span>};  <span style="color:#75715e">// Good: f() returns an object
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">g</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">x</span> =&gt; ({<span style="color:#a6e22e">value</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">x</span>});  <span style="color:#75715e">// Good: g() returns an object
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">h</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">x</span> =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">value</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">x</span>    <span style="color:#75715e">// Bad: h() returns nothing
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">x</span> =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">v</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">w</span><span style="color:#f92672">:</span><span style="color:#a6e22e">x</span>    <span style="color:#75715e">// Bad: Syntax Error
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span></code></pre></div><p>箭头函数与以其他方式定义的函数有一个关键区别：它们从定义自己的环境继承<code>this</code>关键字的值，而不是像以其他方式定义的函数那样定义自己的调用上下文。箭头函数与其他函数还有一个区别，就是它们没有<code>prototype</code>属性，这意味着箭头函数不能作为新类的构造函数。</p>
<p>在ES2020中，可以在函数表达式后面、左圆括号前面插入<code>?.</code>，从而只在函数不是<code>null</code>和<code>undefined</code>时调用函数。也就是说<code>f?.(x)</code>相当于下面语句：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span>(<span style="color:#a6e22e">f</span> <span style="color:#f92672">!==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">f</span> <span style="color:#f92672">!==</span> <span style="color:#66d9ef">undefined</span>) <span style="color:#f92672">?</span> <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">x</span>) <span style="color:#f92672">:</span> <span style="color:#66d9ef">undefined</span>
</span></span></code></pre></div><h3 id="nested-functions">Nested Functions</h3>
<p>在JavaScript中，函数可以内嵌到其他函数中：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">hypotenuse</span>(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">square</span>(<span style="color:#a6e22e">x</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">x</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> Math.<span style="color:#a6e22e">sqrt</span>(<span style="color:#a6e22e">square</span>(<span style="color:#a6e22e">a</span>) <span style="color:#f92672">+</span> <span style="color:#a6e22e">square</span>(<span style="color:#a6e22e">b</span>));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">hypotenuse</span>(<span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">14</span>))
</span></span></code></pre></div><p>嵌套函数的有趣之处在于其变量作用域规则：它们可以访问被嵌套函数（或多个函数）的参数和变量。例如，在上面的代码，内层函数<code>square()</code>可以读写外层函数<code>hypotenuse()</code>定义的参数<code>a</code>和<code>b</code>。嵌套函数的这些作用域规则非常重要。</p>
<h2 id="invoking-functions">Invoking Functions</h2>
<p>构成函数主体的代码不是在定义函数时执行的，而是在调用函数时执行的，函数有五种调用方式：</p>
<ul>
<li>作为函数</li>
<li>作为方法</li>
<li>作为构造器</li>
<li>通过<code>call()</code>和<code>apply()</code>方法间接调用</li>
<li>通过语言特性，隐含地实现了与普通函数调用不同的功能</li>
</ul>
<h3 id="function-invocation">Function Invocation</h3>
<p>函数可以作为函数调用，也可以通过调用表达式作为方法调用。调用表达式由一个求值为函数对象的表达式、一个左圆括号、一个以逗号分隔的零个或多个参数表达式列表和一个右圆括号组成。如果函数表达式是属性访问表达式，即函数是对象的属性或数组的元素，那么它就是方法调用表达式。下面是常规的函数表达式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">printprops</span>({<span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>});
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">probability</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">factorial</span>(<span style="color:#ae81ff">5</span>) <span style="color:#f92672">/</span> <span style="color:#a6e22e">factorial</span>(<span style="color:#ae81ff">13</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">total</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">distance</span>(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> <span style="color:#a6e22e">distance</span>(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>);
</span></span></code></pre></div><p>在调用过程中，每个参数表达式（括号之间的表达式）都会被求值，求值结果将成为函数的参数。这些值被赋值给函数定义中命名的参数。在函数体中，对参数的引用将求值为相应的参数值。</p>
<p>对于常规函数调用，函数的返回值就是调用表达式的值。如果函数返回是因为解释器到了终点，那么返回值是<code>undefined</code>。如果函数返回是因为解释器执行了返回语句，那么返回值就是返回语句后面的表达式的值，如果返回语句没有值，那么返回值就是<code>undefined</code>。</p>
<p>在非严格模式下调用函数时，调用上下文（<code>this</code>的值）是全局对象。而在严格模式下，调用上下文是<code>undefined</code>。需要注意的是，使用箭头语法定义的函数有不同的行为：它们总是继承定义时有效的<code>this</code>值。</p>
<p>作为函数（而不是方法）调用的函数通常不使用<code>this</code>关键字。不过，该关键字可用于确定严格模式是否生效：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">strict</span> <span style="color:#f92672">=</span> (<span style="color:#66d9ef">function</span>() { <span style="color:#66d9ef">return</span> <span style="color:#f92672">!</span><span style="color:#66d9ef">this</span>; }());
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">strict</span>) <span style="color:#75715e">// false
</span></span></span></code></pre></div><p>递归函数是一种可以调用自身的函数，如<code>factorial()</code>函数。某些算法，例如涉及树形数据结构的算法，可以用递归函数来实现，而且特别优雅。不过，在编写递归函数时，必须考虑内存限制。当函数<code>A</code>调用函数<code>B</code>，然后函数<code>B</code>又调用函数<code>C</code>时，解释器需要跟踪这三个函数的执行上下文。当函数<code>C</code>执行完毕时，解释器需要知道在哪里继续执行函数<code>B</code>，而当函数<code>B</code>执行完毕时，解释器需要知道在哪里继续执行函数<code>A</code>。</p>
<p>当一个函数调用另一个函数时，一个新的执行上下文就会被推入堆栈。当该函数返回时，其执行上下文对象会从堆栈中弹出。如果一个函数递归调用自身<code>100</code>次，那么栈中就会推入<code>100</code>个对象，然后再从栈中取出这<code>100</code>个对象。这个调用栈需要占用内存。在现代硬件上，编写数百次自我调用的递归函数通常是没有问题的。但如果一个函数自我调用了上万次，就很可能会出现<code>Maximum call-stack size exceeded</code>这样的错误。</p>
<h3 id="method-invocation">Method Invocation</h3>
<p>方法只不过是存储在对象中的函数。如果有一个函数<code>f</code>和一个对象<code>o</code>，就可以使用下面一行定义一个名为<code>m</code>的方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">m</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">f</span>;
</span></span></code></pre></div><p>在定义了对象<code>o</code>的方法<code>m</code> 后，可以像下面这样调用它：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">m</span>();
</span></span></code></pre></div><p>如果方法<code>m</code>期望两个参数，则可以按下面这样调用方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">m</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>);
</span></span></code></pre></div><p>上面函数表达式本身就是一个属性访问表达式，这意味着函数是作为方法而不是普通函数被调用的。方法调用的参数和返回值的处理与普通函数调用完全相同。</p>
<p>方法调用与函数调用有一个重要区别：调用上下文。属性访问表达式由两部分组成：对象和属性名称。在这样的方法调用表达式中，对象<code>o</code>成为调用上下文，函数体可以使用关键字<code>this</code>来引用该对象。下面是一个具体示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">// An object literal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">calculator</span> <span style="color:#f92672">=</span> { 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">operand1</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">operand2</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">add</span>() { <span style="color:#75715e">// We&#39;re using method shorthand syntax for this function
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// Note the use of the this keyword to refer to the containing object.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">result</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">operand1</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">operand2</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">calculator</span>.<span style="color:#a6e22e">add</span>(); <span style="color:#75715e">// A method invocation to compute 1+1.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">calculator</span>.<span style="color:#a6e22e">result</span>) <span style="color:#75715e">// =&gt; 2
</span></span></span></code></pre></div><p>大多数方法调用是使用点号进行属性访问，但使用方括号的属性访问表达式也可以执行方法调用。例如，以下两种情况都是方法调用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">o</span>[<span style="color:#e6db74">&#34;m&#34;</span>](<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>); <span style="color:#75715e">// Another way to write o.m(x,y).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">0</span>](<span style="color:#a6e22e">z</span>) <span style="color:#75715e">// Also a method invocation (assuming a[0] is a function).
</span></span></span></code></pre></div><p>方法调用可能涉及更复杂的属性访问表达式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">customer</span>.<span style="color:#a6e22e">surname</span>.<span style="color:#a6e22e">toUpperCase</span>(); <span style="color:#75715e">// Invoke method on customer.surname 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">f</span>().<span style="color:#a6e22e">m</span>(); <span style="color:#75715e">// Invoke method m() on return value of f()
</span></span></span></code></pre></div><p>方法和<code>this</code>关键字是面向对象编程范式的核心。<font color=red>任何作为方法使用的函数实际上都传递了一个隐式参数—调用它的对象</font>。一般情况下，方法会对该对象执行某种操作，而方法调用语法是表达函数对该对象进行操作这一事实的优雅方式。比较下面两行:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">rect</span>.<span style="color:#a6e22e">setSize</span>(<span style="color:#a6e22e">width</span>, <span style="color:#a6e22e">height</span>); 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">setRectSize</span>(<span style="color:#a6e22e">rect</span>, <span style="color:#a6e22e">width</span>, <span style="color:#a6e22e">height</span>);
</span></span></code></pre></div><p>上面这两行代码中调用的假定函数可能对（假定）对象<code>rect</code>执行完全相同的操作，但第一行中的方法调用语法更清楚地表明，操作的主要焦点是对象<code>rect</code>。</p>
<p>需要注意的是<code>this</code>是一个关键字，不是变量或属性名，不允许赋值给<code>this</code>。关键字<code>this</code>不像变量那样有作用域，除了箭头函数外，嵌套函数不会继承包含函数的<code>this</code>值。</p>
<p>如果嵌套函数作为方法被调用，其<code>this</code>值就是被调用的对象。如果嵌套函数（不是箭头函数）作为函数调用，那么它的<code>this</code>值要么是全局对象（非严格模式），要么是<code>undefined</code>（严格模式）。</p>
<p>一个常见的错误是，认为在方法中定义并作为函数调用的嵌套函数可以使用此值获取方法的调用上下文。下面的代码演示了这个问题：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">o</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">m</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">function</span> () {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">self</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">this</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">o</span>) <span style="color:#75715e">// true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">f</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">f</span>() {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">this</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">o</span>) <span style="color:#75715e">// false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">self</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">o</span>) <span style="color:#75715e">// true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">m</span>();
</span></span></code></pre></div><p>上面代码中，内嵌了函数<code>f()</code>，关键词<code>this</code>不等于对象<code>o</code>。这被普遍认为是<code>JavaScript</code>语言中的一个缺陷，因此必须加以注意。上面代码演示了一种常见的变通方法。在方法<code>m</code>中，我们将<code>this</code>值赋值给变量<code>self</code>，而在嵌套函数<code>f</code>中，可以使用<code>self</code>代替<code>this</code>来引用包含的对象。</p>
<p>在ES6及以后，解决这一问题的另一种方法是将嵌套函数<code>f</code>转换为箭头函数，这样就能正确地继承this值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">f</span> <span style="color:#f92672">=</span> () =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">this</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">o</span>) <span style="color:#75715e">// true, since arrow functions inherit this
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span></code></pre></div><p>定义为表达式而非语句的函数不会被悬挂，因此为了使上面代码正常运行，需要将<code>f</code>的函数定义移到前面一些，使其在被调用之前出现。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">o</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">m</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">function</span> () {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 函数表达式需要在调用之前定义
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">f</span> <span style="color:#f92672">=</span> () =&gt; {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">this</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">o</span>) <span style="color:#75715e">// true, since arrow functions inherit this
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        };
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">this</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">o</span>) <span style="color:#75715e">// true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">f</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">m</span>();
</span></span></code></pre></div><p>另一种解决方法是调用嵌套函数的<code>bind()</code> 方法来定义一个新函数，该函数会在指定对象上隐式调用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">o</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">m</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">function</span> () {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">this</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">o</span>) <span style="color:#75715e">// true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">f</span> <span style="color:#f92672">=</span> (<span style="color:#66d9ef">function</span> () {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">this</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">o</span>) <span style="color:#75715e">// true, since arrow functions inherit this
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }).<span style="color:#a6e22e">bind</span>(<span style="color:#66d9ef">this</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">f</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">m</span>();
</span></span></code></pre></div><h3 id="constructor-invocation">Constructor Invocation</h3>
<p>如果函数或方法调用之前有关键字<code>new</code>，那么它就是构造函数调用。<font color=LightSeaGreen>构造函数调用在处理参数、调用上下文和返回值方面与普通函数和方法调用不同</font>。</p>
<p>如果构造函数调用的时候包含了参数列表，那么这些参数表达式将以与函数和方法调用相同的方式进行求值并传递给函数。可以在构造函数调用中省略一对空括号，但这种做法并不常见，下面两行代码是等价的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">o</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Object(); 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">o</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Object;
</span></span></code></pre></div><p>构造函数调用会创造一个空的对象，该对象继承自构造函数的<code>prototype</code>属性所指定的对象。构造函数的目的是初始化对象，这个新创建的对象被用作调用上下文，因此构造函数可以使用<code>this</code>关键字来引用它。</p>
<p>需要注意的是，即使构造函数的调用看起来像方法调用，新对象也会被用作调用上下文。也就是说，在表达式<code>new o.m()</code>中，<code>o</code>并未被用作调用上下文。</p>
<p>构造函数通常不使用返回关键字，它们通常会初始化新对象，然后在构造函数体结束时隐式返回。在这种情况下，新对象就是构造函数调用表达式的值。</p>
<p>如果构造函数显式地使用<code>return</code>语句返回对象，那么该对象就会成为调用表达式的值。如果构造函数在使用<code>return</code>时没有返回值，<font color=red>或者返回的是一个基础值，那么返回值将被忽略</font>，新对象将作为调用表达式的值。</p>
<h3 id="indirect-invocation">Indirect Invocation</h3>
<p>函数是对象，如同所有其他所有对象一样，它也有方法。其中的两个方法<code>call()</code> 和<code>apply()</code>可以间接调用函数。这两种方法都允许明确指定调用的<code>this</code>值，这意味着<font color=red>可以将任何函数作为任何对象的方法来调用，即使它实际上不是该对象的方法</font>。这两种方法还允许调用时指定参数。<code>call()</code>方法使用自己的参数列表作为函数的参数，而<code>apply()</code>方法则希望使用一个值数组作为参数。</p>
<h3 id="implicit-function-invocation">Implicit Function Invocation</h3>
<p><code>JavaScript</code>语言有多种功能看起来不像函数调用，但却会导致函数被调用。在编写可能被隐式调用的函数时要格外小心，与普通函数相比，这些函数中的错误、副作用和性能问题更难诊断和修复。</p>
<p>可能导致隐式函数调用包括：</p>
<ul>
<li>如果一个对象定义了<code>get</code>和<code>set</code>方法，那么查询和设置属性的值的时候会激活这些方法。</li>
<li>在字符串上下文中使用对象时（如与字符串连接时），会调用对象的<code>toString()</code>方法。同样，在数字上下文中使用对象时，也会调用其<code>valueOf()</code> 方法。</li>
<li>在循环遍历可迭代对象的元素时，会发生一些方法调用。</li>
<li>带<code>tag</code>的模板字面意义是一种变相的函数调用。</li>
<li>代理对象的行为完全由函数控制，对这些对象的任何操作都会调用一个函数。</li>
</ul>
<h2 id="function-arguments-and-parameters">Function Arguments and Parameters</h2>
<p>函数定义没有指定函数参数的预期类型，<font color=LightSeaGreen>函数调用也不会对传递的参数值进行任何类型检查</font>。事实上，函数调用甚至不会检查传递的参数个数。</p>
<p>下面的小节将介绍在调用函数时，如果传递的参数少于声明的参数，或者传递的参数多于声明的参数，会发生什么情况。还会演示了如果需要确保函数不被调用不适当的参数，如何显式地测试函数参数的类型。</p>
<h3 id="optional-parameters-and-defaults">Optional Parameters and Defaults</h3>
<p>当调用函数的参数少于声明的参数时，附加参数将被设置为默认值，通常是<code>undefined</code>。在编写函数时，将某些参数设置为可选参数通常很有用。下面是一个例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getPropertyNames</span>(<span style="color:#a6e22e">o</span>, <span style="color:#a6e22e">a</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">a</span> <span style="color:#f92672">===</span> <span style="color:#66d9ef">undefined</span>) <span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> []; <span style="color:#75715e">// If undefined, use a new array
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">property</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">o</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">push</span>(<span style="color:#a6e22e">property</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">a</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// getPropertyNames() can be invoked with one or two arguments:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">o</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>}, <span style="color:#a6e22e">p</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">y</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">2</span>, <span style="color:#a6e22e">z</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">3</span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">getPropertyNames</span>(<span style="color:#a6e22e">o</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">getPropertyNames</span>(<span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">a</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">a</span>) <span style="color:#75715e">// [ &#39;x&#39;, &#39;y&#39;, &#39;z&#39; ]
</span></span></span></code></pre></div><p>在上面函数的第一行中，可以使用<code>||</code>操作符，而不是使用<code>if</code>语句：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">||</span> [];
</span></span></code></pre></div><p>运算符<code>||</code>在第一个参数为<code>true</code>时返回该参数，否则返回第二个参数。在这种情况下，如果传递了任何对象作为第二个参数，函数将使用该对象。但如果省略了第二个参数（或传递了空值或其他<code>falsy</code>值），则将使用一个新创建的空数组。</p>
<p>需要注意的是，在设计带有可选参数的函数时，<font color=LightSeaGreen>应确保将可选参数放在参数列表的末尾</font>，以便可以省略它们。调用时不能省略第一个参数而传递第二个参数：必须明确传递<code>undefined</code>作为第一个参数。</p>
<p>在ES6及更高版本中，可以直接在函数的参数列表中为每个函数参数定义默认值。只需在参数名称后面加上等号和默认值，即可在没有参数时使用该参数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">// Append the names of the enumerable properties of object o to the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// array a, and return a. If a is omitted, create and return a new array.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getPropertyNames</span>(<span style="color:#a6e22e">o</span>, <span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> []) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">property</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">o</span>) <span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">push</span>(<span style="color:#a6e22e">property</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">a</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>参数缺省表达式<font color=red>在调用函数时求值，而不是在定义函数时求值</font>，因此每次调用只传入一个参数的<code>getPropertyNames()</code>函数时，都会创建并传递一个新的空数组。</p>
<p>如果参数缺省值是常量（或字面表达式，如<code>[]</code>和<code>{}</code>），可能最容易对函数进行推理。但这并不是必需的，可以使用变量或函数调用来计算参数的默认值。一个有趣的例子是，对于有多个参数的函数，可以使用前一个参数的值来定义后面参数的默认值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">rectangle</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">width</span>, <span style="color:#a6e22e">height</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">width</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>) =&gt; ({<span style="color:#a6e22e">width</span>, <span style="color:#a6e22e">height</span>});
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">rectangle</span>(<span style="color:#ae81ff">1</span>)
</span></span></code></pre></div><h3 id="rest-parameters-and-variable-length-argument-lists">Rest Parameters and Variable-Length Argument Lists</h3>
<p>使用参数缺省值，可以使用比定义时更少的参数调用的函数。而可变参数恰恰相反：它们允许编写可以使用任意参数的函数。下面是一个函数示例，它期望使用一个或多个数字参数，并返回最大的参数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">max</span>(<span style="color:#a6e22e">first</span> <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#66d9ef">Infinity</span>, ...<span style="color:#a6e22e">rest</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">maxValue</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">first</span>; <span style="color:#75715e">// Start by assuming the first arg is biggest
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// Then loop through the rest of the arguments, looking for bigger
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">n</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">rest</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">n</span> <span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">maxValue</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">maxValue</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">n</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Return the biggest
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">maxValue</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">max</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">1000</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>))
</span></span></code></pre></div><p>声明可变参数时，可变参数必须是最后一个参数。当调用一个有可变参数的函数时，会先将实参先赋值给非可变参数，然后将其余实参存储到数组中。最后一点很重要：在函数体中，其余参数的值始终是一个数组。数组可能是空的，但其余参数永远不会是<code>undefined</code>。</p>
<h3 id="the-arguments-object">The Arguments Object</h3>
<p>可变参数是ES6引入的，在此之前，<code>varargs</code>函数是使用<code>Arguments</code>对象编写的：在任何函数体中，标识符 <code>arguments</code>都是指该调用的<code>Arguments</code>对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">max</span>(<span style="color:#a6e22e">x</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">maxValue</span> <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#66d9ef">Infinity</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Loop through the arguments, looking for, and remembering, the biggest.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">arguments</span>.<span style="color:#a6e22e">length</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">arguments</span>[<span style="color:#a6e22e">i</span>] <span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">maxValue</span>) <span style="color:#a6e22e">maxValue</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">arguments</span>[<span style="color:#a6e22e">i</span>];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Return the biggest
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">maxValue</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">max</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">1000</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>))
</span></span></code></pre></div><h3 id="the-spread-operator-for-function-calls">The Spread Operator for Function Calls</h3>
<p>展开操作符<code>...</code>用于将数组（或任何其它可迭代对象，如字符串）中的元素拆开或展开。我们已经看到了数组字面量中的展开操作符。在函数调用中也可以以同样的方式使用该操作符：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">numbers</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">10</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>Math.<span style="color:#a6e22e">min</span>(...<span style="color:#a6e22e">numbers</span>)<span style="color:#75715e">// =&gt; -1
</span></span></span></code></pre></div><p>需要注意的是，<code>...</code>不是真正的操作符，它无法求值。相反，它是一种特殊的<code>JavaScript</code>语法，可用于数组字面量和函数调用。</p>
<h3 id="destructuring-function-arguments-into-parameters">Destructuring Function Arguments into Parameters</h3>

    </div>
    <footer class="post-footer">
        
 
<div class="post-tags">     
     
    <a href="https://iihui.github.io/tags/js" rel="tag" title="js">#js#</a>
    
</div>



        <div class="post-nav">
    <div class="post-nav-next post-nav-item">
    
        <a href="https://iihui.github.io/post/js-this/" rel="next" title="javascript中this指针">
        <i class="fa fa-chevron-left"></i> javascript中this指针
        </a>
    
    </div>

    <div class="post-nav-prev post-nav-item">
    
        <a href="https://iihui.github.io/post/ios-kvo/" rel="prev" title="KVO 介绍">
        KVO 介绍 <i class="fa fa-chevron-right"></i>
        </a>
    
    </div>
</div>
      
        <div class="post-nav">
    <div style="border: 1px dashed #e0e0e0; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
        <div style="float:left;margin-top:0px;">
            <img src="https://i.loli.net/2020/02/09/SvhUdz4XJsOr9Vk.jpg" width="128px" height="128px"/>
            <div style="text-align:center;">谢谢支持!</div>
        </div>
        <div>
            <p style="margin-top:10px;">
                标题：selection 对象
                <br />作者：阿呆<a target="_blank" href="https://iihui.github.io/"></a>
                
                <br />地址：https://iihui.github.io/post/js-selection/
                <br />声明：自由转载-非商用-保持署名（创作共享4.0许可证）
            </p>
        </div>
    </div>
    <div class="clear"></div>
</div>
        
        
        




    </footer>
  </article>
</section>

          </div>
        </div>
        <div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>
<aside id="sidebar" class="sidebar">
  <div class="sidebar-inner">

  <ul class="sidebar-nav motion-element">
    <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
      文章目录
    </li>
    <li class="sidebar-nav-overview" data-target="site-overview">
      站点概览
    </li>
  </ul>

    <section class="site-overview sidebar-panel ">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
        src="https://i.loli.net/2020/02/07/dVFzrvZkHRNq2lL.jpg"
        alt="" />
    <p class="site-author-name" itemprop="name"></p>
    <p class="site-description motion-element" itemprop="description"> 
        coder &amp; cook</p>
</div>
      <nav class="site-state motion-element">
    <div class="site-state-item site-state-posts">
      <a href="https://iihui.github.io/post/">
        <span class="site-state-item-count">140</span>
        <span class="site-state-item-name">日志</span>
      </a>
    </div>
    <div class="site-state-item site-state-categories">    
        <a href="https://iihui.github.io/categories/">      
         
        <span class="site-state-item-count">18</span>
        
        <span class="site-state-item-name">分类</span>
        
        </a>
    </div>

    <div class="site-state-item site-state-tags">
        <a href="https://iihui.github.io/tags/">
         
        <span class="site-state-item-count">29</span>
        
        <span class="site-state-item-name">标签</span>
        </a>
    </div>
</nav>
      
      
<div class="links-of-author motion-element">
    
        <span class="links-of-author-item">
        <a href="https://coolshell.cn" target="_blank" title="皓 大">
            <i class="fa fa-fw fa-globe"></i>
            皓 大
        </a>
        </span>
    
        <span class="links-of-author-item">
        <a href="http://www.ruanyifeng.com" target="_blank" title="阮 大">
            <i class="fa fa-fw fa-globe"></i>
            阮 大
        </a>
        </span>
    
        <span class="links-of-author-item">
        <a href="https://juejin.im/" target="_blank" title="掘 金">
            <i class="fa fa-fw fa-globe"></i>
            掘 金
        </a>
        </span>
    
</div>


      

      <div class="links-of-blogroll motion-element inline">
<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=&amp;m=0&amp;s=220&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;bv=35" async="async"></script>
</div>

    </section>
    
<section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
    <div class="post-toc">
        <div class="post-toc-content"><nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#selection">selection</a></li>
        <li><a href="#range对象">range对象</a></li>
        <li><a href="#range常用方法">range常用方法</a></li>
      </ul>
    </li>
    <li><a href="#chapter-1">Chapter 1</a></li>
    <li><a href="#chapter-2">Chapter 2</a></li>
    <li><a href="#chapter-3">Chapter 3</a>
      <ul>
        <li><a href="#number">Number</a>
          <ul>
            <li><a href="#binary-floating-point-and-rounding-errors">Binary Floating-Point and Rounding Errors</a></li>
            <li><a href="#arbitrary-precision-integers-with-bigint">Arbitrary Precision Integers with BigInt</a></li>
          </ul>
        </li>
        <li><a href="#text">Text</a>
          <ul>
            <li><a href="#string-literals">String Literals</a></li>
            <li><a href="#template-literals">Template Literals</a></li>
            <li><a href="#pattern-matching">Pattern Matching</a></li>
          </ul>
        </li>
        <li><a href="#boolean-values">Boolean Values</a></li>
        <li><a href="#null-and-undefined">null and undefined</a></li>
        <li><a href="#symbols">Symbols</a></li>
        <li><a href="#the-global-object">The Global Object</a></li>
        <li><a href="#immutable-primitive-values-and-mutable-object-references">Immutable Primitive Values and Mutable Object References</a></li>
        <li><a href="#type-conversions">Type Conversions</a>
          <ul>
            <li><a href="#conversions-and-equality">Conversions and Equality</a></li>
            <li><a href="#explicit-conversions">Explicit Conversions</a></li>
            <li><a href="#object-to-primitive-conversions">Object to Primitive Conversions</a></li>
          </ul>
        </li>
        <li><a href="#variable-declaration-and-assignment">Variable Declaration and Assignment</a>
          <ul>
            <li><a href="#declarations-with-let-and-const">Declarations with let and const</a></li>
            <li><a href="#variable-declarations-with-var">Variable Declarations with var</a></li>
            <li><a href="#destructuring-assignment">Destructuring Assignment</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#chapter-4">Chapter 4</a>
      <ul>
        <li><a href="#primary-expressions">Primary Expressions</a></li>
        <li><a href="#object-and-array-initializers">Object and Array Initializers</a></li>
        <li><a href="#property-access-expressions">Property Access Expressions</a></li>
        <li><a href="#operator-overview">Operator Overview</a></li>
      </ul>
    </li>
    <li><a href="#chapter-5">Chapter 5</a>
      <ul>
        <li><a href="#forof">for/of</a></li>
        <li><a href="#forin">for/in</a></li>
      </ul>
    </li>
    <li><a href="#chapter-6">Chapter 6</a>
      <ul>
        <li><a href="#creating-objects">Creating Objects</a>
          <ul>
            <li><a href="#creating-objects-with-new">Creating Objects with new</a></li>
            <li><a href="#prototypes">Prototypes</a></li>
            <li><a href="#objectcreate">Object.create()</a></li>
          </ul>
        </li>
        <li><a href="#querying-and-setting-properties">Querying and Setting Properties</a>
          <ul>
            <li><a href="#objects-as-associative-arrays">Objects As Associative Arrays</a></li>
            <li><a href="#inheritance">Inheritance</a></li>
            <li><a href="#property-access-errors">Property Access Errors</a></li>
          </ul>
        </li>
        <li><a href="#deleting-properties">Deleting Properties</a></li>
        <li><a href="#testing-properties">Testing Properties</a></li>
        <li><a href="#enumerating-properties">Enumerating Properties</a>
          <ul>
            <li><a href="#property-enumeration-order">Property Enumeration Order</a></li>
          </ul>
        </li>
        <li><a href="#extending-objects">Extending Objects</a></li>
        <li><a href="#serializing-objects">Serializing Objects</a></li>
        <li><a href="#object-methods">Object Methods</a>
          <ul>
            <li><a href="#the-tostring-method">The toString() Method</a></li>
            <li><a href="#the-valueof-method">The valueOf() Method</a></li>
            <li><a href="#the-tojson-method">The toJSON() Method</a></li>
          </ul>
        </li>
        <li><a href="#extended-object-literal-syntax">Extended Object Literal Syntax</a>
          <ul>
            <li><a href="#computed-property-names">Computed Property Names</a></li>
            <li><a href="#symbols-as-property-names">Symbols as Property Names</a></li>
          </ul>
        </li>
        <li><a href="#spread-operator">Spread Operator</a></li>
        <li><a href="#shorthand-methods">Shorthand Methods</a></li>
        <li><a href="#property-getters-and-setters">Property Getters and Setters</a></li>
      </ul>
    </li>
    <li><a href="#chapter-7">Chapter 7</a>
      <ul>
        <li><a href="#creating-arrays">Creating Arrays</a>
          <ul>
            <li><a href="#array-literals">Array Literals</a>
              <ul>
                <li><a href="#the-spread-operator">The Spread Operator</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#the-array-constructor">The Array() Constructor</a>
          <ul>
            <li><a href="#arrayof">Array.of()</a></li>
            <li><a href="#arrayfrom">Array.from()</a></li>
          </ul>
        </li>
        <li><a href="#reading-and-writing-array-elements">Reading and Writing Array Elements</a></li>
        <li><a href="#sparse-arrays">Sparse Arrays</a></li>
        <li><a href="#array-length">Array Length</a></li>
        <li><a href="#adding-and-deleting-array-elements">Adding and Deleting Array Elements</a></li>
        <li><a href="#iterating-arrays">Iterating Arrays</a></li>
        <li><a href="#multidimensional-arrays">Multidimensional Arrays</a></li>
        <li><a href="#array-methods">Array Methods</a>
          <ul>
            <li><a href="#array-iterator-methods">Array Iterator Methods</a></li>
            <li><a href="#flattening-arrays-with-flat-and-flatmap">Flattening arrays with flat() and flatMap()</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#chapter-8">Chapter 8</a>
      <ul>
        <li><a href="#defining-functions">Defining Functions</a>
          <ul>
            <li><a href="#function-expressions">Function Expressions</a></li>
            <li><a href="#arrow-functions">Arrow Functions</a></li>
            <li><a href="#nested-functions">Nested Functions</a></li>
          </ul>
        </li>
        <li><a href="#invoking-functions">Invoking Functions</a>
          <ul>
            <li><a href="#function-invocation">Function Invocation</a></li>
            <li><a href="#method-invocation">Method Invocation</a></li>
            <li><a href="#constructor-invocation">Constructor Invocation</a></li>
            <li><a href="#indirect-invocation">Indirect Invocation</a></li>
            <li><a href="#implicit-function-invocation">Implicit Function Invocation</a></li>
          </ul>
        </li>
        <li><a href="#function-arguments-and-parameters">Function Arguments and Parameters</a>
          <ul>
            <li><a href="#optional-parameters-and-defaults">Optional Parameters and Defaults</a></li>
            <li><a href="#rest-parameters-and-variable-length-argument-lists">Rest Parameters and Variable-Length Argument Lists</a></li>
            <li><a href="#the-arguments-object">The Arguments Object</a></li>
            <li><a href="#the-spread-operator-for-function-calls">The Spread Operator for Function Calls</a></li>
            <li><a href="#destructuring-function-arguments-into-parameters">Destructuring Function Arguments into Parameters</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav></div>
    </div>
</section>

  </div>
</aside>

      </div>
    </main>
   
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  <span itemprop="copyrightYear">  &copy; 
  2017 - 2024</span>
  <span class="with-love"><i class="fa fa-heart"></i></span>
  <span class="author" itemprop="copyrightHolder">Keep It Simple</span>
</div>




      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      <span id="scrollpercent"><span>0</span>%</span>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/jquery/index.js?v=2.1.3"></script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script> 
<script type="text/javascript" src="https://iihui.github.io/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/velocity/velocity.min.js?v=1.2.1"></script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="https://iihui.github.io/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>

<script src="https://iihui.github.io/js/vendor/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>

<script type="text/javascript" src="https://iihui.github.io/js/utils.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/motion.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/affix.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/schemes/pisces.js"></script>

<script type="text/javascript" src="https://iihui.github.io/js/scrollspy.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/post-details.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/toc.js"></script>

<script type="text/javascript" src="https://iihui.github.io/js/bootstrap.js"></script>

<script type="text/javascript" src="https://iihui.github.io/js/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
</body>
</html>