<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
    <title>swift中的方法 - Keep It Simple</title>
    <meta name="keywords" content="博客,思考,读书,笔记,技术,分享">
    
    <meta property="og:title" content="swift中的方法">
    <meta property="og:site_name" content="Keep It Simple">
    <meta property="og:image" content="/img/author.jpg"> 
    <meta name="title" content="swift中的方法 - Keep It Simple" />
    <meta name="description" content="Swift | Go | C&#43;&#43; "> 
    <link rel="shortcut icon" href="https://iihui.github.io/img/favicon.ico" />
    <link rel="apple-touch-icon" href="https://iihui.github.io/img/apple-touch-icon.png" />
    <link rel="apple-touch-icon-precomposed" href="https://iihui.github.io/img/apple-touch-icon.png" />
    <link href="https://iihui.github.io/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />
    <link href="https://iihui.github.io/js/vendor/fancybox/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />
    <link href="https://iihui.github.io/css/main.css" rel="stylesheet" type="text/css" />
    <link href="https://iihui.github.io/css/syntax.css" rel="stylesheet" type="text/css" />

    <script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
     fancybox: true, 
    motion: true
  };
</script>

    <link href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/monokai-sublime.min.css" rel="stylesheet">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/go.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/swift.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/objectivec.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/clojure.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/kotlin.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/yaml.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<div class="container one-collumn sidebar-position-left page-home  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-meta  custom-logo ">

  <div class="custom-logo-site-title">
    <a href="https://iihui.github.io/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Keep It Simple</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">靡不有初，鲜克有终</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
    <ul id="menu" class="menu">
      
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/tags/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-tag"></i> <br />标签
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/post/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/categories/%E7%BE%8E%E9%A3%9F/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-fire"></i> <br />美食
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/categories/%E5%90%8E%E6%9C%9F/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-edit"></i> <br />后期
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/categories/%E6%97%85%E8%A1%8C/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-leaf"></i> <br />旅行
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/about/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于
          </a>
        </li>
      
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger"> <i class="menu-item-icon fa fa-search fa-fw"></i> <br /> 搜索</a>
      </li>
    </ul>
    <div class="site-search">
      <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>

    </div>
</nav>
<script type="text/javascript"
        async
        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
		<!-- src = "http://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> <\!--  -\-> -->
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>

<!DOCTYPE html>
<html lang="en">


<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css" integrity="sha384-D+9gmBxUQogRLqvARvNLmA9hS2x//eK1FhVb9PiU86gmcrBrJAQT8okdJ4LMp2uv" crossorigin="anonymous">

    
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js" integrity="sha384-483A6DwYfKeDa0Q52fJmxFXkcPCFfnXMoXblOkJ4JcA8zATN6Tm78UNL72AKk+0O" crossorigin="anonymous"></script>
</head>
<body>

</body>
</html>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
<section id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="https://iihui.github.io/post/swift-method/" itemprop="url">
        swift中的方法
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">创建: </span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2018-09-14">
    2018-09-14
</time>
</span>
&nbsp; | &nbsp;
<span class="post-updated-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-check-o"></i>
</span>
<span class="post-meta-item-text">更新: </span>
<time itemprop="dateUpdated" content="2018-09-14">
    2018-09-14
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类: </span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="https://iihui.github.io/categories/code" itemprop="url" rel="index">
        <span itemprop="name">code</span>
      </a>
      &nbsp; 
    </span>
  
</span>


      <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-file-word-o"></i>
</span>
<span class="post-meta-item-text">字数: </span>
<span class="leancloud-visitors-count">6113</span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-coffee"></i>
</span>
<span class="post-meta-item-text">阅读: </span>
<span class="leancloud-visitors-count">13 分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <blockquote>
<p>在<code>Swift</code>中方法是<font color="#de7802">关联了特定类型的函数</font>。类，结构体，<font color=Blue>枚举类型</font>都能定义实例方法，方法封装了<font color="#de7802">给定类型特定的任务和功能</font>。</p>
</blockquote>
<h1 id="实例方法">实例方法</h1>
<p>实例方法是<font color=Blue>属于特定实例</font>（类实例、结构体实例或者枚举实例）的函数。实例方法<font color="#de7802">只能在类型的具体实例里被调用</font>，不能独立于实例而被调用，也就是说不能直接使用类名直接调用。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Counter</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> count = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">increment</span>() {
</span></span><span style="display:flex;"><span>        count <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">increment</span>(by amount: Int) {
</span></span><span style="display:flex;"><span>        count <span style="color:#f92672">+=</span> amount
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">reset</span>() {
</span></span><span style="display:flex;"><span>        count = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="异变方法">异变方法</h2>
<p>在<code>Swift</code>中<font color=Blue>结构体和枚举是值类型</font>。<font color="#de7802">默认情况下，值类型属性不能被自身的实例方法修改</font>。如果需要改变结构体或者枚举类型的属性，应该将实例方法进行<font color=red>异变</font>。即在实例方法的<code>func</code>关键字前添加<code>mutating</code>关键字：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Point</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> x = <span style="color:#ae81ff">0.0</span>, y = <span style="color:#ae81ff">0.0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">mutating</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">moveBy</span>(x deltaX: Double, y deltaY: Double) {
</span></span><span style="display:flex;"><span>        x <span style="color:#f92672">+=</span> deltaX
</span></span><span style="display:flex;"><span>        y <span style="color:#f92672">+=</span> deltaY
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>但是，<font color="#de7802">不能在常量结构体类型里调用异变方法</font>，因为常量代表自身属性不能被改变，即使这些属性是变量属性：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> fixedPoint = Point(x: <span style="color:#ae81ff">3.0</span>, y: <span style="color:#ae81ff">3.0</span>)
</span></span><span style="display:flex;"><span>fixedPoint.moveBy(x: <span style="color:#ae81ff">2.0</span>, y: <span style="color:#ae81ff">3.0</span>)  <span style="color:#75715e">//编译器会报错，因为常量结构体里的数据不能被修改，而moveBy声明是异变的，所以矛盾，编译器会报错。</span>
</span></span></code></pre></div><h2 id="self属性">self属性</h2>
<p>每一个类的实例都隐含一个叫做<code>self</code>的属性，它完全和实例本身相等，可以使用<code>self</code>来调用实例的方法或者使用实例的属性。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Point</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> x = <span style="color:#ae81ff">0.0</span>, y = <span style="color:#ae81ff">0.0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">isToTheRightOf</span>(x: Double) -&gt; Bool {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">self</span>.x <span style="color:#f92672">&gt;</span> x  <span style="color:#75715e">//形参的优先级别高于实例属性</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>枚举的<font color="#de7802">异变方法</font>可以设置<font color=Blue>隐含的<code>self</code>属性</font>为相同枚举里的不同成员。也就是在枚举类型中其异变的方法中，<code>self</code>也是可以变换的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">TriStateSwitch</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> off, low, high
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">mutating</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">next</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">switch</span> <span style="color:#66d9ef">self</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> .off:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">self</span> = .low
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> .low:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">self</span> = .high
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> .high:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">self</span> = .off
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="类型方法">类型方法</h1>
<p>类型方法是用来定义<font color="#de7802">类型本身调用的方法</font>，通过在<code>func</code>关键字前加<code>static</code>来实现。类还可以用<font color="#de7802">关键字<code>class</code>来允许子类重写父类的方法实现</font>。</p>
<p>在类方法中，隐含的<code>self</code><font color="#de7802">指向的是类本身</font>而不是类的实例。同样在类型方法中，有<code>self</code>访问的属性与同名的形参相比，优先级低一些：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Point</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">var</span> x = <span style="color:#ae81ff">12</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test</span>(x:Int)-&gt;Bool{
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">self</span>.x <span style="color:#f92672">&gt;</span> x
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="modern-concurrency">Modern Concurrency</h1>
<p>基于闭包的代码很多都类似如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">UserInfo</span>: Codable {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> username: String
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> avatar_url: String
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">UserAPI</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fetchUserInfo</span>(
</span></span><span style="display:flex;"><span>        completionHandler: @escaping (<span style="color:#66d9ef">_</span> userInfo: UserInfo?, <span style="color:#66d9ef">_</span> error: Error?) -&gt;
</span></span><span style="display:flex;"><span>            Void
</span></span><span style="display:flex;"><span>    ) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> url = URL(
</span></span><span style="display:flex;"><span>            string:
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;https://www.andyibanez.com/fairesepages.github.io/books/async-await/user_profile.json&#34;</span>
</span></span><span style="display:flex;"><span>        )<span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> session = URLSession.shared
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> dataTask = session.dataTask(with: url) { data, response, error <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> error = error {
</span></span><span style="display:flex;"><span>                completionHandler(<span style="color:#66d9ef">nil</span>, error)
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> data = data {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">let</span> userInfo = <span style="color:#66d9ef">try</span> JSONDecoder().decode(
</span></span><span style="display:flex;"><span>                        UserInfo.<span style="color:#66d9ef">self</span>, from: data)
</span></span><span style="display:flex;"><span>                    completionHandler(userInfo, <span style="color:#66d9ef">nil</span>)
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">catch</span> { completionHandler(<span style="color:#66d9ef">nil</span>, error) }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        dataTask.resume()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> userApi = UserAPI()
</span></span><span style="display:flex;"><span>userApi.fetchUserInfo { value, error <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> userInfo = value {
</span></span><span style="display:flex;"><span>        debugPrint(userInfo.username, userInfo.avatar_url)
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        debugPrint(error?.localizedDescription ?? <span style="color:#e6db74">&#34;无错误信息&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面的代码对于新学者来说，看起来有些吃力，但有经验的开发者，一看就知道这个方法是在做什么，即发送请求获取用户信息。</p>
<h2 id="introducing-asyncawait">Introducing async/await</h2>
<p>在过程式编程中，代码都是按逻辑顺序从上往下执行。回顾上面的代码，若能通过函数的标准返回语句来传递数据，而不是通过闭包传递数据，岂不是更好？这正是新系统允许我们做到的。去掉闭包，就可以编写自然的代码，从而更容易地表达我们的意图，让未来的开发人员（包括未来的自己）更清楚地掌握代码在做什么。</p>
<h3 id="the-async-keyword">The async keyword</h3>
<p>新系统的关键就是使用<code>async</code>和<code>await</code>关键字，了解如何使用这两个关键词至关重要。可以异步运行的函数，或者可以与其它函数同时运行的函数，在函数的返回类型前添加<code>async</code>关键字，就是告诉编译器，这个函数是异步的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fetchUserInfo</span>() async <span style="color:#66d9ef">throws</span> -&gt; UserInfo {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*...*/</span>
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">return</span> UserInfo(username: <span style="color:#e6db74">&#34;Test&#34;</span>, avatar_url: <span style="color:#e6db74">&#34;test&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面声明中，可以看到<code>completionHandler</code>已经消失了，如同回调<code>completionHandler</code>中有返回<code>Error</code>一样，函数会抛出<code>Error</code>。将fetchUserInfo标记为抛出异常，即在<code>async</code>后面添加关键字<code>throws</code>，可以使得错误处理更自然。函数的返回值标记为非可选的UserInfo，可以省去解包的步骤。</p>
<p>为了调用使用<code>async</code>关键字标记的函数，我们需要一个<code>concurrent context</code>（并发上下文），有几种方式创建这种并发上下文：</p>
<ul>
<li>
<p>标记为async的函数体就是一个<code>concurrent context</code>，一个函数未标记为<code>async</code>的，则它<font color="#de7802">不能直接调用<code>async</code>函数</font>，下面代码会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">authenticateAndFetchProfile</span>() { 
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">//...</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> userProfile = <span style="color:#66d9ef">try</span> await fetchUserInfo() <span style="color:#75715e">//...</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
</ul>
<p>但是，如果没有并发上下文会怎样呢？在调用层次的某处，发现根本没有并发上下文来运行async标记的函数。幸运的是，另一种创建异步上下文的方法可以帮助我们解决这个问题，即创建一个<code>Task</code>对象。</p>
<p><code>Task</code>（任务）是一个功能非常强大的对象，可以用它来进行多线程处理，还能对它们进行一些控制，比如取消。现在，我们只使用<code>Task</code>来创建并发上下文，<code>Task</code>有一个带有闭包的初始化器，而<font color="#de7802">闭包本身就是一个并发上下文</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">authenticateAndFetchProfile</span>() {
</span></span><span style="display:flex;"><span>    Task { <span style="color:#75715e">//...</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> userProfile = <span style="color:#66d9ef">try</span> await fetchUserInfo() <span style="color:#75715e">//...</span>
</span></span><span style="display:flex;"><span>        debugPrint(userProfile.username, userProfile.avatar_url)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例代码中，虽然函数authenticateAndFetchProfile没有被标记为async，但因为在函数体内创建了一个Task任务，所以在Task的闭包中可以调用async方法。</p>
<h3 id="the-await-keyword">The await keyword</h3>
<p>每一次对async函数的调用都必须在某个时刻与await关键字配对。await本身具有特殊的语义，它不仅仅是调用async函数的语法。</p>
<p>如果在代码执行过程中遇到await关键字，程序可以选择暂停当前正在执行的函数。因此，<font color="#de7802">await关键字通常也被称为暂停点</font>。这是系统会做出的决定，我们无法主动控制。<font color="#de7802">当我们说可能暂停时，意思是当前的执行将暂停</font>（挂起），而调用的async函数会在其他地方继续执行。如果当前函数被挂起，其中的代码将暂停执行，直到调用的async函数完成后才会恢复。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">authenticateAndFetchProfile</span>() async {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//...</span>
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;Fetching user info&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> userProfile = <span style="color:#66d9ef">try</span> await fetchUserInfo()
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;User info fetched&#34;</span>)  <span style="color:#75715e">//...</span>
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">catch</span> {
</span></span><span style="display:flex;"><span>        debugPrint(error.localizedDescription)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面代码执行后，首先会打印<code>Fetching user info</code>，过了一小会打印<code>User info fetched</code>，这正是我们编写代码的顺序，而且我们去除了闭包且不需要任何其它额外的东西来实现这个效果。</p>
<p>在await调用挂起期间发生的情况是，我们正在将控制权交还给系统。因此，我们无法控制何时会再次获得控制权。<font color="#de7802">调用fetchUserInfo()的同一线程将被释放去做其它工作，而这些其它工作与我们无关，因为它们由系统处理</font>。其它任务可能是我们应用内的另一个任务，或者是系统外部的任务。在我们获得控制权之前，无法继续执行语句。</p>
<p>因此，上面的示例的代码将按照书写的顺序打印语句，但打印用户信息可能需要一点时间，因为我们已经将线程处理交给了系统，下载用户信息是一个耗时任务。当用户信息下载完成时，fetchUserInfo调用中将到达return语句，这个return语句将控制权返回给我们。但请注意，<font color="#de7802">系统将决定何时将控制权交还给我们，这并不是在return语句后立即发生</font>。系统可能正在执行其它并发任务，它需要处理高优先级的问题，然后才会回到我们这边。</p>
<p>总之，在遇到一个挂起点（await关键字）后，<font color="#de7802">如果系统选择挂起，那么它下面的内容将不会执行，直至控制权重新交还给我们</font>。在挂起期间，系统会利用该线程来做其它工作。</p>
<p>任何在await调用之后发生的事情被称为<code>continuation</code>，我们需要继续做在被挂起之前正在做的事情，这很重要。因为我们可能会在恢复控制权时，<font color=red>await下面的语句在不同的线程中运行</font>。这意味着上面的示例代码中，第一个打印语句可能在一个线程中运行，而第二个打印语句可能在一个完全不同的线程中运行。</p>
<p>使用async/await并不能让我们免于在主线程上做UI工作，所以如果需要更新UI，需要将这项工作推迟到主线程上。在实践中，这是通过一个名为@MainActor的系统级全局actor来完成的。</p>
<h3 id="using-asyncawait">Using async/await</h3>
<p>苹果所有基于闭包的并发API都有一个<code>async/await</code>版本，可以在<code>iOS 15</code>及更高版本上使用。虽然使用Xcode 13.3可以在iOS 13及更高版本上使用async/await，但<font color="#de7802">苹果原生支持async/await的API仅在iOS 15及以上版本中可用</font>。</p>
<p>async函数可以被标记为throws。一般来说，如果正在模拟可能抛出错误或返回有效值的代码，可以简单地标记方法为throws，然后将结果类型指定为如果调用成功会得到的对象。本质上，<font color="#de7802">原本的<code>completionHandler</code>闭包的内容已经在函数签名中进行了移动</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fetchUserInfo</span>() async <span style="color:#66d9ef">throws</span> -&gt; UserInfo {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> url = URL(string: <span style="color:#e6db74">&#34;https://www.andyibanez.com/ fairesepages.github.io/books/async-await/user_ profile.json&#34;</span>)<span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> session = URLSession.shared
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> (userInfoData, response) = <span style="color:#66d9ef">try</span> await session.data(from: url)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> userInfo = <span style="color:#66d9ef">try</span> JSONDecoder().decode(UserInfo.<span style="color:#66d9ef">self</span>, from: userInfoData) 
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> userInfo
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>一开始就能看出，<code>async/await</code>能帮我们写出更语义化的代码。在Swift中，可以从函数中抛出错误，但令人惊讶的是，很多开发者并不这样写。这是因为大多数非平凡的应用本质上是并发的（例如，处理网络请求），而且我们无法以一种符合Swift风格的方式处理闭包中的错误，因此我们只能将错误作为闭包的一部分返回。使用 <code>async/await</code>，我们的函数签名更易读，因此也更具<code>self-documented</code>（自文档化）。</p>
<p>我们利用苹果在iOS 15中提供的第一个<code>async/await</code>API。所有返回数据的URLSession方法都有async/await变体。到目前为止一切顺利，但下面这段代码还不能编译，因为我们没有返回任何内容。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fetchUserInfo</span>() async <span style="color:#66d9ef">throws</span> -&gt; UserInfo {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> url = URL(string: <span style="color:#e6db74">&#34;https://www.andyibanez.com/ fairesepages.github.io/books/async-await/user_ profile.json&#34;</span>)<span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> session = URLSession.shared
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> (userInfoData, response) = <span style="color:#66d9ef">try</span> await session.data(from: url)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们需要理解这样一个事实：对<code>session.data(from:)</code>的调用不接受闭包，也不再需要调用<code>resume()</code>了，只要调用<code>data(from:)</code>的<code>async</code>版本，任务就会开始。现在需要将JSON解析成API消费者可以使用的对象并返回一个值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fetchUserInfo</span>() async <span style="color:#66d9ef">throws</span> -&gt; UserInfo {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> url = URL(string: <span style="color:#e6db74">&#34;https://www.andyibanez.com/fairesepages.github.io/books/async-await/user_ profile.json&#34;</span>)<span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> session = URLSession.shared
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> (userInfoData, response) = <span style="color:#66d9ef">try</span> await session.data(from: url)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> userInfo = <span style="color:#66d9ef">try</span> JSONDecoder().decode(UserInfo.<span style="color:#66d9ef">self</span>, from: userInfoData)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> userInfo
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>由于Swift支持方法重载，<code>fetchUserInfo()</code>和<code>fetchUserInfo(completionHandler:)</code>可以并存。通过将函数标记为async，我们创建了一个并发上下文，在其中我们可以调用其它async函数，并且fetchUserInfo的调用者本身需要在并发上下文中（要么它自己需要标记为async，要么在Task {}中调用）。</p>
<p>上面示例代码中，当代码执行到<code>let (userInfoData, response) = try await session.data(from: url)</code>时，代码会挂起，此时执行它的线程可以去做其它工作——可能与我们应用程序无关。由于这种挂起，紧接着的那行将数据转换为对象的代码将不会执行，因为它依赖于上面那行的数据。</p>
<p>当<code>session.data(from:)</code>完成了下载，它会让系统知道已准备好将结果返回给调用者。系统最后通知我们的应用程序，将返回结果并将其赋给<code>(userInfoData, response)</code>变量。在系统返回结果并赋值给两个变量有了值之后，代码会按照编写顺序继续执行，通过解析<code>JSON</code>，然后将该对象返回调用者，这就是最纯粹的过程化编程。</p>
<p>当设备没有联网或服务器发生异常时，代码会抛出异常。</p>
<h2 id="async-get-properties">async get properties</h2>
<p><code>async/await</code>并不局限于函数调用。还可以在只读计算属性中使用它，下面示例代码展示了如何做到这一点：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> userInfo: UserInfo {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">get</span> async <span style="color:#66d9ef">throws</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> url = URL(string: <span style="color:#e6db74">&#34;https://www.andyibanez.com/ fairesepages.github.io/books/async-await/user_ profile.json&#34;</span>)<span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> session = URLSession.shared
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> (userInfoData, <span style="color:#66d9ef">_</span>) = <span style="color:#66d9ef">try</span> await session.data(from: url)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> userInfo = <span style="color:#66d9ef">try</span> JSONDecoder().decode(UserInfo.<span style="color:#66d9ef">self</span>, from: userInfoData)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> userInfo
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="continuations">Continuations</h2>
<p><code>Continuations</code>很有用，因为利用他不仅能够提供基于闭包的代码的<code>async/await</code>版本，还包括第三方库和框架。这将帮助我们创建一个一致的代码库，在有必要时只使用<code>async/await</code>而不是基于闭包的调用。</p>
<p>并非所有基于闭包的代码都是因为处理并发或多线程。Swift和苹果的SDKs中都有多个调用闭包的方法，这与并发无关。例如，集合的流行方法filter、map和reduce，使用闭包来操作它们的元素。请记住这一点，因为很难有完全不使用任何类型闭包的项目，这是可以的。<code>async/await</code>旨在仅消除与并发相关任务基于闭包的调用。</p>
<p>有4种形式的continuations：</p>
<ul>
<li>
<p><code>withCheckedThrowingContinuation</code></p>
</li>
<li>
<p><code>withCheckedContinuation</code></p>
</li>
<li>
<p><code>withUnsafeThrowingContinuation</code></p>
</li>
<li>
<p><code>withUnsafeContinuation</code></p>
</li>
</ul>
<p>当原始的闭包代码根本不返回任何错误时，使用<code>withCheckedContinuation</code>。不安全的变体，<code>withUnsafeThrowingContinuation</code>和 <code>withUnsafeContinuation</code> -与它们的Checked对应项类似。主要区别在于，当使用Checked Continuations时，Swift会在遇到任何违规情况（如多次调用<code>continuations</code>或完全忘记调用它们）时通过记录错误来帮助保护你。不安全continuations没有这些功能，但它们可能稍微快一点。总的来说，不建议使用不安全continuations，但请注意，在大多数情况下，可以互换使用它们。</p>
<h2 id="structured-concurrency">Structured Concurrency</h2>
<p>在结构化并发中，<font color="#de7802">可以同时运行多个代码路径，并得到可预测的结果</font>，而无需思考那些跳转多个基于闭包调用的代码迷宫。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fetchData</span>() async <span style="color:#66d9ef">throws</span> -&gt; (userInfo: UserInfo, followers: UserInfo) {
</span></span><span style="display:flex;"><span>    async <span style="color:#66d9ef">let</span> userInfo = fetchUserInfo()
</span></span><span style="display:flex;"><span>    async <span style="color:#66d9ef">let</span> followers = fetchFellows()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">try</span> await userInfo, <span style="color:#66d9ef">try</span> await followers)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fetchData</span>() async <span style="color:#66d9ef">throws</span> -&gt; (userInfo: UserInfo, followers: UserInfo) {
</span></span><span style="display:flex;"><span>    async <span style="color:#66d9ef">let</span> userInfo = fetchUserInfo()
</span></span><span style="display:flex;"><span>    async <span style="color:#66d9ef">let</span> followers = fetchFellows()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">try</span> await(userInfo, followers)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ServerImage</span>: Codable {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> imageName: String
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> url: URL
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">download</span>(serverImages: [ServerImage]) async <span style="color:#66d9ef">throws</span> -&gt; [URL] {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> urls: [URL] = []
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> await withThrowingTaskGroup(of: URL.<span style="color:#66d9ef">self</span>) { group <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> image <span style="color:#66d9ef">in</span> serverImages {
</span></span><span style="display:flex;"><span>            group.addTask(priority: .userInitiated) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> imageUrl = <span style="color:#66d9ef">try</span> await <span style="color:#66d9ef">self</span>.download(image)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> imageUrl
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">try</span> await imageUrl <span style="color:#66d9ef">in</span> group { urls.append(imageUrl) }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> urls
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fetchImageList</span>() async <span style="color:#66d9ef">throws</span> -&gt; [ServerImage] {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> (data, <span style="color:#66d9ef">_</span>) = <span style="color:#66d9ef">try</span> await URLSession.shared.data(from: imageListURL)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> urls = <span style="color:#66d9ef">try</span> jsonDecoder.decode([ServerImage].<span style="color:#66d9ef">self</span>, from: data)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> urls
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">download</span>(<span style="color:#66d9ef">_</span> serverImage: ServerImage) async <span style="color:#66d9ef">throws</span> -&gt; URL {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> fileManager = FileManager.<span style="color:#66d9ef">default</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> tmpDir = fileManager.temporaryDirectory
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> (downloadedImageUrl, <span style="color:#66d9ef">_</span>) = <span style="color:#66d9ef">try</span> await URLSession.shared.download(from: serverImage.url)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> destinationUrl = tmpDir.appendingPathComponent(serverImage.imageName) <span style="color:#75715e">// If the destination already exists, remove it.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span>? fileManager.removeItem(at: destinationUrl)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> fileManager.moveItem(at: downloadedImageUrl, to: destinationUrl)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> destinationUrl
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="unstructured-concurrency">Unstructured Concurrency</h2>
<p>非结构化并发在牺牲较少可用性的同时提供了更多的灵活性。在处理无结构并发时，代码<font color="#de7802">不一定遵循我们所喜爱的自上而下的结构</font>。幸运的是，处理无结构并发仍然非常容易，这种灵活性不会显著增加程序的复杂性。</p>
<p>对于无结构的并发，依然是使用<code>Task</code>对象。<code>Task</code>是一个很重要的对象，它允许我们做两件非常重要的事情：</p>
<ul>
<li>使用初始化器创建<code>Task</code>后，它就会<font color="#de7802">异步启动闭包中的代码</font>。</li>
<li>它创建了一个并发上下文，使我们<font color="#de7802">能够以调用异步方法的方式使用并发功能</font>。</li>
</ul>
<p>下面示例代码是使用<code>Task</code>调用<code>async</code>方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">authenticateAndFetchProfile</span>() {
</span></span><span style="display:flex;"><span>    Task {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> userProfile = <span style="color:#66d9ef">try</span> await fetchUserInfo()
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>        debugPrint(userProfile)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fetchUserInfo</span>() async -&gt; String {
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;fetchUserInfo&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;Return Test&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>当我们想使用<code>Task</code>做并发时，首先要灵活指定优先级，优先级是<code>Task.Priority</code>（与处理任务组时使用的优先级相同）。下面是可使用的优先级列表：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> background: TaskPriority
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> high: TaskPriority
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> low: TaskPriority
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">var</span> medium: TaskPriority
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> userInitiated: TaskPriority
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> utility: TaskPriority
</span></span></code></pre></div><p><code>Task</code>是一个对象，你可以使用变量存储它，这就是被称为非机构并发的部分原因。我们可以有多个Task，存储在多个变量中（甚至存储在一个collections中）。在非机构化并发中，可以取消Task，但在结构化的Task无法做到：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">authenticate</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> authenticationTask = Task&lt;Bool, Error&gt; {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> context = LAContext()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> policy = LAPolicy.deviceOwnerAuthenticationWithBiometrics
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">try</span> await context.evaluatePolicy(
</span></span><span style="display:flex;"><span>            policy, localizedReason: <span style="color:#e6db74">&#34;To log in&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 取消Task</span>
</span></span><span style="display:flex;"><span>    authenticationTask.cancel()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在上面示例代码中，我们定义变量的类型为<code>Task&lt;Bool, Error&gt;</code>，这是因为<code>context.evaluatePolicy</code>返回一个<code>Bool</code>值，也可能抛出一个<code>Error</code>。</p>
<p>我们可以await某个Task的值。在下面示例代码中，我们需要使用try await，这是因为我们定义的authenticationTask可能返回一个Bool值，也可能抛出一个错误。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">authenticate</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> authenticationTask = Task&lt;Bool, Error&gt; {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> context = LAContext()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> policy = LAPolicy.deviceOwnerAuthenticationWithBiometrics
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">try</span> await context.evaluatePolicy(
</span></span><span style="display:flex;"><span>            policy, localizedReason: <span style="color:#e6db74">&#34;To log in&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    Task {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> status = <span style="color:#66d9ef">try</span> await authenticationTask.value
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> status {
</span></span><span style="display:flex;"><span>            debugPrint(<span style="color:#e6db74">&#34;sucess&#34;</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在上面示例代码创建Task时，我们没有使用do-catch语句体。上面代码隐式地创建了一个<code>Task&lt;(), Error&gt;</code>类型的任务，因为它不返回任何值，但他会抛出异常。Task不需要显式的do-catch语句体，因为闭包会自动捕获Error。</p>
<p>当在代码中使用<code>Task {}</code>创建一个新任务时，它将继承产生这个任务的上下文信息。继承的信息包括任务运行的Actor（如果在@MainActor上运行的任务中产生了任务，那么该任务也将在@MainActor上运行）和优先级。如果新生成的任务是一个根任务（它创建了一个异步上下文，但其本身并不在其中运行），那么它将继承其所运行线程的<code>Actor</code>。</p>

    </div>
    <footer class="post-footer">
        
 
<div class="post-tags">     
     
    <a href="https://iihui.github.io/tags/ios" rel="tag" title="iOS">#iOS#</a>
    
</div>



        <div class="post-nav">
    <div class="post-nav-next post-nav-item">
    
        <a href="https://iihui.github.io/post/oc-tour/" rel="next" title="OC 入门">
        <i class="fa fa-chevron-left"></i> OC 入门
        </a>
    
    </div>

    <div class="post-nav-prev post-nav-item">
    
        <a href="https://iihui.github.io/post/js-data-struct/" rel="prev" title="JavaScript 数据类型">
        JavaScript 数据类型 <i class="fa fa-chevron-right"></i>
        </a>
    
    </div>
</div>
      
        <div class="post-nav">
    <div style="border: 1px dashed #e0e0e0; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
        <div style="float:left;margin-top:0px;">
            <img src="https://i.loli.net/2020/02/09/SvhUdz4XJsOr9Vk.jpg" width="128px" height="128px"/>
            <div style="text-align:center;">谢谢支持!</div>
        </div>
        <div>
            <p style="margin-top:10px;">
                标题：swift中的方法
                <br />作者：阿呆<a target="_blank" href="https://iihui.github.io/"></a>
                
                <br />地址：https://iihui.github.io/post/swift-method/
                <br />声明：自由转载-非商用-保持署名（创作共享4.0许可证）
            </p>
        </div>
    </div>
    <div class="clear"></div>
</div>
        
        
        




    </footer>
  </article>
</section>

          </div>
        </div>
        <div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>
<aside id="sidebar" class="sidebar">
  <div class="sidebar-inner">

  <ul class="sidebar-nav motion-element">
    <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
      文章目录
    </li>
    <li class="sidebar-nav-overview" data-target="site-overview">
      站点概览
    </li>
  </ul>

    <section class="site-overview sidebar-panel ">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
        src="https://i.loli.net/2020/02/07/dVFzrvZkHRNq2lL.jpg"
        alt="" />
    <p class="site-author-name" itemprop="name"></p>
    <p class="site-description motion-element" itemprop="description"> 
        coder &amp; cook</p>
</div>
      <nav class="site-state motion-element">
    <div class="site-state-item site-state-posts">
      <a href="https://iihui.github.io/post/">
        <span class="site-state-item-count">143</span>
        <span class="site-state-item-name">日志</span>
      </a>
    </div>
    <div class="site-state-item site-state-categories">    
        <a href="https://iihui.github.io/categories/">      
         
        <span class="site-state-item-count">18</span>
        
        <span class="site-state-item-name">分类</span>
        
        </a>
    </div>

    <div class="site-state-item site-state-tags">
        <a href="https://iihui.github.io/tags/">
         
        <span class="site-state-item-count">29</span>
        
        <span class="site-state-item-name">标签</span>
        </a>
    </div>
</nav>
      
      
<div class="links-of-author motion-element">
    
        <span class="links-of-author-item">
        <a href="https://coolshell.cn" target="_blank" title="皓 大">
            <i class="fa fa-fw fa-globe"></i>
            皓 大
        </a>
        </span>
    
        <span class="links-of-author-item">
        <a href="http://www.ruanyifeng.com" target="_blank" title="阮 大">
            <i class="fa fa-fw fa-globe"></i>
            阮 大
        </a>
        </span>
    
        <span class="links-of-author-item">
        <a href="https://juejin.im/" target="_blank" title="掘 金">
            <i class="fa fa-fw fa-globe"></i>
            掘 金
        </a>
        </span>
    
</div>


      

      <div class="links-of-blogroll motion-element inline">
<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=&amp;m=0&amp;s=220&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;bv=35" async="async"></script>
</div>

    </section>
    
<section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
    <div class="post-toc">
        <div class="post-toc-content"><nav id="TableOfContents">
  <ul>
    <li><a href="#实例方法">实例方法</a>
      <ul>
        <li><a href="#异变方法">异变方法</a></li>
        <li><a href="#self属性">self属性</a></li>
      </ul>
    </li>
    <li><a href="#类型方法">类型方法</a></li>
    <li><a href="#modern-concurrency">Modern Concurrency</a>
      <ul>
        <li><a href="#introducing-asyncawait">Introducing async/await</a>
          <ul>
            <li><a href="#the-async-keyword">The async keyword</a></li>
            <li><a href="#the-await-keyword">The await keyword</a></li>
            <li><a href="#using-asyncawait">Using async/await</a></li>
          </ul>
        </li>
        <li><a href="#async-get-properties">async get properties</a></li>
        <li><a href="#continuations">Continuations</a></li>
        <li><a href="#structured-concurrency">Structured Concurrency</a></li>
        <li><a href="#unstructured-concurrency">Unstructured Concurrency</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
    </div>
</section>

  </div>
</aside>

      </div>
    </main>
   
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  <span itemprop="copyrightYear">  &copy; 
  2017 - 2025</span>
  <span class="with-love"><i class="fa fa-heart"></i></span>
  <span class="author" itemprop="copyrightHolder">Keep It Simple</span>
</div>




      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      <span id="scrollpercent"><span>0</span>%</span>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/jquery/index.js?v=2.1.3"></script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script> 
<script type="text/javascript" src="https://iihui.github.io/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/velocity/velocity.min.js?v=1.2.1"></script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="https://iihui.github.io/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>

<script src="https://iihui.github.io/js/vendor/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>

<script type="text/javascript" src="https://iihui.github.io/js/utils.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/motion.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/affix.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/schemes/pisces.js"></script>

<script type="text/javascript" src="https://iihui.github.io/js/scrollspy.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/post-details.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/toc.js"></script>

<script type="text/javascript" src="https://iihui.github.io/js/bootstrap.js"></script>

<script type="text/javascript" src="https://iihui.github.io/js/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
</body>
</html>