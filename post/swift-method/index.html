<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
    <title>swift中的方法 - Keep It Simple</title>
    <meta name="keywords" content="博客,思考,读书,笔记,技术,分享">
    
    <meta property="og:title" content="swift中的方法">
    <meta property="og:site_name" content="Keep It Simple">
    <meta property="og:image" content="/img/author.jpg"> 
    <meta name="title" content="swift中的方法 - Keep It Simple" />
    <meta name="description" content="Swift | Go | C&#43;&#43; "> 
    <link rel="shortcut icon" href="https://iihui.github.io/img/favicon.ico" />
    <link rel="apple-touch-icon" href="https://iihui.github.io/img/apple-touch-icon.png" />
    <link rel="apple-touch-icon-precomposed" href="https://iihui.github.io/img/apple-touch-icon.png" />
    <link href="https://iihui.github.io/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />
    <link href="https://iihui.github.io/js/vendor/fancybox/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />
    <link href="https://iihui.github.io/css/main.css" rel="stylesheet" type="text/css" />
    <link href="https://iihui.github.io/css/syntax.css" rel="stylesheet" type="text/css" />

    <script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
     fancybox: true, 
    motion: true
  };
</script>

    <link href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/monokai-sublime.min.css" rel="stylesheet">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/go.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/swift.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/objectivec.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/clojure.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/kotlin.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/yaml.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<div class="container one-collumn sidebar-position-left page-home  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-meta  custom-logo ">

  <div class="custom-logo-site-title">
    <a href="https://iihui.github.io/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Keep It Simple</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">靡不有初，鲜克有终</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
    <ul id="menu" class="menu">
      
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/tags/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-tag"></i> <br />标签
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/post/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/categories/%E7%BE%8E%E9%A3%9F/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-fire"></i> <br />美食
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/categories/%E5%90%8E%E6%9C%9F/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-edit"></i> <br />后期
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/categories/%E6%97%85%E8%A1%8C/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-leaf"></i> <br />旅行
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/about/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于
          </a>
        </li>
      
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger"> <i class="menu-item-icon fa fa-search fa-fw"></i> <br /> 搜索</a>
      </li>
    </ul>
    <div class="site-search">
      <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>

    </div>
</nav>
<script type="text/javascript"
        async
        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
		<!-- src = "http://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> <\!--  -\-> -->
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>

<!DOCTYPE html>
<html lang="en">


<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css" integrity="sha384-D+9gmBxUQogRLqvARvNLmA9hS2x//eK1FhVb9PiU86gmcrBrJAQT8okdJ4LMp2uv" crossorigin="anonymous">

    
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js" integrity="sha384-483A6DwYfKeDa0Q52fJmxFXkcPCFfnXMoXblOkJ4JcA8zATN6Tm78UNL72AKk+0O" crossorigin="anonymous"></script>
</head>
<body>

</body>
</html>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
<section id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="https://iihui.github.io/post/swift-method/" itemprop="url">
        swift中的方法
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">创建: </span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2018-09-14">
    2018-09-14
</time>
</span>
&nbsp; | &nbsp;
<span class="post-updated-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-check-o"></i>
</span>
<span class="post-meta-item-text">更新: </span>
<time itemprop="dateUpdated" content="2018-09-14">
    2018-09-14
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类: </span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="https://iihui.github.io/categories/code" itemprop="url" rel="index">
        <span itemprop="name">code</span>
      </a>
      &nbsp; 
    </span>
  
</span>


      <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-file-word-o"></i>
</span>
<span class="post-meta-item-text">字数: </span>
<span class="leancloud-visitors-count">13344</span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-coffee"></i>
</span>
<span class="post-meta-item-text">阅读: </span>
<span class="leancloud-visitors-count">27 分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <blockquote>
<p>在<code>Swift</code>中方法是<font color="#de7802">关联了特定类型的函数</font>。类，结构体，<font color=Blue>枚举类型</font>都能定义实例方法，方法封装了<font color="#de7802">给定类型特定的任务和功能</font>。</p>
</blockquote>
<h1 id="实例方法">实例方法</h1>
<p>实例方法是<font color=Blue>属于特定实例</font>（类实例、结构体实例或者枚举实例）的函数。实例方法<font color="#de7802">只能在类型的具体实例里被调用</font>，不能独立于实例而被调用，也就是说不能直接使用类名直接调用。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Counter</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> count = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">increment</span>() {
</span></span><span style="display:flex;"><span>        count <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">increment</span>(by amount: Int) {
</span></span><span style="display:flex;"><span>        count <span style="color:#f92672">+=</span> amount
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">reset</span>() {
</span></span><span style="display:flex;"><span>        count = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="异变方法">异变方法</h2>
<p>在<code>Swift</code>中<font color=Blue>结构体和枚举是值类型</font>。<font color="#de7802">默认情况下，值类型属性不能被自身的实例方法修改</font>。如果需要改变结构体或者枚举类型的属性，应该将实例方法进行<font color=red>异变</font>。即在实例方法的<code>func</code>关键字前添加<code>mutating</code>关键字：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Point</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> x = <span style="color:#ae81ff">0.0</span>, y = <span style="color:#ae81ff">0.0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">mutating</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">moveBy</span>(x deltaX: Double, y deltaY: Double) {
</span></span><span style="display:flex;"><span>        x <span style="color:#f92672">+=</span> deltaX
</span></span><span style="display:flex;"><span>        y <span style="color:#f92672">+=</span> deltaY
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>但是，<font color="#de7802">不能在常量结构体类型里调用异变方法</font>，因为常量代表自身属性不能被改变，即使这些属性是变量属性：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> fixedPoint = Point(x: <span style="color:#ae81ff">3.0</span>, y: <span style="color:#ae81ff">3.0</span>)
</span></span><span style="display:flex;"><span>fixedPoint.moveBy(x: <span style="color:#ae81ff">2.0</span>, y: <span style="color:#ae81ff">3.0</span>)  <span style="color:#75715e">//编译器会报错，因为常量结构体里的数据不能被修改，而moveBy声明是异变的，所以矛盾，编译器会报错。</span>
</span></span></code></pre></div><h2 id="self属性">self属性</h2>
<p>每一个类的实例都隐含一个叫做<code>self</code>的属性，它完全和实例本身相等，可以使用<code>self</code>来调用实例的方法或者使用实例的属性。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Point</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> x = <span style="color:#ae81ff">0.0</span>, y = <span style="color:#ae81ff">0.0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">isToTheRightOf</span>(x: Double) -&gt; Bool {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">self</span>.x <span style="color:#f92672">&gt;</span> x  <span style="color:#75715e">//形参的优先级别高于实例属性</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>枚举的<font color="#de7802">异变方法</font>可以设置<font color=Blue>隐含的<code>self</code>属性</font>为相同枚举里的不同成员。也就是在枚举类型中其异变的方法中，<code>self</code>也是可以变换的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">TriStateSwitch</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> off, low, high
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">mutating</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">next</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">switch</span> <span style="color:#66d9ef">self</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> .off:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">self</span> = .low
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> .low:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">self</span> = .high
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> .high:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">self</span> = .off
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="类型方法">类型方法</h1>
<p>类型方法是用来定义<font color="#de7802">类型本身调用的方法</font>，通过在<code>func</code>关键字前加<code>static</code>来实现。类还可以用<font color="#de7802">关键字<code>class</code>来允许子类重写父类的方法实现</font>。</p>
<p>在类方法中，隐含的<code>self</code><font color="#de7802">指向的是类本身</font>而不是类的实例。同样在类型方法中，有<code>self</code>访问的属性与同名的形参相比，优先级低一些：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Point</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">var</span> x = <span style="color:#ae81ff">12</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test</span>(x:Int)-&gt;Bool{
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">self</span>.x <span style="color:#f92672">&gt;</span> x
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="modern-concurrency">Modern Concurrency</h1>
<p>基于闭包的代码很多都类似如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">UserInfo</span>: Codable {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> username: String
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> avatar_url: String
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">UserAPI</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fetchUserInfo</span>(
</span></span><span style="display:flex;"><span>        completionHandler: @escaping (<span style="color:#66d9ef">_</span> userInfo: UserInfo?, <span style="color:#66d9ef">_</span> error: Error?) -&gt;
</span></span><span style="display:flex;"><span>            Void
</span></span><span style="display:flex;"><span>    ) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> url = URL(
</span></span><span style="display:flex;"><span>            string:
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;https://www.andyibanez.com/fairesepages.github.io/books/async-await/user_profile.json&#34;</span>
</span></span><span style="display:flex;"><span>        )<span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> session = URLSession.shared
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> dataTask = session.dataTask(with: url) { data, response, error <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> error = error {
</span></span><span style="display:flex;"><span>                completionHandler(<span style="color:#66d9ef">nil</span>, error)
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> data = data {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">let</span> userInfo = <span style="color:#66d9ef">try</span> JSONDecoder().decode(
</span></span><span style="display:flex;"><span>                        UserInfo.<span style="color:#66d9ef">self</span>, from: data)
</span></span><span style="display:flex;"><span>                    completionHandler(userInfo, <span style="color:#66d9ef">nil</span>)
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">catch</span> { completionHandler(<span style="color:#66d9ef">nil</span>, error) }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        dataTask.resume()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> userApi = UserAPI()
</span></span><span style="display:flex;"><span>userApi.fetchUserInfo { value, error <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> userInfo = value {
</span></span><span style="display:flex;"><span>        debugPrint(userInfo.username, userInfo.avatar_url)
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        debugPrint(error?.localizedDescription ?? <span style="color:#e6db74">&#34;无错误信息&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面的代码对于新学者来说，看起来有些吃力，但有经验的开发者，一看就知道这个方法是在做什么，即发送请求获取用户相关信息。</p>
<h2 id="introducing-asyncawait">Introducing async/await</h2>
<p>在过程式编程中，代码都是按逻辑顺序从上往下执行。回顾上面的代码，若能通过函数的标准返回语句来传递数据，而不是通过闭包传递数据，岂不是更好？这正是新系统允许我们做到的。去掉闭包，就可以编写自然的代码，从而更容易地表达我们的意图，让未来的开发人员（包括未来的自己）更清楚地掌握代码在做什么。</p>
<h3 id="the-async-keyword">The async keyword</h3>
<p>新系统的关键是使用<code>async</code>和<code>await</code>关键字，了解如何使用这两个关键词对于使用整个系统至关重要。可以异步运行的函数（异步函数）或可以与其它函数同时运行的函数（同步函数），在这些函数的返回类型前添加<code>async</code>关键字，就是告诉编译器，这个函数是异步的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fetchUserInfo</span>() async <span style="color:#66d9ef">throws</span> -&gt; UserInfo {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*...*/</span>
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">return</span> UserInfo(username: <span style="color:#e6db74">&#34;Test&#34;</span>, avatar_url: <span style="color:#e6db74">&#34;test&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面声明中，可以看到<code>completionHandler</code>已经消失了，如同在回调<code>completionHandler</code>中返回<code>Error</code>一样，现在定义的函数也可能抛出<code>Error</code>。将<code>fetchUserInfo</code>标记为抛出异常，即在<code>async</code>后面添加关键字<code>throws</code>，可以使得错误处理更自然。函数的返回值标记为非可选的<code>UserInfo</code>，可以省去解包的步骤。</p>
<p>为了调用使用<code>async</code>关键字标记的函数，我们需要一个<code>concurrent context</code>（并发上下文），有几种方式创建这种并发上下文：</p>
<ul>
<li>
<p>标记为<code>async</code>的函数体是一个<code>concurrent context</code>。若一个函数未使用<code>async</code>标记，则它<font color="#de7802">不能直接调用<code>async</code>函数</font>，下面代码会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">authenticateAndFetchProfile</span>() { 
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">//...</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> userProfile = <span style="color:#66d9ef">try</span> await fetchUserInfo() <span style="color:#75715e">//...</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
</ul>
<p>但是，若没有并发上下文会怎样呢？在代码调用层次结构的某处，可能会遇到根本没有并发上下文来运行使用<code>async</code>标记的异步函数。幸运的是，有一种创建异步上下文的方法可以帮助我们解决这个问题，即创建一个<code>Task</code>对象。</p>
<p><code>Task</code>（任务）是一个功能非常强大的对象，可以用它来进行多线程处理，还能对它们进行一些控制，比如取消。现在，我们只使用<code>Task</code>来创建并发上下文，<code>Task</code>有一个带有闭包的初始化器，而这个<font color="#de7802">闭包本身就是一个并发上下文</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">authenticateAndFetchProfile</span>() {
</span></span><span style="display:flex;"><span>    Task { <span style="color:#75715e">//...</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> userProfile = <span style="color:#66d9ef">try</span> await fetchUserInfo() <span style="color:#75715e">//...</span>
</span></span><span style="display:flex;"><span>        debugPrint(userProfile.username, userProfile.avatar_url)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例代码中，虽然函数authenticateAndFetchProfile没有被标记为async，但因为在函数体内创建了一个Task，所以在创建Task的闭包中可以调用<code>async</code>方法。</p>
<h3 id="the-await-keyword">The await keyword</h3>
<p>每一次<code>async</code>函数的调用都必须在某个点有与之对应的<code>await</code>关键字。<code>await</code>本身具有特殊的语义，它不仅仅是调用<code>async</code>函数的语法。</p>
<p>如果我们的代码在过程中遇到<code>await</code>关键字，我们的程序可能选择挂起当前正在执行的函数。因为这个原因，<font color="#de7802"><code>await</code>关键字通常也被称为挂起点</font>。这是系统可能会做出的决定，我们无法主动进行控制。</p>
<p><font color="#de7802">当我们说可能会挂起时，意思是当前的执行将被暂停</font>，而正在调用的<code>async</code>函数会在其它地方继续执行。如果当前函数被挂起，其中的代码将暂停执行（从调用<code>async</code>函数开始，之后的所有代码均不会执行），直到调用的<code>async</code>函数执行完成后才会恢复。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">authenticateAndFetchProfile</span>() async {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//...</span>
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;Fetching user info&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> userProfile = <span style="color:#66d9ef">try</span> await fetchUserInfo()
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;User info fetched&#34;</span>)  <span style="color:#75715e">//...</span>
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">catch</span> {
</span></span><span style="display:flex;"><span>        debugPrint(error.localizedDescription)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面代码执行后，首先会打印字符串<code>Fetching user info</code>，过一小会儿才打印字符串<code>User info fetched</code>，这正是我们编写语句的顺序。而且，我们成功地删除了闭包且不需要任何其它额外的东西来实现按顺序输出。</p>
<p>在<code>await</code>调用挂起期间发生的事情是，我们正在将控制权交还给系统。因此，我们无法控制何时能够再次获得控制权。<font color="#de7802">调用<code>fetchUserInfo()</code>的线程将被释放去做其它工作，具体做什么工作无需我们关心，因为这些由系统调度处理</font>。其它工作可能是我们应用内的另一个任务，或者是系统外部的任务。在我们获得控制权之前，无法继续执行代码中的任何语句。</p>
<p>因此，上面示例代码将按照书写的顺序打印语句，但打印<code>User info fetched</code>可能需要一点时间，因为我们已经将调用线程交给了系统，下载用户信息是一个耗时任务。当用户信息下载完成时，<code>fetchUserInfo</code>函数调用将到达其函数体的<code>return</code>语句，这个<code>return</code>语句将控制权返回给我们。但请注意，<font color="#de7802">系统将决定何时将控制权交还给我们，这并不是在<code>return</code>语句后立即发生</font>。系统可能正在执行其它并发任务，它需要处理高其它优先级的问题，然后才会交换机控制权给我们。</p>
<p>总之，在遇到一个挂起点（<code>await</code>关键字）后，<font color="#de7802">如果系统选择挂起，那么它下面的内容将不会执行，直至控制权重新交还给我们</font>。在挂起期间，系统会利用该线程做其它工作。</p>
<p>任何在<code>await</code>调用之后发生的事情被称为<code>continuation</code>，我们需要继续做在被挂起之前正在做的事情，这很重要。因为我们可能在不同线程重新拿到控制权，即<font color=red><code>await</code>下面的语句可能在不同的线程中运行</font>。这意味着在上面示例代码中，第一个打印语句可能在一个线程中运行，而第二个打印语句可能在一个完全不同的线程中运行。</p>
<p>使用<code>async/await</code>并不能让我们免于在主线程上做UI工作，所以如果需要更新UI，需要将这项工作推迟到主线程上。在实践中，这是通过一个名为<code>@MainActor</code>的系统级全局<code>actor</code>来完成的。</p>
<h3 id="using-asyncawait">Using async/await</h3>
<p>苹果所有基于闭包的并发API都有一个<code>async/await</code>版本，可以在<code>iOS 15</code>及更高版本上使用。虽然使用Xcode 13.3可以在iOS 13及更高版本上使用<code>async/await</code>，但<font color="#de7802">苹果原生支持<code>async/await</code>的API仅在iOS 15及以上版本中可用</font>。</p>
<p>定义<code>async</code>函数时，可以使用<code>throws</code>标记。一般来说，如果正在模拟可能抛出错误或返回有效值的代码，可以简单地将函数标记为<code>throws</code>，然后将结果类型指定为调用成功后能得到的对象。本质上，<font color="#de7802">开始的<code>completionHandler</code>闭包的内容已经在函数签名中进行了移动</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fetchUserInfo</span>() async <span style="color:#66d9ef">throws</span> -&gt; UserInfo {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>一开始就能看出，<code>async/await</code>能帮我们写出更语义化的代码。在Swift中，可以在函数中抛出错误，但令人惊讶的是，很多开发者并不这样写。这是因为大多数应用本质上是并发的（例如，处理网络请求），而且我们无法以一种符合Swift风格的方式处理闭包中的错误，因此只能将错误作为闭包的一部分返回。使用<code>async/await</code>后，函数签名更易读，也更具<code>self-documented</code>（自文档化）。</p>
<p>我们利用苹果在iOS 15中提供的第一个<code>async/await</code>API。所有返回数据的<code>URLSession</code>方法都有<code>async/await</code>变体。到目前为止一切顺利，但下面这段代码还不能编译，因为在函数体中没有返回任何内容。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fetchUserInfo</span>() async <span style="color:#66d9ef">throws</span> -&gt; UserInfo {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> url = URL(string: <span style="color:#e6db74">&#34;https://www.andyibanez.com/ fairesepages.github.io/books/async-await/user_profile.json&#34;</span>)<span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> session = URLSession.shared
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> (userInfoData, response) = <span style="color:#66d9ef">try</span> await session.data(from: url)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们需要理解这样一个事实：上面对<code>session.data(from:)</code>的调用不再接受闭包，也不再需要调用<code>resume()</code>了，只要调用<code>data(from:)</code>的<code>async</code>版本，任务就会自动开始。现在需要将<code>JSON</code>解析成可以使用的对象并返回。</p>
<p>下面是<code>fetchUserInfo</code>完整的<code>aync</code>版本。因为使用<code>async</code>和<code>await</code>，我们将原本15代码简化为了5行，能够真正体会到<code>async/await</code>的优雅。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fetchUserInfo</span>() async <span style="color:#66d9ef">throws</span> -&gt; UserInfo {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> url = URL(string: <span style="color:#e6db74">&#34;https://www.andyibanez.com/fairesepages.github.io/books/async-await/user_profile.json&#34;</span>)<span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> session = URLSession.shared
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> (userInfoData, response) = <span style="color:#66d9ef">try</span> await session.data(from: url)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> userInfo = <span style="color:#66d9ef">try</span> JSONDecoder().decode(UserInfo.<span style="color:#66d9ef">self</span>, from: userInfoData)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> userInfo
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>由于Swift支持方法重载，<code>fetchUserInfo()</code>和<code>fetchUserInfo(completionHandler:)</code>可以并存。通过将函数标记为<code>async</code>，我们创建了一个并发上下文，在其中我们可以调用其它async函数，并且fetchUserInfo的调用者本身需要在并发上下文中（要么它自己标记为async，要么在Task {}中调用）。</p>
<p>当代码执行到<code>let (userInfoData, response) = try await session.data(from: url)</code>时，代码会挂起，此时执行它的线程可以去做其它工作——可能与我们应用程序无关。由于fetchUserInfo函数被挂起，下面将数据转换为对象的那一行代码也不会执行，因为它依赖于上面那行返回的数据。</p>
<p>当<code>session.data(from:)</code>完成了下载，它会让系统知道已准备好将结果返回给调用者。系统最后通过返回结果并将其赋给<code>(userInfoData, response)</code>变量，来通知我们的应用程序。系统返回结果并赋值给两个变量后，代码会按照编写顺序继续执行，即解析<code>JSON</code>，然后将该对象返回给调用者，这就是最纯粹的过程化编程。</p>
<p>当设备没有联网或服务器发生异常时，代码会抛出异常。如果发生错误，可以直观地知道会发生什么，因为它和代码不是异步的情况完全一样：<code>session.data(from:)</code> 会抛出一个错误（符合Error协议的对象），且其下面的所有代码行都不会被执行。因此，在上面示例代码中，<font color="#de7802">调用者必须使用 try、try? 或 try! 调用 fetchUserInfo()（在这种情况下，try! 是完全不推荐的）</font>。</p>
<h3 id="async-get-properties">async get properties</h3>
<p>关键字<code>async/await</code>并不局限于函数调用，<font color="#de7802">还可以在只读计算属性中使用它</font>。下面示例代码展示了如何做到这一点的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> userInfo: UserInfo {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">get</span> async <span style="color:#66d9ef">throws</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> url = URL(string: <span style="color:#e6db74">&#34;https://www.andyibanez.com/ fairesepages.github.io/books/async-await/user_profile.json&#34;</span>)<span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> session = URLSession.shared
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> (userInfoData, <span style="color:#66d9ef">_</span>) = <span style="color:#66d9ef">try</span> await session.data(from: url)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> userInfo = <span style="color:#66d9ef">try</span> JSONDecoder().decode(UserInfo.<span style="color:#66d9ef">self</span>, from: userInfoData)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> userInfo
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在声明属性时可以同时使用async和throws标记。一般来说不推荐这样使用，除非已经实现了某种缓存机制。否则，若频繁地访问该属性，会导致显著的延迟。可能存在一些情况下避免缓存机制是有意义的，但必须逐个案例进行分析。</p>
<h3 id="asyncawait-in-ios-13-and-ios-14">async/await in iOS 13 and iOS 14</h3>
<p>之前我们提到，虽然async/await在iOS 13 和 iOS 14 上可以使用，但苹果并没有提供任何标记为async/await的系统API。这意味这些版本中实际上没有任何方法可以使用async/await的系统API。你可能会疑惑，如果苹果在这些版本中一开始就没有提供任何<code>async/await</code>的系统API，那为什么还要在这些版本中支持<code>async/await</code>呢？如果你需要支持这些版本，可以使用<code>Continuations</code>来实现系统方法的<code>async/await</code>变体。</p>
<h2 id="continuations">Continuations</h2>
<p><code>Continuations</code>很有用，因为利用它不仅能够将我们自己写的基于闭包的代码改为<code>async/await</code>版本，还能将第三方库和框架的代码进行封装。它能够帮助我们创建一致的代码库，在必要时只使用<code>async/await</code>而不是基于闭包的调用。</p>
<p>并非所有基于闭包的代码都是为了处理并发或多线程。Swift和苹果的SDK中都有多个使用闭包的方法，这与并发无关。例如，集合的常用方法<code>filter、map</code>和<code>reduce</code>，使用闭包来操作它们的元素。请记住，因为很难有完全不使用闭包的项目，使用闭包是可以的。<code>async/await</code>旨在仅消除与并发相关的基于闭包的调用。</p>
<h3 id="understanding-continuations">Understanding Continuations</h3>
<p>简而言之，<code>Continuations</code>是指异步调用完成后发生的一切。当我们使用<code>async/await</code>时，一个<code>continuation</code>就是简单地指<code>await</code>调用下面的所有内容。</p>
<p>如果使用的是基于闭包的代码，continuation指的在回调<code>completion handlers</code>中编写的代码。而如果使用的是基于delegate的代码，continuation就是在某个操作完成后的的某个方法调用。新的并发系统允许我们将基于闭包的代码或基于delegate的代码转换为<code>async/await</code>版本。</p>
<h3 id="converting-closure-based-calls-into-asyncawait">Converting closure-based calls into async/await</h3>
<p>下面是基于闭包的函数定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fetchUserInfo</span>(
</span></span><span style="display:flex;"><span>    completionHandler: @escaping (<span style="color:#66d9ef">_</span> userInfo: UserInfo?, <span style="color:#66d9ef">_</span> error: Error?) -&gt;
</span></span><span style="display:flex;"><span>        Void
</span></span><span style="display:flex;"><span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> url = URL(
</span></span><span style="display:flex;"><span>        string:
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;https://www.andyibanez.com/fairesepages.github.io/books/async-await/user_profile.json&#34;</span>
</span></span><span style="display:flex;"><span>    )<span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> session = URLSession.shared
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> dataTask = session.dataTask(with: url) { data, response, error <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> error = error {
</span></span><span style="display:flex;"><span>            completionHandler(<span style="color:#66d9ef">nil</span>, error)
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> data = data {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> userInfo = <span style="color:#66d9ef">try</span> JSONDecoder().decode(
</span></span><span style="display:flex;"><span>                    UserInfo.<span style="color:#66d9ef">self</span>, from: data)
</span></span><span style="display:flex;"><span>                completionHandler(userInfo, <span style="color:#66d9ef">nil</span>)
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">catch</span> { completionHandler(<span style="color:#66d9ef">nil</span>, error) }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    dataTask.resume()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>可以使用<code>withCheckedThrowingContinuation</code>将其转换为async版本（下面这种方式和promiseKit有些相似）。下面示例代码实际上是在<code>withCheckedThrowingContinuation</code>中封装了基于闭包的代码。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fetchUserInfo2</span>() async <span style="color:#66d9ef">throws</span> -&gt; UserInfo {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> await withCheckedThrowingContinuation { continuation <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>        fetchUserInfo { userInfo, error <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> user = userInfo {
</span></span><span style="display:flex;"><span>                continuation.resume(returning: user)
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> err = error {
</span></span><span style="display:flex;"><span>                continuation.resume(throwing: err)
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// Throw a generic error.</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> err = NSError(domain: <span style="color:#e6db74">&#34;com.socialmedia. app&#34;</span>, code: <span style="color:#ae81ff">400</span>)
</span></span><span style="display:flex;"><span>                continuation.resume(throwing: err)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>withCheckedThrowingContinuation</code>是一种提供带参闭包的方法，这个参数实际上就是<code>continuation</code>，当带有闭包的异步调用完成后，我们需要<code>resume</code>它。<code>continuation</code>的类型是<code>CheckedContinuation&lt;T, any Error&gt;</code>，这意味着我们可以使用一个对象或<code>Error</code>来<code>resume</code>它，这是合理的，因为任何网络请求都可能失败。</p>
<p>在上面示例代码中<code>withCheckedThrowingContinuation</code>是一个可能抛出错误的异步函数，因此我们在调用的时候使用了<code>try await</code>。当<code>fetchUserInfo</code>成功获取到<code>userInfo</code>时，我们调用<code>continuation.resume(returning: user)</code>来唤起<code>continuation</code>，当发生错误时使用<code>continuation.resume(throwing: err)</code>来抛出异常。</p>
<p>除了使用<code>withCheckedThrowingContinuation</code>创建<code>continuation</code>，还有其它三种方式创建<code>continuation</code>，即共有4种方法来创建的<code>continuations</code>：</p>
<ul>
<li>
<p><code>withCheckedThrowingContinuation</code></p>
</li>
<li>
<p><code>withCheckedContinuation</code></p>
</li>
<li>
<p><code>withUnsafeThrowingContinuation</code></p>
</li>
<li>
<p><code>withUnsafeContinuation</code></p>
</li>
</ul>
<p>当原始的闭包代码根本不返回任何错误时，使用<code>withCheckedContinuation</code>。不安全的变体，<code>withUnsafeThrowingContinuation</code>和 <code>withUnsafeContinuation</code> ，与对应的Checked项类似。主要区别是，当使用<code>Checked Continuations</code>时，Swift会在遇到任何违规情况（如多次调用<code>continuations</code>或完全忘记调用<code>continuation</code>）时通过记录错误来帮助保护你。</p>
<p>不安全<code>continuations</code>没有这些功能，但它们可能稍微快一点。总的来说，不建议使用不安全<code>continuations</code>，但也请注意，大多数情况下，可以互换使用它们。</p>
<h3 id="converting-delegate-based-code-into-asyncawait">Converting delegate-based code into async/await</h3>
<p>将基于委托的代码转换为<code>async/await</code>是一个更复杂的过程，因为这些类型的API可能会根据发生的事件类型调用不同的<code>delegate</code>方法。基于代理的API可能非常混乱，尤其是当它们有大量可能的方法调用时。</p>
<p>在下面示例中，我们可以为调用者创建一个更简洁的API，通过围绕CNContactPickerViewControllerDelegate及其方法创建一个包装对象来实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#75715e">// 原实现</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">promptContact</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> picker = CNContactPickerViewController()
</span></span><span style="display:flex;"><span>    picker.delegate = <span style="color:#66d9ef">self</span>
</span></span><span style="display:flex;"><span>    picker.displayedPropertyKeys = [CNContactGivenNameKey, CNContactNamePrefixKey, CNContactNameSuffixKey]
</span></span><span style="display:flex;"><span>    present(picker, animated: <span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 改造后的实现</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">promptContact</span>() {
</span></span><span style="display:flex;"><span>    async {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> contactPicker = ContactPicker(viewController: <span style="color:#66d9ef">self</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> contact = await contactPicker.pickContact() {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Contact selected…</span>
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Selection Cancelled…</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">import</span> <span style="color:#a6e22e">Foundation</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">import</span> <span style="color:#a6e22e">ContactsUI</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ContactPicker</span>: NSObject, CNContactPickerDelegate {
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">typealias</span> ContactCheckedContinuation = CheckedContinuation&lt;CNContact?, Never&gt;
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">unowned</span> <span style="color:#66d9ef">var</span> viewController: UIViewController 
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">/// 存储Continuation，在代理方法调用的时候以便它调用</span>
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">var</span> contactContinuation: ContactCheckedContinuation? 
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">var</span> picker: CNContactPickerViewController
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">init</span>(viewController: UIViewController) { 
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">self</span>.viewController = viewController 
</span></span><span style="display:flex;"><span>     picker = CNContactPickerViewController() 
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">super</span>.<span style="color:#66d9ef">init</span>() 
</span></span><span style="display:flex;"><span>     picker.delegate = <span style="color:#66d9ef">self</span> 
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  @MainActor <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">pickContact</span>() async -&gt; CNContact? { 
</span></span><span style="display:flex;"><span>    viewController.present(picker, animated: <span style="color:#66d9ef">true</span>) 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> await withCheckedContinuation({ (continuation: ContactCheckedContinuation) <span style="color:#66d9ef">in</span> 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.contactContinuation = continuation 
</span></span><span style="display:flex;"><span>     }) 
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  @MainActor 
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">contactPicker</span>(<span style="color:#66d9ef">_</span> picker: CNContactPickerViewController, didSelect contact: CNContact) {
</span></span><span style="display:flex;"><span>    contactContinuation?.resume(returning: contact)
</span></span><span style="display:flex;"><span>    contactContinuation = <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>    picker.dismiss(animated: <span style="color:#66d9ef">true</span>, completion: <span style="color:#66d9ef">nil</span>) 
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  @MainActor 
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">contactPickerDidCancel</span>(<span style="color:#66d9ef">_</span> picker: CNContactPickerViewController) {
</span></span><span style="display:flex;"><span>    contactContinuation?.resume(returning: <span style="color:#66d9ef">nil</span>)
</span></span><span style="display:flex;"><span>    contactContinuation = <span style="color:#66d9ef">nil</span> 
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面代理方法的contactPicker和contactPickerDidCancel执行时，都可以恢复<code>contactContinuation</code>，要么在取消选人的时候传递nil，要么在选择人后传递contact。下面是调用<code>ContactPicker</code>的示例代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">promptContact</span>() {
</span></span><span style="display:flex;"><span>    Task {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> contactPicker = ContactPicker(viewController: <span style="color:#66d9ef">self</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> contact = await contactPicker.pickContact() {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> nameFormatter = CNContactFormatter()
</span></span><span style="display:flex;"><span>            nameFormatter.style = .fullName
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> contactName = nameFormatter.string(from: contact)
</span></span><span style="display:flex;"><span>            selectedContactLabel.text = contactName
</span></span><span style="display:flex;"><span>            selectedContactLabel.textColor = .black
</span></span><span style="display:flex;"><span>            selectedContactLabel.isHidden = <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            selectedContactLabel.text = <span style="color:#e6db74">&#34;Cancelled&#34;</span>
</span></span><span style="display:flex;"><span>            selectedContactLabel.textColor = .red
</span></span><span style="display:flex;"><span>            selectedContactLabel.isHidden = <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>经过<code>ContactPicker</code>封装后，原先的<code>ViewController</code>中的代码就减少了很多，类就变得小很多。虽然我们成功为基于代理的调用提供了<code>async/await</code>版本，这确实很棒，但应该考虑这样做是否真的有必要。有时，基于委托的调用（如<code>CoreBluetooth、CoreLocation</code>）的复杂性可能不值得为其提供<code>async/await</code>版本。</p>
<h3 id="supporting-asyncawait-in-ios-13-and-14">Supporting async/await in iOS 13 and 14</h3>
<p>之前有提到过，虽然在Xcode 13.3中就可以使用<code>async/await</code>，但当时苹果没有提供系统库的<code>async</code>版本，直到使用iOS 15才开始提供。因此，为了兼容iOS 13和14系统，建议扩展系统库方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">extension</span> <span style="color:#a6e22e">LAContext</span> {
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    @available(iOS, introduced: <span style="color:#ae81ff">13</span>, deprecated: <span style="color:#ae81ff">15</span>, message: <span style="color:#e6db74">&#34;This method is no longer necessary. Use the API available in iOS 15.&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">evaluatePolicy</span>(<span style="color:#66d9ef">_</span> policy: LAPolicy, localizedReason: String) async <span style="color:#66d9ef">throws</span> -&gt; Bool {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> await withCheckedThrowingContinuation({ continuation <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">self</span>.evaluatePolicy(policy, localizedReason:localizedReason) { success, error <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> error = error {
</span></span><span style="display:flex;"><span>                    continuation.resume(throwing: error)
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                    continuation.resume(returning: success)
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        })
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>下面是一段无关代码封装：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>actor SharedAsyncNetworkManager {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> shared = SharedAsyncNetworkManager()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">var</span> currentTask: Task&lt;Data, Error&gt;?
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fetchData</span>() async <span style="color:#66d9ef">throws</span> -&gt; Data {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> existingTask = currentTask {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">try</span> await existingTask.value
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> task = Task&lt;Data, Error&gt; {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">defer</span> { currentTask = <span style="color:#66d9ef">nil</span> }
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> url = URL(string: <span style="color:#e6db74">&#34;https://api.example.com/data&#34;</span>)<span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> (data, <span style="color:#66d9ef">_</span>) = <span style="color:#66d9ef">try</span> await URLSession.shared.data(from: url)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> data
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        currentTask = task
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">try</span> await task.value
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">clearCache</span>() {
</span></span><span style="display:flex;"><span>        currentTask = <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="structured-concurrency">Structured Concurrency</h2>
<p>截至目前，我们已经讨论了<code>async/await</code>是什么以及它是如何工作的。也已经看到这种新工具如何帮助我们编写结构化代码，使其类似于过程式编程。使用它能够摆脱那些破坏代码线性可读性的其它类型的回调，例如闭包和委托。但我们也已经看到，所有这些代码实际上并不是同时运行、并发或多线程执行的。</p>
<p>我们定义并发为：一个线程（或你的程序）同时处理多件事情的能力。这个定义并不严格意味着同时做多件事，通常人们谈到并发时，实际上指的是多线程或并行。为了与社区对这个词的定义保持一致，当我们谈到并发时，指的是同时执行多个任务。</p>
<h3 id="understanding-structured-concurrency">Understanding Structured Concurrency</h3>
<p>结构化并发遵循结构化编程的相同理念。即<font color="#de7802">按照我们预期的顺序编写代码，并看到可预测（或至少半可预测）的结果</font>。与基于闭包的代码不同，变量具有明确定义的作用域，可以预期代码不会跳转到破坏代码阅读流程的其它地方。这使得我们无需关心诸如内存管理等其它细节（块中捕获的变量会怎样？闭包能否被保留？“weak self”等）。</p>
<p>在结构化并发中，<font color="#de7802">可以同时运行多个代码路径，并得到可预测的结果</font>，而无需思考那些跳转多个基于闭包调用的代码迷宫。在新的async/await系统，提供了两种方式构建结构化并发：async let构造和task groups。</p>
<h3 id="the-async-let-construct">The async let construct</h3>
<p><code>async let</code>构造也被称为也称为<code>async let</code>绑定。下面代码段都是使用<code>async let</code>构建结构化并发，仅在<code>return</code>这一行有区别，但它们的效果是一样的，且第二种方式更简洁：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fetchData</span>() async <span style="color:#66d9ef">throws</span> -&gt; (userInfo: UserInfo, followers: UserInfo) {
</span></span><span style="display:flex;"><span>    async <span style="color:#66d9ef">let</span> userInfo = fetchUserInfo()
</span></span><span style="display:flex;"><span>    async <span style="color:#66d9ef">let</span> followers = fetchFellows()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">try</span> await userInfo, <span style="color:#66d9ef">try</span> await followers)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fetchData</span>() async <span style="color:#66d9ef">throws</span> -&gt; (userInfo: UserInfo, followers: UserInfo) {
</span></span><span style="display:flex;"><span>    async <span style="color:#66d9ef">let</span> userInfo = fetchUserInfo()
</span></span><span style="display:flex;"><span>    async <span style="color:#66d9ef">let</span> followers = fetchFellows()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">try</span> await(userInfo, followers)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>需要注意的是，await关键字是一个挂起点，这意味着fetchUserInfo和fetchFellows<font color="#de7802">都返回或其中一个抛出一个错误之前，函数都是被挂起的</font>。</p>
<p>之前有说过，每一次async调用必须有与之对应的await，但并不要求async和await必须在同一行。<font color="#de7802">使用async let时，当需要使用在async let中赋值的变量的值时，才需要使用await关键字</font>。因此，如果你的<code>async let</code>调用返回一个其它函数依赖的值，就在调用处使用await。如果需要在函数内部并发获取多个值，可以在返回语句处直接使用await。规定async调用必须与await关键字配对的规则并未被违反。</p>
<p>使用<code>aync let</code>是非常有用的，可以在任何地方使用await关键字，如单个变量声明，或在等待数组元素时，或者像上面示例在返回元组之前等场景。</p>
<p>需要特别注意的是，虽然我们使用<code>async let</code>构造来明确表达同时运行任务的意图，但依然由<font color="#de7802">系统决定是否真的并行运行你的代码，或是否为多个调用复用另一个线程</font>。也就是说，系统可能会决定在不同的但共享的线程中运行fetchUserInfo和fetchFollowingAndFollowers，实际上是以串行方式运行，远离主线程。</p>
<h3 id="task-groups">Task Groups</h3>
<p>若预先知道有多个并发量，使用<code>async let</code>来构建是非常理想的选择。但有时我们事先并不知道完成某个任务有多少个并发量。为了应对这种场景，<code>async/await</code>系统提供了<code>task groups</code>。</p>
<p>任务组是一种结构化的并发工具，允许我们同时运行未知数量的（可能）并发任务，但要求这些任务是相关的。如果有太多任务，Swift不会一次性运行所有任务，它会对任务进行优先级排序，尽可能多地并发运行。</p>
<h4 id="task-groups-in-action">Task Groups in Action</h4>
<p>为了创建任务组，可以使用<code>withTaskGroup</code>和<code>withThrowingTaskGroup</code>函数。如同创建<code>continuations</code>一样，创建任务组也有区分是否抛出异常。</p>
<p>需要注意的是，一个计算机系统并没有无限数量的线程。即在下面示例代码中，任务组会尽最大努力并行下载所有图片，但会先进行优化和优先级排序。如果一次处理大量并发任务，任务组可能会将任务排队以待稍后执行，并不一定会同时执行所有任务。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ServerImage</span>: Codable {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> imageName: String
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> url: URL
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">download</span>(serverImages: [ServerImage]) async <span style="color:#66d9ef">throws</span> -&gt; [URL] {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> urls: [URL] = []
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> await withThrowingTaskGroup(of: URL.<span style="color:#66d9ef">self</span>) { group <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> image <span style="color:#66d9ef">in</span> serverImages {
</span></span><span style="display:flex;"><span>            group.addTask(priority: .userInitiated) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> imageUrl = <span style="color:#66d9ef">try</span> await <span style="color:#66d9ef">self</span>.download(image)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> imageUrl
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">try</span> await imageUrl <span style="color:#66d9ef">in</span> group { 
</span></span><span style="display:flex;"><span>          urls.append(imageUrl)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> urls
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fetchImageList</span>() async <span style="color:#66d9ef">throws</span> -&gt; [ServerImage] {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> (data, <span style="color:#66d9ef">_</span>) = <span style="color:#66d9ef">try</span> await URLSession.shared.data(from: imageListURL)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> urls = <span style="color:#66d9ef">try</span> jsonDecoder.decode([ServerImage].<span style="color:#66d9ef">self</span>, from: data)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> urls
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">download</span>(<span style="color:#66d9ef">_</span> serverImage: ServerImage) async <span style="color:#66d9ef">throws</span> -&gt; URL {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> fileManager = FileManager.<span style="color:#66d9ef">default</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> tmpDir = fileManager.temporaryDirectory
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> (downloadedImageUrl, <span style="color:#66d9ef">_</span>) = <span style="color:#66d9ef">try</span> await URLSession.shared.download(from: serverImage.url)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// If the destination already exists, remove it.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> destinationUrl = tmpDir.appendingPathComponent(serverImage.imageName) 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span>? fileManager.removeItem(at: destinationUrl)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> fileManager.moveItem(at: downloadedImageUrl, to: destinationUrl)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> destinationUrl
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>不管是使用withTaskGroup还是withThrowingTaskGroup创建任务组，都需要指定该任务组产生的数据类型。在上面示例中，任务组产生的是URL数组。在withTaskGroup和withThrowingTaskGroup的闭包中，参数group就是任务组本身。往任务组添加任务使用addTask方法，任务提交后立即开始执行。</p>
<p>需要特别注意的是，<font color="#de7802">添加到组中的任务可能不会按照提交顺序执行</font>。如果想使用任务组，重要的是要以使顺序无关的方式设计你的代码。</p>
<p><code>group</code>本身是一个集合，因此不仅可以使用<code>for-in</code>遍历它，还可以使用<code>filter、map、reduce</code>这样的高阶函数来处理结果。而且，<code>for</code>循环中也可以使用<code>await</code>关键字来处理随时间发出值的代码。</p>
<p>还需要注意的是，只要任务组中的一个任务出现错误，这个任务组就会抛出异常。请记住这一点，因为它可能导致意想不到的行为，如果你认为你的图片下载会失败，那么在这个特定项目中为下载任务提供一个默认图片可能是个好主意。</p>
<h2 id="unstructured-concurrency">Unstructured Concurrency</h2>
<p>非结构化并发在牺牲较少可用性的同时提供了更多的灵活性。在处理无结构并发时，代码<font color="#de7802">不一定遵循我们所喜爱的自上而下的结构</font>。幸运的是，处理无结构并发仍然非常容易，这种灵活性不会显著增加程序的复杂性。</p>
<h3 id="tasks-in-depth">Tasks in Depth</h3>
<p>对于无结构的并发，依然是使用<code>Task</code>对象。<code>Task</code>是一个很重要的对象，它允许我们做两件非常重要的事情：</p>
<ul>
<li>创建<code>Task</code>后，它就会<font color="#de7802">异步启动闭包中的代码</font>。</li>
<li>它创建了一个并发上下文，使我们<font color="#de7802">能够以调用async方法的方式使用并发功能</font>。</li>
</ul>
<h3 id="creating-tasks">Creating Tasks</h3>
<p>Task是一个对象，它可以存储值和错误。要创建一个异步、非结构的任务，我们调用Task并使用一个闭包初始化它，这个闭包是我们想要异步执行的代码。下面示例代码是使用<code>Task</code>调用<code>async</code>方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">authenticateAndFetchProfile</span>() {
</span></span><span style="display:flex;"><span>    Task {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> userProfile = <span style="color:#66d9ef">try</span> await fetchUserInfo()
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>        debugPrint(userProfile)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fetchUserInfo</span>() async -&gt; String {
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;fetchUserInfo&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;Return Test&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>当我们想使用<code>Task</code>做并发时，拥有的第一项灵活性是设置优先级，优先级是<code>Task.Priority</code>（与处理任务组时使用的优先级相同）。下面是可使用的优先级列表：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> background: TaskPriority
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> high: TaskPriority
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> low: TaskPriority
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">var</span> medium: TaskPriority
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> userInitiated: TaskPriority
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> utility: TaskPriority
</span></span></code></pre></div><p><code>Task</code>是一个对象，你可以使用变量存储它，这就是被称为非机构并发的部分原因。我们可以有多个Task，存储在多个变量中（甚至存储在一个<code>collections</code>中）。在非机构化并发中，可以取消Task，但在结构化的Task无法做到这一点：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">authenticate</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> authenticationTask = Task&lt;Bool, Error&gt; {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> context = LAContext()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> policy = LAPolicy.deviceOwnerAuthenticationWithBiometrics
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">try</span> await context.evaluatePolicy(
</span></span><span style="display:flex;"><span>            policy, localizedReason: <span style="color:#e6db74">&#34;To log in&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 取消Task</span>
</span></span><span style="display:flex;"><span>    authenticationTask.cancel()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在上面示例代码中，我们定义变量的类型为<code>Task&lt;Bool, Error&gt;</code>，这是因为<code>context.evaluatePolicy</code>返回一个<code>Bool</code>值，也可能抛出一个<code>Error</code>。</p>
<p>我们可以await某个Task的值。在下面示例代码中，需要使用<code>try await</code>，这是因为我们定义的authenticationTask可能返回一个Bool值，也可能抛出一个错误。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">authenticate</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> authenticationTask = Task&lt;Bool, Error&gt; {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> context = LAContext()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> policy = LAPolicy.deviceOwnerAuthenticationWithBiometrics
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">try</span> await context.evaluatePolicy(
</span></span><span style="display:flex;"><span>            policy, localizedReason: <span style="color:#e6db74">&#34;To log in&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    Task {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> status = <span style="color:#66d9ef">try</span> await authenticationTask.value
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> status {
</span></span><span style="display:flex;"><span>            debugPrint(<span style="color:#e6db74">&#34;sucess&#34;</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>需要注意的是，上面示例代码创建Task时，并没有使用<code>do-catch</code>语句体。上面代码隐式地创建了一个<code>Task&lt;(), Error&gt;</code>类型的任务，因为Task中不返回任何值，但会抛出异常。<font color="#de7802">Task不需要显式的do-catch语句体，因为闭包会自动捕获Error</font>。</p>
<p>当在代码中使用<code>Task {}</code>创建一个新任务时，它将继承产生这个任务的上下文信息。继承的信息包括任务运行的<code>Actor</code>（如果在<code>@MainActor</code>上运行的任务中产生了任务，那么该任务也将在<code>@MainActor</code>上运行）和优先级。如果新生成的任务是一个根任务（它创建了一个异步上下文，但其本身并不在其中运行），那么它将继承其所运行线程的<code>Actor</code>。</p>
<h3 id="the-task-tree">The Task Tree</h3>
<p>Swift中的新并发系统由一种称为任务树的基础结构驱动。正如名称所示，任务树为我们提供了一种并发在后台如何运作的思维模型。任务树决定了任务如何与其它任务关联运行。它还控制数据如何传递给子任务。之前我们提到过，<font color="#de7802">一个任务会从启动它的任务那里继承<code>actor</code>、优先级和任务局部变量</font>。这要归功于任务树。任务会生成子任务，而这些子任务会从父任务那里继承所有这些属性。</p>
<p>下面代码中，直觉上我们会认为每个<code>async let</code>调用会隐式地启动一个新任务，但事实并非如此。每个<code>async let</code>调用会启动一个新的子任务。这个区别很重要，<strong><font color="#de7802">因为<code>Task</code>只能显式创建</font></strong>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fetchData</span>() async <span style="color:#66d9ef">throws</span> -&gt; (userInfo: UserInfo, followers: UserInfo) {
</span></span><span style="display:flex;"><span>    async <span style="color:#66d9ef">let</span> userInfo = fetchUserInfo()
</span></span><span style="display:flex;"><span>    async <span style="color:#66d9ef">let</span> followers = fetchFellows()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">try</span> await(userInfo, followers)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>每个子任务都会继承我们之前从父任务接受的信息（在上面这种情况下，父任务就是<code>fetchData()</code>函数本身），这些信息包括actor，priority和局部变量。</p>
<p>当在一个Task中创建一个新Task，它还将继承父Task的属性，但与隐式任务不同，可以根据自己的需求稍作调整，例如以不同的优先级生成该新Task。</p>
<p>任务树的另一个需要特别注意的是：<strong><font color="#de7802">父任务只有在其所有子任务都完成工作后才能完成</font></strong>。即使终止是不成功（即抛出了错误），它仍然是一个终止，当出现这种异常情况时，任务也可以完成。</p>
<h3 id="error-propagation">Error Propagation</h3>
<p>fetchData本身可能会抛出异常，它所生成的所有子任务也是如此。假设fetchUserInfo出现了错误，如果函数抛出错误，<font color="#de7802">那么函数会在该点停止执行，将错误传递给调用者，并且不会执行该点之后的任何代码</font>。到目前为止，这正是若完全不使用新的并发系统时所发生的情况。这就是Swift（以及许多其他编程语言）中的错误传播机制。</p>
<p>但当使用新的并发系统时，情况并不那么直观。<code>fetchUserInfo</code>可能会抛出错误，但<code>fetchFollowingAndFollowers</code>可能正常完成并返回预期的值。如果发生错误，它将沿着任务树向上传播，直到到达调用者。任何其它正在等待或并发运行的子任务将被标记为已取消。</p>
<h3 id="task-cancellation">Task Cancellation</h3>
<p>任务取消是非常重要的，但它的运作方式和我们第一眼看到的有所不同。如果重新阅读上一段的最后一句话，会发现我们说的是这些任务“将被标记为已取消”。</p>
<p>在新的并发系统，任务取消是协作式的。取消一个任务仅仅意味着你通知它打算取消它。任务本身需要找到一个合适的时间点来终止自己，而你需要自行实现这一逻辑。</p>
<p>任务取消之所以是协作式的，是因为存在一些敏感但重要的任务，它们可能无法接受被强制终止执行。如果你正在一个并发任务中写入数据库或者修改用户文件，突然取消它可能会导致用户数据损坏。</p>
<p>若一个任务被取消掉，那么它的所有子任务也会被标记为被取消，这样是试图确保不会进行不必要的工作。</p>
<h3 id="task-cancellation-and-task-groups">Task Cancellation and Task Groups</h3>
<p>理解结构化并发与任务组可以使你的代码<font color="#de7802">向调用者返回部分结果而不是完整集合非常重要</font>。接下来分析下面的代码段：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">download</span>(serverImages: [ServerImage]) async <span style="color:#66d9ef">throws</span> -&gt; [URL] {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> urls: [URL] = []
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> await withThrowingTaskGroup(of: URL.<span style="color:#66d9ef">self</span>) { group <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> image <span style="color:#66d9ef">in</span> serverImages {
</span></span><span style="display:flex;"><span>            group.addTask(priority: .userInitiated) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> imageUrl = <span style="color:#66d9ef">try</span> await <span style="color:#66d9ef">self</span>.download(image)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> imageUrl
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">try</span> await imageUrl <span style="color:#66d9ef">in</span> group { 
</span></span><span style="display:flex;"><span>          urls.append(imageUrl)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> urls
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果有10张图片需要下载，并且在所有图片下载完成之前发生错误（或者你调用group.cancelAll()取消任务组）, urls数组将包含一个不完整的部分结果，只包含它在异常退出之前成功下载的图片。请确保你记录下这种行为，因为调用你代码的用户可能不了解这一点，从而导致他们的程序出现意外行为。</p>
<h3 id="unstructured-concurrency-with-detached-tasks">Unstructured Concurrency with Detached Tasks</h3>
<p>任务树确保任务继承一些来自父任务的属性，例如优先级，<code>actor</code>和局部变量。完全<font color="#de7802">有可能从一个不继承任何父任务属性的任务启动另一个任务，这些任务被称为分离任务</font>。当需要非严格相关的并发时，它们非常有用。例如，从互联网下载图片可以是一个任务，之后可能希望将这些图片存储到本地缓存中。将图片存储到本地缓存的过程可以是一个分离任务，这样即使该任务被取消，但图片已经下载完成，缓存保存操作仍能顺利进行而不会出现问题。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>Task.detached(priority: .low) { 
</span></span><span style="display:flex;"><span>  imageManager.writeImageToCache(image) 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面创建了一个分离任务，从语法上看，和标准任务之间没有太大区别，但<font color="#de7802">在使用它们时要注意任务树和继承属性</font>。指定优先级是可选的，就像在使用普通任务时一样。</p>
<h2 id="actors">Actors</h2>
<p>运行一些任务时，经常看到将结果传递到主线程，但有一些情况，需要在程序中使用共享的可变状态——一个可以被代码读取和写入的公共可变资源。这个资源可以是一个简单的变量，也可以是一个文件，或者任何其它类型的资源，这些资源在并发访问时是危险的，但又需要在多个任务之间同时可用。</p>
<p>如果你有多段代码能访问一个只读资源，程序不会出现问题，此时也不必担心数据损坏。但如果你有多个任务，并且其中至少一个可以向共享资源写入数据，那就可能出现问题，这种情况被称为数据竞争。数据竞争是十分危险的。</p>
<p>如果多段代码可以同时写入一个文件，就会导致数据损坏。如果多个任务从该资源中读取数据，它们都会得到垃圾数据，这些数据甚至可能与它们试图读取的数据不同。最糟糕的是，如果你在底层编写并发代码，引入数据竞争非常容易，而且调试起来也非常困难。</p>
<p>因此，如果使用的是值语义（结构体或枚举），就不会遇到这个问题。值语义是只读的，如果它们发生变异，就会创建一个副本，所有的变异都只作用于该变量。每个任务都会操作不同的数据副本，尽管这可能不是你想要的结果。</p>
<h3 id="introducing-actors">Introducing Actors</h3>
<p>Actor是Swift中引入的一种新的引用类型，由新的并发模型支持。Actor会将自身的状态与程序的其余部分隔离，并对外部访问可变状态提供同步保护。简单来说，如果一个Actor包含一个可被多个任务读写的基本变量，那么 Actor会确保同一时间只有一个任务能够执行该操作，从而保证对特定资源的互斥访问。</p>
<p>每一次访问可变状态都必须通过actor来完成。声明一个Actor非常简单，只需使用<code>actor</code> 关键字并为其命名，这与声明结构体（<code>struct</code>）或类（<code>class</code>）非常相似。作为引用类型，actor具备许多与类相似的功能：它们可以遵循协议（<code>protocol</code>），也能通过扩展（<code>extension</code>）获得更多功能。与类的主要区别在于，actor会隔离自身状态。一个actor可能会挂起零次或多次（即在其方法内部包含其它<code>await</code>调用），因此可以轻松将Actor与Swift的其它新并发系统组件集成。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">countGames</span>(by company: String) -&gt; Int { <span style="color:#66d9ef">let</span> games = fetchGames(by: company) <span style="color:#66d9ef">return</span> games.count }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">add</span>(games: [Videogame]) { <span style="color:#66d9ef">self</span>.videogames.append(contentsOf: games) }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fetchGames</span>(by year: Int) -&gt; [Videogame] { <span style="color:#66d9ef">let</span> games = videogames.filter { $0.releaseYear == year } <span style="color:#66d9ef">return</span> games }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
    </div>
    <footer class="post-footer">
        
 
<div class="post-tags">     
     
    <a href="https://iihui.github.io/tags/ios" rel="tag" title="iOS">#iOS#</a>
    
</div>



        <div class="post-nav">
    <div class="post-nav-next post-nav-item">
    
        <a href="https://iihui.github.io/post/oc-tour/" rel="next" title="OC 入门">
        <i class="fa fa-chevron-left"></i> OC 入门
        </a>
    
    </div>

    <div class="post-nav-prev post-nav-item">
    
        <a href="https://iihui.github.io/post/js-data-struct/" rel="prev" title="JavaScript 数据类型">
        JavaScript 数据类型 <i class="fa fa-chevron-right"></i>
        </a>
    
    </div>
</div>
      
        <div class="post-nav">
    <div style="border: 1px dashed #e0e0e0; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
        <div style="float:left;margin-top:0px;">
            <img src="https://i.loli.net/2020/02/09/SvhUdz4XJsOr9Vk.jpg" width="128px" height="128px"/>
            <div style="text-align:center;">谢谢支持!</div>
        </div>
        <div>
            <p style="margin-top:10px;">
                标题：swift中的方法
                <br />作者：阿呆<a target="_blank" href="https://iihui.github.io/"></a>
                
                <br />地址：https://iihui.github.io/post/swift-method/
                <br />声明：自由转载-非商用-保持署名（创作共享4.0许可证）
            </p>
        </div>
    </div>
    <div class="clear"></div>
</div>
        
        
        




    </footer>
  </article>
</section>

          </div>
        </div>
        <div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>
<aside id="sidebar" class="sidebar">
  <div class="sidebar-inner">

  <ul class="sidebar-nav motion-element">
    <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
      文章目录
    </li>
    <li class="sidebar-nav-overview" data-target="site-overview">
      站点概览
    </li>
  </ul>

    <section class="site-overview sidebar-panel ">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
        src="https://i.loli.net/2020/02/07/dVFzrvZkHRNq2lL.jpg"
        alt="" />
    <p class="site-author-name" itemprop="name"></p>
    <p class="site-description motion-element" itemprop="description"> 
        coder &amp; cook</p>
</div>
      <nav class="site-state motion-element">
    <div class="site-state-item site-state-posts">
      <a href="https://iihui.github.io/post/">
        <span class="site-state-item-count">143</span>
        <span class="site-state-item-name">日志</span>
      </a>
    </div>
    <div class="site-state-item site-state-categories">    
        <a href="https://iihui.github.io/categories/">      
         
        <span class="site-state-item-count">18</span>
        
        <span class="site-state-item-name">分类</span>
        
        </a>
    </div>

    <div class="site-state-item site-state-tags">
        <a href="https://iihui.github.io/tags/">
         
        <span class="site-state-item-count">29</span>
        
        <span class="site-state-item-name">标签</span>
        </a>
    </div>
</nav>
      
      
<div class="links-of-author motion-element">
    
        <span class="links-of-author-item">
        <a href="https://coolshell.cn" target="_blank" title="皓 大">
            <i class="fa fa-fw fa-globe"></i>
            皓 大
        </a>
        </span>
    
        <span class="links-of-author-item">
        <a href="http://www.ruanyifeng.com" target="_blank" title="阮 大">
            <i class="fa fa-fw fa-globe"></i>
            阮 大
        </a>
        </span>
    
        <span class="links-of-author-item">
        <a href="https://juejin.im/" target="_blank" title="掘 金">
            <i class="fa fa-fw fa-globe"></i>
            掘 金
        </a>
        </span>
    
</div>


      

      <div class="links-of-blogroll motion-element inline">
<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=&amp;m=0&amp;s=220&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;bv=35" async="async"></script>
</div>

    </section>
    
<section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
    <div class="post-toc">
        <div class="post-toc-content"><nav id="TableOfContents">
  <ul>
    <li><a href="#实例方法">实例方法</a>
      <ul>
        <li><a href="#异变方法">异变方法</a></li>
        <li><a href="#self属性">self属性</a></li>
      </ul>
    </li>
    <li><a href="#类型方法">类型方法</a></li>
    <li><a href="#modern-concurrency">Modern Concurrency</a>
      <ul>
        <li><a href="#introducing-asyncawait">Introducing async/await</a>
          <ul>
            <li><a href="#the-async-keyword">The async keyword</a></li>
            <li><a href="#the-await-keyword">The await keyword</a></li>
            <li><a href="#using-asyncawait">Using async/await</a></li>
            <li><a href="#async-get-properties">async get properties</a></li>
            <li><a href="#asyncawait-in-ios-13-and-ios-14">async/await in iOS 13 and iOS 14</a></li>
          </ul>
        </li>
        <li><a href="#continuations">Continuations</a>
          <ul>
            <li><a href="#understanding-continuations">Understanding Continuations</a></li>
            <li><a href="#converting-closure-based-calls-into-asyncawait">Converting closure-based calls into async/await</a></li>
            <li><a href="#converting-delegate-based-code-into-asyncawait">Converting delegate-based code into async/await</a></li>
            <li><a href="#supporting-asyncawait-in-ios-13-and-14">Supporting async/await in iOS 13 and 14</a></li>
          </ul>
        </li>
        <li><a href="#structured-concurrency">Structured Concurrency</a>
          <ul>
            <li><a href="#understanding-structured-concurrency">Understanding Structured Concurrency</a></li>
            <li><a href="#the-async-let-construct">The async let construct</a></li>
            <li><a href="#task-groups">Task Groups</a>
              <ul>
                <li><a href="#task-groups-in-action">Task Groups in Action</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#unstructured-concurrency">Unstructured Concurrency</a>
          <ul>
            <li><a href="#tasks-in-depth">Tasks in Depth</a></li>
            <li><a href="#creating-tasks">Creating Tasks</a></li>
            <li><a href="#the-task-tree">The Task Tree</a></li>
            <li><a href="#error-propagation">Error Propagation</a></li>
            <li><a href="#task-cancellation">Task Cancellation</a></li>
            <li><a href="#task-cancellation-and-task-groups">Task Cancellation and Task Groups</a></li>
            <li><a href="#unstructured-concurrency-with-detached-tasks">Unstructured Concurrency with Detached Tasks</a></li>
          </ul>
        </li>
        <li><a href="#actors">Actors</a>
          <ul>
            <li><a href="#introducing-actors">Introducing Actors</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav></div>
    </div>
</section>

  </div>
</aside>

      </div>
    </main>
   
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  <span itemprop="copyrightYear">  &copy; 
  2017 - 2025</span>
  <span class="with-love"><i class="fa fa-heart"></i></span>
  <span class="author" itemprop="copyrightHolder">Keep It Simple</span>
</div>




      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      <span id="scrollpercent"><span>0</span>%</span>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/jquery/index.js?v=2.1.3"></script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script> 
<script type="text/javascript" src="https://iihui.github.io/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/velocity/velocity.min.js?v=1.2.1"></script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="https://iihui.github.io/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>

<script src="https://iihui.github.io/js/vendor/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>

<script type="text/javascript" src="https://iihui.github.io/js/utils.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/motion.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/affix.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/schemes/pisces.js"></script>

<script type="text/javascript" src="https://iihui.github.io/js/scrollspy.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/post-details.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/toc.js"></script>

<script type="text/javascript" src="https://iihui.github.io/js/bootstrap.js"></script>

<script type="text/javascript" src="https://iihui.github.io/js/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
</body>
</html>