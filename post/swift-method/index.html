<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
    <title>swift中的方法 - Keep It Simple</title>
    <meta name="keywords" content="博客,思考,读书,笔记,技术,分享">
    
    <meta property="og:title" content="swift中的方法">
    <meta property="og:site_name" content="Keep It Simple">
    <meta property="og:image" content="/img/author.jpg"> 
    <meta name="title" content="swift中的方法 - Keep It Simple" />
    <meta name="description" content="Swift | Go | C&#43;&#43; "> 
    <link rel="shortcut icon" href="https://iihui.github.io/img/favicon.ico" />
    <link rel="apple-touch-icon" href="https://iihui.github.io/img/apple-touch-icon.png" />
    <link rel="apple-touch-icon-precomposed" href="https://iihui.github.io/img/apple-touch-icon.png" />
    <link href="https://iihui.github.io/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />
    <link href="https://iihui.github.io/js/vendor/fancybox/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />
    <link href="https://iihui.github.io/css/main.css" rel="stylesheet" type="text/css" />
    <link href="https://iihui.github.io/css/syntax.css" rel="stylesheet" type="text/css" />

    <script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
     fancybox: true, 
    motion: true
  };
</script>

    <link href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/monokai-sublime.min.css" rel="stylesheet">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/go.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/swift.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/objectivec.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/clojure.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/kotlin.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/yaml.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<div class="container one-collumn sidebar-position-left page-home  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-meta  custom-logo ">

  <div class="custom-logo-site-title">
    <a href="https://iihui.github.io/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Keep It Simple</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">靡不有初，鲜克有终</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
    <ul id="menu" class="menu">
      
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/tags/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-tag"></i> <br />标签
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/post/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/categories/%E7%BE%8E%E9%A3%9F/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-fire"></i> <br />美食
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/categories/%E5%90%8E%E6%9C%9F/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-edit"></i> <br />后期
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/categories/%E6%97%85%E8%A1%8C/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-leaf"></i> <br />旅行
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/about/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于
          </a>
        </li>
      
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger"> <i class="menu-item-icon fa fa-search fa-fw"></i> <br /> 搜索</a>
      </li>
    </ul>
    <div class="site-search">
      <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>

    </div>
</nav>
<script type="text/javascript"
        async
        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
		<!-- src = "http://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> <\!--  -\-> -->
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>

<!DOCTYPE html>
<html lang="en">


<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css" integrity="sha384-D+9gmBxUQogRLqvARvNLmA9hS2x//eK1FhVb9PiU86gmcrBrJAQT8okdJ4LMp2uv" crossorigin="anonymous">

    
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js" integrity="sha384-483A6DwYfKeDa0Q52fJmxFXkcPCFfnXMoXblOkJ4JcA8zATN6Tm78UNL72AKk+0O" crossorigin="anonymous"></script>
</head>
<body>

</body>
</html>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
<section id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="https://iihui.github.io/post/swift-method/" itemprop="url">
        swift中的方法
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">创建: </span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2018-09-14">
    2018-09-14
</time>
</span>
&nbsp; | &nbsp;
<span class="post-updated-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-check-o"></i>
</span>
<span class="post-meta-item-text">更新: </span>
<time itemprop="dateUpdated" content="2018-09-14">
    2018-09-14
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类: </span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="https://iihui.github.io/categories/code" itemprop="url" rel="index">
        <span itemprop="name">code</span>
      </a>
      &nbsp; 
    </span>
  
</span>


      <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-file-word-o"></i>
</span>
<span class="post-meta-item-text">字数: </span>
<span class="leancloud-visitors-count">25884</span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-coffee"></i>
</span>
<span class="post-meta-item-text">阅读: </span>
<span class="leancloud-visitors-count">52 分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <blockquote>
<p>在<code>Swift</code>中方法是<font color="#de7802">关联了特定类型的函数</font>。类，结构体，<font color=Blue>枚举类型</font>都能定义实例方法，方法封装了<font color="#de7802">给定类型特定的任务和功能</font>。</p>
</blockquote>
<h1 id="实例方法">实例方法</h1>
<p>实例方法是<font color=Blue>属于特定实例</font>（类实例、结构体实例或者枚举实例）的函数。实例方法<font color="#de7802">只能在类型的具体实例里被调用</font>，不能独立于实例而被调用，也就是说不能直接使用类名直接调用。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Counter</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> count = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">increment</span>() {
</span></span><span style="display:flex;"><span>        count <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">increment</span>(by amount: Int) {
</span></span><span style="display:flex;"><span>        count <span style="color:#f92672">+=</span> amount
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">reset</span>() {
</span></span><span style="display:flex;"><span>        count = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="异变方法">异变方法</h2>
<p>在<code>Swift</code>中<font color=Blue>结构体和枚举是值类型</font>。<font color="#de7802">默认情况下，值类型属性不能被自身的实例方法修改</font>。如果需要改变结构体或者枚举类型的属性，应该将实例方法进行<font color=red>异变</font>。即在实例方法的<code>func</code>关键字前添加<code>mutating</code>关键字：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Point</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> x = <span style="color:#ae81ff">0.0</span>, y = <span style="color:#ae81ff">0.0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">mutating</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">moveBy</span>(x deltaX: Double, y deltaY: Double) {
</span></span><span style="display:flex;"><span>        x <span style="color:#f92672">+=</span> deltaX
</span></span><span style="display:flex;"><span>        y <span style="color:#f92672">+=</span> deltaY
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>但是，<font color="#de7802">不能在常量结构体类型里调用异变方法</font>，因为常量代表自身属性不能被改变，即使这些属性是变量属性：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> fixedPoint = Point(x: <span style="color:#ae81ff">3.0</span>, y: <span style="color:#ae81ff">3.0</span>)
</span></span><span style="display:flex;"><span>fixedPoint.moveBy(x: <span style="color:#ae81ff">2.0</span>, y: <span style="color:#ae81ff">3.0</span>)  <span style="color:#75715e">//编译器会报错，因为常量结构体里的数据不能被修改，而moveBy声明是异变的，所以矛盾，编译器会报错。</span>
</span></span></code></pre></div><h2 id="self属性">self属性</h2>
<p>每一个类的实例都隐含一个叫做<code>self</code>的属性，它完全和实例本身相等，可以使用<code>self</code>来调用实例的方法或者使用实例的属性。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Point</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> x = <span style="color:#ae81ff">0.0</span>, y = <span style="color:#ae81ff">0.0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">isToTheRightOf</span>(x: Double) -&gt; Bool {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">self</span>.x <span style="color:#f92672">&gt;</span> x  <span style="color:#75715e">//形参的优先级别高于实例属性</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>枚举的<font color="#de7802">异变方法</font>可以设置<font color=Blue>隐含的<code>self</code>属性</font>为相同枚举里的不同成员。也就是在枚举类型中其异变的方法中，<code>self</code>也是可以变换的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">TriStateSwitch</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> off, low, high
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">mutating</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">next</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">switch</span> <span style="color:#66d9ef">self</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> .off:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">self</span> = .low
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> .low:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">self</span> = .high
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> .high:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">self</span> = .off
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="类型方法">类型方法</h1>
<p>类型方法是用来定义<font color="#de7802">类型本身调用的方法</font>，通过在<code>func</code>关键字前加<code>static</code>来实现。类还可以用<font color="#de7802">关键字<code>class</code>来允许子类重写父类的方法实现</font>。</p>
<p>在类方法中，隐含的<code>self</code><font color="#de7802">指向的是类本身</font>而不是类的实例。同样在类型方法中，有<code>self</code>访问的属性与同名的形参相比，优先级低一些：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Point</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">var</span> x = <span style="color:#ae81ff">12</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test</span>(x:Int)-&gt;Bool{
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">self</span>.x <span style="color:#f92672">&gt;</span> x
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="modern-concurrency">Modern Concurrency</h1>
<p>基于闭包的代码很多都类似如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">UserInfo</span>: Codable {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> username: String
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> avatar_url: String
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">UserAPI</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fetchUserInfo</span>(
</span></span><span style="display:flex;"><span>        completionHandler: @escaping (<span style="color:#66d9ef">_</span> userInfo: UserInfo?, <span style="color:#66d9ef">_</span> error: Error?) -&gt;
</span></span><span style="display:flex;"><span>            Void
</span></span><span style="display:flex;"><span>    ) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> url = URL(
</span></span><span style="display:flex;"><span>            string:
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;https://www.andyibanez.com/fairesepages.github.io/books/async-await/user_profile.json&#34;</span>
</span></span><span style="display:flex;"><span>        )<span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> session = URLSession.shared
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> dataTask = session.dataTask(with: url) { data, response, error <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> error = error {
</span></span><span style="display:flex;"><span>                completionHandler(<span style="color:#66d9ef">nil</span>, error)
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> data = data {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">let</span> userInfo = <span style="color:#66d9ef">try</span> JSONDecoder().decode(UserInfo.<span style="color:#66d9ef">self</span>, from: data)
</span></span><span style="display:flex;"><span>                    completionHandler(userInfo, <span style="color:#66d9ef">nil</span>)
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">catch</span> { 
</span></span><span style="display:flex;"><span>                    completionHandler(<span style="color:#66d9ef">nil</span>, error) 
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        dataTask.resume()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> userApi = UserAPI()
</span></span><span style="display:flex;"><span>userApi.fetchUserInfo { value, error <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> userInfo = value {
</span></span><span style="display:flex;"><span>        debugPrint(userInfo.username, userInfo.avatar_url)
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        debugPrint(error?.localizedDescription ?? <span style="color:#e6db74">&#34;无错误信息&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面代码对于新学者来说，看起来可能有些吃力，但对于有经验的开发者来说，一看就知道这个方法是在做什么，即发送请求获取用户相关信息。</p>
<h2 id="introducing-asyncawait">Introducing async/await</h2>
<p>在过程式编程中，代码是按顺序从上往下执行。若上面代码能通过函数的返回语句来传递数据，而不是通过闭包传递数据，岂不是更好？这正是新系统能做到的。如果去掉闭包，可以编写更自然的代码，更容易地表达我们的意图，让接手的开发人员更清楚地掌握代码是做什么的。</p>
<h3 id="the-async-keyword">The async keyword</h3>
<p>新系统的核心是<code>async</code>和<code>await</code>关键字，理解如何使用这两个关键词对于使用新系统的其余部分至关重要。可以异步运行的函数或可以与其它函数同时运行的函数，在这些函数的返回类型前添加<code>async</code>关键字，就是告诉编译器，这个函数是异步的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fetchUserInfo</span>() async <span style="color:#66d9ef">throws</span> -&gt; UserInfo {
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">/*...*/</span>
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">return</span> UserInfo(username: <span style="color:#e6db74">&#34;Test&#34;</span>, avatar_url: <span style="color:#e6db74">&#34;test&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面声明中可以看到<code>completionHandler</code>已经没了，如同在回调<code>completionHandler</code>中返回<code>Error</code>一样，上面定义的函数也可能抛出<code>Error</code>。将<code>fetchUserInfo</code>标记为抛出错误，即在<code>async</code>后面添加关键字<code>throws</code>，可以使得错误处理更自然。函数的返回值类型标记为非可选的<code>UserInfo</code>，也可以省去解包的步骤。</p>
<p>为了能够调用<code>async</code>关键字标记的函数，我们需要一个<code>concurrent context</code>（并发上下文），有几种方式创建这种并发上下文：</p>
<ul>
<li>
<p>标记为<code>async</code>的函数体是一个<code>concurrent context</code>。若一个函数未使用<code>async</code>标记，则它<font color="#de7802">不能直接调用<code>async</code>函数</font>，下面代码会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">authenticateAndFetchProfile</span>() { 
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> userProfile = <span style="color:#66d9ef">try</span> await fetchUserInfo() <span style="color:#75715e">//...</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
</ul>
<p>但是，若没有并发上下文会怎样呢？在代码调用层次的某处，可能会遇到无并发上下文来运行<code>async</code>标记的异步函数。幸运的是，有一种创建异步上下文的方法可以帮助我们解决这个问题，即创建一个<code>Task</code>对象。</p>
<p><code>Task</code>（任务）是一个功能非常强大的对象，可以用它来进行多线程处理，还能对它们进行一些控制，比如取消。现在，我们只使用<code>Task</code>来创建并发上下文，<code>Task</code>有一个带有闭包的初始化器，这个<font color="#de7802">闭包本身就是一个并发上下文</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">authenticateAndFetchProfile</span>() {
</span></span><span style="display:flex;"><span>    Task { <span style="color:#75715e">//...</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> userProfile = <span style="color:#66d9ef">try</span> await fetchUserInfo() <span style="color:#75715e">//...</span>
</span></span><span style="display:flex;"><span>        debugPrint(userProfile.username, userProfile.avatar_url)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例代码中，虽然函数<code>authenticateAndFetchProfile</code>没有被标记为<code>async</code>，但因为在函数体内创建了一个<code>Task</code>，所以在创建<code>Task</code>的闭包中可以调用<code>async</code>标记的函数。</p>
<h3 id="the-await-keyword">The await keyword</h3>
<p>每一次<code>async</code>函数的调用都必须在某个点有与之对应的<code>await</code>关键字。需要注意的是，<font color="#de7802"><code>await</code>本身具有特殊的语义，它不仅仅是用来调用<code>async</code>函数的语法</font>。</p>
<p>如果在代码执行过程中遇到<code>await</code>关键字，我们的程序可能选择挂起当前正在执行的函数。因为这个原因，<font color="#de7802"><code>await</code>关键字通常也被称为挂起点</font>。但请注意，<font color=red>这是系统可能会做出的决定，我们无法主动进行控制</font>。</p>
<p>当<font color="#de7802">我们说可能会挂起时，意思是当前的执行将被暂停</font>，而调用的<code>async</code>函数将会在其它地方继续执行。如果当前函数被挂起，其后的代码将暂停执行（从调用<code>async</code>函数开始，之后的所有代码均不会执行），直到调用的<code>async</code>函数执行完成后才会恢复。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">authenticateAndFetchProfile</span>() async {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//...</span>
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;Fetching user info&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> userProfile = <span style="color:#66d9ef">try</span> await fetchUserInfo()
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;User info fetched&#34;</span>)  <span style="color:#75715e">//...</span>
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">catch</span> {
</span></span><span style="display:flex;"><span>        debugPrint(error.localizedDescription)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面代码执行后，首先会打印字符串<code>Fetching user info</code>，过一小会儿才打印<code>User info fetched</code>，则正是代码语句的书写顺序。而且，我们成功地删除了闭包且不需要任何其它额外的操作就实现按顺序输出。</p>
<p>在<code>await</code>调用挂起期间发生的事情是：我们将控制权交还给系统，因此我们无法控制何时能够再次获得控制权。<font color="#de7802">调用<code>fetchUserInfo()</code>的同一个线程将被释放去做其它工作，具体做什么工作无需我们关心，因为这些是由系统调度处理的</font>。其它工作可能是我们应用内的另一个任务，或者是系统外部的任务。在我们获得控制权之前，无法继续执行代码中的任何语句。</p>
<p>因此，上面示例代码将按照书写顺序执行打印语句，但打印<code>User info fetched</code>可能需要一点时间，因为我们已经将调用线程交给了系统，获取用户信息是一个耗时任务。当用户信息获取完成时，<code>fetchUserInfo</code>函数调用将到达其函数体中的<code>return</code>语句，这个<code>return</code>语句将控制权返回给我们。但请注意，<font color="#de7802">系统将决定何时将控制权交还给我们，但这并不是在遇到<code>return</code>语句后立即发生</font>。系统可能正在执行其它并发任务，它需要处理高其它优先级的问题，然后才会交还控制权给我们。</p>
<p>总之，在遇到一个挂起点（<code>await</code>关键字）后，<font color="#de7802">如果系统选择挂起，那么它下面的内容将不会执行，直至控制权重新交还给我们</font>。在挂起期间，系统会利用该线程做其它工作。</p>
<p>任何在<code>await</code>调用之后发生的事情被称为<code>continuation</code>，控制权恢复后，我们需要继续做这些事情，这很重要。因为我们可能在不同线程重新拿到控制权，<font color=red>即<code>await</code>下面的语句可能在不同的线程中运行</font>。这意味着在上面示例代码中，第一个打印语句可能在一个线程中运行，而第二个打印语句可能在一个完全不同的线程中运行。</p>
<p>使用<code>async/await</code>并不能让我们免于在主线程上做<code>UI</code>工作，所以如果需要更新<code>UI</code>，需要将这项工作推迟到主线程上。在实践中，这是通过一个名为<code>@MainActor</code>的系统级全局<code>actor</code>来完成的。</p>
<h3 id="using-asyncawait">Using async/await</h3>
<p>苹果所有基于闭包的并发API都有一个<code>async/await</code>版本，可以在<code>iOS 15</code>及更高版本上使用。虽然使用<code>Xcode 13.3</code>可以在<code>iOS 13</code>及更高版本上使用<code>async/await</code>，但<font color="#de7802">苹果原生支持的<code>async/await</code>版本API仅在<code>iOS 15</code>及以上版本中可用</font>。</p>
<p>定义<code>async</code>函数时，可以使用<code>throws</code>标记。一般来说，如果正在建模可能抛出错误或返回有效值的代码，可以简单地将函数标记为<code>throws</code>，然后将结果类型标识为调用成功后能得到的对象。本质上，<font color="#de7802">原来的<code>completionHandler</code>闭包内容已经移动到函数签名中</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fetchUserInfo</span>() async <span style="color:#66d9ef">throws</span> -&gt; UserInfo {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>一开始就能看出，<code>async/await</code>能帮我们写出更语义化的代码。在<code>Swift</code>中，可以在函数中抛出错误，但令人惊讶的是，很多开发者并不这样做。这是因为大多数应用本质上是并发的（例如，处理网络请求），而且我们无法以一种符合<code>Swift</code>风格的方式处理闭包中的错误，因此只能将错误作为闭包的一部分返回。使用<code>async/await</code>后，函数签名更易读，也更具<code>self-documented</code>（自文档化）。</p>
<p>我们开始使用苹果在<code>iOS 15</code>中提供的<code>async/await</code>的API。所有返回数据的<code>URLSession</code>方法都有<code>async/await</code>变体。到目前为止一切顺利，但下面这段代码还不能编译，因为在函数体中没有返回任何内容。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fetchUserInfo</span>() async <span style="color:#66d9ef">throws</span> -&gt; UserInfo {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> url = URL(string: <span style="color:#e6db74">&#34;https://www.andyibanez.com/ fairesepages.github.io/books/async-await/user_profile.json&#34;</span>)<span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> session = URLSession.shared
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> (userInfoData, response) = <span style="color:#66d9ef">try</span> await session.data(from: url)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们需要理解这样一个事实：上面对<code>session.data(from:)</code>的调用已不再接受闭包，也不再需要调用<code>resume()</code>了，只要调用<code>data(from:)</code>的<code>async</code>版本，<font color="#de7802">任务就会自动开始</font>。现在需要将<code>JSON</code>解析成可以使用的对象并返回。</p>
<p>下面是完整的<code>aync</code>版本的<code>fetchUserInfo</code>。因为使用了<code>async</code>和<code>await</code>，我们将原本15行的代码简化为了5行，能够真正体会到<code>async/await</code>的优雅。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fetchUserInfo</span>() async <span style="color:#66d9ef">throws</span> -&gt; UserInfo {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> url = URL(string: <span style="color:#e6db74">&#34;https://www.andyibanez.com/fairesepages.github.io/books/async-await/user_profile.json&#34;</span>)<span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> session = URLSession.shared
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> (userInfoData, response) = <span style="color:#66d9ef">try</span> await session.data(from: url)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> userInfo = <span style="color:#66d9ef">try</span> JSONDecoder().decode(UserInfo.<span style="color:#66d9ef">self</span>, from: userInfoData)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> userInfo
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>因为<code>Swift</code>支持方法重载，<code>fetchUserInfo()</code>和<code>fetchUserInfo(completionHandler:)</code>可以并存。通过将函数标记为<code>async</code>，我们创建了一个并发上下文，在其中可以调用其它<code>async</code>函数，并且<code>fetchUserInfo</code>的调用者本身需要在并发上下文中（要么将它自己标记为<code>async</code>，要么在<code>Task {}</code>中调用）。</p>
<p>当代码执行到<code>let (userInfoData, response) = try await session.data(from: url)</code>时，代码会被挂起，此时执行它的线程可以去做其它工作（其它工作可能与我们的应用程序无关）。由于<code>fetchUserInfo</code>函数被挂起，下面将数据转换为对象的那一行代码也不会执行，因为它依赖于上面那行返回的数据。</p>
<p>当<code>session.data(from:)</code>完成了下载，它会通知系统已准备好将结果返回给调用者。系统最后通过返回结果并将其赋给<code>(userInfoData, response)</code>变量，来通知我们的应用程序。系统返回结果并赋值给两个变量后，代码会按照编写顺序继续执行，即解析<code>JSON</code>，然后将该对象返回给调用者，这是最纯粹的过程化编程。</p>
<p>当然，代码也有可能抛出错误。当设备没有联网或服务器宕机时，代码会抛出异常。如果出现错误，我们可以直观地知道会发生什么，因为它和非异步的情况完全一样：<code>session.data(from:)</code> 会抛出一个错误（遵循<code>Error</code>协议的对象），且其下面的所有代码行都不会被执行。因此，在上面示例代码中，<font color="#de7802">调用者必须使用<code>try、try?</code> 或 <code>try!</code> 调用<code>fetchUserInfo()</code>（在这种情况下，使用<code>try!</code>是完全不推荐的）</font>。</p>
<p>上面示例中<code>session.data(from:)</code>返回一个元组，因此我们可以将其解构为两个不同的变量。因为没有使用 <code>response</code>变量，可以用下划线来代替，但我在那里放上response是为了表明，如果<code>API</code>有其他要求（比如需要检查 <code>headers</code>，或者以不同的方式处理<code>HTTP</code>状态码），可以使用这个类型为<code>URLResponse</code>的变量。需要将其转换为<code>HTTPURLResponse</code>才能从中获取有意义的信息。</p>
<h3 id="async-get-properties">async get properties</h3>
<p>关键字<code>async/await</code>并不局限于函数调用，<font color="#de7802">还可以在只读计算属性中使用它</font>。下面示例代码展示了如何做到这一点的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> userInfo: UserInfo {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">get</span> async <span style="color:#66d9ef">throws</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> url = URL(string: <span style="color:#e6db74">&#34;https://www.andyibanez.com/ fairesepages.github.io/books/async-await/user_profile.json&#34;</span>)<span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> session = URLSession.shared
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> (userInfoData, <span style="color:#66d9ef">_</span>) = <span style="color:#66d9ef">try</span> await session.data(from: url)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> userInfo = <span style="color:#66d9ef">try</span> JSONDecoder().decode(UserInfo.<span style="color:#66d9ef">self</span>, from: userInfoData)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> userInfo
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在声明计算属性时可以同时使用<code>async</code>和<code>throws</code>标记。但一般不推荐这样使用，除非已实现了某种缓存机制。否则若频繁地访问该属性，因为存在异步调用会导致访问显著的延迟。可能在某些情况下避免缓存机制是有意义的，但必须逐个案例进行分析。</p>
<h3 id="asyncawait-in-ios-13-and-ios-14">async/await in iOS 13 and iOS 14</h3>
<p>之前已经提到，虽然<code>async/await</code>在<code>iOS 13</code>和<code>iOS 14</code>上可以使用，但在这两个版本上苹果并没有提供使用<code>async/await</code>的系统<code>API</code>。你可能会疑惑，如果苹果在这些版本中一开始就没有提供任何<code>async/await</code>的系统<code>API</code>，那为什么还要在这些版本中支持<code>async/await</code>呢？如果需要在<code>iOS 13</code>和<code>iOS 14</code>中支持<code>async/await</code>版本的系统<code>API</code>，可以使用<code>Continuations</code>来实现系统方法的<code>async/await</code>变体。</p>
<h2 id="continuations">Continuations</h2>
<p><code>Continuations</code>很有用，因为利用它不仅能够将基于闭包的代码改为<code>async/await</code>版本，还能将第三方库和框架的代码进行封装。使用<code>Continuations</code>能够帮助我们创建一致的代码库，在必要时只使用<code>async/await</code>版本而不是使用基于闭包的调用。</p>
<p>并非所有基于闭包的代码都必然涉及并发或多线程处理。在<code>Swift</code>和苹果<code>SDK</code>中，存在大量接受闭包的调用，这些调用与并发毫无关联。例如，集合中广受欢迎的<code>filter</code>、<code>map</code>和<code>reduce</code>方法，正是通过闭包对元素进行操作的。请牢记一点，几乎不可能存在完全不使用闭包的项目，这是完全正常的。因为<code>async/await</code>的设计目标，<font color="#de7802">仅是消除并发相关任务中基于闭包的调用方式</font>。</p>
<h3 id="understanding-continuations">Understanding Continuations</h3>
<p>简而言之，<code>Continuations</code>是指<code>async</code>调用完成后发生的一切。当我们使用<code>async/await</code>时，<code>continuation</code>就是指<code>await</code>调用之后的所有内容。</p>
<p>如果使用的是基于闭包的代码，<code>continuation</code>指的是在回调<code>completion handlers</code>中的代码。而如果使用的是基于<code>delegate</code>的代码，<code>continuation</code>就是在某个操作完成后相关代理方法调用。新的并发系统允许我们将基于闭包式的或基于<code>delegate</code>式的<code>continuation</code>转换为<code>async/await</code>版本。</p>
<h3 id="converting-closure-based-calls-into-asyncawait">Converting closure-based calls into async/await</h3>
<p>下面是基于闭包的函数定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fetchUserInfo</span>(
</span></span><span style="display:flex;"><span>    completionHandler: @escaping (<span style="color:#66d9ef">_</span> userInfo: UserInfo?, <span style="color:#66d9ef">_</span> error: Error?) -&gt;
</span></span><span style="display:flex;"><span>        Void
</span></span><span style="display:flex;"><span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> url = URL(string:<span style="color:#e6db74">&#34;https://www.andyibanez.com/fairesepages.github.io/books/async-await/user_profile.json&#34;</span>)<span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> session = URLSession.shared
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> dataTask = session.dataTask(with: url) { data, response, error <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> error = error {
</span></span><span style="display:flex;"><span>            completionHandler(<span style="color:#66d9ef">nil</span>, error)
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> data = data {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> userInfo = <span style="color:#66d9ef">try</span> JSONDecoder().decode(UserInfo.<span style="color:#66d9ef">self</span>, from: data)
</span></span><span style="display:flex;"><span>                completionHandler(userInfo, <span style="color:#66d9ef">nil</span>)
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">catch</span> { 
</span></span><span style="display:flex;"><span>              completionHandler(<span style="color:#66d9ef">nil</span>, error) 
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    dataTask.resume()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>可以使用<code>withCheckedThrowingContinuation</code>将上面闭包式的函数转换为<code>async</code>版本（下面代码和<code>promiseKit</code>相似）。下面代码本质上是将基于闭包的代码封装在<code>withCheckedThrowingContinuation</code>（是一个方法，该方法提供带参闭包）中。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fetchUserInfo2</span>() async <span style="color:#66d9ef">throws</span> -&gt; UserInfo {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> await withCheckedThrowingContinuation { continuation <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>        fetchUserInfo { userInfo, error <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> user = userInfo {
</span></span><span style="display:flex;"><span>                continuation.resume(returning: user)
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> err = error {
</span></span><span style="display:flex;"><span>                continuation.resume(throwing: err)
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// Throw a generic error.</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> err = NSError(domain: <span style="color:#e6db74">&#34;com.socialmedia.app&#34;</span>, code: <span style="color:#ae81ff">400</span>)
</span></span><span style="display:flex;"><span>                continuation.resume(throwing: err)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>withCheckedThrowingContinuation</code>是一种提供带参闭包的方法，闭包中的这个参数实际上就是<code>continuation</code>，当使用闭包的异步调用完成后，需要使用这个<code>continuation</code>来<code>resume</code>它。这个<code>continuation</code>的类型是<code>CheckedContinuation&lt;T, any Error&gt;</code>，这意味着我们可以使用一个对象或<code>Error</code>来<code>resume</code>它。这种设计完全合理，因为涉及网络调用的操作始终存在失败的可能性。</p>
<p>上面代码中的<code>withCheckedThrowingContinuation</code>是<font color="#de7802">一个可能抛出错误的<code>async</code>函数</font>，因此我们在调用它（省略了所需的圆括号）时使用了<code>try await</code>。当函数<code>fetchUserInfo</code>成功获取到<code>userInfo</code>时，我们调用<code>continuation.resume(returning: user)</code>来<code>resume</code>对应的<code>continuation</code>，当<code>fetchUserInfo</code>调用发生错误时，我们使用<code>continuation.resume(throwing: err)</code>抛出异常。</p>
<p>当调用<code>continuation.resume(returning:)</code>时，会使得<code>async</code>版本的<code>fetchUserInfo()</code>调用者返回结果对象；而使用<code>continuation.resume(throwing:)</code>时，则会使其抛出错误。请注意，使用<code>continuation</code>时<font color=red>必须在某个时刻精确调用一次<code>continuation</code>（只能一次）</font>。<font color="#de7802">既不能忘记调用，也不能调用多次</font>，若忘记调用，程序将陷入死锁状态。</p>
<p>除了使用<code>withCheckedThrowingContinuation</code>创建<code>continuation</code>，还有其它三种方式创建<code>continuation</code>，即共有四种方法来创建<code>continuations</code>：</p>
<ul>
<li>
<p><code>withCheckedThrowingContinuation</code></p>
</li>
<li>
<p><code>withCheckedContinuation</code></p>
</li>
<li>
<p><code>withUnsafeThrowingContinuation</code></p>
</li>
<li>
<p><code>withUnsafeContinuation</code></p>
</li>
</ul>
<p>若确认原始的闭包代码中不返回任何错误时，可以使用<code>withCheckedContinuation</code>。不安全的变体-<code>withUnsafeThrowingContinuation</code>和<code>withUnsafeContinuation</code> ，与对应的<code>Checked</code>相似。主要区别在于，当使用<code>Checked Continuations</code>时，<code>Swift</code>会在遇到任何违规情况（如多次调用<code>continuations</code>或完全忘记调用<code>continuation</code>）时<font color=red>通过记录错误来保护你</font>。</p>
<p>不安全<code>continuations</code>没有这些功能，但它们可能稍微快一点。总体来说，<font color="#de7802">不建议使用不安全的<code>continuations</code></font>，但也请注意，在大多数情况下可以互换使用它们。</p>
<h3 id="converting-delegate-based-code-into-asyncawait">Converting delegate-based code into async/await</h3>
<p>将基于<code>delegate</code>的代码转换为<code>async/await</code>是一个更复杂的过程，因为这类<code>API</code>可能会根据发生的不同类型事件调用不同<code>delegate</code>方法，这会形成跳跃式的代码结构。基于代理的<code>API</code>可能非常混乱，尤其是当它们有大量可能的方法调用时。</p>
<p>尽管不同调用可能发生在同一线程中，但由于方法调用方式的特性，其行为往往难以预测。例如，<code>ContactsUI</code>框架提供的<code>CNContactPickerViewController</code>对象：当用户选择联系人时通过一个方法通知，而若用户取消选择，则会调用另一个方法通知。</p>
<p>在下面示例中，我们可以为调用者创建一个更简洁的<code>API</code>，围绕<code>CNContactPickerViewControllerDelegate</code>及其方法创建一个包装对象来实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#75715e">// 原实现</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">promptContact</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> picker = CNContactPickerViewController()
</span></span><span style="display:flex;"><span>    picker.delegate = <span style="color:#66d9ef">self</span>
</span></span><span style="display:flex;"><span>    picker.displayedPropertyKeys = [CNContactGivenNameKey, CNContactNamePrefixKey, CNContactNameSuffixKey]
</span></span><span style="display:flex;"><span>    present(picker, animated: <span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 改造后的实现</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">promptContact</span>() {
</span></span><span style="display:flex;"><span>    Task {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> contactPicker = ContactPicker(viewController: <span style="color:#66d9ef">self</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> contact = await contactPicker.pickContact() {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Contact selected…</span>
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Selection Cancelled…</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">import</span> <span style="color:#a6e22e">Foundation</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">import</span> <span style="color:#a6e22e">ContactsUI</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ContactPicker</span>: NSObject, CNContactPickerDelegate {
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">typealias</span> ContactCheckedContinuation = CheckedContinuation&lt;CNContact?, Never&gt;
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">unowned</span> <span style="color:#66d9ef">var</span> viewController: UIViewController 
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">/// 存储Continuation，在代理方法调用的时候以便它调用</span>
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">var</span> contactContinuation: ContactCheckedContinuation? 
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">var</span> picker: CNContactPickerViewController
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">init</span>(viewController: UIViewController) { 
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">self</span>.viewController = viewController 
</span></span><span style="display:flex;"><span>     picker = CNContactPickerViewController() 
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">super</span>.<span style="color:#66d9ef">init</span>() 
</span></span><span style="display:flex;"><span>     picker.delegate = <span style="color:#66d9ef">self</span> 
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  @MainActor <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">pickContact</span>() async -&gt; CNContact? { 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 打开人员选择器</span>
</span></span><span style="display:flex;"><span>    viewController.present(picker, animated: <span style="color:#66d9ef">true</span>) 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 等待返回CNContact?</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> await withCheckedContinuation({ (continuation: ContactCheckedContinuation) <span style="color:#66d9ef">in</span> 
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 保存continuation                          </span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.contactContinuation = continuation 
</span></span><span style="display:flex;"><span>     }) 
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  @MainActor 
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">contactPicker</span>(<span style="color:#66d9ef">_</span> picker: CNContactPickerViewController, didSelect contact: CNContact) {
</span></span><span style="display:flex;"><span>    contactContinuation?.resume(returning: contact)
</span></span><span style="display:flex;"><span>    contactContinuation = <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>    picker.dismiss(animated: <span style="color:#66d9ef">true</span>, completion: <span style="color:#66d9ef">nil</span>) 
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  @MainActor 
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">contactPickerDidCancel</span>(<span style="color:#66d9ef">_</span> picker: CNContactPickerViewController) {
</span></span><span style="display:flex;"><span>    contactContinuation?.resume(returning: <span style="color:#66d9ef">nil</span>)
</span></span><span style="display:flex;"><span>    contactContinuation = <span style="color:#66d9ef">nil</span> 
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面<code>delegate</code>中的方法<code>contactPicker</code>和<code>contactPickerDidCancel</code>执行时，都可以<code>resume</code>(恢复)<code>contactContinuation</code>，要么在取消选人的时候传递<code>nil</code>，要么在选择人后传递<code>contact</code>。下面是调用<code>ContactPicker</code>的示例代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">promptContact</span>() {
</span></span><span style="display:flex;"><span>    Task {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> contactPicker = ContactPicker(viewController: <span style="color:#66d9ef">self</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> contact = await contactPicker.pickContact() {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> nameFormatter = CNContactFormatter()
</span></span><span style="display:flex;"><span>            nameFormatter.style = .fullName
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> contactName = nameFormatter.string(from: contact)
</span></span><span style="display:flex;"><span>            selectedContactLabel.text = contactName
</span></span><span style="display:flex;"><span>            selectedContactLabel.textColor = .black
</span></span><span style="display:flex;"><span>            selectedContactLabel.isHidden = <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            selectedContactLabel.text = <span style="color:#e6db74">&#34;Cancelled&#34;</span>
</span></span><span style="display:flex;"><span>            selectedContactLabel.textColor = .red
</span></span><span style="display:flex;"><span>            selectedContactLabel.isHidden = <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>经过<code>ContactPicker</code>封装后，原先的<code>ViewController</code>中的代码就减少了很多，类也变得小很多。虽然我们成功为基于代理的调用提供了<code>async/await</code>版本，这确实很棒，但应该考虑这样做是否真的有必要。有时，基于委托的调用（如<code>CoreBluetooth、CoreLocation</code>）的复杂性可能不值得为其提供<code>async/await</code>版本。</p>
<h3 id="supporting-asyncawait-in-ios-13-and-14">Supporting async/await in iOS 13 and 14</h3>
<p>之前有提到过，但需要再强调一下，虽然在<code>Xcode 13.3</code>中就可以使用<code>async/await</code>，但在这两个版本的系统中苹果并没有提供系统库的<code>async</code>版本，直到<code>iOS 15</code>才开始提供系统库的<code>async</code>版本。因此，为了兼容<code>iOS 13</code>和<code>14</code>系统，建议扩展系统库方法并利用<code>available</code>检查器：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">extension</span> <span style="color:#a6e22e">LAContext</span> {
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    @available(iOS, introduced: <span style="color:#ae81ff">13</span>, deprecated: <span style="color:#ae81ff">15</span>, message: <span style="color:#e6db74">&#34;This method is no longer necessary. Use the API available in iOS 15.&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">evaluatePolicy</span>(<span style="color:#66d9ef">_</span> policy: LAPolicy, localizedReason: String) async <span style="color:#66d9ef">throws</span> -&gt; Bool {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> await withCheckedThrowingContinuation({ continuation <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">self</span>.evaluatePolicy(policy, localizedReason:localizedReason) { success, error <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> err = error {
</span></span><span style="display:flex;"><span>                    continuation.resume(throwing: err)
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                    continuation.resume(returning: success)
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        })
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在上面代码中，使用<code>@available</code>可以保证这段代码仅运行在<code>iOS 13</code>和<code>iOS 14</code>。老版本的<code>iOS</code>系统不支持<code>async/await</code>，因此可以把低于<code>iOS 12</code>及以下的系统排除在外。当上面方法运行在<code>iOS 15</code>以上的系统时，会得到的警告：<code>This method is no longer necessary Use the API available in iOS 15</code>。当target最低支持到<code>iOS 15</code>以后，上面扩展方法就可以删除了。</p>
<p>上面的<code>continuation</code>允许我们平滑地将基于闭包的调用转换为<code>SDK</code>已经存在的<code>async/await</code>调用。但仅限于针对<code>iOS 15</code>及更高版本时。转换时已经不再返回错误，而是将该方法转换为抛出异常的类型。</p>
<p>下面代码和上面代码没有太大的区别，最大的不同就是返回类型为<code>(Data, Response)</code>类型的元组，但总体而言，将此方法暴露给<code>iOS 14</code>和<code>13</code>系统并不复杂。需要注意的是，我们对返回的<code>data</code>和<code>response</code>进行了强制解包。这样做的原因是：若查看API的原始<code>async</code>签名，元组中的这些属性并未标记为可选类型，因此可安全地假设若未出现错误，这两个变量必为非空值。若对此存疑，可将元组元素标记为可选类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">extension</span> <span style="color:#a6e22e">URLSession</span> {
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    @available(iOS, introduced: <span style="color:#ae81ff">13</span>, deprecated: <span style="color:#ae81ff">15</span>, message: <span style="color:#e6db74">&#34;This method is no longer necessary. Use the API available in iOS 15.&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">data</span>(from url: URL) async <span style="color:#66d9ef">throws</span> -&gt; (Data, URLResponse) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> await withCheckedThrowingContinuation({ continuation <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">self</span>.dataTask(with: url) { data, response, error <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> error = error {
</span></span><span style="display:flex;"><span>                    continuation.resume(throwing: error) }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                    continuation.resume(returning: (data!, response!))
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }.resume()
</span></span><span style="display:flex;"><span>        })
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>下面是一段无关代码封装：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>actor SharedAsyncNetworkManager {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> shared = SharedAsyncNetworkManager()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">var</span> currentTask: Task&lt;Data, Error&gt;?
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fetchData</span>() async <span style="color:#66d9ef">throws</span> -&gt; Data {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> existingTask = currentTask {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">try</span> await existingTask.value
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> task = Task&lt;Data, Error&gt; {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">defer</span> { currentTask = <span style="color:#66d9ef">nil</span> }
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> url = URL(string: <span style="color:#e6db74">&#34;https://api.example.com/data&#34;</span>)<span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> (data, <span style="color:#66d9ef">_</span>) = <span style="color:#66d9ef">try</span> await URLSession.shared.data(from: url)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> data
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        currentTask = task
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">try</span> await task.value
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">clearCache</span>() {
</span></span><span style="display:flex;"><span>        currentTask = <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="structured-concurrency">Structured Concurrency</h2>
<p>截至目前，已经广泛地讨论了<code>async/await</code>是什么以及它是如何工作的。也已看到这种新工具如何帮助我们编写结构化的代码，使其代码结构类似于过程式编程。使用<code>async/await</code>能够摆脱那些破坏代码线性可读性的其他类型的回调，例如闭包和委托。但我们也已看到，所有这些代码实际上并不是同时运行、并发或多线程执行的。</p>
<p>我们定义并发为：一个线程（或你的程序）同时处理多件事情的能力。这个定义并不严格意味着同时做多件事，通常人们谈到并发时，实际上指的是多线程或并行。为了与社区对这个词的定义保持一致，当我们谈到并发时，指的是同时执行多个任务。</p>
<h3 id="understanding-structured-concurrency">Understanding Structured Concurrency</h3>
<p>结构化并发遵循结构化编程的相同思路。即<font color="#de7802">按照预期的顺序编写代码，并看到可预测（或至少半可预测）的结果</font>。与基于闭包的代码不同，结构化并发中定义的变量具有明确的作用域，因此可以预期代码不会跳转到破坏代码阅读流程的其它地方。这使得我们无需关心如内存管理等其他细节（例如，块中捕获的变量会怎样？闭包能否被保留？<code>weak self</code>等）。</p>
<p>而且，这仅适用于只考虑非并发的基于闭包的调用。你能想象一下代码中有多个基于闭包的并发调用，很多独立的代码同时运行的情况吗？</p>
<p>在结构化并发中，<font color="#de7802">可以同时运行多个代码路径，并得到可预测的结果</font>，而无需思考那些跳转多个基于闭包调用的代码迷宫。在新的<code>async/await</code>系统，提供了两种方式构建结构化并发：<code>async let</code>构造和<code>task groups</code>。</p>
<h3 id="the-async-let-construct">The async let construct</h3>
<p>结构化并发的<code>async let</code>构造也被称为<code>async let</code>绑定。下面两段代码都是使用<code>async let</code>构建结构化并发，仅在<code>return</code>这一行有区别，但它们的效果是一样的，且第二种方式更简洁：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fetchData1</span>() async <span style="color:#66d9ef">throws</span> -&gt; (userInfo: UserInfo, followers: UserInfo) {
</span></span><span style="display:flex;"><span>    async <span style="color:#66d9ef">let</span> userInfo = fetchUserInfo()
</span></span><span style="display:flex;"><span>    async <span style="color:#66d9ef">let</span> followers = fetchFellows()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">try</span> await userInfo, <span style="color:#66d9ef">try</span> await followers)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fetchData2</span>() async <span style="color:#66d9ef">throws</span> -&gt; (userInfo: UserInfo, followers: UserInfo) {
</span></span><span style="display:flex;"><span>    async <span style="color:#66d9ef">let</span> userInfo = fetchUserInfo()
</span></span><span style="display:flex;"><span>    async <span style="color:#66d9ef">let</span> followers = fetchFellows()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">try</span> await(userInfo, followers)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>要并发运行代码，只需在<code>let</code>声明前添加<code>async</code>关键字，声明的其余部分看起来像是正常的变量初始化。仍需要注意的是，若要执行<code>async let</code>操作，必须处于异步上下文中，既可以处于一个<code>Task</code>中，也可以处于一个标记为<code>async</code>的函数中。</p>
<p>当代码执行到<code>async let</code>声明时，赋值语句之后的所有操作都将在其它位置执行（被调用的函数和方法可能在不同线程中运行），各项任务将并行执行。<code>async let</code>任务作为创建它们的任务的子任务被创建。</p>
<p>如果在<code>async let</code>调用之间添加<code>print</code>语句，将会看到它们会被立即调用。<code>userInfo</code> 和<code>followers</code>将同时运行，但代码会在即将返回时暂停。需要注意的是，<code>await</code>关键字是一个挂起点，这意味着<code>fetchUserInfo</code>和<code>fetchFellows</code><font color="#de7802">都返回或其中某一个抛出错误之前，函数都是被挂起的</font>。</p>
<p>之前有说过，每一次<code>async</code>调用必须有与之对应的<code>await</code>，但并不要求<code>async</code>和<code>await</code>必须在同一行。如上面实示例代码，在<font color=red>使用<code>async let</code>时，当真正需要使用对应变量的值时，才需要使用<code>await</code>关键字</font>。因此，如果<code>async let</code>调用返回一个其它函数依赖的值，就在调用处使用<code>await</code>。如果需要在函数内部并发获取多个值，可以在返回语句处直接使用<code>await</code>，这并未违反<code>async</code>调用必须与<code>await</code>关键字配对的原则。</p>
<p>使用<code>aync let</code>是非常有用的，并且与之相应的可以在任何地方使用<code>await</code>关键字，如单个变量声明，或在等待数组元素时，或者像上面示例在返回元组之前等场景。</p>
<p>需要特别注意的是，虽然我们使用<code>async let</code>构造来明确表达并行执行任务的意图，但依然由<font color="#de7802">系统决定是否真的并行运行你的代码，或是否为多个调用复用同一个线程</font>。换言之，系统可能会选择在不同的但共享的线程中运行<code>fetchUserInfo</code>和<code>fetchFollowingAndFollowers</code>，实质上是在主线程之外串行执行这两项任务。</p>
<h3 id="task-groups">Task Groups</h3>
<p>若预先知道有多个并发量，使用<code>async let</code>来构建是理想选择。但有时我们事先并不知道完成某个任务有多少个并发量。为了应对这种场景，<code>async/await</code>提供了任务组（<code>task groups</code>）的解决方案。</p>
<p>任务组是一种结构化的并发工具，允许我们同时运行未知数量的（可能）并发任务，前提是这些任务是相关的。当任务过多时，<code>Swift</code>不会一次运行所有任务，它会对任务进行优先级排序，并尽可能多地并行执行其中部分任务。</p>
<h4 id="task-groups-in-action">Task Groups in Action</h4>
<p>为了创建任务组，可以使用<code>withTaskGroup</code>和<code>withThrowingTaskGroup</code>函数。如同创建<code>continuations</code>一样，创建任务组也区分是否抛出异常。当任务组能顺利完成时使用前者，任务组可能抛出错误时使用后者。</p>
<p>需要注意的是，<font color="#de7802">计算机系统并不具备无限数量的线程</font>。下面示例代码中，任务组会尽最大努力并行下载所有图片，但会对任务进行优化和优先级排序。若需同时处理大量并发任务，请注意任务组可能会将部分任务排入队列以备后续执行，且并非所有任务都会同时运行。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">import</span> <span style="color:#a6e22e">Foundation</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ServerImage</span>: Codable {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> imageName: String
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> url: URL
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">download</span>(serverImages: [ServerImage]) async <span style="color:#66d9ef">throws</span> -&gt; [URL] {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> urls: [URL] = []
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> await withThrowingTaskGroup(of: URL.<span style="color:#66d9ef">self</span>) { group <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> image <span style="color:#66d9ef">in</span> serverImages {
</span></span><span style="display:flex;"><span>            group.addTask(priority: .userInitiated) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> imageUrl = <span style="color:#66d9ef">try</span> await <span style="color:#66d9ef">self</span>.download(image)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> imageUrl
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 这里也使用try await                                          </span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">try</span> await imageUrl <span style="color:#66d9ef">in</span> group { 
</span></span><span style="display:flex;"><span>          urls.append(imageUrl)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> urls
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fetchImageList</span>() async <span style="color:#66d9ef">throws</span> -&gt; [ServerImage] {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> (data, <span style="color:#66d9ef">_</span>) = <span style="color:#66d9ef">try</span> await URLSession.shared.data(from: imageListURL)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> urls = <span style="color:#66d9ef">try</span> jsonDecoder.decode([ServerImage].<span style="color:#66d9ef">self</span>, from: data)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> urls
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">download</span>(<span style="color:#66d9ef">_</span> serverImage: ServerImage) async <span style="color:#66d9ef">throws</span> -&gt; URL {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> fileManager = FileManager.<span style="color:#66d9ef">default</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> tmpDir = fileManager.temporaryDirectory
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> (downloadedImageUrl, <span style="color:#66d9ef">_</span>) = <span style="color:#66d9ef">try</span> await URLSession.shared.download(from: serverImage.url)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// If the destination already exists, remove it.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> destinationUrl = tmpDir.appendingPathComponent(serverImage.imageName) 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span>? fileManager.removeItem(at: destinationUrl)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> fileManager.moveItem(at: downloadedImageUrl, to: destinationUrl)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> destinationUrl
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>从高层次来看，上面函数<code>download(serverImages:)</code> 首先声明一个<code>URL</code>数组变量。然后我们将把所有下载图片的本地URL存储在此变量中。随后创建一个任务组——该任务组本身即为可等待的操作——最后返回图片。由此再次体现了<code>async/await</code>机制带来的线性执行特性。</p>
<p>不管是使用<code>withTaskGroup</code>还是使用<code>withThrowingTaskGroup</code>创建任务组，都<font color="#de7802">需要指定该任务组产生的数据类型</font>。上面示例中，任务组产生的是<code>URL</code>数组，因为<code>download(serverImages:)</code>方法将返回<code>URL</code>。在<code>withTaskGroup</code>和<code>withThrowingTaskGroup</code>的<font color="#de7802">闭包都会返回任务组本身</font>，在上面示例中参数<code>group</code>就是任务组本身。往任务组提交任务使用<code>addTask</code>方法，任务一旦提交后便会立即开始执行。</p>
<p>在<code>download(serverImages:)</code>函数中，我们遍历所有服务器图片，每次迭代都会创建一个下载图片的任务。在最佳情况下，任务组能同时执行所有任务。与<code>async/await</code>系统中的其它工具类似，系统会对任务进行优先级排序。若资源充足，它将尝试并行执行所有任务。但若任务组未能同时执行每个任务（尤其当提交大量任务时），请勿感到意外。我们可选择性指定优先级，<font color="#de7802">上面采用的是<code>.userInitiated</code>优先级，这是当前可用的最高优先级</font>。</p>
<p>需要特别注意的是，<strong><font color="#de7802">添加到组中的任务可能不会按照提交顺序执行</font></strong>。要使用任务组，<font color="#de7802">关键是要设计出与执行顺序无关的代码</font>。</p>
<p>最后，在<code>withThrowingTaskGroup</code>内部，还有另一个循环——一个<code>await</code>的<code>for</code>循环。该循环将接收所有下载完成的<code>URL</code>。它会逐个接收每个<code>URL</code>，因此我们不能让<code>URLs</code>变量处于无效状态。再次强调，不要期望<code>URLs</code>会按特定顺序获取。<code>group</code>本身是一个集合，因此不仅可以使用<code>for-in</code>遍历它，还可以使用<code>filter、map、reduce</code>这样的高阶函数来处理结果。而且，<code>for</code>循环中也可以使用<code>await</code>关键字来处理随时间发出值的代码。</p>
<p>还需要注意的是，只要任务组中的一个任务出现错误，整个任务组就会抛出异常。请记住这一点，因为它可能导致意想不到的行为，如果图片下载可能会失败，那么在这个特定项目中为下载任务提供一个默认图片可能是个好主意。</p>
<h2 id="unstructured-concurrency">Unstructured Concurrency</h2>
<p>非结构化并发提供了更大的灵活性，但代价是可用性略有降低。在处理非结构并发时，代码<font color="#de7802">未必遵循我们所喜爱的自上而下的结构</font>。幸运的是，处理非结构并发仍然非常简单，这种灵活性不会显著增加程序的复杂性。</p>
<h3 id="tasks-in-depth">Tasks in Depth</h3>
<p>对于无结构的并发，依然是使用<code>Task</code>对象。<code>Task</code>是一个很重要的对象，它允许我们做两件非常重要的事情：</p>
<ul>
<li>创建<code>Task</code>后，它就会<font color="#de7802">异步启动闭包中的代码</font>。</li>
<li>它创建了一个并发上下文，使我们能够通过调用异步方法的方式实现并发操作。</li>
</ul>
<h3 id="creating-tasks">Creating Tasks</h3>
<p><code>Task</code>是一个对象，它可以存储值、错误、两者兼有或两者皆无。要创建一个异步、非结构的任务，我们调用<code>Task</code>并使用一个闭包初始化它，这个闭包是我们希望异步执行的代码。下面示例代码是使用<code>Task</code>调用<code>async</code>方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">authenticateAndFetchProfile</span>() {
</span></span><span style="display:flex;"><span>    Task {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> userProfile = <span style="color:#66d9ef">try</span> await fetchUserInfo()
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>        debugPrint(userProfile)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fetchUserInfo</span>() async -&gt; String {
</span></span><span style="display:flex;"><span>    debugPrint(<span style="color:#e6db74">&#34;fetchUserInfo&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;Return Test&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>当我们需要使用<code>Task</code>做并发时，先可灵活配置的参数便是优先级。优先级是<code>Task.Priority</code>类型（与处理任务组时使用的优先级相同）。下面是可使用的优先级列表：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> background: TaskPriority
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> high: TaskPriority
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> low: TaskPriority
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">var</span> medium: TaskPriority
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> userInitiated: TaskPriority
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> utility: TaskPriority
</span></span></code></pre></div><p><code>Task</code>是一个对象，你可以使用变量存储它，这就是被称为非机构并发的部分原因。我们可以有多个Task，存储在多个变量中（甚至存储在一个<code>collections</code>中）。在非机构化并发中，可以取消Task，但在结构化的Task无法做到这一点：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">authenticate</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> authenticationTask = Task&lt;Bool, Error&gt; {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> context = LAContext()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> policy = LAPolicy.deviceOwnerAuthenticationWithBiometrics
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">try</span> await context.evaluatePolicy(
</span></span><span style="display:flex;"><span>            policy, localizedReason: <span style="color:#e6db74">&#34;To log in&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 取消Task</span>
</span></span><span style="display:flex;"><span>    authenticationTask.cancel()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在上面示例代码中，我们定义变量的类型为<code>Task&lt;Bool, Error&gt;</code>，这是因为<code>context.evaluatePolicy</code>返回一个<code>Bool</code>值，也可能抛出一个<code>Error</code>。</p>
<p>我们可以<code>await</code>某个<code>Task</code>的值。在下面示例代码中，需要使用<code>try await</code>，这是因为我们定义的<code>authenticationTask</code>可能返回一个<code>Bool</code>值，也可能抛出一个错误。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">authenticate</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> authenticationTask = Task&lt;Bool, Error&gt; {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> context = LAContext()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> policy = LAPolicy.deviceOwnerAuthenticationWithBiometrics
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">try</span> await context.evaluatePolicy(
</span></span><span style="display:flex;"><span>            policy, localizedReason: <span style="color:#e6db74">&#34;To log in&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    Task {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> status = <span style="color:#66d9ef">try</span> await authenticationTask.value
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> status {
</span></span><span style="display:flex;"><span>            debugPrint(<span style="color:#e6db74">&#34;sucess&#34;</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>需要注意的是，上面示例代码创建<code>Task</code>时，并没有使用<code>do-catch</code>语句体。上面代码隐式地创建了一个<code>Task&lt;(), Error&gt;</code>类型的任务，因为<code>Task</code>中不返回任何值，但会抛出异常。<font color="#de7802"><code>Task</code>不需要显式的<code>do-catch</code>语句体，因为闭包会自动捕获<code>Error</code></font>。</p>
<p>当在代码中使用<code>Task {}</code>创建一个新任务时，它将继承产生这个任务的上下文信息。继承的信息包括任务运行的<code>Actor</code>（如果在<code>@MainActor</code>上运行的任务中产生了任务，那么该任务也将在<code>@MainActor</code>上运行）和优先级。如果新生成的任务是一个根任务（它创建了一个异步上下文，但其本身并不在其中运行），那么它将继承其所运行线程的<code>Actor</code>。</p>
<h3 id="the-task-tree">The Task Tree</h3>
<p><code>Swift</code>中的新并发系统由一种称为任务树的基础结构驱动。正如名称所示，任务树为我们提供了一种并发在后台如何运作的思维模型。任务树决定了任务如何与其它任务关联运行。它还控制数据如何传递给子任务。之前我们提到过，<font color="#de7802">一个任务会从启动它的任务那里继承<code>actor</code>、优先级和任务局部变量</font>。这要归功于任务树。任务会生成子任务，而这些子任务会从父任务那里继承所有这些属性。</p>
<p>下面代码中，直觉上我们会认为每个<code>async let</code>调用会隐式地启动一个新任务，但事实并非如此。每个<code>async let</code>调用会启动一个新的子任务。这个区别很重要，<strong><font color="#de7802">因为<code>Task</code>只能显式创建</font></strong>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fetchData</span>() async <span style="color:#66d9ef">throws</span> -&gt; (userInfo: UserInfo, followers: UserInfo) {
</span></span><span style="display:flex;"><span>    async <span style="color:#66d9ef">let</span> userInfo = fetchUserInfo()
</span></span><span style="display:flex;"><span>    async <span style="color:#66d9ef">let</span> followers = fetchFellows()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">try</span> await(userInfo, followers)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>每个子任务都会继承我们之前从父任务接受的信息（在上面这种情况下，父任务就是<code>fetchData()</code>函数本身），这些信息包括actor，priority和局部变量。</p>
<p>当在一个Task中创建一个新Task，它还将继承父Task的属性，但与隐式任务不同，可以根据自己的需求稍作调整，例如以不同的优先级生成该新Task。</p>
<p>任务树的另一个需要特别注意的是：<strong><font color="#de7802">父任务只有在其所有子任务都完成工作后才能完成</font></strong>。即使终止是不成功（即抛出了错误），它仍然是一个终止，当出现这种异常情况时，任务也可以完成。</p>
<h3 id="error-propagation">Error Propagation</h3>
<p>fetchData本身可能会抛出异常，它所生成的所有子任务也是如此。假设fetchUserInfo出现了错误，如果函数抛出错误，<font color="#de7802">那么函数会在该点停止执行，将错误传递给调用者，并且不会执行该点之后的任何代码</font>。到目前为止，这正是若完全不使用新的并发系统时所发生的情况。这就是Swift（以及许多其他编程语言）中的错误传播机制。</p>
<p>但当使用新的并发系统时，情况并不那么直观。<code>fetchUserInfo</code>可能会抛出错误，但<code>fetchFollowingAndFollowers</code>可能正常完成并返回预期的值。如果发生错误，它将沿着任务树向上传播，直到到达调用者。任何其它正在等待或并发运行的子任务将被标记为已取消。</p>
<h3 id="task-cancellation">Task Cancellation</h3>
<p>任务取消是非常重要的，但它的运作方式和我们第一眼看到的有所不同。如果重新阅读上一段的最后一句话，会发现我们说的是这些任务“将被标记为已取消”。</p>
<p>在新的并发系统，任务取消是协作式的。取消一个任务仅仅意味着你通知它打算取消它。任务本身需要找到一个合适的时间点来终止自己，而你需要自行实现这一逻辑。</p>
<p>任务取消之所以是协作式的，是因为存在一些敏感但重要的任务，它们可能无法接受被强制终止执行。如果你正在一个并发任务中写入数据库或者修改用户文件，突然取消它可能会导致用户数据损坏。</p>
<p>若一个任务被取消掉，那么它的所有子任务也会被标记为被取消，这样是试图确保不会进行不必要的工作。</p>
<h3 id="task-cancellation-and-task-groups">Task Cancellation and Task Groups</h3>
<p>理解结构化并发与任务组可以使你的代码<font color="#de7802">向调用者返回部分结果而不是完整集合非常重要</font>。接下来分析下面的代码段：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">download</span>(serverImages: [ServerImage]) async <span style="color:#66d9ef">throws</span> -&gt; [URL] {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> urls: [URL] = []
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> await withThrowingTaskGroup(of: URL.<span style="color:#66d9ef">self</span>) { group <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> image <span style="color:#66d9ef">in</span> serverImages {
</span></span><span style="display:flex;"><span>            group.addTask(priority: .userInitiated) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> imageUrl = <span style="color:#66d9ef">try</span> await <span style="color:#66d9ef">self</span>.download(image)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> imageUrl
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">try</span> await imageUrl <span style="color:#66d9ef">in</span> group { 
</span></span><span style="display:flex;"><span>          urls.append(imageUrl)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> urls
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果有10张图片需要下载，并且在所有图片下载完成之前发生错误（或者你调用group.cancelAll()取消任务组）, urls数组将包含一个不完整的部分结果，只包含它在异常退出之前成功下载的图片。请确保你记录下这种行为，因为调用你代码的用户可能不了解这一点，从而导致他们的程序出现意外行为。</p>
<h3 id="unstructured-concurrency-with-detached-tasks">Unstructured Concurrency with Detached Tasks</h3>
<p>任务树确保任务继承一些来自父任务的属性，例如优先级，<code>actor</code>和局部变量。完全<font color="#de7802">有可能从一个不继承任何父任务属性的任务启动另一个任务，这些任务被称为分离任务</font>。当需要非严格相关的并发时，它们非常有用。例如，从互联网下载图片可以是一个任务，之后可能希望将这些图片存储到本地缓存中。将图片存储到本地缓存的过程可以是一个分离任务，这样即使该任务被取消，但图片已经下载完成，缓存保存操作仍能顺利进行而不会出现问题。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>Task.detached(priority: .low) { 
</span></span><span style="display:flex;"><span>  imageManager.writeImageToCache(image) 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面创建了一个分离任务，从语法上看，和标准任务之间没有太大区别，但<font color="#de7802">在使用它们时要注意任务树和继承属性</font>。指定优先级是可选的，就像在使用普通任务时一样。</p>
<h2 id="actors">Actors</h2>
<p>运行一些任务时，经常需要将结果传递到主线程。但也有一些情况，需要在程序中使用共享的可变状态，即一个可以被代码读取和写入的公共可变资源。这个资源可以是一个简单的变量，也可以是一个文件，或者任何其它在并发访问时危险的资源（但这些资源又需要在多个任务之间同时可用）。</p>
<p>如果有多段代码访问一个<font color="#de7802">只读资源</font>，程序不会出现问题，不必担心数据损坏。但如果有多个任务，并且至少一个可以向共享资源写入数据，那很可能会出现问题。这种情况称为数据竞争（<code>data race or race condition</code>)，数据竞争是十分危险的。</p>
<p>如果多段代码可以同时写入一个文件，将会导致数据损坏。如果多个任务从该资源中读取数据，它们可能会得到垃圾数据，这些数据可能与它们试图读取的数据不一致。最糟糕的是，如果在底层编写并发代码，很容易引入数据竞争，而且调试起来也非常困难。</p>
<p>因此，如果使用的是值语义（如结构体或枚举），就不会遇到这个问题。值语义是只读的，如果值发生变化，会创建一个副本，且所有的修改都局限于该变量。每个任务都会操作数据的不同副本，尽管这可能并非你所期望的。</p>
<h3 id="introducing-actors">Introducing Actors</h3>
<p>Actor是Swift中引入的一种新引用类型，由新的并发模型支持。<font color="#de7802">Actor自身的状态与程序的其余部分隔离，并对外部访问可变状态提供同步保护</font>。简单来说，如果一个Actor包含一个可被多个任务读写的基本变量，那么<code>Actor</code>会确保同一时间只有一个任务能够执行操作，从而保证对资源的互斥访问。</p>
<p>每次访问可变状态都必须通过Actor来完成。声明一个<code>Actor</code>非常简单，只需使用<code>actor</code> 关键字，然后为其命名，这与声明结构体（<code>struct</code>）或类（<code>class</code>）非常相似。作为引用类型，<code>actor</code>与类有许多相似的功能：它们可以遵循协议（<code>protocol</code>），也能通过扩展（<code>extension</code>）获得更多功能。与类的主要区别在于，<code>actor</code>会隔离自身状态。一个<code>actor</code>可能会挂起零次或多次（即在其方法内部包含其它<code>await</code>调用），因此可以轻松地将<code>Actor</code>与<code>Swift</code>的其它新并发系统组件集成。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>actor VideogameLibrary { 
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> videogames: [Videogame] = []
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">countGames</span>(by company: String) -&gt; Int { 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> games = fetchGames(by: company) 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> games.count 
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">add</span>(games: [Videogame]) { 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">self</span>.videogames.append(contentsOf: games) 
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fetchGames</span>(by year: Int) -&gt; [Videogame] { 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> games = videogames.filter { $0.releaseYear == year } 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> games 
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Videogame</span> { 
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> title: String 
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> releaseYear: Int 
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> company: String 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>从上面定义可以看出，<code>actor</code>的声明看起来和类的声明十分相似，它<font color="#de7802">也是一种引用类型，可以预期它与类的行为类似</font>。你可能会问为什么<code>actor</code>是引用类型而不是值类型。原因很简单：<code>actor</code>封装了可变的共享状态。它是一种期望被多个代码片段修改的类型。如果它是一个<code>struct</code>，调用者修改它时得到的是副本。</p>
<h4 id="interacting-with-an-actor">Interacting with an Actor</h4>
<p>需要特别注意，<font color="#de7802">所有的<code>actor</code>调用必须是异步的，因此需要<code>await</code>关键字，这就是<code>actor</code>用来同步状态并防止并发修改的机制</font>。因为<code>actor</code>的调用可以<code>awaited</code>，所以其它调用者会被挂起，等待轮到它们访问<code>actor</code>。</p>
<p>而在<code>actor</code>内部，不需要异步调用自身的方法和属性。因为<code>actor</code>是被隔离的，其内部任何调用都按顺序执行，直到内部操作完成。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> library = VideogameLibrary()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">addGames</span>(to library: VideogameLibrary) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> zelda5 = Videogame(title: <span style="color:#e6db74">&#34;The Legend of Zelda: Ocarina of Time&#34;</span>, releaseYear: <span style="color:#ae81ff">1998</span>, company: <span style="color:#e6db74">&#34;Nintendo&#34;</span>) 
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> zelda6 = Videogame(title: <span style="color:#e6db74">&#34;The Legend of Zelda: Majora&#39;s Mask&#34;</span>, releaseYear: <span style="color:#ae81ff">2020</span>, company: <span style="color:#e6db74">&#34;Nintendo&#34;</span>) 
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> tales1 = Videogame(title: <span style="color:#e6db74">&#34;Tales of Symphonia&#34;</span>, releaseYear: <span style="color:#ae81ff">2004</span>, company: <span style="color:#e6db74">&#34;Namco&#34;</span>) 
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> tales2 = Videogame(title: <span style="color:#e6db74">&#34;Tales of the Abyss&#34;</span>, releaseYear: <span style="color:#ae81ff">2005</span>, company: <span style="color:#e6db74">&#34;Namco&#34;</span>) 
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> eternalSonata = Videogame(title: <span style="color:#e6db74">&#34;Eternal Sonata&#34;</span>, releaseYear: <span style="color:#ae81ff">2008</span>, company: <span style="color:#e6db74">&#34;tri-Crescendo&#34;</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> games = [zelda5, zelda6, tales1, tales2, eternalSonata]
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  library.add(games: games)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面在<code>VideogameLibrary</code>之外定义的方法<code>addGames</code>是一个简单函数，仅用于快速添加一些<code>Videogame</code>，如果尝试编译这段代码，会出现错误：<code>Actor-isolated instance method ‘add(games:)’ can not be referenced from a non-isolated context</code>。</p>
<p>尽管<code>VideogameLibrary</code>中的<code>add(games:)</code>方法本身没有被标记为<code>async</code>，<font color="#de7802">但<code>actor</code>暴露给我们的API确实是异步的，这是<code>actor</code>提供的保护机制</font>。编译器在避免我们误用<code>actor</code>，以避免引入数据竞争。</p>
<p>这意味着，<code>actor</code>只能在异步上下文中运行，若要让代码编译通过，需要在<code>add(games:)</code>方法中添加<code>await</code>关键字，并将其包裹在<code>Task</code>（或<code>Task.detached</code>）中。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> library = VideogameLibrary()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">addGames</span>(to library: VideogameLibrary) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> zelda5 = Videogame(title: <span style="color:#e6db74">&#34;The Legend of Zelda: Ocarina of Time&#34;</span>, releaseYear: <span style="color:#ae81ff">1998</span>, company: <span style="color:#e6db74">&#34;Nintendo&#34;</span>) 
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> zelda6 = Videogame(title: <span style="color:#e6db74">&#34;The Legend of Zelda: Majora&#39;s Mask&#34;</span>, releaseYear: <span style="color:#ae81ff">2020</span>, company: <span style="color:#e6db74">&#34;Nintendo&#34;</span>) 
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> tales1 = Videogame(title: <span style="color:#e6db74">&#34;Tales of Symphonia&#34;</span>, releaseYear: <span style="color:#ae81ff">2004</span>, company: <span style="color:#e6db74">&#34;Namco&#34;</span>) 
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> tales2 = Videogame(title: <span style="color:#e6db74">&#34;Tales of the Abyss&#34;</span>, releaseYear: <span style="color:#ae81ff">2005</span>, company: <span style="color:#e6db74">&#34;Namco&#34;</span>) 
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> eternalSonata = Videogame(title: <span style="color:#e6db74">&#34;Eternal Sonata&#34;</span>, releaseYear: <span style="color:#ae81ff">2008</span>, company: <span style="color:#e6db74">&#34;tri-Crescendo&#34;</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> games = [zelda5, zelda6, tales1, tales2, eternalSonata]
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  Task{
</span></span><span style="display:flex;"><span>    await library.add(games: games)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>当多次调用<code>add(games:)</code>方法时，<code>actor</code>只会一次执行其中一个调用（一个接着一个，不会并发执行）。下面示例代码中，我们创建了一个新方法，用于向库中添加更多的<code>Videogame</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">addNewGames</span>(to library: VideogameLibrary) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> pokemon1 = Videogame(title: <span style="color:#e6db74">&#34;Pokémon Yellow&#34;</span>, releaseYear: <span style="color:#ae81ff">1998</span>, company: <span style="color:#e6db74">&#34;Game Freak&#34;</span>) 
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> pokemon2 = Videogame(title: <span style="color:#e6db74">&#34;Pokémon Gold&#34;</span>, releaseYear: <span style="color:#ae81ff">1999</span>, company: <span style="color:#e6db74">&#34;Game Freak&#34;</span>) 
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> pokemon3 = Videogame(title: <span style="color:#e6db74">&#34;Pokémon Ruby&#34;</span>, releaseYear: <span style="color:#ae81ff">2002</span>, company: <span style="color:#e6db74">&#34;Game Freak&#34;</span>) 
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> games = [pokemon1, pokemon2, pokemon3]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Task { 
</span></span><span style="display:flex;"><span>  	await library.add(games: games) 
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>现在有两个添加<code>Videogame</code>的方法了，下面每个方法都调用一次：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>addGames(to: library) 
</span></span><span style="display:flex;"><span>addNewGames(to: library)
</span></span></code></pre></div><p>现在有趣的事情发生了，我们不知道是<code>addGames</code>先添加成功还是<code>addNewGames</code>先添加成功。但可以保证的是，无论哪一个先执行，<code>actor</code>都会确保在另一个执行之前，函数中的所有<code>Videogame</code>都已经成功添加到数组中。</p>
<p>因此，数组要么包含<code>addGames</code>中按添加顺序排列的所有<code>game</code>，然后是<code>addNewGames</code>中按添加顺序排列的<code>game</code>，要么包含<code>addNewGames</code>中按添加顺序排列的所有<code>game</code>，然后是<code>addGames</code>中按正确顺序排列的game。永远不会以交错顺序或任何其它排列的方式添加<code>game</code>。</p>
<p>此外，对整个<code>actor</code>的访问是同步的。如果同一时间既向<code>library</code>中添加<code>game</code>，又在<code>library</code>中查询<code>game</code>，<code>actor</code>将只执行其中一个调用，直到完成后才会执行另一个。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>Task { 
</span></span><span style="display:flex;"><span>  addGames(to: library)
</span></span><span style="display:flex;"><span>} 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Task {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> games1998 = await library.fetchGames(by: <span style="color:#ae81ff">1998</span>)
</span></span><span style="display:flex;"><span>  print(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">\(</span>games1998.count<span style="color:#e6db74">)</span><span style="color:#e6db74"> games&#34;</span>) 
</span></span><span style="display:flex;"><span>} 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Task {
</span></span><span style="display:flex;"><span>  addNewGames(to: library) 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>理想情况下，上面代码执行完后会打印<code>2 games</code>，但由于<code>Task</code>试图并发地访问<code>actor</code>，三个任务只有一个能够先执行其中代码（一个接一个执行，但顺序不确定）。上面代码执行后，多数情况会打印<code>0 gmaes</code>，也可能打印<code>1 games</code>。互斥访问意味着一次只有一个任务可以进入<code>actor</code>并执行其工作（不管调用的是<code>actor</code>的哪种方法）。对<code>actor</code>的任何调用都会阻塞其它试图调用<code>actor</code>的操作，直到<code>actor</code>完成工作，其它任务才能调用<code>actor</code>。</p>
<p>这也是一个很好的机会用来展示<code>Task</code>的优先级是如何工作的。可以通过为添加game的任务分配更高的优先级，告诉编译器希望先添加<code>game</code>。下面示例代码更改了Task的优先级。其中<code>.utility</code>是最低优先级，因此通常它会最后执行，即打印的结果为<code>2 games</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>Task(priority: .high) {
</span></span><span style="display:flex;"><span>  addGames(to: library)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Task(priority: .utility) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> games1998 = await library.fetchGames(by: <span style="color:#ae81ff">1998</span>)
</span></span><span style="display:flex;"><span>  print(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">\(</span>games1998.count<span style="color:#e6db74">)</span><span style="color:#e6db74"> games&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Task(priority: .high) {
</span></span><span style="display:flex;"><span>  addNewGames(to: library)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="nonisolated-access-to-an-actor">Nonisolated Access to an Actor</h4>
<p>有时可能已经知道访问一个<code>actor</code>不会导致数据竞争。对于这些情况，可以将<code>actor</code>中的某些方法标记为<code>nonisolated</code>。为了阐明如何使用<code>nonisolated</code>，我们先添加一个新类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Owner</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> name: String
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> favoriteGenre: String
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>然后将<code>owner</code>添加到<code>VideogameLibrary</code>中：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>actor VideogameLibrary {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> videogames: [Videogame] = []
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// 只读属性，不会出现数据竞争</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> owner: Owner
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(ower: Owner) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.owner = ower
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    nonisolated <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fetchOwnerInfo</span>() -&gt; String {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">\(</span>owner.name<span style="color:#e6db74">)</span><span style="color:#e6db74"> (</span><span style="color:#e6db74">\(</span>owner.favoriteGenre<span style="color:#e6db74">)</span><span style="color:#e6db74">)&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fetchGames</span>(by company: String) -&gt; [Videogame] {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> games = videogames.filter { $0.title.caseInsensitiveCompare(company) == .orderedSame }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> games
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">countGames</span>(by company: String) -&gt; Int {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> games = fetchGames(by: company)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> games.count
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">add</span>(games: [Videogame]) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.videogames.append(contentsOf: games)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fetchGames</span>(by year: Int) -&gt; [Videogame] {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> games = videogames.filter { $0.releaseYear == year }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> games
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>调用<code>actor</code>中的<code>nonisolated</code>方法时，不需要异步调用，即不需要await关键字，也就是说不再需要并发上下文，下面代码不会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">printOwnerInfo</span>(of library: VideogameLibrary) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> ownerInfo = library.fetchOwnerInfo()
</span></span><span style="display:flex;"><span>    print(ownerInfo)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="actors-and-protocol-conformance">Actors and Protocol Conformance</h3>
<p>如果想让某个<code>actor</code>遵循协议，或者通过<code>extension</code>来扩展<code>actor</code>，需要注意一个重要事项：当<code>actor</code>打算遵循一个协议时，如果该协议有可变的需求，将会在遵循协议的过程中遇到问题。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>actor Game {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> name: String
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> year: Int
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(name: String, year: Int) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.year = year
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">extension</span> <span style="color:#a6e22e">Game</span>: Equatable {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">func</span> == (lhs: Game, rhs: Game) -&gt; Bool {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> lhs.name == rhs.name
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面代码不会出现编译错误，但继续按下面方式扩展<code>actor</code>时，会出现编译错误：<code>Actor-isolated instance method 'hash(into:)' cannot be used to satisfy nonisolated protocol requirement</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">extension</span> <span style="color:#a6e22e">Game</span>: Hashable {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">hash</span>(into hasher: <span style="color:#66d9ef">inout</span> Hasher) {
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>规避这个编译错误的方案很简单，添加<code>nonisolated</code>关键字即可：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">extension</span> <span style="color:#a6e22e">Game</span>: Hashable {
</span></span><span style="display:flex;"><span>    nonisolated <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">hash</span>(into hasher: <span style="color:#66d9ef">inout</span> Hasher) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这能够满足编译器的要求，但我们必须思考在这里使用<code>nonisolated</code>否合理。方法<code>hash(into:)</code>是否依赖于隔离的属性？如果依赖，你尝试实现该方法的任何努力都可能失败。你可能会遇到一些情形，确实很难符合那些期望其方法为同步的协议。</p>
<h3 id="actor-reentrancy">Actor Reentrancy</h3>
<p>当我们进入一个<code>actor</code>，如果它有很多调用其它异步方法的事情要做，那么它可能会被挂起。这可能导致一个常见的，被称为<code>Actor Reentrancy</code>的问题。</p>
<p><code>Actor Reentrancy</code>问题发生在到达<code>await</code>调用之前你假设程序的整体状态。用一个例子来解释这个问题，我们将<code>VideogameLibrary</code>添加一个新方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">addGamesAndPrintResults</span>(<span style="color:#66d9ef">_</span> games: [Videogame]) async <span style="color:#66d9ef">throws</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> existingGameCount = videogames.count
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Imagine a long-running operation is taking place here.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> await Task.sleep(nanoseconds: <span style="color:#ae81ff">1_000_000_000</span>)
</span></span><span style="display:flex;"><span>    add(games: games)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> newGameCount = existingGameCount <span style="color:#f92672">+</span> games.count
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;Games before: </span><span style="color:#e6db74">\(</span>existingGameCount<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;Games now: </span><span style="color:#e6db74">\(</span>newGameCount<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>Actor Reentrancy</code>问题发生在多个任务进入上面方法时，当一个任务进入时，它会记录<code>videogames</code>的数量，然后遇到一个长时间的<code>await</code>调用。在<code>await</code>调用完成前，第二个任务可能进入此方法，并记录<code>videogames</code>的数量。如果第一个任务在第二个任务离开<code>await</code>之前完成，那么第二个任务中的<code>existingGameCount</code>变量的值是错误的。</p>
<p>这里的问题是我们假设在进入<code>await</code>调用之前有多少个<code>games</code>。在离开一个挂起点后，程序的状态可能并不是之前那样。我们在<code>await</code>调用之前检查我们的假设，不幸的是<code>actor</code>无法在这种情况下保护我们。但一个经验法则是，在一个<code>await</code>调用之后检查你的假设。在这种情况下，我们的假设是<code>VideogameLibrary</code>中的游戏数量。</p>
<p>如果我们是在从挂起返回后计算这个数值，那就更有意义了。通过简单地将<code>existingGameCount</code>变量移动到合适的位置，程序就会被修复。下面将<code>existingGameCount</code>变量放在了一个更合理的位置。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">addGamesAndPrintResults</span>(<span style="color:#66d9ef">_</span> games: [Videogame]) async <span style="color:#66d9ef">throws</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Imagine a long-running operation is taking place here.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> await Task.sleep(nanoseconds: <span style="color:#ae81ff">1_000_000_000</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> existingGameCount = videogames.count
</span></span><span style="display:flex;"><span>    add(games: games)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> newGameCount = existingGameCount <span style="color:#f92672">+</span> games.count
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;Games before: </span><span style="color:#e6db74">\(</span>existingGameCount<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;Games now: </span><span style="color:#e6db74">\(</span>newGameCount<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="actors-and-detached-tasks">Actors and Detached Tasks</h3>
<p>会议一些，<code>detached</code>任务不会继承父任务的任何东西，包括父任务可能正在运行的<code>actor</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">playRandomGame</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">guard</span> <span style="color:#66d9ef">let</span> game = videogames.randomElement() <span style="color:#66d9ef">else</span> { <span style="color:#66d9ef">return</span> }
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;Playing </span><span style="color:#e6db74">\(</span>game.title<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">playRandomGameLater</span>() {
</span></span><span style="display:flex;"><span>    Task.detached {
</span></span><span style="display:flex;"><span>        await <span style="color:#66d9ef">self</span>.playRandomGame()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>方法<code>playRandomGame</code>是隔离在<code>actor</code>中的。但需要注意的是，<code>playRandomGameLater</code>要求我们使用<code>await</code>调用<code>self.playRandomGame</code>。这是因为一旦我们启动了分离任务，就跳转到了另一个<code>actor</code>。处于不同的<code>actor</code>中将迫使我们使用<code>await</code>调用该<code>actor</code>的方法。</p>
<h3 id="general-tips-for-working-with-actors">General Tips for Working with Actors</h3>
<p>当我们有共享可变变量时，<code>actor</code>是非常有用的，它使得访问可变数据变得容易，但它绝不是万能的解决方案。为了有效的使用<code>actor</code>，下面有一些建议：</p>
<ul>
<li><code>actor</code>越简单越好。虽然<code>actor</code>会通过Swift编译器保护在多数情形下免受误用，但它们无法保护免受<code>actor</code>重入等问题的影响。保持<code>actor</code>小巧有助于更有效地使用它们。</li>
<li>保证<code>actor</code>的操作是原子的。原子操作被视为一个单一单元。方法简短将有助于此。一般来说，原子性意味着可以一次性完成所有工作，或者如果单个操作失败，则整个操作将被丢弃。尽可能避免在<code>actor</code>中调用<code>await</code>将有助于原子性。</li>
<li>对所需状态的所有假设应该放在<code>await</code>调用之后，当它们被用在actor的方法中时。如果你的方法中只有一个await调用，这很容易做到，但如果有多个，就很难推断你的程序状态。</li>
<li>不要将一个<code>actor</code>作为<code>ObservableObject</code>在SwiftUI中使用。编译器不会阻止你这样做，但 <code>ObservableObject</code>会期望它始终在主线程上运行。如果 actor中包含耗时操作，会导致你的SwiftUI应用出现明显的卡顿。</li>
</ul>
<h2 id="sendable-types">Sendable Types</h2>
<p>最简单的并发程序涉及并发操作时通常是相对隔离的。但在复杂程序中，需要在隔离边界之间传递数据，从一个异步任务到另一个，从一个<code>actor</code>到<code>acotr</code>。这些数据必须是线程安全的。正如我们在actor中学到的，在异步域之间共享可变数据可能会导致数据竞争，从而导致数据损坏。</p>
<p>Swift需要一种安全的方式在隔离边界之间共享数据。<code>Swift Evolution</code>团队提出了一个非常优雅的解决方案，并引入了<code>sendable types</code>。</p>
<h3 id="understanding-sendable-types">Understanding Sendable Types</h3>
<p>一个<code>sendable type</code>可以跨异步<code>task</code>和<code>actor</code>之间共享。按照定义，一个<code>sendable type</code>需要能够防止数据竞争，这种类型应该无法被多个操作同时修改，只能提供同步访问。</p>
<p><code>Swift</code>有一些可以安全地在并发环境中使用的，开箱即用的<code>sendable</code>类型：</p>
<ul>
<li>值类型。包括枚举和结构体，只要它们不包含任何不可发送类型的属性，值类型就是<code>sendable</code>的。如果尝试修改一个值类型，就会创建一个包含原数据的新副本。这使得结构体和枚举能够在新的并发系统能够开箱即用。值类型可能会创建多个副本，但已有的副本会一直保持原样，直到被删除。</li>
<li><code>Actors</code>。<code>acotr</code>被设计为可以共享可变数据，因此他们存在的目的是在新并发模型中被使用。你可以无限制地在隔离边界之间共享<code>actor</code>，但要注意<code>actor</code>中可能有<code>nonisolated</code>的功能。<code>actor</code>始终是可发送的。</li>
<li>类。类可以是可发送的，但需要满足某些条件。类是引用类型，对类的实例进行修改实际上是修改了真实的数据。不像结构体，对类实例的修改不会创建原数据的副本。若一个被标记为<code>final</code>的类拥有只读属性，那么它非常容易使其成为可发送的。另一种方式是，如果类拥有可变属性且没有被标记为<code>private</code>，可以通过在类内部实现自己的同步机制来使其可发送。这听起来很难做，实际上也确实如此。</li>
<li>方法和闭包也可是可发送的，但需要显式地进行。</li>
</ul>
<p>在许多情形下，<code>Swift</code>可以推断类型的可发送性。结构体和<code>actor</code>就是例子。但是如果你做了一些工作使得一个类是线程安全的，当<code>Swift</code>编译器是无法推断出来的，并且会阻止你在编译器认为危险的方式上使用它。</p>
<h3 id="the-sendable-protocol">The Sendable Protocol</h3>
<p>在Swift中，除了值类型和<code>actor</code>之外的可发送类型需要遵守<code>Sendable</code>协议。通过简单地遵守<code>Sendable</code>协议，编译器会检查你对可发送类型的使用，以确保不会以可能导致数据竞争的方式使用它们。</p>
<h3 id="analyzing-sendable-types">Analyzing Sendable Types</h3>
<h4 id="structs">Structs</h4>
<p>为了更好地理解<code>sendable types</code>的行为，通过分析以了解其特点和注意事项。多数情况下，<code>struct</code>是开箱即用的可发送类型，但也有例外情况使得某个<code>struct</code>是不可发送的类型。假设一个结构体有一个类属性：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TVShow</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> title: String 
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> rating: Int
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">init</span>(title: String, rating: Int) { 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">self</span>.title = title 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">self</span>.rating = rating 
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">TVShowLibrary</span> { 
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> shows: [TVShow] = [] 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果试图用这个结构体跨越隔离边界（例如在非隔离上下文中声明一个<code>TVShowLibrary</code>并在<code>Task.detached {}</code>中捕获它），即使<code>TVShowLibrary</code>是一个结构体，编译器也会阻止你。在普通的<code>Task {}</code>捕获不会受到影响，因为它们会继承顶层上下文的<code>actor</code>，下面代码中顶层上下文的<code>actor</code>是<code>@MainActor</code>。下面示例代码中，我们声明了一个<code>TVShowLibrary</code>实例，然后两个<code>Tasks</code>中都捕获它了。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> tvShowLibrary = TVShowLibrary() 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> show = TVShow(name: <span style="color:#e6db74">&#34;Card Captor Sakura&#34;</span>) 
</span></span><span style="display:flex;"><span>tvShowLibrary.shows <span style="color:#f92672">+=</span> [show] 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Task {
</span></span><span style="display:flex;"><span>  tvShowLibrary.shows.first?.rating = <span style="color:#ae81ff">20</span>
</span></span><span style="display:flex;"><span>  print(<span style="color:#e6db74">&#34;Current score Task 1: </span><span style="color:#e6db74">\(</span>tvShowLibrary.shows.first!.rating<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>) 
</span></span><span style="display:flex;"><span>} 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Task {
</span></span><span style="display:flex;"><span>  tvShowLibrary.shows.first?.rating = <span style="color:#ae81ff">30</span>
</span></span><span style="display:flex;"><span>  print(<span style="color:#e6db74">&#34;Current score Task 2: </span><span style="color:#e6db74">\(</span>tvShowLibrary.shows.first!.rating<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>) 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>直觉上，我们可能会认为编译器会阻止这样做。毕竟我们是在两个任务中同时捕获并修改一个可变值。但这样做是完全可接受的，因为这两个<code>Task</code>的调用对应同一个<code>actor</code>（启动它们的<code>actor</code>）。如果是从非异步上下文中启动任务的，它们将继承主线程<code>actor</code>。</p>
<p>结构体默认是可发送的，除非它里面的属性是不可发送。上面的<code>TVShowLibrary</code>是不可发送的，因为它有一个数组属性，而数组中的元素<code>TVShow</code>是一个类，因此整个<code>TVShowLibrary</code>是不可发送的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> tvShowLibrary = TVShowLibrary() 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> show = TVShow(name: <span style="color:#e6db74">&#34;Card Captor Sakura&#34;</span>) 
</span></span><span style="display:flex;"><span>tvShowLibrary.shows <span style="color:#f92672">+=</span> [show] 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Task.detached {
</span></span><span style="display:flex;"><span>  tvShowLibrary.shows.first?.rating = <span style="color:#ae81ff">20</span>
</span></span><span style="display:flex;"><span>  print(<span style="color:#e6db74">&#34;Current score Task 1: </span><span style="color:#e6db74">\(</span>tvShowLibrary.shows.first!.rating<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>) 
</span></span><span style="display:flex;"><span>} 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Task.detached {
</span></span><span style="display:flex;"><span>  tvShowLibrary.shows.first?.rating = <span style="color:#ae81ff">30</span>
</span></span><span style="display:flex;"><span>  print(<span style="color:#e6db74">&#34;Current score Task 2: </span><span style="color:#e6db74">\(</span>tvShowLibrary.shows.first!.rating<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>) 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>因为<code>Task.detached</code>没有从顶层上下文中继承<code>actor</code>，即上面两个Task变成了是完全相互独立的，这会导致数据竞争。Swift为了避免出现这种错误，编译器时会出现错误或提示（根据Xcode版本不同而不同）。</p>
<p>对于上面这种情况，最合理的解决方案是将<code>TVShowLibrary</code>改为一个<code>actor</code>而不是一个<code>struct</code>。这是因为多个任务都对修改它感兴趣，这正是<code>actor</code>的完美用法。</p>
<h4 id="classes">Classes</h4>
<p>class默认是不可发送的。但是，当class被标记为final并且具有只读属性时，可以使它们遵循<code>Sendable</code>协议。即可以将<code>TVShow</code>标记为遵循<code>Sendable</code>，这样你的代码将能够编译，不会有任何警告。下面代码展示了们尝试这样做时会得到的警告。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TVShow</span>:Sendable {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> name: String
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> rating:Int = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(name: String) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 出现的警告</span>
</span></span><span style="display:flex;"><span>Non<span style="color:#f92672">-</span><span style="color:#66d9ef">final</span> <span style="color:#66d9ef">class</span> <span style="color:#960050;background-color:#1e0010">&#39;</span>TVShow<span style="color:#960050;background-color:#1e0010">&#39;</span> cannot conform to <span style="color:#960050;background-color:#1e0010">&#39;</span>Sendable<span style="color:#960050;background-color:#1e0010">&#39;</span>; use <span style="color:#960050;background-color:#1e0010">&#39;</span>@unchecked Sendable<span style="color:#960050;background-color:#1e0010">&#39;</span>; this <span style="color:#66d9ef">is</span> an error <span style="color:#66d9ef">in</span> the Swift <span style="color:#ae81ff">6</span> language mode
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Stored property <span style="color:#960050;background-color:#1e0010">&#39;</span>rating<span style="color:#960050;background-color:#1e0010">&#39;</span> of <span style="color:#960050;background-color:#1e0010">&#39;</span>Sendable<span style="color:#960050;background-color:#1e0010">&#39;</span><span style="color:#f92672">-</span>conforming <span style="color:#66d9ef">class</span> <span style="color:#960050;background-color:#1e0010">&#39;</span>TVShow<span style="color:#960050;background-color:#1e0010">&#39;</span> <span style="color:#66d9ef">is</span> mutable; this <span style="color:#66d9ef">is</span> an error <span style="color:#66d9ef">in</span> the Swift <span style="color:#ae81ff">6</span> language mode
</span></span></code></pre></div><p>将<code>TVShow</code>标记为<code>final</code>时可以消除第一个警告，将<code>rating</code>改为let声明时才能消除第二个警告，当这样做之后我们后续也不能修改<code>rating</code>的值了。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">final</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TVShow</span>:Sendable {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> name: String
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> rating:Int = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(name: String) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>一般来说，如果你需要使得定义的类变成<code>Sendable</code>的，将其标记为<code>final</code>并使所有属性变成只读的是最佳做法，但在这里是不可能的，情况就是这样。</p>
<p>我们唯一能修复这个类的方法是选择退出编译器的安全检查。要做到这一点，需要在<code>Sendable</code>协议前添加<code>@unchecked</code>关键字。下面是不会产生任何警告的TVShow类。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TVShow</span>: @unchecked Sendable {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> name: String
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> rating:Int = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(name: String) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>但需要注意的是，使用<code>@unchecked</code>只是临时规避编译器检查。因为这个类本身没有同步保护机制，当多个任务或<code>actor</code>同时修改它时会导致数据竞争。可以通过使用类似使用NSLock等机制来添加同步保护。下面代码展示了一个简单实现的例子。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TVShow</span>: @unchecked Sendable {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> mutex = NSLock()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> name: String
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> rating: Int = <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">willSet</span> { 
</span></span><span style="display:flex;"><span>          mutex.lock() 
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">didSet</span> { 
</span></span><span style="display:flex;"><span>          mutex.unlock() 
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(name: String) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>不建议在生产环境中使用此代码，除非你真正理解锁等<code>concurrency primitives</code>的工作原理。新的并发系统旨在帮助开发者无需关注这些细节。</p>
<h4 id="closures">Closures</h4>
<p>在Swift闭包是一等公民，可以将闭包和函数引用传递给代码的其它部分，以便随时调用它们。在使用Swift中集合的<code>filter、map</code>和<code>reduce</code>方法时可能已经见过这一点。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>library.shows.filter { $0.rating <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">10</span> <span style="color:#f92672">&amp;&amp;</span> $0.rating <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">30</span> }
</span></span></code></pre></div><p>因为可以将函数和闭包传递给代码中的其它部分，所以可以确信它们也应该是可发送的。因为函数或闭包不能遵循协议，但我们可以使用<code>@Sendable</code>属性来替代。当使用<code>@Sendable</code>属性时，编译器会认为它不需要对任何内容进行同步，因为<code>@Sendable</code>函数的主体是可发送的，而可发送的闭包只能捕获可发送的类型。</p>
<p>查看<code>Task</code>的定义，可以发现泛型<code>Success</code>遵循了<code>Sendable</code>协议。因此，<code>task</code>可以操作<code>Sendable</code>类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>@frozen <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Task</span>&lt;Success, Failure&gt; <span style="color:#66d9ef">where</span> Success : Sendable, Failure : Error
</span></span></code></pre></div><p>接着查看<code>Task</code>的初始化器以及<code>detached</code>静态方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>@discardableResult <span style="color:#66d9ef">init</span>( priority: TaskPriority? = <span style="color:#66d9ef">nil</span>, operation: @escaping () async -&gt; Success )
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//...</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>@discardableResult <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">detached</span>( priority: TaskPriority? = <span style="color:#66d9ef">nil</span>, operation: @escaping () async <span style="color:#66d9ef">throws</span> -&gt; Success ) -&gt; Task&lt;Success, Failure&gt;
</span></span></code></pre></div><p>我们已经确认<code>Success</code>是遵循<code>Sendable</code>协议的，这是<code>Swift</code>通过其机制确保非<code>Sendable</code>类型不能被传递到其他并发区域的方式。初始化器接受一个返回<code>Sendable</code>类型的闭包，而<code>detached</code>方法返回一个具有相同要求的<code>Task</code>。</p>
<p>我们可以参照这种方式创建自己的<code>Sendable</code>函数，下面代码声明了一个使用<code>@Sendable</code>标记的闭包，这个方法会在执行方法之前打印一些内容，在执行之后也会打印一些内容。可以使用这样的函数来对你的方法进行基准测试。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">logBeginningAndEnd</span>(operation: @Sendable () -&gt; Void) { 
</span></span><span style="display:flex;"><span>  print(<span style="color:#e6db74">&#34;Calling Closure&#34;</span>) 
</span></span><span style="display:flex;"><span>  operation() 
</span></span><span style="display:flex;"><span>  print(<span style="color:#e6db74">&#34;Closure finished&#34;</span>) 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们尝试着调用这个方法，传递一个非<code>sendable</code>的东西：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> tvShowLibrary = TVShowLibrary() 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>logBeginningAndEnd {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> showsCount = tvShowLibrary.shows.count
</span></span><span style="display:flex;"><span>  print(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">\(</span>showsCount<span style="color:#e6db74">)</span><span style="color:#e6db74"> Shows&#34;</span>) 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>函数<code>logBeginningAndEnd</code>要求闭包参数要求是<code>sendable</code>的，但传递的实参却是非<code>sendable</code>的，此时编译器会给出警告：<code>Converting non-sendable function value to ‘@Sendable () -&gt; Void</code>。</p>
<p>所以，如果确定你的函数可以在不同的线程间共享，请不要忘记将它们标标记为<code>@Sendable</code>，这样系统就不会发出任何不必要的警告。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>@Sendable <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">doSomething</span>() {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>当然，不要对每一个函数或方法都标记为<code>@Sendable</code>。只有在你确定这些函数可以在不同的并发域中安全使用，并且有意这样使用时，才这么做。</p>
<p>最后，如果有一个可以存储闭包的变量，也可以将其限制为<code>@Sendable</code>闭包。下面代码声明了一个类，该类有一个可以存储<code>@Sendable</code>闭包的属性。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClass</span> { 
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> aClosure: @Sendable () -&gt; Void
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">init</span>(aClosure: @escaping @Sendable () -&gt; Void) { 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">self</span>.aClosure = aClosure 
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> myObject = MyClass { @Sendable <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">let</span> a = <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="the-main-actor--final-actors">The Main Actor &amp; Final Actors</h2>
<p>Actors是引用类型，它同步自身的内部状态，可以从不同线程安全地修改它们。这是通过保证同一时间只有一个任务或线程可以修改<code>actor</code>的状态来实现的。<code>actor</code>是可发送的类型，意味着它可用于并发环境。<code>actor</code>是可以实例化的，并在大部分情况下，像普通<code>class</code>一样的类型。</p>
<p>但是，有时我们遇到需要总是保证在同一个线程上运行，但可能被分散到各处，甚至跨不同文件时的场景，又该如何处理呢？</p>
<h3 id="the-main-thread">The Main Thread</h3>
<p>主线程唯一职责是运行UI相关代码。如果想更新一个标签、给视图添加颜色或切换一个开关，需要在主线程上执行这些操作。不允许在主线程之外更新UI，若在主线程外更新UI，轻则编译器给出警告，重则会导致运行时崩溃。如果正在运行异步任务—无论是使用新的并发系统还是旧工具如GCD，并且希望在UI中显示返回的数据，都在主线程上执行这一操作。</p>
<p>因为主线程负责更新UI，如果在主线程执行任何耗时操作，会使应用挂起几秒钟，或导致UI出现明显卡顿和画面掉帧。如果应用长时间挂起，系统会采取措施终止它。这就是为什么很多API，包括<code>URLSession</code>中的所有网络调用，默认在单独的线程中运行的原因，无论使用这些方法的<code>async/await</code>版本还是传统的基于闭包方式的方法。可以强制让<code>URLSession</code>和其他异步API在主线程运行，但建议千万不要这么做。</p>
<p>简而言之，使用<code>UIKit</code>（以及由此延伸的<code>SwiftUI</code>）进行的任何操作都需要在主线程上执行，并且需要避免在主线程上执行耗时的工作。传统上，我们会将数据传递到主线程，调用类似<code>DispatchQueue.main.async</code>的方法。这种方法接受一个在主线程执行的闭包，因此非常适合在主线程中操作你的UI。<code>DispatchQueue</code>是GCD中的一个对象，而<code>main</code>静态属性指的是主线程队列，它始终在主线程运行。这是一种快速且无痛的方法，可以回到主线程，安全，但如果你大量使用它，也会产生相当多的<code>pyramids of doom</code>。在iOS中，任何以UI前缀开头的对象（如<code>UIButton</code>、<code>UISwitch</code>）或在macOS中的任何AppKit对象都只能在主线程中进行修改。</p>
<p>从<code>Xcode 14</code>及其所有配套的OS发布版本开始，<code>UIImage</code>和<code>UIColor</code>是“所有UI前缀的对象都应从主线程进行修改”这一规则的例外。从这个Xcode版本开始，<code>UIImage</code>和<code>UIColor</code>遵循<code>Sendable</code>协议，因此可以安全地在不同的并发域之间传递。</p>
<p>在现代的并发系统中，系统会决定是否将你的任务在不同的线程中启动。请记住我们之前学过的，当任务遇到 <code>await</code>关键字时会暂停，而系统会决定在另一个线程中启动该调用。如果发生暂停，你并不知道代码会在哪里执行，甚至不知道使用哪个线程来交付结果。那么在使用新的并发系统时，我们如何将结果传递给主线程，以便在完成耗时任务后更新我们的UI呢？嗯，很高兴你问到了！</p>
<h3 id="the-main-actor">The Main Actor</h3>
<p>终于可以解释一下一直在使用的东西，但很难找到一个合适的时机来解释它。是的，就是<code>main actor</code>，它在代码中显示为<code>@MainActor</code>。</p>
<p><code>UIKit</code>和<code>SwiftUI</code>都是大型的<code>frameworks</code>，它们由成百上千个类组成，很可能分散在框架的不同文件中，它们都有一个要求，即任何UI更新都应在主线程进行。将声明标记为<code>@MainActor</code>意味着该特定功能将在主线程上运行。<code>@MainActor</code>本质上被视为一个属性。在<code>iOS 15、macOS 12、watchOS 8</code>和<code>tvOS 16</code>中，这些框架中的大多数类都标记为<code>@MainActor</code>。在使用<code>SwiftUI</code>时，创建<code>ObservableObjects</code>应手动标记为<code>@MainActor</code>，因为该协议本身并不包含这一功能。将<code>UIKit、SwiftUI</code>和<code>AppKit</code>中的所有对象标记为<code>@MainActor</code>是一种非常优雅的解决方案，以确保它们都在主线程上运行。</p>
<h4 id="using-the-mainactor">Using the @MainActor</h4>
<p>如同<code>@Sendable</code>属性，也可以在许多不同地方使用<code>@MainActor</code>属性。可以在类型声明中使用它，比如结构体或类。下面声明了一个结构体和一个类，其中类是用<code>@MainActor</code>标记的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">MusicAlbum</span> { 
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> name: String 
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> artist: String 
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> releaseYear: Int 
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>@MainActor <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MusicLibrary</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> name: String 
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> albums: [MusicAlbum] = []
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">init</span>(name: String) { 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">self</span>.name = name 
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>因为这个原因，想要在类<code>MusicLibrary</code>实例上执行的每一个操作都需要在<code>main actor</code>上运行。<code>MusicLibrary</code>中的每一个属性和方法也会在<code>main actor</code>上运行。想象一下有一个函数<code>createLibraryAndAddAlbum</code>，它是在 <code>MusicLibrary</code>对象本身的上下文之外创建的。你可能试图在这个新函数中对<code>MusicLibrary</code>进行操作。下面示例代码，尝试在一个不在<code>@MainActor</code>上运行的上下文中使用这个类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">createLibraryAndAddAlbum</span>() { 
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> library = MusicLibrary(name: <span style="color:#e6db74">&#34;Andy&#39;s Library&#34;</span>) 
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> album = MusicAlbum(name: <span style="color:#e6db74">&#34;Imaginareum&#34;</span>, artist: <span style="color:#e6db74">&#34;Nightwish&#34;</span>, releaseYear: <span style="color:#ae81ff">2011</span>)
</span></span><span style="display:flex;"><span>  library.shows <span style="color:#f92672">+=</span> [album] 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果尝试编译上面代码，会得到与在不同并发域之间传递非可发送类型时类似的错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>Call to main actor<span style="color:#f92672">-</span>isolated initializer <span style="color:#960050;background-color:#1e0010">&#39;</span><span style="color:#66d9ef">init</span>(name:)<span style="color:#960050;background-color:#1e0010">&#39;</span> <span style="color:#66d9ef">in</span> a synchronous nonisolated context
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>Property <span style="color:#960050;background-color:#1e0010">&#39;</span>albums<span style="color:#960050;background-color:#1e0010">&#39;</span> isolated to global actor <span style="color:#960050;background-color:#1e0010">&#39;</span>MainActor<span style="color:#960050;background-color:#1e0010">&#39;</span> can not be mutated from this context
</span></span></code></pre></div><p>若在<code>createLibraryAndAddAlbum</code>前加上<code>@MainActor</code>，那么函数也会在<code>main actor</code>中运行。<code>MusicLibrary</code>和<code>createLibraryAndAddAlbum</code>函数将会在相同的<code>actor</code>（同一线程）中运行。无论这两个是否在同一个文件中，甚至跨不同的框架也没关系。这就是为什么<code>main actor</code>被称为全局<code>actor</code>的原因。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>@MainActor
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">createLibraryAndAddAlbum</span>() { 
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> library = MusicLibrary(name: <span style="color:#e6db74">&#34;Andy&#39;s Library&#34;</span>) 
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> album = MusicAlbum(name: <span style="color:#e6db74">&#34;Imaginareum&#34;</span>, artist: <span style="color:#e6db74">&#34;Nightwish&#34;</span>, releaseYear: <span style="color:#ae81ff">2011</span>)
</span></span><span style="display:flex;"><span>  library.shows <span style="color:#f92672">+=</span> [album] 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果在不同的<code>actor</code>中，可以调用标记为<code>@MainActor</code>的方法，但这样做需要异步进行（使用await或async let），因为<code>@MainActor</code>会在所有使用它的声明中同步其自身的内部状态。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>@MainActor <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">populateFromWebService</span>() async {
</span></span><span style="display:flex;"><span>  albums = []
</span></span><span style="display:flex;"><span>  albums = <span style="color:#66d9ef">try</span> await WebService.shared.albumsFromService() 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>假设<code>populateFromWebService</code>方法是一个长时间运行的会被挂起的操作，这个<code>actor</code>将会在哪运行？长时间运行的操作（<code>populateFromWebService</code>函数本身）仍然会在不同的线程上运行。你不知道它会在哪里运行，只知道<code>main actor</code>的方法会挂起，而该线程会在返回之前执行其他工作。</p>
<p>在主actor自身上执行的是对<code>albums</code>方法的赋值。仅仅是赋值。<code>populateFromWebService</code>会在其他地方运行，但将它返回的数据赋值给<code>self.albums</code>则会在<code>main actor</code>上执行。很多人误以为<code>populateFromWebService</code>本身会在<code>main actor</code>上执行。也就是说，如果这个方法是从一个慢服务下载一些JSON数据并解析或者做任何可能需要比毫秒更长时间的操作，它会在主线程上运行。这是不正确的，幸运的是全局演员系统比这更聪明。如果在<code>@MainActor</code>上运行某些操作，始终要明白所有语句都会在主演员上执行，但如果它发现一个挂起调用，触发挂起的执行将会在其他地方进行，而数据将返回（并赋值）在主线程上。<code>await</code>的“左边”部分会在主线程上执行，而<code>await</code>关键字的“右边”部分则会在其他地方执行，可以说。</p>

    </div>
    <footer class="post-footer">
        
 
<div class="post-tags">     
     
    <a href="https://iihui.github.io/tags/ios" rel="tag" title="iOS">#iOS#</a>
    
</div>



        <div class="post-nav">
    <div class="post-nav-next post-nav-item">
    
        <a href="https://iihui.github.io/post/oc-tour/" rel="next" title="OC 入门">
        <i class="fa fa-chevron-left"></i> OC 入门
        </a>
    
    </div>

    <div class="post-nav-prev post-nav-item">
    
        <a href="https://iihui.github.io/post/js-data-struct/" rel="prev" title="JavaScript 数据类型">
        JavaScript 数据类型 <i class="fa fa-chevron-right"></i>
        </a>
    
    </div>
</div>
      
        <div class="post-nav">
    <div style="border: 1px dashed #e0e0e0; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
        <div style="float:left;margin-top:0px;">
            <img src="https://i.loli.net/2020/02/09/SvhUdz4XJsOr9Vk.jpg" width="128px" height="128px"/>
            <div style="text-align:center;">谢谢支持!</div>
        </div>
        <div>
            <p style="margin-top:10px;">
                标题：swift中的方法
                <br />作者：阿呆<a target="_blank" href="https://iihui.github.io/"></a>
                
                <br />地址：https://iihui.github.io/post/swift-method/
                <br />声明：自由转载-非商用-保持署名（创作共享4.0许可证）
            </p>
        </div>
    </div>
    <div class="clear"></div>
</div>
        
        
        




    </footer>
  </article>
</section>

          </div>
        </div>
        <div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>
<aside id="sidebar" class="sidebar">
  <div class="sidebar-inner">

  <ul class="sidebar-nav motion-element">
    <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
      文章目录
    </li>
    <li class="sidebar-nav-overview" data-target="site-overview">
      站点概览
    </li>
  </ul>

    <section class="site-overview sidebar-panel ">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
        src="https://i.loli.net/2020/02/07/dVFzrvZkHRNq2lL.jpg"
        alt="" />
    <p class="site-author-name" itemprop="name"></p>
    <p class="site-description motion-element" itemprop="description"> 
        coder &amp; cook</p>
</div>
      <nav class="site-state motion-element">
    <div class="site-state-item site-state-posts">
      <a href="https://iihui.github.io/post/">
        <span class="site-state-item-count">143</span>
        <span class="site-state-item-name">日志</span>
      </a>
    </div>
    <div class="site-state-item site-state-categories">    
        <a href="https://iihui.github.io/categories/">      
         
        <span class="site-state-item-count">18</span>
        
        <span class="site-state-item-name">分类</span>
        
        </a>
    </div>

    <div class="site-state-item site-state-tags">
        <a href="https://iihui.github.io/tags/">
         
        <span class="site-state-item-count">29</span>
        
        <span class="site-state-item-name">标签</span>
        </a>
    </div>
</nav>
      
      
<div class="links-of-author motion-element">
    
        <span class="links-of-author-item">
        <a href="https://coolshell.cn" target="_blank" title="皓 大">
            <i class="fa fa-fw fa-globe"></i>
            皓 大
        </a>
        </span>
    
        <span class="links-of-author-item">
        <a href="http://www.ruanyifeng.com" target="_blank" title="阮 大">
            <i class="fa fa-fw fa-globe"></i>
            阮 大
        </a>
        </span>
    
        <span class="links-of-author-item">
        <a href="https://juejin.im/" target="_blank" title="掘 金">
            <i class="fa fa-fw fa-globe"></i>
            掘 金
        </a>
        </span>
    
</div>


      

      <div class="links-of-blogroll motion-element inline">
<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=&amp;m=0&amp;s=220&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;bv=35" async="async"></script>
</div>

    </section>
    
<section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
    <div class="post-toc">
        <div class="post-toc-content"><nav id="TableOfContents">
  <ul>
    <li><a href="#实例方法">实例方法</a>
      <ul>
        <li><a href="#异变方法">异变方法</a></li>
        <li><a href="#self属性">self属性</a></li>
      </ul>
    </li>
    <li><a href="#类型方法">类型方法</a></li>
    <li><a href="#modern-concurrency">Modern Concurrency</a>
      <ul>
        <li><a href="#introducing-asyncawait">Introducing async/await</a>
          <ul>
            <li><a href="#the-async-keyword">The async keyword</a></li>
            <li><a href="#the-await-keyword">The await keyword</a></li>
            <li><a href="#using-asyncawait">Using async/await</a></li>
            <li><a href="#async-get-properties">async get properties</a></li>
            <li><a href="#asyncawait-in-ios-13-and-ios-14">async/await in iOS 13 and iOS 14</a></li>
          </ul>
        </li>
        <li><a href="#continuations">Continuations</a>
          <ul>
            <li><a href="#understanding-continuations">Understanding Continuations</a></li>
            <li><a href="#converting-closure-based-calls-into-asyncawait">Converting closure-based calls into async/await</a></li>
            <li><a href="#converting-delegate-based-code-into-asyncawait">Converting delegate-based code into async/await</a></li>
            <li><a href="#supporting-asyncawait-in-ios-13-and-14">Supporting async/await in iOS 13 and 14</a></li>
          </ul>
        </li>
        <li><a href="#structured-concurrency">Structured Concurrency</a>
          <ul>
            <li><a href="#understanding-structured-concurrency">Understanding Structured Concurrency</a></li>
            <li><a href="#the-async-let-construct">The async let construct</a></li>
            <li><a href="#task-groups">Task Groups</a>
              <ul>
                <li><a href="#task-groups-in-action">Task Groups in Action</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#unstructured-concurrency">Unstructured Concurrency</a>
          <ul>
            <li><a href="#tasks-in-depth">Tasks in Depth</a></li>
            <li><a href="#creating-tasks">Creating Tasks</a></li>
            <li><a href="#the-task-tree">The Task Tree</a></li>
            <li><a href="#error-propagation">Error Propagation</a></li>
            <li><a href="#task-cancellation">Task Cancellation</a></li>
            <li><a href="#task-cancellation-and-task-groups">Task Cancellation and Task Groups</a></li>
            <li><a href="#unstructured-concurrency-with-detached-tasks">Unstructured Concurrency with Detached Tasks</a></li>
          </ul>
        </li>
        <li><a href="#actors">Actors</a>
          <ul>
            <li><a href="#introducing-actors">Introducing Actors</a>
              <ul>
                <li><a href="#interacting-with-an-actor">Interacting with an Actor</a></li>
                <li><a href="#nonisolated-access-to-an-actor">Nonisolated Access to an Actor</a></li>
              </ul>
            </li>
            <li><a href="#actors-and-protocol-conformance">Actors and Protocol Conformance</a></li>
            <li><a href="#actor-reentrancy">Actor Reentrancy</a></li>
            <li><a href="#actors-and-detached-tasks">Actors and Detached Tasks</a></li>
            <li><a href="#general-tips-for-working-with-actors">General Tips for Working with Actors</a></li>
          </ul>
        </li>
        <li><a href="#sendable-types">Sendable Types</a>
          <ul>
            <li><a href="#understanding-sendable-types">Understanding Sendable Types</a></li>
            <li><a href="#the-sendable-protocol">The Sendable Protocol</a></li>
            <li><a href="#analyzing-sendable-types">Analyzing Sendable Types</a>
              <ul>
                <li><a href="#structs">Structs</a></li>
                <li><a href="#classes">Classes</a></li>
                <li><a href="#closures">Closures</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#the-main-actor--final-actors">The Main Actor &amp; Final Actors</a>
          <ul>
            <li><a href="#the-main-thread">The Main Thread</a></li>
            <li><a href="#the-main-actor">The Main Actor</a>
              <ul>
                <li><a href="#using-the-mainactor">Using the @MainActor</a></li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav></div>
    </div>
</section>

  </div>
</aside>

      </div>
    </main>
   
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  <span itemprop="copyrightYear">  &copy; 
  2017 - 2025</span>
  <span class="with-love"><i class="fa fa-heart"></i></span>
  <span class="author" itemprop="copyrightHolder">Keep It Simple</span>
</div>




      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      <span id="scrollpercent"><span>0</span>%</span>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/jquery/index.js?v=2.1.3"></script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script> 
<script type="text/javascript" src="https://iihui.github.io/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/velocity/velocity.min.js?v=1.2.1"></script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="https://iihui.github.io/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>

<script src="https://iihui.github.io/js/vendor/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>

<script type="text/javascript" src="https://iihui.github.io/js/utils.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/motion.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/affix.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/schemes/pisces.js"></script>

<script type="text/javascript" src="https://iihui.github.io/js/scrollspy.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/post-details.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/toc.js"></script>

<script type="text/javascript" src="https://iihui.github.io/js/bootstrap.js"></script>

<script type="text/javascript" src="https://iihui.github.io/js/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
</body>
</html>