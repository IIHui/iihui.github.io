<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
    <title>TypeScript基础 - Keep It Simple</title>
    <meta name="keywords" content="博客,思考,读书,笔记,技术,分享">
    
    <meta property="og:title" content="TypeScript基础">
    <meta property="og:site_name" content="Keep It Simple">
    <meta property="og:image" content="/img/author.jpg"> 
    <meta name="title" content="TypeScript基础 - Keep It Simple" />
    <meta name="description" content="Swift | Go | C&#43;&#43; "> 
    <link rel="shortcut icon" href="https://iihui.github.io/img/favicon.ico" />
    <link rel="apple-touch-icon" href="https://iihui.github.io/img/apple-touch-icon.png" />
    <link rel="apple-touch-icon-precomposed" href="https://iihui.github.io/img/apple-touch-icon.png" />
    <link href="https://iihui.github.io/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />
    <link href="https://iihui.github.io/js/vendor/fancybox/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />
    <link href="https://iihui.github.io/css/main.css" rel="stylesheet" type="text/css" />
    <link href="https://iihui.github.io/css/syntax.css" rel="stylesheet" type="text/css" />

    <script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
     fancybox: true, 
    motion: true
  };
</script>

    <link href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/monokai-sublime.min.css" rel="stylesheet">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/go.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/swift.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/objectivec.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/clojure.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/kotlin.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/yaml.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<div class="container one-collumn sidebar-position-left page-home  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-meta  custom-logo ">

  <div class="custom-logo-site-title">
    <a href="https://iihui.github.io/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Keep It Simple</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">靡不有初，鲜克有终</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
    <ul id="menu" class="menu">
      
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/tags/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-tag"></i> <br />标签
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/post/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/categories/%E7%BE%8E%E9%A3%9F/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-fire"></i> <br />美食
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/categories/%E5%90%8E%E6%9C%9F/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-edit"></i> <br />后期
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/categories/%E6%97%85%E8%A1%8C/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-leaf"></i> <br />旅行
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/about/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于
          </a>
        </li>
      
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger"> <i class="menu-item-icon fa fa-search fa-fw"></i> <br /> 搜索</a>
      </li>
    </ul>
    <div class="site-search">
      <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>

    </div>
</nav>
<script type="text/javascript"
        async
        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
		<!-- src = "http://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> <\!--  -\-> -->
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>

<!DOCTYPE html>
<html lang="en">


<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css" integrity="sha384-D+9gmBxUQogRLqvARvNLmA9hS2x//eK1FhVb9PiU86gmcrBrJAQT8okdJ4LMp2uv" crossorigin="anonymous">

    
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js" integrity="sha384-483A6DwYfKeDa0Q52fJmxFXkcPCFfnXMoXblOkJ4JcA8zATN6Tm78UNL72AKk+0O" crossorigin="anonymous"></script>
</head>
<body>

</body>
</html>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
<section id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="https://iihui.github.io/post/ts-base/" itemprop="url">
        TypeScript基础
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">创建: </span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2022-01-27">
    2022-01-27
</time>
</span>
&nbsp; | &nbsp;
<span class="post-updated-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-check-o"></i>
</span>
<span class="post-meta-item-text">更新: </span>
<time itemprop="dateUpdated" content="2022-01-27">
    2022-01-27
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类: </span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="https://iihui.github.io/categories/ts" itemprop="url" rel="index">
        <span itemprop="name">ts</span>
      </a>
      &nbsp; 
    </span>
  
</span>


      <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-file-word-o"></i>
</span>
<span class="post-meta-item-text">字数: </span>
<span class="leancloud-visitors-count">61513</span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-coffee"></i>
</span>
<span class="post-meta-item-text">阅读: </span>
<span class="leancloud-visitors-count">123 分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <p><code>TypeScript</code>的7种基本类型为：</p>
<ul>
<li><code>null</code></li>
<li><code>undefined</code></li>
<li><code>boolean</code></li>
<li><code>string</code></li>
<li><code>number</code></li>
<li><code>bigint</code></li>
<li><code>symbol</code></li>
</ul>
<p>若声明变量时不显式标注类型，编译器会推断该变量的类型为<code>any</code>，<font color="#de7802">表示该变量可以被赋为任何类型的值</font>。如果声明变量时既不标注类型也不初始化，接着立即使用<code>typeof</code>得到的结果为<code>undefined</code>。是因为<code>TypeScript</code>编译成<code>JavaScript</code>后，未初始化变量的默认值为<code>undefined</code>，所以使用<code>typeof</code>得到的类型就是<code>undefined</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">rocker</span>; <span style="color:#75715e">// Type: any
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">rocker</span>) <span style="color:#75715e">// 运行结果为undefined
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">rocker</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Joan Jett&#34;</span> <span style="color:#75715e">// 此时类型为string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">rocker</span>.<span style="color:#a6e22e">toUpperCase</span>() <span style="color:#75715e">// JOAN JETT
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">rocker</span>) <span style="color:#75715e">// Joan Jett
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">rocker</span>) <span style="color:#75715e">// string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">rocker</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">19.58</span> <span style="color:#75715e">// 此时类型为number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">rocker</span>, <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">rocker</span>) <span style="color:#75715e">// 19.58 number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">rocker</span>) <span style="color:#75715e">// number
</span></span></span></code></pre></div><p>函数的<font color="#de7802">可选参数必须放在必需参数之后，若将可选参数放在必需参数前，会出现编译错误</font>。下面示例代码会出现编译错误：<code>A required parameter cannot follow an optional parameter</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：A required parameter cannot follow an optional parameter
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">hello3</span>(<span style="color:#a6e22e">x?</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>函数中具有<font color="#de7802">默认值的参数若不位于参数列表的末尾，调用时不能省略该参数，此时如果要触发默认值，必须显式地传入<code>undefined</code></font>。下面示例代码中，函数的第一个参数传入了<code>undefined</code>，触发了<code>x</code>的默认值<code>3</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">hello3</span>(<span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>, <span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">hello3</span>(<span style="color:#66d9ef">undefined</span>, <span style="color:#ae81ff">890</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">3</span> <span style="color:#ae81ff">890</span>
</span></span></code></pre></div><p>空值合并二元运算符<code>??</code>用于检查左侧表达式的求值是否等于<code>null</code>或者<code>undefined</code>。如果左侧表达式为<code>null</code>或者<code>undefined</code>，则表达式的结果为右侧表达式，否则结果为左侧表达式。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">b</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">c</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 因为表达式左侧为null或undefined,所以表达式均为右侧的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">a</span> <span style="color:#f92672">??</span> <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">b</span> <span style="color:#f92672">??</span> <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 因为a是null所以 a ?? c取c的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">a</span> <span style="color:#f92672">??</span> <span style="color:#a6e22e">c</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 因为a是null所以 a ?? b取b的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">a</span> <span style="color:#f92672">??</span> <span style="color:#a6e22e">b</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span>   
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">null</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">undefined</span>
</span></span></code></pre></div><p>在访问对象属性时，<font color=red>如果该属性是<code>undefined</code>或者<code>null</code>，可选链运算符都会返回<code>undefined</code></font>。下面示例代码中，<code>getSpouseNick</code>的返回类型必须为<code>string | null | undefined</code>，因为<code>this.spouse?.nick</code>的值可能是<code>null</code>或<code>undefined</code>。可选链可以任意长，即可以包含任意数量的<code>?.</code>运算符。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">nick</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">spouse?</span>: <span style="color:#66d9ef">Person</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">setSpouse</span>(<span style="color:#a6e22e">spouse</span>: <span style="color:#66d9ef">Person</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">void</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">spouse</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">spouse</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">getSpouseNick</span>()<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// nick的类型是string | null，但使用了?操作符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 所以this.spouse?.nick的类型可能为undefined
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">spouse</span><span style="color:#f92672">?</span>.<span style="color:#a6e22e">nick</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">constructor</span>(<span style="color:#a6e22e">nick</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">nick</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">nick</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">spouse</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">undefined</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">person</span>: <span style="color:#66d9ef">Person</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Person</span>(<span style="color:#e6db74">&#39;nick&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">person</span>.<span style="color:#a6e22e">spouse</span><span style="color:#f92672">?</span>.<span style="color:#a6e22e">nick</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">undefined</span>
</span></span></code></pre></div><p>作为对比，在下面示例代码中，因为属性<code>spouse</code>的默认值是<code>null</code>，若不改变值，则使用可选操作符<code>?</code>后得到的值为<code>undefined</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">nick</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">spouse?</span>: <span style="color:#66d9ef">Person</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">setSpouse</span>(<span style="color:#a6e22e">spouse</span>: <span style="color:#66d9ef">Person</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">void</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">spouse</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">spouse</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">getSpouseNick</span>()<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">spouse</span><span style="color:#f92672">?</span>.<span style="color:#a6e22e">nick</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">person</span>: <span style="color:#66d9ef">Person</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Person</span>()
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">person</span>.<span style="color:#a6e22e">spouse</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// spouse的值为null使用了可选链后得到的nick的值为undefined
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">person</span>.<span style="color:#a6e22e">spouse</span><span style="color:#f92672">?</span>.<span style="color:#a6e22e">nick</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">null</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">undefined</span>
</span></span></code></pre></div><h1 id="modules">Modules</h1>
<p><code>JavaScript</code>编程语言最近才规范了文件之间如何共享代码。<code>ECMAScript 2015</code>增加了<code>ECMAScript Modules</code>以规范文件间的<code>import</code>和<code>export</code>语法。</p>
<p>在<code>module</code>文件中<font color="#de7802">声明的任何内容都只能在该文件中使用</font>，除非该文件中有明确的<code>export</code>语句。下面代码中，<code>test.ts</code>文件从同级的<code>./values</code>文件中导入了<code>value</code>，并导出了一个<code>doubled</code>常量值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// values.ts 中的代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">12</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// test.ts 中的代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">import</span> { <span style="color:#a6e22e">value</span> } <span style="color:#66d9ef">from</span> <span style="color:#e6db74">&#34;./values&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">doubled</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>;
</span></span></code></pre></div><p>如果在某一个模块中声明的变量和另一个模块中声明的变量同名，一般不会冲突。只有当在一个文件中导入了另一个文件中的同名变量时，才会产生冲突。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// a.ts 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">shared</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Cher&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// b.ts 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">shared</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Cher&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// c.ts 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">import</span> { <span style="color:#a6e22e">shared</span> } <span style="color:#66d9ef">from</span> <span style="color:#e6db74">&#34;./a&#34;</span>; 
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Import declaration conflicts with local declaration of &#39;shared&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">shared</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Cher&#34;</span>; 
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Individual declarations in merged declaration &#39;shared&#39; must be all exported or all local.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 若不加export同样会出现编译错误，因为有同名变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Import declaration conflicts with local declaration of &#39;shared&#39;. 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">shared</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Cher&#34;</span>;
</span></span></code></pre></div><p>如果文件是脚本，<code>TypeScript</code>会<font color="#de7802">将其视为全局作用域，这意味着其它所有脚本文件都可以访问其中的内容</font>。也就是说，在某个脚本文件中声明的变量不能与其它脚本文件中声明的变量同名。</p>
<p>下面<code>a.ts</code>和<code>b.ts</code>文件均会被认为是脚本，因为它们中没有<code>export</code>和<code>import</code>语句。这意味着，如果在这两个文件中存在同名变量，就会产生冲突：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// a.ts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">shared</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Cher&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// b.ts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">shared</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Cher&#34;</span>; <span style="color:#75715e">// 编译错误：Cannot redeclare block-scoped variable &#39;shared&#39;.
</span></span></span></code></pre></div><p>根据<code>ECMAScript</code>规范，如果要将一个没有<code>export</code>或<code>import</code>语句的文件变成模块，可以<font color="#de7802">在文件的某个地方添加一个<code>export {};</code>语句来强制让它成为一个模块</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// a.ts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">shared</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Cher&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// b.ts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">shared</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Cher&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">export</span> {};
</span></span></code></pre></div><h1 id="unions-and-literals">Unions and Literals</h1>
<blockquote>
<p>联合：将值的允许类型扩展为两种或两种以上的可能类型。窄化：减少值的允许类型，使其不属于一种或多种可能的类型。联合和窄化是一种强大的概念，允许对代码做出比其他主流语言更智能的推断。</p>
</blockquote>
<h2 id="union-types">Union Types</h2>
<p>下面变量<code>mathematician</code>的类型既可以是<code>undefined</code>，也可以是<code>string</code>，<font color="#de7802">这种非此即彼的类型称为联合类型</font>。联合类型是一个奇妙的概念，它可以让我们在代码中处理这样的情况：暂时还不知道某个值的确切类型，但确定它是两个或多个类型之一。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 变量类型为string | undefined
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">mathematician</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> <span style="color:#66d9ef">undefined</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Mark Goldberg&#34;</span>;
</span></span></code></pre></div><p><code>TypeScript</code>使用管道操作符<code>|</code>来连接可能的类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">mathematician</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> <span style="color:#66d9ef">undefined</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Mark Goldberg&#34;</span>;
</span></span></code></pre></div><p>在<font color="#de7802">变量在有初始值的情况下，也显式地将其类型标注为联合类型有时很有用</font>。下面示例代码中，<code>thinker</code>一开始是<code>null</code>，但在某些情况下可能是字符串。将变量<code>thinker</code>的类型显式标注为<code>string | null</code>联合类型，意味着后续给它赋字符串类型的值是允许的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">thinker</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">thinker</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Susanne Langer&#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 每次执行时生成随机数不同，结果就会不同
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 结果可能是Susanne Langer string 或 null object
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">thinker</span>, <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">thinker</span>)  
</span></span></code></pre></div><p>联合类型可以放置在任何需要类型标注的地方。<strong><font color=red>当已知值是一个联合类型时，只允许访问联合中所有子类型都存在的共有成员</font></strong>。如果尝试访问的属性不是联合类型所有子类型的共有属性或共有方法（函数），会出现编译错误。</p>
<p>下面代码中，<code>physicist</code>是一个<code>number | string</code>联合类型变量。方法<code>toString()</code>在两个子类型中都存在，但<code>toUpperCase</code>方法仅存在于<code>string</code>类型，而<code>toFixed</code>方法仅存在于<code>number</code>类型。所以，如果直接调用<code>toUpperCase</code>和<code>toFixed</code>都会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// physicist变量类型为string | number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">physicist</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;Marie Curie&#34;</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">84</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">physicist</span>.<span style="color:#a6e22e">toString</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Property &#39;toUpperCase&#39; does not exist on type &#39;string | number&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Property &#39;toUpperCase&#39; does not exist on type &#39;number&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">physicist</span>.<span style="color:#a6e22e">toUpperCase</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Property &#39;toFixed&#39; does not exist on type &#39;string | number&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Property &#39;toFixed&#39; does not exist on type &#39;string&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">physicist</span>.<span style="color:#a6e22e">toFixed</span>()
</span></span></code></pre></div><p>需要注意的是，<font color="#de7802">限制访问不存在于联合类型所有子类型的属性或方法是一种安全措施</font>。如果一个对象还不确定是包含某个属性的子类型，<code>TypeScript</code>则认为尝试访问该子类型特有的属性是不安全的。</p>
<p>如果要使用仅存在于联合类型中某个子类型的属性或方法，我们的代码需向<code>TypeScript</code><font color=blue>表明在当前位置该值的类型就是某个具体的子类型，这一过程被称为窄化（<code>narrowing</code>）</font>。</p>
<h2 id="narrowing">Narrowing</h2>
<p>窄化是指在代码的某个位置推断出一个变量的类型比其声明时的类型更具体（范围更窄）。一旦知道一个值的类型比声明时的类型范围更窄，允许将该值的类型视为这个更具体（更窄）的类型。用于<font color="#de7802">窄化类型范围的逻辑检查称为类型保护</font>。下面介绍<code>TypeScript</code>可以用来从代码中窄化类型的两种常见类型保护。</p>
<h3 id="assignment-narrowing">Assignment Narrowing</h3>
<p>如果<font color="#de7802">直接赋值给一个联合类型变量，会立即将变量的类型缩小为该值的类型</font>。下面代码中，变量<code>admiral</code>声明为<code>number | string</code>联合类型。一旦变量被赋值为字符串<code>&quot;Grace Hopper&quot;</code>，编译器就知道它现在是字符串类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">admiral</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">admiral</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Grace Hopper&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">admiral</span>.<span style="color:#a6e22e">toUpperCase</span>(); <span style="color:#75715e">// Ok: string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Property &#39;toFixed&#39; does not exist on type &#39;string&#39;. Did you mean &#39;fixed&#39;?
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">admiral</span>.<span style="color:#a6e22e">toFixed</span>(); 
</span></span></code></pre></div><p>当变量的类型<font color="#de7802">显式地标注为联合类型并且同时有一个初始值时，赋值窄化就会发挥作用</font>。编译器知道，虽然变量以后可能会接收联合类型其它子类型的值，但它初始时只是初始值对应的类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">inventor</span>: <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Hedy Lamarr&#34;</span>; <span style="color:#75715e">// 窄化为string类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">inventor</span>.<span style="color:#a6e22e">toUpperCase</span>();
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Property &#39;toFixed&#39; does not exist on type &#39;string&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">inventor</span>.<span style="color:#a6e22e">toFixed</span>(); 
</span></span></code></pre></div><h3 id="conditional-checks">Conditional Checks</h3>
<p>除了赋值窄化，窄化变量类型的常见方法是使用<code>if</code>语句，<font color="#de7802">检查变量是否等于某个已知值</font>。编译器非常聪明，知道在<code>if</code>语句中，变量类型必须与已知值类型相同：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">scientist</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;Rosalind Franklin&#34;</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">51</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">scientist</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;Rosalind Franklin&#34;</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">scientist</span>.<span style="color:#a6e22e">toUpperCase</span>()) <span style="color:#75715e">// ROSALIND FRANKLIN
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 出了if语句，变量的类型既可能是string也可能是number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 因此调用string类型的toUpperCase()方法会出现错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Property &#39;toUpperCase&#39; does not exist on type &#39;string | number&#39;. Property &#39;toUpperCase&#39; does not exist on type &#39;number&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">scientist</span>.<span style="color:#a6e22e">toUpperCase</span>() 
</span></span></code></pre></div><p>除了在<code>if</code>条件中直接对值进行检查，还可以在其中使用<code>typeof</code>操作符窄化变量的类型范围。下面示例代码中，在<code>if</code>中使用<code>typeof</code>检查变量的类型是否为<code>string</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">scientist</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;Rosalind Franklin&#34;</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">51</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// if窄化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">scientist</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;string&#39;</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">scientist</span>.<span style="color:#a6e22e">toUpperCase</span>())
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">scientist</span>.<span style="color:#a6e22e">toFixed</span>())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>来自<code>!</code>和<code>else</code>语句对类型窄化同样有效：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 变量researcher类型为联合类型string | number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">researcher</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;Rosalind Franklin&#34;</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">51</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">researcher</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;string&#34;</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">researcher</span>.<span style="color:#a6e22e">toUpperCase</span>(); <span style="color:#75715e">// Ok: string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">researcher</span>.<span style="color:#a6e22e">toFixed</span>(); <span style="color:#75715e">// Ok: number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h2 id="literal-types">Literal Types</h2>
<p>介绍了联合和窄化用于处理可能是两种或两种以上类型的变量后，再来介绍一下字面量类型。<strong><font color=red>字面量类型是对应基础类型的更具体版本</font></strong>，这与其它语言区别较大：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 类型为&#34;Hypatia&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">philosopher</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Hypatia&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 使用typeof打印出来的还是string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">philosopher</span>) <span style="color:#75715e">// string
</span></span></span></code></pre></div><p>上面代码中，<code>philosopher</code>是什么类型？乍一看，你可能认为是字符串，没错，<code>philosopher</code>的确是字符串。但是，常量<code>philosopher</code>并不是一个普通的字符串，它的具体值是<code>&quot;Hypatia&quot;</code>。从技术上讲，常量<code>philosopher</code>的类型是更具体的<code>&quot;Hypatia&quot;</code>类型。</p>
<p>这就是字面类型的概念：<span style="background:rgba(255, 183, 139, 0.55)">是基本类型的某个特定值，而不是对应基本类型的任何其它值</span>。字符串基本类型代表了所有可能存在的字符串集合，而字符串字面量类型<code>&quot;Hypatia&quot;</code>只代表了这一特定字符串。</p>
<p>如果将一个变量声明为<code>const</code>，并直接赋值给它一个字面值，<code>TypeScript</code><font color="#de7802">将推断这个常量的类型是这个字面值类型</font>。这就是为什么在IDE中将鼠标悬停在带有初始字面值的<code>const</code>常量上时，会显示常量的类型为字面值，而不是对应的基本类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// philosopher的类型为Hypatia
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">philosopher</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Hypatia&#34;</span>
</span></span></code></pre></div><p>可以把每个基本类型看作是其所有可能字面值的联合类型。换句话说，<font color=red>基本类型是该类型所有可能字面值的集合</font>。除了<code>boolean</code>，<code>null</code>和<code>undefined</code>类型，所有其它基本类型（例如<code>number</code>和<code>string</code>）均有无限多的字面值类型。在<code>TypeScript</code>代码中会出现的常见类型如下：</p>
<ul>
<li><code>boolean</code>: 只有<code>true | false</code></li>
<li><code>null</code>和<code>undefined</code>只有一个字面值，就是它们自己</li>
<li><code>number</code>：<code>0 | 1 | 2 | ... | 0.1 | 0.2 | ...</code></li>
<li><code>string</code>:<code>&quot;&quot; | &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | ... | &quot;aa&quot; | &quot;ab&quot; | &quot;ac&quot; | ...</code></li>
</ul>
<p>需要注意的是，<strong><font color=red>联合类型允许将字面值类型和基本类型混合使用</font></strong>。例如，下面变量<code>lifespan</code>表示可以用任何数值或已知的几种字符串字面值来表示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">lifespan</span>: <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;ongoing&#34;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;uncertain&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">lifespan</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">89</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">lifespan</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;ongoing&#34;</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Type &#39;true&#39; is not assignable to type &#39;number | &#34;ongoing&#34; | &#34;uncertain&#34;&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">lifespan</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>; 
</span></span></code></pre></div><h3 id="literal-assignability">Literal Assignability</h3>
<p>我们已经知道，不同的基本类型（如<code>number</code>和<code>string</code>）是不能相互赋值的。同样地，<font color="#de7802">同一基本类型中的不同字面量类型（如0和1）也不能互相赋值</font>，下面代码会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// specificallyAda的类型为Ada
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">specificallyAda</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Ada&#34;</span>; 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">specificallyAda</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Ada&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果为string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">specificallyAda</span>)  <span style="color:#75715e">// 打印出来仍是字符串string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误: Type &#39;&#34;B&#34;&#39; is not assignable to type &#39;&#34;Ada&#34;&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">specificallyAda</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;B&#39;</span> 
</span></span></code></pre></div><p>需要注意的是，<font color=red>基本类型的变量不能赋值给对应的字面量类型，但字面量类型可以赋值给相应的基本类型</font>。因为任何特定的字面量字符串值仍然是字符串，下面代码不会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">specificallyAda</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Ada&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">specificallyAda</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Ada&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">someString</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>; <span style="color:#75715e">// Type: string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 可以将字面量类型赋值给器基本类型变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">someString</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">specificallyAda</span>
</span></span></code></pre></div><h2 id="strict-null-checking">Strict Null Checking</h2>
<p>在处理可能存在<code>undefined</code>值时，字面值联合的作用尤其明显。<code>TypeScript</code>是现代编程语言浪潮的一部分，这些语言利用严格的空值检查来解决可怕的<code>billion-dollar mistake</code>。</p>
<h4 id="billion-dollar-mistake">billion-dollar mistake</h4>
<p><code>billion-dollar mistake</code>是一个术语，指许多类型系统在需要不同类型的地方允许<code>null</code>值。在没有<code>strict null checking</code>的语言中，像下面这样将<code>null</code>赋值给<code>string</code>类型的变量是允许的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">firstName</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>; 
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 如果是严格类型检查就会出现错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Type &#39;null&#39; is not assignable to type &#39;string&#39;.
</span></span></span></code></pre></div><p><code>TypeScript</code>编译器包含大量选项，可以改变运行方式。严格空值检查（<code>strictNullChecks</code>）是最有用的选项之一，它表示是否启用严格<code>null</code>值检查。概括来讲，禁用<code>strictNullChecks</code>（设置为<code>false</code>）意味着会为每个类型添加<code>| null | undefined</code>，从而允许任何变量都能接收<code>null</code>或<code>undefined</code>。</p>
<p>如果将<code>strictNullChecks</code>选项设置为<code>false</code>，下面代码会被认为是安全的。但这种方式是错误的，当使用变量<code>nameMaybe</code>调用<code>toLowerCase</code>方法时，它可能是<code>undefined</code>的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">nameMaybe</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;Tony Hoare&#34;</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Potential runtime error: Cannot read property &#39;toLowerCase&#39; of undefined.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">nameMaybe</span>.<span style="color:#a6e22e">toLowerCase</span>() 
</span></span></code></pre></div><p>如果开启了严格空值检查（<code>strictNullChecks</code>设置为<code>false</code>），下面代码将会出现编译错误：<code>'nameMaybe' is possibly 'undefined'</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">nameMaybe</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;Tony Hoare&#34;</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// &#39;nameMaybe&#39; is possibly &#39;undefined&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">nameMaybe</span>.<span style="color:#a6e22e">toLowerCase</span>()  
</span></span></code></pre></div><p>如果没有严格空值检查，就很难确定我们的代码是否会因意外的<code>null</code>或<code>undefined</code>而出错。最佳实践是启用<code>strictNullChecks</code>选项。这样做有助于防止代码崩溃，并消除<code>billion-dollar mistake</code>错误。</p>
<h3 id="truthiness-narrowing">Truthiness Narrowing</h3>
<p>在<code>JavaScript</code>中，除了<code>false, 0, -0, 0n, &quot;&quot;, null, undefined, NaN</code>八个为<code>falsy</code>值，其它的都是<code>truthy</code>值。如果变量的某些可能值是<code>truthy</code>的，可以通过真值（<code>truthiness</code>)检查以窄化变量类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">zeroNaN</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#a6e22e">n</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">zeroNaN</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;true&#39;</span>)
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;false&#39;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">falseTest</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e">// null或者空字符串都会走到if语句中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">falseTest</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;false&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">false</span>
</span></span></code></pre></div><p>下面代码中，变量<code>geneticist</code>的类型是<code>string | undefined</code>，因为<code>undefined</code>是<code>falsy</code>值。代码进入第一个<code>if</code>语句体的前提是变量<code>geneticist</code>的值为<code>truthy</code>的，所以在<code>if</code>语句体中推断出它是<code>string</code>类型且其值是非空字符串：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">geneticist</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;Barbara McClintock&#34;</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 如果变量是truthy的，则它一定不是undefined，一定是字符串
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">geneticist</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">geneticist</span>.<span style="color:#a6e22e">toUpperCase</span>()) <span style="color:#75715e">// BARBARA MCCLINTOCK
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">falsyTest</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// falsyTest为空字符串,undefined,null都会走到if语句中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 测试时可以将falsyTest设置为null,undefined,&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">falsyTest</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;false&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">false</span>
</span></span></code></pre></div><p>逻辑运算符执行<code>truthy</code>值检查也同样有效，即使用<code>&amp;&amp;</code>和<code>?</code>运算符:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 变量geneticist类型为string | undefined
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">geneticist</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;Barbara McClintock&#34;</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果可能为undefined或BARBARA MCCLINTOCK
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">geneticist</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">geneticist</span>.<span style="color:#a6e22e">toUpperCase</span>()) 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果可能为undefined或BARBARA MCCLINTOCK
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">geneticist</span><span style="color:#f92672">?</span>.<span style="color:#a6e22e">toUpperCase</span>()) 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// test变量的类型为联合类型：string ｜ undefined
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 其类型不是boolean，这一点要特别注意！！！
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">test1</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">geneticist</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">geneticist</span>.<span style="color:#a6e22e">toUpperCase</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 而下面变量test的类型是boolean
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">test2</span> <span style="color:#f92672">=</span> <span style="color:#f92672">!</span>(<span style="color:#a6e22e">geneticist</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">geneticist</span>.<span style="color:#a6e22e">toUpperCase</span>())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 需要注意的是：!! 是一种简洁地将各种类型值转换为规范布尔值的手段
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 在需要准确获取布尔判断结果的诸多场景下都比较有用。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">test3</span> <span style="color:#f92672">=</span> <span style="color:#f92672">!!</span>(<span style="color:#a6e22e">geneticist</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">geneticist</span>.<span style="color:#a6e22e">toUpperCase</span>())
</span></span></code></pre></div><p>需要注意的是，<font color="#de7802">真值检查不能反过来使用</font>。如果知道类型为<code>string | undefined</code>变量的值是<code>falsy</code>的，并不能推断出这个值是空字符串还是<code>undefined</code>。</p>
<p>下面代码中，变量<code>biologist</code>的类型为<code>string | false</code>。虽然在<code>if</code>语句体中可以窄化类型为字符串，但<code>else</code>语句体包含了<code>biologist</code>的值是空字符串，也就是说在<code>else</code>里变量的类型依然为<code>string | false</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// biologist的类型为联合类型 string | false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">biologist</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#e6db74">&#34;Rachel Carson&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">biologist</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">biologist</span> <span style="color:#75715e">// 类型此时一定为string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">biologist</span> <span style="color:#75715e">// 类型此时为false | string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h3 id="variables-without-initial-values">Variables Without Initial Values</h3>
<p>在<code>JavaScript</code>中，若变量没有初始值，则其默认值是<code>undefined</code>。这在类型系统<code>typescript</code>中出现了一种情况：如果<font color="#de7802">将一个变量声明为不包括<code>undefined</code>的类型，然后尝试在赋值前使用它</font>，会出现什么情况。</p>
<p>实际上，<code>TypeScript</code>很聪明，知道在变量赋值之前，其值是<code>undefined</code>。<font color=red>如果在赋值前尝试使用该变量的值，会出现编译错误</font>。即使尝试使用<code>?</code>来访问变量的属性也会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">mathematician</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 即使使用?来访问属性，也会出现编译错误！！！
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Variable &#39;mathematician&#39; is used before being assigned.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">mathematician</span><span style="color:#f92672">?</span>.<span style="color:#a6e22e">length</span>; 
</span></span></code></pre></div><p>请注意，如果<font color="#de7802">变量的类型中包括<code>undefined</code>，在未初始化时就使用变量，不会出现编译错误</font>。在变量类型中添加<code>| undefined</code>是向<code>TypeScript</code>编译器说明，在使用前无需初始化，因为<code>undefined</code>是变量的有效值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">mathematician</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 变量类型包含了undefined，使用前无需初始化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">mathematician</span>) 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">mathematician</span><span style="color:#f92672">?</span>.<span style="color:#a6e22e">length</span>) 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">undefined</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">undefined</span>
</span></span></code></pre></div><p>需要特别注意的是，在设置了严格空值检查模式下（在<code>tsconfig.json</code>文件中的<code>compilerOptions</code>下设置<code>&quot;strict&quot;: true</code>），定义联合类型变量时，<font color=red>如果类型中只包含了 <code>| null</code>，但不包含 <code>| undefined</code>，也需要初始化</font>，否则会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">mathematician1</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 未初始化时就使用会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Variable &#39;mathematician&#39; is used before being assigned.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">mathematician</span>) 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">mathematician2</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 未初始化不会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">mathematician</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// tsconfig.json中包含严格模式的设置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;compilerOptions&#34;</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;target&#34;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;ES2022&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;module&#34;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;CommonJS&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;outDir&#34;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;out&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;sourceMap&#34;</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">true</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;strict&#34;</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>  },
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;exclude&#34;</span><span style="color:#f92672">:</span> [
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;node_modules&#34;</span>
</span></span><span style="display:flex;"><span>  ],
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;ts-node&#34;</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;files&#34;</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="type-aliases">Type Aliases</h2>
<p>在代码中看到的大多数联合类型的子类型一般只有两到三个。但是，有时可能会遇到一些较长的联合类型，如果这种联合类型出现次数较多，会不太方便。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">rawDataFirst</span>: <span style="color:#66d9ef">boolean</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">rawDataSecond</span>: <span style="color:#66d9ef">boolean</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">rawDataThird</span>: <span style="color:#66d9ef">boolean</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>;
</span></span></code></pre></div><p><code>TypeScript</code>包含类型别名，可以为重复使用的类型分配更简洁的名称。类型别名按照如下方式声明，按照惯例，<font color="#de7802">类型别名以大驼峰命名</font>（即遵循类型命名规范）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">MyName</span> <span style="color:#f92672">=</span> ...;
</span></span></code></pre></div><p>前面5种类型的联合，可以使用<code>type</code>定义类型简写成如下形式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">RawData</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">boolean</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">rawDataFirst</span>: <span style="color:#66d9ef">RawData</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">rawDataSecond</span>: <span style="color:#66d9ef">RawData</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">rawDataThird</span>: <span style="color:#66d9ef">RawData</span>;
</span></span></code></pre></div><p>类型别名是一项便捷功能，当代码中使用的联合类型开始变得复杂，就可以使用它。目前，只包括长联合类型，以后还将包括数组、函数和对象类型等。</p>
<h3 id="type-aliases-are-not-javascript">Type Aliases Are Not JavaScript</h3>
<p>类型别名与类型标注一样，编译后不会输出到<code>JavaScript</code>文件中。也就是说，<font color=red>因为类型别名仅存在于类型系统，所以不能在运行时的代码中引用它们</font>。如果试图访问运行时不存在的内容，就会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">RawData</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">boolean</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：&#39;RawData&#39; only refers to a type, but is being used as a value here.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// RawData仅表示类型，但在此处却作为值使用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">RawData</span>) 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 直接使用基本类型也是报错的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// &#39;string&#39; only refers to a type, but is being used as a value here.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">string</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">rawData</span>: <span style="color:#66d9ef">RawData</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">rawData</span>) 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">rawData</span>) 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">false</span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">boolean</span>
</span></span></code></pre></div><h3 id="combining-type-aliases">Combining Type Aliases</h3>
<p>在定义某个类型别名时<font color="#f79646">也可以引用其它的类型别名</font>，使得新的类型别名更简洁。类型别名相互引用有时很有用，当一个类型别名是一个联合类型时，它可能包含另一个类型别名。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Id</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">IdMaybe</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Id</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span>
</span></span></code></pre></div><p>需要注意的是，<span style="background:rgba(255, 183, 139, 0.55)">类型别名在定义时不必按使用顺序声明</span>。可以让在<font color=red>文件中较前定义的类型别名引用在文件中较后定义的别名</font>。上面代码可以重写，将<code>IdMaybe</code>放在<code>Id</code>之前声明，也不会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 别名Id的定义在后，使用在前
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">IdMaybe</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Id</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 别名Id的定义在后，使用在前
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Id</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">id</span>: <span style="color:#66d9ef">IdMaybe</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">id</span>) <span style="color:#75715e">// undefined
</span></span></span></code></pre></div><h1 id="objects">Objects</h1>
<h2 id="object-types">Object Types</h2>
<p>使用<code>{}</code>创建对象字面量时，<code>TypeScript</code>会<font color="#de7802">根据其属性将其视为新的对象类型</font>。新对象类型具有与对象字面量相同的属性名和对应值类型。访问对象属性的值时可以使用<code>value.member</code>或等同的<code>value['member']</code>。</p>
<p>下面代码中，<code>TypeScript</code>认为常量<code>poet</code>的类型是一个对象，该对象具有<code>born</code>和<code>name</code>两个属性，属性<code>born</code>的值类型为<code>number</code>，<code>name</code>属性的值类型为<code>string</code>。访问这两个属性是允许的，但<font color="#de7802">试图访问任何其它不存在的属性都会出现编译错误</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">poet</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">1935</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Mary Oliver&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">poet</span>.<span style="color:#a6e22e">born</span>, <span style="color:#a6e22e">poet</span>.<span style="color:#a6e22e">name</span>, <span style="color:#a6e22e">poet</span>[<span style="color:#e6db74">&#39;born&#39;</span>], <span style="color:#a6e22e">poet</span>[<span style="color:#e6db74">&#39;name&#39;</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 访问不存在的属性会出现编译错误，这与联合类型只能访问子类型的共有属性或方法是一样的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Property &#39;end&#39; does not exist on type &#39;{ born: number; name: string; }&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">poet</span>.<span style="color:#a6e22e">end</span>; 
</span></span></code></pre></div><p>对象类型是<code>TypeScript</code>理解<code>JavaScript</code>代码的核心概念。除<code>null</code>和<code>undefined</code>之外的每个对象值都有一组成员，<font color=red>必须了解对象类型中的每个值，才能对其进行类型检查</font>。</p>
<h3 id="declaring-object-types">Declaring Object Types</h3>
<p>从现有的对象中直接推断出类型固然是好的，但有些场景需要显式标注变量为对象类型。此时，需要一种方式描述对象类型，将其与满足对象类型的值区分开来。</p>
<p>对象类型使用与对象字面量相似的语法来描述，但<font color="#f79646">与属性名对应的是其值的类型而不是相应的值</font>。若对象类型变量出现赋值相关的编译错误时，显示的是声明对象类型时的语法，清晰易读。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 先声明，声明时未被初始化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 定义时最后一个分号是可以省略
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">poetLater</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">poetLater</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">123</span>, <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;678&#39;</span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">poetLater</span>) <span style="color:#75715e">// { born: 123, name: &#39;678&#39; }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Type &#39;number&#39; is not assignable to type &#39;{ born: number; name: string; }&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">poetLater</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">123</span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 定义时属性之间也可以使用逗号分隔
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 定义时最后一个逗号也是可以去掉的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">poetLater</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">number</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 定义时属性之间也可以用换行符分隔，不需要分号或逗号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">poetLater</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">number</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 需要注意的是字面量属性之间必须使用逗号分隔！！！
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">poetLater</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">123</span>, <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;678&#39;</span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">poetLater</span>.<span style="color:#a6e22e">born</span>, <span style="color:#a6e22e">poetLater</span>.<span style="color:#a6e22e">name</span>) <span style="color:#75715e">// 123 678
</span></span></span></code></pre></div><h3 id="aliased-object-types">Aliased Object Types</h3>
<p>重复写类似<code>{ born: number; name: string; }</code>这样的对象类型很快就会觉得厌烦，也容易出错。常见的做法是使用<code>type</code>创建类型别名，为对象类型赋予一个新名字。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 使用type创建类型别名
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Poet</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 属性之间也使用逗号分隔，使用换行也可以
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">type Poet = {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    born: number,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    name: string,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">};
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">type Poet = {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    born: number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    name: string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">};
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">const poet: Poet = {born: 123, name: &#34;werr&#34;}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">console.log(poet)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">poetLater</span>: <span style="color:#66d9ef">Poet</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">poetLater</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">1935</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Sara Teasdale&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Type &#39;string&#39; is not assignable to type &#39;Poet&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">poetLater</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Emily Dickinson&#34;</span>; 
</span></span></code></pre></div><h2 id="structural-typing">Structural Typing</h2>
<p><code>TypeScript</code>的类型系统是<code>structural typed</code>的，这意味着<font color="#de7802">任何满足类型的值都可以用作该类型的值</font>。换句话说，当标注一个参数或变量是一个特定对象类型时，就是在声明<span style="background:rgba(255, 183, 139, 0.55)">无论使用什么对象值，它们都需要具有这些属性</span>。</p>
<p>下面<code>WithFirstName</code>和<code>WithLastName</code>别名对象类型都只声明了一个字符串类型的成员。常量<code>hasBoth</code>同时有这两种成员，因此可以赋值给这两种别名对象类型中的任何一种变量：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">WithFirstName</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">firstName</span>: <span style="color:#66d9ef">string</span>; };
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">WithLastName</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">lastName</span>: <span style="color:#66d9ef">string</span>; };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">hasBoth</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">firstName</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Lucille&#34;</span>, <span style="color:#a6e22e">lastName</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Clifton&#34;</span>};
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 不直接使用类型字面量而是使用变量赋值避开了属性检查
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">withFirstName</span>: <span style="color:#66d9ef">WithFirstName</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">hasBoth</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">withLastName</span>: <span style="color:#66d9ef">WithLastName</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">hasBoth</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">withFirstName</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">withLastName</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">hasBoth</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{ <span style="color:#a6e22e">firstName</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;Lucille&#39;</span>, <span style="color:#a6e22e">lastName</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;Clifton&#39;</span> } 
</span></span><span style="display:flex;"><span>{ <span style="color:#a6e22e">firstName</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;Lucille&#39;</span>, <span style="color:#a6e22e">lastName</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;Clifton&#39;</span> }
</span></span><span style="display:flex;"><span>{ <span style="color:#a6e22e">firstName</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;Lucille&#39;</span>, <span style="color:#a6e22e">lastName</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;Clifton&#39;</span> }
</span></span></code></pre></div><p>需要注意的是，<code>Structural typing</code>与<code>Duck typing</code>不同，后者源于「<font color="#de7802">如果它看起来像鸭子，叫起来像鸭子，那它可能就是鸭子</font>」。<code>JavaScript</code>是<code>Duck typing</code>的，而<code>TypeScript</code>是<code>Structural typing</code>的。</p>
<ul>
<li><code>Structural typing</code>是指<font color="#de7802">有一个静态系统来检查类型</font>，在<code>TypeScript</code>中这个静态系统就是类型检查器。</li>
<li><code>Duck typing</code><font color="#de7802">使用之前不检查对象类型，直到运行时才检查类型</font>。</li>
</ul>
<h3 id="usage-checking">Usage Checking</h3>
<blockquote>
<p>给对象变量赋值时至少会触发两种检查，第一种是属性缺少检查，第二种是属性对应值的类型检查。若使用字面量赋值，还会触发第三种检查，即多余属性检查。</p>
</blockquote>
<p>当向显式标注为对象类型的变量赋值时，编译器将检查该值是否可赋值给这个对象类型。首先，<span style="background:rgba(255, 183, 139, 0.55)">对象值必须包含对象类型的所有必需属性</span>。如果对象值中缺少对象类型所需的任何成员，将会出现编译错误。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">FirstAndLastNames</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">first</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">last</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">hasBoth</span>: <span style="color:#66d9ef">FirstAndLastNames</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">first</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Sarojini&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">last</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Naidu&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 赋值时字面量缺少属性，会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Property &#39;last&#39; is missing in type &#39;{ first: string; }&#39; but required in type &#39;FirstAndLastNames&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">hasOnlyOne</span>: <span style="color:#66d9ef">FirstAndLastNames</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">first</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Sappho&#34;</span>}; 
</span></span></code></pre></div><p>因为<font color="#de7802">对象类型既指定了所需属性的名称，也指定了这些属性对应值的类型</font>，所以也不允许两者之间值的类型不匹配。如果对象属性的对应值类型不匹配，也会出现编译错误。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">TimeRange</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">start</span>: <span style="color:#66d9ef">Date</span>; };
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误: Type &#39;string&#39; is not assignable to type &#39;Date&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">hasDateStr</span>: <span style="color:#66d9ef">TimeRange</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">start</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;1999-02-13&#34;</span>, 
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 下面属性对应的值的类型是正确的，不会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">hasDate</span>: <span style="color:#66d9ef">TimeRange</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">start</span>: <span style="color:#66d9ef">new</span> Date(),
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">hasDate</span>)
</span></span></code></pre></div><h3 id="excess-property-checking">Excess Property Checking</h3>
<p>若一个变量声明为对象类型，并且<font color="#de7802">使用字面量初始化时，若字面量中的字段多于其类型所描述的字段时，也会出现编译错误</font>。因此，<span style="background:#f8d9c3">将变量显式标注为对象类型是一种让类型检查程序确保变量恰好只包含该类型预期字段的方法。</span></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Poet</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">poetMatch</span>: <span style="color:#66d9ef">Poet</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">1928</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Maya Angelou&#34;</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">extraProperty</span>: <span style="color:#66d9ef">Poet</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">activity</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;walking&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">1935</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Mary Oliver&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Object literal may only specify known properties, and &#39;activity&#39; does not exist in type &#39;Poet&#39;.
</span></span></span></code></pre></div><p>但需要注意的是，<font color=red>只有在标注为对象类型的位置创建的对象字面量才会触发多余属性检查</font>。若提供<font color="#de7802">已有常量或变量存储的对象字面量可以绕过多余属性检查</font>，下面示例代码绕过了多余属性检查：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Poet</span> <span style="color:#f92672">=</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">number</span>;  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;  
</span></span><span style="display:flex;"><span>}  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">poetMatch</span>: <span style="color:#66d9ef">Poet</span> <span style="color:#f92672">=</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">1928</span>,  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Maya Angelou&#34;</span>  
</span></span><span style="display:flex;"><span>};  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">existingObject</span> <span style="color:#f92672">=</span> {    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">1935</span>, 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Mary Oliver&#34;</span>,  
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 相对于Poet类型来说，activity是多余属性  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">activity</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;walking&#34;</span>,
</span></span><span style="display:flex;"><span>};  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 使用变量绕过多余属性检查
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">extraProperty</span>: <span style="color:#66d9ef">Poet</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">existingObject</span>  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">poetMatch</span>) 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{ <span style="color:#a6e22e">activity</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;walking&#39;</span>, <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">1935</span>, <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;Mary Oliver&#39;</span> }
</span></span></code></pre></div><p>在<font color="#de7802">需要对象类型的任何地方使用字面量创建新对象时，都会触发多余属性检查</font>，即创建的对象字面量必须与标注的对象类型匹配。禁止多余属性能确保代码整洁并按照期望的方式运行，因为<font color=green>通常在对象类型中声明的多余属性是书写时输入了错误的属性名</font>。</p>
<h3 id="nested-object-types">Nested Object Types</h3>
<p>由于<code>JavaScript</code>对象中可以嵌入其它对象成员，因此<code>TypeScript</code>的对象类型也必须能够表示嵌套的对象类型。嵌套类型语法与之前相同，但使用<code>{ ... }</code>对象类型来代替基础类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 创建别名类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Poem</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">firstName</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">lastName</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">poemMatch</span>: <span style="color:#66d9ef">Poem</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">firstName</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Sylvia&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">lastName</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Plath&#34;</span>,
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Lady Lazarus&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 创建字面量对象作为初始值会触发属性检查
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误:Object literal may only specify known properties, and &#39;name&#39; does not exist in type &#39;{ firstName: string; lastName: string; }&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">poemMismatch</span>: <span style="color:#66d9ef">Poem</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Sylvia Plath&#34;</span>,
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Tulips&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>声明<code>Poem</code>类型的另一种方法是将<code>author</code>属性提取到别名对象类型<code>Author</code>中。若将对象类型中的嵌套类型提取到别名类型中，在编译出现错误时提供更详细的信息，有助于排查和定位问题。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Author</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">firstName</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">lastName</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Poem</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span>: <span style="color:#66d9ef">Author</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Object literal may only specify known properties, and &#39;name&#39; does not exist in type &#39;Author&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">poemMismatch</span>: <span style="color:#66d9ef">Poem</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Sylvia Plath&#34;</span>, 
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Tulips&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 也可以使用,分隔属性
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">type Author = {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    firstName: string,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    lastName: string,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">};
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">type Poem = {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    author: Author,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    name: string,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">};
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span></code></pre></div><p>通常来说，为嵌套对象类型创建一个别名类型是个好主意，这样既能使具有嵌套类型的代码更易读，也能使<code>TypeScript</code>的错误信息更清晰易读。</p>
<h3 id="optional-properties">Optional Properties</h3>
<p>对象类型的属性不一定都是必需属性，<font color="#de7802">可以在属性的类型标注的<code>:</code>前加上<code>?</code>来表示它是一个可选属性</font>（这种方式与<code>Swift</code>区别很大）。下面示例代码中，<code>Book</code>中的<code>author</code>属性是可选的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Book</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author?</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">ok</span>: <span style="color:#66d9ef">Book</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Rita Dove&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">80</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">normal</span>: <span style="color:#66d9ef">Book</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">80</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">normal</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 打印结果时不会显示可选类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{<span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">80</span>} 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 不能缺少必需属性，否则会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Property &#39;pages&#39; is missing in type &#39;{ author: string; }&#39; but required in type &#39;Book&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">missing</span>: <span style="color:#66d9ef">Book</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Rita Dove&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>需要注意的是，可选属性与属性的类型标注为包括<code>undefined</code>的联合类型是不同的。<font color="#de7802">声明为可选属性，属性可以不存在</font>（此时属性对应值为<code>undefined</code>）。<font color=red>但使用<code>| undefined</code>声明的属性，其值必须存在</font>，即便该属性的值就是<code>undefined</code>也不能省略。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Writers</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">editor?</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">hasRequired</span>: <span style="color:#66d9ef">Writers</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span>: <span style="color:#66d9ef">undefined</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 但定义变量时，若是带undefined的联合类型可以不初始化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">test</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">test</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 对象中属性为undefined的联合类型时必须赋初值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 触发属性检查，author属性必须有，且必须提供值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Property &#39;author&#39; is missing in type &#39;{}&#39; but required in type &#39;Writers&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">missingRequired</span>: <span style="color:#66d9ef">Writers</span> <span style="color:#f92672">=</span> {}; 
</span></span></code></pre></div><p>请特别注意，对象类型中某个属性的类型标注为与<code>undefined</code>的联合，与普通变量类型标注为<code>undefined</code>的联合区别较大。<font color="#de7802">对象类型中属性的类型是包含了<code>undefined</code>的联合类型时也需要初始化</font>，而普通变量变量不需要初始化。</p>
<h2 id="unions-of-object-types">Unions of Object Types</h2>
<blockquote>
<p>如果变量的初始值可能是多种对象类型之一，<code>TypeScript</code>将推断变量的类型为对象类型的联合。<font color="#de7802">该联合类型为每种可能的类型提供一个成分</font>，类型上的每种可能属性都将出现在每个组成元素中，尽管它们<span style="background:rgba(255, 183, 139, 0.55)">在没有初始值的任何类型中都是可选类型</span>。</p>
</blockquote>
<h3 id="inferred-object-type-unions">Inferred Object-Type Unions</h3>
<p>下面代码中，常量<code>poem</code>的值一定有<code>name</code>属性，可能有<code>pages</code>或<code>rhymes</code>属性。常量<code>poem</code>的类型被推断为<code>{name: string, pages: number, rhymes?: undefined} | {name: string, rhymes: boolean, pages?: undefined}</code> 。也就是说编译器在推断对象类型的联合时，非共有属性均是可选的，并且对应的值类型是<code>undefined</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// poem的类型被推断为{name: string, pages: number, rhymes?: undefined} | {name: string, rhymes: boolean, pages?: undefined}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">poem</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;The Double Image&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">7</span>
</span></span><span style="display:flex;"><span>} <span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Her Kind&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">rhymes</span>: <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">name</span>  <span style="color:#75715e">// 类型为 string 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">pages</span>; <span style="color:#75715e">// 类型为 number | undefined
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">rhymes</span>; <span style="color:#75715e">// 类型为 boolean | undefined
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行后的可能结果:The Double Image 7 undefined 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">name</span>, <span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">pages</span>, <span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">rhymes</span>, <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">poem</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行后的可能结果：string undefined boolean
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">name</span>, <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">pages</span>, <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">rhymes</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">poem</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果是下面二者之一，可选类型不会打印出来！！！
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{<span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;Her Kind&#39;</span>, <span style="color:#a6e22e">rhymes</span>: <span style="color:#66d9ef">true</span>}
</span></span><span style="display:flex;"><span>{<span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;The Double Image&#39;</span>, <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">7</span>}
</span></span></code></pre></div><h3 id="explicit-object-type-unions">Explicit Object-Type Unions</h3>
<p>也可以通过对象类型的联合来更明确地标注对象类型，这样做需要写更多代码，好处是能更多地控制对象类型。但需要注意的是，<strong><font color=red>如果是对象类型的联合，则只允许访问存在于联合类型所有子类型上的属性</font></strong>。这与上面将变量推断为对象类型的联合有明显区别：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">PoemWithPages</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">PoemWithRhymes</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">rhymes</span>: <span style="color:#66d9ef">boolean</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 定义别名类型，该类型是对象类型的联合
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Poem</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">PoemWithPages</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">PoemWithRhymes</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">poem</span>: <span style="color:#66d9ef">Poem</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span>  <span style="color:#f92672">?</span> {<span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;The Double Image&#34;</span>, <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">7</span>} <span style="color:#f92672">:</span> {<span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Her Kind&#34;</span>, <span style="color:#a6e22e">rhymes</span>: <span style="color:#66d9ef">true</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 访问联合类型所有子类型的共有属性，不会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">name</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 因为pages属性不一定有，所以会编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Property &#39;pages&#39; does not exist on type &#39;Poem&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Property &#39;pages&#39; does not exist on type &#39;PoemWithRhymes&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">pages</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 因为rhymes属性不一定有，所以会编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Property &#39;rhymes&#39; does not exist on type &#39;Poem&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Property &#39;rhymes&#39; does not exist on type &#39;PoemWithPages&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">rhymes</span>;
</span></span></code></pre></div><h3 id="narrowing-object-types">Narrowing Object Types</h3>
<p>如果类型检查器发现在某个位置的代码<span style="background:rgba(255, 183, 139, 0.55)">只有在联合类型值包含特定属性的情况下才能运行，那么会将联合类型窄化到只包含该属性的子类型</span>。换句话说，如果在代码中检查对象，类型窄化功能也适用。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">PoemWithPages</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">PoemWithRhymes</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">rhymes</span>: <span style="color:#66d9ef">boolean</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Poem</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">PoemWithPages</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">PoemWithRhymes</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">poem</span>: <span style="color:#66d9ef">Poem</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span>  <span style="color:#f92672">?</span> {<span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;The Double Image&#34;</span>, <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">7</span>} <span style="color:#f92672">:</span> {<span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Her Kind&#34;</span>, <span style="color:#a6e22e">rhymes</span>: <span style="color:#66d9ef">true</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// pages若在poem中，则可以访问该属性，不能直接使用.来访问属性，因为还不确定是否有该属性
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 如果直接使用.操作符访问属性将出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (<span style="color:#e6db74">&#34;pages&#34;</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">poem</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">pages</span>)
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果没有pages，那么必定有属性rhymes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">rhymes</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>请注意，<code>TypeScript</code>不允许使用<code>if (poem.pages)</code>这样的真值检查，因为还不确定变量中是否有该属性。<font color="#de7802">试图访问可能不存在的对象属性会被视为错误，即使用起来的方式看起来像是类型保护</font>。</p>
<h3 id="discriminated-unions">Discriminated Unions</h3>
<p><code>JavaScript</code>和<code>TypeScript</code>中另一种流行的联合类型对象形式是在对象上设置一个属性，用于指示对象具体是哪种类型。这种类型被称为判别联合(<code>discriminated union</code>)，指示对象类型的属性被称为<code>discriminant</code>。<code>TypeScript</code>能够对在<code>discriminant</code>属性上进行类型保护的代码执行类型窄化。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// type表示判别类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">PoemWithPages</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;pages&#39;</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">PoemWithRhymes</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">rhymes</span>: <span style="color:#66d9ef">boolean</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;rhymes&#39;</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Poem</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">PoemWithPages</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">PoemWithRhymes</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">poem</span>: <span style="color:#66d9ef">Poem</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;The Double Image&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">7</span>, 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;pages&#34;</span>
</span></span><span style="display:flex;"><span>} <span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Her Kind&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">rhymes</span>: <span style="color:#66d9ef">true</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;rhymes&#34;</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">poem</span>.<span style="color:#66d9ef">type</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;pages&#34;</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 进行了类型窄化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`It&#39;s got pages: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">pages</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 进行了类型窄化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`It rhymes: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">rhymes</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="intersection-types">Intersection Types</h2>
<p>联合类型表示一个值的类型可能是两个或多个不同类型中的一个。<code>TypeScript</code>同样允许同时表示多种类型，即<code>intersection</code>（交叉）类型。<code>intersection</code>类型<font color="#de7802">通常与别名对象类型一起使用，以创建合并多个现有类型的新类型</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 使用type定义新类型时可以使用分号，逗号，或换行来分隔属性
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Artwork</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">genre</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Writing</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 定义新的交叉类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">WrittenArt</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Artwork</span> <span style="color:#f92672">&amp;</span> <span style="color:#a6e22e">Writing</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 必须同时具有name,pages和genre属性
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">writtenAndArt</span>: <span style="color:#66d9ef">WrittenArt</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;test&#39;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">genre</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;man&#39;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">123</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">writtenAndArt</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{ <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;test&#39;</span>, <span style="color:#a6e22e">genre</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;man&#39;</span>, <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">123</span> }
</span></span></code></pre></div><p><code>Intersection</code>类型可以与联合类型结合使用。在某些场景这种结合有助于只在一种类型中描述<code>discriminated unions</code>，省略重复定义的共有属性。下面示例代码中，使用交叉与联合类型的交叉省略了重复定义属性<code>author</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ShortPoem</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">author</span>: <span style="color:#66d9ef">string</span> } <span style="color:#f92672">&amp;</span> (<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">kigo</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;haiku&#34;</span>;
</span></span><span style="display:flex;"><span>} <span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">meter</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;villanelle&#34;</span>;
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*  可以去掉第一个用于联合的 | 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">type ShortPoem = { author: string } &amp; ({  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    kigo: string;  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    type: &#34;haiku&#34;;  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">} | {  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    meter: number;  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    type: &#34;villanelle&#34;;  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">});  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">morningGlory</span>: <span style="color:#66d9ef">ShortPoem</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Fukuda Chiyo-ni&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">kigo</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Morning Glory&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;haiku&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 下面会出现编译错误： Type &#39;{ author: string; type: &#34;villanelle&#34;; }&#39; is not assignable to type &#39;{ author: string; } &amp; { meter: number; type: &#34;villanelle&#34;; }&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">oneArt</span>: <span style="color:#66d9ef">ShortPoem</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Elizabeth Bishop&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;villanelle&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="dangers-of-intersection-types">Dangers of Intersection Types</h3>
<p><code>Intersection</code>（交叉类型）是一个有用的概念，但使用时很容易让自己或<code>TypeScript</code>编译器感到困惑。<font color="#de7802">建议在使用交叉类型时尽量简化代码</font>。</p>
<p>当创建了复杂的交叉类型（如与联合类型交叉）时，赋值错误信息就会变得难以理解。这是类型编程语言的一个共同主题：<font color=green>创建的类型越复杂，就越难理解来自类型检查器给出的错误信息</font>。</p>
<p>以前面代码片段中的<code>ShortPoem</code>为例，如果将该类型拆分为一系列别名对象类型，<code>TypeScript</code>就可以打印这些别名，可读性就会大大提高：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ShortPoemBase</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span>: <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Haiku</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">ShortPoemBase</span> <span style="color:#f92672">&amp;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">kigo</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;haiku&#34;</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Villanelle</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">ShortPoemBase</span> <span style="color:#f92672">&amp;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">meter</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;villanelle&#34;</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ShortPoem</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Haiku</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">Villanelle</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Type &#39;{ author: string; type: &#34;villanelle&#34;; }&#39; is not assignable to type &#39;ShortPoem&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">oneArt</span>: <span style="color:#66d9ef">ShortPoem</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Elizabeth Bishop&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;villanelle&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="never">never</h3>
<p>使用<code>&amp;</code>声明<code>Intersection</code><font color="#de7802">类型很容易被滥用，创建出一种不可能的类型</font>。基本类型不能作为交叉类型的成员组合在一起，因为一个值不可能同时是多个基本类型。如果尝试将两个基本类型交叉在一起，就会产生<code>never</code>类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 一个变量不可能既是number又是string类型，所以NotPossible的类型为never
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">NotPossible</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Type &#39;number&#39; is not assignable to type &#39;never&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">notPossible</span>: <span style="color:#66d9ef">NotPossible</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">123</span>
</span></span></code></pre></div><p>类型<code>never</code>被称为<code>bottom type</code>或<code>empty type</code>。<font color="#de7802">底层类型是指不可能的值，也是无法到达的类型</font>。需要注意的是，<font color=green>不能向标注为底层类型的位置提供任何类型值</font>，否则会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">NotPossible</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Type &#39;number&#39; is not assignable to type &#39;never&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">notNumber</span>: <span style="color:#66d9ef">NotPossible</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; 
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Type &#39;number&#39; is not assignable to type &#39;never&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">notString</span>: <span style="color:#66d9ef">never</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>; 
</span></span></code></pre></div><p>大多数项目很少使用<code>never</code>类型，<code>never</code>偶尔会出现在代码中表示不可能的状态。但多数情况下，很可能是误用<code>Intersection</code>（交叉）产生的错误类型。</p>
<h1 id="functions">Functions</h1>
<p>前面介绍了如何使用类型标注来声明变量和常量的类型。现在，可以看看如何对函数的形参类型和返回值类型进行同样的标注。</p>
<h2 id="function-parameters">Function Parameters</h2>
<p>下面定义的函数入参只有一个<code>song</code>，并在函数体中打印了这个参数的值。但在声明该函数时形参并没有显式地标注类型，那么<code>TypeScript</code>会认为这个参数的类型是<code>any</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">sing</span>(<span style="color:#a6e22e">song</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Singing: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span><span style="color:#e6db74">}</span><span style="color:#e6db74">!`</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">Parameter</span> <span style="color:#e6db74">&#39;song&#39;</span> <span style="color:#a6e22e">implicitly</span> <span style="color:#a6e22e">has</span> <span style="color:#a6e22e">an</span> <span style="color:#e6db74">&#39;any&#39;</span> <span style="color:#66d9ef">type</span>.
</span></span></code></pre></div><p>但如果编译选项设置的是严格模式（在<code>tsconfig.json</code>文件中的<code>compilerOptions</code>下设置<code>&quot;strict&quot;: true</code>），上面代码会出现编译错误：<code>Parameter 'song' implicitly has an 'any' type</code>。与变量的类型标注一样，允许使用类型标注函数形参的类型。例如，可以使用<code>: string</code>告诉编译器形参<code>song</code>的类型是字符串类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">sing</span>(<span style="color:#a6e22e">song</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Singing: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span><span style="color:#e6db74">}</span><span style="color:#e6db74">!`</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="required-parameters">Required Parameters</h3>
<p><code>JavaScript</code>函数允许使用任意数量的实参(<code>arguments</code>)调用函数，而<code>TypeScript</code><span style="background:rgba(255, 183, 139, 0.55)">假定函数中声明的所有参数都是必需的</span>。如果使用错误数量或类型的实参数来调用函数，将会出现编译错误。</p>
<p>如果函数调用的实参过少或过多，<code>TypeScript</code>的实参计数器就会发挥作用。下面函数<code>singTwo</code>声明时有两个参数，因此传递<code>1</code>个或<code>3</code>个参数都是不允许的。实际上，<font color="#e36c09">强制要求向函数提供必需的参数</font>，有助于执行类型安全。如果不能确保这些参数值都存在，可能会导致代码出现意外行为。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">singTwo</span>(<span style="color:#a6e22e">first</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">second</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">first</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> / </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">second</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Expected 2 arguments, but got 1.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">singTwo</span>(<span style="color:#e6db74">&#34;Ball and Chain&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Expected 2 arguments, but got 3.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">singTwo</span>(<span style="color:#e6db74">&#34;Go Your Own Way&#34;</span>, <span style="color:#e6db74">&#34;The Chain&#34;</span>, <span style="color:#e6db74">&#34;Dreams&#34;</span>);
</span></span></code></pre></div><p>形参（<code>parameter</code>）是指函数声明的预期参数。实参（<code>arguments</code>）是指函数调用时提供给形参的值。上面示例代码中，<code>first</code>和<code>second</code>是形参，而<code>&quot;Ball and Chain&quot;</code>等字符串是实参。</p>
<h3 id="optional-parameters">Optional Parameters</h3>
<p><code>TypeScript</code>允许将形参标注为可选参数，即在其类型标注的<code>:</code>前添加<code>?</code>（类似于对象类型的可选属性）。<font color=red>函数调用不需要向可选参数提供实参，因为它们的类型总是以<code>| undefined</code>作为联合类型</font>。</p>
<p>下面<code>announceSong</code>函数中，<code>singer</code>形参被标记为可选参数，它的类型是<code>string | undefined</code>。对于可选参数，函数的调用者可以不提供实参（此时其值为<code>undefined</code>）。如果主动提供了<code>singer</code>对应的实参，<font color="#de7802">它的值可能是一个字符串或<code>undefined</code></font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 声明singer为可选参数，且为最后一个形参
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">announceSong</span>(<span style="color:#a6e22e">song</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">singer?</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Song: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">singer</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Singer: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">singer</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">announceSong</span>(<span style="color:#e6db74">&#34;Greensleeves&#34;</span>); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">announceSong</span>(<span style="color:#e6db74">&#34;Greensleeves&#34;</span>, <span style="color:#66d9ef">undefined</span>); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">announceSong</span>(<span style="color:#e6db74">&#34;Chandelier&#34;</span>, <span style="color:#e6db74">&#34;Sia&#34;</span>); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 上面三次调用的执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">Song</span>: <span style="color:#66d9ef">Greensleeves</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Song</span>: <span style="color:#66d9ef">Greensleeves</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Song</span>: <span style="color:#66d9ef">Chandelier</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Singer</span>: <span style="color:#66d9ef">Sia</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 在调用函数时，如果没有为可选参数提供实参，其值为undefined
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">announceSong</span>(<span style="color:#a6e22e">song</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">singer?</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Song: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Singer: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">singer</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">announceSong</span>(<span style="color:#e6db74">&#34;test&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">Song</span>: <span style="color:#66d9ef">test</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Singer</span>: <span style="color:#66d9ef">undefined</span> <span style="color:#75715e">// 可选参数未传入实参时，值为undefined
</span></span></span></code></pre></div><p>可选参数与包含<code>| undefined</code>的联合类型参数不同。调用函数时，未用<code>?</code>标记为可选的参数必需提供实参，即使其值是<code>undefined</code>。<font color=red>函数的可选参数必须放在必需参数后面，若将可选参数放在必需参数前，会出现编译错误</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 将可选参数放到必需参数前出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// A required parameter cannot follow an optional parameter.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">announceSong</span>(<span style="color:#a6e22e">song?</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">singer</span>: <span style="color:#66d9ef">string</span>) {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Song: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Singer: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">singer</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果定义的函数参数列表后面有多个可选参数，<font color="#de7802">调用时若想略过前面的可选参数，则必需显式传入值<code>undefined</code></font>。下面定义的<code>announceSong</code>函数，如果只想给函数最后一个参数传入有效实参，则需要将前面的参数都传入<code>undefined</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">announceSong</span>(<span style="color:#a6e22e">song?</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">singer?</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">name?</span>: <span style="color:#66d9ef">string</span>) {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Song: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Singer: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">singer</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">name</span>)  
</span></span><span style="display:flex;"><span>}  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">announceSong</span>(<span style="color:#e6db74">&#39;test&#39;</span>)  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">announceSong</span>(<span style="color:#66d9ef">undefined</span>, <span style="color:#e6db74">&#39;test&#39;</span>) 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">announceSong</span>(<span style="color:#66d9ef">undefined</span>, <span style="color:#66d9ef">undefined</span>, <span style="color:#e6db74">&#39;test&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">Song</span>: <span style="color:#66d9ef">test</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Singer</span>: <span style="color:#66d9ef">undefined</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">undefined</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Song</span>: <span style="color:#66d9ef">undefined</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Singer</span>: <span style="color:#66d9ef">test</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">undefined</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Song</span>: <span style="color:#66d9ef">undefined</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Singer</span>: <span style="color:#66d9ef">undefined</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">test</span>
</span></span></code></pre></div><h3 id="default-parameters">Default Parameters</h3>
<p>若函数定义时参数有默认值且没有指明类型，编译器会根据默认值推断参数的类型。下面<code>rateSong</code>函数中，参数<code>rating</code>的类型被推断为<code>number</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">rateSong</span>(<span style="color:#a6e22e">song</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">rating</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> gets </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">rating</span><span style="color:#e6db74">}</span><span style="color:#e6db74">/5 stars!`</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">rateSong</span>(<span style="color:#e6db74">&#34;Photograph&#34;</span>); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">rateSong</span>(<span style="color:#e6db74">&#34;Set Fire to the Rain&#34;</span>, <span style="color:#ae81ff">5</span>); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">rateSong</span>(<span style="color:#e6db74">&#34;Set Fire to the Rain&#34;</span>, <span style="color:#66d9ef">undefined</span>); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 会出现编译错误：Argument of type &#39;string&#39; is not assignable to parameter of type &#39;number&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">rateSong</span>(<span style="color:#e6db74">&#34;At Last!&#34;</span>, <span style="color:#e6db74">&#34;100&#34;</span>); 
</span></span></code></pre></div><p>具有<font color="#e36c09">默认值的参数若不位于形参列表的末尾，调用时则不能省略该参数，如果要触发默认值，必须显式地传入</font><code>undefined</code>。需要特别注意的是，<code>undefined</code>是用来触发默认值的，不是真正的实参。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">hello3</span>(<span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>, <span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">hello3</span>(<span style="color:#66d9ef">undefined</span>, <span style="color:#ae81ff">890</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">3</span> <span style="color:#ae81ff">890</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 如果省略默认参数则会出现编译错误: Expected 2 arguments, but got 1.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">hello3</span>(<span style="color:#ae81ff">13</span>)
</span></span></code></pre></div><h3 id="rest-parameters">Rest Parameters</h3>
<p>在<code>JavaScript</code>中<font color="#e36c09">展开操作符<code>...</code>必须是函数声明的最后一个参数</font>，表示从该参数开始传递给函数的所有<code>rest</code>参数都应存储在一个数组中。需要特别注意的是，<font color=red>一个函数只能有一个<code>rest</code>参数</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 编译错误： A rest parameter must be last in a parameter list.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">singAllTheSongs</span>(...<span style="color:#a6e22e">songs</span>: <span style="color:#66d9ef">string</span>[], <span style="color:#a6e22e">singer</span>: <span style="color:#66d9ef">string</span>) {  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">song</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">songs</span>) {  
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, by </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">singer</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 一个函数只能有一个rest parameters
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">singAllTheSongs</span>(...<span style="color:#a6e22e">songs</span>: <span style="color:#66d9ef">string</span>[], ...<span style="color:#a6e22e">singer</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">number</span>]) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">song</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">songs</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, by </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">singer</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误error TS1014: A rest parameter must be last in a parameter list.
</span></span></span></code></pre></div><p>函数中若**<font color=red>同时有可选参数和可变参数时，可变参数需要放到最后，否则会出现编译错误</font>**。也就是说，<font color="#de7802">对于函数最后一个参数来说，可变参数具有更高优先级</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">singTwo</span>(<span style="color:#a6e22e">first?</span>: <span style="color:#66d9ef">string</span>, ...<span style="color:#a6e22e">second</span>: <span style="color:#66d9ef">string</span>[]) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">first</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> / </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">second</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 这样定义会出现编译错误，因为可变参数在前面
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">singTwo1</span>(...<span style="color:#a6e22e">first</span>: <span style="color:#66d9ef">string</span>[], <span style="color:#a6e22e">second?</span>: <span style="color:#66d9ef">string</span>[]) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">first</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> / </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">second</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#a6e22e">A</span> <span style="color:#a6e22e">rest</span> <span style="color:#a6e22e">parameter</span> <span style="color:#a6e22e">must</span> <span style="color:#a6e22e">be</span> <span style="color:#a6e22e">last</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">a</span> <span style="color:#a6e22e">parameter</span> <span style="color:#a6e22e">list</span>. 
</span></span></code></pre></div><p>在<code>TypeScript</code>中允许标注<code>rest</code>参数的类型，与普通参数类似，只是在末尾添加了<code>[]</code>语法，表示这是一个数组。下面函数<code>singAllTheSongs</code>第二个形参允许<font color=red>接受<code>0</code>个或多个字符串类型的实参</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">singAllTheSongs</span>(<span style="color:#a6e22e">singer</span>: <span style="color:#66d9ef">string</span>, ...<span style="color:#a6e22e">songs</span>: <span style="color:#66d9ef">string</span>[]) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">song</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">songs</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, by </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">singer</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">singAllTheSongs</span>(<span style="color:#e6db74">&#34;Alicia Keys&#34;</span>); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">singAllTheSongs</span>(<span style="color:#e6db74">&#34;Lady Gaga&#34;</span>, <span style="color:#e6db74">&#34;Bad Romance&#34;</span>, <span style="color:#e6db74">&#34;Just Dance&#34;</span>, <span style="color:#e6db74">&#34;Poker Face&#34;</span>); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">Bad</span> <span style="color:#a6e22e">Romance</span>, <span style="color:#a6e22e">by</span> <span style="color:#a6e22e">Lady</span> <span style="color:#a6e22e">Gaga</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Just</span> <span style="color:#a6e22e">Dance</span>, <span style="color:#a6e22e">by</span> <span style="color:#a6e22e">Lady</span> <span style="color:#a6e22e">Gaga</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Poker</span> <span style="color:#a6e22e">Face</span>, <span style="color:#a6e22e">by</span> <span style="color:#a6e22e">Lady</span> <span style="color:#a6e22e">Gaga</span>
</span></span></code></pre></div><h2 id="return-types">Return Types</h2>
<p>如果编译器知道函数所有可能的返回值，就能推断出函数的返回类型。下面代码中，因为函数<code>singSongs</code>返回一个<code>number</code>值，所以编译器推断函数的返回类型为<code>number</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">singSongs</span>(<span style="color:#a6e22e">songs</span>: <span style="color:#66d9ef">string</span>[]) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">song</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">songs</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">songs</span>.<span style="color:#a6e22e">length</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果函数体中包含多个不同返回语句，编译器<font color="#e36c09">将返回类型推断为所有可能返回值类型的联合</font>。下面函数<code>getSongAt</code>的返回类型将被推断为<code>string | undefined</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getSongAt</span>(<span style="color:#a6e22e">songs</span>: <span style="color:#66d9ef">string</span>[], <span style="color:#a6e22e">index</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">index</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">songs</span>.<span style="color:#a6e22e">length</span> <span style="color:#f92672">?</span> <span style="color:#a6e22e">songs</span>[<span style="color:#a6e22e">index</span>] <span style="color:#f92672">:</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="explicit-return-types">Explicit Return Types</h3>
<p>如同变量声明，通常不建议使用类型标注来显式声明函数的返回值类型。不过，在某些情况下显式地标注函数的返回类型很有用：</p>
<ul>
<li>可能希望强制具有多种可能返回值的函数始终返回相同类型的值。</li>
<li><code>TypeScript</code>编译器<font color=red>拒绝尝试推断递归函数的返回类型</font>。</li>
<li>加快超大型项目中的<code>TypeScript</code>类型检查速度。</li>
</ul>
<p>函数声明时的返回值类型标注位于参数列表的右圆括号之后，函数声明的左大括号<code>{</code>之前：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 使用function定义的函数可以在其定义前被调用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">singSongsRecursive</span>([<span style="color:#e6db74">&#39;000&#39;</span>])) 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">singSongsRecursive</span>(<span style="color:#a6e22e">songs</span>: <span style="color:#66d9ef">string</span>[], <span style="color:#a6e22e">count</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">songs</span>.<span style="color:#a6e22e">length</span> <span style="color:#f92672">?</span> <span style="color:#a6e22e">singSongsRecursive</span>(<span style="color:#a6e22e">songs</span>.<span style="color:#a6e22e">slice</span>(<span style="color:#ae81ff">1</span>), <span style="color:#a6e22e">count</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">:</span> <span style="color:#a6e22e">count</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>对于箭头函数（也称为<code>lambdas</code>表达式）来说，返回类型标注正好位于箭头<code>=&gt;</code>之前，箭头之后是函数体。下面定义了两个箭头函数<code>receive</code>和<code>singSongsRecursive</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">receive</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">song</span>: <span style="color:#66d9ef">string</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">song</span>.<span style="color:#a6e22e">length</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">receive</span>(<span style="color:#e6db74">&#39;67890&#39;</span>)); <span style="color:#75715e">// 执行结果为5
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 定义递归箭头函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">singSongsRecursive</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">songs</span>: <span style="color:#66d9ef">string</span>[], <span style="color:#a6e22e">count</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">songs</span>.<span style="color:#a6e22e">length</span> <span style="color:#f92672">?</span> <span style="color:#a6e22e">singSongsRecursive</span>(<span style="color:#a6e22e">songs</span>.<span style="color:#a6e22e">slice</span>(<span style="color:#ae81ff">1</span>), <span style="color:#a6e22e">count</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">:</span> <span style="color:#a6e22e">count</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">len</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">singSongsRecursive</span>([<span style="color:#e6db74">&#39;13&#39;</span>, <span style="color:#e6db74">&#39;345&#39;</span>, <span style="color:#e6db74">&#39;890&#39;</span>])
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">len</span>) <span style="color:#75715e">// 3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">singSongsRecursive</span>([<span style="color:#e6db74">&#39;2&#39;</span>, <span style="color:#e6db74">&#39;45&#39;</span>, <span style="color:#e6db74">&#39;99090&#39;</span>], <span style="color:#ae81ff">10</span>)) <span style="color:#75715e">// 执行结果为13
</span></span></span></code></pre></div><p>若<font color="#e36c09">函数体中返回语句对应的值不能赋值给函数标注的返回类型</font>，会出现编译错误。下面示例代码中，函数的返回类型标注为<code>Date | undefined</code>，但在函数体中却返回了<code>string</code>，会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getSongRecordingDate</span>(<span style="color:#a6e22e">song</span>: <span style="color:#66d9ef">string</span>)<span style="color:#f92672">:</span> Date <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">switch</span> (<span style="color:#a6e22e">song</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;Strange Fruit&#34;</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> Date(<span style="color:#e6db74">&#39;April 20, 1939&#39;</span>); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;Greensleeves&#34;</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 编译错误: Type &#39;string&#39; is not assignable to type &#39;Date&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;unknown&#34;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">undefined</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>但需要注意的是，使用<code>function</code>定义的函数可以在其定义前被调用，而箭头函数不能在定义前调用（会出现编译错误）。</p>
<h2 id="function-types">Function Types</h2>
<p><code>JavaScript</code>允许将函数作为值传递。这意味着需要一种方法来声明用于存放函数类型的参数或变量。<font color=red>函数类型标注语法与箭头函数类似，只是用类型代替了函数体</font>。下面变量<code>nothingInGivesString</code>的类型标注为一个无参数，返回一个字符串的函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 猜测是因为已经有冒号了，所以不使用冒号来定义返回值类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">nothingInGivesString</span><span style="color:#f92672">:</span> () <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">string</span>; 
</span></span></code></pre></div><p>下面变量<code>inputAndOutput</code>的类型标注是一个函数，该函数有一个<code>string[]</code>字符串数组类型的形参，一个可选的形参<code>count</code>，并返回一个<code>number</code>类型值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">inputAndOutput</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">songs</span>: <span style="color:#66d9ef">string</span>[], <span style="color:#a6e22e">count?</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">number</span>;
</span></span></code></pre></div><p>函数类型常用于描述回调：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">songs</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#39;123&#39;</span>, <span style="color:#e6db74">&#39;789&#39;</span>, <span style="color:#e6db74">&#39;778&#39;</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">runOnSongs</span>(<span style="color:#a6e22e">songs</span>: <span style="color:#66d9ef">string</span>[], <span style="color:#a6e22e">getSongAt</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">index</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">songs</span>.<span style="color:#a6e22e">length</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">getSongAt</span>(<span style="color:#a6e22e">i</span>));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">runOnSongs2</span>(<span style="color:#a6e22e">songs</span>: <span style="color:#66d9ef">string</span>[], <span style="color:#a6e22e">getSongAt</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">index</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span> [<span style="color:#66d9ef">string</span>, <span style="color:#66d9ef">number</span>]) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">songs</span>.<span style="color:#a6e22e">length</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">getSongAt</span>(<span style="color:#a6e22e">i</span>));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getSongAt</span>(<span style="color:#a6e22e">index</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">songs</span>[<span style="color:#a6e22e">index</span>]<span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">runOnSongs</span>(<span style="color:#a6e22e">songs</span>, <span style="color:#a6e22e">getSongAt</span>);
</span></span></code></pre></div><h3 id="function-type-parentheses">Function Type Parentheses</h3>
<p>函数类型可以放置在任何需要类型标注的地方，包括联合类型。在联合类型中，可以<font color="#e36c09">使用圆括号来表示哪一部分是函数返回值哪一部分是联合类型的函数子类型</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 定义了一个函数类型变量，该函数的返回的类型是string和undefine的联合
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Type is a function that returns a union: string | undefined
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">returnsStringOrUndefined</span><span style="color:#f92672">:</span> () <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 定义了一个变量，该变量的类型是函数类型和undefined的联合
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Type is either undefined or a function that returns a string 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">maybeReturnsString</span><span style="color:#f92672">:</span> (() <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">string</span>) <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>;
</span></span></code></pre></div><h3 id="parameter-type-inferences">Parameter Type Inferences</h3>
<p>如果必须为编写的每个函数（包括用作参数的内联函数）声明参数类型，将会非常麻烦。幸运的是，可以推断出函数中的参数类型，即<font color="#de7802">使用函数声明时相同位置的参数类型</font>。</p>
<p>下面示例代码中，变量<code>singer</code>是一个接收字符串类型形参的函数，因此赋值给<code>singer</code>的函数中的<code>song</code>参数也是一个字符串类型。声明和定义分开时，定义的参数名可以和声明时不一致：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">singer</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">song</span>: <span style="color:#66d9ef">string</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 下面形参song的类型被推断为string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">singer</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">song</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">str</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">`Singing: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span>.<span style="color:#a6e22e">toUpperCase</span>()<span style="color:#e6db74">}</span><span style="color:#e6db74">!`</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">str</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">str</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">singer</span>(<span style="color:#e6db74">&#39;test&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 形参名可以和定义时不一致！！！
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">singer</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">singer</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">str</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">`Singing: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">singer</span>.<span style="color:#a6e22e">toUpperCase</span>()<span style="color:#e6db74">}</span><span style="color:#e6db74">!`</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">str</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">str</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>实际上，<font color="#de7802">作为实参传递给函数类型形参的函数，其参数类型也能被推断出来</font>。下面示例代码中，参数<code>song</code>和<code>index</code>的类型被推断为<code>string</code>和<code>number</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">songs</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;Call Me&#34;</span>, <span style="color:#e6db74">&#34;Jolene&#34;</span>, <span style="color:#e6db74">&#34;The Chain&#34;</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 省略了第3个数组参数，这里有个疑问为什么可以省略第3个参数？？？
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">songs</span>.<span style="color:#a6e22e">forEach</span>((<span style="color:#a6e22e">song</span>, <span style="color:#a6e22e">index</span>) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> is at index </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">index</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>});
</span></span></code></pre></div><h3 id="function-type-aliases">Function Type Aliases</h3>
<p>用于创建类型别名的<code>type</code>也可以用于函数类型。下面示例代码中类型别名<code>StringToNumber</code>是一个接收<code>string</code>并返回<code>number</code>的函数，这意味着别名类型<code>StringToNumber</code>可以用来标注函数变量的类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">StringToNumber</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">string</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">stringToNumber</span>: <span style="color:#66d9ef">StringToNumber</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// input被推断为字符串类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">stringToNumber</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">input</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">input</span>.<span style="color:#a6e22e">length</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">stringToNumber</span>(<span style="color:#e6db74">&#39;1233199&#39;</span>))  <span style="color:#75715e">// 7
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">stringToNumber</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">input</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">123</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">stringToNumber</span>(<span style="color:#e6db74">&#39;3455&#39;</span>)) <span style="color:#75715e">// 123
</span></span></span></code></pre></div><p>类似地，函数的类型别名也可以用于函数形参的声明：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">NumberToString</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">usesNumberToString</span>(<span style="color:#a6e22e">numberToString</span>: <span style="color:#66d9ef">NumberToString</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`The string is: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">numberToString</span>(<span style="color:#ae81ff">1234</span>)<span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="more-return-types">More Return Types</h2>
<p>接下来看两个特殊的函数返回值类型，<code>void</code>和<code>never</code>。有些函数并不返回任何值，它们要么没有<code>return</code>语句，要么只有无返回值的<code>return</code>语句。<code>TypeScript</code>允许<font color="#e36c09">使用<code>void</code>关键字来说明这种不返回任何值的函数的返回类型</font>。</p>
<p>在<font color="#de7802">返回类型声明为<code>void</code>的函数体中不能返回任何值，否则会出现编译错误</font>。下面<code>logSong</code>函数被声明为返回<code>void</code>类型，因此在函数体中不允许有返回值。在函数体中出现了<code>return true</code>，所以会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">logSong</span>(<span style="color:#a6e22e">song</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">void</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 空字符串或undefined直接返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">song</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 出现编译错误：Type &#39;boolean&#39; is not assignable to type &#39;void&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 无返回值的函数不能返回值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>; 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在箭头函数类型声明时（不使用<code>function</code>关键字声明的函数），<code>void</code>作为返回类型很有用。在函数类型声明时，将函数返回类型标注<code>void</code>时，<strong><font color=red>它表示函数中的任何返回值都将被忽略</font></strong>。下面示例代码中，<code>songLogger</code>变量代表了一个函数，它接受一个<code>string</code>参数，并且不返回任何值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">songLogger</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">song</span>: <span style="color:#66d9ef">string</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">void</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">songLogger</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">song</span>) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">songLogger</span>(<span style="color:#e6db74">&#34;Heart of Glass&#34;</span>); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 下面函数类型声明时使用void，但实参函数中有返回值时会被忽略
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">songLogger</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">song</span>: <span style="color:#66d9ef">string</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">void</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">songLogger</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">song</span>: <span style="color:#66d9ef">string</span>) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">song</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 虽然有参数参数返回，但会被忽略，不会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">song</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">test</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">songLogger</span>(<span style="color:#e6db74">&#34;HerKind1&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">test</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">HerKind1</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">HerKind1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">songs</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;Call Me&#34;</span>, <span style="color:#e6db74">&#34;Jolene&#34;</span>, <span style="color:#e6db74">&#34;The Chain&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">songs</span>.<span style="color:#a6e22e">forEach</span>((<span style="color:#a6e22e">song</span>, <span style="color:#a6e22e">index</span>) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> is at index </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">index</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 即使有返回值也会被忽略
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>});
</span></span></code></pre></div><p>请注意，尽管<code>JavaScript</code>函数在没有真实返回值的情况下默认会返回<code>undefined</code>，但返回类型<font color="#e36c09"><code>void</code>并不等同于<code>undefined</code>。<code>void</code>意味着函数的返回值将被忽略，而<code>undefined</code>则是要返回的字面量</font>。此外，若尝试将<code>void</code>类型值赋给类型包括<code>undefined</code>的变量，将会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">returnsVoid() {</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">lazyValue</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 将void赋值给变量出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Type &#39;void&#39; is not assignable to type &#39;string | undefined&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">lazyValue</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">returnsVoid</span>(); 
</span></span></code></pre></div><p>返回值<code>undefined</code>和<code>void</code>之间的区别，对于忽略传递到形参为函数类型的，并且该形参函数的返回类型标注为<code>void</code>的实参函数的任何返回值特别有用。例如，数组的内置<code>forEach</code>方法声明的形参函数的返回类型为<code>void</code>，<span style="background:rgba(240, 107, 5, 0.2)">它可以忽略任何传入的实参函数的返回值</span>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// forEach的定义
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">forEach</span>(<span style="color:#a6e22e">callbackfn</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">T</span>, <span style="color:#a6e22e">index</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">array</span>: <span style="color:#66d9ef">T</span>[]) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">void</span>, <span style="color:#a6e22e">thisArg?</span>: <span style="color:#66d9ef">any</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">void</span>;
</span></span></code></pre></div><p>下面<code>saveRecords</code>函数中，<code>records.push(record)</code>返回一个数值（数组<code>push()</code>方法的返回值，表示数组的元素个数），但仍允许作为传递给<code>newRecords.forEach</code>的箭头函数的返回值，<font color="#de7802">因为这个返回值会被忽略</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">records</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#39;123&#39;</span>, <span style="color:#e6db74">&#39;456&#39;</span>]  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">saveRecords</span>(<span style="color:#a6e22e">newRecords</span>: <span style="color:#66d9ef">string</span>[]) {  
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// records.push有返回值，且没有使用大括号，因此records.push就是箭头函数的返回值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 实际上传入的实参是有返回值，但被忽略了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">newRecords</span>.<span style="color:#a6e22e">forEach</span>(<span style="color:#a6e22e">record</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">records</span>.<span style="color:#a6e22e">push</span>(<span style="color:#a6e22e">record</span>));  
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">saveRecords</span>([<span style="color:#e6db74">&#39;21&#39;</span>, <span style="color:#e6db74">&#39;Come On Over&#39;</span>, <span style="color:#e6db74">&#39;The Bodyguard&#39;</span>])  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">records</span>) <span style="color:#75715e">// [ &#39;123&#39;, &#39;456&#39;, &#39;21&#39;, &#39;Come On Over&#39;, &#39;The Bodyguard&#39; ]
</span></span></span></code></pre></div><p><code>void</code>类型不属于<code>JavaScript</code>，仅是<code>TypeScript</code>的一个关键字，用于声明函数的返回值类型。需要注意的是，<font color=red>它表示函数的返回值不打算被使用，而不是表示返回值可以被返回</font>。</p>
<h3 id="never-returns">Never Returns</h3>
<p>有些函数不仅没有返回值，而且根本不返回。<font color="#de7802">永不返回的函数是那些抛出错误或运行无限循环的函数</font>（希望是故意的）。如果一个函数永远不返回，那么显式添加<code>: never</code>类型标注，表示调用该函数后的任何代码都不会运行。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">fail</span>(<span style="color:#a6e22e">message</span>: <span style="color:#66d9ef">string</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">never</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> Error(<span style="color:#e6db74">`Invariant failure: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">message</span><span style="color:#e6db74">}</span><span style="color:#e6db74">.`</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fail</span>(<span style="color:#e6db74">&#34;123&#34;</span>)
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">e</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">error</span>((<span style="color:#a6e22e">e</span> <span style="color:#66d9ef">as</span> Error).<span style="color:#a6e22e">message</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">Invariant</span> <span style="color:#a6e22e">failure</span>: <span style="color:#66d9ef">123.</span>
</span></span></code></pre></div><p>下面<code>fail</code>函数只是抛出一个错误，它有助于控制流分析，将参数<code>param</code>窄化为<code>string</code>，即参数<code>param</code>的类型不为<code>string</code>，则会抛出异常。虽然没有标注返回类型，编译器推断返回类型是<code>void</code>，而不是<code>never</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">workWithUnsafeParam</span>(<span style="color:#a6e22e">param</span>: <span style="color:#66d9ef">unknown</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">param</span> <span style="color:#f92672">!==</span> <span style="color:#e6db74">&#34;string&#34;</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fail</span>(<span style="color:#e6db74">`param should be a string, not </span><span style="color:#e6db74">${</span><span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">param</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">param</span>.<span style="color:#a6e22e">toUpperCase</span>());
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">workWithUnsafeParam</span>(<span style="color:#e6db74">&#39;1233&#39;</span>);
</span></span></code></pre></div><p>需要注意的是，返回类型为<code>void</code>指的是函数不返回任何内容，而<code>never</code>指的是永远不返回内容的函数。<em>never is not the same as void. void is for a function that returns nothing. never is for a function that never returns.</em></p>
<h2 id="function-overloads">Function Overloads</h2>
<p>有些<code>JavaScript</code>函数可以使用完全不同的实参来调用，而这些实参集不能只用可选参数或可变参数来表示。这些函数可以使用一种被称为重载签名（<code>overload signatures</code>）的语法来描述：<font color="#de7802">在最终实现签名和函数体之前，多次声明不同版本的形参和返回类型</font>。</p>
<p>在决定是否对重载函数的调用发出语法错误时，<code>TypeScript</code>只会查看函数的重载签名。实现签名只用于函数的内部逻辑。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">createDate</span>(<span style="color:#a6e22e">timestamp</span>: <span style="color:#66d9ef">number</span>)<span style="color:#f92672">:</span> Date;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">createDate</span>(<span style="color:#a6e22e">month</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">day</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">year</span>: <span style="color:#66d9ef">number</span>)<span style="color:#f92672">:</span> Date;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">createDate</span>(<span style="color:#a6e22e">monthOrTimestamp</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">day?</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">year?</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">day</span> <span style="color:#f92672">===</span> <span style="color:#66d9ef">undefined</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">year</span> <span style="color:#f92672">===</span> <span style="color:#66d9ef">undefined</span> <span style="color:#f92672">?</span> <span style="color:#66d9ef">new</span> Date(<span style="color:#a6e22e">monthOrTimestamp</span>) <span style="color:#f92672">:</span> <span style="color:#66d9ef">new</span> Date(<span style="color:#a6e22e">year</span>, <span style="color:#a6e22e">monthOrTimestamp</span>, <span style="color:#a6e22e">day</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">createDate</span>(<span style="color:#ae81ff">554356800</span>); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">createDate</span>(<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">27</span>, <span style="color:#ae81ff">1987</span>); <span style="color:#75715e">// Ok
</span></span></span></code></pre></div><p>函数的重载签名与类型系统的其它语法一样，在编译输出为<code>JavaScript</code>后会被删除。<font color="#e36c09">一般来说，最好保持函数简单，尽可能避免使用函数重载</font>。</p>
<h3 id="call-signature-compatibility">Call-Signature Compatibility</h3>
<p>重载函数实现所使用的签名就是该函数的实现所使用的参数类型和返回类型。因此，<font color="#e36c09">函数重载签名中的返回类型和每个参数都必须可以可赋值给实现签名中同一索引处的参数</font>。换句话说，重载函数的<font color="#0070c0">实现签名必须与所有重载签名兼容</font>。下面示例代码中，因为实现签名和所有的重载签名不兼容，会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">format</span>(<span style="color:#a6e22e">data</span>: <span style="color:#66d9ef">string</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">format</span>(<span style="color:#a6e22e">data</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">needle</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">haystack</span>: <span style="color:#66d9ef">string</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">format</span>(<span style="color:#a6e22e">getData</span><span style="color:#f92672">:</span> () <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">string</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// This overload signature is not compatible with its implementation signature.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">format</span>(<span style="color:#a6e22e">data</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">needle?</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">haystack?</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">needle</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">haystack</span> <span style="color:#f92672">?</span> <span style="color:#a6e22e">data</span>.<span style="color:#a6e22e">replace</span>(<span style="color:#a6e22e">needle</span>, <span style="color:#a6e22e">haystack</span>) <span style="color:#f92672">:</span> <span style="color:#a6e22e">data</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="arrays">Arrays</h1>
<p><code>TypeScript</code>通过记住数组中初始的数据类型，并且只允许数组对该数据类型进行操作，从而遵守了每个数组只使用一种数据类型的最佳实践。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">warriors</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;Artemisia&#34;</span>, <span style="color:#e6db74">&#34;Boudica&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Ok: &#34;Zenobia&#34; is a string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">warriors</span>.<span style="color:#a6e22e">push</span>(<span style="color:#e6db74">&#34;Zenobia&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Argument of type &#39;boolean&#39; is not assignable to parameter of type &#39;string&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">warriors</span>.<span style="color:#a6e22e">push</span>(<span style="color:#66d9ef">true</span>);
</span></span></code></pre></div><p>通常，<font color="#de7802">编译器通常会尝试从初始赋值来推断类型</font>，数组也不例外。根据数组的初始成员推断数组类型与根据变量的初始值推断变量类型类似。</p>
<h2 id="array-types">Array Types</h2>
<p>如同其它变量声明，数组变量声明时也可以不初始化。同样地，在严格模式下，<span style="background:rgba(255, 183, 139, 0.55)">如果数组变量未初始化之前就使用会出现编译错误</span>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">arrayOfNumbers</span>: <span style="color:#66d9ef">number</span>[];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 因为已标注了类型且未初始化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 所以未初始化前就使用会编译报错
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Variable &#39;arrayOfNumbers&#39; is used before being assigned.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">arrayOfNumbers</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">arrayOfNumbers</span>[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">arrayOfNumbers</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">23</span>, <span style="color:#ae81ff">42</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 初始化之后才可以使用，此时不会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">arrayOfNumbers</span>) <span style="color:#75715e">// 打印出来的值为Object
</span></span></span></code></pre></div><h3 id="array-and-function-types">Array and Function Types</h3>
<p>如果<font color="#de7802">涉及数组和函数类型时可能需要使用圆括号来区分数组类型中的内容</font>。圆括号可用于指明类型中哪一部分是函数的返回值，哪一部分是数组内容。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// Type is a function that returns an array of strings
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">createStrings</span><span style="color:#f92672">:</span> () <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">string</span>[];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type is an array of functions that each return a string 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">stringCreators</span><span style="color:#f92672">:</span> (() <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">string</span>)[];
</span></span></code></pre></div><h3 id="union-type-arrays">Union-Type Arrays</h3>
<p>可以使用联合类型来标注数组中元素是多个可能的类型。将数组类型与联合类型一起使用时，<font color="#de7802">可能需要使用圆括号来指明中哪一部分是数组的内容，哪一部分是联合类型的内容</font>。在数组联合类型中使用圆括号非常重要，以下两种类型并不相同：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// Type is either a number or an array of strings
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">stringOrArrayOfNumbers</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">number</span>[];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type is an array of elements that are each either a number or a string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">arrayOfStringOrNumbers</span><span style="color:#f92672">:</span> (<span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">number</span>)[];
</span></span></code></pre></div><p>如果同一个数组中的元素类型不同，编译器就会从数组的声明中推断它是一个<code>union</code>类型的数组。换句话说，使用字面量初始化数组变量时，<font color="#de7802">数组中元素的类型是数组中所有可能元素类型的联合</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// namesMaybe的类型是(string | undefined)[]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">namesMaybe</span> <span style="color:#f92672">=</span> [
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;Aqualtune&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;Blenda&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">undefined</span>,
</span></span><span style="display:flex;"><span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">namesMaybe</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">namesMaybe</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>[<span style="color:#e6db74">&#34;Aqualtune&#34;</span>, <span style="color:#e6db74">&#34;Blenda&#34;</span>, <span style="color:#66d9ef">undefined</span>]
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">object</span>
</span></span></code></pre></div><h3 id="evolving-any-arrays">Evolving Any Arrays</h3>
<p>若初始值为空的数组变量不加上类型标注，则数组的类型将被推断为<code>any[]</code>。这意味着该数组可以接收任何内容，若不小心添加了可能不正确的值，会抵消类型检查器的好处。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// Type: any[]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">values</span> <span style="color:#f92672">=</span> [];
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">values</span>.<span style="color:#a6e22e">push</span>(<span style="color:#e6db74">&#39;&#39;</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">values</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">values</span>, <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">values</span>) <span style="color:#75715e">// [ &#39;&#39;, 0 ] object
</span></span></span></code></pre></div><p>如同变量，如果允许数组的元素是<code>any</code>类型，也就违背了类型检查的目的。当精确地知道变量是什么类型时，编译器会工作得更好。</p>
<h3 id="multidimensional-arrays">Multidimensional Arrays</h3>
<p>一个二维数组，有两个<code>[]</code>，三维数组有3个<code>[]</code>，四维数组有4个<code>[]</code>，5个数组有5个<code>[]</code>，依此类推：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 声明二维数组，下面两种方式均可以
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">arrayOfArraysOfNumbers1</span>: <span style="color:#66d9ef">number</span>[][];  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">arrayOfArraysOfNumbers2</span><span style="color:#f92672">:</span> (<span style="color:#66d9ef">number</span>[])[]; 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">arrayOfArraysOfNumbers1</span> <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>], [<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">6</span>], [<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">9</span>],];  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">arrayOfArraysOfNumbers2</span> <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>], [<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">8</span>], [<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">11</span>],];  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">arrayOfArraysOfNumbers1</span>, <span style="color:#a6e22e">arrayOfArraysOfNumbers2</span>)
</span></span></code></pre></div><h2 id="array-members">Array Members</h2>
<p><code>TypeScript</code>基于索引访问数组中的元素。下面定义的常量<code>defenders</code>类型为<code>string[]</code>，因此接收数组中元素的常量<code>defender</code>的类型是<code>string</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">defenders</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;Clarenza&#34;</span>, <span style="color:#e6db74">&#34;Dina&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">defender</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">defenders</span>[<span style="color:#ae81ff">0</span>];
</span></span></code></pre></div><p>联合类型数组的成员都是同一种联合类型。下面常量<code>soldiersOrDates</code>的类型为<code>(string | Date)[]</code>，因此常量<code>soldierOrDate</code>的类型也为<code>string | Date</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">soldiersOrDates</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;Deborah Sampson&#34;</span>, <span style="color:#66d9ef">new</span> Date(<span style="color:#ae81ff">1782</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">3</span>)];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 即使不显式标注类型，编译器可以推断出类型为: Date | string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">soldierOrDate</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">soldiersOrDates</span>[<span style="color:#ae81ff">0</span>];
</span></span></code></pre></div><h3 id="caveat-unsound-members">Caveat: Unsound Members</h3>
<p>众所周知，<code>TypeScript</code>的<span style="background:rgba(255, 183, 139, 0.55)">类型系统在技术上是不健全的，它可以使类型在多数情况下是正确的</span>，但有时对值类型的理解可能是不正确的，<strong><font color=red>数组尤其是类型系统不健全的根源</font></strong>。</p>
<p>默认情况下，<code>TypeScript</code><font color="#de7802">假设所有数组成员的访问都会返回相应成员</font>，尽管在<code>JavaScript</code>中，访问数组元素的索引大于数组的长度会得到<code>undefined</code>。下面这段代码<font color="#245bdb">编译没有任何问题，但运行时会报错</font>，因为访问了<code>undefined</code>，但它没有<code>length</code>属性：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">withElements</span>(<span style="color:#a6e22e">elements</span>: <span style="color:#66d9ef">string</span>[]) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 不会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">elements</span>[<span style="color:#ae81ff">9001</span>].<span style="color:#a6e22e">length</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 运行时错误：Cannot read properties of undefined (reading &#39;length&#39;)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">withElements</span>([<span style="color:#e6db74">&#34;It&#39;s&#34;</span>, <span style="color:#e6db74">&#34;over&#34;</span>]);
</span></span></code></pre></div><p><code>TypeScript</code><span style="background:rgba(255, 183, 139, 0.55)">故意不确保检索到的数组成员是否存在</span>，它认为上面示例代码片段中的<code>elements[9001]</code>是字符串类型，而不是<code>undefined</code>类型。</p>
<h2 id="spreads-and-rests">Spreads and Rests</h2>
<p>在函数定义时可以使用<code>...</code>表示可变参数，在数组中也有同样的操作符<code>...</code>，被称为<code>spread</code>操作符，表示将数组展开。同样的符号，代表不同的含义，需要特别注意。</p>
<h3 id="spreads">Spreads</h3>
<p>可以使用<code>...</code>展开操作符将将数组连接在一起，<font color="#de7802">结果数组将包含来自输入数组的所有值</font>。如果输入数组的元素类型相同，则结果数组的元素类型也相同。<font color="#de7802">如果将两个不同类型的数组展开在一起创建一个新数组，新数组将被推断为联合类型数组</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 数组类型为 string[]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">soldiers</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;Harriet Tubman&#34;</span>, <span style="color:#e6db74">&#34;Joan of Arc&#34;</span>, <span style="color:#e6db74">&#34;Khutulun&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 数组类型为 number[]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">soldierAges</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">90</span>, <span style="color:#ae81ff">19</span>, <span style="color:#ae81ff">45</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 数组类型为 (string | number)[]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">conjoined</span> <span style="color:#f92672">=</span> [...<span style="color:#a6e22e">soldiers</span>, ...<span style="color:#a6e22e">soldierAges</span>]; <span style="color:#75715e">// [ &#39;Harriet Tubman&#39;, &#39;Joan of Arc&#39;, &#39;Khutulun&#39;, 90, 19, 45 ]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 数组类型为string[]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>([...<span style="color:#a6e22e">soldiers</span>, ...<span style="color:#a6e22e">soldiers</span>]);
</span></span></code></pre></div><h3 id="spreading-rest-parameters">Spreading Rest Parameters</h3>
<p>编译器可识别<code>...</code>展开操作符，即<font color=#548dd4>可将一个数组展开作为可变形参的实参</font>并执行类型检查。<font color="#de7802">数组作为实参传递给可变形参时必须具有相同类型</font>，下面代码中展开数组<code>warriors</code>是允许的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">logWarriors</span>(<span style="color:#a6e22e">greeting</span>: <span style="color:#66d9ef">string</span>, ...<span style="color:#a6e22e">names</span>: <span style="color:#66d9ef">string</span>[]) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">name</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">names</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">greeting</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">name</span><span style="color:#e6db74">}</span><span style="color:#e6db74">!`</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">warriors</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;Cathay Williams&#34;</span>, <span style="color:#e6db74">&#34;Lozen&#34;</span>, <span style="color:#e6db74">&#34;Nzinga&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">logWarriors</span>(<span style="color:#e6db74">&#34;Hello&#34;</span>, ...<span style="color:#a6e22e">warriors</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">Hello</span>, <span style="color:#a6e22e">Cathay</span> <span style="color:#a6e22e">Williams</span><span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Hello</span>, <span style="color:#a6e22e">Lozen</span><span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Hello</span>, <span style="color:#a6e22e">Nzinga</span><span style="color:#f92672">!</span>
</span></span></code></pre></div><h2 id="tuples">Tuples</h2>
<p>虽然数组在理论上可以是任意大小，但有时使用固定大小的数组（称为元组）也很有用。<font color="#de7802">元组中的每个元素都有特定类型，这个类型可能比数组所有可能成员的联合类型更具体</font>。声明元组类型的语法与数组字面量相似，只是用类型代替了元素值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 元组类型，中括号里面是类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">yearAndWarrior</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">number</span>, <span style="color:#66d9ef">string</span>];
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">yearAndWarrior</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">530</span>, <span style="color:#e6db74">&#34;Tomyris&#34;</span>]; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">yearAndWarrior</span>[<span style="color:#ae81ff">0</span>], <span style="color:#a6e22e">yearAndWarrior</span>[<span style="color:#ae81ff">1</span>]);
</span></span></code></pre></div><p>在<code>JavaScript</code>中，<span style="background:#ffb78b8c">元组通常与数组解构一起使用，以便一次赋值多个变量</span>。例如，可以根据条件判断设置两个变量的初始值。下面使用元组来解构数组的元素，得到的类型和直接访问某个元素得到的结果不一样：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 因为是使用字面量直接解构，所以year的类型为number,warrior的类型为string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 注意year和warrior类型不是sting | number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> [<span style="color:#a6e22e">year</span>, <span style="color:#a6e22e">warrior</span>] <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> [<span style="color:#ae81ff">340</span>, <span style="color:#e6db74">&#34;Archidamia&#34;</span>] <span style="color:#f92672">:</span> [<span style="color:#ae81ff">1828</span>, <span style="color:#e6db74">&#34;Rani of Jhansi&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">year</span>, <span style="color:#a6e22e">warrior</span>) <span style="color:#75715e">// 每次执行结果可能不同，结果为340 Archidamia 或1828 Archidamia
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">year</span>, <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">warrior</span>); <span style="color:#75715e">// number string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// other的类型为string ｜ number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">other</span> <span style="color:#f92672">=</span> (Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> [<span style="color:#ae81ff">340</span>, <span style="color:#e6db74">&#34;Archidamia&#34;</span>] <span style="color:#f92672">:</span> [<span style="color:#ae81ff">1828</span>, <span style="color:#e6db74">&#34;Rani of Jhansi&#34;</span>])[<span style="color:#ae81ff">0</span>];
</span></span></code></pre></div><h3 id="tuple-assignability">Tuple Assignability</h3>
<p>在<code>TypeScript</code>中元组类型视为比变长数组更特殊的类型，<font color=red>这意味着变长数组类型不能赋值给元组类型</font>。下面代码中，变量<code>pairLoose</code>是数组类型<code>(boolean | number)[]</code>，即数组中元素类型是<code>(boolean | number)</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 推断为数组类型，数组中元素的类型为 (boolean | number)[]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">pairLoose</span> <span style="color:#f92672">=</span> [<span style="color:#66d9ef">false</span>, <span style="color:#ae81ff">123</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误: Type &#39;(number | boolean)[]&#39; is not assignable to type &#39;[boolean, number]&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Target requires 2 element(s) but source may have fewer.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">pairTupleLoose</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">boolean</span>, <span style="color:#66d9ef">number</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">pairLoose</span>;
</span></span></code></pre></div><p>上面代码中，如果将变量<code>pairLoose</code>的类型声明为<code>[boolean, number]</code>，那么赋值就是允许的，也不会出现编译错误，因为元组的类型比数组更特殊：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">pairLoose</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">boolean</span>, <span style="color:#66d9ef">number</span>] <span style="color:#f92672">=</span> [<span style="color:#66d9ef">false</span>, <span style="color:#ae81ff">123</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">pairTupleLoose</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">boolean</span>, <span style="color:#66d9ef">number</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">pairLoose</span>;
</span></span></code></pre></div><p>需要注意的是，<span style="background:#ffb78b8c">不同长度的元组也不能相互赋值</span>。因为在声明元组时，编译器已经知道当前元组中有多少个成员，每个成员的类型是什么：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">tupleThree</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">boolean</span>, <span style="color:#66d9ef">number</span>, <span style="color:#66d9ef">string</span>] <span style="color:#f92672">=</span> [<span style="color:#66d9ef">false</span>, <span style="color:#ae81ff">1583</span>, <span style="color:#e6db74">&#34;Nzinga&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">tupleTwoExact</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">boolean</span>, <span style="color:#66d9ef">number</span>] <span style="color:#f92672">=</span> [<span style="color:#a6e22e">tupleThree</span>[<span style="color:#ae81ff">0</span>], <span style="color:#a6e22e">tupleThree</span>[<span style="color:#ae81ff">1</span>]];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Type &#39;[boolean, number, string]&#39; is not assignable to type &#39;[boolean, number]&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Source has 3 element(s) but target allows only 2.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">tupleTwoExtra</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">boolean</span>, <span style="color:#66d9ef">number</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">tupleThree</span>;
</span></span></code></pre></div><p>因为元组被视为数组，但在长度和元素类型上有更具体的信息，所以用于存储传递给函数的实参特别有用。编译器能够<font color="#de7802">将作为实参传递给函数使用<code>...</code>操作符展开的元组提供精确的类型检查</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">logPair</span>(<span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">name</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> has </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">value</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// pairArray的类型为数组 (string | number)[]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">pairArray</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;Amage&#34;</span>, <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 因为pariArray是数组，展开后的元素类型为string | number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 得到的元素类型和函数logPair的类型不一致，会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// A spread argument must either have a tuple type or be passed to a rest parameter.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">logPair</span>(...<span style="color:#a6e22e">pairArray</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">pairTupleIncorrect</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">number</span>, <span style="color:#66d9ef">string</span>] <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;Amage&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误:Argument of type &#39;number&#39; is not assignable to parameter of type &#39;string&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 元组被展开后，对应的类型顺序不对，也会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">logPair</span>(...<span style="color:#a6e22e">pairTupleIncorrect</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 元组类型被展开，编译不会报错
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">pairTupleCorrect</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">string</span>, <span style="color:#66d9ef">number</span>] <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;Amage&#34;</span>, <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">logPair</span>(...<span style="color:#a6e22e">pairTupleCorrect</span>); <span style="color:#75715e">// Ok
</span></span></span></code></pre></div><p>如果想在<code>rest parameters tuples</code>上做文章，可以将它们与数组混合，为多个函数调用存储参数。下面代码中<code>trios.forEach(trio =&gt; logTrio(...trio))</code>是安全的，因为<code>...trio</code>中的每个元素恰好与函数<code>logTrio</code>的参数类型相匹配。即元组<code>...trio</code>被展开为两个实参，第一个是<code>string</code>类型，第二个是<code>[number, boolean]</code>类型。</p>
<p>但是，使用<code>trios.forEach(logTrio)</code>是不可行的，因为它试图将整个<code>[string, [number, boolean]]</code>作为参数传递，但函数<code>logTrio</code>的第一个参数类型要求是<code>string</code>，所以会出现类型不匹配的错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">logTrio</span>(<span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">value</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">number</span>, <span style="color:#66d9ef">boolean</span>]) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">name</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> has </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">value</span>[<span style="color:#ae81ff">0</span>]<span style="color:#e6db74">}</span><span style="color:#e6db74"> (</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">value</span>[<span style="color:#ae81ff">1</span>]<span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">trios</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">string</span>, [<span style="color:#66d9ef">number</span>, <span style="color:#66d9ef">boolean</span>]][] <span style="color:#f92672">=</span> [
</span></span><span style="display:flex;"><span>    [<span style="color:#e6db74">&#34;Amanitore&#34;</span>, [<span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">true</span>]],
</span></span><span style="display:flex;"><span>    [<span style="color:#e6db74">&#34;Æthelflæd&#34;</span>, [<span style="color:#ae81ff">2</span>, <span style="color:#66d9ef">false</span>]],
</span></span><span style="display:flex;"><span>    [<span style="color:#e6db74">&#34;Ann E. Dunwoody&#34;</span>, [<span style="color:#ae81ff">3</span>, <span style="color:#66d9ef">false</span>]]];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 下面方式不会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">trios</span>.<span style="color:#a6e22e">forEach</span>(<span style="color:#a6e22e">trio</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">logTrio</span>(...<span style="color:#a6e22e">trio</span>)); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 下面会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">trios</span>.<span style="color:#a6e22e">forEach</span>(<span style="color:#a6e22e">logTrio</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Argument of type &#39;(name: string, value: [number, boolean]) =&gt; void&#39; is not assignable to parameter of type &#39;(value: [string, [number, boolean]], index: number, array: [string, [number, boolean]][]) =&gt; void&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Types of parameters &#39;name&#39; and &#39;value&#39; are incompatible.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Type &#39;[string, [number, boolean]]&#39; is not assignable to type &#39;string&#39;.
</span></span></span></code></pre></div><h3 id="tuple-inferences">Tuple Inferences</h3>
<p>编译器<font color="#de7802">通常将创建的数组字面量视为长度可变的数组，而不是元组</font>。若<mark style="background:#ffb78b8c">一个数组字面量被用作变量的初始值或函数的返回值，那么编译器将推断它是一个可变长度的数组</mark>，而不是一个固定长度的元组。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 使用[]包围的里面的值是非字面量的，编译器默认推断为数组，而不是元组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">firstCharAndSize</span>(<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 推断为数组类型, (string | number)[]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> [<span style="color:#a6e22e">input</span>[<span style="color:#ae81ff">0</span>], <span style="color:#a6e22e">input</span>.<span style="color:#a6e22e">length</span>];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 这里和对数组字面量的解构有很大区别！！！
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// firstChar的类型为 string | number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// size的类型也为string | number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">firstChar</span>, <span style="color:#a6e22e">size</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">firstCharAndSize</span>(<span style="color:#e6db74">&#34;Gudit&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 使用[]包围的字面量赋值有些区别，year推断为number类型，warrior推断为string类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> [<span style="color:#a6e22e">year</span>, <span style="color:#a6e22e">warrior</span>] <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> [<span style="color:#ae81ff">340</span>, <span style="color:#e6db74">&#34;Archidamia&#34;</span>] <span style="color:#f92672">:</span> [<span style="color:#ae81ff">1828</span>, <span style="color:#e6db74">&#34;Rani of Jhansi&#34;</span>];
</span></span></code></pre></div><h4 id="explicit-tuple-types">Explicit tuple types</h4>
<p>元组可能会被用于类型标注，例如函数的返回值类型标注。<font color="#de7802">如果一个函数的返回类型声明为元组类型，并且在函数里返回一个数组字面量，则这个数组字面量会被推断为元组而不是可变数组。</font></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">firstCharAndSizeExplicit</span>(<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">string</span>)<span style="color:#f92672">:</span> [<span style="color:#66d9ef">string</span>, <span style="color:#66d9ef">number</span>] {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 在函数里面返回字面量，但因为函数显式声明了返回类型为元组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 所以字面量被推断为元组，而不是可变长度数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> [<span style="color:#a6e22e">input</span>[<span style="color:#ae81ff">0</span>], <span style="color:#a6e22e">input</span>.<span style="color:#a6e22e">length</span>];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// firstChar的类型: string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// size的类型: number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">firstChar</span>, <span style="color:#a6e22e">size</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">firstCharAndSizeExplicit</span>(<span style="color:#e6db74">&#34;Cathay Williams&#34;</span>);
</span></span></code></pre></div><h4 id="const-asserted-tuples">Const asserted tuples</h4>
<p>显式标注元组类型比较麻烦，<code>TypeScript</code>提供被称为<code>const</code>断言的<code>as const</code>操作符，该操作符放在值的后面。<code>const</code>断言告诉编译器在推断该值类型时，应当<font color="#de7802">使用该值最直白的只读形式</font>。</p>
<p>如果将<code>const</code>断言放在数组字面量之后，<span style="background:#ffb78b8c">表示数组字面量应被视为元组，并且元组类型被推断为字面量</span>，即不可以被修改的（<code>read only</code>）。下面示例代码中，因为<code>readonlyTuple[0]</code>也是<code>readonly</code>的，所以不能再被赋值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// Type: (string | number)[]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">unionArray</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1157</span>, <span style="color:#e6db74">&#34;Tomoe&#34;</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 只读元组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: readonly [1157, &#34;Tomoe&#34;]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">readonlyTuple</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1157</span>, <span style="color:#e6db74">&#34;Tomoe&#34;</span>] <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">const</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Cannot assign to &#39;0&#39; because it is a read-only property.  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">readonlyTuple</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">12</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 使用变量接收只读元组，编译器推断变量的类型是只读的元组：readonly [1157, &#34;Tomoe&#34;]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">readonlyTuple</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1157</span>, <span style="color:#e6db74">&#34;Tomoe&#34;</span>] <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">const</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 使用let声明，是可以重新赋值的，即能指向新的地方
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">readonlyTuple</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1157</span>, <span style="color:#e6db74">&#34;Tomoe&#34;</span>]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">readonlyTuple</span>, <span style="color:#a6e22e">readonlyTuple</span>[<span style="color:#ae81ff">0</span>], <span style="color:#a6e22e">readonlyTuple</span>[<span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// readonlyTuple的类型是readOnly的[1157, &#34;Tomoe&#34;]，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 即使指向了新的元组，修改元组中的元素依然会编译错误，因为其属性仍然是不可修改的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Cannot assign to &#39;0&#39; because it is a read-only property
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 从编译错误信息来看，即使使用索引访问数组，但其也是属性！！！
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">readonlyTuple</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">12</span>
</span></span></code></pre></div><p>请注意，<code>const</code>断言不仅将数组字面量转换为固定大小的元组，还向编译器表明，<font color=red>元组是只读的，不能在希望允许修改值的地方使用</font>。</p>
<p>下面代码中，<code>pairMutable</code>中的元素是允许被修改的，因为它是普通的元组类型。但是，断言<code>as const</code>使得常量<code>pairConst</code>中的成员也不允许被修改：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">pairMutable</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">number</span>, <span style="color:#66d9ef">string</span>] <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1157</span>, <span style="color:#e6db74">&#34;Tomoe&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">pairMutable</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1247</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 下面赋值是可以的，但pairAlsoMutable不能整体被赋值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">pairAlsoMutable</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">number</span>, <span style="color:#66d9ef">string</span>] <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1157</span>, <span style="color:#e6db74">&#34;Tomoe&#34;</span>] <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">const</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 直接改变元组中的值是允许的！！！
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 因为pairAlsoMutable声明时只表明指向是不可修改的，但其中的元素依然是可以被修改的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">pairAlsoMutable</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1233</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// pariConst的类型相当于字面量的[1157,&#34;Tomoe&#34;]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">pairConst</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1157</span>, <span style="color:#e6db74">&#34;Tomoe&#34;</span>] <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">const</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 直接改变元组中的值是不允许的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Cannot assign to &#39;0&#39; because it is a read-only property
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">pairConst</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1247</span>;
</span></span></code></pre></div><p>在实践中，只读元组作为函数返回值很方便。因为<font color="#de7802">函数中返回的元组值通常会立即解构，所以只读元组不会妨碍函数的使用</font>。下面示例代码中，使用<code>let</code>解构<code>as const</code>断言后的元组，可以修改解构后的变量的值，这一点与只读元组变量有很大区别：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">firstCharAndSizeAsConst</span>(<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> [<span style="color:#a6e22e">input</span>[<span style="color:#ae81ff">0</span>], <span style="color:#a6e22e">input</span>.<span style="color:#a6e22e">length</span>] <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">const</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 函数返回的元组立即被解构
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// firstChar的类型是string，size的类型是number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">firstChar</span>, <span style="color:#a6e22e">size</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">firstCharAndSizeAsConst</span>(<span style="color:#e6db74">&#34;Ching Shih&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">firstChar</span>, <span style="color:#a6e22e">size</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 出现编译错误:Cannot assign to &#39;firstChar&#39; because it is a constant.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">firstChar</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;chear&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 函数返回的元组立即被解构  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> [<span style="color:#a6e22e">firstChar1</span>, <span style="color:#a6e22e">size1</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">firstCharAndSizeAsConst</span>(<span style="color:#e6db74">&#34;Ching Shih&#34;</span>);  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">firstChar1</span>, <span style="color:#a6e22e">size1</span>)  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 不会出现编译错误，因为是使用let定义的解构
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">firstChar1</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;chear&#39;</span>
</span></span></code></pre></div><h1 id="interfaces">Interfaces</h1>
<blockquote>
<p>接口是声明具有相关名称对象的另一种方法。<font color="#de7802">接口在许多方面与别名对象类型相似，但由于其错误信息更易读、编译器性能更快以及与类的互操作性更好，通常更受青睐。</font>编译器对接口的可赋值性检查和错误信息的展示与对象类型大致相同。</p>
</blockquote>
<h2 id="type-aliases-versus-interfaces">Type Aliases Versus Interfaces</h2>
<p>下面是定义类型别名描述对象的语法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Poet</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>下面是使用<code>interface</code>声明的等效语法，如同使用<code>type</code>定义对象别名类型一样，<font color="#de7802">既可以使用分号，也可以逗号或换行符来分隔属性</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 可以在定义后面添加分号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Poet</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 定义时属性间既可以使用分号也可以使用逗号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Poet</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">number</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 也可以使用换行符区分属性
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Poet</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">number</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面三种语法基本一致。喜欢使用分号的开发人员<font color="#de7802">通常会将分号放在类型别名定义的右大括号之后，而接口定义之后的右大括号通常不加分号</font>。这种偏好反映了使用<code>;</code>声明变量，不使用<code>;</code>声明类或函数。尽管接口和类型别名相似，但类型别名<code>type</code>和<code>interface</code>有一些关键区别：</p>
<ul>
<li><code>interface</code>可以<code>merge</code>在一起增强，这一特性在使用第三方代码时尤其有用。</li>
<li><font color="#de7802">接口可以用来对<code>class</code>的结构进行类型检查，而类型别名则不能</font>。</li>
<li>对于类型检查程序来说，<span style="background:#ffb78b8c">接口的工作速度通常更快</span>。因为它们声明了一个<code>named</code>类型，可以更容易在内部缓存，而<font color="#de7802">不是像类型别名那样动态复制粘贴一个新的对象字面量。</font></li>
<li>因为<font color="#de7802">接口被认为是<code>named</code>的对象</font>，不是<code>unnamed</code>对象字面量的别名，所以它们的错误信息在某些情况下更具可读性。</li>
</ul>
<h2 id="types-of-properties">Types of Properties</h2>
<h3 id="optional-properties-1">Optional Properties</h3>
<p>与对象类型一样，接口中的属性不一定都是对象的必需属性。可以在接口定义时，在属性类型标注的<code>:</code>前加上<code>?</code>以表示该属性是可选的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Book</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author?</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">ok</span>: <span style="color:#66d9ef">Book</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Rita Dove&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">80</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">missing</span>: <span style="color:#66d9ef">Book</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">80</span>
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>和对象类型以及别名类型定义类似，<font color="#de7802">若接口中属性值的类型是包含了<code>undefined</code>的联合类型，如果在初始化的时候没有为该属性提供初始值，也会出现编译错误</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Book</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author?</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">book</span>: <span style="color:#66d9ef">Book</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Jose&#34;</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">Property</span> <span style="color:#e6db74">&#39;pages&#39;</span> <span style="color:#66d9ef">is</span> <span style="color:#a6e22e">missing</span> <span style="color:#66d9ef">in</span> <span style="color:#66d9ef">type</span> <span style="color:#e6db74">&#39;{ author: string; }&#39;</span> <span style="color:#a6e22e">but</span> <span style="color:#a6e22e">required</span> <span style="color:#66d9ef">in</span> <span style="color:#66d9ef">type</span> <span style="color:#e6db74">&#39;Book&#39;</span>. 
</span></span></code></pre></div><h3 id="read-only-properties">Read-Only Properties</h3>
<p>有时，希望禁止重新赋值接口的某个属性值。允许在接口属性名称前添加一个<code>readonly</code>修饰符，表示该属性一旦设置，就不能再被修改。也就是说<code>readonly</code>属性可以正常读取，但不能被重新赋值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Page</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">readonly</span> <span style="color:#a6e22e">text</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">read</span>(<span style="color:#a6e22e">page</span>: <span style="color:#66d9ef">Page</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Ok: reading the text property doesn&#39;t attempt to modify it
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">page</span>.<span style="color:#a6e22e">text</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 出现编译错误：Cannot assign to &#39;text&#39; because it is a read-only property.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">page</span>.<span style="color:#a6e22e">text</span> <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;!&#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>需要注意的是，修饰符<code>readonly</code><font color=red>只存在于类型系统</font>，编译成<code>JavaScript</code>后，该修饰符会被删除。添加<code>readonly</code>修饰符后，<span style="background:#ffb78b8c">依靠的是类型检查器，它只能防止在开发过程中属性被修改，不能防止在运行过程中被修改</span>。</p>
<h3 id="functions-and-methods">Functions and Methods</h3>
<p>在<code>JavaScript</code>中对象成员为函数比较常见。因此，允许将<code>interface</code>的成员声明为函数类型。<code>TypeScript</code>提供了两种将接口成员声明为函数的方法：</p>
<ul>
<li>方法语法：声明接口成员是一个打算作为对象成员调用的函数，如<code>member(): void</code>。</li>
<li>属性语法：声明接口成员等同于独立函数，如<code>member: () =&gt; void</code>。</li>
</ul>
<p>下面接口<code>HasBothFunctionTypes</code>中声明的<code>method</code>和<code>property</code>都是函数，可以不带实参调用，并返回一个字符串：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">HasBothFunctionTypes</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">method</span>()<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span>;  <span style="color:#75715e">// 方法语法，类似使用function声明函数（去掉关键字function）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">property</span><span style="color:#f92672">:</span> () <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">string</span>; <span style="color:#75715e">// 属性语法，箭头函数声明方式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">hasBoth</span>: <span style="color:#66d9ef">HasBothFunctionTypes</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">property</span><span style="color:#f92672">:</span> () <span style="color:#f92672">=&gt;</span> <span style="color:#e6db74">&#34;&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">method() {</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">hasBoth</span>.<span style="color:#a6e22e">property</span>();
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">hasBoth</span>.<span style="color:#a6e22e">method</span>()
</span></span></code></pre></div><p>上面两种方式声明的函数都支持可选修饰器<code>?</code>，表明它们对于当前定义的接口来说不是必需的成员：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">OptionalFunctions</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">optionalProperty</span><span style="color:#f92672">?:</span> () <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">optionalMethod</span><span style="color:#f92672">?</span>()<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">t1</span>: <span style="color:#66d9ef">OptionalFunctions</span> <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">t2</span>: <span style="color:#66d9ef">OptionalFunctions</span> <span style="color:#f92672">=</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">optionalProperty</span><span style="color:#f92672">:</span>() <span style="color:#f92672">=&gt;</span> {  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&#34;</span>  
</span></span><span style="display:flex;"><span>    },  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">optionalMethod</span>()<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span> {  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&#34;</span>  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>方法和属性声明多数情况下可以互换，它们之间的主要区别如下：</p>
<ul>
<li>方法不能声明为<code>readonly</code>，但属性可以。</li>
<li>同名<font color="#de7802">接口合并时，认为方法和属性是不同的</font>（需要特别注意）。</li>
</ul>
<p><code>TypeScript</code>的未来版本可能会添加某些选项，对方法和属性函数之间的差异进行更严格地区分。目前，推荐按照如下原则：</p>
<ul>
<li>如果知道底层函数可能会引用<code>this</code>，建议使用方法<code>method</code>。</li>
<li>其它情况则建议使用属性。</li>
</ul>
<h3 id="call-signatures">Call Signatures</h3>
<p>接口和对象类型均可以声明<code>call signatures</code>，调用签名是<font color="#de7802">类型系统对值如何像函数一样被调用的描述</font>。只有按照<code>call signatures</code>声明的方式调用的值才可以赋值给<code>interface</code>，即具有可赋值参数和返回类型的函数。</p>
<p>声明<code>call signatures</code>看起来和声明函数类型相似，可以理解为使用<code>function</code>声明函数时去掉<code>function</code>和函数名。下面代码中，变量<code>typedFunctionAlias</code>和<code>typedCallSignature</code>的类型描述了相同的函数参数和返回类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">CallSignature</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 调用签名，相当于接口中函数语法去掉函数名
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    (<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">string</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">FunctionAlias</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">string</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">typedFunctionAlias</span>: <span style="color:#66d9ef">FunctionAlias</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">input</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">input</span>.<span style="color:#a6e22e">length</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">typedCallSignature</span>: <span style="color:#66d9ef">CallSignature</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">input</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">input</span>.<span style="color:#a6e22e">length</span>; <span style="color:#75715e">// Ok
</span></span></span></code></pre></div><p>此外，<code>call signatures</code>可用于<font color="#f79646">描述附加了一些自定义属性的函数</font>。编译器会识别添加到函数声明中的属性，并将其添加到函数声明的类型中。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">FunctionWithCount</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">count</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    ()<span style="color:#f92672">:</span> <span style="color:#66d9ef">void</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">hasCallCount</span>: <span style="color:#66d9ef">FunctionWithCount</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">keepsTrackOfCalls() {</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">keepsTrackOfCalls</span>.<span style="color:#a6e22e">count</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`I&#39;ve been called </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">keepsTrackOfCalls</span>.<span style="color:#a6e22e">count</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> times!`</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">keepsTrackOfCalls</span>.<span style="color:#a6e22e">count</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">hasCallCount</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">keepsTrackOfCalls</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">hasCallCount</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">doesNotHaveCount() {</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;No idea!&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误:Property &#39;count&#39; is missing in type &#39;() =&gt; void&#39; but required in type &#39;FunctionWithCount&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">hasCallCount</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">doesNotHaveCount</span>;
</span></span></code></pre></div><h3 id="index-signatures">Index Signatures</h3>
<p>有些<code>JavaScript</code>项目创建的对象可以使用任意字符串<code>key</code>存储值。对于这种「容器」对象来说，为接口的每一个可能的<code>key</code>声明一个属性是不切实际的。</p>
<p><code>TypeScript</code>提供了一种称为<code>index signature</code>的语法，允许接口接收任意的<code>key</code>，并返回该<code>key</code>对应值的类型。常见的是<code>string</code>类型的<code>key</code>，这是因为<code>JavaScript</code>对象查找属性时会将<code>key</code><font color="#de7802">隐式地转换为字符串</font>。<font color="#de7802">索引签名看起来像普通的属性定义，只是在键后面加上了类型，并用数组中括号将其括起来</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">WordCounts</span> {
</span></span><span style="display:flex;"><span>    [<span style="color:#a6e22e">i</span>: <span style="color:#66d9ef">string</span>]<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">counts</span>: <span style="color:#66d9ef">WordCounts</span> <span style="color:#f92672">=</span> {};
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">counts</span>.<span style="color:#a6e22e">apple</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// Ok 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">counts</span>.<span style="color:#a6e22e">banana</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Type &#39;boolean&#39; is not assignable to type &#39;number&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">counts</span>.<span style="color:#a6e22e">cherry</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span></code></pre></div><p>虽然<span style="background:#ffb78b8c">索引签名便于将值赋值给对象，但并非完全类型安全</span>。因为索引签名表示，<font color="#de7802">无论访问的是什么属性，对象都应该返回一个值</font>，这一点和数组的索引相似。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">DatesByName</span> {
</span></span><span style="display:flex;"><span>    [<span style="color:#a6e22e">i</span>: <span style="color:#66d9ef">string</span>]<span style="color:#f92672">:</span> Date;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">publishDates</span>: <span style="color:#66d9ef">DatesByName</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Frankenstein</span>: <span style="color:#66d9ef">new</span> Date(<span style="color:#e6db74">&#34;1 January 1818&#34;</span>),
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// webStrom中没有提示
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">publishDates</span>.<span style="color:#a6e22e">Frankenstein</span>) <span style="color:#75715e">// Type: Date
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">publishDates</span>.<span style="color:#a6e22e">Frankenstein</span>.<span style="color:#a6e22e">toString</span>());
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">publishDates</span>.<span style="color:#a6e22e">Beloved</span>) <span style="color:#75715e">// undefined
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 运行时错误：Cannot read properties of undefined (reading &#39;toString&#39;)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">publishDates</span>.<span style="color:#a6e22e">Beloved</span>.<span style="color:#a6e22e">toString</span>())
</span></span></code></pre></div><p>如果要存储键值对，并且无法提前知道键的值，通常使用<code>Map</code>更安全。<code>Map</code>的<code>get</code>方法总是返回带有<code>| undefined</code>的类型，<font color="#de7802">表示键可能不存在</font>。</p>
<h4 id="mixing-properties-and-index-signatures">Mixing properties and index signatures</h4>
<p>接口可以包含显式命名属性和<code>catchall string</code>索引签名。但有一个限制：<font color="#de7802">每个显式命名属性的类型必须可以赋值给其<code>catchall</code>索引签名的类型</font>。可以认为将它们混合在一起就是告诉<code>TypeScript</code>，命名的属性会给出一个更具体的类型，而其它属性都会返回索引签名的类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">HistoricalNovels</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 类型不一致，出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Property &#39;Oroonoko&#39; of type &#39;string&#39; is not assignable to &#39;string&#39; index type &#39;number&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">Oroonoko</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    [<span style="color:#a6e22e">i</span>: <span style="color:#66d9ef">string</span>]<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">HistoricalNovels</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Oroonoko</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    [<span style="color:#a6e22e">i</span>: <span style="color:#66d9ef">string</span>]<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">novels</span>: <span style="color:#66d9ef">HistoricalNovels</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Outlander</span>: <span style="color:#66d9ef">2001</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Oroonoko</span>: <span style="color:#66d9ef">1688</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Property &#39;Oroonoko&#39; is missing in type &#39;{ Outlander: number; }&#39; but required in type &#39;HistoricalNovels&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">missingOroonoko</span>: <span style="color:#66d9ef">HistoricalNovels</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Outlander</span>: <span style="color:#66d9ef">2003</span>,
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>使用属性和索引签名的混合的一个常用技巧是为命名属性使用比索引签名的基本类型更具体的字面量类型。只要命名属性的类型可以分配给索引签名的类型&ndash;这对于字面类型和基本类型都是正确。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">ChapterStarts</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">preface</span>: <span style="color:#66d9ef">0</span>;
</span></span><span style="display:flex;"><span>    [<span style="color:#a6e22e">i</span>: <span style="color:#66d9ef">string</span>]<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">correctPreface</span>: <span style="color:#66d9ef">ChapterStarts</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">preface</span>: <span style="color:#66d9ef">0</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">night</span>: <span style="color:#66d9ef">1</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">shopping</span>: <span style="color:#66d9ef">5</span>
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h4 id="numeric-index-signatures">Numeric index signatures</h4>
<p>仅管在<code>JavaScript</code>将对象属性查找键隐式地转换为字符串，但有时只允许将数字作为对象的键也是可取的。<font color="#de7802">索引签名可以使用数字类型代替字符串，但与命名属性一样</font>，它的类型必须可以赋值给<code>catchall</code>字符串索引签名。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">MoreNarrowNumbers</span> {
</span></span><span style="display:flex;"><span>    [<span style="color:#a6e22e">i</span>: <span style="color:#66d9ef">number</span>]<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    [<span style="color:#a6e22e">i</span>: <span style="color:#66d9ef">string</span>]<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">mixesNumbersAndStrings</span>: <span style="color:#66d9ef">MoreNarrowNumbers</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">0</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;&#39;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">key1</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;&#39;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">key2</span>: <span style="color:#66d9ef">undefined</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 下面会出现编译错误，因为数值索引的值类型不能赋值给字符串索引值的类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 因为数值键对应的值类型多了一个undefined类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">MoreNarrowStrings</span> {
</span></span><span style="display:flex;"><span>    [<span style="color:#a6e22e">i</span>: <span style="color:#66d9ef">number</span>]<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Error: &#39;number&#39; index type &#39;string | undefined&#39; // is not assignable to &#39;string&#39; index type &#39;string&#39;. 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    [<span style="color:#a6e22e">i</span>: <span style="color:#66d9ef">string</span>]<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="nested-interfaces">Nested Interfaces</h3>
<p>如同对象类型可以嵌套其它对象类型作为属性值的类型一样，<font color="#de7802">接口类型也可以拥有本身就是接口类型（或对象类型）的属性</font>。下面定义的接口<code>Novel</code>，它的属性<code>setting</code>的值类型是<code>Setting</code>就是接口：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Novel</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span><span style="color:#f92672">:</span> { <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>; };
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">setting</span>: <span style="color:#66d9ef">Setting</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Setting</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">place</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">year</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">myNovel</span>: <span style="color:#66d9ef">Novel</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">myNovel</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;Jane Austen&#39;</span>,
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">setting</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">place</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;England&#39;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">year</span>: <span style="color:#66d9ef">1812</span>,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h2 id="interface-extensions">Interface Extensions</h2>
<p>有时，可能会有多个看起来相似的<code>interface</code>。一个<code>interface</code>可能包含另一个<code>interface</code>的所有成员，只是增加了一些额外的成员。<code>TypeScript</code>允许一个接口<code>extend</code>另一个接口，即<font color="#de7802">声明它复制了另一个接口的所有成员</font>。</p>
<p>可以在接口名后添加<code>extends</code>关键字和待扩展的接口名，以标记当前接口扩展了另一个接口。下面示例代码中，接口<code>Novella</code>扩展了接口<code>Writing</code>，因此要求对象至少同时拥有<code>Novella</code>的<code>pages</code>和<code>Writing</code>的<code>title</code>成员：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Writing</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">title</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Novella</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Writing</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">myNovella</span>: <span style="color:#66d9ef">Novella</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">195</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">title</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Ethan Frome&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Property &#39;pages&#39; is missing in type &#39;{ title: string; }&#39; but required in type &#39;Novella&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">missingPages</span>: <span style="color:#66d9ef">Novella</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">title</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;The Awakening&#34;</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Object literal may only specify known properties, and &#39;strategy&#39; does not exist in type &#39;Novella&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 对象字面量会触发多余属性检查
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">extraProperty</span>: <span style="color:#66d9ef">Novella</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">300</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">strategy</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;baseline&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">style</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Naturalism&#34;</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 使用变量暂存对象字面量规避多余属性检查
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">extraProperty1</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">300</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">strategy</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;baseline&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">style</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Naturalism&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">title</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;test&#34;</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 这样赋值不会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">myNovella</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">extraProperty1</span>
</span></span></code></pre></div><h3 id="overridden-properties">Overridden Properties</h3>
<p>派生接口可以通过<font color="#de7802">再次声明同名的但类型不同的属性来覆盖或替换其基础接口的属性</font>。<span style="background:#ffb78b8c">类型检查器会强制要求覆盖的属性必须可赋值给其基础接口对应的属性</span>，也就是说<code>override</code><strong><font color=red>属性的类型范围只能缩小不能扩大</font></strong>。目的是确保派生接口类型的实例始终可赋值给基础接口类型变量。</p>
<p>实际上，<font color="#de7802">大多数派生接口在重新声明属性时，是为了使得这些属性成为一个联合类型的更具体的子类型</font>，也可能是为了使属性成为一个从基本接口类型扩展而来的类型（通常是扩展多个接口）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">WithNullableName</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">WithNonNullableName</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">WithNullableName</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 类型更具体，是正确的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误，子接口对应属性的类型没有窄化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Interface &#39;WithNumericName&#39; incorrectly extends interface &#39;WithNullableName&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">WithNumericName</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">WithNullableName</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="extending-multiple-interfaces">Extending Multiple Interfaces</h3>
<p><code>TypeScript</code>中的<font color="#de7802">接口定义时可以声明为扩展多个其它接口</font>。即派生接口的<code>extends</code>关键字之后，存在多个用逗号分隔的接口名，派生接口将接收所有基础接口的所有成员。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">GivesNumber</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">giveNumber</span>()<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">GivesString</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">giveString</span>()<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">GivesBothAndEither</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">GivesNumber</span>, <span style="color:#a6e22e">GivesString</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">giveEither</span>()<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">useGivesBoth</span>(<span style="color:#a6e22e">instance</span>: <span style="color:#66d9ef">GivesBothAndEither</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">instance</span>.<span style="color:#a6e22e">giveEither</span>(); <span style="color:#75715e">// Type: number | string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">instance</span>.<span style="color:#a6e22e">giveNumber</span>(); <span style="color:#75715e">// Type: number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">instance</span>.<span style="color:#a6e22e">giveString</span>(); <span style="color:#75715e">// Type: string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>将一个接口标注为扩展多个其它接口，既可以减少代码重复，又可以使对象更容易跨越不同的代码区域重复使用。</p>
<h2 id="interface-merging">Interface Merging</h2>
<p>接口的一个重要特性是可以合并。接口合并意味着，如果<font color="#de7802">在同一作用域中声明了两个名称相同的接口，它们就会合并成一个更大的接口</font>，并在该名称下包含所有声明的字段。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Merged</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fromFirst</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Merged</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fromSecond</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>接口<code>merge</code>在日常开发中并不经常使用，<font color="#de7802">建议尽量避免使用该功能</font>。因为，如果在多个地方声明同一个接口，会使得代码比较难理解和混乱。</p>
<p>但是，<font color="#de7802">接口合并对于增强来自外部包或内置的全局接口（如<code>Window</code>）特别有用</font>。例如，当使用默认的编译器选项时，在一个文件中声明带有<code>myEnvironmentVariable</code>属性的<code>Window</code>接口，就可以使用<code>window.myEnvironmentVariable</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Window</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">myEnvironmentVariable</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>window.<span style="color:#a6e22e">myEnvironmentVariable</span>;
</span></span></code></pre></div><h3 id="member-naming-conflicts">Member Naming Conflicts</h3>
<p>请注意，<font color=red>合并后的接口不能以不同类型多次声明同名的属性</font>。<font color="#548dd4">如果一个接口中已经声明了一个属性，那么以后合并的接口中必须使用相同的类型</font>。但是，<span style="background:#ffb78b8c">合并后的接口可以定义一个名称相同但签名不同的方法</span>，这样做会为该方法创建一个重载。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">MergedMethods</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 名称相同的方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">different</span>(<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">string</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">MergedMethods</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 名称相同的方法，但签名不同
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">different</span>(<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">number</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span>; <span style="color:#75715e">// Ok 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 因为类型相同，下面代码不会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Page</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">readonly</span> <span style="color:#a6e22e">text</span>: <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">read1</span>(<span style="color:#a6e22e">page</span>: <span style="color:#66d9ef">Page</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">page</span>.<span style="color:#a6e22e">text</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Page</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">readonly</span> <span style="color:#a6e22e">text</span>: <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">read2</span>(<span style="color:#a6e22e">page</span>: <span style="color:#66d9ef">Page</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">page</span>.<span style="color:#a6e22e">text</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="classes">Classes</h1>
<h2 id="class-methods">Class Methods</h2>
<p><code>TypeScript</code>对类中方法的理解与对独立函数的理解相同。<font color="#de7802">除非显式地标注类型或给出默认值，否则方法形参的类型被推断为</font><code>any</code>。如果编译设置的是严格模式，形参不允许省略类型标注。</p>
<p>调用类中方法时<font color="#0070c0">需要给出正确的实参数量和正确的类型</font>，否则会出现编译错误。如果函数不是递归的，返回类型通常可以被编译器推断出来。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Greeter</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">greet</span>(<span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">name</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, do your stuff!`</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Greeter</span>().<span style="color:#a6e22e">greet</span>(<span style="color:#e6db74">&#34;Miss Frizzle&#34;</span>) <span style="color:#75715e">// Miss Frizzle, do your stuff!
</span></span></span></code></pre></div><p>类构造函数的形参与其它方法相同。编译器会执行类型检查，<font color="#de7802">以确保调用构造方法时提供了数量正确、类型正确的实参。</font></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Greeted</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>(<span style="color:#a6e22e">message</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`As I always say: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">message</span><span style="color:#e6db74">}</span><span style="color:#e6db74">!`</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Greeted</span>(<span style="color:#e6db74">&#34;take chances, make mistakes, get messy&#34;</span>); 
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">As</span> <span style="color:#a6e22e">I</span> <span style="color:#a6e22e">always</span> <span style="color:#a6e22e">say</span>: <span style="color:#66d9ef">take</span> <span style="color:#a6e22e">chances</span>, <span style="color:#a6e22e">make</span> <span style="color:#a6e22e">mistakes</span>, <span style="color:#66d9ef">get</span> <span style="color:#a6e22e">messy</span><span style="color:#f92672">!</span>
</span></span></code></pre></div><h2 id="class-properties">Class Properties</h2>
<p>在<code>TypeScript</code>中，若要读取或写入类的属性，必须在类中明确声明。类属性声明语法与接口相同，名称后跟一个类型标注。不同于<code>JavaScrpit</code>，<code>TypeScript</code><font color="#de7802">不会试图通过构造函数中的赋值来推断类中可能存在的成员</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FieldTrip</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">destination</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>(<span style="color:#a6e22e">destination</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">destination</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">destination</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`We&#39;re going to </span><span style="color:#e6db74">${</span><span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">destination</span><span style="color:#e6db74">}</span><span style="color:#e6db74">!`</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 编译错误：Property &#39;nonexistent&#39; does not exist on type &#39;FieldTrip&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">nonexistent</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">destination</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>显式地声明类的属性可以让<code>TypeScript</code>快速地了解类的实例中哪些属性是存在的，哪些是不存在的。与<code>JavaScript</code>不同，<font color="#548dd4">若访问类中不存在的属性，会出现编译错误</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FieldTrip</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">destination</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>(<span style="color:#a6e22e">destination</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">destination</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">destination</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`We&#39;re going to </span><span style="color:#e6db74">${</span><span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">destination</span><span style="color:#e6db74">}</span><span style="color:#e6db74">!`</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">trip</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">FieldTrip</span>(<span style="color:#e6db74">&#34;planetarium&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 访问存在的属性，没有问题
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">trip</span>.<span style="color:#a6e22e">destination</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 访问未声明的属性会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Property &#39;nonexistent&#39; does not exist on type &#39;FieldTrip&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">trip</span>.<span style="color:#a6e22e">nonexistent</span>)
</span></span></code></pre></div><h3 id="function-properties">Function Properties</h3>
<p>下面<code>WithMethod</code>类定义了一个<code>myMethod</code>方法，所有<code>WithMethod</code>的实例都可以引用该方法。<strong><font color="#de7802">这种方式定义的方法，不会为每个类的实例创建一个副本</font></strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">WithMethod</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">myMethod() {</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">new</span> <span style="color:#a6e22e">WithMethod</span>().<span style="color:#a6e22e">myMethod</span> <span style="color:#f92672">===</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">WithMethod</span>().<span style="color:#a6e22e">myMethod</span>) 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">true</span>
</span></span></code></pre></div><p>另一种定义方法的语法是声明一个属性，其值恰好是一个函数。<span style="background:#ffb78b8c">这种方式将会为类的每个实例创建一个新函数</span>，这对于箭头函数可能很有用，因为箭头函数的<code>this</code>作用域应始终指向类的当前实例。</p>
<p>下面<code>WithProperty</code>类定义了单个属性<code>myProperty</code>，它的类型为<code>() =&gt; void</code>。<font color="#de7802">每个类的实例都会创建一个新副本</font>，两个不同实例比较该属性时总是返回<code>false</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">WithProperty</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">myProperty</span><span style="color:#f92672">:</span> () <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">myProperty</span> <span style="color:#f92672">=</span> () <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">new</span> <span style="color:#a6e22e">WithProperty</span>().<span style="color:#a6e22e">myProperty</span> <span style="color:#f92672">===</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">WithProperty</span>().<span style="color:#a6e22e">myProperty</span>) 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">false</span>
</span></span></code></pre></div><p>属性函数的形参和返回值类型与独立函数相同:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">WithPropertyParameters</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">takesParameters</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">boolean</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">input</span> <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;Yes&#34;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;No&#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">instance</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">WithPropertyParameters</span>();
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">instance</span>.<span style="color:#a6e22e">takesParameters</span>(<span style="color:#66d9ef">true</span>)) 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">Yes</span>
</span></span></code></pre></div><h3 id="initialization-checking">Initialization Checking</h3>
<p>如果启用了严格的编译器设置，编译器将<font color="#de7802">检查所声明的每个属性</font>（属性值类型不包括<code>undefined</code>的属性）是否在构造函数中赋值。</p>
<p>这种严格初始化检查非常有用，可以防止因意外忘记为相关属性赋值。下面定义的类<code>WithValue</code>，在构造函数中因没有为属性<code>unused</code>赋初始值，会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">WithValue</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">immediate</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">later</span>: <span style="color:#66d9ef">number</span>; <span style="color:#75715e">// Ok (set in the constructor)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 类中的属性值的类型包含了undefined与对象类型和接口类型不同
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">mayBeUndefined</span>: <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>; <span style="color:#75715e">// Ok (allowed to be undefined)，这与Object有区别
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">unused</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">later</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误: Property &#39;unused&#39; has no initializer and is not definitely assigned in the constructor.
</span></span></span></code></pre></div><p>对于<font color=red>类中属性的值类型包含了<code>undefined</code>类型来说，与对象类型以及接口类型有很大区别，在构造函数中可以初始化该属性，也可以不初始化</font>。若没有严格的初始化检查，类实例可能会被允许访问一个可能为<code>undefined</code>的值，即使类型系统规定不能这样做。</p>
<h4 id="definitely-assigned-properties">Definitely assigned properties</h4>
<p>尽管严格的初始检查在多数情况下很有用。但在某些情况下，可能会遇到故意在类构造函数之后取消检查类的某个属性的情况。如果<font color="#de7802">绝对确定某个属性不需要应用严格初始化检查</font>，可以在其名称后添加一个<code>!</code>来禁用属性检查。这样做可以向编译器申明，该属性将在首次使用前一定会被赋值，不会是<code>undefined</code>值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ActivitiesQueue</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pending</span><span style="color:#f92672">!:</span> <span style="color:#66d9ef">string</span>[]; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">initialize</span>(<span style="color:#a6e22e">pending</span>: <span style="color:#66d9ef">string</span>[]) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">pending</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">pending</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">next() {</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">pending</span>.<span style="color:#a6e22e">pop</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">activities</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">ActivitiesQueue</span>();
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">activities</span>.<span style="color:#a6e22e">initialize</span>([<span style="color:#e6db74">&#39;eat&#39;</span>, <span style="color:#e6db74">&#39;sleep&#39;</span>, <span style="color:#e6db74">&#39;learn&#39;</span>])
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">activities</span>.<span style="color:#a6e22e">next</span>();
</span></span></code></pre></div><h2 id="optional-properties-2">Optional Properties</h2>
<p>和接口相似，类也可以声明可选属性。可选属性与属性值类型为包含<code>| undefined</code>的联合类型大致相同。<font color="#de7802">如果没有在构造函数中明确设置可选属性的初始值，严格的初始化检查也不会在意。</font>下面定义的<code>OptionalProperty</code>类中，它的<code>property</code>属性是可选的。因此，无论是否有严格的属性初始化检查，都允许在类的构造函数中不赋值可选属性：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MissingInitializer</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">property?</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 正确的使用方式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">new</span> <span style="color:#a6e22e">MissingInitializer</span>().<span style="color:#a6e22e">property</span><span style="color:#f92672">?</span>.<span style="color:#a6e22e">length</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 错误的使用方式，会出现编译错误：Object is possibly &#39;undefined&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">new</span> <span style="color:#a6e22e">MissingInitializer</span>().<span style="color:#a6e22e">property</span>.<span style="color:#a6e22e">length</span>)
</span></span></code></pre></div><h2 id="read-only-properties-1">Read-Only Properties</h2>
<p>与接口类型，类定义时也可以在属性前面添加<code>readonly</code>关键词。关键词<code>readonly</code>仅存在于类型系统，当编译为<code>JavaScript</code>文件后，关键字<code>readonly</code><font color="#de7802">会被移除</font>。</p>
<p>需要注意的是，<font color=red>声明为只读的属性只能在声明处或构造函数中赋初始值</font>。任何其它位置（包括类本身的其它方法）只能读取属性，不能修改属性（修改属性时会出现编译错误）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Quote</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 只读属性只能在声明处或构造函数中分配初始值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">readonly</span> <span style="color:#a6e22e">text</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>(<span style="color:#a6e22e">text</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">text</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">text</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">emphasize() {</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 编译错误: Cannot assign to &#39;text&#39; because it is a read-only property.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 已经在构造函数中设置了初始值，所以不能再赋值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">text</span> <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;!&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">quote</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Quote</span>(<span style="color:#e6db74">&#34;this is a test&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">quote</span>.<span style="color:#a6e22e">text</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 只读属性不能重新被赋值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">quote</span>.<span style="color:#a6e22e">text</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Hello world&#34;</span>;
</span></span></code></pre></div><p>与其它属性相比，<font color=red>声明为只读且同时初始化为基础类型字面量的属性有一个特性：它们会被推断为其值的字面量类型，而不是对应基本类型</font>，<mark style="background:#ffb78b8c">这样的属性在类构造函数中也不能重新赋值</mark>，这与<code>const</code>断言相似。</p>
<p><code>TypeScript</code>对于这种激进的字面量初始类型窄化感觉良好，因为知道其值以后不会改变。类似于使用<code>const</code>断言定义变量会比<code>let</code>变量使用更窄的类型。下面代码中，在构造函数中变量<code>explicit</code>可以再次被赋值（在其它函数中不能赋值），但<code>implicit</code>不能再次被赋值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">RandomQuote</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 显式声明为string类型，在初始化器中可以被修改
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">readonly</span> <span style="color:#a6e22e">explicit</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Home is the nicest word there is.&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 推断为字面量类型，一旦赋值就不可修改
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">readonly</span> <span style="color:#a6e22e">implicit</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Home is the nicest word there is.&#34;</span>;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 非字面量类型，在初始化器中可以赋值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">explicit</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;We start learning the minute we&#39;re born.&#34;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 没有显式标注类型，并使用字面量进行初始化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// 即使在构造函数中重新赋值也会出现编译错误，因为已经初始化一次了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">implicit</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;We start learning the minute we&#39;re born.&#34;</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">Type</span> <span style="color:#e6db74">&#39;&#34;We start learning the minute we&#39;</span><span style="color:#a6e22e">re</span> <span style="color:#a6e22e">born</span>.<span style="color:#e6db74">&#34;&#39; is not assignable to type &#39;&#34;</span><span style="color:#a6e22e">Home</span> <span style="color:#66d9ef">is</span> <span style="color:#a6e22e">the</span> <span style="color:#a6e22e">nicest</span> <span style="color:#a6e22e">word</span> <span style="color:#a6e22e">there</span> <span style="color:#66d9ef">is</span>.<span style="color:#960050;background-color:#1e0010">&#34;&#39;</span>.
</span></span></code></pre></div><h2 id="classes-as-types">Classes as Types</h2>
<p>类在类型系统中相对独特，因为类声明既创建了运行时值（类本身），也创建了可用于类型标注的类型。下面示例代码中，类<code>Teacher</code>用于标注变量<code>teacher</code>，以告诉编译器它应该只能被那些能够赋值给<code>Teacher</code>类的值（例如<code>Teacher</code>类的实例）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Teacher</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sayHello() {</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Take chances, make mistakes, get messy!&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">teacher</span>: <span style="color:#66d9ef">Teacher</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">teacher</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Teacher</span>()
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">teacher</span>.<span style="color:#a6e22e">sayHello</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Type &#39;string&#39; is not assignable to type &#39;Teacher&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">tearcher</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Wahoo!&#34;</span>
</span></span></code></pre></div><p>有趣的是，<code>TypeScript</code>会<font color="#de7802">将任何恰好包含当前类中所有相同成员的对象类型视为可赋值给当前类</font>。这是因为<code>TypeScript</code>中的<code>structural typing</code><span style="background:#ffb78b8c">只关心对象的形状，而不关心它们是如何声明的</span>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SchoolBus</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">getAbilities() {</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> [<span style="color:#e6db74">&#34;magic&#34;</span>, <span style="color:#e6db74">&#34;shapeshifting&#34;</span>];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">withSchoolBus</span>(<span style="color:#a6e22e">bus</span>: <span style="color:#66d9ef">SchoolBus</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">bus</span>.<span style="color:#a6e22e">getAbilities</span>());
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">withSchoolBus</span>(<span style="color:#66d9ef">new</span> <span style="color:#a6e22e">SchoolBus</span>());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 下面这种调用方式也是可以的，因为类也是structural typing的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">withSchoolBus</span>({
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">getAbilities</span><span style="color:#f92672">:</span> () <span style="color:#f92672">=&gt;</span> [<span style="color:#e6db74">&#34;transmogrification&#34;</span>]
</span></span><span style="display:flex;"><span>})
</span></span></code></pre></div><h2 id="classes-and-interfaces">Classes and Interfaces</h2>
<p><code>TypeScript</code>允许在定义类时的名字后添加<code>implements</code>关键字和接口名称，从而声明当前类遵循某个<code>interface</code>。这样声明是向编译器申明，<span style="background:#ffb78b8c">类的实例可以赋值给这些接口中的任何一个</span>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Learner</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">study</span>(<span style="color:#a6e22e">hours</span>: <span style="color:#66d9ef">number</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">void</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Student</span> <span style="color:#66d9ef">implements</span> <span style="color:#a6e22e">Learner</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>(<span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">name</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">study</span>(<span style="color:#a6e22e">hours</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">hours</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;...studying...&#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">leaner</span>: <span style="color:#66d9ef">Learner</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Student</span>(<span style="color:#e6db74">&#34;Hui&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">leaner</span>.<span style="color:#a6e22e">study</span>(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>...<span style="color:#a6e22e">studying</span>...
</span></span><span style="display:flex;"><span>...<span style="color:#a6e22e">studying</span>...
</span></span></code></pre></div><p>将一个类标记为实现了某个接口并不会改变该类的使用方式。如果该类与某个接口相匹配，<code>TypeScript</code>的类型检查器允许<font color="#de7802">在需要该接口实例的地方使用该类的实例</font>。</p>
<h3 id="implementing-multiple-interfaces">Implementing Multiple Interfaces</h3>
<p>在<code>TypeScript</code>中<font color="#de7802">一个类可以实现任意多个接口，接口名称之间用逗号隔开</font>。下面示例代码中，类在实现接口<code>Graded</code>时必需具有<code>grades</code>属性，在实现接口<code>Reporter</code>时必需具有<code>report</code>属性（是一个箭头函数）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Graded</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">grades</span>: <span style="color:#66d9ef">number</span>[];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Reporter</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">report</span><span style="color:#f92672">:</span> () <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 下面类ReportCard是正常的，因为实现了grades和report
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ReportCard</span> <span style="color:#66d9ef">implements</span> <span style="color:#a6e22e">Graded</span>, <span style="color:#a6e22e">Reporter</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">grades</span>: <span style="color:#66d9ef">number</span>[];
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>(<span style="color:#a6e22e">grades</span>: <span style="color:#66d9ef">number</span>[]) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">grades</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">grades</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">report() {</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">grades</span>.<span style="color:#a6e22e">join</span>(<span style="color:#e6db74">&#34;, &#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 下面会出现编译错误，因为Empty没有真正实现接口
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 如果实现了接口，需要把所有的属性和接口都生成一遍
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Empty</span> <span style="color:#66d9ef">implements</span> <span style="color:#a6e22e">Graded</span>, <span style="color:#a6e22e">Reporter</span> {
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">// 没有任何实现
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h2 id="extending-a-class">Extending a Class</h2>
<p><code>TypeScript</code>将类型检查也添加到了<code>JavaScript</code>的类扩展（或子类）概念中。首先，基类中声明的任何非私有方法或属性都可以在子类（也称为派生类）中使用。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Teacher</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">teach() {</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;The surest test of discipline is its absence.&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">StudentTeacher</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Teacher</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">learn() {</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;I cannot afford the luxury of a closed mind.&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">teacher</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">StudentTeacher</span>();
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">teacher</span>.<span style="color:#a6e22e">teach</span>(); <span style="color:#75715e">// Ok (defined on base)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">teacher</span>.<span style="color:#a6e22e">learn</span>(); <span style="color:#75715e">// Ok (defined on subclass)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 出现编译错误：Property &#39;other&#39; does not exist on type &#39;StudentTeacher&#39;. 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">teacher</span>.<span style="color:#a6e22e">other</span>();
</span></span></code></pre></div><h3 id="extension-assignability">Extension Assignability</h3>
<p>子类从父类中继承成员如同子接口扩展父接口，子类的实例拥有父类的所有成员，因此可以在需要父类实例的地方使用。如果父类不具备子类的所有成员，那么当需要更具体的子类时，就无法使用它。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Lesson</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">subject</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>(<span style="color:#a6e22e">subject</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">subject</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">subject</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">OnlineLesson</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Lesson</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">url</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>(<span style="color:#a6e22e">subject</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">url</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">super</span>(<span style="color:#a6e22e">subject</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">url</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">url</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">lesson</span>: <span style="color:#66d9ef">Lesson</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">lesson</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Lesson</span>(<span style="color:#e6db74">&#34;coding&#34;</span>); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">lesson</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">OnlineLesson</span>(<span style="color:#e6db74">&#34;coding&#34;</span>, <span style="color:#e6db74">&#34;oreilly.com&#34;</span>); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">online</span>: <span style="color:#66d9ef">OnlineLesson</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">online</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">OnlineLesson</span>(<span style="color:#e6db74">&#34;coding&#34;</span>, <span style="color:#e6db74">&#34;oreilly.com&#34;</span>); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Property &#39;url&#39; is missing in type &#39;Lesson&#39; but required in type &#39;OnlineLesson&#39;. 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 因为是结构类型，父类中缺少子类中的成员url
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">online</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Lesson</span>(<span style="color:#e6db74">&#34;coding&#34;</span>);
</span></span></code></pre></div><p>根据结构类型的特点，<font color="#de7802">如果子类上的所有成员都已经存在于父类中（例如子类的自定义属性均是可选的），那么允许使用父类的实例来代替子类</font>。下面示例中，因为子类唯一自定义的属性是可选类型，所以赋值是允许的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">PastGrades</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">grades</span>: <span style="color:#66d9ef">number</span>[] <span style="color:#f92672">=</span> [];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LabeledPastGrades</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">PastGrades</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">label?</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">subClass</span>: <span style="color:#66d9ef">LabeledPastGrades</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">subClass</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">LabeledPastGrades</span>(); <span style="color:#75715e">// Ok 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 因为子类扩展父类时，其自定义属性时可选的，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 所以父类相当于拥有子类的所有属性
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">subClass</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">PastGrades</span>(); <span style="color:#75715e">// Ok
</span></span></span></code></pre></div><h3 id="overridden-constructors">Overridden Constructors</h3>
<p>与<code>JavaScript</code>一样，<code>TypeScript</code>并<font color="#de7802">不要求子类必须定义自己的构造函数</font>。<strong>没有自定义构造函数的子类会隐式地使用父类的构造函数</strong>。在<code>JavaScript</code>中，如果<font color=red>子类声明了自己的构造函数，必须通过<code>super</code>关键字调用父类的构造函数</font>。</p>
<p>子类构造函数可以声明任何形参，而无需考虑父类构造函数的要求。因为<code>TypeScript</code>的类型检查器会确保调用父类构造函数时使用了正确的参数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">GradeAnnouncer</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">message</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>(<span style="color:#a6e22e">grade</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">message</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">grade</span> <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">65</span> <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;Maybe next time...&#34;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;You pass!&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">PassingAnnouncer</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">GradeAnnouncer</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 子类中定义了自己的构造函数，所以必须使用super调用父类的构造函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">super</span>(<span style="color:#ae81ff">100</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>根据<code>JavaScript</code>的规则，<strong><font color=red>子类的构造器在使用<code>this</code>或<code>super</code>之前必须调用父类的构造器</font></strong>。若在调用父类的构造函数之前使用<code>this</code>或<code>super</code>会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">GradesTally</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">grades</span>: <span style="color:#66d9ef">number</span>[] <span style="color:#f92672">=</span> [];
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">addGrades</span>(...<span style="color:#a6e22e">grades</span>: <span style="color:#66d9ef">number</span>[]) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">grades</span>.<span style="color:#a6e22e">push</span>(...<span style="color:#a6e22e">grades</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">grades</span>.<span style="color:#a6e22e">length</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ContinuedGradesTally</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">GradesTally</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>(<span style="color:#a6e22e">previousGrades</span>: <span style="color:#66d9ef">number</span>[]) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 在使用this之前需要调用父类的构造函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">grades</span> <span style="color:#f92672">=</span> [...<span style="color:#a6e22e">previousGrades</span>];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">Constructors</span> <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">derived</span> <span style="color:#a6e22e">classes</span> <span style="color:#a6e22e">must</span> <span style="color:#a6e22e">contain</span> <span style="color:#a6e22e">a</span> <span style="color:#e6db74">&#39;super&#39;</span> <span style="color:#a6e22e">call</span>. 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 下面这样先调用基类的构造函数才不会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ContinuedGradesTally</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">GradesTally</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>(<span style="color:#a6e22e">previousGrades</span>: <span style="color:#66d9ef">number</span>[]) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">super</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 展开操作符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">grades</span> <span style="color:#f92672">=</span> [...<span style="color:#a6e22e">previousGrades</span>];
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Starting with length&#34;</span>, <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">grades</span>.<span style="color:#a6e22e">length</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="overridden-methods">Overridden Methods</h3>
<blockquote>
<p><code>TypeScript</code>有一套基于结构类型的系统，判断类型兼容性时，会比较两个类型的结构。当涉及到函数时，<font color="#de7802">函数参数是逆变的，而返回值是协变的</font>。</p>
</blockquote>
<p><code>TypeScript</code>中的「协变」和「逆变」是描述父子类型在复杂类型（如函数、数组）中如何传递的规则。可以使用生活中的例子比喻：</p>
<ul>
<li><strong>协变</strong>：买了一个装苹果的箱子（<code>Apple[]</code>），可以当作装水果的箱子（<code>Fruit[]</code>）用，因为苹果是水果的子类型。</li>
<li><strong>逆变</strong>：要求一个能处理所有水果的机器（参数是<code>Fruit</code>），可以替换成只能处理苹果的机器（参数是<code>Apple</code>），但反过来可能不安全。</li>
</ul>
<p>通俗的理解，协变是子类型可以替代父类型，方向一致，<font color="#de7802">常见场景是函数返回值、数组、对象属性</font>。函数返回值类型是<strong>协变的</strong>。如果<code>B</code>是<code>A</code>的子类型，则返回值类型为<code>B</code>的函数可以赋值给返回值类型为<code>A</code>的函数变量。换句话说，函数的返回类型关系保持一致。</p>
<p>为什么需要协变？返回值类型的协变是安全的。如果<font color="#de7802">函数返回一个更具体的子类型</font>，它可以安全替代返回<strong>更宽泛父类型</strong>的函数。</p>
<p>下面示例代码中，因为<code>Dog</code>是<code>Animal</code>的子类型，返回<code>Dog</code>的函数可以替代返回<code>Animal</code>的函数。调用函数<code>getAnimal()</code>时，实际得到的是<code>Dog</code>，但使用者只关心父接口<code>Animal</code>的属性和方法，因此是安全的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Animal</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>  
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Dog</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Animal</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">bark</span>()<span style="color:#f92672">:</span> <span style="color:#66d9ef">void</span>  
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 协变示例：Dog是Animal的子类型，返回值类型是协变的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">getAnimal</span><span style="color:#f92672">:</span> () <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">Animal</span> <span style="color:#f92672">=</span> () <span style="color:#f92672">=&gt;</span> ({<span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;动物&#34;</span>}); 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">getDog</span><span style="color:#f92672">:</span> () <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">Dog</span> <span style="color:#f92672">=</span> () <span style="color:#f92672">=&gt;</span> ({<span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;旺财&#34;</span>, <span style="color:#a6e22e">bark</span><span style="color:#f92672">:</span> () <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;汪汪！&#34;</span>)});  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 安全：将返回Dog的函数赋值给返回Animal的函数类型  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">getAnimal</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">getDog</span>; <span style="color:#75715e">// ✅ 允许（协变）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">animal</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">getAnimal</span>()
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">animal</span>.<span style="color:#a6e22e">name</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#960050;background-color:#1e0010">旺财</span>
</span></span></code></pre></div><p>逆变是父类型可以替代子类型，方向相反，常见场景是函数参数。如果<code>B</code>是<code>A</code>的子类型，则参数类型为<code>A</code>的函数是参数类型为<code>B</code>的函数的子类型。换句话说，<font color="#de7802">函数参数的子类型关系是反向的</font>。</p>
<p>为什么需要逆变？是为了保证类型安全。如果一个函数期望接收一个<strong>更宽泛的类型</strong>（例如<code>Animal</code>），它可以安全地替换一个需要<strong>更具体类型</strong>（例如<code>Dog</code>）的函数。</p>
<p>下面示例代码中，当<code>FeedAnimal</code>（参数为父类型）赋值给<code>FeedDog</code>（参数为子类型）时，实际调用<code>feedDog(new Dog())</code>时，函数内部会以<code>Animal</code>类型处理参数。由于<code>Dog</code>具备<code>Animal</code>的所有属性，所以是安全的。反之，在函数中可能访问子类型的独有属性（如<code>bark</code>），导致运行时错误（实际类型是父类型的实例）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">FeedAnimal</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">animal</span>: <span style="color:#66d9ef">Animal</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">void</span>;  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">FeedDog</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">dog</span>: <span style="color:#66d9ef">Dog</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">void</span>;  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 逆变示例：FeedAnimal是FeedDog 的子类型  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">feedAnimal</span>: <span style="color:#66d9ef">FeedAnimal</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">animal</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`喂养 </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">animal</span>.<span style="color:#a6e22e">name</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">feedDog</span>: <span style="color:#66d9ef">FeedDog</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">dog</span>) <span style="color:#f92672">=&gt;</span> { <span style="color:#a6e22e">dog</span>.<span style="color:#a6e22e">bark</span>(); };  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 安全：将父类型函数赋值给子类型变量 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 实际调用是的FeedAnimal类型的实例
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">feedDog</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">feedAnimal</span>; <span style="color:#75715e">// ✅ 允许（逆变）  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 危险：将子类型函数赋值给父类型变量（需要关闭strictFunctionTypes）  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// feedAnimal = feedDog; // ❌ 默认报错（除非关闭严格模式）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 下面方式使用会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// feedDog({name: &#34;1233&#34;});
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 这样调用才可以
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">feedDog</span>({  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;1233&#34;</span>,  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">bark</span><span style="color:#f92672">:</span> () <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;汪汪！&#34;</span>)  
</span></span><span style="display:flex;"><span>})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果，实际调用的是feedAnimal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#960050;background-color:#1e0010">喂养</span> <span style="color:#ae81ff">1233</span>
</span></span></code></pre></div><p>子类<font color="#de7802">可以重新声明与父类同名的新方法，只要子类上的方法可以赋值给父类对应的方法即可</font>，即只要满足子类中同名的新方法中的参数类型是父类型，或者返回类型是子类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">GradeCounter</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">countGrades</span>(<span style="color:#a6e22e">grades</span>: <span style="color:#66d9ef">string</span>[], <span style="color:#a6e22e">letter</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">grades</span>.<span style="color:#a6e22e">filter</span>(<span style="color:#a6e22e">grade</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">grade</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">letter</span>).<span style="color:#a6e22e">length</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FailureCounter</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">GradeCounter</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">countGrades</span>(<span style="color:#a6e22e">grades</span>: <span style="color:#66d9ef">string</span>[]) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">super</span>.<span style="color:#a6e22e">countGrades</span>(<span style="color:#a6e22e">grades</span>, <span style="color:#e6db74">&#34;F&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 上面声明FailureCounter时不会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 到下面声明AnyFailureChecker会出现编译错误，因为返回值类型不同
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AnyFailureChecker</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">GradeCounter</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">countGrades</span>(<span style="color:#a6e22e">grades</span>: <span style="color:#66d9ef">string</span>[]) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 返回类型是bool，不是number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">super</span>.<span style="color:#a6e22e">countGrades</span>(<span style="color:#a6e22e">grades</span>, <span style="color:#e6db74">&#34;F&#34;</span>) <span style="color:#f92672">!==</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">Property</span> <span style="color:#e6db74">&#39;countGrades&#39;</span> <span style="color:#66d9ef">in</span> <span style="color:#66d9ef">type</span> <span style="color:#e6db74">&#39;AnyFailureChecker&#39;</span> <span style="color:#66d9ef">is</span> <span style="color:#a6e22e">not</span> <span style="color:#a6e22e">assignable</span> <span style="color:#a6e22e">to</span> <span style="color:#a6e22e">the</span> <span style="color:#a6e22e">same</span> <span style="color:#a6e22e">property</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">base</span> <span style="color:#66d9ef">type</span> <span style="color:#e6db74">&#39;GradeCounter&#39;</span>. 
</span></span></code></pre></div><p>因为<font color="#de7802">较少参数的函数类型是可以赋值给多参数的同类型函数</font>。<strong>参数少的函数可以赋值给参数多的函数类型</strong>（即参数多的兼容参数少的）。这是因为：</p>
<ol>
<li>
<p><strong>调用时的参数冗余不会导致错误</strong>，当一个函数（参数少）被赋值给另一个参数更多的函数类型时，实际调用时多余的参数会被忽略。例如，参数多的函数可能接受3个参数，但实际调用的函数（参数少）只用到了前2个，此时不会引发运行时错误。</p>
</li>
<li>
<p><strong>适配JavaScript常见模式</strong>，在<code>JavaScript</code>中，开发者经常忽略不用的参数（例如<font color="#de7802">回调函数仅使用部分参数</font>），<code>TypeScript</code>的设计需要兼容这种习惯。</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 基础参数数量兼容
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">name11</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">number</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">name12</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">number</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">name11</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">number</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">name12</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">name11</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">name12</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 数组的`forEach`方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">arr</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;a&#34;</span>, <span style="color:#e6db74">&#34;b&#34;</span>, <span style="color:#e6db74">&#34;c&#34;</span>];  
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 回调函数类型：(value: string, index: number, array: string[]) =&gt; void  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">arr</span>.<span style="color:#a6e22e">forEach</span>((<span style="color:#a6e22e">value</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">value</span>)); <span style="color:#75715e">// ✅ 忽略 index 和 array 参数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 这里，参数少的回调函数（只接受`value`）可以赋值给参数多的函数类型，因为多余的参数（`index`和`array`）不会被使用
</span></span></span></code></pre></div><p>这种设计有助于实现多态，<font color=red>子类减少不必要的参数，往往意味着它简化或者特化了父类的逻辑</font>，这在很多场景下是合理的编程需求。比如，父类的某个方法为了通用性设计了很多配置相关的参数，子类在特定场景下复用该方法时，一些参数固定不变，所以子类就省略了这些固定不变的参数，让代码更加简洁，同时又能融入基于父类构建的多态调用体系。</p>
<h3 id="overridden-properties-1">Overridden Properties</h3>
<p>子类也可能显式地重新声明父类的同名属性，<font color="#de7802">只要子类同名属性的类型可以赋值给父类上的类型即可（类似于协变）</font>。与重载方法一样，<font color=red>子类必须在结构上与父类相匹配</font>。</p>
<p>大多数重新声明属性的子类，要么是为了使这些属性成为联合类型更具体的子类型（通常是联合类型的子类型），要么是为了<font color="#de7802">使这些属性成为一种从基类属性类型扩展而来的类型</font>（添加自定义属性）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Assignment</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">grade?</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">GradedAssignment</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Assignment</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">grade</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>(<span style="color:#a6e22e">grade</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">super</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">grade</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">grade</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>假设基类有一个属性，它的类型是<code>Animal</code>，在子类里重新声明这个属性，把该属性的类型改成<code>Dog</code>（假设<code>Dog</code>是从<code>Animal</code>继承或扩展而来的类型，也就是<code>class Dog extends Animal</code>），<font color="#de7802">子类的属性类型就是对基类属性类型的扩展</font>，在保持继承体系的同时，<font color=red>还可以添加子类特有的属性或方法，增强代码的复用性与扩展性</font>。这种方式遵循了面向对象编程中的继承原则，在类型层面强化了类之间的层次关系，同时借助<code>TypeScript</code>的类型系统保障类型一致性。</p>
<h2 id="abstract-classes">Abstract Classes</h2>
<p>有时，创建的基类本身并不声明某些方法的实现，而是期望子类实现这些方法。将一个类标记为抽象类的方法是在类名前面和任何抽象方法前面添加<code>abstract</code>关键字。这些抽象方法声明跳过了在抽象基类中提供方法体的过程，它们的声明方式与接口相同。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">School</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">readonly</span> <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>(<span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">name</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">abstract</span> <span style="color:#a6e22e">getStudentTypes</span>()<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span>[];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Preschool</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">School</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">getStudentTypes() {</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> [<span style="color:#e6db74">&#34;preschooler&#34;</span>];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>需要注意的是，抽象类不能实例化，非抽象类才能被实例化。</p>
<h2 id="member-visibility">Member Visibility</h2>
<p><code>JavaScript</code>可以在类的成员名称前加上<code>#</code>，将其标记为<code>private</code>成员。私有类成员只能被该类的实例访问。若类外的代码试图访问私有方法或属性，<code>JavaScript</code>运行时会抛出错误，以强制执行这种私有性。</p>
<p><code>TypeScript</code>对类的可见性的支持早于<code>JavaScript</code>，在<code>TypeScript</code>不仅支持<code>#</code>形式的私有类成员，也允许对类方法和属性（仅存在于类型系统中）的隐私性定义进行细微的调整。<code>TypeScript</code>中成员可见性是通过在类成员声明的名称前添加以下关键字来实现的：</p>
<ul>
<li><code>public</code>(默认的)：允许在任何地方使用，这是默认的可见性（若不添加任何关键词默认是该可见性）。</li>
<li><code>protected</code>: 只允许在类本身或其子类中使用。</li>
<li><code>private</code>：只允许在类里面使用。</li>
</ul>
<p>需要注意的是，<font color="#de7802">上面的关键字仅存在于类型系统，当代码编译为<code>JavaScript</code>后，这些关键词就会被移除</font>。下面示例代码中，类<code>Base</code>声明了两个<code>public</code>成员，一个<code>protected</code>成员，一个<code>private</code>成员，一个<code>#</code>表示的私有成员：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 默认是public的访问权限
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">isPublicImplicit</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">isPublicExplicit</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">protected</span> <span style="color:#a6e22e">isProtected</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#a6e22e">isPrivate</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#a6e22e">truePrivate</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Subclass</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Base</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">examples() {</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">isPublicImplicit</span>; <span style="color:#75715e">// Ok 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">isPublicExplicit</span>; <span style="color:#75715e">// Ok 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">isProtected</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// this.isPrivate;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// this.#truePrivate;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Subclass</span>().<span style="color:#a6e22e">isPublicImplicit</span>; <span style="color:#75715e">// Ok 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Subclass</span>().<span style="color:#a6e22e">isPublicExplicit</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Property &#39;isProtected&#39; is protected and only accessible within class &#39;Base&#39; and its subclasses.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Subclass</span>().<span style="color:#a6e22e">isProtected</span>;
</span></span></code></pre></div><h3 id="static-field-modifiers">Static Field Modifiers</h3>
<p><code>JavaScript</code>允许使用<code>static</code>关键字声明类本身的成员（而非类的实例）。<code>TypeScript</code>支持单独使用<code>static</code>关键字，也支持将它与<code>readonly</code>一起使用，或者和可见性关键字（比如<code>public</code>、<code>private</code>、<code>protected</code>等）中的某一个一起使用。</p>
<p>但需要注意的是，当组合使用这些关键字时，<font color="#de7802">可见性关键字要放在首位，接着是<code>static</code>关键字，最后才是<code>readonly</code>关键字</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Question</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// &#39;protected&#39; modifier must precede &#39;static&#39; modifier.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// static protected readonly name: string = &#34;Test&#34;;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> <span style="color:#a6e22e">answer</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;bash&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> <span style="color:#a6e22e">prompt</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;What&#39;s an ogre&#39;s favorite programming language?&#34;</span>;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">guess</span>(<span style="color:#a6e22e">getAnswer</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">prompt</span>: <span style="color:#66d9ef">string</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">answer</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">getAnswer</span>(<span style="color:#a6e22e">Question</span>.<span style="color:#a6e22e">prompt</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">answer</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">Question</span>.<span style="color:#a6e22e">answer</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;You got it!&#34;</span>);
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Try again...&#34;</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">Question</span>.<span style="color:#a6e22e">answer</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">question</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Question</span>()  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">question</span>.<span style="color:#a6e22e">guess</span>((<span style="color:#a6e22e">prompt</span>: <span style="color:#66d9ef">string</span>) <span style="color:#f92672">=&gt;</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">prompt</span>;  
</span></span><span style="display:flex;"><span>})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">Try</span> <span style="color:#a6e22e">again</span>...
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">undefined</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：保护成员只能在类中或子类中使用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">Question</span>.<span style="color:#a6e22e">answer</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Test</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 不能添加readonly关键字而不初始化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#a6e22e">answer</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;bash&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 在静态构造器中初始化静态成员
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">Test</span>.<span style="color:#a6e22e">answer</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;bash&#39;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Test</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> <span style="color:#a6e22e">answer</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;bash&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 因为没有初始化，所以执行结果为undefined
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">Test</span>.<span style="color:#a6e22e">answer</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="type-modifiers">Type Modifiers</h1>
<p>现在，已经了解<code>TypeScript</code>类型系统如何与现有<code>JavaScript</code>结构（如数组、类和对象）协同工作，接下来将进一步介绍类型系统本身。</p>
<h2 id="top-types">Top Types</h2>
<p>在<code>TypeScript</code>中<font color=red>顶层类型或通用类型是一种可以代表类型系统中任何可能值的类型</font>。所有类型的值都可以赋值给顶层类型的变量或常量，但相反时不一定正确，因为顶层类型区分<code>any</code>和<code>unknwon</code>。</p>
<h3 id="any">any</h3>
<p><code>any</code>类型可以作为顶层类型，<font color="#de7802">表示没有任何限制，该类型的变量可以被赋予任意类型的值</font>。类型<code>any</code>可用于允许接受任何类型的地方，例如作为<code>console.log</code>的参数:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">anyValue</span>: <span style="color:#66d9ef">any</span>;  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">anyValue</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Lucille Ball&#34;</span>; <span style="color:#75715e">// Ok  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">anyValue</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">123</span>; <span style="color:#75715e">// Ok  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">anyValue</span>); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">anyValue</span>); <span style="color:#75715e">// number
</span></span></span></code></pre></div><p>使用<code>any</code>就是<font color="#de7802">明确告诉编译器不需要执行类型检查</font>。这种类型检查的缺失有时会有用，但有时也会触发异常。例如，下面代码不会出现编译错误，但运行时会报错：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">greetComedian</span>(<span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">any</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 此时无编译错误，但传入不能调用toUpperCase方法实参时会出现运行时错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Announcing </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">name</span>.<span style="color:#a6e22e">toUpperCase</span>()<span style="color:#e6db74">}</span><span style="color:#e6db74">!`</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 运行正常
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">greetComedian</span>(<span style="color:#e6db74">&#34;Bea Arthur&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 运行时错误: name.toUpperCase is not a function
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">greetComedian</span>(<span style="color:#ae81ff">123</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">any</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;hello&#39;</span>;  
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译不报错，但运行时会报错  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">x</span>(<span style="color:#ae81ff">1</span>) 
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译不报错，但运行时会报错
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">x</span>.<span style="color:#a6e22e">foo</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>; 
</span></span></code></pre></div><p>因为上面这些原因，应当尽量避免使用<code>any</code>类型。从集合论的角度看，<code>any</code>类型可以看成是所有其它类型的全集，包含了一切可能的类型。这种类型被称为<code>Top Type</code>，涵盖了所有下层类型。</p>
<p>类型<code>any</code>除了关闭类型检查，还有一个很大的问题，<font color=red>就是它会「污染」其它变量</font>。因为，<font color="#de7802">any类型变量可以赋值给其他任何类型的变量（没有类型检查），导致其它变量跟着出错</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">any</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;hello&#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">number</span>;  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">y</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">x</span>; <span style="color:#75715e">// 不报错，因为编译器不会检查x的类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">y</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">123</span> <span style="color:#75715e">// 告诉编译器y也不需要类型检查，因此也不会报错，运行时返回的是NaN
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 因为一直认为y是number类型，所以编译时不报错
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 运行时报错：y.toFixed is not a function
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">y</span>.<span style="color:#a6e22e">toFixed</span>() 
</span></span></code></pre></div><h3 id="unknown">unknown</h3>
<p>为了解决<code>any</code>类型污染其它类型的问题，引入了<code>unknown</code>类型，<font color="#de7802">它是一种真正的顶层类型</font>。类型<code>unknown</code>和<code>any</code>类似，所有对象都可以赋值给标注为<code>unknown</code>类型的变量。类型<code>any</code>与<code>unknown</code>的主要区别在于，<code>TypeScript</code>对<code>unknown</code>类型的值有更严格的限制：</p>
<ul>
<li><font color=red>不允许直接访问</font><code>unkonwn</code>类型值的方法和属性，需要先转换为特定类型后才能使用相关方法或属性。</li>
<li>类型为<code>unknown</code>的变量不可赋值给非顶级类型（即非<code>any</code>或<code>unknown</code>）变量。</li>
</ul>
<p>如果直接访问类型为<code>unknown</code>类型值的属性，会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">greetComedian</span>(<span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">unknown</span>) {  
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 不能直接访问unknown类型变量的方法或属性
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Announcing </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">name</span>.<span style="color:#a6e22e">toUpperCase</span>()<span style="color:#e6db74">}</span><span style="color:#e6db74">!`</span>);  
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：&#39;name&#39; is of type &#39;unknown&#39;.
</span></span></span></code></pre></div><p>允许在代码中访问<code>unknwon</code>类型值的<font color="#de7802">唯一方法是窄化值的类型范围</font>。例如，使用<code>instanceof</code>或<code>typeof</code>或使用类型断言。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">greetComedianSafety</span>(<span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">unknown</span>) {  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">name</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;string&#39;</span>) {  
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Announcing </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">name</span>.<span style="color:#a6e22e">toUpperCase</span>()<span style="color:#e6db74">}</span><span style="color:#e6db74">!`</span>); <span style="color:#75715e">// Ok  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    } <span style="color:#66d9ef">else</span> {  
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Well, I&#39;m off.&#34;</span>);  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">greetComedianSafety</span>(<span style="color:#e6db74">&#34;Betty White&#34;</span>); 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">greetComedianSafety</span>({}); 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Announcing BETTY WHITE!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Well, I&#39;m off.
</span></span></span></code></pre></div><h2 id="type-predicates">Type Predicates</h2>
<p>使用<code>instanceof</code>和<code>typeof</code>，可以窄化类型范围。对于<font color="#de7802">直接使用有限检查集窄化类型来说，这一切都很好</font>。如果用函数来包装类型窄化逻辑，会使得原来的窄化失去作用。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 将窄化封装成函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">isNumberOrString</span>(<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">unknown</span>) {  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> [<span style="color:#e6db74">&#39;number&#39;</span>, <span style="color:#e6db74">&#39;string&#39;</span>].<span style="color:#a6e22e">includes</span>(<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">value</span>);  
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">logValueIfExists</span>(<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>) {  
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Type of value: number | string | null | undefined  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">isNumberOrString</span>(<span style="color:#a6e22e">value</span>)) { 
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 调用isNumberOrString只知道返回true，并不知道具体类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 编译错误：&#39;value&#39; is possibly &#39;null&#39; or &#39;undefined&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">value</span>.<span style="color:#a6e22e">toString</span>();  
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {  
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Value does not exist:&#34;</span>, <span style="color:#a6e22e">value</span>);  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>TypeScript</code>有一种特殊语法，<font color="#de7802">用于返回布尔值的函数，以指示参数是否为特定类型</font>。这种特殊的语法被称为<code>type predicate</code>(类型谓词)，有时也被称为<code>user-defined type guard</code>，表示开发者正在创建自己的类型保护，类似<code>instanceof</code>或<code>typeof</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">typePredicate</span>(<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">WideType</span>)<span style="color:#f92672">:</span> <span style="color:#a6e22e">input</span> <span style="color:#66d9ef">is</span> <span style="color:#a6e22e">NarrowType</span>;
</span></span></code></pre></div><p>可以修改上面定义的函数<code>isNumberOrString</code>，使其具有明确的输入类型，即限制函数入参<code>value</code>的类型为<code>string | number</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">isNumberOrString</span>(<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">unknown</span>)<span style="color:#f92672">:</span> <span style="color:#a6e22e">value</span> <span style="color:#66d9ef">is</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">string</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> [<span style="color:#e6db74">&#39;number&#39;</span>, <span style="color:#e6db74">&#39;string&#39;</span>].<span style="color:#a6e22e">includes</span>(<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">value</span>);  
</span></span><span style="display:flex;"><span>}  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">logValueIfExists</span>(<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>) {  
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 无编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">isNumberOrString</span>(<span style="color:#a6e22e">value</span>)) { 
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">value</span>.<span style="color:#a6e22e">toString</span>(); 
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {  
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Value does not exist:&#34;</span>, <span style="color:#a6e22e">value</span>);  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>类型谓词通常用于检查一个已知接口实例的对象是否是一个更具体接口实例。下面代码中，接口<code>StandupComedian</code>扩展自<code>Comedian</code>，而在函数<code>isStandupComedian</code>中使用类型谓词限制<code>value</code>的类型:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Comedian</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">funny</span>: <span style="color:#66d9ef">boolean</span>;  
</span></span><span style="display:flex;"><span>}  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">StandupComedian</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Comedian</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">routine</span>: <span style="color:#66d9ef">string</span>;  
</span></span><span style="display:flex;"><span>}  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">isStandupComedian</span>(<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">Comedian</span>)<span style="color:#f92672">:</span> <span style="color:#a6e22e">value</span> <span style="color:#66d9ef">is</span> <span style="color:#a6e22e">StandupComedian</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#39;routine&#39;</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">value</span>;  
</span></span><span style="display:flex;"><span>}  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">workWithComedian</span>(<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">Comedian</span>) {  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">isStandupComedian</span>(<span style="color:#a6e22e">value</span>)) { <span style="color:#75715e">// Type of value: StandupComedian  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">value</span>.<span style="color:#a6e22e">routine</span>); <span style="color:#75715e">// Ok  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }  
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Type of value: Comedian  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 编译错误: Property &#39;routine&#39; does not exist on type &#39;Comedian&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">value</span>.<span style="color:#a6e22e">routine</span>);  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>但需要注意的是，因为类型谓词在<code>false</code>情况下也会窄化类型范围，<font color="#de7802">如果类型谓词不仅检查输入类型，还过多地检查其它条件，可能会出现令人惊讶的结果</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">isLongString</span>(<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>)<span style="color:#f92672">:</span> <span style="color:#a6e22e">input</span> <span style="color:#66d9ef">is</span> <span style="color:#66d9ef">string</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// !!的含义就是为了将结果转为真正的boolean值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">!!</span>(<span style="color:#a6e22e">input</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">input</span>.<span style="color:#a6e22e">length</span> <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">7</span>);  
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">workWithText</span>(<span style="color:#a6e22e">text</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>) { 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 使用了类型谓词，则认为if里面全部是string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// else里面是undefined
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">isLongString</span>(<span style="color:#a6e22e">text</span>)) { <span style="color:#75715e">// Type of text: string  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Long text:&#34;</span>, <span style="color:#a6e22e">text</span>.<span style="color:#a6e22e">length</span>);  
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {  
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Type of text: undefined  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 编译错误 Property &#39;length&#39; does not exist on type &#39;never&#39;. 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Short text:&#34;</span>, <span style="color:#a6e22e">text</span><span style="color:#f92672">?</span>.<span style="color:#a6e22e">length</span>);  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例代码中，因为<code>else</code>部分推断的类型必须是<code>undefined</code>，而函数<code>isLongString</code>为<code>false</code>时的类型推断是长度小于<code>7</code>的字符串，两部分交叉的结果是<code>never</code>，因此编译器给出的提示是<code>never</code>类型。</p>
<p>因为<span style="background:#ffb78b8c">类型谓词除了验证类型外，还可以验证其他，所以很容易被滥用</span>，一般建议尽可能避免使用它们。多数情况下，简单的类型谓词就足够使用了。</p>
<h2 id="type-operators">Type Operators</h2>
<p>并非所有类型都可以只使用关键字或现有类型的名称来表示。有时，需要创建一种新类型，将两者结合起来，对现有类型的属性进行一些转换。</p>
<h3 id="keyof">keyof</h3>
<p><code>JavaScript</code>对象可以使用动态键访问成员，动态键通常（但不一定）是<code>string</code>。在类型系统中表示这些键可能很棘手。使用诸如<code>catchall primitive</code>将允许非法的容器键值。</p>
<p>这就是为什么<code>TypeScript</code>在使用更严格的编译设置时，直接使用<code>ratings[key]</code>会报错。如下所示，类型<code>string</code>允许的值很可能不允许作为<code>Ratings</code>接口上的属性，而且<code>Ratings</code>在定义时并没有允许任何字符串键的索引签名：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Ratings</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">audience</span>: <span style="color:#66d9ef">number</span>;  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">critics</span>: <span style="color:#66d9ef">number</span>;  
</span></span><span style="display:flex;"><span>} 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getRating</span>(<span style="color:#a6e22e">ratings</span>: <span style="color:#66d9ef">Ratings</span>, <span style="color:#a6e22e">key</span>: <span style="color:#66d9ef">string</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ratings</span>[<span style="color:#a6e22e">key</span>];  
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//  Element implicitly has an &#39;any&#39; type because expression of type &#39;string&#39; can&#39;t be used to index type &#39;Ratings&#39;.
</span></span></span></code></pre></div><p>一种可行的方法是<font color="#de7802">对允许的键使用字面量联合</font>。这样可以更准确地限制容器中存在的键，下面代码使用了字面量联合类型来限制键的范围：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Ratings</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">audience</span>: <span style="color:#66d9ef">number</span>;  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">critics</span>: <span style="color:#66d9ef">number</span>;  
</span></span><span style="display:flex;"><span>}  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getRating</span>(<span style="color:#a6e22e">ratings</span>: <span style="color:#66d9ef">Ratings</span>, <span style="color:#a6e22e">key</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;audience&#39;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#39;critics&#39;</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ratings</span>[<span style="color:#a6e22e">key</span>]; <span style="color:#75715e">// Ok  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">ratings</span>: <span style="color:#66d9ef">Ratings</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">audience</span>: <span style="color:#66d9ef">66</span>, <span style="color:#a6e22e">critics</span>: <span style="color:#66d9ef">84</span>};  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">getRating</span>(<span style="color:#a6e22e">ratings</span>, <span style="color:#e6db74">&#39;audience&#39;</span>);
</span></span></code></pre></div><p>但如果接口有很多属性时，必须把每个成员的<code>key</code>对应的字面量放到联合类型中。若接口的属性发生变化时，需要随时更新允许的<code>key</code>。这样后续维护就会变得非常麻烦。</p>
<p><code>TypeScript</code>提供了<code>keyof</code>操作符，<font color=red>它接收现有类型，并返回该类型允许的所有键的联合</font>。在任何需要使用类型的地方，可以将它放在类型名称的前面。下面代码中，<code>keyof Ratings</code>等同于<code>'audience' | 'critic'</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Ratings</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">audience</span>: <span style="color:#66d9ef">number</span>;  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">critics</span>: <span style="color:#66d9ef">number</span>;  
</span></span><span style="display:flex;"><span>} 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getCountKeyof</span>(<span style="color:#a6e22e">ratings</span>: <span style="color:#66d9ef">Ratings</span>, <span style="color:#a6e22e">key</span>: <span style="color:#66d9ef">keyof</span> <span style="color:#a6e22e">Ratings</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ratings</span>[<span style="color:#a6e22e">key</span>];  
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">RatingsExt</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Ratings</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">test</span>: <span style="color:#66d9ef">number</span>  
</span></span><span style="display:flex;"><span>}  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getCountKeyof</span>(<span style="color:#a6e22e">ratings</span>: <span style="color:#66d9ef">RatingsExt</span>, <span style="color:#a6e22e">key</span>: <span style="color:#66d9ef">keyof</span> <span style="color:#a6e22e">RatingsExt</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ratings</span>[<span style="color:#a6e22e">key</span>];  
</span></span><span style="display:flex;"><span>}  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">ratingsExt</span>: <span style="color:#66d9ef">RatingsExt</span> <span style="color:#f92672">=</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">audience</span>: <span style="color:#66d9ef">66</span>,  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">critics</span>: <span style="color:#66d9ef">84</span>,  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">test</span>: <span style="color:#66d9ef">124</span>  
</span></span><span style="display:flex;"><span>};  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 继承的键也是可用的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">getCountKeyof</span>(<span style="color:#a6e22e">ratingsExt</span>, <span style="color:#e6db74">&#39;test&#39;</span>))  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">getCountKeyof</span>(<span style="color:#a6e22e">ratingsExt</span>, <span style="color:#e6db74">&#39;audience&#39;</span>))  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">getCountKeyof</span>(<span style="color:#a6e22e">ratingsExt</span>, <span style="color:#e6db74">&#39;critics&#39;</span>))
</span></span></code></pre></div><p><code>keyof</code>是<font color="#de7802">基于现有类型的键创建联合类型的一项强大功能</font>。它还能与<code>TypeScript</code>中的其它类型操作符很好地结合，实现一些非常有趣的模式。</p>
<h3 id="typeof">typeof</h3>
<p><code>TypeScript</code>提供的另一个类型操作符是<code>typeof</code>，它会返回所提供值的类型。如果手动编写值的类型复杂得令人讨厌的时候，这个操作符就非常有用。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">original</span> <span style="color:#f92672">=</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">medium</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;movie&#34;</span>,  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">title</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Mean Girls&#34;</span>,  
</span></span><span style="display:flex;"><span>}; 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">adaptation</span>: <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">original</span>;  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 可以使用...展开对象类型，后面的属性会覆盖展开后的属性
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">adaptation</span> <span style="color:#f92672">=</span> {...<span style="color:#a6e22e">original</span>, <span style="color:#a6e22e">medium</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;play&#34;</span>};  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">adaptation</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{ <span style="color:#a6e22e">medium</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;play&#39;</span>, <span style="color:#a6e22e">title</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;Mean Girls&#39;</span> }
</span></span></code></pre></div><p>尽管<code>typeof</code><font color="#de7802">类型操作符从外观上看很像运行时的</font><code>typeof</code>操作符，<font color="#de7802">后者返回相应的值类型的字符串描述</font>，但两者是不同的。也就是说，<font color=red>它们只是巧合地使用了同一个词。</font></p>
<p>请记住：<code>JavaScript</code>操作符<code>typeof</code>是一个运行时操作符，返回对应值类型的字符串名称。<code>typeScript</code>中的<code>typeof</code>因为是类型操作符，所以只能在类型中使用，不会出现在编译后的代码中。</p>
<h3 id="keyof-typeof">keyof typeof</h3>
<p><code>typeof</code>检索值的类型，<code>keyof</code>检索类型允许的键。<code>typeScript</code>允许将这两个关键字串联起来，以简洁地检索值对应类型上允许的键。将它们组合在一起，<code>typeof</code>类型操作符在处理<code>keyof</code>类型操作时变得非常有用。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">ratings</span> <span style="color:#f92672">=</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">imdb</span>: <span style="color:#66d9ef">8.4</span>,  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">metacritic</span>: <span style="color:#66d9ef">82</span>,  
</span></span><span style="display:flex;"><span>};  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">logRating</span>(<span style="color:#a6e22e">key</span>: <span style="color:#66d9ef">keyof</span> <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">ratings</span>) {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">ratings</span>[<span style="color:#a6e22e">key</span>]);  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="type-assertions">Type Assertions</h2>
<p>当我们的代码是「强类型」时，若所有值都有精确的类型，此时<code>TypeScript</code>的效果最好。顶层类型和类型保护等特性可以让类型检查程序理解复杂的代码。但是，有时并不能百分之百准确地告诉类型系统值的准确类型。</p>
<p>例如，<code>JSON.parse</code>故意返回顶层类型<code>any</code>。我们无法安全地告知类型系统，传递给<code>JSON.parse</code>的特定字符串值应返回任何特定的值类型。</p>
<p><code>TypeScript</code>提供了一种语法，<font color="#de7802">用于覆盖类型系统对值类型的理解</font>。即<code>type assertion</code>，也被称为<code>type cast</code>。如果一个值的类型不同，可以在<code>as</code>关键字后面加上一个类型，<code>TypeScript</code>将遵从断言，将该值视为该类型。<font color=red>类型断言也称为类型强制转换，如果转换失败会抛出异常</font>，因此在使用时要格外注意 。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">rawData</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">`[&#34;grace&#34;, &#34;frankie&#34;]`</span>;  
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: any  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">JSON</span>.<span style="color:#a6e22e">parse</span>(<span style="color:#a6e22e">rawData</span>);  
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: string[]  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">JSON</span>.<span style="color:#a6e22e">parse</span>(<span style="color:#a6e22e">rawData</span>) <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">string</span>[];  
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: [string, string]  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">JSON</span>.<span style="color:#a6e22e">parse</span>(<span style="color:#a6e22e">rawData</span>) <span style="color:#66d9ef">as</span> [<span style="color:#66d9ef">string</span>, <span style="color:#66d9ef">string</span>];  
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: [&#34;grace&#34;, &#34;frankie&#34;]  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">JSON</span>.<span style="color:#a6e22e">parse</span>(<span style="color:#a6e22e">rawData</span>) <span style="color:#66d9ef">as</span> [<span style="color:#e6db74">&#34;grace&#34;</span>, <span style="color:#e6db74">&#34;frankie&#34;</span>];
</span></span></code></pre></div><p><span style="background:#F5D6A9">类型断言仅存在于类型系统</span>，当编译为<code>JavaScript</code>后，<font color="#de7802">它们会与类型系统语法的其它部分一起被删除</font>。上面代码编译为<code>JavaScript</code>后将变成如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">rawData</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">`[&#34;grace&#34;, &#34;frankie&#34;]`</span>;  
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: any  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">re1</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">JSON</span>.<span style="color:#a6e22e">parse</span>(<span style="color:#a6e22e">rawData</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: string[]  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">re2</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">JSON</span>.<span style="color:#a6e22e">parse</span>(<span style="color:#a6e22e">rawData</span>) <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">string</span>[];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: [string, string]  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">re3</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">JSON</span>.<span style="color:#a6e22e">parse</span>(<span style="color:#a6e22e">rawData</span>) <span style="color:#66d9ef">as</span> [<span style="color:#66d9ef">string</span>, <span style="color:#66d9ef">string</span>];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: [&#34;grace&#34;, &#34;frankie&#34;]  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">re4</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">JSON</span>.<span style="color:#a6e22e">parse</span>(<span style="color:#a6e22e">rawData</span>) <span style="color:#66d9ef">as</span> [<span style="color:#e6db74">&#34;grace&#34;</span>, <span style="color:#e6db74">&#34;frankie&#34;</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">re1</span>, <span style="color:#a6e22e">re2</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">re3</span>, <span style="color:#a6e22e">re4</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>[ <span style="color:#e6db74">&#39;grace&#39;</span>, <span style="color:#e6db74">&#39;frankie&#39;</span> ] [ <span style="color:#e6db74">&#39;grace&#39;</span>, <span style="color:#e6db74">&#39;frankie&#39;</span> ]
</span></span><span style="display:flex;"><span>[ <span style="color:#e6db74">&#39;grace&#39;</span>, <span style="color:#e6db74">&#39;frankie&#39;</span> ] [ <span style="color:#e6db74">&#39;grace&#39;</span>, <span style="color:#e6db74">&#39;frankie&#39;</span> ]
</span></span></code></pre></div><p><code>TypeScript</code>的<span style="background:#F5D6A9">最佳实践是尽可能避免使用类型断言</span>。我们写的代码最好是能完全准确类型化的，不需要使用断言来干扰编译器对其类型的理解。但有时类型断言是有用的，甚至是必要的。</p>
<h3 id="asserting-caught-error-types">Asserting Caught Error Types</h3>
<p>错误处理是类型断言可能派上用场的另一个地方。一般来说，我们不清楚在<code>catch</code>代码块中捕获的错误是什么类型，因为<code>try</code>代码块中的代码可能会意外地抛出与预期不同的对象。此外，虽然<code>JavaScript</code>的最佳实践是始终抛出<code>Error</code>类的实例，但**<font color="#de7802">有些项目却会抛出字符串字面量或其它出人意料的值</font>**。</p>
<p>如果确信某个代码区域只会抛出<code>Error</code>类的实例，可以使用类型断言将捕获的断言视为<code>Error</code>。下面代码将访问捕获的<code>error</code>的<code>message</code>属性，并假定该<code>error</code>是<code>Error</code>类的实例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">try</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// code that may throw an error
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">error</span>) {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">warn</span>(<span style="color:#e6db74">&#34;Oh no!&#34;</span>, (<span style="color:#a6e22e">error</span> <span style="color:#66d9ef">as</span> Error).<span style="color:#a6e22e">message</span>);  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>比较安全的做法是使用类型窄化形式，如使用<code>instanceof</code>检查，以确保抛出的错误是预期的类型。下面示例代码检查抛出的错误是否为<code>Error</code>类的实例，以确定是记录<code>message</code>还是记录错误本身：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">try</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// (code that may throw an error)  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">error</span>) {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">warn</span>(<span style="color:#e6db74">&#34;Oh no!&#34;</span>, <span style="color:#a6e22e">error</span> <span style="color:#66d9ef">instanceof</span> Error <span style="color:#f92672">?</span> <span style="color:#a6e22e">error.message</span> : <span style="color:#66d9ef">error</span>)  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="non-null-assertions">Non-Null Assertions</h3>
<p>类型断言的另一个常见场景是从变量中移除<code>null</code>或<code>undefined</code>，因为<font color="#de7802">这些变量理论上可能包含<code>null</code>或<code>undefined</code>，但实际上并不包含</font>，所以要手动去除。</p>
<p>这种情况十分常见，<code>TypeScript</code>为此提供了一种速记方法。使用<code>!</code>表示同样的意思，不用写出<code>as</code>和值的完整类型，无论该值是否包含<code>null</code>和<code>undefined</code>。换句话说，<code>!</code>表示变量的类型不是<code>null</code>或<code>undefined</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">maybeDate</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> <span style="color:#66d9ef">undefined</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">new</span> Date();  
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Asserted type: Date  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">maybeDate</span> <span style="color:#66d9ef">as</span> Date;  
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Asserted type: Date  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">maybeDate</span><span style="color:#f92672">!</span>;
</span></span></code></pre></div><p>在使用<code>Map.get</code>等<code>API</code>时，非空断言尤其有用，这些<code>API</code>会返回一个值，如果该键对应的值不存在时，则返回<code>undefined</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">seasonCounts</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Map</span>([[<span style="color:#e6db74">&#34;I Love Lucy&#34;</span>, <span style="color:#ae81ff">6</span>], [<span style="color:#e6db74">&#34;The Golden Girls&#34;</span>, <span style="color:#ae81ff">7</span>],]);  
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: number | undefined  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">maybeValue</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">seasonCounts</span>.<span style="color:#66d9ef">get</span>(<span style="color:#e6db74">&#34;I Love Lucy&#34;</span>);  
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Error: Object is possibly &#39;undefined&#39;.  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">maybeValue</span>.<span style="color:#a6e22e">toFixed</span>());  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: number 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">knownValue</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">seasonCounts</span>.<span style="color:#66d9ef">get</span>(<span style="color:#e6db74">&#34;I Love Lucy&#34;</span>)<span style="color:#f92672">!</span>;  
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 除非十分确认，否则上面代码会有运行时报错
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">knownValue</span>.<span style="color:#a6e22e">toFixed</span>()); <span style="color:#75715e">// Ok
</span></span></span></code></pre></div><h3 id="type-assertion-caveats">Type Assertion Caveats</h3>
<p>如同<code>any</code>类型一样，类型断言是<code>TypeScript</code><font color="#de7802">类型系统的一个必要逃生舱口</font>。因此，与<code>any</code>类型一样，如果有其它方案，应当避免使用断言。</p>
<p>通常情况下，在代码中使用更准确的类型比使用断言更好。因为，有时断言往往是错误的，要么在编写代码时已经是错误的，要么是在代码库变化后产生的错误。下面代码无编译错误，但运行时会报错：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">seasonCounts</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Map</span>([[<span style="color:#e6db74">&#34;I Love Lucy&#34;</span>, <span style="color:#ae81ff">6</span>], [<span style="color:#e6db74">&#34;The Golden Girls&#34;</span>, <span style="color:#ae81ff">7</span>]]); 
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 不会出现编译错误，但会出现运行错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 运行时错误：Cannot read properties of undefined (reading &#39;toFixed&#39;)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">knownValue</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">seasonCounts</span>.<span style="color:#66d9ef">get</span>(<span style="color:#e6db74">&#34;I Love Lucy 11&#34;</span>)<span style="color:#f92672">!</span>;  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">knownValue</span>.<span style="color:#a6e22e">toFixed</span>()); 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 运行时会出现错误，应当捕获异常
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">knownValue</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">seasonCounts</span>.<span style="color:#66d9ef">get</span>(<span style="color:#e6db74">&#34;I Love Lucy 11&#34;</span>)<span style="color:#f92672">!</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">knownValue</span>.<span style="color:#a6e22e">toFixed</span>());
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">err</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">err</span> <span style="color:#66d9ef">instanceof</span> Error <span style="color:#f92672">?</span> <span style="color:#a6e22e">err.message</span> : <span style="color:#66d9ef">err</span>);
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;finally&#39;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>作为对比，如果使用类型声明，在编译就会报错，<font color="#de7802">使用类型断言，需要在运行时才会报错</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Entertainer</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">acts</span>: <span style="color:#66d9ef">string</span>[];  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;  
</span></span><span style="display:flex;"><span>}  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误:  Property &#39;acts&#39; is missing in type &#39;{ name: string; }&#39; but required in type &#39;Entertainer&#39;.  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// const declared: Entertainer = {name: &#34;Moms Mabley&#34;,};  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">asserted</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Moms Mabley&#34;</span>,} <span style="color:#66d9ef">as</span> <span style="color:#a6e22e">Entertainer</span>; <span style="color:#75715e">// Ok, but...  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 运行时错误: Cannot read properties of undefined (reading &#39;join&#39;)  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">asserted</span>.<span style="color:#a6e22e">acts</span>.<span style="color:#a6e22e">join</span>(<span style="color:#e6db74">&#34;, &#34;</span>));
</span></span></code></pre></div><p>需要注意的是，<span style="background:#F8D9C3">类型断言被允许的前提是其中一个类型可以赋值给另一个类型</span>。如果类型断言发生在两个完全不相关的类型之间，就会出现编译错误。例如，在<font color="#de7802">两个基本类型之间直接使用类型断言是不允许的</font>。下面代码中，<code>string</code>类型使用类型断言为<code>number</code>会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// Conversion of type &#39;string&#39; to type &#39;number&#39; may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to &#39;unknown&#39; first.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">myValue</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Stella!&#34;</span> <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 下面这样使用双重断言可以转换成功，但十分危险
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">myValueDouble</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;1337&#34;</span> <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">unknown</span> <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">number</span>;  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">myValueDouble</span>)
</span></span></code></pre></div><h2 id="const-assertions">Const Assertions</h2>
<p><code>const</code>断言通常用于表示任何值（数组、基础类型值等）都<span style="background:#f8d9c3">应被视为其自身的恒定不变版本</span>。具体来说，<code>const</code>断言会对其接收到的任意类型应用以下三条规则：</p>
<ul>
<li>数组会被认为是<code>readonly</code>的元组，而不是可变的数组。</li>
<li>字面量被视为字面量类型，而不是对应的基础类型。</li>
<li>对象上的属性被认为是只读的。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// Type: (number | string)[]   
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">arr</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>, <span style="color:#e6db74">&#39;&#39;</span>];  
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 类型被推断为readonly的元组，即: readonly [0, &#39;&#39;]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 即使是用let声明了typle，但const的优先级更高
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">typle</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>, <span style="color:#e6db74">&#39;&#39;</span>] <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">const</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// typle不能再被赋值，也不能修改其对应的数组元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Cannot assign to &#39;0&#39; because it is a read-only property.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">typle</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">12</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">classA</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// text的类型是字面量&#39;const&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">text</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;const&#39;</span> <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">const</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="literals-to-primitives">Literals to Primitives</h3>
<p>对于类型系统来说，<font color="#de7802">将字面量理解为特定的字面量类型，而不是将其扩大到对应的基础类型</font>，在某些情况非常有用。例如，与返回元组的函数类似，一个函数返回一个特定的字面量类型而非对应的基础类型，这可能会很有用。下面示例代码中，<code>getNameConst</code>的返回类型是更具体的<code>&quot;Maria Bamford&quot;</code>类型，而不是对应的基础类型<code>string</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// Type: () =&gt; string  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">getName</span> <span style="color:#f92672">=</span> () <span style="color:#f92672">=&gt;</span> <span style="color:#e6db74">&#34;Maria Bamford&#34;</span>;  
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: () =&gt; &#34;Maria Bamford&#34;  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">getNameConst</span> <span style="color:#f92672">=</span> () <span style="color:#f92672">=&gt;</span> <span style="color:#e6db74">&#34;Maria Bamford&#34;</span> <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">const</span>;
</span></span></code></pre></div><p>让值的特定字段成为更具体的字面量类型也可能是有用的。许多流行的库都要求值的判别字段是一个特定的字面量，这样它们的代码类型就能更具体地对值进行推断：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Joke</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">quote</span>: <span style="color:#66d9ef">string</span>;  
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// style属性是字面量类型的联合
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">style</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;story&#34;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;one-liner&#34;</span>;  
</span></span><span style="display:flex;"><span>}  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">tellJoke</span>(<span style="color:#a6e22e">joke</span>: <span style="color:#66d9ef">Joke</span>) {  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">joke</span>.<span style="color:#a6e22e">style</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;one-liner&#34;</span>) {  
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">joke</span>.<span style="color:#a6e22e">quote</span>);  
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {  
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">joke</span>.<span style="color:#a6e22e">quote</span>.<span style="color:#a6e22e">split</span>(<span style="color:#e6db74">&#34;\n&#34;</span>));  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: { quote: string; style: &#34;one-liner&#34; }  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">narrowJoke</span> <span style="color:#f92672">=</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">quote</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;If you stay alive for no other reason do it for spite.&#34;</span>,  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">style</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;one-liner&#34;</span> <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">const</span>,  
</span></span><span style="display:flex;"><span>};  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">tellJoke</span>(<span style="color:#a6e22e">narrowJoke</span>); <span style="color:#75715e">// OK  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 下面的wideObject类型为{ quote: string; style: string }  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">wideObject</span> <span style="color:#f92672">=</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">quote</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Time flies when you are anxious!&#34;</span>,  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">style</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;one-liner&#34;</span>,  
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">tellJoke</span>(<span style="color:#a6e22e">wideObject</span>);
</span></span></code></pre></div><h3 id="read-only-objects">Read-Only Objects</h3>
<p>对象字面量（如用作变量初始值的对象字面量）通常会拓宽属性类型，这与<code>let</code>变量初始值的拓宽方式相同。字符串值（如 <code>&quot;apple&quot;</code>）变成了基本类型<code>string</code>，数组字面量变成了可变数组而不是元组。如果这些值中的一部分或全部以后要用于需要其特定字面量类型的地方，这可能会带来不便。</p>
<p>断言值字面类型为<code>const</code>时，推断类型会尽可能具体。<font color=red>所有成员属性都变成只读，字面量被视为自己的字面类型，而不是对应的基本类型，数组变成只读元组</font>。换句话说，对一个值字面量类型应用<code>const</code>断言会使该值字面类型不可变，<font color="#de7802">并递归地对其所有成员应用相同的<code>const</code>断言逻辑</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 返回类型为字符串字面量的联合
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">describePreference</span>(<span style="color:#a6e22e">preference</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;maybe&#34;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;no&#34;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;yes&#34;</span>) {  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">switch</span> (<span style="color:#a6e22e">preference</span>) {  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;maybe&#34;</span><span style="color:#f92672">:</span>  
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;I suppose...&#34;</span>;  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;no&#34;</span><span style="color:#f92672">:</span>  
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;No thanks.&#34;</span>;  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;yes&#34;</span><span style="color:#f92672">:</span>  
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;Yes please!&#34;</span>;  
</span></span><span style="display:flex;"><span>    } 
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: { movie: string, standup: string }  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">preferencesMutable</span> <span style="color:#f92672">=</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">movie</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;maybe&#34;</span>,  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">standup</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;yes&#34;</span>,  
</span></span><span style="display:flex;"><span>};  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 严格类型检测，传入的实参类型为string，而非字面量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Argument of type &#39;string&#39; is not assignable to parameter of type &#39;&#34;maybe&#34; | &#34;no&#34; | &#34;yes&#34;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">describePreference</span>(<span style="color:#a6e22e">preferencesMutable</span>.<span style="color:#a6e22e">movie</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">preferencesMutable</span>.<span style="color:#a6e22e">movie</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;no&#34;</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: readonly { readonly movie: &#34;maybe&#34;, readonly standup: &#34;yes&#34; }  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">preferencesReadonly</span> <span style="color:#f92672">=</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">movie</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;maybe&#34;</span>,  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">standup</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;yes&#34;</span>,  
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">const</span>  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">describePreference</span>(<span style="color:#a6e22e">preferencesReadonly</span>.<span style="color:#a6e22e">movie</span>); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Cannot assign to &#39;movie&#39; because it is a read-only property.  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">preferencesReadonly</span>.<span style="color:#a6e22e">movie</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;no&#34;</span>;
</span></span></code></pre></div><p>需要注意的是，<em><font color="#de7802">类型断言只能暂时欺骗编译器，无法避免运行时错误</font></em>。因此，滥用类型断言可能会导致运行时错误，下面代码不会出现编译错误，但会出现运行时错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Cat</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">run</span>()<span style="color:#f92672">:</span> <span style="color:#66d9ef">void</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Fish</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">swim</span>()<span style="color:#f92672">:</span> <span style="color:#66d9ef">void</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">isFish</span>(<span style="color:#a6e22e">animal</span>: <span style="color:#66d9ef">Cat</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">Fish</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 传入的类型可能是Cat
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 使用类型断言，因为cat没有swim方法，可能会出现运行时错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    (<span style="color:#a6e22e">animal</span> <span style="color:#66d9ef">as</span> <span style="color:#a6e22e">Fish</span>).<span style="color:#a6e22e">swim</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">cat</span>: <span style="color:#66d9ef">Cat</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Hello&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">run</span>()<span style="color:#f92672">:</span> <span style="color:#66d9ef">void</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">isFish</span>(<span style="color:#a6e22e">cat</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 出现运行时错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#a6e22e">animal</span>.<span style="color:#a6e22e">swim</span> <span style="color:#66d9ef">is</span> <span style="color:#a6e22e">not</span> <span style="color:#a6e22e">a</span> <span style="color:#66d9ef">function</span>
</span></span></code></pre></div><p>下面示例代码中，使用<code>instanceof</code>来判断变量是否为某个类的实例是合适的。但某些情况下，<code>ApiError</code>和<code>HttpError</code>不是一个类，而是接口类型。<font color="#de7802">接口是一个类型，并不是一个真正的值，它在编译结果中会被删除，因此无法使用<code>instanceof</code>来做运行时判断。</font></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ApiError</span> <span style="color:#66d9ef">extends</span> Error {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">code</span>: <span style="color:#66d9ef">number</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">HttpError</span> <span style="color:#66d9ef">extends</span> Error {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">statusCode</span>: <span style="color:#66d9ef">number</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">200</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">isApiError</span>(<span style="color:#a6e22e">error</span>: <span style="color:#66d9ef">Error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">error</span> <span style="color:#66d9ef">instanceof</span> <span style="color:#a6e22e">ApiError</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>此时只能使用类型断言：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">ApiError</span> <span style="color:#66d9ef">extends</span> Error {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">code</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">HttpError</span> <span style="color:#66d9ef">extends</span> Error {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">statusCode</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">isApiError</span>(<span style="color:#a6e22e">error</span>: <span style="color:#66d9ef">Error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (<span style="color:#a6e22e">error</span> <span style="color:#66d9ef">as</span> <span style="color:#a6e22e">ApiError</span>).<span style="color:#a6e22e">code</span> <span style="color:#f92672">===</span> <span style="color:#ae81ff">23</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="generics">Generics</h1>
<p>目前为止，所学到的所有类型语法都用于完全已知的类型。有时，一段代码<font color="#de7802">可能会根据不同的调用方式与各种不同类型协同工作</font>。我们需要一种方法来说明输入类型与函数返回类型之间的关系，<code>TypeScript</code>使用泛型捕捉类型之间的关系。</p>
<p>在<code>Typescript</code>中，函数等泛型构造可以声明任意数量的类型参数，泛型构造的每次使用都会确定这些类型。这些类型参数在泛型构造中表示类型，以表示构造的每个实例中都可能不同的某种类型。<font color=red>类型参数可以为泛型构造的每个实例提供不同的类型（称为类型参数），但在当前实例中将保持一致</font>。</p>
<p>按照惯例，类型参数通常使用单字母（如<code>T</code>和<code>U</code>）或<code>PascalCase</code>名称（如<code>Key</code>和<code>Value</code>）。可以使用<code>&lt;</code>和<code>&gt;</code>声明泛型，如<code>someFunction&lt;T&gt;</code>或<code>SomeInterface&lt;T&gt;</code>。</p>
<h2 id="generic-functions">Generic Functions</h2>
<p>要使函数具有泛型功能，<font color="#de7802">可以在参数圆括号之前，用一对尖括号声明类型参数名</font>。接下来，该类型参数就可以在函数体中的形参类型标注、返回类型标注以及函数中使用。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">identity</span>&lt;<span style="color:#f92672">T</span>&gt;(<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">T</span>) {  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">input</span>;  
</span></span><span style="display:flex;"><span>}  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">numeric</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">identity</span>(<span style="color:#e6db74">&#34;me&#34;</span>); <span style="color:#75715e">// Type: &#34;me&#34;  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">stringy</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">identity</span>(<span style="color:#ae81ff">123</span>); <span style="color:#75715e">// Type: 123
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">stringy</span>, <span style="color:#a6e22e">numeric</span>) <span style="color:#75715e">// me 123
</span></span></span></code></pre></div><p>箭头函数也可以声明为泛型，<font color=red>也是在形参圆括号前用尖括号封装类型参数</font>。下面定义的箭头泛型函数和上面定义的普通泛型函数效果是一样的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">identity</span> <span style="color:#f92672">=</span> &lt;<span style="color:#f92672">T</span>&gt;(<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">T</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">input</span>;  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">identity</span>(<span style="color:#ae81ff">12</span>)) <span style="color:#75715e">// 12
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">identity</span>(<span style="color:#e6db74">&#39;133&#39;</span>)) <span style="color:#75715e">// 133
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 箭头泛型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">arrowVal</span> <span style="color:#f92672">=</span> &lt;<span style="color:#f92672">T</span>&gt;(<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">T</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">value</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">arrowVal</span>(<span style="color:#e6db74">&#39;898989&#39;</span>))
</span></span></code></pre></div><p>但需要注意的是，在<code>.tsx</code>文件中泛型箭头语法有一些限制，因为它与<code>JSX</code>语法冲突。修改相关的配置可以支持<code>JSX</code>和<code>React</code>。</p>
<h3 id="explicit-generic-call-types">Explicit Generic Call Types</h3>
<p>多数情况下，在调用泛型函数时，能够根据函数的调用方式推断出类型实参。例如，在前面的<code>identity</code>函数中，类型检查器根据提供给它的实参来推断泛型函数的类型实参。</p>
<p>不幸的是，与类成员和变量类型一样，有时函数调用时没有足够的信息来告知编译器类型参数应解析成什么类型。如果一个泛型构造器被提供给另一个泛型构造器，则可能会发生这种情况。<font color="#de7802">对于无法推断的类型参数，则认为是<code>unknown</code>类型。</font></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">logWrapper</span>&lt;<span style="color:#f92672">Input</span>&gt;(<span style="color:#a6e22e">callback</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">Input</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">void</span>) {  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">Input</span>) <span style="color:#f92672">=&gt;</span> {  
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Input:&#34;</span>, <span style="color:#a6e22e">input</span>);  
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">callback</span>(<span style="color:#a6e22e">input</span>);  
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 正常
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">test</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">logWrapper</span>((<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">string</span>) <span style="color:#f92672">=&gt;</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">input</span>.<span style="color:#a6e22e">length</span>);  
</span></span><span style="display:flex;"><span>})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">test</span>(<span style="color:#e6db74">&#39;1233&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 上面代码的执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">Input</span>: <span style="color:#66d9ef">1234</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 若未指明类型，编译器默认推断为unknown
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 出现编译错误：&#39;input&#39; is of type &#39;unknown&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// unkonwn不能直接访问属性，必须进行类型转换
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">log1</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">logWrapper</span>((<span style="color:#a6e22e">input</span>) <span style="color:#f92672">=&gt;</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">input</span>.<span style="color:#a6e22e">length</span>);  
</span></span><span style="display:flex;"><span>})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 下面代码不会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">log1</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">logWrapper</span>((<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">input</span>.<span style="color:#a6e22e">toFixed</span>());
</span></span><span style="display:flex;"><span>})
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">log1</span>(<span style="color:#ae81ff">133.456</span>)
</span></span></code></pre></div><p>为了避免使用默认的类型<code>unknown</code>，泛型函数调用时<font color="#de7802">可能需要显式标注泛型的类型实参</font>。编译器将对泛型函数调用执行类型检查，以确保显式标注的类型参数是正确的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">logWrapper</span>&lt;<span style="color:#f92672">Input</span>&gt;(<span style="color:#a6e22e">callback</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">Input</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">void</span>) {  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">Input</span>) <span style="color:#f92672">=&gt;</span> {  
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Input:&#34;</span>, <span style="color:#a6e22e">input</span>);  
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">callback</span>(<span style="color:#a6e22e">input</span>);  
</span></span><span style="display:flex;"><span>    };  
</span></span><span style="display:flex;"><span>}  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">test</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">logWrapper</span>&lt;<span style="color:#f92672">string</span>&gt;((<span style="color:#a6e22e">input</span>) <span style="color:#f92672">=&gt;</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">input</span>.<span style="color:#a6e22e">length</span>);  
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">test</span>(<span style="color:#e6db74">&#34;Hello world&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">log1</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">logWrapper</span>&lt;<span style="color:#f92672">string</span>&gt;((<span style="color:#a6e22e">input</span>) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;input length:&#34;</span>, <span style="color:#a6e22e">input</span>.<span style="color:#a6e22e">length</span>);
</span></span><span style="display:flex;"><span>})
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">log1</span>(<span style="color:#e6db74">&#34;133.456&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">Input</span>: <span style="color:#66d9ef">Hello</span> <span style="color:#a6e22e">world</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">study.ts</span>:<span style="color:#66d9ef">2311</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">input</span> <span style="color:#a6e22e">length</span>: <span style="color:#66d9ef">7</span>
</span></span></code></pre></div><h3 id="multiple-function-type-parameters">Multiple Function Type Parameters</h3>
<p>泛型函数<font color="#de7802">可以定义任意数量的类型参数，类型参数之间用逗号隔开</font>。泛型函数每次调用时都可以为每个类型参数确定相应的实际类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">makeTuple</span>&lt;<span style="color:#f92672">First</span><span style="color:#960050;background-color:#1e0010">,</span> <span style="color:#a6e22e">Second</span>&gt;(<span style="color:#a6e22e">first</span>: <span style="color:#66d9ef">First</span>, <span style="color:#a6e22e">second</span>: <span style="color:#66d9ef">Second</span>) {  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> [<span style="color:#a6e22e">first</span>, <span style="color:#a6e22e">second</span>] <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">const</span>;  
</span></span><span style="display:flex;"><span>}  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 因为使用了const，所以let tuple: readonly [boolean, string]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">tuple</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">makeTuple</span>(<span style="color:#66d9ef">true</span>, <span style="color:#e6db74">&#34;abc&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 下面修改tuple会出现编译错误：Cannot assign to &#39;0&#39; because it is a read-only property.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">tuple</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 返回值是{key: Key, value: Value}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">makePair</span>&lt;<span style="color:#f92672">Key</span><span style="color:#960050;background-color:#1e0010">,</span> <span style="color:#a6e22e">Value</span>&gt;(<span style="color:#a6e22e">key</span>: <span style="color:#66d9ef">Key</span>, <span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">Value</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> {<span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">value</span>};
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">makePair</span>(<span style="color:#ae81ff">123</span>, <span style="color:#e6db74">&#39;123&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">makePair</span>&lt;<span style="color:#f92672">string</span><span style="color:#960050;background-color:#1e0010">,</span> <span style="color:#a6e22e">number</span>&gt;(<span style="color:#e6db74">&#34;abc&#34;</span>, <span style="color:#ae81ff">123</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">makePair</span><span style="color:#f92672">&lt;</span><span style="color:#e6db74">&#34;abc&#34;</span>, <span style="color:#ae81ff">123</span><span style="color:#f92672">&gt;</span>(<span style="color:#e6db74">&#34;abc&#34;</span>, <span style="color:#ae81ff">123</span>);
</span></span></code></pre></div><p>在声明泛型函数时，<font color="#de7802">尽量不要超过两个类型参数</font>。与普通函数的参数一样，在泛型函数中使用的类型参数越多，代码就越难阅读和理解。</p>
<h2 id="generic-interfaces">Generic Interfaces</h2>
<p>接口也可以声明为泛型，它们遵循与函数类似的泛型规则：可以在接口名后面添加<code>&lt;</code>和<code>&gt;</code>，尖括号中可以声明任意数量的类型参数。需要注意的是，<font color="#de7802">使用泛型接口类型时，需要显式标注类型实参，否则会出现编译错误</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Box</span>&lt;<span style="color:#f92672">T</span>&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">inside</span>: <span style="color:#66d9ef">T</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 使用泛型接口类型时，需要显式标注类型实参，否则会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误： Generic type &#39;Box&lt;T&gt;&#39; requires 1 type argument(s)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">d</span>: <span style="color:#66d9ef">Box</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">inside</span>: <span style="color:#66d9ef">123</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 正常
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">stringyBox</span>: <span style="color:#66d9ef">Box</span>&lt;<span style="color:#f92672">string</span>&gt; <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">inside</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;abc&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">numberBox</span>: <span style="color:#66d9ef">Box</span>&lt;<span style="color:#f92672">number</span>&gt; <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">inside</span>: <span style="color:#66d9ef">123</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 声明的参数类型和实际使用的类型不同时会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Type &#39;boolean&#39; is not assignable to type &#39;number&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">incorrectBox</span>: <span style="color:#66d9ef">Box</span>&lt;<span style="color:#f92672">number</span>&gt; <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">inside</span>: <span style="color:#66d9ef">false</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>实际上，内置的<code>Array</code>就是一个泛型接口，它使用类型参数<code>T</code>来表示存储在数组里的元素类型，它的<code>pop</code>和<code>push</code>方法的声明大致如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> Array&lt;<span style="color:#f92672">T</span>&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pop</span>()<span style="color:#f92672">:</span> <span style="color:#a6e22e">T</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">push</span>(...<span style="color:#a6e22e">items</span>: <span style="color:#66d9ef">T</span>[])<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h3 id="inferred-generic-interface-types">Inferred Generic Interface Types</h3>
<p>如同泛型函数，<font color="#de7802">泛型接口的类型实参也可以从使用中推断出来</font>。<code>TypeScript</code>会尽力从提供给标注为泛型接口类型的形参对应的实参值推断出泛型接口对应的具体类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">LinkedNode</span>&lt;<span style="color:#f92672">Value</span>&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">next?</span>: <span style="color:#66d9ef">LinkedNode</span>&lt;<span style="color:#f92672">Value</span>&gt;;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">Value</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getLast</span>&lt;<span style="color:#f92672">Value</span>&gt;(<span style="color:#a6e22e">node</span>: <span style="color:#66d9ef">LinkedNode</span>&lt;<span style="color:#f92672">Value</span>&gt;)<span style="color:#f92672">:</span> <span style="color:#a6e22e">Value</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">next</span> <span style="color:#f92672">?</span> <span style="color:#a6e22e">getLast</span>(<span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">next</span>) <span style="color:#f92672">:</span> <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">value</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Inferred Value type argument: Date
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">lastDate</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">getLast</span>({
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">new</span> Date(<span style="color:#e6db74">&#34;09-13-1993&#34;</span>),
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Inferred Value type argument: string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">lastFruit</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">getLast</span>({
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">next</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">value</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;banana&#34;</span>,
</span></span><span style="display:flex;"><span>    }, <span style="color:#a6e22e">value</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;apple&#34;</span>,
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Inferred Value type argument: number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">lastMismatch</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">getLast</span>({
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">next</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">123</span>
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 类型不一致，会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// Error: type &#39;boolean&#39; is not assignable to type &#39;number&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">false</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>请注意，<span style="background:#f8d9c3">如果接口声明时是泛型的，则任何引用该接口类型的地方都必须提供相应的类型实参</span>，否则会出现编译错误。下面示例代码中，因为使用泛型类型标注时没有提供类型实参，所以会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">CrateLike</span>&lt;<span style="color:#f92672">T</span>&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">contents</span>: <span style="color:#66d9ef">T</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Generic type &#39;CrateLike&lt;T&gt;&#39; requires 1 type argument(s).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">missingGeneric</span>: <span style="color:#66d9ef">CrateLike</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">contents</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;??&#34;</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 类型标注指定了类型实参，所以不会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">missingGeneric1</span>: <span style="color:#66d9ef">CrateLike</span>&lt;<span style="color:#f92672">string</span>&gt; <span style="color:#f92672">=</span> {<span style="color:#a6e22e">contents</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;??&#34;</span>};
</span></span></code></pre></div><h2 id="generic-classes">Generic Classes</h2>
<p>如同<code>interface</code>，<code>class</code>也支持泛型，并且支持任意数量的类型参数。创建的每一个类的实例可能使用不同的类型实参。下面定义的泛型类声明了两个类型参数<code>key</code>和<code>value</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Secret</span>&lt;<span style="color:#f92672">Key</span><span style="color:#960050;background-color:#1e0010">,</span> <span style="color:#a6e22e">Value</span>&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">key</span>: <span style="color:#66d9ef">Key</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">Value</span>;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>(<span style="color:#a6e22e">key</span>: <span style="color:#66d9ef">Key</span>, <span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">Value</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">key</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">key</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">value</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">value</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">getValue</span>(<span style="color:#a6e22e">key</span>: <span style="color:#66d9ef">Key</span>)<span style="color:#f92672">:</span> <span style="color:#a6e22e">Value</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">key</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">key</span> <span style="color:#f92672">?</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">value</span> : <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">storage</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Secret</span>(<span style="color:#ae81ff">12345</span>, <span style="color:#e6db74">&#34;luggage&#34;</span>); <span style="color:#75715e">// Type: Secret&lt;number, string&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">value1</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">storage</span>.<span style="color:#a6e22e">getValue</span>(<span style="color:#ae81ff">1987</span>);  <span style="color:#75715e">// Type: string | undefined
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">value2</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">storage</span>.<span style="color:#a6e22e">getValue</span>(<span style="color:#ae81ff">12345</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">value1</span>, <span style="color:#a6e22e">value2</span>) <span style="color:#75715e">// undefined luggage
</span></span></span></code></pre></div><h3 id="explicit-generic-class-types">Explicit Generic Class Types</h3>
<p>实例化泛型类和调用泛型函数类似，如果类型参数可以从构造器中的参数中推断出来，就可以省略显式的类型实参标注。如果省略了类型实参，编译器却推断不出来类型实参，则使用默认的<code>unknown</code>。例如，上面示例代码使用了<code>new Secret(12345, &quot;luggage&quot;)</code>，可以推断出类型实参为<code>number</code>和<code>string</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">storage</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Secret</span>(<span style="color:#ae81ff">12345</span>, <span style="color:#e6db74">&#34;luggage&#34;</span>); <span style="color:#75715e">// Type: Secret&lt;number, string&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">storage</span>.<span style="color:#a6e22e">getValue</span>(<span style="color:#ae81ff">1987</span>); <span style="color:#75715e">// Type: string | undefined
</span></span></span></code></pre></div><p>下面定义了泛型类<code>CurriedCallback</code>，类的构造器中接受一个泛型函数作为入参，如果泛型函数有已知的类型（例如来自显式类型参数类型标注），那么类实例中的<code>input</code>类型参数就可以推断出来。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CurriedCallback</span>&lt;<span style="color:#f92672">Input</span>&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#a6e22e">callback</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">Input</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">void</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>(<span style="color:#a6e22e">callback</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">Input</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">void</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#960050;background-color:#1e0010">#</span><span style="color:#a6e22e">callback</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">Input</span>) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Input:&#34;</span>, <span style="color:#a6e22e">input</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">callback</span>(<span style="color:#a6e22e">input</span>);
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">call</span>(<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">Input</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#960050;background-color:#1e0010">#</span><span style="color:#a6e22e">callback</span>(<span style="color:#a6e22e">input</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: CurriedCallback&lt;string&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">new</span> <span style="color:#a6e22e">CurriedCallback</span>((<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">string</span>) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">input</span>.<span style="color:#a6e22e">length</span>);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 显式声明类型实参，构造器的入参就可以省略类型标注
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">new</span> <span style="color:#a6e22e">CurriedCallback</span>&lt;<span style="color:#f92672">string</span>&gt;((<span style="color:#a6e22e">input</span>) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">input</span>.<span style="color:#a6e22e">length</span>);
</span></span><span style="display:flex;"><span>})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 既不能从构造器中推断出类型，也未显式标注类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 所以会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: CurriedCallback&lt;unknown&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">new</span> <span style="color:#a6e22e">CurriedCallback</span>((<span style="color:#a6e22e">input</span>) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 编译错误：&#39;input&#39; is of type &#39;unknown&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// unknown需要类型窄化才可以访问属性
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">input</span>.<span style="color:#a6e22e">length</span>);
</span></span><span style="display:flex;"><span>})
</span></span></code></pre></div><h3 id="extending-generic-classes">Extending Generic Classes</h3>
<p>泛型类可以作为普通类的基类。但需要注意的是，<font color="#de7802">编译器不会尝试从使用中推断基类的类型参数，任何没有默认值的类型参数都需要使用显式类型标注。</font></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Quote</span>&lt;<span style="color:#f92672">T</span>&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">lines</span>: <span style="color:#66d9ef">T</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>(<span style="color:#a6e22e">lines</span>: <span style="color:#66d9ef">T</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">lines</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">lines</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SpokenQuote</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Quote</span>&lt;<span style="color:#f92672">string</span><span style="color:#960050;background-color:#1e0010">[]</span>&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">speak() {</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">lines</span>.<span style="color:#a6e22e">join</span>(<span style="color:#e6db74">&#34;\n&#34;</span>));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Quote</span>(<span style="color:#e6db74">&#34;The only real failure is the failure to try.&#34;</span>).<span style="color:#a6e22e">lines</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Quote</span>([<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">23</span>, <span style="color:#ae81ff">42</span>]).<span style="color:#a6e22e">lines</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">new</span> <span style="color:#a6e22e">SpokenQuote</span>([<span style="color:#e6db74">&#34;Greed is so destructive.&#34;</span>, <span style="color:#e6db74">&#34;It destroys everything&#34;</span>,]).<span style="color:#a6e22e">lines</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 实参类型不对，会出现编译错误：Type &#39;number&#39; is not assignable to type &#39;string&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">new</span> <span style="color:#a6e22e">SpokenQuote</span>([<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">23</span>, <span style="color:#ae81ff">42</span>]);
</span></span></code></pre></div><p>泛型派生类也可以将自己的类型参数传递给基类。需要注意的是，<font color="#de7802">派生泛型类中的类型参数名不必与基类泛型声明时使用的名称一致</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AttributedQuote</span>&lt;<span style="color:#f92672">Value</span>&gt; <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Quote</span>&lt;<span style="color:#f92672">Value</span>&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">speaker</span>: <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>(<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">Value</span>, <span style="color:#a6e22e">speaker</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">super</span>(<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">speaker</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">speaker</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">AttributedQuote</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;The road to success is always under construction.&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;Lily Tomlin&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">value</span>.<span style="color:#a6e22e">speaker</span>);
</span></span></code></pre></div><h3 id="implementing-generic-interfaces">Implementing Generic Interfaces</h3>
<p>泛型类也可以通过提供必要的类型参数来实现泛型接口。这与<code>extends</code>泛型基类的原理类似：<font color="#de7802">基接口上的任何类型参数都必须由实现类来声明</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">ActingCredit</span>&lt;<span style="color:#f92672">Role</span>&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">role</span>: <span style="color:#66d9ef">Role</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MoviePart</span> <span style="color:#66d9ef">implements</span> <span style="color:#a6e22e">ActingCredit</span>&lt;<span style="color:#f92672">string</span>&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">role</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">speaking</span>: <span style="color:#66d9ef">boolean</span>;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>(<span style="color:#a6e22e">role</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">speaking</span>: <span style="color:#66d9ef">boolean</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">role</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">role</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">speaking</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">speaking</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">part</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">MoviePart</span>(<span style="color:#e6db74">&#34;Miranda Priestly&#34;</span>, <span style="color:#66d9ef">true</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">part</span>.<span style="color:#a6e22e">role</span>);
</span></span></code></pre></div><h3 id="method-generics">Method Generics</h3>
<p>类方法可以<font color="#de7802">在类实例之外声明自己的泛型方法</font>。对类中泛型方法的每次调用，对应的每个类型参数都可能有不同的类型实参。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CreatePairFactory</span>&lt;<span style="color:#f92672">Key</span>&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">key</span>: <span style="color:#66d9ef">Key</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>(<span style="color:#a6e22e">key</span>: <span style="color:#66d9ef">Key</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">key</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">key</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 类中泛型方法中的类型参数和泛型类定义时使用的类型参数不同
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">createPair</span>&lt;<span style="color:#f92672">Value</span>&gt;(<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">Value</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> {<span style="color:#a6e22e">key</span>: <span style="color:#66d9ef">this.key</span>, <span style="color:#a6e22e">value</span>};
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">factory</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">CreatePairFactory</span>(<span style="color:#e6db74">&#34;role&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">numberPair</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">factory</span>.<span style="color:#a6e22e">createPair</span>(<span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">stringPair</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">factory</span>.<span style="color:#a6e22e">createPair</span>(<span style="color:#e6db74">&#34;Sophie&#34;</span>);
</span></span></code></pre></div><h3 id="static-class-generics">Static Class Generics</h3>
<p>类的静态成员独立于实例成员，与类的任何特定实例无关。它们无法访问任何类实例或任何类实例特有的类型信息。因此，虽然静态类方法可以声明自己的类型参数，但**<font color="#de7802">它们不能访问泛型类声明时的任何类型参数</font>**。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BothLogger</span>&lt;<span style="color:#f92672">OnInstance</span>&gt; {
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">instanceLog</span>(<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">OnInstance</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">value</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#a6e22e">staticLog</span>&lt;<span style="color:#f92672">OnStatic</span>&gt;(<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">OnStatic</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 静态方法不能使用泛型类的类型参数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">fromInstance</span>: <span style="color:#66d9ef">OnInstance</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">value</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 出现编译错误： Static members cannot reference class type parameters.
</span></span></span></code></pre></div><h2 id="generic-type-aliases">Generic Type Aliases</h2>
<p>类型别名也支持泛型，每一个泛型别名类型可以有任意数量的类型参数。泛型别名通常与函数一起使用，用于标注泛型函数的类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Nullish</span>&lt;<span style="color:#f92672">T</span>&gt; <span style="color:#f92672">=</span> <span style="color:#a6e22e">T</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">CreatesValue</span>&lt;<span style="color:#f92672">Input</span><span style="color:#960050;background-color:#1e0010">,</span> <span style="color:#a6e22e">Output</span>&gt; <span style="color:#f92672">=</span> (<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">Input</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">Output</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">funTest</span>: <span style="color:#66d9ef">CreatesValue</span>&lt;<span style="color:#f92672">string</span><span style="color:#960050;background-color:#1e0010">,</span> <span style="color:#a6e22e">number</span>&gt; <span style="color:#f92672">=</span> (<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">string</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">input</span>.<span style="color:#a6e22e">length</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">funTest</span>(<span style="color:#e6db74">&#39;123333&#39;</span>));
</span></span></code></pre></div><h3 id="generic-discriminated-unions">Generic Discriminated Unions</h3>
<p>在<code>TypeScript</code>中，判别联合能优雅地将<code>JavaScript</code>常见模式与<code>TypeScript</code>的类型窄化完美地结合在一起。我最喜欢的判别联合用法是添加一个类型参数，以创建一个泛型的<code>Result</code>类型，它可以代表成功的数据结果，也可以代表失败的错误结果。</p>
<p>该<code>Result</code>泛型有一个<code>succeeded</code>判别式，必须使用该判别式才能确定结果是成功还是失败。这意味着任何返回<code>Result</code>的操作都可以表示错误或数据<code>result</code>，并确保使用者需要检查结果是否成功：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Result</span>&lt;<span style="color:#f92672">Data</span>&gt; <span style="color:#f92672">=</span> <span style="color:#a6e22e">FailureResult</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">SuccessfulResult</span>&lt;<span style="color:#f92672">Data</span>&gt;;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">FailureResult</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">error</span>: <span style="color:#66d9ef">Error</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">succeeded</span>: <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">SuccessfulResult</span>&lt;<span style="color:#f92672">Data</span>&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">data</span>: <span style="color:#66d9ef">Data</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">succeeded</span>: <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">handleResult</span>(<span style="color:#a6e22e">result</span>: <span style="color:#66d9ef">Result</span>&lt;<span style="color:#f92672">string</span>&gt;) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">succeeded</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 正常
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">data</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`We did it! </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">data</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">error</span>(<span style="color:#e6db74">`Awww... </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">error</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 没有类型窄化会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// Property &#39;data&#39; does not exist on type &#39;Result&lt;string&gt;&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">data</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>将泛型和<code>discriminated types</code>结合在一起，能为像<code>Result</code>这样的可重用类型提供绝佳的定义方式。</p>
<h2 id="generic-modifiers">Generic Modifiers</h2>
<p><code>TypeScript</code>包含允许修改泛型参数行为的语法，下面介绍泛型默认类型参数和类型参数约束。</p>
<h3 id="generic-defaults">Generic Defaults</h3>
<p>到目前为止，如果在类型标注中使用泛型，或者将其作为类的扩展或实现的基类，那么它必须为每个类型参数提供一个类型实参。可以在类型参数的声明后加上一个<code>=</code>符号和一个默认类型，避免显式地提供类型参数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Quote</span>&lt;<span style="color:#f92672">T</span> <span style="color:#960050;background-color:#1e0010">=</span> <span style="color:#a6e22e">string</span>&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">T</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">explicit</span>: <span style="color:#66d9ef">Quote</span>&lt;<span style="color:#f92672">number</span>&gt; <span style="color:#f92672">=</span> {<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">123</span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">implicit</span>: <span style="color:#66d9ef">Quote</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">value</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Be yourself. The world worships the original.&#34;</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 不显式标注类型，则表示使用默认的类型参数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Type &#39;number&#39; is not assignable to type &#39;string&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">mismatch</span>: <span style="color:#66d9ef">Quote</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">123</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">KeyValuePair</span>&lt;<span style="color:#f92672">Key</span><span style="color:#960050;background-color:#1e0010">,</span> <span style="color:#a6e22e">Value </span><span style="color:#f92672">=</span> <span style="color:#a6e22e">Key</span>&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">key</span>: <span style="color:#66d9ef">Key</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">Value</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">allExplicit</span>: <span style="color:#66d9ef">KeyValuePair</span>&lt;<span style="color:#f92672">string</span><span style="color:#960050;background-color:#1e0010">,</span> <span style="color:#a6e22e">number</span>&gt; <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">key</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;rating&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">10</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">oneDefaulting</span>: <span style="color:#66d9ef">KeyValuePair</span>&lt;<span style="color:#f92672">string</span>&gt; <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">key</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;rating&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">value</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;ten&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 只提供了第一个类型实参，第二个默认和第一个相同
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误： Generic type &#39;KeyValuePair&lt;Key, Value&gt;&#39; requires between 1 and 2 type arguments.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">firstMissing</span>: <span style="color:#66d9ef">KeyValuePair</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">key</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;rating&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">10</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>需要注意的是，<strong><font color="#de7802">所有缺省类型参数都必须在类型参数列表的最后</font>，这与可选参数类似</strong>。也就是说，没有默认值的类型参数不能排在有默认值的类型参数之后。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 正常
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">inTheEnd</span>&lt;<span style="color:#f92672">First</span><span style="color:#960050;background-color:#1e0010">,</span> <span style="color:#a6e22e">Second</span><span style="color:#960050;background-color:#1e0010">,</span> <span style="color:#a6e22e">Third </span><span style="color:#f92672">=</span> <span style="color:#a6e22e">number</span><span style="color:#960050;background-color:#1e0010">,</span> <span style="color:#a6e22e">Fourth </span><span style="color:#f92672">=</span> <span style="color:#a6e22e">string</span>&gt;() {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 有默认值的类型参数放在了中间，会出现编译错误:Required type parameters may not follow optional type parameters.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">inTheMiddle</span>&lt;<span style="color:#f92672">First</span><span style="color:#960050;background-color:#1e0010">,</span> <span style="color:#a6e22e">Second </span><span style="color:#f92672">=</span> <span style="color:#a6e22e">boolean</span><span style="color:#960050;background-color:#1e0010">,</span> <span style="color:#a6e22e">Third </span><span style="color:#f92672">=</span> <span style="color:#a6e22e">number</span><span style="color:#960050;background-color:#1e0010">,</span> <span style="color:#a6e22e">Fourth</span>&gt;() {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h2 id="constrained-generic-types">Constrained Generic Types</h2>
<p>默认情况下，泛型的实参类型可以是任何类型：类、接口、基本类型、联合等。但是，有些函数只能用于有限的类型集。在泛型中，允许一个类型参数声明自己需要<code>extends</code>另一个类型，这就是类型约束。泛型类型约束的语法是在类型参数名称后加上<code>extends</code>关键字，然后再加上要约束它的类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">WithLength</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">length</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">logWithLength</span>&lt;<span style="color:#f92672">T</span> <span style="color:#a6e22e">extends</span> <span style="color:#a6e22e">WithLength</span>&gt;(<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">T</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Length: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">input</span>.<span style="color:#a6e22e">length</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">input</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">logWithLength</span>({<span style="color:#a6e22e">length</span>: <span style="color:#66d9ef">123</span>}) <span style="color:#75715e">// Length：123
</span></span></span></code></pre></div><h3 id="keyof-and-constrained-type-parameters">keyof and Constrained Type Parameters</h3>
<p>关键词<code>keyof</code>也可以用于泛型中的类型约束。将<code>extends</code>和<code>keyof</code>一起使用，可以将<code>key</code>限定在某个类型参数的所有<code>key</code>之内。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#66d9ef">get</span>&lt;<span style="color:#f92672">T</span><span style="color:#960050;background-color:#1e0010">,</span> <span style="color:#a6e22e">Key</span> <span style="color:#a6e22e">extends</span> <span style="color:#a6e22e">keyof</span> <span style="color:#a6e22e">T</span>&gt;(<span style="color:#a6e22e">container</span>: <span style="color:#66d9ef">T</span>, <span style="color:#a6e22e">key</span>: <span style="color:#66d9ef">Key</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">container</span>[<span style="color:#a6e22e">key</span>];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">roles</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">favorite</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Fargo&#34;</span>, <span style="color:#a6e22e">others</span><span style="color:#f92672">:</span> [<span style="color:#e6db74">&#34;Almost Famous&#34;</span>, <span style="color:#e6db74">&#34;Burn After Reading&#34;</span>, <span style="color:#e6db74">&#34;Nomadland&#34;</span>],};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">favorite</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">get</span>(<span style="color:#a6e22e">roles</span>, <span style="color:#e6db74">&#34;favorite&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">others</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">get</span>(<span style="color:#a6e22e">roles</span>, <span style="color:#e6db74">&#34;others&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Argument of type &#39;&#34;extras&#34;&#39; is not assignable to parameter of type &#39;&#34;favorite&#34; | &#34;others&#34;&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">missing</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">get</span>(<span style="color:#a6e22e">roles</span>, <span style="color:#e6db74">&#34;extras&#34;</span>);
</span></span></code></pre></div><h2 id="promises">Promises</h2>
<p><code>JavaScript</code>中的<code>Promise</code>表示<font color=red>仍在等待处理的事情</font>，例如网络请求。每个<code>Promise</code>都提供了注册回调的方法，以防待执行操作<code>resolve</code>（成功完成）或 <code>reject</code>（抛出异常）。</p>
<p><code>Promise</code>能够在任意值类型上表示类似地操作，这与<code>TypeScript</code>泛型非常契合。在<code>TypeScript</code>类型系统中，<code>Promises</code>使用<code>Promise</code>类表示，该类有一个类型参数，代表最终解析的值。</p>
<h3 id="creating-promises">Creating Promises</h3>
<p><code>Promise</code>类的构造器中只有单个参数，这个参数的类型取决于泛型<code>Promise</code>类中声明的类型参数，<code>Promise</code>类的简化版本大致如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">PromiseLike</span>&lt;<span style="color:#f92672">Value</span>&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>(<span style="color:#a6e22e">executor</span><span style="color:#f92672">:</span> (
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">resolve</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">Value</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">void</span>,
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">reject</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">reason</span>: <span style="color:#66d9ef">unknown</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">void</span>,
</span></span><span style="display:flex;"><span>                ) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">void</span>,
</span></span><span style="display:flex;"><span>    ) { 
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">/* ... */</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面的构造函数中，需要传入的是单个函数，该函数有两个入参，返回类型为<code>void</code>，每个入参又是一个函数。一般来说，要创建一个最终要与值解析的<code>Promise</code>，就必须明确声明<code>Promise</code>的类型参数。</p>
<p>通常需要显式声明泛型类<code>Promise</code>的类型实参，如果没有显式地标注类型实参，编译器则认为类型实参为<code>unknown</code>。向<code>Promise</code>构造函数明确提供类型实参，编译器会解析<code>Promise</code>实例的类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">resolvesUnknown</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Promise</span>((<span style="color:#a6e22e">resolve</span>) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">setTimeout</span>(() <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">resolve</span>(<span style="color:#e6db74">&#34;Done!&#34;</span>), <span style="color:#ae81ff">1000</span>);
</span></span><span style="display:flex;"><span>})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: Promise&lt;string&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">resolvesString</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Promise</span>&lt;<span style="color:#f92672">string</span>&gt;((<span style="color:#a6e22e">resolve</span>) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">setTimeout</span>(() <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">resolve</span>(<span style="color:#e6db74">&#34;Done!&#34;</span>), <span style="color:#ae81ff">1000</span>);
</span></span><span style="display:flex;"><span>});
</span></span></code></pre></div><p><code>Promise</code>的泛型方法<code>.then</code>方法引入了一个新的类型参数，代表<code>Promise</code>返回的<code>resolve</code>值。下面示例中，创建了一个<code>textEventually</code>的<code>Promise</code>（等待<code>1</code>秒后，<code>resolve</code>了一个<code>string</code>类型的值）。接着，创建了一个<code>lengthEventually</code>，等待一秒后<code>resolve</code>出一个<code>number</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// Type: Promise&lt;string&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">textEventually</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Promise</span>&lt;<span style="color:#f92672">string</span>&gt;((<span style="color:#a6e22e">resolve</span>) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">setTimeout</span>(() <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">resolve</span>(<span style="color:#e6db74">&#34;Done!&#34;</span>), <span style="color:#ae81ff">1000</span>);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: Promise&lt;number&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">lengthEventually</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">textEventually</span>.<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">text</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">text</span>.<span style="color:#a6e22e">length</span>)
</span></span></code></pre></div><h3 id="async-functions">Async Functions</h3>
<p>在<code>JavaScript</code>中<font color=red>任何以<code>async</code>关键字声明的函数都返回一个<code>Promise</code></font>。如果在<code>async</code>函数中返回的值不是<code>Thenable</code>的（一个对象能使用<code>.then</code>方法，几乎总是一个<code>Promise</code>），<font color="#de7802">返回值会被封装在一个<code>Promise</code>中，就像调用了<code>Promise.resolve</code>一样</font>。<code>TypeScript</code>可以识别这一点，并会推断<code>async</code>函数的返回类型始终是<code>Promise</code>的。</p>
<p>下面示例代码中，函数<code>lengthAfterSecond</code>返回一个<code>Promise&lt;number&gt;</code>。因为<code>lengthImmediately</code>标记为<code>async</code>的，所以它的返回类型也被推为<code>Promise&lt;number&gt;</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">lengthAfterSecond</span>(<span style="color:#a6e22e">text</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">await</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Promise</span>((<span style="color:#a6e22e">resolve</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">setTimeout</span>(<span style="color:#a6e22e">resolve</span>, <span style="color:#ae81ff">1000</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">text</span>.<span style="color:#a6e22e">length</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: (text: string) =&gt; Promise&lt;number&gt; 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">lengthImmediately</span>(<span style="color:#a6e22e">text</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">text</span>.<span style="color:#a6e22e">length</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>因此，在<code>async</code>函数上手动声明的任何返回类型都必须是<code>Promise</code>类型，即使在函数的实现中没有明确提及任何<code>Promise</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">givesPromiseForString</span>()<span style="color:#f92672">:</span> <span style="color:#a6e22e">Promise</span>&lt;<span style="color:#f92672">string</span>&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;Done!&#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 函数声明时使用了async关键字但返回类型的标注不是promise，会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">givesString</span>()<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 编译错误: The return type of an async function or method must be 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// the global Promise&lt;T&gt; type. Did you mean to write &#39;Promise&lt;string&gt;&#39;? 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;Done!&#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="using-generics-right">Using Generics Right</h2>
<p>如前面的<code>Promise&lt;Value&gt;</code>实现一样，虽然泛型可在代码中描述类型提供很大的灵活性，但它们也会很快变得相当复杂。刚接触<code>TypeScript</code>时可能经常会经历一个过度使用泛型的阶段，以至于代码读起来令人困惑。<code>TypeScript</code>的最佳实践通常是在必要时才使用泛型。</p>
<h3 id="the-golden-rule-of-generics">The Golden Rule of Generics</h3>
<p>有一个<font color="#de7802">快速测试方法可以帮助确定函数是否需要类型参数，那就是类型参数至少要使用两次</font>。泛型描述的是类型之间的关系，如果一个泛型类型参数只出现在一次，它就不可能定义多个类型之间的关系。</p>
<p>在泛型函数中，每个类型参数都应该用于一个形参，还至少用于一个其它参数和/或函数的返回类型。下面示例中，泛型函数<code>logInput</code>只使用了<code>Input</code>类型形参一次：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">logInput</span>&lt;<span style="color:#f92672">Input</span> <span style="color:#a6e22e">extends</span> <span style="color:#a6e22e">string</span>&gt;(<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">Input</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Hi!&#34;</span>, <span style="color:#a6e22e">input</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在函数体中，函数<code>logInput</code>中的类型参数后没有做任何操作，例如返回或声明更多参数。因此，声明<code>Input</code>类型参数的用处不大。可以重写<code>logInput</code>，不需要声明为泛型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">logInput</span>(<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Hi!&#34;</span>, <span style="color:#a6e22e">input</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="declaration-files">Declaration Files</h1>
<p>尽管用<code>TypeScript</code>编写代码很棒，但有时还需要能够在<code>TypeScript</code>项目中处理原始<code>JavaScript</code>文件。许多软件包都是使用<code>JavaScript</code>而不是<code>TypeScript</code>编写的。即便是使用<code>TypeScript</code>编写的软件包也是以<code>JavaScript</code>文件的形式发布的。</p>
<p>此外，<code>TypeScript</code>项目还需要一种方法来获知环境特定功能（如全局变量和<code>API</code>）的<code>type shapes</code>。例如，在<code>Node.js</code>中运行的项目可能可以访问浏览器中不可用的内置<code>Node</code>模块，反之亦然。</p>
<p><code>TypeScript</code><font color="#de7802">允许将类型声明与其实现分开</font>。类型声明通常放在以<code>.d.ts</code>扩展名结尾的文件中，称为声明文件。声明文件通常放在项目中，随项目编译的<code>npm</code>包一起构建和发布，或作为独立的<code>typings</code>包共享。</p>
<h2 id="declaration-files-1">Declaration Files</h2>
<p><code>.d.ts</code>文件的工作原理与<code>.ts</code>文件类似，<span style="background:#f8d9c3">但有一个明显的限制，不允许包含运行时代码</span>。<code>.d.ts</code>文件只包含对可用运行时值、接口、模块和一般类型的描述。<font color="#de7802">它们不能包含任何可编译为<code>JavaScript</code>的运行时代码</font>。可以像导入其它<code>TypeScript</code>源文件一样导入声明文件。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// types.d.ts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Character</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">catchphrase?</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// index.ts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">import</span> {<span style="color:#a6e22e">Character</span>} <span style="color:#66d9ef">from</span> <span style="color:#e6db74">&#34;./types&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">character</span>: <span style="color:#66d9ef">Character</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">catchphrase</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Yee-haw!&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Sandy Cheeks&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>在<code>TypeScript</code>里，像声明一些外部模块、全局变量、或者在<code>.d.ts</code>（类型声明文件）里去描述一些已有代码（比如<code>JavaScript</code>库）的类型信息等场景，就是所谓的环境上下文。声明文件创建所谓的<code>ambient context</code>（上下文），表示在代码中只能声明类型而不能声明值的区域。</p>
<h2 id="declaring-runtime-values">Declaring Runtime Values</h2>
<p>虽然定义文件不能创建函数或变量等运行时值，但它们可以使用<code>declare</code>关键字声明这些构造的存在。这样做可以告知类型系统，某些外部因素（比如网页中的<code>&lt;script&gt;</code>标签）已经以特定的类型创建了该名称下的（相应）值。通过使用<code>declare</code>关键字在定义文件里进行声明，其意义在于让类型系统 “知晓”，虽然定义文件没去创建相应的值，但是在别的地方（像网页中通过<code>&lt;script&gt;</code>标签引入外部脚本这种外部手段）已经创建好了对应名称并且有着特定类型的一些值了。</p>
<p>这样类型系统就能基于这些声明去做类型检查等相关工作，确保代码在类型层面的正确性和兼容性等，避免出现类型不匹配之类的错误。 例如，在<code>TypeScript</code>项目中如果要使用某个已有的、没有自带类型声明的<code>JavaScript</code>库，就可以通过编写定义文件用<code>declare</code>关键字去声明库中暴露出来的函数、变量等的类型，以便<code>TypeScript</code>能正确处理对这些内容的使用情况。</p>
<p>使用<code>declare</code>声明变量的语法与普通变量声明的语法相似，只是不允许使用初始值。下面示例代码段成功地声明了一个已声明的变量，但在试图为初始化变量赋值时却出现了类型错误。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 合法声明
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">declare</span> <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">declared</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 不合法声明，会出现编译错误，因为不能包括可执行的代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">declare</span> <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">initializer</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Wanda&#34;</span>;
</span></span></code></pre></div><p>函数和类的声明也与普通的变量相似，但<font color="#de7802">在声明时不能有函数体或方法体</font>，即不能有相关实现。下面示例代码中的<code>canGrantWish</code>函数和方法在没有函数体的情况下的声明是正确的，但<code>grantWish</code>函数因为有了函数体而出现语法错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 正常，因为没有函数体
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">declare</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">canGrantWish</span>(<span style="color:#a6e22e">wish</span>: <span style="color:#66d9ef">string</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">boolean</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 会出现编译错误，因为有函数体
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">declare</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">grantWish</span>(<span style="color:#a6e22e">wish</span>: <span style="color:#66d9ef">string</span>) { <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Fairy</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 正常
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">canGrantWish</span>(<span style="color:#a6e22e">wish</span>: <span style="color:#66d9ef">string</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">boolean</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 出现编译错误，因为里面有方法体
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">grantWish</span>(<span style="color:#a6e22e">wish</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>对于环境上下文（<code>ambient context</code>）中声明函数和变量时，隐式<code>any</code>规则同样适用。由于在环境上下文里没办法通过函数体内部的逻辑、或者变量初始值这些常规方式来让<code>TypeScript</code>编译器推断出准确类型，所以只能通过手动添加显式类型标注的方式，明确告诉编译器这个函数的参数、返回值是什么类型，变量又是什么类型等，这样才能避免它们被默认当作<code>any</code>类型去处理。</p>
<p>尽管在<code>.d.ts</code>中使用<code>declare</code>关键字进行类型声明最为常见，但在声明文件之外也可以使用<code>declare</code>关键字。模块或脚本文件中也可以使用<code>declare</code>，当一个全局可用的变量仅打算在该文件中使用时，这么做可能就很有用了。下面示例代码中，变量<code>myGlobalValue</code>定义在一个<code>index.ts</code>文件中，因此可以在这个文件中使用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// index.ts 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">declare</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">myGlobalValue</span>: <span style="color:#66d9ef">string</span>; 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">myGlobalValue</span>); <span style="color:#75715e">// Ok
</span></span></span></code></pre></div><p>当存在某个变量，<font color="#de7802">它在全局范围内是可以被访问到的（也就是全局可用变量），但又只想让它在当前这个特定的文件中使用</font>，不想让它影响到项目里的其他文件，此时在这个文件里使用<code>declare</code>关键字来声明这个变量就很合适。</p>
<p>例如，在一个单独的模块文件<code>moduleA.ts</code>中，有一个全局变量<code>localGlobalVar</code>，它只是在<code>moduleA.ts</code>内部用于一些临时的计算或者逻辑处理并且和其它模块没有关系，就可以写成<code>declare var localGlobalVar: string;</code>这种形式进行变量声明，这样既能体现它是全局可用的（在本文件内的全局概念），又能限定它的使用范围就在这个文件中，避免和其它模块产生不必要的冲突或者混淆。</p>
<p>需要注意的是，仅管在<code>.d.ts</code>文件中，无论是否有<code>declare</code>，都允许接口的类型声明。<font color="#de7802">而函数或变量等在<code>runtime constructs</code>没有<code>declare</code>的情况下会出现编译错误</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// index.d.ts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Writer</span> {} <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">declare</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Writer</span> {} <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">declare</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">fullName</span>: <span style="color:#66d9ef">string</span>; <span style="color:#75715e">// Ok: type is the primitive string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">declare</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">firstName</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Liz&#34;</span>; <span style="color:#75715e">// Ok: type is the literal &#34;value&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Error: Top-level declarations in .d.ts files must 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// start with either a &#39;declare&#39; or &#39;export&#39; modifier.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">lastName</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Lemon&#34;</span>; 
</span></span></code></pre></div><h3 id="global-values">Global Values</h3>
<p>因为<font color="#de7802">没有导入或导出语句的<code>TypeScript</code>文件被视为脚本而非模块</font>。因此，在其中声明的类型在全局范围内可用。在没有导入或导出语句的定义文件可以利用这种特性在全局范围内声明类型。全局定义文件对于声明应用程序中所有文件都可用的全局类型或变量特别有用。</p>
<p>下面代码中，<code>globals.d.ts</code>文件全局声明了一个<code>const version: string</code>。因此，尽管没有主动导入<code>globals.d.ts</code>中的<code>version</code>，在<code>version.ts</code>文件也能引用全局的<code>version</code>变量：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// globals.d.ts 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">declare</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">version</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// version.ts 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">logVersion() {</span> 
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Version: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">version</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>); <span style="color:#75715e">// Ok 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>全局声明值最常用于使用全局变量的浏览器应用程序中。虽然大多数现代网络框架一般都使用<code>ECMAScript</code>模块等较新的技术，但全局变量存储仍然非常有用，尤其是在较小的项目中。</p>
<p>如果发现无法自动访问<code>.d.ts</code>文件中声明的全局类型，需要检查<code>.d.ts</code>文件是否导入和导出了任何内容。即使是一次导出也会导致整个文件不再在全局范围内可用。</p>
<h3 id="global-interface-merging">Global Interface Merging</h3>
<p><font color="#de7802">变量并不是类型系统中唯一可以设置为全局的东西</font>，许多类型声明都是为全局API和值而存在的。因为接口会与其它同名的接口合并，所以在全局脚本上下文中声明接口（如不包含任何<code>import</code>或<code>export</code>语句的<code>.d.ts</code>文件）会在全局范围内对该接口进行补充。</p>
<p>例如，依赖于服务端设置的全局变量的网页应用可能希望将其声明为存在于全局的<code>Window </code>接口上。接口合并将允许<code>types/window.d.ts</code>这样的文件声明一个存在于<code>Window</code>类型全局<code>window</code>变量：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span>&lt;<span style="color:#f92672">script</span> <span style="color:#a6e22e">type </span><span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;text/javascript&#34;</span> &gt;
</span></span><span style="display:flex;"><span>window.<span style="color:#a6e22e">myVersion</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;3.1.1&#34;</span>;
</span></span><span style="display:flex;"><span>&lt;/<span style="color:#f92672">script</span>&gt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// types/window.d.ts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Window</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">myVersion</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// index.ts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">logWindowVersion() {</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Window version is: </span><span style="color:#e6db74">${</span>window.<span style="color:#a6e22e">myVersion</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>    window.<span style="color:#a6e22e">alert</span>(<span style="color:#e6db74">&#34;Built-in window types still work! Hooray!&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="global-augmentations">Global Augmentations</h3>
<p>在<code>.d.ts</code>文件中避免使用<code>import</code>或<code>export</code>语句，以保持该文件的全局范围作用域并不总是可行的。有时，<code>Mudule</code>文件中声明的类型会在全局范围内使用。</p>
<p>在这种情况下，<code>TypeScript</code>允许使用一种语法来声明代码块的全局性。这样做会将该代码块的内容标记为全局上下文，即使其上下文并非如此：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// types.d.ts 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// (module context)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">declare</span> <span style="color:#66d9ef">global</span> { 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// (global context) 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// (module context)
</span></span></span></code></pre></div><p>如下所示，<code>type/data.d.ts</code>文件导出了一个<code>Data</code>接口，随后被<code>types/globals.d.ts</code>和运行时<code>index.ts</code>导入该接口：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// types/data.d.ts 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Data</span> { 
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">version</span>: <span style="color:#66d9ef">string</span>; 
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// types/globals.d.ts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">import</span> { <span style="color:#a6e22e">Data</span> } <span style="color:#66d9ef">from</span> <span style="color:#e6db74">&#34;./data&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">declare</span> <span style="color:#66d9ef">global</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">globallyDeclared</span>: <span style="color:#66d9ef">Data</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">declare</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">locallyDeclared</span>: <span style="color:#66d9ef">Data</span>;
</span></span></code></pre></div><p>这样，<code>index.ts</code>就可以访问<code>globallyDeclared</code>变量，而无需导入，但仍需要导入<code>Data</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// index.ts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">import</span> { <span style="color:#a6e22e">Data</span> } <span style="color:#66d9ef">from</span> <span style="color:#e6db74">&#34;./types/data&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">logData</span>(<span style="color:#a6e22e">data</span>: <span style="color:#66d9ef">Data</span>) { <span style="color:#75715e">// Ok 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Data version is: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">data</span>.<span style="color:#a6e22e">version</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>); 
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">logData</span>(<span style="color:#a6e22e">globallyDeclared</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">logData</span>(<span style="color:#a6e22e">locallyDeclared</span>);
</span></span></code></pre></div><p>如何让全局声明和模块声明很好地结合在一起是一件棘手的事情。正确使用<code>TypeScript</code>的<code>declare</code>和<code>global</code>关键字可以描述哪些类型定义在项目中全局可用。</p>
<h2 id="built-in-declarations">Built-In Declarations</h2>
<p>既然已经了解了声明是如何工作的，那么是时候揭开它在<code>TypeScript</code>中的神秘面纱了：它一直在为类型检查提供动力。全局对象（如数组（<code>Array</code>）、函数（<code>Function</code>）、映射（<code>Map</code>）和集合（<code>Set</code>）等）是类型系统需要了解的构造示例，但并未在我们的代码中声明。它们由代码要运行的<code>runtime</code>提供，例如<code>Deno、Node、Web</code>浏览器等。</p>
<h3 id="library-declarations">Library Declarations</h3>
<p>所有<code>JavaScript</code>运行时都存在的<code>Array</code>和<code>Function</code>等内置全局对象都是在文件中声明，文件名如<code>lib.[target].d.ts</code>。<code>target</code>是项目所针对的<code>JavaScript</code>的最小支持版本，如<code>ES5、ES2020</code>或<code>ESNext</code>。</p>
<p>内置库定义文件（或称<code>lib</code>文件）相当庞大，因为它们代表<code>JavaScript</code>内置<code>API</code>的全部内容。例如，内置数组类型的成员由一个全局数组<code>interface</code>表示，该接口的开头是这样的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// lib.es5.d.ts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> Array&lt;<span style="color:#f92672">T</span>&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Gets or sets the length of the array. This is a number one higher than the highest index in the array.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">length</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Returns a string representation of an array.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">toString</span>()<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Returns a string representation of an array. The elements are converted to string using their toLocaleString methods.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">toLocaleString</span>()<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>Lib</code>文件作为<code>TypeScript npm</code>软件包的一部分发布，可以在软件包中找到它们，路径类似<code>node_modules/typescript/lib/lib.es5.d.ts</code>。对于<code>VS Code</code>等使用自己打包的<code>TypeScript</code>版本进行代码类型检查的集成开发环境，可以右键单击代码中的内置方法（如数组的<code>forEach</code>），然后选择<code>“Go to Definition”</code>等选项，找到正在使用的<code>lib</code>文件。</p>
<h3 id="library-targets">Library targets</h3>
<p>默认情况下，<code>TypeScript</code>将根据提供给<code>tsc CLI</code>和/或项目<code>tsconfig.json</code>的目标设置（默认为<code>“es5”</code>），包含相应的<code>lib</code>文件。新版本<code>JavaScript</code>的连续<code>lib</code>文件会使用接口合并功能相互构建。例如，<code>ES2015</code>中添加的 <code>EPSILON</code>和<code>isFinite</code>等静态<code>Number</code>成员都列在<code>lib.es2015.d.ts</code>中。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">NumberConstructor</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * The value of Number.EPSILON is the difference between 1 and the smallest value greater than 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * that is representable as a Number value, which is approximately:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 2.2204460492503130808472633361816 x 10‍−‍16.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">readonly</span> <span style="color:#a6e22e">EPSILON</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Returns true if passed value is finite.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Unlike the global isFinite, Number.isFinite doesn&#39;t forcibly convert the parameter to a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * number. Only finite values of the type number, result in true.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param number A numeric value.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    isFinite(<span style="color:#66d9ef">number</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">unknown</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">boolean</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Returns true if the value passed is an integer, false otherwise.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param number A numeric value.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">isInteger</span>(<span style="color:#66d9ef">number</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">unknown</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">boolean</span>;
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>TypeScript</code>项目将包括<code>JavaScript</code>所有版本目标的<code>lib</code>文件，直至其最小目标。例如，目标为<code>es2016</code>的项目将包含<code>lib.es5.d.ts、lib.es2015.d.ts</code>和<code>lib.es2016.d.ts</code>。</p>
<h3 id="dom-declarations">DOM Declarations</h3>
<p>除了<code>JavaScript</code>语言本身，最常被引用的类型声明领域是网络浏览器。网络浏览器类型通常被称为<code>DOM</code>类型，涵盖了<code>localStorage</code>等<code>API</code>和<code>HTMLElement</code>等主要在网络浏览器中可用的类型。<code>DOM</code>类型与其它<code>lib.*.d.ts</code>声明文件一起存储在<code>lib.dom.d.ts</code>文件中。</p>
<p>全局<code>DOM</code>类型和许多内置全局一样，通常用全局<code>interface</code>来描述。例如，用于本地存储（<code>localStorage</code>）和会话存储（<code>sessionStorage</code>）的存储接口大致是这样开始的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Storage</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Returns the number of key/value pairs.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Storage/length)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">readonly</span> <span style="color:#a6e22e">length</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Removes all key/value pairs, if there are any.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Dispatches a storage event on Window objects holding an equivalent Storage object.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Storage/clear)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">clear</span>()<span style="color:#f92672">:</span> <span style="color:#66d9ef">void</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Returns the current value associated with the given key, or null if the given key does not exist.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Storage/getItem)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">getItem</span>(<span style="color:#a6e22e">key</span>: <span style="color:#66d9ef">string</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在未覆盖<code>lib</code>编译器选项的项目中，<code>TypeScript</code>默认包含<code>DOM</code>类型。这有时会让开发人员感到困惑，因为他们无法访问类型系统声称存在的<code>document</code>和<code>localStorage</code>等全局<code>API</code>。</p>
<h2 id="module-declarations">Module Declarations</h2>
<p>声明文件的另一个重要特点是可以描述模块的<code>shape</code>。可以在模块的字符串名称前使用<code>declare</code>关键字，以告知类型系统该模块的内容。下面<code>my-example-lib</code>模块在<code>modules.d.ts</code>声明脚本文件中声明，然后在<code>index.ts</code>文件中使用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// modules.d.ts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">declare</span> <span style="color:#a6e22e">module</span> <span style="color:#e6db74">&#34;my-example-lib&#34;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">export</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// index.ts 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">import</span> {<span style="color:#a6e22e">value</span>} <span style="color:#66d9ef">from</span> <span style="color:#e6db74">&#34;my-example-lib&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">value</span>); <span style="color:#75715e">// Ok
</span></span></span></code></pre></div><p>在我们的代码中，不会经常用到<code>declare module</code>。它主要用于通配符<code>module</code>声明和后面涉及的<code>package types</code>。</p>
<h3 id="wildcard-module-declarations">Wildcard Module Declarations</h3>
<p>模块声明的一个常见用途是告诉网络应用，某个特定的非<code>JavaScript/TypeScript</code>文件扩展名可以导入到代码中。模块声明可以包含单个<code>*</code>通配符，表示与该模式匹配的任何模块看起来都是一样的。</p>
<p>例如，许多<code>Web</code>项目（如<code>create-react-app</code>和<code>create-next-app</code>等流行的<code>React</code>启动程序中预置的项目）都支持<code>CSS</code>模块，以便将<code>CSS</code>文件中的样式导入为可在运行时使用的对象。它们可能会使用以下模式定义模块：<code>&quot;*.module.css&quot;</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// styles.d.ts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">declare</span> <span style="color:#a6e22e">module</span> <span style="color:#e6db74">&#34;*.module.css&#34;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">styles</span><span style="color:#f92672">:</span> { [<span style="color:#a6e22e">i</span>: <span style="color:#66d9ef">string</span>]<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span> };
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">export</span> <span style="color:#66d9ef">default</span> <span style="color:#a6e22e">styles</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// component.ts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">import</span> <span style="color:#a6e22e">styles</span> <span style="color:#66d9ef">from</span> <span style="color:#e6db74">&#34;./styles.module.css&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">styles</span>.<span style="color:#a6e22e">anyClassName</span>; <span style="color:#75715e">// Type: string
</span></span></span></code></pre></div><p>使用通配符模块来表示本地文件并不完全安全。<code>TypeScript</code>没有提供确保导入模块路径与本地文件匹配的机制。有些项目会使用<code>Webpack</code>等构建系统和/或从本地文件生成<code>.d.ts</code>文件，以确保导入的模块路径匹配。</p>
<h2 id="package-types">Package Types</h2>
<p>现在已经了解了如何在项目中声明类型，是时候介绍在包之间使用类型了。使用<code>TypeScript</code>编写的项目通常仍会分发包含编译后<code>.js</code>输出的包。它们通常使用<code>.d.ts</code>文件来声明这些<code>JavaScript</code>文件背后的<code>TypeScript</code>类型系统形状。</p>
<h3 id="declaration">declaration</h3>
<p><code>TypeScript</code>提供了一个<code>declaration</code>选项，可为输入文件创建<code>.d.ts</code>输出和<code>JavaScript</code>输出。例如，给定以下 <code>index.ts</code>源文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// index.ts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">greet</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">text</span>: <span style="color:#66d9ef">string</span>) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Hello, </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">text</span><span style="color:#e6db74">}</span><span style="color:#e6db74">!`</span>);
</span></span><span style="display:flex;"><span>}<span style="color:#960050;background-color:#1e0010">；</span>
</span></span></code></pre></div><p>使用<code>declaration</code>，<code>es2015</code>的某个<code>module</code>，以及<code>es2015</code>的<code>target</code>，下面输出将会产生：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// index.d.ts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">declare</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">greet</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">text</span>: <span style="color:#66d9ef">string</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">void</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// index.js
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">greet</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">text</span>) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Hello, </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">text</span><span style="color:#e6db74">}</span><span style="color:#e6db74">!`</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>自动生成的<code>.d.ts</code>文件是项目创建供用户使用的类型定义的最佳方式。一般建议，大多数使用<code>TypeScript</code>编写的软件包在生成<code>.js</code>文件输出时，也应将<code>.d.ts</code>与这些文件捆绑在一起。</p>
<h3 id="dependency-package-types">Dependency Package Types</h3>
<p><code>TypeScript</code>能够检测并利用捆绑在项目的<code>node_modules</code>依赖项中的<code>.d.ts</code>文件。这些文件将告知类型系统该包导出的类型形状，就像它们是在同一项目中编写或用<code>declare</code>模块块声明的一样。一个典型的<code>npm</code>模块如果自带<code>.d.ts</code>声明文件，其文件结构可能类似于这样：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#a6e22e">lib</span><span style="color:#f92672">/</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">index</span>.<span style="color:#a6e22e">js</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">index</span>.<span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">ts</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">package</span>.<span style="color:#a6e22e">json</span>
</span></span></code></pre></div><h1 id="enum">Enum</h1>
<p>因为<code>enum</code>编译后是一个对象，所以*<font color="#de7802">不能有与它同名的变量，对象，函数和类等</font>*。如果在相同作用域内存在与枚举同名的变量、对象、函数或类，将会出现编译错误。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 下面代码因为枚举和变量名重复了，会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Enum declarations can only merge with namespace or other enum declarations.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Test1</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Local</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;local&#39;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Remote</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;remote&#39;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 因为有和枚举同名的常量，会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Enum declarations can only merge with namespace or other enum declarations
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">Test1</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;890&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误，因为枚举和类名重复，会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Enum declarations can only merge with namespace or other enum declarations.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Test2</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span>,  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">B</span>  
</span></span><span style="display:flex;"><span>}  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Test2</span> {  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 类的定义部分
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h2 id="property">property</h2>
<p>枚举的<font color="#de7802">成员不要求强制赋初始值，若没有初始值，默认从<code>0</code>开始逐一增<code>1</code>，按顺序为每个成员赋值</font>。下面第一个示例中，枚举成员对应值分别为<code>0，1，2</code>。第二段示例代码中，枚举成员对应值为<code>0,4,5</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">B</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">C</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">Foo</span>.<span style="color:#a6e22e">A</span>, <span style="color:#a6e22e">Foo</span>.<span style="color:#a6e22e">B</span>, <span style="color:#a6e22e">Foo</span>.<span style="color:#a6e22e">C</span>) <span style="color:#75715e">// 0 1 2
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>    A,
</span></span><span style="display:flex;"><span>    B = <span style="color:#ae81ff">4</span>,
</span></span><span style="display:flex;"><span>    C,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>console.log(Foo.A, Foo.B, Foo.C) <span style="color:#75715e">// 0 4 5</span>
</span></span></code></pre></div><p>与其它语言不同的是，<code>enum</code>中<font color="#de7802">属性的值可以是小数</font>。若某个成员没有初始值，则其后的值也依次在上一个值的基础上<code>+1</code>。下面示例代码，属性的值依次是<code>0.12,1.12,2.12</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.12</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">B</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">C</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">Foo</span>.<span style="color:#a6e22e">A</span>, <span style="color:#a6e22e">Foo</span>.<span style="color:#a6e22e">B</span>, <span style="color:#a6e22e">Foo</span>.<span style="color:#a6e22e">C</span>) <span style="color:#75715e">// 0.12 1.12 2.12
</span></span></span></code></pre></div><p>但<code>enum</code>属性（成员）的值<font color=red>不能是<code>BigInt</code>类型</font>，否则会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Type &#39;bigint&#39; is not assignable to type &#39;number&#39; as required for computed enum member values.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span><span style="color:#a6e22e">n</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>不同于<code>Swift</code>，在<code>TypeScript</code>中<code>enum</code><font color="#de7802">不同属性（成员）对应的值可以相同，但属性名一定不能相同</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.12</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">B</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.1</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">C</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.12</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果只设置第一个属性的值，后面成员的值就会从这个值开始依次递增（在上一个值的基础上自动<code>+1</code>）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Color</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Red</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">7</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Green</span>, <span style="color:#75715e">// 8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">Blue</span>, <span style="color:#75715e">// 9
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">Color</span>.<span style="color:#a6e22e">Blue</span>) 
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">9</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 或者
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Color</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Red</span>, <span style="color:#75715e">// 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">Green</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">7</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Blue</span>, <span style="color:#75715e">// 8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">Color</span>.<span style="color:#a6e22e">Blue</span>, <span style="color:#a6e22e">Color</span>.<span style="color:#a6e22e">Red</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">8</span> <span style="color:#ae81ff">0</span>
</span></span></code></pre></div><p><code>enum</code>所有属性对应的值都是只读的，不能重新被赋值。下面实例代码中，因为重新赋值枚举中的属性<code>Red</code>，会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Color</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Red</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Green</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Blue</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译报错:Cannot assign to &#39;Blue&#39; because it is a read-only property.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">Color</span>.<span style="color:#a6e22e">Red</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>; 
</span></span></code></pre></div><p>为了强调这一点，通常定义枚举时在<code>enum</code>关键字前面加上<code>const</code>修饰，表示该枚举是常量，不能再次被赋值。加上<code>const</code>还有一个好处，编译为<code>JavaScript</code>代码后，<font color="#de7802">枚举的成员会被替换成对应的值，可以提升性能</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Color</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Red</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Green</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Blue</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>实际上，普通枚举会被编译成<code>JavaScript</code>对象，而<code>const enum</code>在编译时会被完全内联（<code>inline</code>），不会生成任何<code>JavaScript</code>代码。<font color="#de7802">减少生成的代码体积，能够提升运行时性能</font>。此外，因为普通枚举在运行时生成一个全局对象，可能与其它代码产生命名冲突，<code>const enum</code>不会生成任何运行时标识符，完全通过内联值工作。</p>
<p><code>enum</code>成员的值也可以是计算属性。但需要注意的是，<font color="#de7802">如果定义枚举时在关键字<code>enum</code>前添加了<code>const</code>修饰符，就不能再使用计算属性定义其中的成员</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Bool</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">No</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">123</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 非const枚举可以使用计算属性
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">Yes</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>(),
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">numb</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">12</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 正常
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Test</span> {
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">No</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">123</span>,
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">Yes</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">+</span> <span style="color:#a6e22e">numb</span>,
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">Third</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">getNum</span>(<span style="color:#ae81ff">12</span>)
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getNum</span>(<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span> {
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">return</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">+</span> <span style="color:#a6e22e">x</span>
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// const enum member initializers must be constant expressions.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Test1</span> {
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">No</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">123</span>,
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">Yes</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">+</span> <span style="color:#a6e22e">numb</span>,
</span></span><span style="display:flex;"><span> }
</span></span></code></pre></div><p><code>enum</code>成员的值除了设置为<code>number</code>，还可以设置为<code>string</code>类型。也就是说，<code>enum</code>也可以作为一组字符串的集合，示例如下所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Direction</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Up</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;UP&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Down</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;DOWN&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Left</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;LEFT&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Right</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;RIGHT&#34;</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>需要注意的是，<em><font color="#de7802">字符串枚举的所有成员都必须显式设置对应值</font></em>。如果成员值没有显式设置为<code>string</code>，则值默认为<code>number</code>的，且其<font color="#31859b">位置必须放在字符串成员之前</font>。也就是说，在枚举定义时，<font color=red>一旦设置了字符串的成员，其后的成员一定要赋初值，否则会出现编译错误</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span>, <span style="color:#75715e">// 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">B</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">C</span>, <span style="color:#75715e">// 报错 Enum member must have initializer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p><code>enum</code>成员<font color="#de7802">可以是字符串和数值的混合，如果要使用默认的数值，则成员必需放在字符串值成员之前</font>。下面定义的枚举<code>Foo</code>第一个成员使用了默认的<code>number</code>，然后是<code>string</code>，再是<code>number</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Foo</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">zero</span>,  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">One</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;One&#34;</span>,  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Two</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Two&#34;</span>,  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Three</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>,  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Four</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>,  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>enum</code>的成员<font color="#de7802">除了<code>number</code>和<code>string</code>，不允许使用其它类型值。</font>需要特别注意的是，<em><font color=red>若变量类型是字符串的枚举，不能使用字符串直接赋值该变量</font></em>，这跟数值<code>enum</code>变量不一样。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Enum</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">One</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;One&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Two</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Two&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Three</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Four</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">test</span>(<span style="color:#a6e22e">a</span>: <span style="color:#66d9ef">Enum</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">a</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">test</span>(<span style="color:#ae81ff">3</span>) <span style="color:#75715e">// 正常
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误:Argument of type &#39;&#34;One&#34;&#39; is not assignable to parameter of type &#39;Enum&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">test</span>(<span style="color:#e6db74">&#34;One&#34;</span>) 
</span></span></code></pre></div><p>还需要注意的是，<code>enum</code>的<font color="#de7802">字符串类型成员的值不能使用运行时才能计算的表达式赋值</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">MyEnum</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;one&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 使用表达式时会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// Type &#39;string&#39; is not assignable to type &#39;number&#39; as required for computed enum member values. 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">B</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;T&#34;</span>, <span style="color:#e6db74">&#34;w&#34;</span>, <span style="color:#e6db74">&#34;o&#34;</span>].<span style="color:#a6e22e">join</span>(<span style="color:#e6db74">&#34;&#34;</span>),
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">MyEnum</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;one&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// Type &#39;string&#39; is not assignable to type &#39;number&#39; as required for computed enum member values.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">B</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;T&#34;</span>.<span style="color:#a6e22e">repeat</span>(<span style="color:#ae81ff">12</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 下面是正常的，因为&#34;T&#34; + &#34;B&#34;编译时就能确定值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">MyEnum</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;one&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">B</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;T&#34;</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;B&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="merge">merge</h2>
<p>同名的<code>enum</code>可以合并，但有一些需要注意的地方，首先是<font color="#de7802">合并时不能有同名的成员</font>（或被称为属性），否则会出现编译报错：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 因为有同名的属性会出现编译错误:Duplicate identifier &#39;A&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>同名<code>enum</code>合并时，<font color="#de7802">只允许同名枚举的某一个定义中的第一个成员省略初始值</font>(不能同时第一个成员省略)，否则会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：In an enum with multiple declarations, only one declaration can omit an initializer for its first enum element.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">B</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 下面定义同名枚举的方式是正确的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 因为仅有一个枚举定义的第一个成员省略了值，所以不会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">B</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">12</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">C</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>同名<code>enum</code>合并的另一个限制，所有枚举定义<font color=red>必须同为<code>const</code>或者非<code>const</code>，不允许混合使用</font>，否则会出现编译错误。同名枚举合并的最大用处是补充外部定义的<code>enum</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Enum declarations can only merge with namespace or other enum declarations.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">B</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="reverse-map">reverse map</h2>
<p>枚举的反向映射，是指通过枚举属性的值获取到属性名，但*<font color=red>仅限于非<code>const</code>的<code>number</code>类型的枚举</font>*：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">B</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">C</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">Foo</span>[<span style="color:#ae81ff">3</span>], <span style="color:#a6e22e">Foo</span>[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;C&#39;</span>) <span style="color:#75715e">// undefined true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 如果是const会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">B</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">C</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：A const enum member can only be accessed using a string literal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">Foo</span>[<span style="color:#ae81ff">3</span>], <span style="color:#a6e22e">Foo</span>[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;C&#39;</span>)
</span></span></code></pre></div><p>因为枚举中不同属性名的属性值可以相同，所以在使用反向映射时，<font color="#de7802">相同值的反向映射会取到在枚举定义时最后一个值对应的属性</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">B</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">C</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">D</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Foo[1]拿到的反向映射值为D
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">Foo</span>[<span style="color:#ae81ff">3</span>], <span style="color:#a6e22e">Foo</span>[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;C&#39;</span>, <span style="color:#a6e22e">Foo</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;A&#39;</span>) 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">undefined</span> <span style="color:#66d9ef">true</span> <span style="color:#66d9ef">false</span>
</span></span></code></pre></div><p>枚举的反向映射只发生在数值成员上。<font color="#f79646">对于字符串成员值的枚举，不存在反向映射</font>，因为字符串枚举编译后只有一组赋值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Foo</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>,  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">B</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>,  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">C</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>,  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">D</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;CHEN&#39;</span>,  
</span></span><span style="display:flex;"><span>}  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误:Element implicitly has an &#39;any&#39; type because index expression is not of type &#39;number&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">Foo</span>[<span style="color:#ae81ff">3</span>], <span style="color:#a6e22e">Foo</span>[<span style="color:#e6db74">&#39;CHEN&#39;</span>])
</span></span></code></pre></div><p>需要特别注意的是，<font color=red>常量枚举也没有反向映射</font>，因为它在编译时会被完全内联。下面示例代码会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">ConstDirection</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Up</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Down</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// A const enum member can only be accessed using a string literal. 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">ConstDirection</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;Up&#39;</span>);
</span></span></code></pre></div><p><a href="https://typescript.p6p.net/typescript-tutorial/enum.html">参考资料1</a></p>
<h1 id="namespaces">NameSpaces</h1>
<p>命名空间<code>namespace</code>是一种将相关代码组织在一起的方式，通常用于建立一个容器，容器<font color="#f79646">内部的所有变量和函数，默认都必须在这个容器里使用</font>。下面示例代码中，函数<code>isString</code>只能在命名空间<code>Utils</code>中使用，如果<font color=red>在外部直接使用</font>函数<code>isString</code>，会出现编译错误。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> <span style="color:#a6e22e">Utils</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">isString</span>(<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">any</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;string&#39;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 在内部使用不会报错
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">isString</span>(<span style="color:#e6db74">&#39;test&#39;</span>))
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 在外部直接使用命名空间中的函数编译报错
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Cannot find name &#39;isString&#39;. Did you mean &#39;String&#39;?
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">isString</span>(<span style="color:#e6db74">&#39;test&#39;</span>))
</span></span></code></pre></div><p>如果想<font color="#de7802">要在命名空间以外使用其中的内部成员，就必须在该成员前面加上<code>export</code>关键字，表示对外导出该成员（即声明对外可见）</font>，否则会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> <span style="color:#a6e22e">Utils</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">isString</span>(<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">any</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;string&#39;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">isString</span>(<span style="color:#e6db74">&#39;test&#39;</span>))
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 下面会出现编译错误：Property &#39;isString&#39; does not exist on type &#39;typeof Utils&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 因为isString前没有添加export
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">Utils</span>.<span style="color:#a6e22e">isString</span>(<span style="color:#e6db74">&#39;test&#39;</span>)) 
</span></span></code></pre></div><p>下面示例代码中，在<code>Utils</code>中使用<code>export</code>调整函数<code>isString</code>的可见性：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> <span style="color:#a6e22e">Utils</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 只有添加export后才不会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">export</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">isString</span>(<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">any</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;string&#39;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">Utils</span>.<span style="color:#a6e22e">isString</span>(<span style="color:#e6db74">&#39;test&#39;</span>))
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">true</span>
</span></span></code></pre></div><p>编译成<code>JavaScript</code>代码后，命名空间<code>Utils</code>变成了<code>JavaScript</code>的一个对象，<font color=red>凡是在命名空间中<code>export</code>的内部成员，都成为了该对象的属性。</font>也就是说<code>namespace</code>会变成一个值，保留在编译后的代码中，这一点要小心，它不是纯类型代码。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> <span style="color:#a6e22e">Utils</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">export</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">isString</span>(<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">any</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;string&#39;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">isString</span>(<span style="color:#e6db74">&#39;test&#39;</span>))
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> <span style="color:#a6e22e">App</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">import</span> <span style="color:#a6e22e">isString</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Utils</span>.<span style="color:#a6e22e">isString</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">isString</span>(<span style="color:#e6db74">&#39;yes&#39;</span>))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在<code>namespace</code>内部还可以使用<code>import</code>命令导入外部成员，<font color="#f79646">相当于给外部成员起别名</font>。当外部成员的名字比较长时，通过别名能够简化代码。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> <span style="color:#a6e22e">Utils</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">export</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">isString</span>(<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">any</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;string&#34;</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> <span style="color:#a6e22e">App</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">import</span> <span style="color:#a6e22e">isString</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Utils</span>.<span style="color:#a6e22e">isString</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 等同于Utils.isString(&#34;yes&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">isString</span>(<span style="color:#e6db74">&#34;yes&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>也可以在命名空间外部使用<code>import</code>导入命名空间内的成员：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> <span style="color:#a6e22e">Shapes</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">export</span> <span style="color:#66d9ef">namespace</span> <span style="color:#a6e22e">Polygons</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">export</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Triangle</span> {
</span></span><span style="display:flex;"><span>          <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 在外部使用import导入
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">import</span> <span style="color:#a6e22e">polygons</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Shapes</span>.<span style="color:#a6e22e">Polygons</span>;  
</span></span></code></pre></div><p>命名空间也可以嵌套：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> <span style="color:#a6e22e">Utils</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">export</span> <span style="color:#66d9ef">namespace</span> <span style="color:#a6e22e">Messaging</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">export</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">msg</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">msg</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Utils</span>.<span style="color:#a6e22e">Messaging</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Test namespace&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">Test</span> <span style="color:#66d9ef">namespace</span>
</span></span></code></pre></div><p>命名空间与模块的作用是一致的，都是把相关代码组织在一起，对外导出内容。区别是<font color="#de7802">一个文件只能有一个模块，但可以有多个<code>namespace</code></font>。由于模块可以取代<code>namespace</code>，而且是<code>JavaScript</code>的标准语法，不需要编译转换，所以通常建议使用模块。如果<code>namespace</code>的代码放在一个单独的文件里，那么引入这个文件需要使用三斜杠的语法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">/// &lt;reference path = &#34;SomeFileName.ts&#34; /&gt;
</span></span></span></code></pre></div><h2 id="export">export</h2>
<p>命名空间本身也支持使用<code>export</code>命令输出，供其它文件使用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// shapes.ts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">namespace</span> <span style="color:#a6e22e">Shapes</span> {
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">export</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Triangle</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">export</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Square</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>其它文件可以使用<code>import</code>命名加载这个命名空间：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 写法一
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">import</span> { <span style="color:#a6e22e">Shapes</span> } <span style="color:#66d9ef">from</span> <span style="color:#e6db74">&#39;./shapes&#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">t</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Shapes</span>.<span style="color:#a6e22e">Triangle</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 写法二
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">import</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">as</span> <span style="color:#a6e22e">shapes</span> <span style="color:#66d9ef">from</span> <span style="color:#e6db74">&#34;./shapes&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">t</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">shapes</span>.<span style="color:#a6e22e">Shapes</span>.<span style="color:#a6e22e">Triangle</span>();
</span></span></code></pre></div><p>更好的方法是建议使用模块，采用模块的输出和输入：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// shapes.ts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Triangle</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* ... */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Square</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* ... */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// shapeConsumer.ts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">import</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">as</span> <span style="color:#a6e22e">shapes</span> <span style="color:#66d9ef">from</span> <span style="color:#e6db74">&#34;./shapes&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">t</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">shapes</span>.<span style="color:#a6e22e">Triangle</span>();
</span></span></code></pre></div><h2 id="merge-1">merge</h2>
<p>多个同名的<code>namespace</code>能够自动合并，这一点跟<code>interface</code>一样。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> <span style="color:#a6e22e">Animals</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">export</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Cat</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> <span style="color:#a6e22e">Animals</span> {
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">export</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Legged</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">numberOfLegs</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">export</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 等同于
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">namespace</span> <span style="color:#a6e22e">Animals</span> {
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">export</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Legged</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">numberOfLegs</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">export</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Cat</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">export</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这样做的目的是，如果同名的命名空间分布在不同的文件中，<code>TypeScript</code>会将它们合并在一起，这样就比较方便扩展别人的代码。合并命名空间时，<font color="#de7802">命名空间中的非<code>export</code>的成员不会被合并，它们只能在各自的命名空间中使用</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> <span style="color:#a6e22e">N</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">export</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">foo() {</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">a</span>);  <span style="color:#75715e">// 正确
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> <span style="color:#a6e22e">N</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">export</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">bar() {</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">foo</span>(); <span style="color:#75715e">// 正确
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">a</span>);  <span style="color:#75715e">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 出现编译报错
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">Cannot</span> <span style="color:#a6e22e">find</span> <span style="color:#a6e22e">name</span> <span style="color:#e6db74">&#39;a&#39;</span>
</span></span></code></pre></div><p>命名空间还可以跟同名函数合并，但<font color="#de7802">要求同名函数必须在命名空间之前声明</font>。这样做是为了确保先创建出一个函数对象，而同名的命名空间就相当于给这个函数对象添加额外的属性。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">f() {</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">f</span>.<span style="color:#a6e22e">version</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> <span style="color:#a6e22e">f</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">export</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">version</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;1.0&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">f</span>()   <span style="color:#75715e">// &#39;1.0&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">f</span>.<span style="color:#a6e22e">version</span> <span style="color:#75715e">// &#39;1.0&#39;
</span></span></span></code></pre></div><p>命名空间也能与同名<code>class</code>合并，也要求<code>class</code>必须在命名空间之前声明，原因同上。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">C</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">foo</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> <span style="color:#a6e22e">C</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">export</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">bar</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">C</span>.<span style="color:#a6e22e">bar</span> <span style="color:#75715e">// 2
</span></span></span></code></pre></div><p>命名空间还能与同名枚举合并，但此时<font color="#de7802">不要求枚举在命名空间之前声明</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> <span style="color:#a6e22e">E</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">export</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">foo() {</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">E</span>.<span style="color:#a6e22e">C</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">E</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">A</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">B</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">C</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">E</span>.<span style="color:#a6e22e">foo</span>() <span style="color:#75715e">// 2
</span></span></span></code></pre></div><p>但需要注意的是，枚举成员与命名空间<code>export</code>成员不允许同名：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">E</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">A</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">B</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> <span style="color:#a6e22e">E</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">export</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">A() {</span>} 
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Duplicate identifier &#39;A&#39;.
</span></span></span></code></pre></div><hr>
<p><a href="https://ts.xcatliu.com/basics/declaration-files.html">参考资料2</a></p>
<p><a href="https://forums.developer.apple.com/forums/thread/110312">WK中使用sock5代理</a></p>
<p><a href="https://github.com/betafish-inc/OpenVPNAdapter">openAdapter</a></p>
<h1 id="module">Module</h1>
<p>若文件中<font color="#de7802">包含<code>import</code>或<code>export</code>语句，就是一个模块</font>，反之则是一个全局的脚本文件。模块本身就是一个作用域，但它<font color="#de7802">不是全局作用域</font>，模块内部的代码默认仅内部可见。若想暴露<code>module</code>中的代码给外部使用，需使用<code>export</code>声明，其它文件若想使用<code>module</code>内定义的<code>export</code>项，必须使用<code>import</code>导入。</p>
<p>如果一个文件不包含<code>export</code>语句，但是希望把它当作一个模块（让内部代码对外不可见），可以在文件头部添加<code>export {};</code>。这条语句会让当前文件被当作模块处理，即文件内的所有代码变成了仅内部可见。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">export</span> {};
</span></span></code></pre></div><p><code>TypeScript</code>模块除了支持所有<code>ES</code>模块的语法，特别之处在于允许<code>export</code>和<code>import</code>类型。下面示例代码中，当前文件导出一个类型别名<code>Bool</code>。既可以把类型定义和导出写在一行，也可以写成两行。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Bool</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 一行拆成两行，先定义类型别名，再导出类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Bool</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">export</span> { <span style="color:#a6e22e">Bool</span> };
</span></span></code></pre></div><h2 id="export-1">export</h2>
<h3 id="default-export">default export</h3>
<p>在<font color=red>一个模块（<code>.ts</code>文件）中只能有一个默认导出</font>，语法为<code>export default expression;</code>。其中<code>expression</code>可以是一个类、函数、对象等。下面示例代码中，默认导出一个函数<code>add</code>。如果<font color="#de7802">同一个文件中默认导出了多个项，则会出现编译错误</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// mathUtils.ts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">default</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">add</span>(<span style="color:#a6e22e">a</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">b</span>: <span style="color:#66d9ef">number</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">b</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 同一个文件中如果有两个默认导出，则会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Cannot redeclare exported variable &#39;default&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">default</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">add1</span>(<span style="color:#a6e22e">a</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">b</span>: <span style="color:#66d9ef">number</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">b</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="named-export">named export</h3>
<p>可以在一个模块中导出多个具名的变量、函数、类等。具名导出(<code>named export</code>)的语法是<code>export const/function/class/interface name = value;</code>，即在定义的最前面加上<code>export</code>关键词。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// stringUtils.ts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">joinStrings</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">str1</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">str2</span>: <span style="color:#66d9ef">string</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">str1</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">str2</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">splitString</span>(<span style="color:#a6e22e">str</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">separator</span>: <span style="color:#66d9ef">string</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span>[] {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">str</span>.<span style="color:#a6e22e">split</span>(<span style="color:#a6e22e">separator</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="re-export">re-export</h3>
<p>可以在一个模块中导出另一个模块的内容。语法为<code>export { name1, name2 } from'modulePath';</code>。例如，有一个<code>utils</code>目录，其中<code>mathUtils.ts</code>和<code>stringUtils.ts</code>是两个工具模块，现在创建了一个<code>index.ts</code>来重导出这些工具：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// utils/index.ts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">export</span> {<span style="color:#a6e22e">add</span>} <span style="color:#66d9ef">from</span> <span style="color:#e6db74">&#39;./mathUtils&#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">export</span> {<span style="color:#a6e22e">joinStrings</span>, <span style="color:#a6e22e">splitString</span>} <span style="color:#66d9ef">from</span> <span style="color:#e6db74">&#39;./stringUtils&#39;</span>;
</span></span></code></pre></div><p>将多个文件的内容重导出到同一个文件中时，其它模块就可以通过导入<code>utils/index.ts</code>来使用所有重导出的内容：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// main.ts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">import</span> {<span style="color:#a6e22e">add</span>, <span style="color:#a6e22e">joinStrings</span>, <span style="color:#a6e22e">splitString</span>} <span style="color:#66d9ef">from</span> <span style="color:#e6db74">&#39;./utils&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">add</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>));
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">joinStrings</span>(<span style="color:#e6db74">&#34;Good&#34;</span>, <span style="color:#e6db74">&#34;bye&#34;</span>));
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">splitString</span>(<span style="color:#e6db74">&#34;Good,bye&#34;</span>, <span style="color:#e6db74">&#34;,&#34;</span>));
</span></span></code></pre></div><p>在一个模块中，具名导出的名称必须是唯一的。若<font color="#de7802">尝试使用相同的名称导出两个不同的内容，会出现编译错误</font>（这其实和<code>export</code>没有多大关系，就是重定义了两个同名变量而出现的编译错误）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">Cannot</span> <span style="color:#a6e22e">redeclare</span> <span style="color:#a6e22e">block</span><span style="color:#f92672">-</span><span style="color:#a6e22e">scoped</span> <span style="color:#a6e22e">variable</span> <span style="color:#e6db74">&#39;value&#39;</span>.
</span></span></code></pre></div><h3 id="export-type">export type</h3>
<p>同样地，<code>export type</code>语句也有两种方法，表示导出的是类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">A</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;a&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">B</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;b&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 方法一
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">export</span> { <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">A</span>, <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">B</span> };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 方法二
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">type</span> { <span style="color:#a6e22e">A</span>, <span style="color:#a6e22e">B</span> };
</span></span></code></pre></div><h2 id="import">import</h2>
<p>若上面的模块文件为<code>a.ts</code>，在另一个文件<code>b.ts</code>就可以使用<code>import</code>语句导入这个类型。下面示例代码中，<code>import</code>语句导入的是一个类型。文件写成了<code>./a</code>，并没有加上后缀名 ，这是因为<code>TypeScript</code>允许加载模块时，<font color="#de7802">省略模块文件的后缀名，它会自动定位</font>，将<code>./a</code>定位到<code>./a.ts</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">import</span> { <span style="color:#a6e22e">Bool</span> } <span style="color:#66d9ef">from</span> <span style="color:#e6db74">&#34;./a&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">foo</span>: <span style="color:#66d9ef">Bool</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span></code></pre></div><h3 id="all-import">all import</h3>
<p>若想<code>import</code>某个模块中的所有<code>export</code>内容，语法为<code>import * as moduleName from'modulePath';</code>。若有一个名为<code>mathUtils</code>的模块，里面包含了一些数学工具函数，如<code>add</code>和<code>subtract</code>，模块路径为<code>./mathUtils</code>，可以使用如下方式导入模块中所有<code>export</code>内容：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">import</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">as</span> <span style="color:#a6e22e">math</span> <span style="color:#66d9ef">from</span> <span style="color:#e6db74">&#39;./mathUtils&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">add</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>)); 
</span></span></code></pre></div><h3 id="named-import">named import</h3>
<p>当只需要模块中的某些特定的导出内容时，可以使用具名导入（<code>named import</code>）。语法是<code>import {Name1, Name2} from'modulePath';</code>。例如，如果<code>mathUtils</code>模块导出了<code>add</code>和<code>subtract</code>函数，可以按下面方式具名导入：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">import</span> {<span style="color:#a6e22e">add</span>, <span style="color:#a6e22e">subtract</span>} <span style="color:#66d9ef">from</span> <span style="color:#e6db74">&#39;./mathUtils&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">add</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>));
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">subtract</span>(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">1</span>));
</span></span></code></pre></div><h3 id="default-import">default import</h3>
<p>一个模块<font color="#de7802">仅能有一个默认导出</font>，默认导入的语法是<code>import defaultExportedName from'modulePath';</code>（没有大括号）。例如，有一个模块<code>person</code>中默认导出了一个名为<code>Person</code>的类，可以使用如下方式导入：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">import</span> <span style="color:#a6e22e">Person</span> <span style="color:#66d9ef">from</span> <span style="color:#e6db74">&#39;./person&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Person</span>();
</span></span></code></pre></div><h3 id="rename-import">rename import</h3>
<p>无论是具名导入还是默认导入，都可以对导入的内容进行重命名。对于具名导入，语法是<code>import {exportedName1 as newName1, exportedName2 as newName2} from'modulePath';</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">import</span> {<span style="color:#a6e22e">add</span> <span style="color:#66d9ef">as</span> <span style="color:#a6e22e">sum</span>, <span style="color:#a6e22e">subtract</span> <span style="color:#66d9ef">as</span> <span style="color:#a6e22e">diff</span>} <span style="color:#66d9ef">from</span> <span style="color:#e6db74">&#39;./mathUtils&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">sum</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>));
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">diff</span>(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">1</span>));
</span></span></code></pre></div><p>但对于默认导入，因为它没有大括号且每个模块仅允许一个默认导出，所以语法变成了<code>import newName from'modulePath';</code>，<font color=red>即对应的重命名导入也不需要使用<code>as</code>关键字</font>。若在<code>person</code>模块默认导出了<code>Person</code>类，重命名默认导入方式如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">import</span> <span style="color:#a6e22e">Human</span> <span style="color:#66d9ef">from</span> <span style="color:#e6db74">&#39;./person&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">h</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Human</span>();
</span></span></code></pre></div><h3 id="type-import">type import</h3>
<p>在一条<code>import</code>语句中，可以同时导入变量和类型。下面示例代码中，文件<code>a.ts</code>的<code>export</code>语句导出了一个接口类型<code>A</code>和一个普通的变量<code>a</code>，另一个文件<code>b.ts</code>则在同一条语句中导入了这个类型和变量。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// a.ts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">A</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">foo</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">123</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// b.ts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">import</span> { <span style="color:#a6e22e">A</span>, <span style="color:#a6e22e">a</span> } <span style="color:#66d9ef">from</span> <span style="color:#e6db74">&#34;./a&#34;</span>;
</span></span></code></pre></div><p>这样不利于区分类型和普通变量，容易造成混淆。为了解决这个问题，<code>TypeScript</code>提供了两种方案。第一种是在待导入类型前加上<code>type</code>关键字，表示要导入的是一个类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">import</span> { <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">A</span>, <span style="color:#a6e22e">a</span> } <span style="color:#66d9ef">from</span> <span style="color:#e6db74">&#34;./a&#34;</span>;
</span></span></code></pre></div><p>第二种是使用<code>import type</code>语句：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 正确
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">import</span> <span style="color:#66d9ef">type</span> { <span style="color:#a6e22e">A</span> } <span style="color:#66d9ef">from</span> <span style="color:#e6db74">&#34;./a&#34;</span>;
</span></span></code></pre></div><p>使用<code>import type</code>时，也可以导入默认类型。假如有一个模块<code>person</code>默认导出了一个<code>Person</code>类，就可以使用<code>type</code>默认导入<code>Person</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">import</span> <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Person</span> <span style="color:#66d9ef">from</span> <span style="color:#e6db74">&#34;./Person&#34;</span>;
</span></span></code></pre></div><p>使用<code>import type</code>还可以导入一个名称空间下的所有类型，写法如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">import</span> <span style="color:#66d9ef">type</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">as</span> <span style="color:#a6e22e">NewType</span> <span style="color:#66d9ef">from</span> <span style="color:#e6db74">&#34;moduleA&#34;</span>;
</span></span></code></pre></div>
    </div>
    <footer class="post-footer">
        
 
<div class="post-tags">     
     
    <a href="https://iihui.github.io/tags/ts" rel="tag" title="ts">#ts#</a>
    
</div>



        <div class="post-nav">
    <div class="post-nav-next post-nav-item">
    
        <a href="https://iihui.github.io/post/tool-rider/" rel="next" title="Rider 使用">
        <i class="fa fa-chevron-left"></i> Rider 使用
        </a>
    
    </div>

    <div class="post-nav-prev post-nav-item">
    
        <a href="https://iihui.github.io/post/ios-fundamentals/" rel="prev" title="iOS 14 编程基础">
        iOS 14 编程基础 <i class="fa fa-chevron-right"></i>
        </a>
    
    </div>
</div>
      
        <div class="post-nav">
    <div style="border: 1px dashed #e0e0e0; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
        <div style="float:left;margin-top:0px;">
            <img src="https://i.loli.net/2020/02/09/SvhUdz4XJsOr9Vk.jpg" width="128px" height="128px"/>
            <div style="text-align:center;">谢谢支持!</div>
        </div>
        <div>
            <p style="margin-top:10px;">
                标题：TypeScript基础
                <br />作者：阿呆<a target="_blank" href="https://iihui.github.io/"></a>
                
                <br />地址：https://iihui.github.io/post/ts-base/
                <br />声明：自由转载-非商用-保持署名（创作共享4.0许可证）
            </p>
        </div>
    </div>
    <div class="clear"></div>
</div>
        
        
        




    </footer>
  </article>
</section>

          </div>
        </div>
        <div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>
<aside id="sidebar" class="sidebar">
  <div class="sidebar-inner">

  <ul class="sidebar-nav motion-element">
    <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
      文章目录
    </li>
    <li class="sidebar-nav-overview" data-target="site-overview">
      站点概览
    </li>
  </ul>

    <section class="site-overview sidebar-panel ">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
        src="https://i.loli.net/2020/02/07/dVFzrvZkHRNq2lL.jpg"
        alt="" />
    <p class="site-author-name" itemprop="name"></p>
    <p class="site-description motion-element" itemprop="description"> 
        coder &amp; cook</p>
</div>
      <nav class="site-state motion-element">
    <div class="site-state-item site-state-posts">
      <a href="https://iihui.github.io/post/">
        <span class="site-state-item-count">142</span>
        <span class="site-state-item-name">日志</span>
      </a>
    </div>
    <div class="site-state-item site-state-categories">    
        <a href="https://iihui.github.io/categories/">      
         
        <span class="site-state-item-count">18</span>
        
        <span class="site-state-item-name">分类</span>
        
        </a>
    </div>

    <div class="site-state-item site-state-tags">
        <a href="https://iihui.github.io/tags/">
         
        <span class="site-state-item-count">29</span>
        
        <span class="site-state-item-name">标签</span>
        </a>
    </div>
</nav>
      
      
<div class="links-of-author motion-element">
    
        <span class="links-of-author-item">
        <a href="https://coolshell.cn" target="_blank" title="皓 大">
            <i class="fa fa-fw fa-globe"></i>
            皓 大
        </a>
        </span>
    
        <span class="links-of-author-item">
        <a href="http://www.ruanyifeng.com" target="_blank" title="阮 大">
            <i class="fa fa-fw fa-globe"></i>
            阮 大
        </a>
        </span>
    
        <span class="links-of-author-item">
        <a href="https://juejin.im/" target="_blank" title="掘 金">
            <i class="fa fa-fw fa-globe"></i>
            掘 金
        </a>
        </span>
    
</div>


      

      <div class="links-of-blogroll motion-element inline">
<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=&amp;m=0&amp;s=220&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;bv=35" async="async"></script>
</div>

    </section>
    
<section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
    <div class="post-toc">
        <div class="post-toc-content"><nav id="TableOfContents">
  <ul>
    <li><a href="#modules">Modules</a></li>
    <li><a href="#unions-and-literals">Unions and Literals</a>
      <ul>
        <li><a href="#union-types">Union Types</a></li>
        <li><a href="#narrowing">Narrowing</a>
          <ul>
            <li><a href="#assignment-narrowing">Assignment Narrowing</a></li>
            <li><a href="#conditional-checks">Conditional Checks</a></li>
          </ul>
        </li>
        <li><a href="#literal-types">Literal Types</a>
          <ul>
            <li><a href="#literal-assignability">Literal Assignability</a></li>
          </ul>
        </li>
        <li><a href="#strict-null-checking">Strict Null Checking</a>
          <ul>
            <li>
              <ul>
                <li><a href="#billion-dollar-mistake">billion-dollar mistake</a></li>
              </ul>
            </li>
            <li><a href="#truthiness-narrowing">Truthiness Narrowing</a></li>
            <li><a href="#variables-without-initial-values">Variables Without Initial Values</a></li>
          </ul>
        </li>
        <li><a href="#type-aliases">Type Aliases</a>
          <ul>
            <li><a href="#type-aliases-are-not-javascript">Type Aliases Are Not JavaScript</a></li>
            <li><a href="#combining-type-aliases">Combining Type Aliases</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#objects">Objects</a>
      <ul>
        <li><a href="#object-types">Object Types</a>
          <ul>
            <li><a href="#declaring-object-types">Declaring Object Types</a></li>
            <li><a href="#aliased-object-types">Aliased Object Types</a></li>
          </ul>
        </li>
        <li><a href="#structural-typing">Structural Typing</a>
          <ul>
            <li><a href="#usage-checking">Usage Checking</a></li>
            <li><a href="#excess-property-checking">Excess Property Checking</a></li>
            <li><a href="#nested-object-types">Nested Object Types</a></li>
            <li><a href="#optional-properties">Optional Properties</a></li>
          </ul>
        </li>
        <li><a href="#unions-of-object-types">Unions of Object Types</a>
          <ul>
            <li><a href="#inferred-object-type-unions">Inferred Object-Type Unions</a></li>
            <li><a href="#explicit-object-type-unions">Explicit Object-Type Unions</a></li>
            <li><a href="#narrowing-object-types">Narrowing Object Types</a></li>
            <li><a href="#discriminated-unions">Discriminated Unions</a></li>
          </ul>
        </li>
        <li><a href="#intersection-types">Intersection Types</a>
          <ul>
            <li><a href="#dangers-of-intersection-types">Dangers of Intersection Types</a></li>
            <li><a href="#never">never</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#functions">Functions</a>
      <ul>
        <li><a href="#function-parameters">Function Parameters</a>
          <ul>
            <li><a href="#required-parameters">Required Parameters</a></li>
            <li><a href="#optional-parameters">Optional Parameters</a></li>
            <li><a href="#default-parameters">Default Parameters</a></li>
            <li><a href="#rest-parameters">Rest Parameters</a></li>
          </ul>
        </li>
        <li><a href="#return-types">Return Types</a>
          <ul>
            <li><a href="#explicit-return-types">Explicit Return Types</a></li>
          </ul>
        </li>
        <li><a href="#function-types">Function Types</a>
          <ul>
            <li><a href="#function-type-parentheses">Function Type Parentheses</a></li>
            <li><a href="#parameter-type-inferences">Parameter Type Inferences</a></li>
            <li><a href="#function-type-aliases">Function Type Aliases</a></li>
          </ul>
        </li>
        <li><a href="#more-return-types">More Return Types</a>
          <ul>
            <li><a href="#never-returns">Never Returns</a></li>
          </ul>
        </li>
        <li><a href="#function-overloads">Function Overloads</a>
          <ul>
            <li><a href="#call-signature-compatibility">Call-Signature Compatibility</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#arrays">Arrays</a>
      <ul>
        <li><a href="#array-types">Array Types</a>
          <ul>
            <li><a href="#array-and-function-types">Array and Function Types</a></li>
            <li><a href="#union-type-arrays">Union-Type Arrays</a></li>
            <li><a href="#evolving-any-arrays">Evolving Any Arrays</a></li>
            <li><a href="#multidimensional-arrays">Multidimensional Arrays</a></li>
          </ul>
        </li>
        <li><a href="#array-members">Array Members</a>
          <ul>
            <li><a href="#caveat-unsound-members">Caveat: Unsound Members</a></li>
          </ul>
        </li>
        <li><a href="#spreads-and-rests">Spreads and Rests</a>
          <ul>
            <li><a href="#spreads">Spreads</a></li>
            <li><a href="#spreading-rest-parameters">Spreading Rest Parameters</a></li>
          </ul>
        </li>
        <li><a href="#tuples">Tuples</a>
          <ul>
            <li><a href="#tuple-assignability">Tuple Assignability</a></li>
            <li><a href="#tuple-inferences">Tuple Inferences</a>
              <ul>
                <li><a href="#explicit-tuple-types">Explicit tuple types</a></li>
                <li><a href="#const-asserted-tuples">Const asserted tuples</a></li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#interfaces">Interfaces</a>
      <ul>
        <li><a href="#type-aliases-versus-interfaces">Type Aliases Versus Interfaces</a></li>
        <li><a href="#types-of-properties">Types of Properties</a>
          <ul>
            <li><a href="#optional-properties-1">Optional Properties</a></li>
            <li><a href="#read-only-properties">Read-Only Properties</a></li>
            <li><a href="#functions-and-methods">Functions and Methods</a></li>
            <li><a href="#call-signatures">Call Signatures</a></li>
            <li><a href="#index-signatures">Index Signatures</a>
              <ul>
                <li><a href="#mixing-properties-and-index-signatures">Mixing properties and index signatures</a></li>
                <li><a href="#numeric-index-signatures">Numeric index signatures</a></li>
              </ul>
            </li>
            <li><a href="#nested-interfaces">Nested Interfaces</a></li>
          </ul>
        </li>
        <li><a href="#interface-extensions">Interface Extensions</a>
          <ul>
            <li><a href="#overridden-properties">Overridden Properties</a></li>
            <li><a href="#extending-multiple-interfaces">Extending Multiple Interfaces</a></li>
          </ul>
        </li>
        <li><a href="#interface-merging">Interface Merging</a>
          <ul>
            <li><a href="#member-naming-conflicts">Member Naming Conflicts</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#classes">Classes</a>
      <ul>
        <li><a href="#class-methods">Class Methods</a></li>
        <li><a href="#class-properties">Class Properties</a>
          <ul>
            <li><a href="#function-properties">Function Properties</a></li>
            <li><a href="#initialization-checking">Initialization Checking</a>
              <ul>
                <li><a href="#definitely-assigned-properties">Definitely assigned properties</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#optional-properties-2">Optional Properties</a></li>
        <li><a href="#read-only-properties-1">Read-Only Properties</a></li>
        <li><a href="#classes-as-types">Classes as Types</a></li>
        <li><a href="#classes-and-interfaces">Classes and Interfaces</a>
          <ul>
            <li><a href="#implementing-multiple-interfaces">Implementing Multiple Interfaces</a></li>
          </ul>
        </li>
        <li><a href="#extending-a-class">Extending a Class</a>
          <ul>
            <li><a href="#extension-assignability">Extension Assignability</a></li>
            <li><a href="#overridden-constructors">Overridden Constructors</a></li>
            <li><a href="#overridden-methods">Overridden Methods</a></li>
            <li><a href="#overridden-properties-1">Overridden Properties</a></li>
          </ul>
        </li>
        <li><a href="#abstract-classes">Abstract Classes</a></li>
        <li><a href="#member-visibility">Member Visibility</a>
          <ul>
            <li><a href="#static-field-modifiers">Static Field Modifiers</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#type-modifiers">Type Modifiers</a>
      <ul>
        <li><a href="#top-types">Top Types</a>
          <ul>
            <li><a href="#any">any</a></li>
            <li><a href="#unknown">unknown</a></li>
          </ul>
        </li>
        <li><a href="#type-predicates">Type Predicates</a></li>
        <li><a href="#type-operators">Type Operators</a>
          <ul>
            <li><a href="#keyof">keyof</a></li>
            <li><a href="#typeof">typeof</a></li>
            <li><a href="#keyof-typeof">keyof typeof</a></li>
          </ul>
        </li>
        <li><a href="#type-assertions">Type Assertions</a>
          <ul>
            <li><a href="#asserting-caught-error-types">Asserting Caught Error Types</a></li>
            <li><a href="#non-null-assertions">Non-Null Assertions</a></li>
            <li><a href="#type-assertion-caveats">Type Assertion Caveats</a></li>
          </ul>
        </li>
        <li><a href="#const-assertions">Const Assertions</a>
          <ul>
            <li><a href="#literals-to-primitives">Literals to Primitives</a></li>
            <li><a href="#read-only-objects">Read-Only Objects</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#generics">Generics</a>
      <ul>
        <li><a href="#generic-functions">Generic Functions</a>
          <ul>
            <li><a href="#explicit-generic-call-types">Explicit Generic Call Types</a></li>
            <li><a href="#multiple-function-type-parameters">Multiple Function Type Parameters</a></li>
          </ul>
        </li>
        <li><a href="#generic-interfaces">Generic Interfaces</a>
          <ul>
            <li><a href="#inferred-generic-interface-types">Inferred Generic Interface Types</a></li>
          </ul>
        </li>
        <li><a href="#generic-classes">Generic Classes</a>
          <ul>
            <li><a href="#explicit-generic-class-types">Explicit Generic Class Types</a></li>
            <li><a href="#extending-generic-classes">Extending Generic Classes</a></li>
            <li><a href="#implementing-generic-interfaces">Implementing Generic Interfaces</a></li>
            <li><a href="#method-generics">Method Generics</a></li>
            <li><a href="#static-class-generics">Static Class Generics</a></li>
          </ul>
        </li>
        <li><a href="#generic-type-aliases">Generic Type Aliases</a>
          <ul>
            <li><a href="#generic-discriminated-unions">Generic Discriminated Unions</a></li>
          </ul>
        </li>
        <li><a href="#generic-modifiers">Generic Modifiers</a>
          <ul>
            <li><a href="#generic-defaults">Generic Defaults</a></li>
          </ul>
        </li>
        <li><a href="#constrained-generic-types">Constrained Generic Types</a>
          <ul>
            <li><a href="#keyof-and-constrained-type-parameters">keyof and Constrained Type Parameters</a></li>
          </ul>
        </li>
        <li><a href="#promises">Promises</a>
          <ul>
            <li><a href="#creating-promises">Creating Promises</a></li>
            <li><a href="#async-functions">Async Functions</a></li>
          </ul>
        </li>
        <li><a href="#using-generics-right">Using Generics Right</a>
          <ul>
            <li><a href="#the-golden-rule-of-generics">The Golden Rule of Generics</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#declaration-files">Declaration Files</a>
      <ul>
        <li><a href="#declaration-files-1">Declaration Files</a></li>
        <li><a href="#declaring-runtime-values">Declaring Runtime Values</a>
          <ul>
            <li><a href="#global-values">Global Values</a></li>
            <li><a href="#global-interface-merging">Global Interface Merging</a></li>
            <li><a href="#global-augmentations">Global Augmentations</a></li>
          </ul>
        </li>
        <li><a href="#built-in-declarations">Built-In Declarations</a>
          <ul>
            <li><a href="#library-declarations">Library Declarations</a></li>
            <li><a href="#library-targets">Library targets</a></li>
            <li><a href="#dom-declarations">DOM Declarations</a></li>
          </ul>
        </li>
        <li><a href="#module-declarations">Module Declarations</a>
          <ul>
            <li><a href="#wildcard-module-declarations">Wildcard Module Declarations</a></li>
          </ul>
        </li>
        <li><a href="#package-types">Package Types</a>
          <ul>
            <li><a href="#declaration">declaration</a></li>
            <li><a href="#dependency-package-types">Dependency Package Types</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#enum">Enum</a>
      <ul>
        <li><a href="#property">property</a></li>
        <li><a href="#merge">merge</a></li>
        <li><a href="#reverse-map">reverse map</a></li>
      </ul>
    </li>
    <li><a href="#namespaces">NameSpaces</a>
      <ul>
        <li><a href="#export">export</a></li>
        <li><a href="#merge-1">merge</a></li>
      </ul>
    </li>
    <li><a href="#module">Module</a>
      <ul>
        <li><a href="#export-1">export</a>
          <ul>
            <li><a href="#default-export">default export</a></li>
            <li><a href="#named-export">named export</a></li>
            <li><a href="#re-export">re-export</a></li>
            <li><a href="#export-type">export type</a></li>
          </ul>
        </li>
        <li><a href="#import">import</a>
          <ul>
            <li><a href="#all-import">all import</a></li>
            <li><a href="#named-import">named import</a></li>
            <li><a href="#default-import">default import</a></li>
            <li><a href="#rename-import">rename import</a></li>
            <li><a href="#type-import">type import</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav></div>
    </div>
</section>

  </div>
</aside>

      </div>
    </main>
   
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  <span itemprop="copyrightYear">  &copy; 
  2017 - 2025</span>
  <span class="with-love"><i class="fa fa-heart"></i></span>
  <span class="author" itemprop="copyrightHolder">Keep It Simple</span>
</div>




      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      <span id="scrollpercent"><span>0</span>%</span>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/jquery/index.js?v=2.1.3"></script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script> 
<script type="text/javascript" src="https://iihui.github.io/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/velocity/velocity.min.js?v=1.2.1"></script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="https://iihui.github.io/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>

<script src="https://iihui.github.io/js/vendor/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>

<script type="text/javascript" src="https://iihui.github.io/js/utils.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/motion.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/affix.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/schemes/pisces.js"></script>

<script type="text/javascript" src="https://iihui.github.io/js/scrollspy.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/post-details.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/toc.js"></script>

<script type="text/javascript" src="https://iihui.github.io/js/bootstrap.js"></script>

<script type="text/javascript" src="https://iihui.github.io/js/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
</body>
</html>