<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
    <title>TypeScript基础 - Keep It Simple</title>
    <meta name="keywords" content="博客,思考,读书,笔记,技术,分享">
    
    <meta property="og:title" content="TypeScript基础">
    <meta property="og:site_name" content="Keep It Simple">
    <meta property="og:image" content="/img/author.jpg"> 
    <meta name="title" content="TypeScript基础 - Keep It Simple" />
    <meta name="description" content="Swift | Go | C&#43;&#43; "> 
    <link rel="shortcut icon" href="https://iihui.github.io/img/favicon.ico" />
    <link rel="apple-touch-icon" href="https://iihui.github.io/img/apple-touch-icon.png" />
    <link rel="apple-touch-icon-precomposed" href="https://iihui.github.io/img/apple-touch-icon.png" />
    <link href="https://iihui.github.io/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />
    <link href="https://iihui.github.io/js/vendor/fancybox/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />
    <link href="https://iihui.github.io/css/main.css" rel="stylesheet" type="text/css" />
    <link href="https://iihui.github.io/css/syntax.css" rel="stylesheet" type="text/css" />

    <script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
     fancybox: true, 
    motion: true
  };
</script>

    <link href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/monokai-sublime.min.css" rel="stylesheet">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/go.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/swift.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/objectivec.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/clojure.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/kotlin.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/yaml.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<div class="container one-collumn sidebar-position-left page-home  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-meta  custom-logo ">

  <div class="custom-logo-site-title">
    <a href="https://iihui.github.io/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Keep It Simple</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">靡不有初，鲜克有终</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
    <ul id="menu" class="menu">
      
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/tags/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-tag"></i> <br />标签
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/post/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/categories/%E7%BE%8E%E9%A3%9F/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-fire"></i> <br />美食
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/categories/%E5%90%8E%E6%9C%9F/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-edit"></i> <br />后期
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/categories/%E6%97%85%E8%A1%8C/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-leaf"></i> <br />旅行
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/about/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于
          </a>
        </li>
      
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger"> <i class="menu-item-icon fa fa-search fa-fw"></i> <br /> 搜索</a>
      </li>
    </ul>
    <div class="site-search">
      <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>

    </div>
</nav>
<script type="text/javascript"
        async
        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
		<!-- src = "http://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> <\!--  -\-> -->
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>

<!DOCTYPE html>
<html lang="en">


<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css" integrity="sha384-D+9gmBxUQogRLqvARvNLmA9hS2x//eK1FhVb9PiU86gmcrBrJAQT8okdJ4LMp2uv" crossorigin="anonymous">

    
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js" integrity="sha384-483A6DwYfKeDa0Q52fJmxFXkcPCFfnXMoXblOkJ4JcA8zATN6Tm78UNL72AKk+0O" crossorigin="anonymous"></script>
</head>
<body>

</body>
</html>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
<section id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="https://iihui.github.io/post/ts-base/" itemprop="url">
        TypeScript基础
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">创建: </span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2022-01-27">
    2022-01-27
</time>
</span>
&nbsp; | &nbsp;
<span class="post-updated-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-check-o"></i>
</span>
<span class="post-meta-item-text">更新: </span>
<time itemprop="dateUpdated" content="2022-01-27">
    2022-01-27
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类: </span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="https://iihui.github.io/categories/ts" itemprop="url" rel="index">
        <span itemprop="name">ts</span>
      </a>
      &nbsp; 
    </span>
  
</span>


      <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-file-word-o"></i>
</span>
<span class="post-meta-item-text">字数: </span>
<span class="leancloud-visitors-count">43624</span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-coffee"></i>
</span>
<span class="post-meta-item-text">阅读: </span>
<span class="leancloud-visitors-count">88 分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <p><code>TypeScript</code>的7种基本类型为：</p>
<ul>
<li><code>null</code></li>
<li><code>undefined</code></li>
<li><code>boolean</code></li>
<li><code>string</code></li>
<li><code>number</code></li>
<li><code>bigint</code></li>
<li><code>symbol</code></li>
</ul>
<p>若声明变量时不标注类型，编译器会推断该变量的类型为<code>any</code>，<font color="#de7802">表示该变量可以被赋为任何类型的值</font>。如果声明变量时既不标注类型也不初始化，接着使用<code>typeof</code>得到的结果为<code>undefined</code>。这是因为<code>TypeScript</code>编译成<code>JavaScript</code>后，未初始化变量的默认值为<code>undefined</code>，所以使用<code>typeof</code>得到的类型为<code>undefined</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">rocker</span>; <span style="color:#75715e">// Type: any
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">rocker</span>) <span style="color:#75715e">// 运行结果为undefined
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">rocker</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Joan Jett&#34;</span>; <span style="color:#75715e">// 此时类型为string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">rocker</span>.<span style="color:#a6e22e">toUpperCase</span>(); <span style="color:#75715e">// JOAN JETT
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">rocker</span>, <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">rocker</span>) <span style="color:#75715e">// Joan Jett string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">rocker</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">19.58</span>; <span style="color:#75715e">// 此时类型为number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">rocker</span>, <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">rocker</span>) <span style="color:#75715e">// 19.58 number
</span></span></span></code></pre></div><p>函数的<font color="#de7802">可选参数必须是最后一个参数，若将可选参数放在必需参数前，会出现编译错误</font>。下面代码编译时会出现<code>A required parameter cannot follow an optional parameter</code>错误。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：A required parameter cannot follow an optional parameter
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">hello3</span>(<span style="color:#a6e22e">x?</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>具有<font color="#de7802">默认值的参数若不位于参数列表的末尾，调用时不能省略该参数，此时如果要触发默认值，必须显式地传入<code>undefined</code></font>，下面第一个参数传入了<code>undefined</code>，触发了默认值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">hello3</span>(<span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>, <span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">hello3</span>(<span style="color:#66d9ef">undefined</span>, <span style="color:#ae81ff">890</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">3</span> <span style="color:#ae81ff">890</span>
</span></span></code></pre></div><h1 id="modules">Modules</h1>
<p><code>JavaScript</code>编程语言最近才规范了文件之间如何共享代码。<code>ECMAScript 2015</code>增加了<code>ECMAScript Modules</code>以规范文件间的<code>import</code>和<code>export</code>语法。</p>
<p>在<code>module</code>文件中<font color="#de7802">声明的任何内容都只能在该文件中使用</font>，除非该文件中有明确的<code>export</code>语句。下面代码中，<code>test.ts</code>文件从同级的<code>./values</code>文件中导入了<code>value</code>，并导出了一个<code>doubled</code>常量值:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">//values.ts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">12</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// test.ts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">import</span> {<span style="color:#a6e22e">value</span>} <span style="color:#66d9ef">from</span> <span style="color:#e6db74">&#34;./values&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">doubled</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>;
</span></span></code></pre></div><p>如果在某一个模块中声明的变量和另一个模块中声明的变量同名，一般不会冲突。只有当在一个文件中导入了另一个文件中的同名变量时，才会产生冲突。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// a.ts 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">shared</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Cher&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// b.ts 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">shared</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Cher&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// c.ts 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">import</span> { <span style="color:#a6e22e">shared</span> } <span style="color:#66d9ef">from</span> <span style="color:#e6db74">&#34;./a&#34;</span>; 
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Import declaration conflicts with local declaration of &#39;shared&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">shared</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Cher&#34;</span>; 
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Individual declarations in merged declaration &#39;shared&#39; must be all exported or all local.
</span></span></span></code></pre></div><p>如果文件是脚本，<code>TypeScript</code>会<font color="#de7802">将其视为全局作用域，这意味着其它所有脚本文件都可以访问其中的内容</font>。也就是说，在某个脚本文件中声明的变量不能与其它脚本文件中声明的变量同名。</p>
<p>下面<code>a.ts</code>和<code>b.ts</code>文件均会被认为是脚本，因为它们中没有<code>export</code>和<code>import</code>语句。意味着如果在这两个文件中有同名的变量，就会有冲突：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// a.ts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">shared</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Cher&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// b.ts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">shared</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Cher&#34;</span>; <span style="color:#75715e">// 编译错误：Cannot redeclare block-scoped variable &#39;shared&#39;.
</span></span></span></code></pre></div><p>根据<code>ECMAScript</code>规范，如果要将一个没有<code>export</code>或<code>import</code>语句的文件变成模块，可以<font color="#de7802">在文件的某个地方添加一个<code>export {};</code>语句来强制它成为一个模块</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// a.ts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">shared</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Cher&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// b.ts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">shared</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Cher&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">export</span> {};
</span></span></code></pre></div><h1 id="unions-and-literals">Unions and Literals</h1>
<blockquote>
<p>联合：将值的允许类型扩展为两种或两种以上的可能类型。窄化：减少值的允许类型，使其不属于一种或多种可能的类型。联合和窄化是一种强大的概念，允许对代码做出比其他主流语言更智能的推断。</p>
</blockquote>
<h2 id="union-types">Union Types</h2>
<p>下面定义的变量<code>mathematician</code>的类型既可以是<code>undefined</code>，也可以是<code>string</code>，<font color="#de7802">这种非此即彼的类型称为联合类型</font>。联合类型是一个奇妙的概念，它可以让我们在代码中处理这样的情况：暂时还不知道某个值的确切类型，但确定它是两个或多个类型之一。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 变量类型为string | undefined
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">mathematician</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> <span style="color:#66d9ef">undefined</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Mark Goldberg&#34;</span>;
</span></span></code></pre></div><p><code>TypeScript</code>使用管道操作符<code>|</code>来连接可能的类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">mathematician</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> <span style="color:#66d9ef">undefined</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Mark Goldberg&#34;</span>;
</span></span></code></pre></div><p>在<font color="#de7802">变量在有初始值的情况下，也显式地将其类型标注为联合类型有时很有用</font>。下面代码中，<code>thinker</code>一开始是<code>null</code>，但在某些情况下可能是字符串。将变量的类型显式标注为<code>string | null</code>联合类型，意味着后续给它赋字符串类型的值是允许的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">thinker</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">thinker</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Susanne Langer&#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">thinker</span>, <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">thinker</span>)  <span style="color:#75715e">// 每次执行时生成随机数不同，结果就会不同
</span></span></span></code></pre></div><p>联合类型标注可以放置在任何需要类型标注的地方。<font color=red>当已知值是一个联合类型时，<code>TypeScript</code>只允许访问联合中所有子类型都存在的共有成员属性</font>。如果尝试访问的属性不是联合类型所有子类型的共有属性，会出现编译错误。</p>
<p>下面代码中，<code>physicist</code>是一个<code>number | string</code>联合类型变量。方法<code>toString()</code>在两种子类型中都存在，但<code>toUpperCase</code>方法仅存在于<code>string</code>类型，而<code>toFixed</code>方法仅存在于<code>number</code>类型。所以，如果直接调用<code>toUpperCase</code>和<code>toFixed</code>都会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// physicist变量类型为string | number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">physicist</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;Marie Curie&#34;</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">84</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">physicist</span>.<span style="color:#a6e22e">toString</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Property &#39;toUpperCase&#39; does not exist on type &#39;string | number&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Property &#39;toUpperCase&#39; does not exist on type &#39;number&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">physicist</span>.<span style="color:#a6e22e">toUpperCase</span>(); 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Property &#39;toFixed&#39; does not exist on type &#39;string | number&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Property &#39;toFixed&#39; does not exist on type &#39;string&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">physicist</span>.<span style="color:#a6e22e">toFixed</span>();
</span></span></code></pre></div><p>需要注意的是，<font color="#de7802">限制访问并不存在于联合类型所有子类型的属性或方法是一种安全措施</font>。如果一个对象还不确定是包含某个属性的子类型，<code>TypeScript</code>则认为尝试访问该子类型独有的属性是不安全的。</p>
<p>如果要使用仅存在于联合类型中某个子类型的属性或方法，我们的代码需向<code>TypeScript</code><span style="background:rgba(255, 183, 139, 0.55)">表明在当前位置该值的类型就是某个具体的子类型，这一过程被称为窄化（<code>narrowing</code>）</span>。</p>
<h2 id="narrowing">Narrowing</h2>
<p>窄化是指在代码中推断出一个变量值的类型比其声明时的类型更具体（范围更窄）。一旦知道一个值的类型比声明时的类型范围更窄，将允许将该值的类型视为这个更具体（更窄）的类型。用于<font color="#de7802">窄化类型范围的逻辑检查称为类型保护</font>。下面介绍<code>TypeScript</code>可以用来从代码中窄化类型的两种常见类型保护。</p>
<h3 id="assignment-narrowing">Assignment Narrowing</h3>
<p>如果<font color="#de7802">直接赋值给一个联合类型变量，会将变量的类型缩小为该值的类型</font>。下面示例代码中，变量<code>admiral</code>声明为<code>number | string</code>联合类型。一旦变量被赋值为字符串<code>&quot;Grace Hopper&quot;</code>，编译器就知道它是字符串类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">admiral</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">admiral</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Grace Hopper&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">admiral</span>.<span style="color:#a6e22e">toUpperCase</span>(); <span style="color:#75715e">// Ok: string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Property &#39;toFixed&#39; does not exist on type &#39;string&#39;. Did you mean &#39;fixed&#39;?
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">admiral</span>.<span style="color:#a6e22e">toFixed</span>(); 
</span></span></code></pre></div><p>当变量的类型<font color="#de7802">显式地标注为联合类型并且同时有一个初始值时，赋值窄化就会发挥作用</font>。编译器知道，虽然变量以后可能会接收联合类型其它子类型的值，但它初始时只是初始值的类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">inventor</span>: <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Hedy Lamarr&#34;</span>; <span style="color:#75715e">// 窄化为string类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">inventor</span>.<span style="color:#a6e22e">toUpperCase</span>();
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Property &#39;toFixed&#39; does not exist on type &#39;string&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">inventor</span>.<span style="color:#a6e22e">toFixed</span>(); 
</span></span></code></pre></div><h3 id="conditional-checks">Conditional Checks</h3>
<p>窄化变量类型的常见方法是使用<code>if</code>语句，<font color="#de7802">检查变量是否等于某个已知值</font>。编译器非常聪明，知道在<code>if</code>语句中，变量必须与已知值类型相同：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">scientist</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;Rosalind Franklin&#34;</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">51</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">scientist</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;Rosalind Franklin&#34;</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">scientist</span>.<span style="color:#a6e22e">toUpperCase</span>()) <span style="color:#75715e">// ROSALIND FRANKLIN
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 出了if语句，变量的类型既可能是string也可能是number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 因此调用string类型的toUpperCase()方法会出现错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Property &#39;toUpperCase&#39; does not exist on type &#39;string | number&#39;. Property &#39;toUpperCase&#39; does not exist on type &#39;number&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">scientist</span>.<span style="color:#a6e22e">toUpperCase</span>() 
</span></span></code></pre></div><p>除了在<code>if</code>条件中直接对值进行检查，还可以在其中使用<code>typeof</code>操作符窄化变量的类型范围。下面实例代码中，在<code>if</code>中使用<code>typeof</code>检查类型是否为<code>string</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">scientist</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;Rosalind Franklin&#34;</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">51</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// if窄化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">scientist</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;string&#39;</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">scientist</span>.<span style="color:#a6e22e">toUpperCase</span>())
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">scientist</span>.<span style="color:#a6e22e">toFixed</span>())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>来自<code>!</code>和<code>else</code>语句对类型窄化同样有效：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 变量researcher类型为联合类型string | number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">researcher</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;Rosalind Franklin&#34;</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">51</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">researcher</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;string&#34;</span>)) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">researcher</span>.<span style="color:#a6e22e">toFixed</span>(); <span style="color:#75715e">// Ok: number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">researcher</span>.<span style="color:#a6e22e">toUpperCase</span>(); <span style="color:#75715e">// Ok: string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h2 id="literal-types">Literal Types</h2>
<p>介绍了联合和窄化用于处理可能是两种或两种以上类型的值后，再来介绍一下字面量类型。字面量类型是基础类型的更具体版本。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 类型为&#34;Hypatia&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">philosopher</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Hypatia&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 使用typeof打印出来的还是string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">philosopher</span>) <span style="color:#75715e">// string
</span></span></span></code></pre></div><p>上面代码中，<code>philosopher</code>是什么类型？乍一看，你可能会说是字符串，没错，<code>philosopher</code>常量的确是字符串。但是，<code>philosopher</code>并不是一个普通的字符串，它的具体值是<code>&quot;Hypatia&quot;</code>。从技术上讲，<code>philosopher</code>常量的类型是更具体的<code>&quot;Hypatia&quot;</code>类型。</p>
<p>这就是字面类型的概念：<span style="background:rgba(255, 183, 139, 0.55)">是基本类型的某个特定值，而不是这些基本类型的任何其它值</span>。字符串基本类型代表了所有可能存在的字符串集合，而字面量类型<code>&quot;Hypatia&quot;</code>只代表了这一特定字符串。</p>
<p>如果将一个变量声明为<code>const</code>，并直接给它一个字面值，<code>TypeScript</code><font color="#de7802">将推断这个变量的类型是这个字面值类型</font>。这就是为什么在IDE中将鼠标悬停在带有初始字面值的<code>const</code>常量上时，会显示常量的类型为字面值，而不是其基本类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// philosopher的类型为Hypatia
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">philosopher</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Hypatia&#34;</span>
</span></span></code></pre></div><p>可以把每个基本类型看作是所有可能的字面值的联合类型。换句话说，基本类型是该类型所有可能字面值的集合。除了<code>boolean</code>，<code>null</code>和<code>undefined</code>类型，所有其它基本类型（例如<code>number</code>和<code>string</code>）均有无限多的字面值类型。在<code>TypeScript</code>代码中会出现的常见类型如下：</p>
<ul>
<li><code>boolean</code>: 只有<code>true | false</code></li>
<li><code>null</code>和<code>undefined</code>只有一个字面值，就是它们自己</li>
<li><code>number</code>：<code>0 | 1 | 2 | ... | 0.1 | 0.2 | ...</code></li>
<li><code>string</code>:<code>&quot;&quot; | &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | ... | &quot;aa&quot; | &quot;ab&quot; | &quot;ac&quot; | ...</code></li>
</ul>
<p>联合类型<font color="#de7802">可以将字面值类型和基本类型混合使用</font>。例如，下面变量<code>lifespan</code>表示可以用任何数值或已知的几种字符串字面值来表示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">lifespan</span>: <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;ongoing&#34;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;uncertain&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">lifespan</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">89</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">lifespan</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;ongoing&#34;</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Type &#39;true&#39; is not assignable to type &#39;number | &#34;ongoing&#34; | &#34;uncertain&#34;&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">lifespan</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>; 
</span></span></code></pre></div><h3 id="literal-assignability">Literal Assignability</h3>
<p>我们已经知道，不同的基本类型（如<code>number</code>和<code>string</code>）是不能相互赋值的。同样，<font color="#de7802">同一基本类型中的不同字面量类型（如0和1）也不能互相赋值</font>，下面代码会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// specificallyAda的类型为Ada
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">specificallyAda</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Ada&#34;</span>; 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">specificallyAda</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Ada&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果为string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">specificallyAda</span>)  <span style="color:#75715e">// string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误: Type &#39;&#34;B&#34;&#39; is not assignable to type &#39;&#34;Ada&#34;&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">specificallyAda</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;B&#39;</span> 
</span></span></code></pre></div><p>需要注意的是，<font color="#de7802">基本类型的变量不能赋值给对应的字面量类型，但字面量类型可以赋值给相应的基本类型</font>。因为任何特定的字面量字符串值仍然是字符串，下面代码不会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">specificallyAda</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Ada&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">specificallyAda</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Ada&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">someString</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>; <span style="color:#75715e">// Type: string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 可以将字面量类型赋值给器基本类型变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">someString</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">specificallyAda</span>
</span></span></code></pre></div><h2 id="strict-null-checking">Strict Null Checking</h2>
<p>在处理可能存在<code>undefined</code>值时，字面值联合的作用尤其明显。<code>TypeScript</code>是现代编程语言浪潮的一部分，这些语言利用严格的空值检查来解决可怕的<code>billion-dollar mistake</code>。</p>
<h4 id="billion-dollar-mistake">billion-dollar mistake</h4>
<p><code>billion-dollar mistake</code>是一个术语，指许多类型系统在需要不同类型的地方允许<code>null</code>值。在没有<code>strict null checking</code>的语言中，像下面这样将<code>null</code>赋值给<code>string</code>类型的变量是允许的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">firstName</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>; 
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 如果是严格类型检查就会出现错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Type &#39;null&#39; is not assignable to type &#39;string&#39;.
</span></span></span></code></pre></div><p><code>TypeScript</code>编译器包含大量选项，可以改变运行方式。严格空值检查（<code>strictNullChecks</code>）是最有用的选项之一，它表示是否启用严格<code>null</code>值检查。概括来讲，禁用<code>strictNullChecks</code>（设置为<code>false</code>）意味着会为每个类型添加<code>| null | undefined</code>，从而允许任何变量都能接收<code>null</code>或<code>undefined</code>。</p>
<p>如果将<code>strictNullChecks</code>选项设置为<code>false</code>，下面代码会被认为是安全的。但这种方式是错误的，当使用变量<code>nameMaybe</code>调用<code>toLowerCase</code>方法时，它可能是<code>undefined</code>的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">nameMaybe</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;Tony Hoare&#34;</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Potential runtime error: Cannot read property &#39;toLowerCase&#39; of undefined.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">nameMaybe</span>.<span style="color:#a6e22e">toLowerCase</span>() 
</span></span></code></pre></div><p>如果开启了严格空值检查（<code>strictNullChecks</code>设置为<code>false</code>），下面代码将会出现编译错误：<code>'nameMaybe' is possibly 'undefined'</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">nameMaybe</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;Tony Hoare&#34;</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// &#39;nameMaybe&#39; is possibly &#39;undefined&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">nameMaybe</span>.<span style="color:#a6e22e">toLowerCase</span>()  
</span></span></code></pre></div><p>如果没有严格空值检查，就很难确定我们的代码是否会因意外的<code>null</code>或<code>undefined</code>而出错。最佳实践是启用<code>strictNullChecks</code>选项。这样做有助于防止代码崩溃，并消除<code>billion-dollar mistake</code>错误。</p>
<h3 id="truthiness-narrowing">Truthiness Narrowing</h3>
<p>在<code>JavaScript</code>中，除了<code>false, 0, -0, 0n, &quot;&quot;, null, undefined, NaN</code>为<code>falsy</code>值，其它的都是<code>truthy</code>值。如果变量的某些可能值是<code>truthy</code>的，可以通过<code>truthiness</code>检查以窄化变量类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">zeroNaN</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#a6e22e">n</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">zeroNaN</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;true&#39;</span>)
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;false&#39;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">false</span>
</span></span></code></pre></div><p>下面代码中，变量<code>geneticist</code>的类型是<code>string | undefined</code>，因为<code>undefined</code>是<code>falsy</code>值。代码进入<code>if</code>语句体的前提是变量<code>geneticist</code>为<code>truthy</code>值，所以在<code>if</code>语句体中推断出它必须是<code>string</code>类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">geneticist</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;Barbara McClintock&#34;</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 如果变量是truthy，则一定不是undefined，那么一定是字符串
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">geneticist</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">geneticist</span>.<span style="color:#a6e22e">toUpperCase</span>()) <span style="color:#75715e">// BARBARA MCCLINTOCK
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>逻辑运算符执行<code>truthy</code>值检查也同样有效，即使用<code>&amp;&amp;</code>和 <code>?</code>运算符:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 变量geneticist类型为string | undefined
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">geneticist</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;Barbara McClintock&#34;</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果可能为undefined或BARBARA MCCLINTOCK
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">geneticist</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">geneticist</span>.<span style="color:#a6e22e">toUpperCase</span>()) 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果可能为undefined或BARBARA MCCLINTOCK
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">geneticist</span><span style="color:#f92672">?</span>.<span style="color:#a6e22e">toUpperCase</span>()) 
</span></span></code></pre></div><p>需要注意的是，<span style="background:rgba(255, 183, 139, 0.55)">真值检查不能反过来使用</span>。如果知道类型为<code>string | undefined</code>变量的值是<code>falsy</code>的，并不能推断这个值是空字符串还是<code>undefined</code>。</p>
<p>下面代码中，变量<code>biologist</code>的类型为<code>string | false</code>。虽然在<code>if</code>语句体中可以窄化类型为字符串，但<code>else</code>语句体包含<code>biologist</code>为字符串且值为<code>&quot;&quot;</code>，也就是说在<code>else</code>里变量的类型依然为<code>string | false</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 变量类型为联合类型 string | false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">biologist</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#e6db74">&#34;Rachel Carson&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">biologist</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">biologist</span>; <span style="color:#75715e">// Type一定为string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">biologist</span>; <span style="color:#75715e">// Type为false | string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h3 id="variables-without-initial-values">Variables Without Initial Values</h3>
<p>在<code>JavaScript</code>中，变量若没有初始值，则其默认值是<code>undefined</code>。这在类型系统中出现了一种情况：如果<font color="#de7802">将一个变量声明为不包括<code>undefined</code>的类型，然后尝试在赋值前使用它</font>，会出现什么情况。</p>
<p>实际上，<code>TypeScript</code>很聪明，知道在变量赋值之前，其值是<code>undefined</code>。<font color=red>如果在赋值前尝试使用该变量的值，会出现编译错误</font>，即使使用<code>?</code>来访问变量的属性也会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">mathematician</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 即使使用?来访问属性，也会出现编译错误！！！
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Variable &#39;mathematician&#39; is used before being assigned.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">mathematician</span><span style="color:#f92672">?</span>.<span style="color:#a6e22e">length</span>; 
</span></span></code></pre></div><p>请注意，如果<font color="#de7802">变量的类型中包括<code>undefined</code>类型，在未初始化时就使用，不会出现编译错误</font>。在变量类型中添加<code>| undefined</code>是向<code>TypeScript</code>说明，在使用前无需初始化，因为<code>undefined</code>是变量的有效值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">mathematician</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 变量类型包含了undefined，使用前无需初始化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">mathematician</span>) 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">mathematician</span><span style="color:#f92672">?</span>.<span style="color:#a6e22e">length</span>) 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">undefined</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">undefined</span>
</span></span></code></pre></div><p>但需要注意的是，如果在定义联合类型变量时，<font color=red>如果只包含了 <code>| null</code>，而不包含 <code>| undefined</code>，则需要初始化</font>，否则会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">mathematician</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 未初始化时就调用会出现编译错误：Variable &#39;mathematician&#39; is used before being assigned.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">mathematician</span>) 
</span></span></code></pre></div><h2 id="type-aliases">Type Aliases</h2>
<p>在代码中看到的大多数联合类型的子类型一般只有两到三个。但是，有时可能会遇到一些较长的联合类型，如果这种联合类型出现次数较多，会不太方便。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">rawDataFirst</span>: <span style="color:#66d9ef">boolean</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">rawDataSecond</span>: <span style="color:#66d9ef">boolean</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">rawDataThird</span>: <span style="color:#66d9ef">boolean</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>;
</span></span></code></pre></div><p><code>TypeScript</code>包含类型别名，可以为重复使用的类型分配更简单的名称。类型别名以如下方式声明，按照惯例，<font color="#de7802">类型别名以大驼峰命名</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">MyName</span> <span style="color:#f92672">=</span> ...;
</span></span></code></pre></div><p>之前的联合类型，可以简写成如下形式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">RawData</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">boolean</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">rawDataFirst</span>: <span style="color:#66d9ef">RawData</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">rawDataSecond</span>: <span style="color:#66d9ef">RawData</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">rawDataThird</span>: <span style="color:#66d9ef">RawData</span>;
</span></span></code></pre></div><p>类型别名是一项便捷功能，只要代码中使用的类型开始变得复杂，就可以使用它。目前，只包括长联合类型，以后还将包括数组、函数和对象类型等。</p>
<h3 id="type-aliases-are-not-javascript">Type Aliases Are Not JavaScript</h3>
<p>类型别名与类型标注一样，编译后不会输出到<code>JavaScript</code>文件中。<font color=red>类型别名仅存在于类型系统，因此不能在运行时的代码中引用它们</font>。如果试图访问运行时不存在的内容，<code>TypeScript</code>会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">RawData</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">boolean</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：&#39;RawData&#39; only refers to a type, but is being used as a value here.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">RawData</span>) 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">rawData</span>: <span style="color:#66d9ef">RawData</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">rawData</span>, <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">rawData</span>) 
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// false boolean
</span></span></span></code></pre></div><h3 id="combining-type-aliases">Combining Type Aliases</h3>
<p>类型别名在<font color="#f79646">定义时也可以引用其它的类型别名</font>。类型别名相互引用有时会很有用，当一个类型别名是一个联合类型时，它可能包含另一个类型别名。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Id</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">IdMaybe</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Id</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span>;
</span></span></code></pre></div><p>需要注意的是，<span style="background:rgba(255, 183, 139, 0.55)">类型别名不必按使用顺序声明</span>。可以让文件中较早声明的类型别名引用在文件中较后声明的别名。上面代码可以重写，将<code>IdMaybe</code>放在<code>Id</code>之前声明：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">IdMaybe</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Id</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Id</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">id</span>: <span style="color:#66d9ef">IdMaybe</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">id</span>) <span style="color:#75715e">// undefined
</span></span></span></code></pre></div><h1 id="objects">Objects</h1>
<blockquote>
<p>对象字面量是键和值的集合，每个键和值都有自己的类型。前面介绍的基本类型，只是<code>JavaScript</code>常用复杂对象类型的表面。如果<code>TypeScript</code>不能表示对象，用处将十分有限。</p>
</blockquote>
<h2 id="object-types">Object Types</h2>
<p>使用<code>{}</code>创建对象字面量时，<code>TypeScript</code>会<font color="#de7802">根据其属性将其视为新的对象类型</font>。新对象类型具有与对象字面量相同的属性名和对应值类型。访问对象属性的值时可以使用<code>value.member</code>或等同的<code>value['member']</code>语法。</p>
<p>下面代码中，<code>TypeScript</code>认为常量<code>poet</code>的类型是一个对象，该对象具有<code>born</code>和<code>name</code>两个属性，属性<code>born</code>对应的值类型为<code>number</code>，<code>name</code>属性对应值类型为<code>string</code>。访问这两个属性是允许的，但<font color="#de7802">试图访问任何其它不存在的属性都会出现编译错误</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">poet</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">1935</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Mary Oliver&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">poet</span>.<span style="color:#a6e22e">born</span>, <span style="color:#a6e22e">poet</span>.<span style="color:#a6e22e">name</span>, <span style="color:#a6e22e">poet</span>[<span style="color:#e6db74">&#39;born&#39;</span>], <span style="color:#a6e22e">poet</span>[<span style="color:#e6db74">&#39;name&#39;</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 访问不存在的属性会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Property &#39;end&#39; does not exist on type &#39;{ born: number; name: string; }&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">poet</span>.<span style="color:#a6e22e">end</span>; 
</span></span></code></pre></div><p>对象类型是<code>TypeScript</code>理解<code>JavaScript</code>代码的核心概念。除<code>null</code>和<code>undefined</code>之外的每个对象值都有一组成员，<font color=red>必须了解对象类型中的每个值，才能对其进行类型检查</font>。</p>
<h3 id="declaring-object-types">Declaring Object Types</h3>
<p>从现有的对象中直接推断出类型固然是好的，但有时还是需要显式标注对象类型。此时，需要一种方式描述对象类型，将其与满足其类型的对象值区分开来。</p>
<p>对象类型使用与对象字面量相似的语法来描述，但<font color="#f79646">与属性名对应的是其值的类型而不是相应的值</font>。若对象类型变量出现赋值相关的编译错误，显示的是声明对象类型时的语法，清晰易读。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 先声明，声明时未被初始化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">poetLater</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">poetLater</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">123</span>, <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;678&#39;</span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">poetLater</span>) <span style="color:#75715e">// { born: 123, name: &#39;678&#39; }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Type &#39;number&#39; is not assignable to type &#39;{ born: number; name: string; }&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">poetLater</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">123</span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 定义时属性之间也可以使用逗号分隔
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">poetLater</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">number</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">poetLater</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">123</span>, <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;678&#39;</span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">poetLater</span>.<span style="color:#a6e22e">born</span>, <span style="color:#a6e22e">poetLater</span>.<span style="color:#a6e22e">name</span>) <span style="color:#75715e">// 123 678
</span></span></span></code></pre></div><h3 id="aliased-object-types">Aliased Object Types</h3>
<p>重复写类似<code>{ born: number; name: string; }</code>的对象类型很快就会让人厌烦，也容易出错。常见的做法是使用<code>type</code>创建类型别名，为类型赋予一个新名字。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 使用type创建类型别名
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Poet</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 使用逗号分隔属性也可以
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">type Poet = {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    born: number,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    name: string,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">};
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">poetLater</span>: <span style="color:#66d9ef">Poet</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">poetLater</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">1935</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Sara Teasdale&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Type &#39;string&#39; is not assignable to type &#39;Poet&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">poetLater</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Emily Dickinson&#34;</span>; 
</span></span></code></pre></div><h2 id="structural-typing">Structural Typing</h2>
<p><code>TypeScript</code>的类型系统是<code>structural typed</code>的，这意味着<font color="#de7802">任何满足类型的值都可以用作该类型的值</font>。换句话说，当标注一个参数或变量是一个特定对象类型时，就是在声明<span style="background:rgba(255, 183, 139, 0.55)">无论使用什么对象值，它们都需要具有这些属性</span>。</p>
<p>下面<code>WithFirstName</code>和<code>WithLastName</code>别名对象类型都只声明了一个字符串类型的成员。常量<code>hasBoth</code>同时有这两种成员，因此可以赋值给这两种别名对象类型中的任何一种变量：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">WithFirstName</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">firstName</span>: <span style="color:#66d9ef">string</span>; };
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">WithLastName</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">lastName</span>: <span style="color:#66d9ef">string</span>; };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">hasBoth</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">firstName</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Lucille&#34;</span>, <span style="color:#a6e22e">lastName</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Clifton&#34;</span>,};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">withFirstName</span>: <span style="color:#66d9ef">WithFirstName</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">hasBoth</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">withLastName</span>: <span style="color:#66d9ef">WithLastName</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">hasBoth</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">withFirstName</span>, <span style="color:#a6e22e">withLastName</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">hasBoth</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{ <span style="color:#a6e22e">firstName</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;Lucille&#39;</span>, <span style="color:#a6e22e">lastName</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;Clifton&#39;</span> } { <span style="color:#a6e22e">firstName</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;Lucille&#39;</span>, <span style="color:#a6e22e">lastName</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;Clifton&#39;</span> }
</span></span><span style="display:flex;"><span>{ <span style="color:#a6e22e">firstName</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;Lucille&#39;</span>, <span style="color:#a6e22e">lastName</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;Clifton&#39;</span> }
</span></span></code></pre></div><p>需要注意的是，<code>Structural typing</code>与<code>Duck typing</code>不同，后者源于「<font color="#de7802">如果它看起来像鸭子，叫起来像鸭子，那它可能就是鸭子</font>」。<code>JavaScript</code>是<code>Duck typing</code>的，而<code>TypeScript</code>是<code>Structural typing</code>的。</p>
<ul>
<li><code>Structural typing</code>是指<font color="#de7802">有一个静态系统来检查类型</font>，在<code>TypeScript</code>中这个静态系统就是类型检查器。</li>
<li><code>Duck typing</code><font color="#de7802">使用之前不检查对象类型，直到运行时才检查类型</font>。</li>
</ul>
<h3 id="usage-checking">Usage Checking</h3>
<p>当向显式标注为对象类型的变量赋值时，编译器将检查该值是否可赋值给这个对象类型。首先，<span style="background:rgba(255, 183, 139, 0.55)">对象值必须包含对象类型的所有必需属性</span>。如果对象中缺少对象类型所需的任何成员，将会出现编译错误。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">FirstAndLastNames</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">first</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">last</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">hasBoth</span>: <span style="color:#66d9ef">FirstAndLastNames</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">first</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Sarojini&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">last</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Naidu&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 赋值时字面量缺少属性，会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Property &#39;last&#39; is missing in type &#39;{ first: string; }&#39; but required in type &#39;FirstAndLastNames&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">hasOnlyOne</span>: <span style="color:#66d9ef">FirstAndLastNames</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">first</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Sappho&#34;</span>}; 
</span></span></code></pre></div><p>当<span style="background:rgba(255, 183, 139, 0.55)">使用对象字面量赋值时</span>，也不允许两者之间值的类型不匹配。<font color="#de7802">对象类型既指定了所需属性的名称，也指定了这些属性对应值的类型</font>。如果对象属性的对应值类型不匹配，也会出现编译错误。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">TimeRange</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">start</span>: <span style="color:#66d9ef">Date</span>; };
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误: Type &#39;string&#39; is not assignable to type &#39;Date&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">hasDateStr</span>: <span style="color:#66d9ef">TimeRange</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">start</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;1879-02-13&#34;</span>, 
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 下面属性类型是正确的，不会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">hasDate</span>: <span style="color:#66d9ef">TimeRange</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">start</span>: <span style="color:#66d9ef">new</span> Date(),
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">hasDate</span>)
</span></span></code></pre></div><h3 id="excess-property-checking">Excess Property Checking</h3>
<p>如果一个变量声明为对象类型，并且<font color="#de7802">使用字面量初始化时，若字面量中的字段多于其类型所描述的字段时，也会出现编译错误</font>。因此，将变量显式标注为对象类型是一种让类型检查程序确保变量恰好只包含该类型预期字段的方法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Poet</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">poetMatch</span>: <span style="color:#66d9ef">Poet</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">1928</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Maya Angelou&#34;</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">extraProperty</span>: <span style="color:#66d9ef">Poet</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">activity</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;walking&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">1935</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Mary Oliver&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Object literal may only specify known properties, and &#39;activity&#39; does not exist in type &#39;Poet&#39;.
</span></span></span></code></pre></div><p>但需要注意的是，<span style="background:rgba(255, 183, 139, 0.55)">只有在标注为对象类型的位置创建的对象字面量才会触发多余属性检查</span>。提供<font color="#de7802">已有常量或变量存储的对象字面量可以绕过多余属性检查</font>，下面示例绕过了多余属性检查：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Poet</span> <span style="color:#f92672">=</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">number</span>;  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;  
</span></span><span style="display:flex;"><span>}  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">poetMatch</span>: <span style="color:#66d9ef">Poet</span> <span style="color:#f92672">=</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">1928</span>,  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Maya Angelou&#34;</span>  
</span></span><span style="display:flex;"><span>};  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">existingObject</span> <span style="color:#f92672">=</span> {    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">1935</span>, 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Mary Oliver&#34;</span>,  
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 相对于Poet来说是多余属性  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">activity</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;walking&#34;</span>,
</span></span><span style="display:flex;"><span>};  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 绕过多余属性检查
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">extraProperty</span>: <span style="color:#66d9ef">Poet</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">existingObject</span>  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">poetMatch</span>) 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{ <span style="color:#a6e22e">activity</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;walking&#39;</span>, <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">1935</span>, <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;Mary Oliver&#39;</span> }
</span></span></code></pre></div><p>在<span style="background:rgba(255, 183, 139, 0.55)">需要对象类型的任何地方创建新对象时，都会触发多余属性检查</span>，即创建的对象字面量必须与标注的对象类型匹配。禁止多余属性能确保代码整洁并按照期望的方式运行，因为通常在对象类型中声明的多余属性通常是书写时输入了错误的属性名。</p>
<h3 id="nested-object-types">Nested Object Types</h3>
<p>由于<code>JavaScript</code>对象中可以嵌入其它对象成员，因此<code>TypeScript</code>的对象类型也必须能够表示嵌套的对象类型。嵌套类型语法与之前相同，但使用<code>{ ... }</code>对象类型来代替基础类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 创建别名类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Poem</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">firstName</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">lastName</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">poemMatch</span>: <span style="color:#66d9ef">Poem</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">firstName</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Sylvia&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">lastName</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Plath&#34;</span>,
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Lady Lazarus&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 创建字面量对象作为初始值会触发属性检查
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误:Object literal may only specify known properties, and &#39;name&#39; does not exist in type &#39;{ firstName: string; lastName: string; }&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">poemMismatch</span>: <span style="color:#66d9ef">Poem</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Sylvia Plath&#34;</span>,
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Tulips&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>声明<code>Poem</code>类型的另一种方法是将<code>author</code>属性提取到它的别名对象类型<code>Author</code>中。将对象类型中的嵌套类型提取到别名类型中，有助于出现编译出现错误时提供更详细的信息。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Author</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">firstName</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">lastName</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Poem</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span>: <span style="color:#66d9ef">Author</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Object literal may only specify known properties, and &#39;name&#39; does not exist in type &#39;Author&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">poemMismatch</span>: <span style="color:#66d9ef">Poem</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Sylvia Plath&#34;</span>, 
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Tulips&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 也可以使用,分隔属性
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">type Author = {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    firstName: string,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    lastName: string,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">};
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">type Poem = {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    author: Author,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    name: string,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">};
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span></code></pre></div><p>通常来说，为嵌套对象类型创建一个别名类型是个好主意，这样既能使代码更易读，也能使<code>TypeScript</code>的错误信息更易读。</p>
<h3 id="optional-properties">Optional Properties</h3>
<p>对象类型的属性不一定都是必需属性，<font color="#de7802">可以在属性的类型标注的<code>:</code>前加上<code>?</code>来表示它是一个可选属性</font>。下面代码中，<code>Book</code>中的<code>author</code>属性是可选的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Book</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author?</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">ok</span>: <span style="color:#66d9ef">Book</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Rita Dove&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">80</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">normal</span>: <span style="color:#66d9ef">Book</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">80</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 不能缺少必需属性，否则会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Property &#39;pages&#39; is missing in type &#39;{ author: string; }&#39; but required in type &#39;Book&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">missing</span>: <span style="color:#66d9ef">Book</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Rita Dove&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>需要注意的是，可选属性与属性的类型标注为包括<code>undefined</code>的联合类型是不同的。<font color="#de7802">声明为可选属性，属性可以不存在</font>（此时属性对应值为<code>undefined</code>）。<font color=red>但使用<code>| undefined</code>声明的属性，其值必须存在</font>，即使该属性的值是<code>undefined</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Writers</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">editor?</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">hasRequired</span>: <span style="color:#66d9ef">Writers</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span>: <span style="color:#66d9ef">undefined</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 变量带undefined的联合类型可以不初始化，但属性undefined的联合类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">test</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">test</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 触发属性检查，author属性必须有，且必须提供值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">missingRequired</span>: <span style="color:#66d9ef">Writers</span> <span style="color:#f92672">=</span> {}; <span style="color:#75715e">//  Property &#39;author&#39; is missing in type &#39;{}&#39; but required in type &#39;Writers&#39;.
</span></span></span></code></pre></div><h2 id="unions-of-object-types">Unions of Object Types</h2>
<blockquote>
<p>如果变量的初始值可能是多种对象类型之一，<code>TypeScript</code>将推断变量的类型为对象类型的联合。<font color="#de7802">该联合类型为每种可能的类型提供一个成分</font>，类型上的每种可能属性都将出现在每个组成元素中，尽管它们<span style="background:rgba(255, 183, 139, 0.55)">在没有初始值的任何类型中都是可选类型</span>。</p>
</blockquote>
<h3 id="inferred-object-type-unions">Inferred Object-Type Unions</h3>
<p>下面代码中，常量<code>poem</code>值一定有<code>name</code>属性，可能有<code>pages</code>或<code>rhymes</code>属性。常量<code>poem</code>的类型被推断为<code>{name: string, pages: number, rhymes?: undefined} | {name: string, rhymes: boolean, pages?: undefined}</code> 。请注意下面非共有属性在其他不包含该属性的对象类型中是可选的，并且值类型是<code>undefined</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// poem的类型被推断为{name: string, pages: number, rhymes?: undefined} | {name: string, rhymes: boolean, pages?: undefined}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">poem</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;The Double Image&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">7</span>
</span></span><span style="display:flex;"><span>} <span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Her Kind&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">rhymes</span>: <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">name</span>  <span style="color:#75715e">// 类型为 string 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">pages</span>; <span style="color:#75715e">// 类型为 number | undefined
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">rhymes</span>; <span style="color:#75715e">// 类型为 boolean | undefined
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 可能的执行结果:The Double Image 7 undefined 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">name</span>, <span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">pages</span>, <span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">rhymes</span>, <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">poem</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 可能的执行结果：string undefined boolean
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">name</span>, <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">pages</span>, <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">rhymes</span>);
</span></span></code></pre></div><h3 id="explicit-object-type-unions">Explicit Object-Type Unions</h3>
<p>也可以通过对象类型的联合来更明确地标注对象类型，这样做需要写更多的代码，好处是可以对对象类型有更多的控制。需要注意的是，<strong><font color="#de7802">如果是对象类型的联合，则只允许访问存在于联合类型所有子类型上的属性</font></strong>。这与上面将变量推断为对象类型的联合有明显的区别：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">PoemWithPages</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">PoemWithRhymes</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">rhymes</span>: <span style="color:#66d9ef">boolean</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 定义别名类型，该类型是对象类型的联合
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Poem</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">PoemWithPages</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">PoemWithRhymes</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">poem</span>: <span style="color:#66d9ef">Poem</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span>  <span style="color:#f92672">?</span> {<span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;The Double Image&#34;</span>, <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">7</span>} <span style="color:#f92672">:</span> {<span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Her Kind&#34;</span>, <span style="color:#a6e22e">rhymes</span>: <span style="color:#66d9ef">true</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 访问联合类型所有子类型的公有属性，不会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">name</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Property &#39;pages&#39; does not exist on type &#39;Poem&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">pages</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Property &#39;rhymes&#39; does not exist on type &#39;Poem&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">rhymes</span>;
</span></span></code></pre></div><h3 id="narrowing-object-types">Narrowing Object Types</h3>
<p>如果类型检查器发现在某个位置的代码<span style="background:rgba(255, 183, 139, 0.55)">只有在联合类型值包含特定属性的情况下才能运行，那么会将联合类型窄化到只包含该属性的子类型</span>。换句话说，如果在代码中检查对象，类型窄化功能也适用。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">PoemWithPages</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">PoemWithRhymes</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">rhymes</span>: <span style="color:#66d9ef">boolean</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Poem</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">PoemWithPages</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">PoemWithRhymes</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">poem</span>: <span style="color:#66d9ef">Poem</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span>  <span style="color:#f92672">?</span> {<span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;The Double Image&#34;</span>, <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">7</span>} <span style="color:#f92672">:</span> {<span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Her Kind&#34;</span>, <span style="color:#a6e22e">rhymes</span>: <span style="color:#66d9ef">true</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// pages若在poem中，则可以访问该属性
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (<span style="color:#e6db74">&#34;pages&#34;</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">poem</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">pages</span>)
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果没有pages，那么必定有属性rhymes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">rhymes</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>请注意，<code>TypeScript</code>不允许使用像<code>if (poem.pages)</code>这样的真值检查。<span style="background:rgba(255, 183, 139, 0.55)">试图访问可能不存在的对象属性会被视为错误，即使用起来的方式看起来像是类型保护</span>。</p>
<h3 id="discriminated-unions">Discriminated Unions</h3>
<p><code>JavaScript</code>和<code>TypeScript</code>中另一种流行的联合类型对象形式是在对象上设置一个属性，用于指示对象具体是哪种类型。这种类型被称为判别联合（<code>discriminated union</code>），指示对象类型的属性被称为<code>discriminant</code>。<code>TypeScript</code>对<code>discriminant</code>属性进行类型保护的代码执行类型窄化。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// type表示判别类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">PoemWithPages</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;pages&#39;</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">PoemWithRhymes</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">rhymes</span>: <span style="color:#66d9ef">boolean</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;rhymes&#39;</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Poem</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">PoemWithPages</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">PoemWithRhymes</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">poem</span>: <span style="color:#66d9ef">Poem</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;The Double Image&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">7</span>, 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;pages&#34;</span>
</span></span><span style="display:flex;"><span>} <span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Her Kind&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">rhymes</span>: <span style="color:#66d9ef">true</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;rhymes&#34;</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">poem</span>.<span style="color:#66d9ef">type</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;pages&#34;</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`It&#39;s got pages: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">pages</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`It rhymes: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">rhymes</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="intersection-types">Intersection Types</h2>
<p>联合类型表示一个值的类型可能是两个或多个不同类型中的一个。<code>TypeScript</code>允许同时表示多种类型，即<code>intersection</code>（交叉）类型。<code>intersection</code>类型通常与别名对象类型一起使用，以创建结合多个现有类型的新类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Artwork</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">genre</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Writing</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 可以直接使用换行区分属性
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">type Artwork = {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    genre: string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    name: string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">};
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">type Writing = {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    pages: number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    name: string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">};
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 可以直接使用逗号区分属性
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">type Artwork = {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    genre: string,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    name: string,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">};
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">type Writing = {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    pages: number,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    name: string,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">};
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 定义新的交叉类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">WrittenArt</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Artwork</span> <span style="color:#f92672">&amp;</span> <span style="color:#a6e22e">Writing</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 必须同时具有name,pages和genre属性
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">writtenAndArt</span>: <span style="color:#66d9ef">WrittenArt</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;test&#39;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">genre</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;man&#39;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">123</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">writtenAndArt</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{ <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;test&#39;</span>, <span style="color:#a6e22e">genre</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;man&#39;</span>, <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">123</span> }
</span></span></code></pre></div><p><code>Intersection</code>类型可以与联合类型结合使用。在某些场景这种结合有助于只在一种类型中描述<code>discriminated unions</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ShortPoem</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">author</span>: <span style="color:#66d9ef">string</span> } <span style="color:#f92672">&amp;</span> (<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">kigo</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;haiku&#34;</span>;
</span></span><span style="display:flex;"><span>} <span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">meter</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;villanelle&#34;</span>;
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*  可以去掉第一个用于联合的 | 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">type ShortPoem = { author: string } &amp; ({  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    kigo: string;  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    type: &#34;haiku&#34;;  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">} | {  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    meter: number;  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    type: &#34;villanelle&#34;;  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">});  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">morningGlory</span>: <span style="color:#66d9ef">ShortPoem</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Fukuda Chiyo-ni&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">kigo</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Morning Glory&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;haiku&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 下面会出现编译错误： Type &#39;{ author: string; type: &#34;villanelle&#34;; }&#39; is not assignable to type &#39;{ author: string; } &amp; { meter: number; type: &#34;villanelle&#34;; }&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">oneArt</span>: <span style="color:#66d9ef">ShortPoem</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Elizabeth Bishop&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;villanelle&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="dangers-of-intersection-types">Dangers of Intersection Types</h3>
<p><code>Intersection</code>（交叉类型）是一个有用的概念，但使用时很容易让自己或<code>TypeScript</code>编译器感到困惑。<font color="#de7802">建议在使用交叉类型时尽量简化代码</font>。</p>
<p>当创建了复杂的交叉类型（例如与联合类型交叉）时，赋值错误信息就会变得难以理解。这是类型编程语言的一个共同主题：<font color="#4f81bd">创建的类型越复杂，就越难理解来自类型检查器的错误信息</font>。</p>
<p>以前面代码片段中的<code>ShortPoem</code>为例，如果将该类型拆分为一系列别名对象类型，<code>TypeScript</code>就可以打印这些别名，可读性就会大大提高：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ShortPoemBase</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span>: <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Haiku</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">ShortPoemBase</span> <span style="color:#f92672">&amp;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">kigo</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;haiku&#34;</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Villanelle</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">ShortPoemBase</span> <span style="color:#f92672">&amp;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">meter</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;villanelle&#34;</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ShortPoem</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Haiku</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">Villanelle</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Type &#39;{ author: string; type: &#34;villanelle&#34;; }&#39; is not assignable to type &#39;ShortPoem&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">oneArt</span>: <span style="color:#66d9ef">ShortPoem</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Elizabeth Bishop&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;villanelle&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="never">never</h3>
<p>使用<code>&amp;</code>声明<code>Intersection</code><font color="#de7802">类型很容易被滥用，创建出一种不可能的类型</font>。基本类型不能作为交叉类型的成员组合在一起，因为一个值不可能同时是多个基本类型（除了<code>null</code>或<code>undefined</code>）。如果尝试将两个基本类型交叉在一起，就会产生由关键字<code>never</code>表示的<code>never</code>类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 一个变量不可能既是number又是string类型，所以NotPossible的类型为never
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">NotPossible</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">string</span>
</span></span></code></pre></div><p>类型<code>never</code>称为<code>bottom type</code>或<code>empty type</code>。<font color="#de7802">底层类型是指没有可能的值，也是无法到达的类型</font>。==不能向标注为底层类型的位置提供任何类型值，否则会出现编译错误==：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">NotPossible</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Type &#39;number&#39; is not assignable to type &#39;never&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">notNumber</span>: <span style="color:#66d9ef">NotPossible</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; 
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Type &#39;number&#39; is not assignable to type &#39;never&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">notString</span>: <span style="color:#66d9ef">never</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>; 
</span></span></code></pre></div><p>大多数<code>TypeScript</code>项目很少使用<code>never</code>类型，<code>never</code>偶尔会出现在代码中表示不可能的状态。但多数情况下，很可能是误用<code>Intersection</code>（交叉）类型造成的错误。</p>
<h1 id="functions">Functions</h1>
<p>前面介绍了如何使用类型标注来声明变量和常量的类型。现在，可以看看如何对函数的参数和返回值类型进行同样的标注。</p>
<h2 id="function-parameters">Function Parameters</h2>
<p>下面定义了一个函数，参数为<code>song</code>，并在函数体中打印了这个参数的值。在声明该函数时形参并没有显式地标注类型，那么<code>TypeScript</code>会认为这个参数的类型是<code>any</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">sing</span>(<span style="color:#a6e22e">song</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Singing: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span><span style="color:#e6db74">}</span><span style="color:#e6db74">!`</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果编译设置的是严格模式，上面代码会出现编译错误：<code>Parameter 'song' implicitly has an 'any' type</code>。与变量一样，允许使用类型标注函数形参的类型。可以使用<code>: string</code>来告诉编译器形参<code>song</code>的类型是字符串类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">sing</span>(<span style="color:#a6e22e">song</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Singing: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span><span style="color:#e6db74">}</span><span style="color:#e6db74">!`</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="required-parameters">Required Parameters</h3>
<p><code>JavaScript</code>函数允许使用任意数量的实参(<code>arguments</code>)调用函数，而<code>TypeScript</code><span style="background:rgba(255, 183, 139, 0.55)">假定函数中声明的所有参数都是必需的</span>。如果使用错误的实参数来调用函数，将会出现编译错误。</p>
<p>如果函数调用的实参过少或过多，<code>TypeScript</code>的实参计数器就会发挥作用。下面函数<code>singTwo</code>要求有两个参数，因此传递<code>1</code>个或<code>3</code>个参数都是不允许的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">singTwo</span>(<span style="color:#a6e22e">first</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">second</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">first</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> / </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">second</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Expected 2 arguments, but got 1.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">singTwo</span>(<span style="color:#e6db74">&#34;Ball and Chain&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Expected 2 arguments, but got 3.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">singTwo</span>(<span style="color:#e6db74">&#34;Go Your Own Way&#34;</span>, <span style="color:#e6db74">&#34;The Chain&#34;</span>, <span style="color:#e6db74">&#34;Dreams&#34;</span>);
</span></span></code></pre></div><p>实际上，<font color="#e36c09">强制要求向函数提供必需的参数</font>，有助于执行类型安全。如果不能确保这些参数值都存在，可能会导致代码出现意外行为。</p>
<p>形参（<code>parameter</code>）是指函数声明的预期参数。实参（<code>arguments</code>）是指函数调用时提供给形参的值。在上面示例中，<code>first</code>和<code>second</code>是形参，而<code>&quot;Dream&quot;</code>等字符串是实参。</p>
<h3 id="optional-parameters">Optional Parameters</h3>
<p><code>TypeScript</code>允许将形参标注为可选参数，即在其类型标注的<code>:</code>前添加<code>?</code>（类似于对象类型的可选属性）。<font color=red>函数调用不需要向可选参数提供实参，因为它们的类型总是以<code>| undefined</code>作为联合类型</font>。</p>
<p>下面<code>announceSong</code>函数中，<code>singer</code>形参被标记为可选参数，它的类型是<code>string | undefined</code>。对于可选参数，函数的调用者可以不提供实参（此时其值为<code>undefined</code>）。如果主动提供了<code>singer</code>对应的实参，它的值可能是一个字符串值或<code>undefined</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 声明singer为可选参数，且为最后一个形参
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">announceSong</span>(<span style="color:#a6e22e">song</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">singer?</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Song: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">singer</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Singer: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">singer</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">announceSong</span>(<span style="color:#e6db74">&#34;Greensleeves&#34;</span>); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">announceSong</span>(<span style="color:#e6db74">&#34;Greensleeves&#34;</span>, <span style="color:#66d9ef">undefined</span>); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">announceSong</span>(<span style="color:#e6db74">&#34;Chandelier&#34;</span>, <span style="color:#e6db74">&#34;Sia&#34;</span>); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 上面三次调用的执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">Song</span>: <span style="color:#66d9ef">Greensleeves</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Song</span>: <span style="color:#66d9ef">Greensleeves</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Song</span>: <span style="color:#66d9ef">Chandelier</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Singer</span>: <span style="color:#66d9ef">Sia</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 在调用函数时，如果没有为可选参数提供实参，其值为undefined
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">announceSong</span>(<span style="color:#a6e22e">song</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">singer?</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Song: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Singer: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">singer</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">announceSong</span>(<span style="color:#e6db74">&#34;test&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">Song</span>: <span style="color:#66d9ef">test</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Singer</span>: <span style="color:#66d9ef">undefined</span> <span style="color:#75715e">// 未传入参数时，值为undefined
</span></span></span></code></pre></div><p>可选参数与包含<code>| undefined</code>的联合类型参数不同。调用函数时，未用<code>?</code>标记为可选的参数必需提供实参，即使其值是<code>undefined</code>。<span style="background:rgba(255, 183, 139, 0.55)">函数的可选参数必须是最后一个参数，若将可选参数放在必需参数前，会出现编译错误</span>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 将可选参数放到必需参数前出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// A required parameter cannot follow an optional parameter.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">announceSong</span>(<span style="color:#a6e22e">song?</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">singer</span>: <span style="color:#66d9ef">string</span>) {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Song: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Singer: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">singer</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果定义的函数参数列表后面有多个可选参数，<font color="#de7802">调用时若想省略前面的可选参数，需要显式传入<code>undefined</code></font>。下面定义的<code>announceSong</code>函数，如果只想给函数最后一个参数传入有效实参，则需要将前面的参数都传入<code>undefined</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">announceSong</span>(<span style="color:#a6e22e">song?</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">singer?</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">name?</span>: <span style="color:#66d9ef">string</span>) {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Song: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Singer: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">singer</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">name</span>)  
</span></span><span style="display:flex;"><span>}  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">announceSong</span>(<span style="color:#e6db74">&#39;test&#39;</span>)  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">announceSong</span>(<span style="color:#66d9ef">undefined</span>, <span style="color:#e6db74">&#39;test&#39;</span>) 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">announceSong</span>(<span style="color:#66d9ef">undefined</span>, <span style="color:#66d9ef">undefined</span>, <span style="color:#e6db74">&#39;test&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">Song</span>: <span style="color:#66d9ef">test</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Singer</span>: <span style="color:#66d9ef">undefined</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">undefined</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Song</span>: <span style="color:#66d9ef">undefined</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Singer</span>: <span style="color:#66d9ef">test</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">undefined</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Song</span>: <span style="color:#66d9ef">undefined</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Singer</span>: <span style="color:#66d9ef">undefined</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">test</span>
</span></span></code></pre></div><h3 id="default-parameters">Default Parameters</h3>
<p>如果函数定义时参数有默认值且没有指明类型，将会根据默认值推断参数的类型。下面<code>rateSong</code>函数中，参数<code>rating</code>的类型被推断为<code>number</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">rateSong</span>(<span style="color:#a6e22e">song</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">rating</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> gets </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">rating</span><span style="color:#e6db74">}</span><span style="color:#e6db74">/5 stars!`</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">rateSong</span>(<span style="color:#e6db74">&#34;Photograph&#34;</span>); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">rateSong</span>(<span style="color:#e6db74">&#34;Set Fire to the Rain&#34;</span>, <span style="color:#ae81ff">5</span>); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">rateSong</span>(<span style="color:#e6db74">&#34;Set Fire to the Rain&#34;</span>, <span style="color:#66d9ef">undefined</span>); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 会出现编译错误：Argument of type &#39;string&#39; is not assignable to parameter of type &#39;number&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">rateSong</span>(<span style="color:#e6db74">&#34;At Last!&#34;</span>, <span style="color:#e6db74">&#34;100&#34;</span>); 
</span></span></code></pre></div><p>具有<font color="#e36c09">默认值的参数若不位于形参列表的末尾，调用时则不能省略该参数，如果要触发默认值，必须显式地传入</font><code>undefined</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">hello3</span>(<span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>, <span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">hello3</span>(<span style="color:#66d9ef">undefined</span>, <span style="color:#ae81ff">890</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">3</span> <span style="color:#ae81ff">890</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 如果省略默认参数则会出现编译错误: Expected 2 arguments, but got 1.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">hello3</span>(<span style="color:#ae81ff">13</span>)
</span></span></code></pre></div><h3 id="rest-parameters">Rest Parameters</h3>
<p>在<code>JavaScript</code>中<font color="#e36c09">展开操作符<code>...</code>必须是函数声明的最后一个参数</font>，表示从该参数开始传递给函数的所有<code>rest</code>参数都应存储在一个数组中。需要注意的是，<font color=red>一个函数只能有一个<code>rest</code>参数</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 编译错误： A rest parameter must be last in a parameter list.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">singAllTheSongs</span>(...<span style="color:#a6e22e">songs</span>: <span style="color:#66d9ef">string</span>[], <span style="color:#a6e22e">singer</span>: <span style="color:#66d9ef">string</span>) {  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">song</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">songs</span>) {  
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, by </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">singer</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 一个函数只能有一个rest parameters
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">singAllTheSongs</span>(...<span style="color:#a6e22e">songs</span>: <span style="color:#66d9ef">string</span>[], ...<span style="color:#a6e22e">singer</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">number</span>]) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">song</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">songs</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, by </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">singer</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在<code>TypeScript</code>中允许标注<code>rest</code>参数的类型，与普通参数类似，只是在末尾添加了<code>[]</code>语法，表示这是一个数组。下面函数<code>singAllTheSongs</code>允许接受<code>0</code>个或多个字符串类型的实参：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">singAllTheSongs</span>(<span style="color:#a6e22e">singer</span>: <span style="color:#66d9ef">string</span>, ...<span style="color:#a6e22e">songs</span>: <span style="color:#66d9ef">string</span>[]) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">song</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">songs</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, by </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">singer</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">singAllTheSongs</span>(<span style="color:#e6db74">&#34;Alicia Keys&#34;</span>); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">singAllTheSongs</span>(<span style="color:#e6db74">&#34;Lady Gaga&#34;</span>, <span style="color:#e6db74">&#34;Bad Romance&#34;</span>, <span style="color:#e6db74">&#34;Just Dance&#34;</span>, <span style="color:#e6db74">&#34;Poker Face&#34;</span>); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">Bad</span> <span style="color:#a6e22e">Romance</span>, <span style="color:#a6e22e">by</span> <span style="color:#a6e22e">Lady</span> <span style="color:#a6e22e">Gaga</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Just</span> <span style="color:#a6e22e">Dance</span>, <span style="color:#a6e22e">by</span> <span style="color:#a6e22e">Lady</span> <span style="color:#a6e22e">Gaga</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Poker</span> <span style="color:#a6e22e">Face</span>, <span style="color:#a6e22e">by</span> <span style="color:#a6e22e">Lady</span> <span style="color:#a6e22e">Gaga</span>
</span></span></code></pre></div><h2 id="return-types">Return Types</h2>
<p>如果编译器知道函数的所有可能返回值，就能推断出函数的返回类型。下面代码中，<code>TypeScript</code>推断函数<code>singSongs</code>返回一个<code>number</code>，即返回类型为<code>number</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">singSongs</span>(<span style="color:#a6e22e">songs</span>: <span style="color:#66d9ef">string</span>[]) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">song</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">songs</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">songs</span>.<span style="color:#a6e22e">length</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果函数包含多个不同返回语句，编译器<font color="#e36c09">将返回类型推断为所有可能返回值类型的联合</font>。下面函数<code>getSongAt</code>的返回类型将被推断为<code>string | undefined</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getSongAt</span>(<span style="color:#a6e22e">songs</span>: <span style="color:#66d9ef">string</span>[], <span style="color:#a6e22e">index</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">index</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">songs</span>.<span style="color:#a6e22e">length</span> <span style="color:#f92672">?</span> <span style="color:#a6e22e">songs</span>[<span style="color:#a6e22e">index</span>] <span style="color:#f92672">:</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="explicit-return-types">Explicit Return Types</h3>
<p>如同变量声明，通常不建议使用类型标注来显式声明函数的返回值类型。不过，在某些情况下，显式的返回类型标注对函数很有用：</p>
<ul>
<li>可能希望强制具有多种可能返回值的函数始终返回相同类型的值。</li>
<li><code>TypeScript</code>拒绝尝试推断递归函数的返回类型。</li>
<li>加快超大型项目中的<code>TypeScript</code>类型检查速度。</li>
</ul>
<p>函数声明的返回值类型标注位于参数列表的右圆括号之后。对于函数来说，这恰好位于其声明的左大括号<code>{</code>之前，如下函数声明所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">singSongsRecursive</span>(<span style="color:#a6e22e">songs</span>: <span style="color:#66d9ef">string</span>[], <span style="color:#a6e22e">count</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">songs</span>.<span style="color:#a6e22e">length</span> <span style="color:#f92672">?</span> <span style="color:#a6e22e">singSongsRecursive</span>(<span style="color:#a6e22e">songs</span>.<span style="color:#a6e22e">slice</span>(<span style="color:#ae81ff">1</span>), <span style="color:#a6e22e">count</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">:</span> <span style="color:#a6e22e">count</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>对于箭头函数（也称为<code>lambdas</code>表达式）来说，返回类型标注正好位于箭头<code>=&gt;</code>之前。下面定义了一个箭头函数<code>singSongsRecursive</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">singSongsRecursive</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">songs</span>: <span style="color:#66d9ef">string</span>[], <span style="color:#a6e22e">count</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">songs</span>.<span style="color:#a6e22e">length</span> <span style="color:#f92672">?</span> <span style="color:#a6e22e">singSongsRecursive</span>(<span style="color:#a6e22e">songs</span>.<span style="color:#a6e22e">slice</span>(<span style="color:#ae81ff">1</span>), <span style="color:#a6e22e">count</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">:</span> <span style="color:#a6e22e">count</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">singRecursive</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">string</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">input</span>.<span style="color:#a6e22e">length</span> <span style="color:#f92672">?</span> <span style="color:#a6e22e">singRecursive</span>(<span style="color:#a6e22e">input</span>.<span style="color:#a6e22e">slice</span>(<span style="color:#ae81ff">1</span>)) <span style="color:#f92672">:</span> <span style="color:#a6e22e">input</span>.<span style="color:#a6e22e">length</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">len</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">singRecursive</span>(<span style="color:#e6db74">&#39;123&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">len</span>) <span style="color:#75715e">// 0
</span></span></span></code></pre></div><p>如果<font color="#e36c09">函数体中返回语句对应的值不能赋值给函数标注的返回类型</font>，将会出现编译错误。下面代码中，函数本应返回的类型为<code>Date | undefined</code>，但在函数体中却返回了<code>string</code>，因此会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getSongRecordingDate</span>(<span style="color:#a6e22e">song</span>: <span style="color:#66d9ef">string</span>)<span style="color:#f92672">:</span> Date <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">switch</span> (<span style="color:#a6e22e">song</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;Strange Fruit&#34;</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> Date(<span style="color:#e6db74">&#39;April 20, 1939&#39;</span>); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;Greensleeves&#34;</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 编译错误: Type &#39;string&#39; is not assignable to type &#39;Date&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;unknown&#34;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">undefined</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="function-types">Function Types</h2>
<p><code>JavaScript</code>允许将函数作为值传递。这意味着需要一种方法来声明用于存放函数类型的参数或变量。<font color="#e36c09">函数类型标注语法与箭头函数类似，只是用类型代替了函数体</font>。下面变量<code>nothingInGivesString</code>的类型标注描述了一个无参数，返回字符串值的函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">nothingInGivesString</span><span style="color:#f92672">:</span> () <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">string</span>;
</span></span></code></pre></div><p>下面定义的变量<code>inputAndOutput</code>类型标注是一个函数。这个函数有一个<code>string[]</code>类型的形参，一个可选的形参<code>count</code>，并返回一个<code>number</code>类型值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">inputAndOutput</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">songs</span>: <span style="color:#66d9ef">string</span>[], <span style="color:#a6e22e">count?</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">number</span>;
</span></span></code></pre></div><p>函数类型常用于描述回调：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">runOnSongs</span>(<span style="color:#a6e22e">songs</span>: <span style="color:#66d9ef">string</span>[], <span style="color:#a6e22e">getSongAt</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">index</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">songs</span>.<span style="color:#a6e22e">length</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">getSongAt</span>(<span style="color:#a6e22e">i</span>));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">runOnSongs2</span>(<span style="color:#a6e22e">songs</span>: <span style="color:#66d9ef">string</span>[], <span style="color:#a6e22e">getSongAt</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">index</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span> [<span style="color:#66d9ef">string</span>, <span style="color:#66d9ef">number</span>]) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">songs</span>.<span style="color:#a6e22e">length</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">getSongAt</span>(<span style="color:#a6e22e">i</span>));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getSongAt</span>(<span style="color:#a6e22e">index</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">songs</span>[<span style="color:#a6e22e">index</span>]<span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">runOnSongs</span>(<span style="color:#a6e22e">getSongAt</span>); <span style="color:#75715e">// Ok
</span></span></span></code></pre></div><h3 id="function-type-parentheses">Function Type Parentheses</h3>
<p>函数类型可以放置在任何需要类型标注的地方，包括联合类型。在联合类型中，可以<font color="#e36c09">使用圆括号来表示哪一部分是函数返回值哪一部分是联合类型的函数子类型</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// Type is a function that returns a union: string | undefined
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">returnsStringOrUndefined</span><span style="color:#f92672">:</span> () <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type is either undefined or a function that returns a string 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">maybeReturnsString</span><span style="color:#f92672">:</span> (() <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">string</span>) <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>;
</span></span></code></pre></div><h3 id="parameter-type-inferences">Parameter Type Inferences</h3>
<p>如果必须为编写的每个函数（包括用作参数的内联函数）声明参数类型，将会非常麻烦。幸运的是，可以推断出函数中的参数类型，即<font color="#de7802">使用声明时相同位置的参数类型</font>。</p>
<p>下面示例代码中，变量<code>singer</code>是一个接收字符串类型形参的函数，因此赋值给<code>singer</code>的函数中的<code>song</code>参数也是一个字符串类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">singer</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">song</span>: <span style="color:#66d9ef">string</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// song的类型被推断为string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Type of song: string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">singer</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">song</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">str</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">`Singing: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span>.<span style="color:#a6e22e">toUpperCase</span>()<span style="color:#e6db74">}</span><span style="color:#e6db74">!`</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">str</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">str</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">singer</span>(<span style="color:#e6db74">&#39;test&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 参数名可以定义时不一致
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">singer</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">singer</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">str</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">`Singing: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">singer</span>.<span style="color:#a6e22e">toUpperCase</span>()<span style="color:#e6db74">}</span><span style="color:#e6db74">!`</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">str</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">str</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>实际上，<font color="#de7802">作为实参传递给函数类型形参的函数，其参数类型也能被推断出来</font>。下面示例代码中，参数<code>song</code>和<code>index</code>的类型被推断为<code>string</code>和<code>number</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">songs</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;Call Me&#34;</span>, <span style="color:#e6db74">&#34;Jolene&#34;</span>, <span style="color:#e6db74">&#34;The Chain&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">songs</span>.<span style="color:#a6e22e">forEach</span>((<span style="color:#a6e22e">song</span>, <span style="color:#a6e22e">index</span>) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> is at index </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">index</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>});
</span></span></code></pre></div><h3 id="function-type-aliases">Function Type Aliases</h3>
<p>创建类型别名的<code>type</code>也可以用于函数，下面代码中类型别名<code>StringToNumber</code>是一个接收<code>string</code>并返回<code>number</code>的函数，这意味着别名类型<code>StringToNumber</code>可以用来标注函数变量的类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">StringToNumber</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">string</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">stringToNumber</span>: <span style="color:#66d9ef">StringToNumber</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// input被推断为字符串类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">stringToNumber</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">input</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">input</span>.<span style="color:#a6e22e">length</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">stringToNumber</span>(<span style="color:#e6db74">&#39;1233199&#39;</span>))  <span style="color:#75715e">// 7
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">stringToNumber</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">input</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">123</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">stringToNumber</span>(<span style="color:#e6db74">&#39;3455&#39;</span>)) <span style="color:#75715e">// 123
</span></span></span></code></pre></div><p>类似地，函数的类型别名也可以用于函数形参的声明：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">NumberToString</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">usesNumberToString</span>(<span style="color:#a6e22e">numberToString</span>: <span style="color:#66d9ef">NumberToString</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`The string is: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">numberToString</span>(<span style="color:#ae81ff">1234</span>)<span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="more-return-types">More Return Types</h2>
<p>有些函数并不返回任何值，它们要么没有<code>return</code>语句，要么只有无返回值的<code>return</code>语句。<code>TypeScript</code>允许<font color="#e36c09">使用<code>void</code>关键字来说明这种不返回任何值函数的返回类型</font>。</p>
<p>返回类型为<code>void</code>的函数体中不能返回任何值，否则会出现编译错误。下面<code>logSong</code>函数被声明为返回<code>void</code>，因此在函数体中不允许有返回值。因为在函数体中出现了<code>return true</code>，所以会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">logSong</span>(<span style="color:#a6e22e">song</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">void</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">song</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 出现编译错误：Type &#39;boolean&#39; is not assignable to type &#39;void&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 无返回值的函数不能返回值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>; 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>void</code>可以作为函数返回类型。将函数返回类型标注<code>void</code>时，<em><strong><font color="#e36c09">表示传入函数的任何返回值都将被忽略</font></strong></em>。下面代码中，<code>songLogger</code>变量代表了一个函数，它接受一个<code>string</code>参数，并且不返回任何值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">songLogger</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">song</span>: <span style="color:#66d9ef">string</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">void</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">songLogger</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">song</span>) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">songLogger</span>(<span style="color:#e6db74">&#34;Heart of Glass&#34;</span>); <span style="color:#75715e">// Ok
</span></span></span></code></pre></div><p>请注意，尽管<code>JavaScript</code>函数在没有返回值的情况下默认会返回<code>undefined</code>，但<font color="#e36c09"><code>void</code>并不等同于<code>undefined</code>。<code>void</code>意味着函数的返回值将被忽略，而<code>undefined</code>则是要返回的字面量</font>。如果尝试将<code>void</code>类型的值赋给类型包括<code>undefined</code>的变量，将会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">returnsVoid() {</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">lazyValue</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 将void赋值给变量出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Type &#39;void&#39; is not assignable to type &#39;string | undefined&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">lazyValue</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">returnsVoid</span>(); 
</span></span></code></pre></div><p>返回值<code>undefined</code>和<code>void</code>之间的区别，对于忽略传递到形参为函数类型的，并且该形参函数的返回类型标注为<code>void</code>的实参函数的任何返回值特别有用。例如，数组的内置<code>forEach</code>方法声明的形参函数的返回类型为<code>void</code>，<span style="background:rgba(240, 107, 5, 0.2)">它可以忽略任何传入的实参函数的返回值</span>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// forEach的定义
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">forEach</span>(<span style="color:#a6e22e">callbackfn</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">T</span>, <span style="color:#a6e22e">index</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">array</span>: <span style="color:#66d9ef">T</span>[]) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">void</span>, <span style="color:#a6e22e">thisArg?</span>: <span style="color:#66d9ef">any</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">void</span>;
</span></span></code></pre></div><p>下面<code>saveRecords</code>函数中，<code>records.push(record)</code>返回一个数值（数组<code>push()</code>方法的返回值，表示数组的元素个数），但仍允许作为传递给<code>newRecords.forEach</code>的箭头函数的返回值，<font color="#de7802">因为这个返回值会被忽略</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">records</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#39;123&#39;</span>, <span style="color:#e6db74">&#39;456&#39;</span>]  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">saveRecords</span>(<span style="color:#a6e22e">newRecords</span>: <span style="color:#66d9ef">string</span>[]) {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">newRecords</span>.<span style="color:#a6e22e">forEach</span>(<span style="color:#a6e22e">record</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">records</span>.<span style="color:#a6e22e">push</span>(<span style="color:#a6e22e">record</span>));  
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">saveRecords</span>([<span style="color:#e6db74">&#39;21&#39;</span>, <span style="color:#e6db74">&#39;Come On Over&#39;</span>, <span style="color:#e6db74">&#39;The Bodyguard&#39;</span>])  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">records</span>) <span style="color:#75715e">// [ &#39;123&#39;, &#39;456&#39;, &#39;21&#39;, &#39;Come On Over&#39;, &#39;The Bodyguard&#39; ]
</span></span></span></code></pre></div><p><code>void</code>类型不属于<code>JavaScript</code>，是<code>TypeScript</code>的一个关键字，用于声明函数的返回值类型。需要注意的是，<font color="#de7802">它表示函数的返回值不打算被使用，而不是表示返回值可以被返回</font>。</p>
<h3 id="never-returns">Never Returns</h3>
<p>有些函数不仅没有返回值，而且根本不返回。<font color="#de7802">永不返回的函数是那些总是抛出错误或运行无限循环的函数</font>（希望是故意的）。</p>
<p>如果一个函数永远不返回，那么显式添加一个<code>: never</code>类型标注，表示调用该函数后的任何代码都不会运行。下面<code>fail</code>函数只是抛出一个错误，它有助于控制流分析，将参数<code>param</code>窄化为<code>string</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">fail</span>(<span style="color:#a6e22e">message</span>: <span style="color:#66d9ef">string</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">never</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> Error(<span style="color:#e6db74">`Invariant failure: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">message</span><span style="color:#e6db74">}</span><span style="color:#e6db74">.`</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">workWithUnsafeParam</span>(<span style="color:#a6e22e">param</span>: <span style="color:#66d9ef">unknown</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">param</span> <span style="color:#f92672">!==</span> <span style="color:#e6db74">&#34;string&#34;</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fail</span>(<span style="color:#e6db74">`param should be a string, not </span><span style="color:#e6db74">${</span><span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">param</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">param</span>.<span style="color:#a6e22e">toUpperCase</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>需要注意的是，返回类型为<code>void</code>指的是函数不返回任何内容，而<code>never</code>指的是函数执行后永远不返回内容。</p>
<h2 id="function-overloads">Function Overloads</h2>
<p>有些<code>JavaScript</code>函数可以使用完全不同的实参来调用，而这些实参集不能只用可选参数或可变参数来表示。这些函数可以使用一种名为重载签名（<code>overload signatures</code>）的语法来描述：<font color="#de7802">在最终实现签名和函数体之前，多次声明不同版本的形参和返回类型</font>。</p>
<p>在决定是否对重载函数的调用发出语法错误时，<code>TypeScript</code>只会查看函数的重载签名。实现签名只用于函数的内部逻辑。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">createDate</span>(<span style="color:#a6e22e">timestamp</span>: <span style="color:#66d9ef">number</span>)<span style="color:#f92672">:</span> Date;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">createDate</span>(<span style="color:#a6e22e">month</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">day</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">year</span>: <span style="color:#66d9ef">number</span>)<span style="color:#f92672">:</span> Date;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">createDate</span>(<span style="color:#a6e22e">monthOrTimestamp</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">day?</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">year?</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">day</span> <span style="color:#f92672">===</span> <span style="color:#66d9ef">undefined</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">year</span> <span style="color:#f92672">===</span> <span style="color:#66d9ef">undefined</span> <span style="color:#f92672">?</span> <span style="color:#66d9ef">new</span> Date(<span style="color:#a6e22e">monthOrTimestamp</span>) <span style="color:#f92672">:</span> <span style="color:#66d9ef">new</span> Date(<span style="color:#a6e22e">year</span>, <span style="color:#a6e22e">monthOrTimestamp</span>, <span style="color:#a6e22e">day</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">createDate</span>(<span style="color:#ae81ff">554356800</span>); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">createDate</span>(<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">27</span>, <span style="color:#ae81ff">1987</span>); <span style="color:#75715e">// Ok
</span></span></span></code></pre></div><p>函数的重载签名与类型系统的其它语法一样，在编译输出为<code>JavaScript</code>后会被删除。<font color="#e36c09">一般来说，最好保持函数简单，尽可能避免使用函数重载</font>。</p>
<h3 id="call-signature-compatibility">Call-Signature Compatibility</h3>
<p>重载函数实现所使用的签名就是该函数的实现所使用的参数类型和返回类型。因此，<font color="#e36c09">函数重载签名中的返回类型和每个参数都必须可以可赋值给实现签名中同一索引处的参数</font>。换句话说，重载函数的<font color="#0070c0">实现签名必须与所有重载签名兼容</font>。下面示例代码中，因为实现签名和所有的重载签名不兼容，会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">format</span>(<span style="color:#a6e22e">data</span>: <span style="color:#66d9ef">string</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">format</span>(<span style="color:#a6e22e">data</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">needle</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">haystack</span>: <span style="color:#66d9ef">string</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">format</span>(<span style="color:#a6e22e">getData</span><span style="color:#f92672">:</span> () <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">string</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// This overload signature is not compatible with its implementation signature.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">format</span>(<span style="color:#a6e22e">data</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">needle?</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">haystack?</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">needle</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">haystack</span> <span style="color:#f92672">?</span> <span style="color:#a6e22e">data</span>.<span style="color:#a6e22e">replace</span>(<span style="color:#a6e22e">needle</span>, <span style="color:#a6e22e">haystack</span>) <span style="color:#f92672">:</span> <span style="color:#a6e22e">data</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="arrays">Arrays</h1>
<p><code>TypeScript</code>通过记住数组中最初的数据类型，并只允许数组对该数据类型进行操作，从而遵守了每个数组只使用一种数据类型的最佳实践。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">warriors</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;Artemisia&#34;</span>, <span style="color:#e6db74">&#34;Boudica&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Ok: &#34;Zenobia&#34; is a string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">warriors</span>.<span style="color:#a6e22e">push</span>(<span style="color:#e6db74">&#34;Zenobia&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Argument of type &#39;boolean&#39; is not assignable to parameter of type &#39;string&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">warriors</span>.<span style="color:#a6e22e">push</span>(<span style="color:#66d9ef">true</span>);
</span></span></code></pre></div><p>根据数组的初始成员推断数组类型与根据变量的初始值推断变量类型相似。<font color="#de7802">编译器通常会尝试从初始赋值来推断预期类型</font>，数组也不例外。</p>
<h2 id="array-types">Array Types</h2>
<p>如同其它变量声明，数组变量声明时也可以不初始化。同样地，在严格模式下，<span style="background:rgba(255, 183, 139, 0.55)">如果数组变量未初始化之前就使用会出现编译错误</span>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">arrayOfNumbers</span>: <span style="color:#66d9ef">number</span>[];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 未初始化前就使用会编译报错： Variable &#39;arrayOfNumbers&#39; is used before being assigned.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">arrayOfNumbers</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">arrayOfNumbers</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">23</span>, <span style="color:#ae81ff">42</span>];
</span></span></code></pre></div><h3 id="array-and-function-types">Array and Function Types</h3>
<p>如果<font color="#de7802">涉及数组和函数类型时可能需要使用圆括号来区分数组类型中的内容</font>。圆括号可用于指明类型中哪一部分是函数的返回值，哪一部分是数组内容。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// Type is a function that returns an array of strings
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">createStrings</span><span style="color:#f92672">:</span> () <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">string</span>[];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type is an array of functions that each return a string 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">stringCreators</span><span style="color:#f92672">:</span> (() <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">string</span>)[];
</span></span></code></pre></div><h3 id="union-type-arrays">Union-Type Arrays</h3>
<p>可以使用联合类型来标注数组中元素是多个可能的类型。将数组类型与联合类型一起使用时，<font color="#de7802">可能需要使用圆括号来指明中哪一部分是数组的内容，哪一部分是联合类型的内容</font>。在数组联合类型中使用圆括号非常重要，以下两种类型并不相同：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// Type is either a number or an array of strings
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">stringOrArrayOfNumbers</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">number</span>[];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type is an array of elements that are each either a number or a string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">arrayOfStringOrNumbers</span><span style="color:#f92672">:</span> (<span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">number</span>)[];
</span></span></code></pre></div><p>如果同一个数组中的元素类型不同，<code>TypeScript</code>就会从数组的声明中推断它是一个<code>union</code>类型的数组。换句话说，<font color="#de7802">数组中元素的类型是数组中所有可能元素类型的联合</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// namesMaybe&#39;s type is (string | undefined)[]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">namesMaybe</span> <span style="color:#f92672">=</span> [
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;Aqualtune&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;Blenda&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">undefined</span>,
</span></span><span style="display:flex;"><span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">namesMaybe</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>[ <span style="color:#e6db74">&#39;Aqualtune&#39;</span>, <span style="color:#e6db74">&#39;Blenda&#39;</span>, <span style="color:#66d9ef">undefined</span> ]
</span></span></code></pre></div><h3 id="evolving-any-arrays">Evolving Any Arrays</h3>
<p>若初始值为空的数组变量不加上类型标注，则数组的类型将被推断为<code>any[]</code>。这意味着该数组可以接收任何内容，若不小心添加了可能不正确的值，会抵消类型检查器的益处。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// Type: any[]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">values</span> <span style="color:#f92672">=</span> [];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: string[]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">values</span>.<span style="color:#a6e22e">push</span>(<span style="color:#e6db74">&#39;&#39;</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: (number | string)[]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">values</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">values</span>, <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">values</span>) <span style="color:#75715e">// [ &#39;&#39;, 0 ] object
</span></span></span></code></pre></div><p>如同变量，如果允许数组是<code>any</code>类型，也就违背了类型检查的目的。当精确地知道变量是什么类型时，就会工作得更好。</p>
<h3 id="multidimensional-arrays">Multidimensional Arrays</h3>
<p>一个二维数组，有两个<code>[]</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 声明二维数组，下面两种方式均可以
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">arrayOfArraysOfNumbers1</span>: <span style="color:#66d9ef">number</span>[][];  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">arrayOfArraysOfNumbers2</span><span style="color:#f92672">:</span> (<span style="color:#66d9ef">number</span>[])[]; 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">arrayOfArraysOfNumbers1</span> <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>], [<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">6</span>], [<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">9</span>],];  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">arrayOfArraysOfNumbers2</span> <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>], [<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">8</span>], [<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">11</span>],];  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">arrayOfArraysOfNumbers1</span>, <span style="color:#a6e22e">arrayOfArraysOfNumbers2</span>)
</span></span></code></pre></div><p>三维数组有3个<code>[]</code>，四维数组有4个<code>[]</code>，5个数组有5个<code>[]</code>，依此类推。</p>
<h2 id="array-members">Array Members</h2>
<p><code>TypeScript</code>基于索引访问数组中的元素。下面定义的常量<code>defenders</code>类型为<code>string []</code> ，因此接受数组中第一个元素的常量<code>defender</code>的类型是<code>string</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">defenders</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;Clarenza&#34;</span>, <span style="color:#e6db74">&#34;Dina&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">defender</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">defenders</span>[<span style="color:#ae81ff">0</span>];
</span></span></code></pre></div><p>联合类型数组的成员都是同一种联合类型。下面常量<code>soldiersOrDates</code>的类型为<code>(string | Date)[]</code>，因此常量<code>soldierOrDate</code>的类型也为<code>string | Date</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">soldiersOrDates</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;Deborah Sampson&#34;</span>, <span style="color:#66d9ef">new</span> Date(<span style="color:#ae81ff">1782</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">3</span>)];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 即使不显式标注类型，编译器可以推断出类型为: Date | string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">soldierOrDate</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">soldiersOrDates</span>[<span style="color:#ae81ff">0</span>];
</span></span></code></pre></div><h3 id="caveat-unsound-members">Caveat: Unsound Members</h3>
<p>众所周知，<code>TypeScript</code>的<span style="background:rgba(255, 183, 139, 0.55)">类型系统在技术上是不健全的，它可以使类型在多数情况下是正确的</span>，但有时对值类型的理解可能是不正确的，<strong><font color=red>数组尤其是类型系统不健全的根源</font></strong>。</p>
<p>默认情况下，<code>TypeScript</code><font color="#de7802">假设所有数组成员的访问都会返回相应成员</font>，尽管在<code>JavaScript</code>中，访问数组元素的索引大于数组的长度会得到<code>undefined</code>。在编译器默认设置下，下面这段代码<font color="#245bdb">编译没有任何问题，但运行时会报错</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">withElements</span>(<span style="color:#a6e22e">elements</span>: <span style="color:#66d9ef">string</span>[]) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 不会出现类型错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">elements</span>[<span style="color:#ae81ff">9001</span>].<span style="color:#a6e22e">length</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 运行时错误：Cannot read properties of undefined (reading &#39;length&#39;)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">withElements</span>([<span style="color:#e6db74">&#34;It&#39;s&#34;</span>, <span style="color:#e6db74">&#34;over&#34;</span>]);
</span></span></code></pre></div><p><code>TypeScript</code><span style="background:rgba(255, 183, 139, 0.55)">故意不确保检索到的数组成员是否存在</span>，它认为上面代码片段中的<code>elements[9001]</code>是字符串类型，而不是<code>undefined</code>类型。</p>
<h2 id="spreads-and-rests">Spreads and Rests</h2>
<h3 id="spreads">Spreads</h3>
<p>可以使用<code>...</code>展开操作符将数组连接在一起，<font color="#de7802">结果数组将包含来自输入数组的所有值</font>。如果输入数组的元素类型相同，则结果数组的元素类型也相同。如果将两个不同类型的数组展开在一起创建一个新数组，<font color="#de7802">新数组将被推断为联合类型数组</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 数组类型为 string[]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">soldiers</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;Harriet Tubman&#34;</span>, <span style="color:#e6db74">&#34;Joan of Arc&#34;</span>, <span style="color:#e6db74">&#34;Khutulun&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 数组类型为 number[]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">soldierAges</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">90</span>, <span style="color:#ae81ff">19</span>, <span style="color:#ae81ff">45</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 数组类型为 (string | number)[]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">conjoined</span> <span style="color:#f92672">=</span> [...<span style="color:#a6e22e">soldiers</span>, ...<span style="color:#a6e22e">soldierAges</span>]; <span style="color:#75715e">// [ &#39;Harriet Tubman&#39;, &#39;Joan of Arc&#39;, &#39;Khutulun&#39;, 90, 19, 45 ]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 数组类型为string[]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>([...<span style="color:#a6e22e">soldiers</span>, ...<span style="color:#a6e22e">soldiers</span>]);
</span></span></code></pre></div><h3 id="spreading-rest-parameters">Spreading Rest Parameters</h3>
<p><code>TypeScript</code>可识别<code>...</code>展开操作符，即<font color=#548dd4>可将一个数组展开作为可变形参的实参</font>，并执行类型检查。<font color="#de7802">数组作为实参传递给可变形参时必须具有相同类型</font>，下面代码中展开数组<code>string[]</code>是允许的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">logWarriors</span>(<span style="color:#a6e22e">greeting</span>: <span style="color:#66d9ef">string</span>, ...<span style="color:#a6e22e">names</span>: <span style="color:#66d9ef">string</span>[]) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">name</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">names</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">greeting</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">name</span><span style="color:#e6db74">}</span><span style="color:#e6db74">!`</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">warriors</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;Cathay Williams&#34;</span>, <span style="color:#e6db74">&#34;Lozen&#34;</span>, <span style="color:#e6db74">&#34;Nzinga&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">logWarriors</span>(<span style="color:#e6db74">&#34;Hello&#34;</span>, ...<span style="color:#a6e22e">warriors</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">Hello</span>, <span style="color:#a6e22e">Cathay</span> <span style="color:#a6e22e">Williams</span><span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Hello</span>, <span style="color:#a6e22e">Lozen</span><span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Hello</span>, <span style="color:#a6e22e">Nzinga</span><span style="color:#f92672">!</span>
</span></span></code></pre></div><h2 id="tuples">Tuples</h2>
<p>虽然数组在理论上可以是任意大小，但有时使用固定大小的数组（称为元组）也很有用。<font color="#de7802">元组中的每个元素都有特定类型，这个类型可能比数组所有可能成员的联合类型更具体</font>。声明元组类型的语法与数组字面意义相似，只是用类型代替了元素值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 元组类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">yearAndWarrior</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">number</span>, <span style="color:#66d9ef">string</span>];
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">yearAndWarrior</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">530</span>, <span style="color:#e6db74">&#34;Tomyris&#34;</span>]; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">yearAndWarrior</span>[<span style="color:#ae81ff">0</span>], <span style="color:#a6e22e">yearAndWarrior</span>[<span style="color:#ae81ff">1</span>]);
</span></span></code></pre></div><p>在<code>JavaScript</code>中，<span style="background:rgba(255, 183, 139, 0.55)">元组通常与数组解构一起使用，以便一次赋值多个变量</span>。例如，可以根据条件设置两个变量的初始值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// year的类型为number,warrior的类型为string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> [<span style="color:#a6e22e">year</span>, <span style="color:#a6e22e">warrior</span>] <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> [<span style="color:#ae81ff">340</span>, <span style="color:#e6db74">&#34;Archidamia&#34;</span>] <span style="color:#f92672">:</span> [<span style="color:#ae81ff">1828</span>, <span style="color:#e6db74">&#34;Rani of Jhansi&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">year</span>, <span style="color:#a6e22e">warrior</span>) <span style="color:#75715e">// 每次执行结果不同
</span></span></span></code></pre></div><h3 id="tuple-assignability">Tuple Assignability</h3>
<p><code>TypeScript</code>将元组类型视为比变长数组更特殊的类型，<font color="#de7802">这意味着变长数组类型不能赋值给元组类型</font>。下面代码中，变量<code>pairLoose</code>是数组类型<code>(boolean | number)[]</code>，即数组中元素类型是<code>(boolean | number)</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 推断为数组类型，数组中元素的类型为 (boolean | number)[]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">pairLoose</span> <span style="color:#f92672">=</span> [<span style="color:#66d9ef">false</span>, <span style="color:#ae81ff">123</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误:Type &#39;(number | boolean)[]&#39; is not assignable to type &#39;[boolean, number]&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">pairTupleLoose</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">boolean</span>, <span style="color:#66d9ef">number</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">pairLoose</span>;
</span></span></code></pre></div><p>上面代码中，如果将变量<code>pairLoose</code>的类型声明为<code>[boolean, number]</code>，那么赋值就是允许的，不会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">pairLoose</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">boolean</span>, <span style="color:#66d9ef">number</span>] <span style="color:#f92672">=</span> [<span style="color:#66d9ef">false</span>, <span style="color:#ae81ff">123</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">pairTupleLoose</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">boolean</span>, <span style="color:#66d9ef">number</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">pairLoose</span>;
</span></span></code></pre></div><p>需要注意的是，<span style="background:rgba(255, 183, 139, 0.55)">不同长度的元组也不能相互赋值</span>。因为在声明元组时，编译器已经知道当前元组类型中有多少个成员：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">tupleThree</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">boolean</span>, <span style="color:#66d9ef">number</span>, <span style="color:#66d9ef">string</span>] <span style="color:#f92672">=</span> [<span style="color:#66d9ef">false</span>, <span style="color:#ae81ff">1583</span>, <span style="color:#e6db74">&#34;Nzinga&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">tupleTwoExact</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">boolean</span>, <span style="color:#66d9ef">number</span>] <span style="color:#f92672">=</span> [<span style="color:#a6e22e">tupleThree</span>[<span style="color:#ae81ff">0</span>], <span style="color:#a6e22e">tupleThree</span>[<span style="color:#ae81ff">1</span>]];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Type &#39;[boolean, number, string]&#39; is not assignable to type &#39;[boolean, number]&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">tupleTwoExtra</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">boolean</span>, <span style="color:#66d9ef">number</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">tupleThree</span>;
</span></span></code></pre></div><p>由于元组被视为数组，在长度和元素类型上有更具体的信息，因此对于存储传递给函数的实参特别有用。<code>TypeScript</code>能够<font color="#de7802">将作为实参传递给函数可变形参的元组提供精确的类型检查</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">logPair</span>(<span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">name</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> has </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">value</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// pairArray的类型为 (string | number)[]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">pairArray</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;Amage&#34;</span>, <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 因为展开后的元素类型为string | number，因此不一致，会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// A spread argument must either have a tuple type or be passed to a rest parameter.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">logPair</span>(...<span style="color:#a6e22e">pairArray</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">pairTupleIncorrect</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">number</span>, <span style="color:#66d9ef">string</span>] <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;Amage&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误:Argument of type &#39;number&#39; is not assignable to parameter of type &#39;string&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 元组被展开后，对应的类型顺序不对
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">logPair</span>(...<span style="color:#a6e22e">pairTupleIncorrect</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 元组类型被展开，编译不会报错
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">pairTupleCorrect</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">string</span>, <span style="color:#66d9ef">number</span>] <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;Amage&#34;</span>, <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">logPair</span>(...<span style="color:#a6e22e">pairTupleCorrect</span>); <span style="color:#75715e">// Ok
</span></span></span></code></pre></div><p>如果想随意使用可变形参元组，可以将它们与数组混合使用，为函数调用存储实参列表。下面代码中<code>trios.forEach(trio =&gt; logTrio(...trio))</code>是安全的，因为每个<code>...trio</code>恰好与<code>logTrio</code>的参数类型相匹配。然而，<code>trios.forEach(logTrio)</code> 不可赋值，因为它试图将整个<code>[string, number, boolean]</code>作为第一个参数传递，但实际上第一个参数类型是<code>string</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">logTrio</span>(<span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">value</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">number</span>, <span style="color:#66d9ef">boolean</span>]) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">name</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> has </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">value</span>[<span style="color:#ae81ff">0</span>]<span style="color:#e6db74">}</span><span style="color:#e6db74"> (</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">value</span>[<span style="color:#ae81ff">1</span>]<span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">trios</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">string</span>, [<span style="color:#66d9ef">number</span>, <span style="color:#66d9ef">boolean</span>]][] <span style="color:#f92672">=</span> [
</span></span><span style="display:flex;"><span>    [<span style="color:#e6db74">&#34;Amanitore&#34;</span>, [<span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">true</span>]],
</span></span><span style="display:flex;"><span>    [<span style="color:#e6db74">&#34;Æthelflæd&#34;</span>, [<span style="color:#ae81ff">2</span>, <span style="color:#66d9ef">false</span>]],
</span></span><span style="display:flex;"><span>    [<span style="color:#e6db74">&#34;Ann E. Dunwoody&#34;</span>, [<span style="color:#ae81ff">3</span>, <span style="color:#66d9ef">false</span>]]];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 下面方式不会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">trios</span>.<span style="color:#a6e22e">forEach</span>(<span style="color:#a6e22e">trio</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">logTrio</span>(...<span style="color:#a6e22e">trio</span>)); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 下面会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">trios</span>.<span style="color:#a6e22e">forEach</span>(<span style="color:#a6e22e">logTrio</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Argument of type &#39;(name: string, value: [number, boolean]) =&gt; void&#39; is not assignable to parameter of type &#39;(value: [string, [number, boolean]], index: number, array: [string, [number, boolean]][]) =&gt; void&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Types of parameters &#39;name&#39; and &#39;value&#39; are incompatible.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Type &#39;[string, [number, boolean]]&#39; is not assignable to type &#39;string&#39;.
</span></span></span></code></pre></div><h3 id="tuple-inferences">Tuple Inferences</h3>
<p><code>TypeScript</code><em><font color="#de7802">通常将创建的数组视为长度可变的数组，而不是元组</font></em>。如果<span style="background:rgba(255, 183, 139, 0.55)">一个数组被用作变量的初始值或函数的返回值，那么编译器将推断它是一个可变长度的数组</span>，而不是一个固定长度的元组。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">firstCharAndSize</span>(<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> [<span style="color:#a6e22e">input</span>[<span style="color:#ae81ff">0</span>], <span style="color:#a6e22e">input</span>.<span style="color:#a6e22e">length</span>];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// firstChar的类型为 string | number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// size的类型也为string | number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">firstChar</span>, <span style="color:#a6e22e">size</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">firstCharAndSize</span>(<span style="color:#e6db74">&#34;Gudit&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 上面的参数类型都为 string | number
</span></span></span></code></pre></div><h4 id="explicit-tuple-types">Explicit tuple types</h4>
<p>元组可能会被用于类型声明，例如函数的返回值类型。<font color="#de7802">如果一个函数声明返回元组类型，并且在函数里面返回一个数组字面量，则这个数组字面量会被推推断为元组而不是可变数组。</font></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">firstCharAndSizeExplicit</span>(<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">string</span>)<span style="color:#f92672">:</span> [<span style="color:#66d9ef">string</span>, <span style="color:#66d9ef">number</span>] {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 在函数里面返回字面量，但因为声明了返回类型为元组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 所以字面量被推断为元组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> [<span style="color:#a6e22e">input</span>[<span style="color:#ae81ff">0</span>], <span style="color:#a6e22e">input</span>.<span style="color:#a6e22e">length</span>];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// firstChar type: string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// size type: number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">firstChar</span>, <span style="color:#a6e22e">size</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">firstCharAndSizeExplicit</span>(<span style="color:#e6db74">&#34;Cathay Williams&#34;</span>);
</span></span></code></pre></div><h4 id="const-asserted-tuples">Const asserted tuples</h4>
<p>显式标注元组类型比较麻烦，<code>TypeScript</code>提供了<code>as const</code>操作符，称为<code>const</code>断言，放在值的后面。<code>const</code>断言告诉<code>TypeScript</code>在推断该值的类型时，应当<font color="#de7802">使用该值最直白的只读形式</font>。</p>
<p>如果将<code>const</code>断言放在数组字面之后，<span style="background:rgba(255, 183, 139, 0.55)">表示数组应被视为元组，并且元组类型被推断为字面量</span>。下面示例代码中，因为<code>readonlyTuple[0]</code>也是<code>readonly</code>的，所以不能再被赋值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// Type: (string | number)[]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">unionArray</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1157</span>, <span style="color:#e6db74">&#34;Tomoe&#34;</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 只读元组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: readonly [1157, &#34;Tomoe&#34;]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">readonlyTuple</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1157</span>, <span style="color:#e6db74">&#34;Tomoe&#34;</span>] <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">const</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Cannot assign to &#39;0&#39; because it is a read-only property.  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">readonlyTuple</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">12</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 使用变量接收只读元组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">readonlyTuple</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1157</span>, <span style="color:#e6db74">&#34;Tomoe&#34;</span>] <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">const</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">readonlyTuple</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1157</span>, <span style="color:#e6db74">&#34;Tomoe&#34;</span>]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">readonlyTuple</span>, <span style="color:#a6e22e">readonlyTuple</span>[<span style="color:#ae81ff">0</span>], <span style="color:#a6e22e">readonlyTuple</span>[<span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误，仍然是不可修改的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">readonlyTuple</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">12</span>
</span></span></code></pre></div><p>请注意，<code>const</code>断言不仅将可变的数组转换为固定大小的元组。还向<code>TypeScript</code>表明，<font color="#de7802">元组是只读的，不能在希望允许修改值的地方使用</font>。</p>
<p>下面代码中，<code>pairMutable</code>允许被修改，因为它是传统的元组类型。但是，<code>as const</code>使得常量<code>pairConst</code>的成员也不允许被修改：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">pairMutable</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">number</span>, <span style="color:#66d9ef">string</span>] <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1157</span>, <span style="color:#e6db74">&#34;Tomoe&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">pairMutable</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1247</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 下面赋值是可以的，但不能再使用pairAlsoMutable赋值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">pairAlsoMutable</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">number</span>, <span style="color:#66d9ef">string</span>] <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1157</span>, <span style="color:#e6db74">&#34;Tomoe&#34;</span>] <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">const</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 直接改变元组中的值是允许的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">pairAlsoMutable</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1233</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// pariConst的类型相当于字面量的[1157,&#34;Tomoe&#34;]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">pairConst</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1157</span>, <span style="color:#e6db74">&#34;Tomoe&#34;</span>] <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">const</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 直接改变元组中的值是不允许的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Cannot assign to &#39;0&#39; because it is a read-only property
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">pairConst</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1247</span>;
</span></span></code></pre></div><p>在实践中，只读元组作为函数返回值很方便。<span style="background:rgba(255, 183, 139, 0.55)">函数中返回的元组值通常会立即解构，因此只读元组不会妨碍函数的使用</span>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">firstCharAndSizeAsConst</span>(<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> [<span style="color:#a6e22e">input</span>[<span style="color:#ae81ff">0</span>], <span style="color:#a6e22e">input</span>.<span style="color:#a6e22e">length</span>] <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">const</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 函数返回的元组立即被解构
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">firstChar</span>, <span style="color:#a6e22e">size</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">firstCharAndSizeAsConst</span>(<span style="color:#e6db74">&#34;Ching Shih&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">firstChar</span>, <span style="color:#a6e22e">size</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 出现编译错误:Cannot assign to &#39;firstChar&#39; because it is a constant.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">firstChar</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;chear&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 函数返回的元组立即被解构  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> [<span style="color:#a6e22e">firstChar1</span>, <span style="color:#a6e22e">size1</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">firstCharAndSizeAsConst</span>(<span style="color:#e6db74">&#34;Ching Shih&#34;</span>);  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">firstChar1</span>, <span style="color:#a6e22e">size1</span>)  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 不会出现编译错误，因为是使用let定义的解构
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">firstChar1</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;chear&#39;</span>
</span></span></code></pre></div><h1 id="interfaces">Interfaces</h1>
<blockquote>
<p>接口是声明具有相关名称对象的另一种方法。<font color="#de7802">接口在许多方面与别名对象类型相似，但由于其错误信息更易读、编译器性能更快以及与类的互操作性更好，通常更受青睐。</font></p>
</blockquote>
<h2 id="type-aliases-versus-interfaces">Type Aliases Versus Interfaces</h2>
<p>下面是定义类型别名描述对象的语法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Poet</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>下面是使用<code>interface</code>声明的等效语法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Poet</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 也可以使用逗号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Poet</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">number</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>,
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>上面两种语法基本一致。喜欢使用分号的<code>TypeScript</code>开发人员<font color="#de7802">通常会将分号放在类型别名定义之后，而接口定义之后通常不加分号</font>。这种偏好反映了使用<code>;</code>声明变量，不使用<code>;</code>声明类或函数。尽管接口和类型别名相似，但类型别名<code>type</code>和<code>interface</code>有一些关键区别：</p>
<ul>
<li><code>interface</code>可以<code>merge</code>在一起增强，这一特性在使用第三方代码时尤其有用。</li>
<li><font color="#de7802">接口可以用来对<code>class</code>的结构进行类型检查，而类型别名则不能</font>。</li>
<li>对于类型检查程序来说，<span style="background:rgba(255, 183, 139, 0.55)">接口的工作速度通常更快</span>。因为它们声明了一个<code>named</code>类型，可以更容易地在内部缓存，而<font color="#de7802">不是像类型别名那样动态复制粘贴一个新的对象字面量。</font></li>
<li>由于<font color="#de7802">接口被认为是<code>named</code>的对象</font>，不是<code>unnamed</code>对象字面量的别名，因此它们的错误信息在某些极端情况下更具可读性。</li>
</ul>
<h2 id="types-of-properties">Types of Properties</h2>
<h3 id="optional-properties-1">Optional Properties</h3>
<p>与对象类型一样，接口属性不一定都是对象的必需属性。可以在接口中属性类型标注的<code>:</code>前加上<code>?</code>来表示该属性是可选的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Book</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author?</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">ok</span>: <span style="color:#66d9ef">Book</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Rita Dove&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">80</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">missing</span>: <span style="color:#66d9ef">Book</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">80</span>
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="read-only-properties">Read-Only Properties</h3>
<p>有时，可能希望禁止重新赋值接口的某个属性值。<code>TypeScript</code>允许在接口属性名称前添加一个<code>readonly</code>修饰符，表示该属性一旦设置，就不能再被修改。也就是说<code>readonly</code>属性可以正常读取，但不能被重新赋值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Page</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">readonly</span> <span style="color:#a6e22e">text</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">read</span>(<span style="color:#a6e22e">page</span>: <span style="color:#66d9ef">Page</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Ok: reading the text property doesn&#39;t attempt to modify it
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">page</span>.<span style="color:#a6e22e">text</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 出现编译错误：Cannot assign to &#39;text&#39; because it is a read-only property.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">page</span>.<span style="color:#a6e22e">text</span> <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;!&#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>需要注意的是，<code>readonly</code><font color="#de7802">修饰器只存在于类型系统</font>，编译成<code>JavaScript</code>后，该修饰符会被删除。添加<code>readonly</code>后，<span style="background:rgba(255, 183, 139, 0.55)">依靠的是类型检查器，它只能防止在开发过程中属性被修改，不能防止运行过程中被修改</span>。</p>
<h3 id="functions-and-methods">Functions and Methods</h3>
<p>在<code>JavaScript</code>中对象成员为函数比较常见。因此，允许将<code>interface</code>的成员声明为函数类型。<code>TypeScript</code>提供了两种将接口成员声明为函数的方法：</p>
<ul>
<li>方法语法：声明接口成员是一个打算作为对象成员调用的函数，如<code>member(): void</code>。</li>
<li>属性语法：声明接口成员等同于独立函数，如<code>member: () =&gt; void</code>。</li>
</ul>
<p>下面接口<code>HasBothFunctionTypes</code>中声明的<code>method</code>和<code>property</code>都是函数，可以不带实参调用，并返回一个字符串：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">HasBothFunctionTypes</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">property</span><span style="color:#f92672">:</span> () <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">method</span>()<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">hasBoth</span>: <span style="color:#66d9ef">HasBothFunctionTypes</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">property</span><span style="color:#f92672">:</span> () <span style="color:#f92672">=&gt;</span> <span style="color:#e6db74">&#34;&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">method() {</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">hasBoth</span>.<span style="color:#a6e22e">property</span>();
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">hasBoth</span>.<span style="color:#a6e22e">method</span>()
</span></span></code></pre></div><p>上面两种方式声明的函数都支持可选修饰器<code>?</code>，表明它们不是必需的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">OptionalReadonlyFunctions</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">optionalProperty</span><span style="color:#f92672">?:</span> () <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">optionalMethod</span><span style="color:#f92672">?</span>()<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">t1</span>: <span style="color:#66d9ef">OptionalReadonlyFunctions</span> <span style="color:#f92672">=</span> {}
</span></span></code></pre></div><p>方法和属性声明多数情况下可以互换，它们之间的主要区别如下：</p>
<ul>
<li>方法不能声明为<code>readonly</code>，但属性可以。</li>
<li><font color="#de7802">接口合并时，认为方法和属性是不同的</font>。</li>
</ul>
<p><code>TypeScript</code>的未来版本可能会添加某些选项，对方法和属性函数之间的差异进行更严格地区分。目前，推荐按如下原则进行：</p>
<ul>
<li>如果知道底层函数可能会引用<code>this</code>，建议使用方法。</li>
<li>其它情况则建议使用属性。</li>
</ul>
<h3 id="call-signatures">Call Signatures</h3>
<p>接口和对象类型均可以声明<code>call signatures</code>，这是类型系统对值如何像函数一样被调用的描述。只有按照<code>call signatures</code>方式声明的值才可以赋值给<code>interface</code>，即具有可赋值参数和返回类型的函数。<code>call signatures</code><font color="#de7802">看起来和函数类型相似，只是用冒号代替<code>=&gt;</code></font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">CallSignature</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 调用签名，相当于函数语法去掉函数名
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    (<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">string</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">FunctionAlias</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">string</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">typedFunctionAlias</span>: <span style="color:#66d9ef">FunctionAlias</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">input</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">input</span>.<span style="color:#a6e22e">length</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">typedCallSignature</span>: <span style="color:#66d9ef">CallSignature</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">input</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">input</span>.<span style="color:#a6e22e">length</span>; <span style="color:#75715e">// Ok
</span></span></span></code></pre></div><p><code>call signatures</code>可用于<font color="#f79646">描述附加了一些自定义属性的函数</font>。<code>TypeScript</code>会识别添加到函数声明中的属性，并将其添加到函数声明的类型中。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">FunctionWithCount</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">count</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    ()<span style="color:#f92672">:</span> <span style="color:#66d9ef">void</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">hasCallCount</span>: <span style="color:#66d9ef">FunctionWithCount</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">keepsTrackOfCalls() {</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">keepsTrackOfCalls</span>.<span style="color:#a6e22e">count</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`I&#39;ve been called </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">keepsTrackOfCalls</span>.<span style="color:#a6e22e">count</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> times!`</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">keepsTrackOfCalls</span>.<span style="color:#a6e22e">count</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">hasCallCount</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">keepsTrackOfCalls</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">doesNotHaveCount() {</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;No idea!&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误:Property &#39;count&#39; is missing in type &#39;() =&gt; void&#39; but required in type &#39;FunctionWithCount&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">hasCallCount</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">doesNotHaveCount</span>;
</span></span></code></pre></div><h3 id="index-signatures">Index Signatures</h3>
<p>有些<code>JavaScript</code>项目创建的对象可以使用任意字符串<code>key</code>存储值。对于这些「容器」对象来说，为接口的每一个可能的<code>key</code>声明一个属性是不切实际的。</p>
<p><code>TypeScript</code>提供了一种称为<code>index signature</code>的语法，允许接口接收任意的<code>key</code>，并返回该<code>key</code>下的某个类型值。常见的是<code>string keys</code>，这是因为<code>JavaScript</code>对象查找属性时会将<code>key</code><font color="#de7802">隐式转换为字符串</font>。<font color="#de7802">索引签名看起来就像普通的属性定义，只是在键后面加上了类型，并用数组括号将其括起来</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">WordCounts</span> {
</span></span><span style="display:flex;"><span>    [<span style="color:#a6e22e">i</span>: <span style="color:#66d9ef">string</span>]<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">counts</span>: <span style="color:#66d9ef">WordCounts</span> <span style="color:#f92672">=</span> {};
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">counts</span>.<span style="color:#a6e22e">apple</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// Ok 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">counts</span>.<span style="color:#a6e22e">banana</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Type &#39;boolean&#39; is not assignable to type &#39;number&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">counts</span>.<span style="color:#a6e22e">cherry</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span></code></pre></div><p>虽然<span style="background:rgba(255, 183, 139, 0.55)">索引签名便于将值赋值给对象，但并非完全类型安全</span>。因为索引签名表示，<font color="#de7802">无论访问的是什么属性，对象都应返回一个值</font>，这一点和数组的索引相似。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">DatesByName</span> {
</span></span><span style="display:flex;"><span>    [<span style="color:#a6e22e">i</span>: <span style="color:#66d9ef">string</span>]<span style="color:#f92672">:</span> Date;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">publishDates</span>: <span style="color:#66d9ef">DatesByName</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Frankenstein</span>: <span style="color:#66d9ef">new</span> Date(<span style="color:#e6db74">&#34;1 January 1818&#34;</span>),
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// webStrom中没有提示
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">publishDates</span>.<span style="color:#a6e22e">Frankenstein</span>) <span style="color:#75715e">// Type: Date
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">publishDates</span>.<span style="color:#a6e22e">Frankenstein</span>.<span style="color:#a6e22e">toString</span>());
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">publishDates</span>.<span style="color:#a6e22e">Beloved</span>) <span style="color:#75715e">// undefined
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 运行时错误：Cannot read properties of undefined (reading &#39;toString&#39;)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">publishDates</span>.<span style="color:#a6e22e">Beloved</span>.<span style="color:#a6e22e">toString</span>())
</span></span></code></pre></div><p>如果要存储键值对，并且无法提前知道键值，通常使用<code>Map</code>更安全。<code>Map</code>的<code>get</code>方法总是返回带有<code>| undefined</code>的类型，<font color="#de7802">表示键可能不存在</font>。</p>
<h4 id="mixing-properties-and-index-signatures">Mixing properties and index signatures</h4>
<p>接口可以包含显式命名属性和<code>catchall string</code>索引签名。但有一个限制：<font color="#de7802">每个显式命名属性的类型必须可以赋值给其<code>catchall</code>索引签名的类型</font>。可以认为将它们混合在一起就是告诉<code>TypeScript</code>，命名的属性会给出一个更具体的类型，而其它属性都会返回索引签名的类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">HistoricalNovels</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Oroonoko</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    [<span style="color:#a6e22e">i</span>: <span style="color:#66d9ef">string</span>]<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">novels</span>: <span style="color:#66d9ef">HistoricalNovels</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Outlander</span>: <span style="color:#66d9ef">1991</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Oroonoko</span>: <span style="color:#66d9ef">1688</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Property &#39;Oroonoko&#39; is missing in type &#39;{ Outlander: number; }&#39; but required in type &#39;HistoricalNovels&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">missingOroonoko</span>: <span style="color:#66d9ef">HistoricalNovels</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Outlander</span>: <span style="color:#66d9ef">1991</span>,
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h2 id="interface-extensions">Interface Extensions</h2>
<p>有时，可能会有多个看起来相似的<code>interface</code>。一个<code>interface</code>可能包含另一个<code>interface</code>的所有成员，只是增加了一些额外的成员。</p>
<p><code>TypeScript</code>允许一个接口<code>extend</code>另一个接口，即<font color="#de7802">声明它复制了另一个接口的所有成员</font>。可以在接口名后添加<code>extends</code>关键字和待扩展的接口名，以标记当前接口扩展了另一个接口。</p>
<p>在下面示意代码中，接口<code>Novella</code>扩展了接口<code>Writing</code>，因此要求对象至少同时拥有<code>Novella</code>的<code>pages</code>和<code>Writing</code>的<code>title</code>成员：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Writing</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">title</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Novella</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Writing</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">myNovella</span>: <span style="color:#66d9ef">Novella</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">195</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">title</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Ethan Frome&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Property &#39;pages&#39; is missing in type &#39;{ title: string; }&#39; but required in type &#39;Novella&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">missingPages</span>: <span style="color:#66d9ef">Novella</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">title</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;The Awakening&#34;</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Object literal may only specify known properties, and &#39;strategy&#39; does not exist in type &#39;Novella&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 对象字面量会触发多余属性检查
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">extraProperty</span>: <span style="color:#66d9ef">Novella</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">300</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">strategy</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;baseline&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">style</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Naturalism&#34;</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 使用变量暂存对象字面量规避多余属性检查
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">extraProperty1</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">300</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">strategy</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;baseline&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">style</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Naturalism&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">title</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;test&#34;</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 这样赋值不会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">myNovella</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">extraProperty1</span>
</span></span></code></pre></div><h3 id="overridden-properties">Overridden Properties</h3>
<p>派生接口可以通过<font color="#de7802">再次声明同名的不同类型属性来覆盖或替换其基础接口的属性</font>。<span style="background:rgba(255, 183, 139, 0.55)">类型检查器会强制要求覆盖的属性必须可赋值给其基础接口对应的属性</span>，也就是说<code>override</code>的**<font color=red>属性类型只能缩小不能扩大</font>**。目的是确保派生接口类型的实例始终可赋值给基础接口类型变量。</p>
<p><font color="#de7802">大多数派生接口在重新声明属性时，通常是为了使得这些属性成为一个联合类型的更具体的子类型</font>，也可能是为了使属性成为一个从基本接口类型扩展而来的类型（通常是扩展多个接口）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">WithNullableName</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">WithNonNullableName</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">WithNullableName</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误，子接口对应属性的类型没有窄化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">WithNumericName</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">WithNullableName</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="extending-multiple-interfaces">Extending Multiple Interfaces</h3>
<p><code>TypeScript</code>中的<font color="#de7802">接口定义时可以声明为扩展多个其它接口</font>。即派生接口的<code>extends</code>关键字之后，存在多个用逗号分隔的接口名，派生接口将接收所有基础接口的所有成员。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">GivesNumber</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">giveNumber</span>()<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">GivesString</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">giveString</span>()<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">GivesBothAndEither</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">GivesNumber</span>, <span style="color:#a6e22e">GivesString</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">giveEither</span>()<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">useGivesBoth</span>(<span style="color:#a6e22e">instance</span>: <span style="color:#66d9ef">GivesBothAndEither</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">instance</span>.<span style="color:#a6e22e">giveEither</span>(); <span style="color:#75715e">// Type: number | string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">instance</span>.<span style="color:#a6e22e">giveNumber</span>(); <span style="color:#75715e">// Type: number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">instance</span>.<span style="color:#a6e22e">giveString</span>(); <span style="color:#75715e">// Type: string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>将一个接口标注为扩展多个其它接口，既可以减少代码重复，又可以使对象更容易在不同的代码区域重复使用。</p>
<h2 id="interface-merging">Interface Merging</h2>
<p>接口的一个重要特性是可以合并。接口合并意味着，如果**<font color="#de7802">在同一作用域中声明了两个名称相同的接口，它们就会合并成一个更大的接口</font>**，并在该名称下包含所有声明的字段。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Merged</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fromFirst</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Merged</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fromSecond</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>接口<code>merge</code>并不经常使用，<span style="background:rgba(255, 183, 139, 0.55)">建议在可能的情况下尽量避免使用该功能</span>。因为，如果在多个地方声明了一个接口，会出现代码比较难理解。</p>
<p>但是，接口合并对于增强来自外部包或内置的全局接口（如<code>Window</code>）特别有用。例如，当使用默认的编译器选项时，在带有<code>myEnvironmentVariable</code>属性的文件中声明<code>Window</code>接口，就可以使用 <code>window.myEnvironmentVariable</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Window</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">myEnvironmentVariable</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>window.<span style="color:#a6e22e">myEnvironmentVariable</span>;
</span></span></code></pre></div><h3 id="member-naming-conflicts">Member Naming Conflicts</h3>
<p>请注意，<font color="#de7802">合并后的接口不能以不同类型多次声明相同名称的属性</font>。<font color="#548dd4">如果一个接口中已经声明了一个属性，那么以后合并的接口必须使用相同的类型</font>。但是，<span style="background:rgba(255, 183, 139, 0.55)">合并后的接口可以定义一个名称相同但签名不同的方法</span>。这样做会为该方法创建一个函数重载。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">MergedMethods</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 名称相同的方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">different</span>(<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">string</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">MergedMethods</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 名称相同的方法，但签名不同
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">different</span>(<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">number</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span>; <span style="color:#75715e">// Ok 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 因为类型相同，下面代码不会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Page</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">readonly</span> <span style="color:#a6e22e">text</span>: <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">read</span>(<span style="color:#a6e22e">page</span>: <span style="color:#66d9ef">Page</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">page</span>.<span style="color:#a6e22e">text</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Page</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">readonly</span> <span style="color:#a6e22e">text</span>: <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">read1</span>(<span style="color:#a6e22e">page</span>: <span style="color:#66d9ef">Page</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">page</span>.<span style="color:#a6e22e">text</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="classes">Classes</h1>
<blockquote>
<p>除了类型检查，<code>TypeScript</code>还强调了它的转换器（<code>transpiler</code>），类就是一个常见的例子。<code>TypeScript</code>中的类只是支持所有<code>JavaScript</code>语言特性的众多特性之一。<code>TypeScript</code>既不鼓励也不反对类的使用或任何其它流行的<code>JavaScript</code>模式。</p>
</blockquote>
<h2 id="class-methods">Class Methods</h2>
<p><code>TypeScript</code>对类中方法的理解与对独立函数的理解相同。<font color="#de7802">除非显式给出类型或默认值，否则方法形参的类型被编译器推断为</font><code>any</code>。需要注意的是如果设置的是严格模式，形参不允许省略类型标注。调用方法时<font color="#0070c0">需要给出正确的实参数量</font>，如果函数不是递归的，返回类型通常可以被编译器推断出来。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Greeter</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">greet</span>(<span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">name</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, do your stuff!`</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Greeter</span>().<span style="color:#a6e22e">greet</span>(<span style="color:#e6db74">&#34;Miss Frizzle&#34;</span>) <span style="color:#75715e">// Miss Frizzle, do your stuff!
</span></span></span></code></pre></div><p>类构造函数的形参与其它方法相同。<code>TypeScript</code>会执行类型检查，<font color="#de7802">以确保调用方法时提供了数量正确、类型正确的实参。</font></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Greeted</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>(<span style="color:#a6e22e">message</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`As I always say: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">message</span><span style="color:#e6db74">}</span><span style="color:#e6db74">!`</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Greeted</span>(<span style="color:#e6db74">&#34;take chances, make mistakes, get messy&#34;</span>); 
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">As</span> <span style="color:#a6e22e">I</span> <span style="color:#a6e22e">always</span> <span style="color:#a6e22e">say</span>: <span style="color:#66d9ef">take</span> <span style="color:#a6e22e">chances</span>, <span style="color:#a6e22e">make</span> <span style="color:#a6e22e">mistakes</span>, <span style="color:#66d9ef">get</span> <span style="color:#a6e22e">messy</span><span style="color:#f92672">!</span>
</span></span></code></pre></div><h2 id="class-properties">Class Properties</h2>
<p>在<code>TypeScript</code>中，若要读取或写入类的属性，必须在类中明确声明。类属性的声明语法与接口相同，名称后跟一个类型标注。<code>TypeScript</code><font color="#de7802">不会试图通过构造函数中的赋值来推断类中可能存在的成员</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FieldTrip</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">destination</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>(<span style="color:#a6e22e">destination</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">destination</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">destination</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`We&#39;re going to </span><span style="color:#e6db74">${</span><span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">destination</span><span style="color:#e6db74">}</span><span style="color:#e6db74">!`</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 编译错误：Property &#39;nonexistent&#39; does not exist on type &#39;FieldTrip&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">nonexistent</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">destination</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>显式地声明类的属性可以让<code>TypeScript</code>快速地了解类的实例中哪些属性是存在的，哪些是不存在的。<strong><font color="#548dd4">若访问类中不存在的属性，会出现编译错误</font></strong>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FieldTrip</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">destination</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>(<span style="color:#a6e22e">destination</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">destination</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">destination</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`We&#39;re going to </span><span style="color:#e6db74">${</span><span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">destination</span><span style="color:#e6db74">}</span><span style="color:#e6db74">!`</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">trip</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">FieldTrip</span>(<span style="color:#e6db74">&#34;planetarium&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 访问存在的属性，没有问题
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">trip</span>.<span style="color:#a6e22e">destination</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误:  Property &#39;nonexistent&#39; does not exist on type &#39;FieldTrip&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">trip</span>.<span style="color:#a6e22e">nonexistent</span>)
</span></span></code></pre></div><h3 id="function-properties">Function Properties</h3>
<p>下面<code>WithMethod</code>类定义了一个<code>myMethod</code>方法，所有实例都可以引用该方法。<strong><font color="#de7802">这种方式定义的方法，不会为每个类的实例创建一个副本</font></strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">WithMethod</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">myMethod() {</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果为true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">new</span> <span style="color:#a6e22e">WithMethod</span>().<span style="color:#a6e22e">myMethod</span> <span style="color:#f92672">===</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">WithMethod</span>().<span style="color:#a6e22e">myMethod</span>) 
</span></span></code></pre></div><p>另一种定义方法的语法是声明一个属性，其值恰好是一个函数。<span style="background:rgba(255, 183, 139, 0.55)">这种方式将会为类的每个实例创建一个新函数</span>，这对于箭头函数可能很有用，因为箭头函数的<code>this</code>作用域应始终指向类的实例。</p>
<p>下面<code>WithProperty</code>类定义了单个属性<code>myProperty</code>，它的类型为<code>() =&gt; void</code>，<font color="#de7802">每个类的实例都会创建一个新副本</font>，新创建的类实例对比该属性时总是返回false：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">WithProperty</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">myProperty</span><span style="color:#f92672">:</span> () <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">myProperty</span> <span style="color:#f92672">=</span> () <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 赋值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">new</span> <span style="color:#a6e22e">WithProperty</span>().<span style="color:#a6e22e">myProperty</span> <span style="color:#f92672">===</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">WithProperty</span>().<span style="color:#a6e22e">myProperty</span>) 
</span></span></code></pre></div><p>属性函数的形参和返回值类型与独立函数相同。因为，它们只是赋给类成员的值，而该值恰好是一个函数而已，所以并没有什么特殊。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">WithPropertyParameters</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">takesParameters</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">boolean</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">input</span> <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;Yes&#34;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;No&#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">instance</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">WithPropertyParameters</span>();
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">instance</span>.<span style="color:#a6e22e">takesParameters</span>(<span style="color:#66d9ef">true</span>)) <span style="color:#75715e">// Yes
</span></span></span></code></pre></div><h3 id="initialization-checking">Initialization Checking</h3>
<p>如果启用了严格的编译器设置，<code>TypeScript</code>将<font color="#de7802">检查所声明的每个属性</font>（类型不包括<code>undefined</code>的属性）是否在构造函数中赋值。</p>
<p>这种严格初始化检查非常有用，可以防止因意外忘记为属性赋值。下面定义的类<code>WithValue</code>，在构造函数中因没有为属性<code>unused</code>赋初始值，会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">WithValue</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">immediate</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">later</span>: <span style="color:#66d9ef">number</span>; <span style="color:#75715e">// Ok (set in the constructor)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">mayBeUndefined</span>: <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>; <span style="color:#75715e">// Ok (allowed to be undefined)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">unused</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">later</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误: Property &#39;unused&#39; has no initializer and is not definitely assigned in the constructor.
</span></span></span></code></pre></div><p>如果没有严格的初始化检查，类实例可能会被允许访问一个可能为<code>undefined</code>的值，即使类型系统规定不能这样做。</p>
<h4 id="definitely-assigned-properties">Definitely assigned properties</h4>
<p>尽管严格的初始检查在多数情况下是很有用的，但在某些情况下，可能会遇到故意在类构造函数之后取消检查类的某个属性的情况。</p>
<p>如果<font color="#de7802">绝对确定某个属性不需要应用严格初始化检查</font>，可以在其名称后添加一个<code>!</code>来禁用检查。这样做可以向<code>TypeScript</code>申明，该属性将在首次使用前一定会被赋值，而不是<code>undefined</code>的值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ActivitiesQueue</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pending</span><span style="color:#f92672">!:</span> <span style="color:#66d9ef">string</span>[]; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">initialize</span>(<span style="color:#a6e22e">pending</span>: <span style="color:#66d9ef">string</span>[]) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">pending</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">pending</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">next() {</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">pending</span>.<span style="color:#a6e22e">pop</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">activities</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">ActivitiesQueue</span>();
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">activities</span>.<span style="color:#a6e22e">initialize</span>([<span style="color:#e6db74">&#39;eat&#39;</span>, <span style="color:#e6db74">&#39;sleep&#39;</span>, <span style="color:#e6db74">&#39;learn&#39;</span>])
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">activities</span>.<span style="color:#a6e22e">next</span>();
</span></span></code></pre></div><h2 id="optional-properties-2">Optional Properties</h2>
<p>和接口相似，类也可以声明可选的属性。可选属性的行为与属性类型恰巧是包含<code>| undefined</code>的联合类型属性大致相同。<strong><font color="#de7802">如果没有在构造函数中明确设置可选属性的初始值，严格的初始化检查也不会在意。</font></strong></p>
<p>下面的<code>OptionalProperty</code>类中，它的<code>property</code>属性是可选的。因此，无论是否有严格的属性初始化检查，都允许不在类构造函数中赋值可选属性：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MissingInitializer</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">property?</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">new</span> <span style="color:#a6e22e">MissingInitializer</span>().<span style="color:#a6e22e">property</span><span style="color:#f92672">?</span>.<span style="color:#a6e22e">length</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Object is possibly &#39;undefined&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">new</span> <span style="color:#a6e22e">MissingInitializer</span>().<span style="color:#a6e22e">property</span>.<span style="color:#a6e22e">length</span>)
</span></span></code></pre></div><h2 id="read-only-properties-1">Read-Only Properties</h2>
<p>类似接口，类定义时也可以在属性前面添加<code>readonly</code>关键词。关键词<code>readonly</code>仅存在于类型系统，当编译为<code>JavaScript</code>文件后，<code>readonly</code><span style="background:rgba(255, 183, 139, 0.55)">关键字会被移除</span>。</p>
<p>需要注意的是，<span style="background:rgba(255, 183, 139, 0.55)">声明为只读的属性只能在声明处或构造函数中分配初始值</span>。任何其它位置（包括类本身的方法）只能读取属性，而不能写入属性。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Quote</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 只读属性只能在声明处或构造函数中分配初始值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">readonly</span> <span style="color:#a6e22e">text</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>(<span style="color:#a6e22e">text</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">text</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">text</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">emphasize() {</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 编译错误: Cannot assign to &#39;text&#39; because it is a read-only property.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">text</span> <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;!&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">quote</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Quote</span>(<span style="color:#e6db74">&#34;this is a test&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">quote</span>.<span style="color:#a6e22e">text</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 只读属性不能重新赋值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">quote</span>.<span style="color:#a6e22e">text</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Hello world&#34;</span>;
</span></span></code></pre></div><p>与其它属性相比，<font color="#de7802">声明为只读且初始值为基础类型字面量的属性有一个特性：它们会被推断为其值的字面量类型，而不是基本类型</font>，<span style="background:rgba(255, 183, 139, 0.55)">这样的属性在类构造函数中也不能重新赋值。</span></p>
<p><code>TypeScript</code>对于这种激进的字面量初始类型窄化感觉良好，因为知道其值以后不会改变。这类似于<code>const</code>变量比<code>let</code>变量使用更窄的类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">RandomQuote</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 显式声明为string类型，在初始化器中可以被修改
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">readonly</span> <span style="color:#a6e22e">explicit</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Home is the nicest word there is.&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 推断为字面量类型，不可修改
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">readonly</span> <span style="color:#a6e22e">implicit</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Home is the nicest word there is.&#34;</span>;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 非字面量类型，在初始化器中可以赋值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">explicit</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;We start learning the minute we&#39;re born.&#34;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 没有显式标注类型，并使用字面量进行初始化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// 即使在构造函数中重新赋值也会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">implicit</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;We start learning the minute we&#39;re born.&#34;</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 错误信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">Type</span> <span style="color:#e6db74">&#39;&#34;We start learning the minute we&#39;</span><span style="color:#a6e22e">re</span> <span style="color:#a6e22e">born</span>.<span style="color:#e6db74">&#34;&#39; is not assignable to type &#39;&#34;</span><span style="color:#a6e22e">Home</span> <span style="color:#66d9ef">is</span> <span style="color:#a6e22e">the</span> <span style="color:#a6e22e">nicest</span> <span style="color:#a6e22e">word</span> <span style="color:#a6e22e">there</span> <span style="color:#66d9ef">is</span>.<span style="color:#960050;background-color:#1e0010">&#34;&#39;</span>.
</span></span></code></pre></div><h2 id="classes-as-types">Classes as Types</h2>
<p>类在类型系统中相对独特，因为类声明既创建了运行时值（类本身），也创建了可用于类型标注的类型。下面示例代码中，类<code>Teacher</code>用于标注变量<code>teacher</code>，以告诉<code>TypeScript</code>它应该只赋值给可赋值给<code>Teacher</code>类的值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Teacher</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sayHello() {</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Take chances, make mistakes, get messy!&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">teacher</span>: <span style="color:#66d9ef">Teacher</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">teacher</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Teacher</span>()
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">teacher</span>.<span style="color:#a6e22e">sayHello</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type &#39;string&#39; is not assignable to type &#39;Teacher&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">tearcher</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Wahoo!&#34;</span>
</span></span></code></pre></div><p>有趣的是，<code>TypeScript</code>会<font color="#de7802">将任何恰好包含当前类中所有相同成员的对象类型视为可赋值给当前类</font>。这是因为<code>TypeScript</code>中的<code>structural typing</code><span style="background:rgba(255, 183, 139, 0.55)">只关心对象的形状，并不关心它们是如何声明的</span>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SchoolBus</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">getAbilities() {</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> [<span style="color:#e6db74">&#34;magic&#34;</span>, <span style="color:#e6db74">&#34;shapeshifting&#34;</span>];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">withSchoolBus</span>(<span style="color:#a6e22e">bus</span>: <span style="color:#66d9ef">SchoolBus</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">bus</span>.<span style="color:#a6e22e">getAbilities</span>());
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">withSchoolBus</span>(<span style="color:#66d9ef">new</span> <span style="color:#a6e22e">SchoolBus</span>());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 下面这种调用方式也是可以的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">withSchoolBus</span>({
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">getAbilities</span><span style="color:#f92672">:</span> () <span style="color:#f92672">=&gt;</span> [<span style="color:#e6db74">&#34;transmogrification&#34;</span>]
</span></span><span style="display:flex;"><span>})
</span></span></code></pre></div><h2 id="classes-and-interfaces">Classes and Interfaces</h2>
<p><code>TypeScript</code>允许类在名字后添加<code>implements</code>关键字，并在其后添加接口名称，从而将类声明为遵循这个接口。这样做是向<code>TypeScript</code>表明，<span style="background:rgba(255, 183, 139, 0.55)">类的实例可以赋值给这些接口中的任何一个</span>。任何不匹配都会被类型检查器认为时类型错误。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Learner</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">study</span>(<span style="color:#a6e22e">hours</span>: <span style="color:#66d9ef">number</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">void</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Student</span> <span style="color:#66d9ef">implements</span> <span style="color:#a6e22e">Learner</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>(<span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">name</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">study</span>(<span style="color:#a6e22e">hours</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">hours</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;...studying...&#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>将一个类标记为实现了一个接口并不会改变该类的使用方式。如果该类已经与接口相匹配，<code>TypeScript</code>的类型检查器允许在需要接口实例的地方使用该类的实例。</p>
<h3 id="implementing-multiple-interfaces">Implementing Multiple Interfaces</h3>
<p><code>TypeScript</code>中<font color="#de7802">一个类可以实现任意多个接口，接口名称之间用逗号隔开</font>。下面代码中，类在实现接口<code>Graded</code>时必需具有<code>grades</code>属性，在实现接口<code>Reporter</code>时必需具有<code>report</code>属性。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Graded</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">grades</span>: <span style="color:#66d9ef">number</span>[];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Reporter</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">report</span><span style="color:#f92672">:</span> () <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 下面类ReportCard是正常的，因为实现了grades和report
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ReportCard</span> <span style="color:#66d9ef">implements</span> <span style="color:#a6e22e">Graded</span>, <span style="color:#a6e22e">Reporter</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">grades</span>: <span style="color:#66d9ef">number</span>[];
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>(<span style="color:#a6e22e">grades</span>: <span style="color:#66d9ef">number</span>[]) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">grades</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">grades</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">report() {</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">grades</span>.<span style="color:#a6e22e">join</span>(<span style="color:#e6db74">&#34;, &#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 下面会出现编译错误，因为Empty没有真正实现接口
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 如果实现了接口，需要把所有的属性和接口都生成一遍
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Empty</span> <span style="color:#66d9ef">implements</span> <span style="color:#a6e22e">Graded</span>, <span style="color:#a6e22e">Reporter</span> {
</span></span><span style="display:flex;"><span>   
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="type-modifiers">Type Modifiers</h1>
<p>现在，已经了解<code>TypeScript</code>类型系统如何与现有<code>JavaScript</code>结构（如数组、类和对象）协同工作，接下来将进一步介绍类型系统本身。</p>
<h2 id="top-types">Top Types</h2>
<p><span style="background:rgba(255, 183, 139, 0.55)">顶层类型或通用类型是一种可以代表类型系统中任何可能值的类型</span>。所有类型的值都可以赋值给顶层类型的变量或常量，但相反时不一定正确。</p>
<h3 id="any">any</h3>
<p><code>any</code>类型可以作为顶层类型，<span style="background:rgba(255, 183, 139, 0.55)">表示没有任何限制，该类型的变量可以被赋予任意类型的值</span>。 <code>any</code>类型可用于允许接受任何类型的地方，例如作为<code>console.log</code>的参数:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">anyValue</span>: <span style="color:#66d9ef">any</span>;  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">anyValue</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Lucille Ball&#34;</span>; <span style="color:#75715e">// Ok  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">anyValue</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">123</span>; <span style="color:#75715e">// Ok  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">anyValue</span>); <span style="color:#75715e">// Ok
</span></span></span></code></pre></div><p>使用<code>any</code>就是<font color="#de7802">明确告诉编译器不需要执行类型检查</font>。这种类型检查的缺失有时会有用，但也降低了实用性。例如，下面代码不会出现编译错误，但会出现运行时错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">greetComedian</span>(<span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">any</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 此时无类型错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Announcing </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">name</span>.<span style="color:#a6e22e">toUpperCase</span>()<span style="color:#e6db74">}</span><span style="color:#e6db74">!`</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 运行时错误: name.toUpperCase is not a function
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">greetComedian</span>({<span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Bea Arthur&#34;</span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">any</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;hello&#39;</span>;  
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译不报错，但运行时报错  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">x</span>(<span style="color:#ae81ff">1</span>) 
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译不报错，但运行时报错
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">x</span>.<span style="color:#a6e22e">foo</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>; 
</span></span></code></pre></div><p>因为上面原因，应当尽量避免使用<code>any</code>类型。从集合论的角度看，<code>any</code>类型可以看成是所有其它类型的全集，它包含了一切可能的类型。这种类型被称为<code>Top Type</code>，表示涵盖了所有下层类型。</p>
<p>类型<code>any</code>除了关闭类型检查，还有一个很大的问题，<span style="background:rgba(255, 183, 139, 0.55)">就是它会「污染」其他变量</span>。<font color="#de7802">它可以赋值给其他任何类型的变量（因为没有类型检查），导致其他变量出错</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">any</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;hello&#39;</span>;  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">number</span>;  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">y</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">x</span>; <span style="color:#75715e">// 不报错  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">y</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">123</span> <span style="color:#75715e">// 告诉编译器y也不需要类型检查，因此也不会报错，只是在运行时报错
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 因为一直认为y是number类型，所以编译不报错
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 运行时报错：y.toFixed is not a function
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">y</span>.<span style="color:#a6e22e">toFixed</span>() 
</span></span></code></pre></div><h3 id="unknown">unknown</h3>
<p>为了解决<code>any</code>类型污染其它类型的问题，引入了<code>unkonw</code>类型，<font color="#de7802">它是一种真正的顶层类型</font>。<code>unknown</code>和<code>any</code>类似，所有对象都可以赋值给标注为<code>unknown</code>类型的变量。类型<code>any</code>与<code>unknown</code>的主要区别在于，<code>TypeScript</code>对<code>unknown</code>类型的值有更严格的限制：</p>
<ul>
<li>不允许<font color="#de7802">直接访问</font><code>unkonwn</code>类型值的方法和属性。</li>
<li><code>unknown</code>不可赋值给非顶级类型（非<code>any</code>或<code>unknown</code>）。</li>
</ul>
<p>如果直接访问类型为<code>unknown</code>类型值的属性，会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">greetComedian</span>(<span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">unknown</span>) {  
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 不能直接访问unknown类型变量的方法或属性
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Announcing </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">name</span>.<span style="color:#a6e22e">toUpperCase</span>()<span style="color:#e6db74">}</span><span style="color:#e6db74">!`</span>);  
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：&#39;name&#39; is of type &#39;unknown&#39;.
</span></span></span></code></pre></div><p>允许在代码中访问<code>unknwon</code>类型值的唯一方法是窄化值的类型范围。例如，使用<code>instanceof</code>或<code>typeof</code>或使用类型断言。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">greetComedianSafety</span>(<span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">unknown</span>) {  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">name</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;string&#39;</span>) {  
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Announcing </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">name</span>.<span style="color:#a6e22e">toUpperCase</span>()<span style="color:#e6db74">}</span><span style="color:#e6db74">!`</span>); <span style="color:#75715e">// Ok  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    } <span style="color:#66d9ef">else</span> {  
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Well, I&#39;m off.&#34;</span>);  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">greetComedianSafety</span>(<span style="color:#e6db74">&#34;Betty White&#34;</span>); <span style="color:#75715e">// Logs: 4  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">greetComedianSafety</span>({});
</span></span></code></pre></div><h2 id="type-predicates">Type Predicates</h2>
<p>使用<code>instanceof</code>和<code>typeof</code>，可以窄化类型范围。对于<font color="#de7802">直接使用有限检查集窄化类型来说，这一切都很好</font>。如果用函数来包装类型窄化逻辑，会使得原来的窄化失去作用。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 将窄化封装成函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">isNumberOrString</span>(<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">unknown</span>) {  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> [<span style="color:#e6db74">&#39;number&#39;</span>, <span style="color:#e6db74">&#39;string&#39;</span>].<span style="color:#a6e22e">includes</span>(<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">value</span>);  
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">logValueIfExists</span>(<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>) {  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">isNumberOrString</span>(<span style="color:#a6e22e">value</span>)) { <span style="color:#75715e">// Type of value: number | string | null | undefined  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 编译错误Object is possibly undefined. 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">value</span>.<span style="color:#a6e22e">toString</span>();  
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {  
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Value does not exist:&#34;</span>, <span style="color:#a6e22e">value</span>);  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>TypeScript</code>有一种特殊语法，<span style="background:rgba(240, 107, 5, 0.2)">用于返回布尔值的函数，以指示参数是否为特定类型</span>。这种特殊的语法被称为<code>type predicate</code>(类型谓词)，有时也被称为<code>user-defined type guard</code>，表示开发者正在创建自己的类型保护，类似<code>instanceof</code>或<code>typeof</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">typePredicate</span>(<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">WideType</span>)<span style="color:#f92672">:</span> <span style="color:#a6e22e">input</span> <span style="color:#66d9ef">is</span> <span style="color:#a6e22e">NarrowType</span>;
</span></span></code></pre></div><p>可以修改上面定义的函数<code>isNumberOrString</code>，使其具有明确的输入类型，即限制函数入参<code>value</code>的类型为<code>string | number</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">isNumberOrString</span>(<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">unknown</span>)<span style="color:#f92672">:</span> <span style="color:#a6e22e">value</span> <span style="color:#66d9ef">is</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">string</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> [<span style="color:#e6db74">&#39;number&#39;</span>, <span style="color:#e6db74">&#39;string&#39;</span>].<span style="color:#a6e22e">includes</span>(<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">value</span>);  
</span></span><span style="display:flex;"><span>}  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">logValueIfExists</span>(<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>) {  
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 无编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">isNumberOrString</span>(<span style="color:#a6e22e">value</span>)) { 
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">value</span>.<span style="color:#a6e22e">toString</span>(); 
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {  
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Value does not exist:&#34;</span>, <span style="color:#a6e22e">value</span>);  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>类型谓词通常用于检查一个已知接口实例的对象是否是一个更具体接口的实例。下面代码中，接口<code>StandupComedian</code>扩展自<code>Comedian</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Comedian</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">funny</span>: <span style="color:#66d9ef">boolean</span>;  
</span></span><span style="display:flex;"><span>}  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">StandupComedian</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Comedian</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">routine</span>: <span style="color:#66d9ef">string</span>;  
</span></span><span style="display:flex;"><span>}  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">isStandupComedian</span>(<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">Comedian</span>)<span style="color:#f92672">:</span> <span style="color:#a6e22e">value</span> <span style="color:#66d9ef">is</span> <span style="color:#a6e22e">StandupComedian</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#39;routine&#39;</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">value</span>;  
</span></span><span style="display:flex;"><span>}  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">workWithComedian</span>(<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">Comedian</span>) {  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">isStandupComedian</span>(<span style="color:#a6e22e">value</span>)) { <span style="color:#75715e">// Type of value: StandupComedian  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">value</span>.<span style="color:#a6e22e">routine</span>); <span style="color:#75715e">// Ok  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }  
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Type of value: Comedian  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 编译错误: Property &#39;routine&#39; does not exist on type &#39;Comedian&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">value</span>.<span style="color:#a6e22e">routine</span>);  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>需要注意的是，因为类型谓词在<code>false</code>情况下也会窄化类型范围，<font color="#de7802">如果类型谓词不仅检查输入类型，还检查其他，可能会出现令人惊讶的结果</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">isLongString</span>(<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>)<span style="color:#f92672">:</span> <span style="color:#a6e22e">input</span> <span style="color:#66d9ef">is</span> <span style="color:#66d9ef">string</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">!!</span>(<span style="color:#a6e22e">input</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">input</span>.<span style="color:#a6e22e">length</span> <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">7</span>);  
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">workWithText</span>(<span style="color:#a6e22e">text</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>) { 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 使用了类型谓词，则认为if里面全部是string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// else里面是undefined
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">isLongString</span>(<span style="color:#a6e22e">text</span>)) { <span style="color:#75715e">// Type of text: string  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Long text:&#34;</span>, <span style="color:#a6e22e">text</span>.<span style="color:#a6e22e">length</span>);  
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {  
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Type of text: undefined  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 编译错误 Property &#39;length&#39; does not exist on type &#39;never&#39;.  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Short text:&#34;</span>, <span style="color:#a6e22e">text</span><span style="color:#f92672">?</span>.<span style="color:#a6e22e">length</span>);  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>因为<span style="background:rgba(240, 107, 5, 0.2)">类型谓词除了验证类型外，还可以验证其他，因此很容易被滥用</span>，一般建议尽可能避免使用它们。多数情况下，简单的类型谓词就足够使用了。</p>
<h2 id="type-operators">Type Operators</h2>
<p>并非所有类型都可以只使用关键字或现有类型的名称来表示。有时，需要创建一种新类型，将两者结合起来，对现有类型的属性进行一些转换。</p>
<h3 id="keyof">keyof</h3>
<p><code>JavaScript</code>对象可以使用动态键访问成员，动态键通常（但不一定）是<code>string</code>。在类型系统中表示这些键可能很棘手。使用诸如<code>catchall primitive</code>将允许非法的容器键值。</p>
<p>这就是为什么<code>TypeScript</code>在使用更严格的编译设置时，直接使用<code>ratings[key]</code>会报错。如下所示，类型<code>string</code>允许的值很可能不允许作为<code>Ratings</code>接口上的属性，而且<code>Ratings</code>在定义时并没有允许任何字符串键的索引签名：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Ratings</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">audience</span>: <span style="color:#66d9ef">number</span>;  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">critics</span>: <span style="color:#66d9ef">number</span>;  
</span></span><span style="display:flex;"><span>} 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getRating</span>(<span style="color:#a6e22e">ratings</span>: <span style="color:#66d9ef">Ratings</span>, <span style="color:#a6e22e">key</span>: <span style="color:#66d9ef">string</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ratings</span>[<span style="color:#a6e22e">key</span>];  
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//  Element implicitly has an &#39;any&#39; type because expression of type &#39;string&#39; can&#39;t be used to index type &#39;Ratings&#39;.
</span></span></span></code></pre></div><p>一种可行的方法是<font color="#de7802">对允许的键使用字面量联合</font>。这样可以更准确地限制容器中存在的键，下面代码使用了字面量联合类型来限制键的范围：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Ratings</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">audience</span>: <span style="color:#66d9ef">number</span>;  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">critics</span>: <span style="color:#66d9ef">number</span>;  
</span></span><span style="display:flex;"><span>}  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getRating</span>(<span style="color:#a6e22e">ratings</span>: <span style="color:#66d9ef">Ratings</span>, <span style="color:#a6e22e">key</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;audience&#39;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#39;critics&#39;</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ratings</span>[<span style="color:#a6e22e">key</span>]; <span style="color:#75715e">// Ok  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">ratings</span>: <span style="color:#66d9ef">Ratings</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">audience</span>: <span style="color:#66d9ef">66</span>, <span style="color:#a6e22e">critics</span>: <span style="color:#66d9ef">84</span>};  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">getRating</span>(<span style="color:#a6e22e">ratings</span>, <span style="color:#e6db74">&#39;audience&#39;</span>);
</span></span></code></pre></div><p>但如果接口有很多属性时，必须把每个成员的<code>key</code>都输入到联合类型中，并随时更新。这样后续维护就会变得非常麻烦。</p>
<p><code>TypeScript</code>提供了<code>keyof</code>操作符，<span style="background:rgba(240, 107, 5, 0.2)">它接收现有类型，并返回该类型允许的所有键的联合</span>。在任何需要使用类型的地方，可以将它放在类型名称的前面。下面代码中，<code>keyof Ratings</code>等同于<code>'audience' | 'critic'</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getCountKeyof</span>(<span style="color:#a6e22e">ratings</span>: <span style="color:#66d9ef">Ratings</span>, <span style="color:#a6e22e">key</span>: <span style="color:#66d9ef">keyof</span> <span style="color:#a6e22e">Ratings</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ratings</span>[<span style="color:#a6e22e">key</span>];  
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">RatingsExt</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Ratings</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">test</span>: <span style="color:#66d9ef">number</span>  
</span></span><span style="display:flex;"><span>}  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getCountKeyof</span>(<span style="color:#a6e22e">ratings</span>: <span style="color:#66d9ef">RatingsExt</span>, <span style="color:#a6e22e">key</span>: <span style="color:#66d9ef">keyof</span> <span style="color:#a6e22e">RatingsExt</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ratings</span>[<span style="color:#a6e22e">key</span>];  
</span></span><span style="display:flex;"><span>}  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">ratingsExt</span>: <span style="color:#66d9ef">RatingsExt</span> <span style="color:#f92672">=</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">audience</span>: <span style="color:#66d9ef">66</span>,  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">critics</span>: <span style="color:#66d9ef">84</span>,  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">test</span>: <span style="color:#66d9ef">124</span>  
</span></span><span style="display:flex;"><span>};  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 继承的键也是可用的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">getCountKeyof</span>(<span style="color:#a6e22e">ratingsExt</span>, <span style="color:#e6db74">&#39;test&#39;</span>))  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">getCountKeyof</span>(<span style="color:#a6e22e">ratingsExt</span>, <span style="color:#e6db74">&#39;audience&#39;</span>))  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">getCountKeyof</span>(<span style="color:#a6e22e">ratingsExt</span>, <span style="color:#e6db74">&#39;critics&#39;</span>))
</span></span></code></pre></div><p><code>keyof</code>是基于现有类型的键创建联合类型的一项强大功能。它还能与<code>TypeScript</code>中的其他类型操作符很好地结合，从而实现一些非常有趣的模式。</p>
<h3 id="typeof">typeof</h3>
<p><code>TypeScript</code>提供的另一个类型操作符是<code>typeof</code>，它会返回所提供值的类型。如果手动编写值的类型复杂得令人讨厌，这个操作符就非常有用。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">original</span> <span style="color:#f92672">=</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">medium</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;movie&#34;</span>,  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">title</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Mean Girls&#34;</span>,  
</span></span><span style="display:flex;"><span>}; 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">adaptation</span>: <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">original</span>;  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span>) {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">adaptation</span> <span style="color:#f92672">=</span> {...<span style="color:#a6e22e">original</span>, <span style="color:#a6e22e">medium</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;play&#34;</span>}; <span style="color:#75715e">// Ok  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} <span style="color:#66d9ef">else</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Error: Type &#39;number&#39; is not assignable to type &#39;string&#39;.  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">adaptation</span> <span style="color:#f92672">=</span> {...<span style="color:#a6e22e">original</span>, <span style="color:#a6e22e">medium</span>: <span style="color:#66d9ef">2</span>};  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>尽管<code>typeof</code><font color="#de7802">类型操作符从外观上看很像运行时的</font><code>typeof</code>操作符，后者返回值类型的字符串描述，但两者是不同的。</p>
<p>也就是说，<span style="background:rgba(255, 183, 139, 0.55)">它们只是巧合地使用了同一个词。请记住：<code>JavaScript</code>操作符是一个运行时操作符，用于返回类型的字符串名称</span>。<code>typeScript</code>中的<code>typeof</code>因为是类型操作符，所以只能在类型中使用，不会出现在编译后的代码中。</p>
<h3 id="keyof-typeof">keyof typeof</h3>
<p><code>typeof</code>检索值的类型，<code>keyof</code>检索类型允许的键。<code>typeScript</code>允许将这两个关键字串联起来，以简洁地检索值类型上允许的键。将它们组合在一起，<code>typeof</code>类型操作符在处理<code>keyof</code>类型操作时变得非常有用。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">ratings</span> <span style="color:#f92672">=</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">imdb</span>: <span style="color:#66d9ef">8.4</span>,  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">metacritic</span>: <span style="color:#66d9ef">82</span>,  
</span></span><span style="display:flex;"><span>};  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">logRating</span>(<span style="color:#a6e22e">key</span>: <span style="color:#66d9ef">keyof</span> <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">ratings</span>) {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">ratings</span>[<span style="color:#a6e22e">key</span>]);  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="type-assertions">Type Assertions</h2>
<p>当我们的代码是「强类型」时，所有值都有精确的类型，<code>TypeScript</code>的效果最好。顶层类型和类型保护等特性可以让类型检查程序理解复杂的代码。但是，有时并不能<code>100%</code>准确地告诉类型系统值的准确类型。</p>
<p>例如，<code>JSON.parse</code>故意返回顶层类型<code>any</code>。我们无法安全地告知类型系统，传递给<code>JSON.parse</code>的特定字符串值应返回任何特定的值类型。</p>
<p><code>TypeScript</code>提供了一种语法，<font color="#de7802">用于覆盖类型系统对值类型的理解</font>。即<code>type assertion</code>，也称为<code>type cast</code>。如果一个值的类型不同，可以在<code>as</code>关键字后面加上一个类型，<code>TypeScript</code>将遵从断言，将该值视为该类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">rawData</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">`[&#34;grace&#34;, &#34;frankie&#34;]`</span>;  
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: any  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">JSON</span>.<span style="color:#a6e22e">parse</span>(<span style="color:#a6e22e">rawData</span>);  
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: string[]  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">JSON</span>.<span style="color:#a6e22e">parse</span>(<span style="color:#a6e22e">rawData</span>) <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">string</span>[];  
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: [string, string]  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">JSON</span>.<span style="color:#a6e22e">parse</span>(<span style="color:#a6e22e">rawData</span>) <span style="color:#66d9ef">as</span> [<span style="color:#66d9ef">string</span>, <span style="color:#66d9ef">string</span>];  
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: [&#34;grace&#34;, &#34;frankie&#34;]  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">JSON</span>.<span style="color:#a6e22e">parse</span>(<span style="color:#a6e22e">rawData</span>) <span style="color:#66d9ef">as</span> [<span style="color:#e6db74">&#34;grace&#34;</span>, <span style="color:#e6db74">&#34;frankie&#34;</span>];
</span></span></code></pre></div><p><span style="background:#F5D6A9">类型断言仅存在于类型系统</span>，当编译为<code>JavaScript</code>后，<font color="#de7802">它们会与类型系统语法的其它部分一起被删除</font>。上面代码编译为<code>JavaScript</code>后将变成如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">rawData</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">`[&#34;grace&#34;, &#34;frankie&#34;]`</span>;  
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: any  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">JSON</span>.<span style="color:#a6e22e">parse</span>(<span style="color:#a6e22e">rawData</span>);  
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: string[]  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">JSON</span>.<span style="color:#a6e22e">parse</span>(<span style="color:#a6e22e">rawData</span>) 
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: [string, string]  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">JSON</span>.<span style="color:#a6e22e">parse</span>(<span style="color:#a6e22e">rawData</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: [&#34;grace&#34;, &#34;frankie&#34;]  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">JSON</span>.<span style="color:#a6e22e">parse</span>(<span style="color:#a6e22e">rawData</span>)
</span></span></code></pre></div><p><code>TypeScript</code><span style="background:#F5D6A9">最佳实践是尽可能避免使用类型断言</span>。我们写的代码最好是完全准确类型化的，不需要使用断言来干扰<code>TypeScript</code>对其类型的理解。但有时类型断言是有用的，甚至是必要的。</p>
<h3 id="asserting-caught-error-types">Asserting Caught Error Types</h3>
<p>错误处理是类型断言可能派上用场的另一个地方。一般来说，我们不清楚在<code>catch</code>代码块中捕获的错误是什么类型，因为<code>try</code>代码块中的代码可能会意外地抛出与预期不同的对象。</p>
<p>此外，虽然<code>JavaScript</code>的最佳实践是始终抛出<code>Error</code>类的实例，但**<font color="#de7802">有些项目却会抛出字符串字面量或其它出人意料的值</font>**。</p>
<p>如果确信某个代码区域只会抛出<code>Error</code>类的实例，可以使用类型断言将捕获的断言视为<code>Error</code>。下面代码将访问捕获的<code>error</code>的<code>message</code>属性，并假定该<code>error</code>是<code>Error</code>类的实例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">try</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// code that may throw an error
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">error</span>) {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">warn</span>(<span style="color:#e6db74">&#34;Oh no!&#34;</span>, (<span style="color:#a6e22e">error</span> <span style="color:#66d9ef">as</span> Error).<span style="color:#a6e22e">message</span>);  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>比较安全的做法是使用类型窄化形式，如使用<code>instanceof</code>检查，以确保抛出的错误是预期的类型。下面代码检查抛出的错误是否为<code>Error</code>类的实例，以确定是记录<code>message</code>还是记录错误本身：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">try</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// (code that may throw an error)  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">error</span>) {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">warn</span>(<span style="color:#e6db74">&#34;Oh no!&#34;</span>, <span style="color:#a6e22e">error</span> <span style="color:#66d9ef">instanceof</span> Error <span style="color:#f92672">?</span> <span style="color:#a6e22e">error.message</span> : <span style="color:#66d9ef">error</span>)  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="non-null-assertions">Non-Null Assertions</h3>
<p>类型断言的另一个常见场景是从变量中移除<code>null</code>或<code>undefined</code>，而<font color="#de7802">这些变量理论上可能包含<code>null</code>或<code>undefined</code>，但实际上并不包含</font>。</p>
<p>这种情况十分常见，<code>TypeScript</code>为此提供了一种速记方法。使用<code>!</code>表示同样的意思，不用写出<code>as</code>和值的完整类型，无论该值是否包含<code>null</code>和<code>undefined</code>。换句话说，<code>!</code>表示变量的类型不是<code>null</code>或<code>undefined</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">maybeDate</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> <span style="color:#66d9ef">undefined</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">new</span> Date();  
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Asserted type: Date  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">maybeDate</span> <span style="color:#66d9ef">as</span> Date;  
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Asserted type: Date  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">maybeDate</span><span style="color:#f92672">!</span>;
</span></span></code></pre></div><p>在使用<code>Map.get</code>等<code>API</code>时，非空断言尤其有用，这些<code>API</code>会返回一个值，如果该键对应的值不存在时，则返回<code>undefined</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">seasonCounts</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Map</span>([[<span style="color:#e6db74">&#34;I Love Lucy&#34;</span>, <span style="color:#ae81ff">6</span>], [<span style="color:#e6db74">&#34;The Golden Girls&#34;</span>, <span style="color:#ae81ff">7</span>],]);  
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: string | undefined  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">maybeValue</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">seasonCounts</span>.<span style="color:#66d9ef">get</span>(<span style="color:#e6db74">&#34;I Love Lucy&#34;</span>);  
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Error: Object is possibly &#39;undefined&#39;.  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">maybeValue</span>.<span style="color:#a6e22e">toUpperCase</span>());  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: string  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">knownValue</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">seasonCounts</span>.<span style="color:#66d9ef">get</span>(<span style="color:#e6db74">&#34;I Love Lucy&#34;</span>)<span style="color:#f92672">!</span>;  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">knownValue</span>.<span style="color:#a6e22e">toUpperCase</span>()); <span style="color:#75715e">// Ok
</span></span></span></code></pre></div><h3 id="type-assertion-caveats">Type Assertion Caveats</h3>
<p>类型断言，像<code>any</code>类型一样，是<code>TypeScript</code><font color="#de7802">类型系统的一个必要逃生舱口</font>。因此，与<code>any</code>类型一样，如果有其它方案，应当避免使用断言。</p>
<p>通常情况下，在代码中使用更准确的类型比使用断言更好。因为，有时断言往往是错误的，要么在编写时已经是错误的，要么在代码库发生变化后产生的错误。下面代码无编译错误，但运行时会报错：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">seasonCounts</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Map</span>([[<span style="color:#e6db74">&#34;I Love Lucy&#34;</span>, <span style="color:#ae81ff">6</span>], [<span style="color:#e6db74">&#34;The Golden Girls&#34;</span>, <span style="color:#ae81ff">7</span>],]);  
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: string  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">knownValue</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">seasonCounts</span>.<span style="color:#66d9ef">get</span>(<span style="color:#e6db74">&#34;I Love Lucy 11&#34;</span>)<span style="color:#f92672">!</span>;  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">knownValue</span>.<span style="color:#a6e22e">toUpperCase</span>()); <span style="color:#75715e">// Ok
</span></span></span></code></pre></div><p>作为对比，如果使用类型声明时，在编译时可能就会报错。而<font color="#de7802">使用类型断言时，需要在运行时才会报错</font>，需要特别注意：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Entertainer</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">acts</span>: <span style="color:#66d9ef">string</span>[];  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;  
</span></span><span style="display:flex;"><span>}  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误:  Property &#39;acts&#39; is missing in type &#39;{ name: string; }&#39; but required in type &#39;Entertainer&#39;.  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// const declared: Entertainer = {name: &#34;Moms Mabley&#34;,};  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">asserted</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Moms Mabley&#34;</span>,} <span style="color:#66d9ef">as</span> <span style="color:#a6e22e">Entertainer</span>; <span style="color:#75715e">// Ok, but...  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 运行时错误: Cannot read properties of undefined (reading &#39;join&#39;)  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">asserted</span>.<span style="color:#a6e22e">acts</span>.<span style="color:#a6e22e">join</span>(<span style="color:#e6db74">&#34;, &#34;</span>));
</span></span></code></pre></div><p>需要注意的是，<span style="background:#F8D9C3">类型断言被允许的前提是其中一个类型可以赋值给另一个类型</span>。如果类型断言发生在两个完全不相关的类型之间，就会出现编译错误。</p>
<p>如下所示，在<font color="#de7802">两个基本类型之间直接使用类型断言是不允许的</font>。下面代码中<code>string</code>类型直接断言为<code>number</code>会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// Conversion of type &#39;string&#39; to type &#39;number&#39; may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to &#39;unknown&#39; first.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">myValue</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Stella!&#34;</span> <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 使用双重断言可以转换成功，但十分危险
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">myValueDouble</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;1337&#34;</span> <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">unknown</span> <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">number</span>;  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">myValueDouble</span>)
</span></span></code></pre></div><h2 id="const-assertions">Const Assertions</h2>
<p><code>const</code>断言通常用于表示任何值（数组、基础类型值等）都<span style="background:#f8d9c3">应被视为其自身的恒定不变版本</span>。具体来说，<code>const</code>断言会对其接收到的任意类型应用以下三条规则：</p>
<ul>
<li>数组会被认为是<code>readonly</code>的元组，而不是可变的数组。</li>
<li>字面量被视为字面量类型，而不是对应的基础类型。</li>
<li>对象上的属性被认为是只读的。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// Type: (number | string)[]   
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">arr</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>, <span style="color:#e6db74">&#39;&#39;</span>];  
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 类型被推断为readonly的元组，即: readonly [0, &#39;&#39;]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 即使是用let声明了typle，但const的优先级更高
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">typle</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>, <span style="color:#e6db74">&#39;&#39;</span>] <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">const</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// typle不能再被赋值，也不能修改其对应的数组元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Cannot assign to &#39;0&#39; because it is a read-only property.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">typle</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">12</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">classA</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// text的类型是字面量&#39;const&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">text</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;const&#39;</span> <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">const</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="literals-to-primitives">Literals to Primitives</h3>
<p>对于类型系统来说，<font color="#de7802">将字面值理解为特定的字面值，而不是将其扩大到对应的基础类型</font>，在某些情况是非常有用的。例如，与返回元组的函数类似，一个函数会产生一个特定的字面量类型而非一般的基础类型，这可能会很有用。这些函数还可以返回更具体的字面值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// Type: () =&gt; string  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">getName</span> <span style="color:#f92672">=</span> () <span style="color:#f92672">=&gt;</span> <span style="color:#e6db74">&#34;Maria Bamford&#34;</span>;  
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: () =&gt; &#34;Maria Bamford&#34;  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">getNameConst</span> <span style="color:#f92672">=</span> () <span style="color:#f92672">=&gt;</span> <span style="color:#e6db74">&#34;Maria Bamford&#34;</span> <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">const</span>;
</span></span></code></pre></div><p>让值的特定字段成为更具体的字面量类型也可能是有用的。许多流行的库都要求值的判别字段是一个特定的字面量，这样它们的代码类型就能更具体地对值进行推断：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Joke</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">quote</span>: <span style="color:#66d9ef">string</span>;  
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// style属性是字面量类型的联合
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">style</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;story&#34;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;one-liner&#34;</span>;  
</span></span><span style="display:flex;"><span>}  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">tellJoke</span>(<span style="color:#a6e22e">joke</span>: <span style="color:#66d9ef">Joke</span>) {  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">joke</span>.<span style="color:#a6e22e">style</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;one-liner&#34;</span>) {  
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">joke</span>.<span style="color:#a6e22e">quote</span>);  
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {  
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">joke</span>.<span style="color:#a6e22e">quote</span>.<span style="color:#a6e22e">split</span>(<span style="color:#e6db74">&#34;\n&#34;</span>));  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: { quote: string; style: &#34;one-liner&#34; }  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">narrowJoke</span> <span style="color:#f92672">=</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">quote</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;If you stay alive for no other reason do it for spite.&#34;</span>,  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">style</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;one-liner&#34;</span> <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">const</span>,  
</span></span><span style="display:flex;"><span>};  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">tellJoke</span>(<span style="color:#a6e22e">narrowJoke</span>); <span style="color:#75715e">// OK  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 下面的wideObject类型为{ quote: string; style: string }  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">wideObject</span> <span style="color:#f92672">=</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">quote</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Time flies when you are anxious!&#34;</span>,  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">style</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;one-liner&#34;</span>,  
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">tellJoke</span>(<span style="color:#a6e22e">wideObject</span>);
</span></span></code></pre></div><h3 id="read-only-objects">Read-Only Objects</h3>
<p>对象字面量（如用作变量初始值的对象字面量）通常会拓宽属性类型，这与<code>let</code>变量初始值的拓宽方式相同。字符串值（如 <code>&quot;apple&quot;</code>）变成了基本类型<code>string</code>，数组类型变成了可变数组而不是元组。如果这些值中的一部分或全部以后要用于需要其特定字面量类型的地方，这可能会带来不便。</p>
<p>断言值字面类型为<code>const</code>时，推断类型会尽可能具体。<font color="#de7802">所有成员属性都变成只读，字面量被视为自己的字面类型，而不是对应的基本类型，数组变成只读元组</font>。换句话说，对一个值字面量类型应用<code>const</code>断言会使该值字面类型不可变，并<font color="#de7802">递归地对其所有成员应用相同的<code>const</code>断言逻辑</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">describePreference</span>(<span style="color:#a6e22e">preference</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;maybe&#34;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;no&#34;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;yes&#34;</span>) {  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">switch</span> (<span style="color:#a6e22e">preference</span>) {  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;maybe&#34;</span><span style="color:#f92672">:</span>  
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;I suppose...&#34;</span>;  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;no&#34;</span><span style="color:#f92672">:</span>  
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;No thanks.&#34;</span>;  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;yes&#34;</span><span style="color:#f92672">:</span>  
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;Yes please!&#34;</span>;  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: { movie: string, standup: string }  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">preferencesMutable</span> <span style="color:#f92672">=</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">movie</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;maybe&#34;</span>,  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">standup</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;yes&#34;</span>,  
</span></span><span style="display:flex;"><span>};  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 严格类型检测，传入的实参类型为string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Argument of type &#39;string&#39; is not assignable to parameter of type &#39;&#34;maybe&#34; | &#34;no&#34; | &#34;yes&#34;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">describePreference</span>(<span style="color:#a6e22e">preferencesMutable</span>.<span style="color:#a6e22e">movie</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">preferencesMutable</span>.<span style="color:#a6e22e">movie</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;no&#34;</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: readonly { readonly movie: &#34;maybe&#34;, readonly standup: &#34;yes&#34; }  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">preferencesReadonly</span> <span style="color:#f92672">=</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">movie</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;maybe&#34;</span>,  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">standup</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;yes&#34;</span>,  
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">const</span>  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">describePreference</span>(<span style="color:#a6e22e">preferencesReadonly</span>.<span style="color:#a6e22e">movie</span>); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Cannot assign to &#39;movie&#39; because it is a read-only property.  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">preferencesReadonly</span>.<span style="color:#a6e22e">movie</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;no&#34;</span>;
</span></span></code></pre></div><p>需要注意的是，<font color="#de7802">类型断言只能暂时欺骗编译器，无法避免运行时错误</font>。因此，滥用类型断言可能会导致运行时错误，下面代码无编译错误，但会出现运行时错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Cat</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">run</span>()<span style="color:#f92672">:</span> <span style="color:#66d9ef">void</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Fish</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">swim</span>()<span style="color:#f92672">:</span> <span style="color:#66d9ef">void</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">isFish</span>(<span style="color:#a6e22e">animal</span>: <span style="color:#66d9ef">Cat</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">Fish</span>) {
</span></span><span style="display:flex;"><span>    (<span style="color:#a6e22e">animal</span> <span style="color:#66d9ef">as</span> <span style="color:#a6e22e">Fish</span>).<span style="color:#a6e22e">swim</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">cat</span>: <span style="color:#66d9ef">Cat</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Hello&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">run</span>()<span style="color:#f92672">:</span> <span style="color:#66d9ef">void</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">isFish</span>(<span style="color:#a6e22e">cat</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 出现运行时错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#a6e22e">animal</span>.<span style="color:#a6e22e">swim</span> <span style="color:#66d9ef">is</span> <span style="color:#a6e22e">not</span> <span style="color:#a6e22e">a</span> <span style="color:#66d9ef">function</span>
</span></span></code></pre></div><p>下面示例代码中，使用<code>instanceof</code>来判断变量是否为某个类的实例是合适的。但某些情况下，<code>ApiError</code>和<code>HttpError</code>不是一个类，而是接口类型。<font color="#de7802">接口是一个类型，并不是一个真正的值，它在编译结果中会被删除</font>，因此无法使用<code>instanceof</code>来做运行时判断。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ApiError</span> <span style="color:#66d9ef">extends</span> Error {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">code</span>: <span style="color:#66d9ef">number</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">HttpError</span> <span style="color:#66d9ef">extends</span> Error {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">statusCode</span>: <span style="color:#66d9ef">number</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">200</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">isApiError</span>(<span style="color:#a6e22e">error</span>: <span style="color:#66d9ef">Error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">error</span> <span style="color:#66d9ef">instanceof</span> <span style="color:#a6e22e">ApiError</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>此时只能使用类型断言：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">ApiError</span> <span style="color:#66d9ef">extends</span> Error {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">code</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">HttpError</span> <span style="color:#66d9ef">extends</span> Error {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">statusCode</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">isApiError</span>(<span style="color:#a6e22e">error</span>: <span style="color:#66d9ef">Error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (<span style="color:#a6e22e">error</span> <span style="color:#66d9ef">as</span> <span style="color:#a6e22e">ApiError</span>).<span style="color:#a6e22e">code</span> <span style="color:#f92672">===</span> <span style="color:#ae81ff">23</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="generics">Generics</h1>
<p>目前为止，所学到的所有类型语法都用于完全已知的类型。有时，一段代码<font color="#de7802">可能会根据不同的调用方式与各种不同类型协同工作</font>。我们需要一种方法来说明输入类型与函数返回类型之间的关系，<code>TypeScript</code>使用泛型捕捉类型之间的关系。</p>
<p>在<code>Typescript</code>中，函数等泛型构造可以声明任意数量的类型参数，泛型构造的每次使用都会确定这些类型。这些类型参数在泛型构造中表示类型，以表示构造的每个实例中都可能不同的某种类型。<span style="background:rgba(255, 183, 139, 0.55)">类型参数可以为泛型构造的每个实例提供不同的类型（称为类型参数），但在当前实例中将保持一致</span>。</p>
<p>按照惯例，类型参数通常使用单字母（如<code>T</code>和<code>U</code>）或<code>PascalCase</code>名称（如<code>Key</code>和<code>Value</code>）。可以使用<code>&lt;</code>和<code>&gt;</code>声明泛型，如<code>someFunction&lt;T&gt;</code>或<code>SomeInterface&lt;T&gt;</code>。</p>
<h2 id="generic-functions">Generic Functions</h2>
<p>要使函数具有泛型功能，<font color="#de7802">可以在参数圆括号之前，用一对尖括号声明类型参数名称</font>。接下来，该类型参数就可以在函数体的形参类型标注、或返回类型标注以及函数中使用。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">identity</span>&lt;<span style="color:#f92672">T</span>&gt;(<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">T</span>) {  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">input</span>;  
</span></span><span style="display:flex;"><span>}  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">numeric</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">identity</span>(<span style="color:#e6db74">&#34;me&#34;</span>); <span style="color:#75715e">// Type: &#34;me&#34;  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">stringy</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">identity</span>(<span style="color:#ae81ff">123</span>); <span style="color:#75715e">// Type: 123
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">stringy</span>, <span style="color:#a6e22e">numeric</span>) <span style="color:#75715e">// me 123
</span></span></span></code></pre></div><p>箭头函数也可以声明为泛型，<font color="#de7802">也是在形参圆括号前用尖括号封装类型参数</font>，下面定义的箭头泛型函数和上面的定义的普通泛型函数效果一样：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">identity</span> <span style="color:#f92672">=</span> &lt;<span style="color:#f92672">T</span>&gt;(<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">T</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">input</span>;  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">identity</span>(<span style="color:#ae81ff">12</span>)) <span style="color:#75715e">// 12
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">identity</span>(<span style="color:#e6db74">&#39;133&#39;</span>)) <span style="color:#75715e">// 133
</span></span></span></code></pre></div><p>但需要注意的是，在<code>.tsx</code>文件中泛型箭头语法有一些限制，因为它与<code>JSX</code>语法冲突。修改相关的配置可以支持<code>JSX</code>和<code>React</code>。</p>
<h3 id="explicit-generic-call-types">Explicit Generic Call Types</h3>
<p>多数情况下，在调用泛型函数时，能够根据函数的调用方式推断出类型实参。例如，在前面的<code>identity</code>函数中，类型检查器根据提供给它的实参来推断泛型函数的类型实参。</p>
<p>不幸的是，与类成员和变量类型一样，有时函数调用时没有足够的信息来告知编译器类型参数应解析成什么类型。如果一个泛型构造器被提供给另一个泛型构造器，而后者的类型参数未知，则可能会发生这种情况。<span style="background:#f8d9c3">对于无法推断的类型参数，将被认为是<code>unknown</code>类型。</span></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">logWrapper</span>&lt;<span style="color:#f92672">Input</span>&gt;(<span style="color:#a6e22e">callback</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">Input</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">void</span>) {  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">Input</span>) <span style="color:#f92672">=&gt;</span> {  
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Input:&#34;</span>, <span style="color:#a6e22e">input</span>);  
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">callback</span>(<span style="color:#a6e22e">input</span>);  
</span></span><span style="display:flex;"><span>    };  
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 正常
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">test</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">logWrapper</span>((<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">string</span>) <span style="color:#f92672">=&gt;</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">input</span>.<span style="color:#a6e22e">length</span>);  
</span></span><span style="display:flex;"><span>})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">test</span>(<span style="color:#e6db74">&#39;1233&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 上面test的执行后打印的是Input: 1233 4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 异常：&#39;input&#39; is of type &#39;unknown&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">logWrapper</span>((<span style="color:#a6e22e">input</span>) <span style="color:#f92672">=&gt;</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">input</span>.<span style="color:#a6e22e">length</span>);  
</span></span><span style="display:flex;"><span>})
</span></span></code></pre></div><p>为了避免使用默认的<code>unknown</code>，泛型函数调用时<font color="#de7802">可能需要显式标注泛型的类型实参</font>。编译器将对泛型函数调用执行类型检查，以确保显式标注的类型参数是正确的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">logWrapper</span>&lt;<span style="color:#f92672">Input</span>&gt;(<span style="color:#a6e22e">callback</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">Input</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">void</span>) {  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">Input</span>) <span style="color:#f92672">=&gt;</span> {  
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Input:&#34;</span>, <span style="color:#a6e22e">input</span>);  
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">callback</span>(<span style="color:#a6e22e">input</span>);  
</span></span><span style="display:flex;"><span>    };  
</span></span><span style="display:flex;"><span>}  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">test</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">logWrapper</span>&lt;<span style="color:#f92672">string</span>&gt;((<span style="color:#a6e22e">input</span>) <span style="color:#f92672">=&gt;</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">input</span>.<span style="color:#a6e22e">length</span>);  
</span></span><span style="display:flex;"><span>});
</span></span></code></pre></div><h3 id="multiple-function-type-parameters">Multiple Function Type Parameters</h3>
<p>泛型函数<font color="#de7802">可以定义任意数量的类型参数，参数之间用逗号隔开</font>。泛型函数每次调用时都可以为每个类型参数确定相应的实际类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">makeTuple</span>&lt;<span style="color:#f92672">First</span><span style="color:#960050;background-color:#1e0010">,</span> <span style="color:#a6e22e">Second</span>&gt;(<span style="color:#a6e22e">first</span>: <span style="color:#66d9ef">First</span>, <span style="color:#a6e22e">second</span>: <span style="color:#66d9ef">Second</span>) {  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> [<span style="color:#a6e22e">first</span>, <span style="color:#a6e22e">second</span>] <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">const</span>;  
</span></span><span style="display:flex;"><span>}  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 因为使用了const，所以let tuple: readonly [boolean, string]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">tuple</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">makeTuple</span>(<span style="color:#66d9ef">true</span>, <span style="color:#e6db74">&#34;abc&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 下面修改tuple会出现编译错误：Cannot assign to &#39;0&#39; because it is a read-only property.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">tuple</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">makePair</span>&lt;<span style="color:#f92672">Key</span><span style="color:#960050;background-color:#1e0010">,</span> <span style="color:#a6e22e">Value</span>&gt;(<span style="color:#a6e22e">key</span>: <span style="color:#66d9ef">Key</span>, <span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">Value</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> {<span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">value</span>};
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">makePair</span>(<span style="color:#ae81ff">123</span>, <span style="color:#e6db74">&#39;123&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">makePair</span>&lt;<span style="color:#f92672">string</span><span style="color:#960050;background-color:#1e0010">,</span> <span style="color:#a6e22e">number</span>&gt;(<span style="color:#e6db74">&#34;abc&#34;</span>, <span style="color:#ae81ff">123</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">makePair</span><span style="color:#f92672">&lt;</span><span style="color:#e6db74">&#34;abc&#34;</span>, <span style="color:#ae81ff">123</span><span style="color:#f92672">&gt;</span>(<span style="color:#e6db74">&#34;abc&#34;</span>, <span style="color:#ae81ff">123</span>);
</span></span></code></pre></div><p>在泛型函数声明时，<font color="#de7802">尽量不要超过两个类型参数</font>。与运行时函数参数一样，使用的类型参数越多，代码就越难阅读和理解。</p>
<h2 id="generic-interfaces">Generic Interfaces</h2>
<p>接口也可以声明为泛型，它们遵循与函数类似的泛型规则：可以在接口名称后面的<code>&lt;</code>和<code>&gt;</code>之间声明任意数量的类型参数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Box</span>&lt;<span style="color:#f92672">T</span>&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">inside</span>: <span style="color:#66d9ef">T</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 使用泛型接口类型时，需要显式标注类型实参，否则会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误： Generic type &#39;Box&lt;T&gt;&#39; requires 1 type argument(s)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">d</span>: <span style="color:#66d9ef">Box</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">inside</span>: <span style="color:#66d9ef">123</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 正常
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">stringyBox</span>: <span style="color:#66d9ef">Box</span>&lt;<span style="color:#f92672">string</span>&gt; <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">inside</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;abc&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">numberBox</span>: <span style="color:#66d9ef">Box</span>&lt;<span style="color:#f92672">number</span>&gt; <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">inside</span>: <span style="color:#66d9ef">123</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 声明的参数类型和实际使用的类型不同时会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Type &#39;boolean&#39; is not assignable to type &#39;number&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">incorrectBox</span>: <span style="color:#66d9ef">Box</span>&lt;<span style="color:#f92672">number</span>&gt; <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">inside</span>: <span style="color:#66d9ef">false</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>实际上，内置的<code>Array</code>就是一个泛型接口，它使用类型参数<code>T</code>来表示存储在数组里的元素，它的<code>pop</code>和<code>push</code>方法大抵如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> Array&lt;<span style="color:#f92672">T</span>&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pop</span>()<span style="color:#f92672">:</span> <span style="color:#a6e22e">T</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">push</span>(...<span style="color:#a6e22e">items</span>: <span style="color:#66d9ef">T</span>[])<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h3 id="inferred-generic-interface-types">Inferred Generic Interface Types</h3>
<p>如同泛型函数，泛型接口的类型实参也可以从使用中推断出来。<code>TypeScript</code>会尽力从提供给标注为泛型接口类型位置的值推断出泛型接口对应的类型实参：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">LinkedNode</span>&lt;<span style="color:#f92672">Value</span>&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">next?</span>: <span style="color:#66d9ef">LinkedNode</span>&lt;<span style="color:#f92672">Value</span>&gt;;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">Value</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getLast</span>&lt;<span style="color:#f92672">Value</span>&gt;(<span style="color:#a6e22e">node</span>: <span style="color:#66d9ef">LinkedNode</span>&lt;<span style="color:#f92672">Value</span>&gt;)<span style="color:#f92672">:</span> <span style="color:#a6e22e">Value</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">next</span> <span style="color:#f92672">?</span> <span style="color:#a6e22e">getLast</span>(<span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">next</span>) <span style="color:#f92672">:</span> <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">value</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Inferred Value type argument: Date
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">lastDate</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">getLast</span>({
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">new</span> Date(<span style="color:#e6db74">&#34;09-13-1993&#34;</span>),
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Inferred Value type argument: string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">lastFruit</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">getLast</span>({
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">next</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">value</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;banana&#34;</span>,
</span></span><span style="display:flex;"><span>    }, <span style="color:#a6e22e">value</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;apple&#34;</span>,
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Inferred Value type argument: number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">lastMismatch</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">getLast</span>({
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">next</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">123</span>
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 类型不一致，会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// Error: type &#39;boolean&#39; is not assignable to type &#39;number&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">false</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>请注意，<span style="background:#f8d9c3">如果接口声明时是泛型的，则任何引用该接口类型的地方都必须提供相应的类型参数，</span>，否则会出现编译错误。下面示例代码中，使用泛型类型标注时没有提供类型实参，所以会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">CrateLike</span>&lt;<span style="color:#f92672">T</span>&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">contents</span>: <span style="color:#66d9ef">T</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Generic type &#39;CrateLike&lt;T&gt;&#39; requires 1 type argument(s).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">missingGeneric</span>: <span style="color:#66d9ef">CrateLike</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">inside</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;??&#34;</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 类型标注指定了类型实参，所以不会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">missingGeneric1</span>: <span style="color:#66d9ef">CrateLike</span>&lt;<span style="color:#f92672">string</span>&gt; <span style="color:#f92672">=</span> {<span style="color:#a6e22e">contents</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;??&#34;</span>};
</span></span></code></pre></div><h2 id="generic-classes">Generic Classes</h2>
<p>如同接口，类也支持泛型，并且支持任意数量的类型参数。创建的每一个类的实例可能使用不同的类型实参。下面定义的泛型类声明了两个类型参数<code>key</code>和<code>value</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Secret</span>&lt;<span style="color:#f92672">Key</span><span style="color:#960050;background-color:#1e0010">,</span> <span style="color:#a6e22e">Value</span>&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">key</span>: <span style="color:#66d9ef">Key</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">Value</span>;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>(<span style="color:#a6e22e">key</span>: <span style="color:#66d9ef">Key</span>, <span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">Value</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">key</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">key</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">value</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">value</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">getValue</span>(<span style="color:#a6e22e">key</span>: <span style="color:#66d9ef">Key</span>)<span style="color:#f92672">:</span> <span style="color:#a6e22e">Value</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">key</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">key</span> <span style="color:#f92672">?</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">value</span> : <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">storage</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Secret</span>(<span style="color:#ae81ff">12345</span>, <span style="color:#e6db74">&#34;luggage&#34;</span>); <span style="color:#75715e">// Type: Secret&lt;number, string&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">value1</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">storage</span>.<span style="color:#a6e22e">getValue</span>(<span style="color:#ae81ff">1987</span>);  <span style="color:#75715e">// Type: string | undefined
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">value2</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">storage</span>.<span style="color:#a6e22e">getValue</span>(<span style="color:#ae81ff">12345</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">value1</span>, <span style="color:#a6e22e">value2</span>) <span style="color:#75715e">// undefined luggage
</span></span></span></code></pre></div><h3 id="explicit-generic-class-types">Explicit Generic Class Types</h3>
<p>实例化泛型类和调用泛型函数类似，如果类型参数可以从构造器中的参数中推断出来，就可以省略显式的类型实参标注，但如果省略了类型实参，编译器却推断不出来类型实参，则使用默认的<code>unknown</code>。例如，上面示例代码使用了<code>new Secret(12345, &quot;luggage&quot;)</code>，可以推断出类型实参为<code>number</code>和<code>string</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">storage</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Secret</span>(<span style="color:#ae81ff">12345</span>, <span style="color:#e6db74">&#34;luggage&#34;</span>); <span style="color:#75715e">// Type: Secret&lt;number, string&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">storage</span>.<span style="color:#a6e22e">getValue</span>(<span style="color:#ae81ff">1987</span>); <span style="color:#75715e">// Type: string | undefined
</span></span></span></code></pre></div><p>下面定义了泛型类<code>CurriedCallback</code>，类的构造器中接受一个泛型函数作为入参，如果泛型函数有已知的类型（例如来自显式类型参数类型标注），那么类实例中的<code>input</code>类型参数就可以推断出来。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CurriedCallback</span>&lt;<span style="color:#f92672">Input</span>&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#a6e22e">callback</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">Input</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">void</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>(<span style="color:#a6e22e">callback</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">Input</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">void</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#960050;background-color:#1e0010">#</span><span style="color:#a6e22e">callback</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">Input</span>) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Input:&#34;</span>, <span style="color:#a6e22e">input</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">callback</span>(<span style="color:#a6e22e">input</span>);
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">call</span>(<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">Input</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#960050;background-color:#1e0010">#</span><span style="color:#a6e22e">callback</span>(<span style="color:#a6e22e">input</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: CurriedCallback&lt;string&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">new</span> <span style="color:#a6e22e">CurriedCallback</span>((<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">string</span>) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">input</span>.<span style="color:#a6e22e">length</span>);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 显式声明类型实参，构造器的入参就可以省略类型标注
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">new</span> <span style="color:#a6e22e">CurriedCallback</span>&lt;<span style="color:#f92672">string</span>&gt;((<span style="color:#a6e22e">input</span>) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">input</span>.<span style="color:#a6e22e">length</span>);
</span></span><span style="display:flex;"><span>})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 既不能从构造器中推断出类型，也未显式标注类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 所以会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: CurriedCallback&lt;unknown&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">new</span> <span style="color:#a6e22e">CurriedCallback</span>((<span style="color:#a6e22e">input</span>) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 编译错误：&#39;input&#39; is of type &#39;unknown&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// unknown需要类型窄化才可以访问属性
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">input</span>.<span style="color:#a6e22e">length</span>);
</span></span><span style="display:flex;"><span>})
</span></span></code></pre></div><h3 id="extending-generic-classes">Extending Generic Classes</h3>
<p>泛型类可以作为普通类的基类。但需要注意的是，<font color="#de7802">编译器不会尝试从使用中推断基类的类型参数，任何没有默认值的类型参数都需要使用显式类型标注。</font></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Quote</span>&lt;<span style="color:#f92672">T</span>&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">lines</span>: <span style="color:#66d9ef">T</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>(<span style="color:#a6e22e">lines</span>: <span style="color:#66d9ef">T</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">lines</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">lines</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SpokenQuote</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Quote</span>&lt;<span style="color:#f92672">string</span><span style="color:#960050;background-color:#1e0010">[]</span>&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">speak() {</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">lines</span>.<span style="color:#a6e22e">join</span>(<span style="color:#e6db74">&#34;\n&#34;</span>));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Quote</span>(<span style="color:#e6db74">&#34;The only real failure is the failure to try.&#34;</span>).<span style="color:#a6e22e">lines</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Quote</span>([<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">23</span>, <span style="color:#ae81ff">42</span>]).<span style="color:#a6e22e">lines</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">new</span> <span style="color:#a6e22e">SpokenQuote</span>([<span style="color:#e6db74">&#34;Greed is so destructive.&#34;</span>, <span style="color:#e6db74">&#34;It destroys everything&#34;</span>,]).<span style="color:#a6e22e">lines</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 实参类型不对，会出现编译错误：Type &#39;number&#39; is not assignable to type &#39;string&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">new</span> <span style="color:#a6e22e">SpokenQuote</span>([<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">23</span>, <span style="color:#ae81ff">42</span>]);
</span></span></code></pre></div><p>泛型派生类也可以将自己的类型参数传递给基类。需要注意的是，<font color="#de7802">派生泛型类中的类型参数名不必与基类泛型声明时使用的名称一致</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AttributedQuote</span>&lt;<span style="color:#f92672">Value</span>&gt; <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Quote</span>&lt;<span style="color:#f92672">Value</span>&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">speaker</span>: <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>(<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">Value</span>, <span style="color:#a6e22e">speaker</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">super</span>(<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">speaker</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">speaker</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">AttributedQuote</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;The road to success is always under construction.&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;Lily Tomlin&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">value</span>.<span style="color:#a6e22e">speaker</span>);
</span></span></code></pre></div><h3 id="implementing-generic-interfaces">Implementing Generic Interfaces</h3>
<p>泛型类也可以通过提供必要的类型参数来实现泛型接口。这与<code>extends</code>泛型基类的原理类似：<font color="#de7802">基接口上的任何类型参数都必须由实现类来声明</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">ActingCredit</span>&lt;<span style="color:#f92672">Role</span>&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">role</span>: <span style="color:#66d9ef">Role</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MoviePart</span> <span style="color:#66d9ef">implements</span> <span style="color:#a6e22e">ActingCredit</span>&lt;<span style="color:#f92672">string</span>&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">role</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">speaking</span>: <span style="color:#66d9ef">boolean</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>(<span style="color:#a6e22e">role</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">speaking</span>: <span style="color:#66d9ef">boolean</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">role</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">role</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">speaking</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">speaking</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">part</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">MoviePart</span>(<span style="color:#e6db74">&#34;Miranda Priestly&#34;</span>, <span style="color:#66d9ef">true</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">part</span>.<span style="color:#a6e22e">role</span>);
</span></span></code></pre></div><h3 id="method-generics">Method Generics</h3>
<p>类方法可以<font color="#de7802">在类实例之外声明自己的泛型方法</font>。对类中泛型方法的每次调用，其每个类型参数都可能有不同的类型参数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CreatePairFactory</span>&lt;<span style="color:#f92672">Key</span>&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">key</span>: <span style="color:#66d9ef">Key</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>(<span style="color:#a6e22e">key</span>: <span style="color:#66d9ef">Key</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">key</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">key</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 类中泛型方法中的类型参数和泛型类定义时使用的类型参数不同
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">createPair</span>&lt;<span style="color:#f92672">Value</span>&gt;(<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">Value</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> {<span style="color:#a6e22e">key</span>: <span style="color:#66d9ef">this.key</span>, <span style="color:#a6e22e">value</span>};
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">factory</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">CreatePairFactory</span>(<span style="color:#e6db74">&#34;role&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">numberPair</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">factory</span>.<span style="color:#a6e22e">createPair</span>(<span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">stringPair</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">factory</span>.<span style="color:#a6e22e">createPair</span>(<span style="color:#e6db74">&#34;Sophie&#34;</span>);
</span></span></code></pre></div><h3 id="static-class-generics">Static Class Generics</h3>
<p>类的静态成员独立于实例成员，与类的任何特定实例无关。它们无法访问任何类实例或任何类实例特有的类型信息。因此，虽然静态类方法可以声明自己的类型参数，但**<font color="#de7802">它们不能访问泛型类声明时的任何类型参数</font>**。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BothLogger</span>&lt;<span style="color:#f92672">OnInstance</span>&gt; {
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">instanceLog</span>(<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">OnInstance</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">value</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#a6e22e">staticLog</span>&lt;<span style="color:#f92672">OnStatic</span>&gt;(<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">OnStatic</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 静态方法不能使用泛型类的类型参数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">fromInstance</span>: <span style="color:#66d9ef">OnInstance</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">value</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 出现编译错误： Static members cannot reference class type parameters.
</span></span></span></code></pre></div><h2 id="generic-type-aliases">Generic Type Aliases</h2>
<p>类型别名也支持泛型，每一个泛型别名类型可以有任意数量的类型参数。泛型别名通常与函数一起使用，用于标注泛型函数的类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Nullish</span>&lt;<span style="color:#f92672">T</span>&gt; <span style="color:#f92672">=</span> <span style="color:#a6e22e">T</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">CreatesValue</span>&lt;<span style="color:#f92672">Input</span><span style="color:#960050;background-color:#1e0010">,</span> <span style="color:#a6e22e">Output</span>&gt; <span style="color:#f92672">=</span> (<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">Input</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">Output</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">funTest</span>: <span style="color:#66d9ef">CreatesValue</span>&lt;<span style="color:#f92672">string</span><span style="color:#960050;background-color:#1e0010">,</span> <span style="color:#a6e22e">number</span>&gt; <span style="color:#f92672">=</span> (<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">string</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">input</span>.<span style="color:#a6e22e">length</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">funTest</span>(<span style="color:#e6db74">&#39;123333&#39;</span>));
</span></span></code></pre></div><h3 id="generic-discriminated-unions">Generic Discriminated Unions</h3>
<p>在<code>TypeScript</code>中，判别联合能优雅地将<code>JavaScript</code>常见模式与<code>TypeScript</code>的类型窄化完美地结合在一起。我最喜欢的判别联合用法是添加一个类型参数，以创建一个泛型的<code>Result</code>类型，它可以代表成功的数据结果，也可以代表失败的错误结果。</p>
<p>该<code>Result</code>泛型有一个<code>succeeded</code>判别式，必须使用该判别式才能确定结果是成功还是失败。这意味着任何返回<code>Result</code>的操作都可以表示错误或数据<code>result</code>，并确保使用者需要检查结果是否成功：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Result</span>&lt;<span style="color:#f92672">Data</span>&gt; <span style="color:#f92672">=</span> <span style="color:#a6e22e">FailureResult</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">SuccessfulResult</span>&lt;<span style="color:#f92672">Data</span>&gt;;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">FailureResult</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">error</span>: <span style="color:#66d9ef">Error</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">succeeded</span>: <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">SuccessfulResult</span>&lt;<span style="color:#f92672">Data</span>&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">data</span>: <span style="color:#66d9ef">Data</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">succeeded</span>: <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">handleResult</span>(<span style="color:#a6e22e">result</span>: <span style="color:#66d9ef">Result</span>&lt;<span style="color:#f92672">string</span>&gt;) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">succeeded</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 正常
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">data</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`We did it! </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">data</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">error</span>(<span style="color:#e6db74">`Awww... </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">error</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 没有类型窄化会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// Property &#39;data&#39; does not exist on type &#39;Result&lt;string&gt;&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">data</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>将泛型和<code>discriminated types</code>结合在一起，能为像<code>Result</code>这样的可重用类型提供绝佳的定义方式。</p>
<h2 id="generic-modifiers">Generic Modifiers</h2>
<p><code>TypeScript</code>包含允许修改泛型参数行为的语法，下面介绍泛型默认类型参数和类型参数约束。</p>
<h3 id="generic-defaults">Generic Defaults</h3>
<p>到目前为止，如果在类型标注中使用泛型，或者将其作为类的扩展或实现的基类，那么它必须为每个类型参数提供一个类型实参。可以在类型参数的声明后加上一个<code>=</code>符号和一个默认类型，避免显式地提供类型参数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Quote</span>&lt;<span style="color:#f92672">T</span> <span style="color:#960050;background-color:#1e0010">=</span> <span style="color:#a6e22e">string</span>&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">T</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">explicit</span>: <span style="color:#66d9ef">Quote</span>&lt;<span style="color:#f92672">number</span>&gt; <span style="color:#f92672">=</span> {<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">123</span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">implicit</span>: <span style="color:#66d9ef">Quote</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">value</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Be yourself. The world worships the original.&#34;</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 不显式标注类型，则表示使用默认的类型参数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Type &#39;number&#39; is not assignable to type &#39;string&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">mismatch</span>: <span style="color:#66d9ef">Quote</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">123</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">KeyValuePair</span>&lt;<span style="color:#f92672">Key</span><span style="color:#960050;background-color:#1e0010">,</span> <span style="color:#a6e22e">Value </span><span style="color:#f92672">=</span> <span style="color:#a6e22e">Key</span>&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">key</span>: <span style="color:#66d9ef">Key</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">Value</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">allExplicit</span>: <span style="color:#66d9ef">KeyValuePair</span>&lt;<span style="color:#f92672">string</span><span style="color:#960050;background-color:#1e0010">,</span> <span style="color:#a6e22e">number</span>&gt; <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">key</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;rating&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">10</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">oneDefaulting</span>: <span style="color:#66d9ef">KeyValuePair</span>&lt;<span style="color:#f92672">string</span>&gt; <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">key</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;rating&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">value</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;ten&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 只提供了第一个类型实参，第二个默认和第一个相同
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误： Generic type &#39;KeyValuePair&lt;Key, Value&gt;&#39; requires between 1 and 2 type arguments.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">firstMissing</span>: <span style="color:#66d9ef">KeyValuePair</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">key</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;rating&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">10</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>需要注意的是，<strong><font color="#de7802">所有缺省类型参数都必须在类型参数列表的最后</font>，这与可选参数类似</strong>。也就是说，没有默认值的类型参数不能排在有默认值的类型参数之后。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 正常
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">inTheEnd</span>&lt;<span style="color:#f92672">First</span><span style="color:#960050;background-color:#1e0010">,</span> <span style="color:#a6e22e">Second</span><span style="color:#960050;background-color:#1e0010">,</span> <span style="color:#a6e22e">Third </span><span style="color:#f92672">=</span> <span style="color:#a6e22e">number</span><span style="color:#960050;background-color:#1e0010">,</span> <span style="color:#a6e22e">Fourth </span><span style="color:#f92672">=</span> <span style="color:#a6e22e">string</span>&gt;() {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 有默认值的类型参数放在了中间，会出现编译错误:Required type parameters may not follow optional type parameters.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">inTheMiddle</span>&lt;<span style="color:#f92672">First</span><span style="color:#960050;background-color:#1e0010">,</span> <span style="color:#a6e22e">Second </span><span style="color:#f92672">=</span> <span style="color:#a6e22e">boolean</span><span style="color:#960050;background-color:#1e0010">,</span> <span style="color:#a6e22e">Third </span><span style="color:#f92672">=</span> <span style="color:#a6e22e">number</span><span style="color:#960050;background-color:#1e0010">,</span> <span style="color:#a6e22e">Fourth</span>&gt;() {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h2 id="constrained-generic-types">Constrained Generic Types</h2>
<p>默认情况下，泛型的实参类型可以是任何类型：类、接口、基本类型、联合等。但是，有些函数只能用于有限的类型集。在泛型中，允许一个类型参数声明自己需要<code>extends</code>另一个类型，这就是类型约束。泛型类型约束的语法是在类型参数名称后加上<code>extends</code>关键字，然后再加上要约束它的类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">WithLength</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">length</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">logWithLength</span>&lt;<span style="color:#f92672">T</span> <span style="color:#a6e22e">extends</span> <span style="color:#a6e22e">WithLength</span>&gt;(<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">T</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Length: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">input</span>.<span style="color:#a6e22e">length</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">input</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">logWithLength</span>({<span style="color:#a6e22e">length</span>: <span style="color:#66d9ef">123</span>}) <span style="color:#75715e">// Length：123
</span></span></span></code></pre></div><h3 id="keyof-and-constrained-type-parameters">keyof and Constrained Type Parameters</h3>
<p>关键词<code>keyof</code>也可以用于泛型中的类型约束。将<code>extends</code>和<code>keyof</code>一起使用，可以将<code>key</code>限定在某个类型参数的所有<code>key</code>之内。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#66d9ef">get</span>&lt;<span style="color:#f92672">T</span><span style="color:#960050;background-color:#1e0010">,</span> <span style="color:#a6e22e">Key</span> <span style="color:#a6e22e">extends</span> <span style="color:#a6e22e">keyof</span> <span style="color:#a6e22e">T</span>&gt;(<span style="color:#a6e22e">container</span>: <span style="color:#66d9ef">T</span>, <span style="color:#a6e22e">key</span>: <span style="color:#66d9ef">Key</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">container</span>[<span style="color:#a6e22e">key</span>];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">roles</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">favorite</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Fargo&#34;</span>, <span style="color:#a6e22e">others</span><span style="color:#f92672">:</span> [<span style="color:#e6db74">&#34;Almost Famous&#34;</span>, <span style="color:#e6db74">&#34;Burn After Reading&#34;</span>, <span style="color:#e6db74">&#34;Nomadland&#34;</span>],};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">favorite</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">get</span>(<span style="color:#a6e22e">roles</span>, <span style="color:#e6db74">&#34;favorite&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">others</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">get</span>(<span style="color:#a6e22e">roles</span>, <span style="color:#e6db74">&#34;others&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Argument of type &#39;&#34;extras&#34;&#39; is not assignable to parameter of type &#39;&#34;favorite&#34; | &#34;others&#34;&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">missing</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">get</span>(<span style="color:#a6e22e">roles</span>, <span style="color:#e6db74">&#34;extras&#34;</span>);
</span></span></code></pre></div><h2 id="promises">Promises</h2>
<p><code>JavaScript</code>中的<code>Promise</code>表示<font color="#de7802">仍在等待处理的事情</font>，例如网络请求。每个<code>Promise</code>都提供了注册回调的方法，以防待执行操作<code>resolve</code>（成功完成）或 <code>reject</code>（抛出异常）。</p>
<p><code>Promise</code>能够在任意值类型上表示类似地操作，这与<code>TypeScript</code>泛型非常契合。在<code>TypeScript</code>类型系统中，<code>Promises</code>使用<code>Promise</code>类表示，该类有一个类型参数，代表最终解析的值。</p>
<h3 id="creating-promises">Creating Promises</h3>
<p><code>Promise</code>类的构造器中只有单个参数，这个参数的类型取决于泛型<code>Promise</code>类中声明的类型参数，<code>Promise</code>类的简化版本大致如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">PromiseLike</span>&lt;<span style="color:#f92672">Value</span>&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>(<span style="color:#a6e22e">executor</span><span style="color:#f92672">:</span> (
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">resolve</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">Value</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">void</span>,
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">reject</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">reason</span>: <span style="color:#66d9ef">unknown</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">void</span>,
</span></span><span style="display:flex;"><span>                ) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">void</span>,
</span></span><span style="display:flex;"><span>    ) { 
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">/* ... */</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面的构造函数中，需要传入的是单个函数，该函数有两个入参，返回类型为<code>void</code>，每个入参又是一个函数。一般来说，要创建一个最终要与值解析的<code>Promise</code>，就必须明确声明<code>Promise</code>的类型参数。</p>
<p>通常需要显式声明泛型类<code>Promise</code>的类型实参，如果没有显式地标注类型实参，编译器则认为类型实参为<code>unknown</code>。向<code>Promise</code>构造函数明确提供类型实参，编译器会解析<code>Promise</code>实例的类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">resolvesUnknown</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Promise</span>((<span style="color:#a6e22e">resolve</span>) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">setTimeout</span>(() <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">resolve</span>(<span style="color:#e6db74">&#34;Done!&#34;</span>), <span style="color:#ae81ff">1000</span>);
</span></span><span style="display:flex;"><span>})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: Promise&lt;string&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">resolvesString</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Promise</span>&lt;<span style="color:#f92672">string</span>&gt;((<span style="color:#a6e22e">resolve</span>) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">setTimeout</span>(() <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">resolve</span>(<span style="color:#e6db74">&#34;Done!&#34;</span>), <span style="color:#ae81ff">1000</span>);
</span></span><span style="display:flex;"><span>});
</span></span></code></pre></div><p><code>Promise</code>的泛型方法<code>.then</code>方法引入了一个新的类型参数，代表<code>Promise</code>返回的<code>resolve</code>值。下面示例中，创建了一个<code>textEventually</code>的<code>Promise</code>，等待1秒后，<code>resolve</code>了一个<code>string</code>类型的值，接着还创建了一个<code>lengthEventually</code>，再等一秒<code>resolve</code>出<code>number</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// Type: Promise&lt;string&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">textEventually</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Promise</span>&lt;<span style="color:#f92672">string</span>&gt;((<span style="color:#a6e22e">resolve</span>) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">setTimeout</span>(() <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">resolve</span>(<span style="color:#e6db74">&#34;Done!&#34;</span>), <span style="color:#ae81ff">1000</span>);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: Promise&lt;number&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">lengthEventually</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">textEventually</span>.<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">text</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">text</span>.<span style="color:#a6e22e">length</span>)
</span></span></code></pre></div><h3 id="async-functions">Async Functions</h3>
<p>在<code>JavaScript</code>中<span style="background:#f8d9c3">任何以<code>async</code>关键字声明的函数都返回一个<code>Promise</code></span>。如果在<code>async</code>函数中返回的值不是<code>Thenable</code>的（一个对象使用<code>.then</code>方法，几乎总是一个<code>Promise</code>），<font color="#de7802">返回值会被封装在一个<code>Promise</code>中，就像调用了<code>Promise.resolve</code>一样</font>。<code>TypeScript</code>可以识别这一点，并会推断<code>async</code>函数的返回类型始终是<code>Promise</code>的。</p>
<p>下面示例代码中，函数<code>lengthAfterSecond</code>返回一个<code>Promise&lt;number&gt;</code>。因为<code>lengthImmediately</code>标记为<code>asyc</code>的，因此它的返回类型也被推为<code>Promise&lt;number&gt;</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">lengthAfterSecond</span>(<span style="color:#a6e22e">text</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">await</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Promise</span>((<span style="color:#a6e22e">resolve</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">setTimeout</span>(<span style="color:#a6e22e">resolve</span>, <span style="color:#ae81ff">1000</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">text</span>.<span style="color:#a6e22e">length</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: (text: string) =&gt; Promise&lt;number&gt; 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">lengthImmediately</span>(<span style="color:#a6e22e">text</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">text</span>.<span style="color:#a6e22e">length</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>因此，在<code>async</code>函数上手动声明的任何返回类型都必须是<code>Promise</code>类型，即使在函数的实现中没有明确提及任何<code>Promise</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">givesPromiseForString</span>()<span style="color:#f92672">:</span> <span style="color:#a6e22e">Promise</span>&lt;<span style="color:#f92672">string</span>&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;Done!&#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 函数声明时使用了async但返回类型的标注不是promise，会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">givesString</span>()<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ~~~~~~ // Error: The return type of an async function // or method must be the global Promise&lt;T&gt; type.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;Done!&#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="using-generics-right">Using Generics Right</h2>
<p>如前面的<code>Promise&lt;Value&gt;</code>实现一样，虽然泛型可为我们在代码中描述类型提供很大的灵活性，但它们也会很快变得相当复杂。刚接触<code>TypeScript</code>时可能经常会经历一个过度使用泛型的阶段，以至于代码读起来令人困惑，使用起来过于复杂。<code>TypeScript</code>的最佳实践通常是在必要时才使用泛型，并明确泛型的用途。</p>
<h3 id="the-golden-rule-of-generics">The Golden Rule of Generics</h3>
<p>有一个<font color="#de7802">快速测试方法可以帮助确定函数是否需要类型参数，那就是类型参数至少要使用两次</font>。泛型描述的是类型之间的关系，如果一个泛型类型参数只出现在一个地方，它就不可能定义多个类型之间的关系。</p>
<p>在泛型函数中，每个类型参数都应该用于一个形参，还至少用于一个其它参数和/或函数的返回类型。下面示例中，泛型函数<code>logInput</code>只使用了<code>Input</code>类型形参一次：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">logInput</span>&lt;<span style="color:#f92672">Input</span> <span style="color:#a6e22e">extends</span> <span style="color:#a6e22e">string</span>&gt;(<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">Input</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Hi!&#34;</span>, <span style="color:#a6e22e">input</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在函数体中，函数logInput你到类型参数后没有做任何操作，例如返回或声明更多参数。因此，声明Input类型参数的用处不大。可以重写logInput，不需要声明为泛型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">logInput</span>(<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Hi!&#34;</span>, <span style="color:#a6e22e">input</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="declaration-files">Declaration Files</h1>
<p><code>TypeScript</code><font color="#de7802">允许将类型声明与其实现分开</font>。类型声明通常放在以<code>.d.ts</code>扩展名结尾的文件中，称为声明文件。声明文件通常放在项目中，随项目编译的<code>npm</code>包一起构建和发布，或作为独立的<code>typings</code>包共享。</p>
<p><code>.d.ts</code>文件的工作原理与<code>.ts</code>文件类似，<span style="background:#f8d9c3">但有一个明显的限制，不允许包含运行时代码</span>。<code>.d.ts</code>文件只包含对可用运行时值、接口、模块和一般类型的描述。<span style="background:#f8d9c3">它们不能包含任何可编译为<code>JavaScript</code>的运行时代码</span>。可以像导入其它<code>TypeScript</code>源文件一样导入声明文件。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// types.d.ts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Character</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">catchphrase?</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// index.ts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">import</span> {<span style="color:#a6e22e">Character</span>} <span style="color:#66d9ef">from</span> <span style="color:#e6db74">&#34;./type&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">character</span>: <span style="color:#66d9ef">Character</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">catchphrase</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Yee-haw!&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Sandy Cheeks&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>声明文件会创建所谓的<code>ambient context</code>，表示在代码中只能声明类型而不能声明值的区域。接下来主要介绍声明文件及其中最常用的类型声明形式。</p>
<h2 id="declaring-runtime-values">Declaring Runtime Values</h2>
<p>虽然定义文件不能创建函数或变量等运行时值，但它们可以使用<code>declare</code>关键字声明这些构造的存在。这样做可以告诉类型系统，某些外部影响（如网页中的<code>&lt;script&gt;</code>标记）已经创建了具有特定类型的该名称的值。也就是说<code>declare</code>关键字用来告诉编译器，某个类型或值是存在的，可以在当前文件中使用。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 合法声明
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">declare</span> <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">declared</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 不合法声明，会出现编译错误，因为不能包括可执行的代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">declare</span> <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">initializer</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Wanda&#34;</span>;
</span></span></code></pre></div><p>函数和类的声明也与普通的变量相似，但在声明时不能有函数体或方法体，即不能有相关实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 正常，因为没有函数体
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">declare</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">canGrantWish</span>(<span style="color:#a6e22e">wish</span>: <span style="color:#66d9ef">string</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">boolean</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 会出现编译错误，因为有函数体
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">declare</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">grantWish</span>(<span style="color:#a6e22e">wish</span>: <span style="color:#66d9ef">string</span>) { <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Fairy</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 正常
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">canGrantWish</span>(<span style="color:#a6e22e">wish</span>: <span style="color:#66d9ef">string</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">boolean</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 出现编译错误，因为里面有方法体
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">grantWish</span>(<span style="color:#a6e22e">wish</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>对于<code>ambient context</code>中声明的函数和变量，隐式<code>any</code>规则同样适用。由于<code>ambient context</code>中可能不提供函数体或变量初始值，因此显式类型标注（包括显式返回类型标注）通常是阻止它们隐式成为<code>any</code>类型的唯一方法。</p>
<p>尽管在<code>.d.ts</code>中使用<code>declare</code>关键字进行类型声明很常见，但在声明文件之外也可以使用<code>declare</code>关键字。模块或脚本文件中也可以使用<code>declare</code>，当一个全局可用的变量只能在该文件中使用时，这就很有用了。下面代码中，变量<code>myGlobalValue</code>定义在一个<code>index.ts</code>文件中，因此可以在这个文件中使用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// index.ts 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">declare</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">myGlobalValue</span>: <span style="color:#66d9ef">string</span>; 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">myGlobalValue</span>); <span style="color:#75715e">// Ok
</span></span></span></code></pre></div><p>需要注意的是，在<code>.d.ts</code>文件中，无论是否有<code>declare</code>，都允许使用接口等类型声明。而函数或变量等在r<code>untime constructs</code>没有<code>declare</code>的情况下会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// index.d.ts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Writer</span> {} <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">declare</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Writer</span> {} <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">declare</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">fullName</span>: <span style="color:#66d9ef">string</span>; <span style="color:#75715e">// Ok: type is the primitive string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">declare</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">firstName</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Liz&#34;</span>; <span style="color:#75715e">// Ok: type is the literal &#34;value&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Error: Top-level declarations in .d.ts files must 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// start with either a &#39;declare&#39; or &#39;export&#39; modifier.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">lastName</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Lemon&#34;</span>; 
</span></span></code></pre></div><h3 id="global-values">Global Values</h3>
<p>因为没有导入或导出语句的<code>TypeScript</code>文件被视为脚本而非模块，因此其中声明的<code>constructs—including types</code>在全局范围内可用。在没有导入或导出语句的定义文件可以利用这种行为在全局范围内声明类型。全局定义文件对于声明应用程序中所有文件都可用的全局类型或变量特别有用。</p>
<p>下面代码中，<code>globals.d.ts</code>文件全局声明了一个<code>const version: string</code>。这样，尽管没有从<code>globals.d.ts</code>导入，<code>version.ts</code>文件也能引用全局版本变量：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// globals.d.ts 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">declare</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">version</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// version.ts 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">logVersion() {</span> 
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Version: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">version</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>); <span style="color:#75715e">// Ok 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>全局声明值最常用于使用全局变量的浏览器应用程序中。虽然大多数现代网络框架一般都使用<code>ECMAScript</code>模块等较新的技术，但全局变量存储仍然非常有用，尤其是在较小的项目中。</p>
<p>如果发现无法自动访问<code>.d.ts</code>文件中声明的全局类型，需要检查<code>.d.ts</code>文件是否导入和导出了任何内容。即使是一次导出也会导致整个文件不再在全局范围内可用！</p>
<h3 id="global-interface-merging">Global Interface Merging</h3>
<p><font color="#de7802">变量并不是唯一可以设置为全局的东西</font>，许多类型声明都是为全局API和值而存在的。因为接口会与其它同名的接口合并，所以在全局脚本上下文中声明接口（例如不包含任何<code>import</code>或<code>export</code>语句的<code>.d.ts</code>文件）会在全局范围内对该接口进行补充。</p>
<p>例如，依赖于服务器设置的全局变量的网络应用程序可能希望将其声明为存在于全局<code>Window interface</code>上。接口合并将允许<code>types/window.d.ts</code>这样的文件声明一个存在于<code>Window</code>类型全局<code>window</code>变量：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span>&lt;<span style="color:#f92672">script</span> <span style="color:#a6e22e">type </span><span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;text/javascript&#34;</span> &gt;
</span></span><span style="display:flex;"><span>window.<span style="color:#a6e22e">myVersion</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;3.1.1&#34;</span>;
</span></span><span style="display:flex;"><span>&lt;/<span style="color:#f92672">script</span>&gt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// types/window.d.ts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Window</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">myVersion</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// index.ts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">logWindowVersion() {</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Window version is: </span><span style="color:#e6db74">${</span>window.<span style="color:#a6e22e">myVersion</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>    window.<span style="color:#a6e22e">alert</span>(<span style="color:#e6db74">&#34;Built-in window types still work! Hooray!&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="global-augmentations">Global Augmentations</h3>
<p>在<code>.d.ts</code>文件中避免使用<code>import</code>或<code>export</code>语句，以保持该文件的全局范围作用域并不总是可行的。有时，<code>mudule</code>文件中声明的类型会在全局范围内使用。</p>
<p>在这种情况下，<code>TypeScript</code>允许使用一种语法来声明代码块的全局性。这样做会将该代码块的内容标记为全局上下文，即使其周围环境并非如此：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// types.d.ts 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// (module context)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">declare</span> <span style="color:#66d9ef">global</span> { 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// (global context) 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// (module context)
</span></span></span></code></pre></div><h2 id="built-in-declarations">Built-In Declarations</h2>
<p>既然已经了解了声明是如何工作的，那么是时候揭开它在<code>TypeScript</code>中的神秘面纱了：它一直在为类型检查提供动力。数组（<code>Array</code>）、函数（<code>Function</code>）、映射（<code>Map</code>）和集合（<code>Set</code>）等全局对象是类型系统需要了解的构造示例，但它们并未在我们的代码中声明。它们由代码要运行的运行时提供，<code>Deno、Node、Web</code>浏览器等。</p>
<h3 id="library-declarations">Library Declarations</h3>
<p>所有<code>JavaScript</code>运行时都存在的<code>Array</code>和<code>Function</code>等内置全局对象都是在文件中声明，文件名如<code>lib.[target].d.ts</code>。<code>target</code>是项目所针对的<code>JavaScript</code>的最小支持版本，如<code>ES5、ES2020</code>或<code>ESNext</code>。</p>
<p>内置库定义文件（或称<code>lib</code>文件）相当庞大，因为它们代表<code>JavaScript</code>内置<code>API</code>的全部内容。例如，内置数组类型的成员由一个全局数组<code>interface</code>表示，该接口的开头是这样的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// lib.es5.d.ts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> Array&lt;<span style="color:#f92672">T</span>&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Gets or sets the length of the array. This is a number one higher than the highest index in the array.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">length</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Returns a string representation of an array.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">toString</span>()<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Returns a string representation of an array. The elements are converted to string using their toLocaleString methods.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">toLocaleString</span>()<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>Lib</code>文件作为<code>TypeScript npm</code>软件包的一部分发布，可以在软件包中找到它们，路径类似<code>node_modules/typescript/lib/lib.es5.d.ts</code>。</p>
<h1 id="enum">enum</h1>
<p>由于<code>enum</code>编译后是一个对象，所以**<font color="#de7802">不能有与它同名的变量，对象，函数和类等</font>**。如果存在同名的变量、对象、函数或类，将会出现编译错误。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 下面代码因为枚举和变量名重复了，会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Enum declarations can only merge with namespace or other enum declarations.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Test1</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Local</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;local&#39;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Remote</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;remote&#39;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 同名的常量，会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">Test1</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;890&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误，因为枚举和类名重复
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Enum declarations can only merge with namespace or other enum declarations.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Test2</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span>,  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">B</span>  
</span></span><span style="display:flex;"><span>}  
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 类名和枚举同名了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Test2</span> {  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 类的定义部分
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>枚举的成员不强制赋初始值。若没有初始值，默认从<code>0</code>开始逐一增<code>1</code>，按顺序为每个成员赋值。下面示例代码中，枚举成员(或称属性)对应值分别为<code>0，1，2</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">B</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">C</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">Foo</span>.<span style="color:#a6e22e">A</span>, <span style="color:#a6e22e">Foo</span>.<span style="color:#a6e22e">B</span>, <span style="color:#a6e22e">Foo</span>.<span style="color:#a6e22e">C</span>) <span style="color:#75715e">// 0 1 2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">B</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">C</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">Foo</span>.<span style="color:#a6e22e">A</span>, <span style="color:#a6e22e">Foo</span>.<span style="color:#a6e22e">B</span>, <span style="color:#a6e22e">Foo</span>.<span style="color:#a6e22e">C</span>) <span style="color:#75715e">// 0 4 5
</span></span></span></code></pre></div><p><code>enum</code>属性的值可以是小数，若某个成员没有初始值，则其后的值也依次在上一个的基础上<code>+1</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.12</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">B</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">C</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">Foo</span>.<span style="color:#a6e22e">A</span>, <span style="color:#a6e22e">Foo</span>.<span style="color:#a6e22e">B</span>, <span style="color:#a6e22e">Foo</span>.<span style="color:#a6e22e">C</span>) <span style="color:#75715e">// 0.12 1.12 2.12
</span></span></span></code></pre></div><p><code>enum</code>属性（成员）的值<font color="#de7802">不能是<code>BigInt</code>类型</font>，否则会出现编译错误:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Type &#39;bigint&#39; is not assignable to type &#39;number&#39; as required for computed enum member values.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span><span style="color:#a6e22e">n</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>不同于<code>Swift</code>，<code>TypeScript</code>中<code>enum</code><font color="#de7802">不同属性对应的值可以相同，但属性名一定不能相同</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.12</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">B</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.1</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">C</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.12</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果只设置第一个属性的值，后面成员的值就会从这个值开始依次递增（默认在上一个值的基础上<code>+1</code>）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Color</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Red</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">7</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Green</span>, <span style="color:#75715e">// 8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">Blue</span>, <span style="color:#75715e">// 9
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 或者
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Color</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Red</span>, <span style="color:#75715e">// 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">Green</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">7</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Blue</span>, <span style="color:#75715e">// 8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p><code>enum</code>所有属性对应的值都是只读的，不能重新被赋值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Color</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Red</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Green</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Blue</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译报错:Cannot assign to &#39;Blue&#39; because it is a read-only property.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">Color</span>.<span style="color:#a6e22e">Red</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>; 
</span></span></code></pre></div><p>为了强调这一点，通常在<code>enum</code>关键字前面加上<code>const</code>修饰，表示该枚举是常量，不能再次被赋值。加上<code>const</code>还有一个好处，编译为<code>JavaScript</code>代码后，<span style="background:rgba(255, 183, 139, 0.55)">枚举的成员会被替换成对应的值，可以提升性能</span>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Color</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Red</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Green</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Blue</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>enum</code>成员的值也可以是计算属性。但需要注意，如果在定义枚举时添加了<code>const</code>，<font color="#de7802">就不能再使用计算属性定义其中的成员</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Bool</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">No</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">123</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 非const枚举可以使用计算属性
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">Yes</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>(),
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">numb</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">12</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 正常
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Test</span> {
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">No</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">123</span>,
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">Yes</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">+</span> <span style="color:#a6e22e">numb</span>,
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">Third</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">getNum</span>(<span style="color:#ae81ff">12</span>)
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getNum</span>(<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span> {
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">return</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">+</span> <span style="color:#a6e22e">x</span>
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 出现编译错误:const enum member initializers must be constant expressions.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Test1</span> {
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">No</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">123</span>,
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">Yes</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">+</span> <span style="color:#a6e22e">numb</span>,
</span></span><span style="display:flex;"><span> }
</span></span></code></pre></div><p><code>enum</code>成员的值除了设置为<code>number</code>，还可以设置为<code>string</code>。也就是说，<code>enum</code>也可以作为一组字符串的集合，示例如下所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Direction</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Up</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;UP&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Down</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;DOWN&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Left</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;LEFT&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Right</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;RIGHT&#34;</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>需要注意的是，<font color="#de7802">字符串枚举的所有成员都必须显式设置对应值</font>。如果成员值没有显式设置为<code>string</code>，则默认为<code>number</code>，且其<font color="#31859b">位置必须在字符串成员之前</font>。也就是说一旦设置了字符串的成员，其后的成员一定要赋初值，否则会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span>, <span style="color:#75715e">// 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">B</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">C</span>, <span style="color:#75715e">// 报错 Enum member must have initializer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p><code>enum</code>成员<font color="#de7802">可以是字符串和数值的混合，如果要使用默认的数值，则成员必需放在字符串值成员之前</font>。下面定义的<code>Foo</code>枚举的第一个成员使用了默认的<code>number</code>，然后是<code>string</code>，再是<code>number</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Foo</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">zero</span>,  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">One</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;One&#34;</span>,  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Two</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Two&#34;</span>,  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Three</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>,  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Four</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>,  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>enum</code>的成员<font color="#de7802">除了<code>number</code>和<code>string</code>，不允许使用其它类型值。需要特别注意的是，若变量类型是字符串的<code>enum</code>，不能使用字符串直接赋值该变量，这跟数值<code>enum</code>变量不一样</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Enum</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">One</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;One&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Two</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Two&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Three</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Four</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">test</span>(<span style="color:#a6e22e">a</span>: <span style="color:#66d9ef">Enum</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">a</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">test</span>(<span style="color:#ae81ff">3</span>) <span style="color:#75715e">// 正常
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误:Argument of type &#39;&#34;One&#34;&#39; is not assignable to parameter of type &#39;Enum&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">test</span>(<span style="color:#e6db74">&#34;One&#34;</span>) 
</span></span></code></pre></div><p>需要注意的是，<code>enum</code>的<font color="#f79646">字符串类型成员值不能使用运行时才能计算的表达式赋值</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">MyEnum</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;one&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 使用表达式时会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">B</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;T&#34;</span>, <span style="color:#e6db74">&#34;w&#34;</span>, <span style="color:#e6db74">&#34;o&#34;</span>].<span style="color:#a6e22e">join</span>(<span style="color:#e6db74">&#34;&#34;</span>),
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Type &#39;string&#39; is not assignable to type &#39;number&#39; as required for computed enum member values.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">MyEnum</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;one&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">B</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;T&#34;</span>.<span style="color:#a6e22e">repeat</span>(<span style="color:#ae81ff">12</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">MyEnum</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;one&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">B</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;T&#34;</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;B&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Type &#39;string&#39; is not assignable to type &#39;number&#39; as required for computed enum member values.
</span></span></span></code></pre></div><p>同名的<code>enum</code>可以合并，但<font color="#de7802">合并时不能有同名的成员</font>，否则会出现编译报错。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 因为有同名的属性会出现编译错误:Duplicate identifier &#39;A&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>同名<code>enum</code>合并时，<font color="#de7802">只允许其中的一个同名枚举的第一个成员省略初始值</font>，否则会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：In an enum with multiple declarations, only one declaration can omit an initializer for its first enum element.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">B</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>同名<code>enum</code>合并的另一个限制，所有枚举定义必须同为<code>const</code>或者非<code>const</code>，<span style="background:#f8d9c3">不允许混合使用</span>。同名枚举合并的最大用处是补充外部定义的<code>enum</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Enum declarations can only merge with namespace or other enum declarations.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">B</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>枚举的反向映射，是指通过属性值获取到属性名，但仅限于<code>number</code>类型枚举：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">B</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">C</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">Foo</span>[<span style="color:#ae81ff">3</span>], <span style="color:#a6e22e">Foo</span>[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;C&#39;</span>) <span style="color:#75715e">// undefined true
</span></span></span></code></pre></div><p>枚举的反向映射只发生<code>enum</code>的数值成员。<font color="#f79646">对于字符串成员值的枚举，不存在反向映射</font>，因为字符串枚举编译后只有一组赋值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Foo</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>,  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">B</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>,  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">C</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>,  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">D</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;CHEN&#39;</span>,  
</span></span><span style="display:flex;"><span>}  
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误:Cannot find name &#39;D&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">Foo</span>[<span style="color:#ae81ff">3</span>], <span style="color:#a6e22e">Foo</span>[<span style="color:#a6e22e">D</span>])
</span></span></code></pre></div><p><a href="https://typescript.p6p.net/typescript-tutorial/enum.html">参考资料1</a></p>
<h1 id="namespaces">NameSpaces</h1>
<p><code>namespace</code>用于建立一个容器，其<font color="#f79646">内部的所有变量和函数，默认都必须在这个容器里使用</font>。下面示例代码中，<code>isString</code>只能在命名空间<code>Utils</code>中使用，如果在外部直接使用函数<code>isString</code>，就会报错。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> <span style="color:#a6e22e">Utils</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">isString</span>(<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">any</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;string&#39;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 在内部使用不会报错
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">isString</span>(<span style="color:#e6db74">&#39;test&#39;</span>))
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 在外部直接使用报错Cannot find name &#39;isString&#39;. Did you mean &#39;String&#39;?
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">isString</span>(<span style="color:#e6db74">&#39;test&#39;</span>))
</span></span></code></pre></div><p>如果要在命名空间以外使用内部成员，就必须在该成员前面加上<code>export</code>关键字，表示对外导出该成员，否则会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> <span style="color:#a6e22e">Utils</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">isString</span>(<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">any</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;string&#39;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">isString</span>(<span style="color:#e6db74">&#39;test&#39;</span>))
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 下面会出现编译错误：Property &#39;isString&#39; does not exist on type &#39;typeof Utils&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 因为isString前没有添加export
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">Utils</span>.<span style="color:#a6e22e">isString</span>(<span style="color:#e6db74">&#39;test&#39;</span>)) 
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> <span style="color:#a6e22e">Utils</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 只有添加export后才不会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">export</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">isString</span>(<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">any</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;string&#39;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">Utils</span>.<span style="color:#a6e22e">isString</span>(<span style="color:#e6db74">&#39;test&#39;</span>))
</span></span></code></pre></div><p>编译成<code>JavaScript</code>代码后，命名空间<code>Utils</code>变成了一个对象，<font color="#f79646">凡是在命名空间中export的内部成员，都成为了该对象的属性</font>。也就是说<code>namespace</code>会变成一个值，保留在编译后的代码中，这一点要小心，它不是纯类型代码。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> <span style="color:#a6e22e">Utils</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">export</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">isString</span>(<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">any</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;string&#39;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">isString</span>(<span style="color:#e6db74">&#39;test&#39;</span>))
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> <span style="color:#a6e22e">App</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">import</span> <span style="color:#a6e22e">isString</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Utils</span>.<span style="color:#a6e22e">isString</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">isString</span>(<span style="color:#e6db74">&#39;yes&#39;</span>))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>namespace</code>内部还可以使用<code>import</code>命令导入外部成员，<font color="#f79646">相当于给外部成员起别名</font>。当外部成员的名字比较长时，别名能够简化代码。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> <span style="color:#a6e22e">Utils</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">export</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">isString</span>(<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">any</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;string&#34;</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> <span style="color:#a6e22e">App</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">import</span> <span style="color:#a6e22e">isString</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Utils</span>.<span style="color:#a6e22e">isString</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">isString</span>(<span style="color:#e6db74">&#34;yes&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 等同于
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">Utils</span>.<span style="color:#a6e22e">isString</span>(<span style="color:#e6db74">&#34;yes&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><a href="https://ts.xcatliu.com/basics/declaration-files.html">参考资料2</a></p>
<p><a href="https://forums.developer.apple.com/forums/thread/110312">WK中使用sock5代理</a></p>
<p><a href="https://github.com/betafish-inc/OpenVPNAdapter">openAdapter</a></p>

    </div>
    <footer class="post-footer">
        
 
<div class="post-tags">     
     
    <a href="https://iihui.github.io/tags/ts" rel="tag" title="ts">#ts#</a>
    
</div>



        <div class="post-nav">
    <div class="post-nav-next post-nav-item">
    
        <a href="https://iihui.github.io/post/tool-rider/" rel="next" title="Rider 使用">
        <i class="fa fa-chevron-left"></i> Rider 使用
        </a>
    
    </div>

    <div class="post-nav-prev post-nav-item">
    
        <a href="https://iihui.github.io/post/ios-fundamentals/" rel="prev" title="iOS 14 编程基础">
        iOS 14 编程基础 <i class="fa fa-chevron-right"></i>
        </a>
    
    </div>
</div>
      
        <div class="post-nav">
    <div style="border: 1px dashed #e0e0e0; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
        <div style="float:left;margin-top:0px;">
            <img src="https://i.loli.net/2020/02/09/SvhUdz4XJsOr9Vk.jpg" width="128px" height="128px"/>
            <div style="text-align:center;">谢谢支持!</div>
        </div>
        <div>
            <p style="margin-top:10px;">
                标题：TypeScript基础
                <br />作者：阿呆<a target="_blank" href="https://iihui.github.io/"></a>
                
                <br />地址：https://iihui.github.io/post/ts-base/
                <br />声明：自由转载-非商用-保持署名（创作共享4.0许可证）
            </p>
        </div>
    </div>
    <div class="clear"></div>
</div>
        
        
        




    </footer>
  </article>
</section>

          </div>
        </div>
        <div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>
<aside id="sidebar" class="sidebar">
  <div class="sidebar-inner">

  <ul class="sidebar-nav motion-element">
    <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
      文章目录
    </li>
    <li class="sidebar-nav-overview" data-target="site-overview">
      站点概览
    </li>
  </ul>

    <section class="site-overview sidebar-panel ">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
        src="https://i.loli.net/2020/02/07/dVFzrvZkHRNq2lL.jpg"
        alt="" />
    <p class="site-author-name" itemprop="name"></p>
    <p class="site-description motion-element" itemprop="description"> 
        coder &amp; cook</p>
</div>
      <nav class="site-state motion-element">
    <div class="site-state-item site-state-posts">
      <a href="https://iihui.github.io/post/">
        <span class="site-state-item-count">140</span>
        <span class="site-state-item-name">日志</span>
      </a>
    </div>
    <div class="site-state-item site-state-categories">    
        <a href="https://iihui.github.io/categories/">      
         
        <span class="site-state-item-count">18</span>
        
        <span class="site-state-item-name">分类</span>
        
        </a>
    </div>

    <div class="site-state-item site-state-tags">
        <a href="https://iihui.github.io/tags/">
         
        <span class="site-state-item-count">29</span>
        
        <span class="site-state-item-name">标签</span>
        </a>
    </div>
</nav>
      
      
<div class="links-of-author motion-element">
    
        <span class="links-of-author-item">
        <a href="https://coolshell.cn" target="_blank" title="皓 大">
            <i class="fa fa-fw fa-globe"></i>
            皓 大
        </a>
        </span>
    
        <span class="links-of-author-item">
        <a href="http://www.ruanyifeng.com" target="_blank" title="阮 大">
            <i class="fa fa-fw fa-globe"></i>
            阮 大
        </a>
        </span>
    
        <span class="links-of-author-item">
        <a href="https://juejin.im/" target="_blank" title="掘 金">
            <i class="fa fa-fw fa-globe"></i>
            掘 金
        </a>
        </span>
    
</div>


      

      <div class="links-of-blogroll motion-element inline">
<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=&amp;m=0&amp;s=220&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;bv=35" async="async"></script>
</div>

    </section>
    
<section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
    <div class="post-toc">
        <div class="post-toc-content"><nav id="TableOfContents">
  <ul>
    <li><a href="#modules">Modules</a></li>
    <li><a href="#unions-and-literals">Unions and Literals</a>
      <ul>
        <li><a href="#union-types">Union Types</a></li>
        <li><a href="#narrowing">Narrowing</a>
          <ul>
            <li><a href="#assignment-narrowing">Assignment Narrowing</a></li>
            <li><a href="#conditional-checks">Conditional Checks</a></li>
          </ul>
        </li>
        <li><a href="#literal-types">Literal Types</a>
          <ul>
            <li><a href="#literal-assignability">Literal Assignability</a></li>
          </ul>
        </li>
        <li><a href="#strict-null-checking">Strict Null Checking</a>
          <ul>
            <li>
              <ul>
                <li><a href="#billion-dollar-mistake">billion-dollar mistake</a></li>
              </ul>
            </li>
            <li><a href="#truthiness-narrowing">Truthiness Narrowing</a></li>
            <li><a href="#variables-without-initial-values">Variables Without Initial Values</a></li>
          </ul>
        </li>
        <li><a href="#type-aliases">Type Aliases</a>
          <ul>
            <li><a href="#type-aliases-are-not-javascript">Type Aliases Are Not JavaScript</a></li>
            <li><a href="#combining-type-aliases">Combining Type Aliases</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#objects">Objects</a>
      <ul>
        <li><a href="#object-types">Object Types</a>
          <ul>
            <li><a href="#declaring-object-types">Declaring Object Types</a></li>
            <li><a href="#aliased-object-types">Aliased Object Types</a></li>
          </ul>
        </li>
        <li><a href="#structural-typing">Structural Typing</a>
          <ul>
            <li><a href="#usage-checking">Usage Checking</a></li>
            <li><a href="#excess-property-checking">Excess Property Checking</a></li>
            <li><a href="#nested-object-types">Nested Object Types</a></li>
            <li><a href="#optional-properties">Optional Properties</a></li>
          </ul>
        </li>
        <li><a href="#unions-of-object-types">Unions of Object Types</a>
          <ul>
            <li><a href="#inferred-object-type-unions">Inferred Object-Type Unions</a></li>
            <li><a href="#explicit-object-type-unions">Explicit Object-Type Unions</a></li>
            <li><a href="#narrowing-object-types">Narrowing Object Types</a></li>
            <li><a href="#discriminated-unions">Discriminated Unions</a></li>
          </ul>
        </li>
        <li><a href="#intersection-types">Intersection Types</a>
          <ul>
            <li><a href="#dangers-of-intersection-types">Dangers of Intersection Types</a></li>
            <li><a href="#never">never</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#functions">Functions</a>
      <ul>
        <li><a href="#function-parameters">Function Parameters</a>
          <ul>
            <li><a href="#required-parameters">Required Parameters</a></li>
            <li><a href="#optional-parameters">Optional Parameters</a></li>
            <li><a href="#default-parameters">Default Parameters</a></li>
            <li><a href="#rest-parameters">Rest Parameters</a></li>
          </ul>
        </li>
        <li><a href="#return-types">Return Types</a>
          <ul>
            <li><a href="#explicit-return-types">Explicit Return Types</a></li>
          </ul>
        </li>
        <li><a href="#function-types">Function Types</a>
          <ul>
            <li><a href="#function-type-parentheses">Function Type Parentheses</a></li>
            <li><a href="#parameter-type-inferences">Parameter Type Inferences</a></li>
            <li><a href="#function-type-aliases">Function Type Aliases</a></li>
          </ul>
        </li>
        <li><a href="#more-return-types">More Return Types</a>
          <ul>
            <li><a href="#never-returns">Never Returns</a></li>
          </ul>
        </li>
        <li><a href="#function-overloads">Function Overloads</a>
          <ul>
            <li><a href="#call-signature-compatibility">Call-Signature Compatibility</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#arrays">Arrays</a>
      <ul>
        <li><a href="#array-types">Array Types</a>
          <ul>
            <li><a href="#array-and-function-types">Array and Function Types</a></li>
            <li><a href="#union-type-arrays">Union-Type Arrays</a></li>
            <li><a href="#evolving-any-arrays">Evolving Any Arrays</a></li>
            <li><a href="#multidimensional-arrays">Multidimensional Arrays</a></li>
          </ul>
        </li>
        <li><a href="#array-members">Array Members</a>
          <ul>
            <li><a href="#caveat-unsound-members">Caveat: Unsound Members</a></li>
          </ul>
        </li>
        <li><a href="#spreads-and-rests">Spreads and Rests</a>
          <ul>
            <li><a href="#spreads">Spreads</a></li>
            <li><a href="#spreading-rest-parameters">Spreading Rest Parameters</a></li>
          </ul>
        </li>
        <li><a href="#tuples">Tuples</a>
          <ul>
            <li><a href="#tuple-assignability">Tuple Assignability</a></li>
            <li><a href="#tuple-inferences">Tuple Inferences</a>
              <ul>
                <li><a href="#explicit-tuple-types">Explicit tuple types</a></li>
                <li><a href="#const-asserted-tuples">Const asserted tuples</a></li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#interfaces">Interfaces</a>
      <ul>
        <li><a href="#type-aliases-versus-interfaces">Type Aliases Versus Interfaces</a></li>
        <li><a href="#types-of-properties">Types of Properties</a>
          <ul>
            <li><a href="#optional-properties-1">Optional Properties</a></li>
            <li><a href="#read-only-properties">Read-Only Properties</a></li>
            <li><a href="#functions-and-methods">Functions and Methods</a></li>
            <li><a href="#call-signatures">Call Signatures</a></li>
            <li><a href="#index-signatures">Index Signatures</a>
              <ul>
                <li><a href="#mixing-properties-and-index-signatures">Mixing properties and index signatures</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#interface-extensions">Interface Extensions</a>
          <ul>
            <li><a href="#overridden-properties">Overridden Properties</a></li>
            <li><a href="#extending-multiple-interfaces">Extending Multiple Interfaces</a></li>
          </ul>
        </li>
        <li><a href="#interface-merging">Interface Merging</a>
          <ul>
            <li><a href="#member-naming-conflicts">Member Naming Conflicts</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#classes">Classes</a>
      <ul>
        <li><a href="#class-methods">Class Methods</a></li>
        <li><a href="#class-properties">Class Properties</a>
          <ul>
            <li><a href="#function-properties">Function Properties</a></li>
            <li><a href="#initialization-checking">Initialization Checking</a>
              <ul>
                <li><a href="#definitely-assigned-properties">Definitely assigned properties</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#optional-properties-2">Optional Properties</a></li>
        <li><a href="#read-only-properties-1">Read-Only Properties</a></li>
        <li><a href="#classes-as-types">Classes as Types</a></li>
        <li><a href="#classes-and-interfaces">Classes and Interfaces</a>
          <ul>
            <li><a href="#implementing-multiple-interfaces">Implementing Multiple Interfaces</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#type-modifiers">Type Modifiers</a>
      <ul>
        <li><a href="#top-types">Top Types</a>
          <ul>
            <li><a href="#any">any</a></li>
            <li><a href="#unknown">unknown</a></li>
          </ul>
        </li>
        <li><a href="#type-predicates">Type Predicates</a></li>
        <li><a href="#type-operators">Type Operators</a>
          <ul>
            <li><a href="#keyof">keyof</a></li>
            <li><a href="#typeof">typeof</a></li>
            <li><a href="#keyof-typeof">keyof typeof</a></li>
          </ul>
        </li>
        <li><a href="#type-assertions">Type Assertions</a>
          <ul>
            <li><a href="#asserting-caught-error-types">Asserting Caught Error Types</a></li>
            <li><a href="#non-null-assertions">Non-Null Assertions</a></li>
            <li><a href="#type-assertion-caveats">Type Assertion Caveats</a></li>
          </ul>
        </li>
        <li><a href="#const-assertions">Const Assertions</a>
          <ul>
            <li><a href="#literals-to-primitives">Literals to Primitives</a></li>
            <li><a href="#read-only-objects">Read-Only Objects</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#generics">Generics</a>
      <ul>
        <li><a href="#generic-functions">Generic Functions</a>
          <ul>
            <li><a href="#explicit-generic-call-types">Explicit Generic Call Types</a></li>
            <li><a href="#multiple-function-type-parameters">Multiple Function Type Parameters</a></li>
          </ul>
        </li>
        <li><a href="#generic-interfaces">Generic Interfaces</a>
          <ul>
            <li><a href="#inferred-generic-interface-types">Inferred Generic Interface Types</a></li>
          </ul>
        </li>
        <li><a href="#generic-classes">Generic Classes</a>
          <ul>
            <li><a href="#explicit-generic-class-types">Explicit Generic Class Types</a></li>
            <li><a href="#extending-generic-classes">Extending Generic Classes</a></li>
            <li><a href="#implementing-generic-interfaces">Implementing Generic Interfaces</a></li>
            <li><a href="#method-generics">Method Generics</a></li>
            <li><a href="#static-class-generics">Static Class Generics</a></li>
          </ul>
        </li>
        <li><a href="#generic-type-aliases">Generic Type Aliases</a>
          <ul>
            <li><a href="#generic-discriminated-unions">Generic Discriminated Unions</a></li>
          </ul>
        </li>
        <li><a href="#generic-modifiers">Generic Modifiers</a>
          <ul>
            <li><a href="#generic-defaults">Generic Defaults</a></li>
          </ul>
        </li>
        <li><a href="#constrained-generic-types">Constrained Generic Types</a>
          <ul>
            <li><a href="#keyof-and-constrained-type-parameters">keyof and Constrained Type Parameters</a></li>
          </ul>
        </li>
        <li><a href="#promises">Promises</a>
          <ul>
            <li><a href="#creating-promises">Creating Promises</a></li>
            <li><a href="#async-functions">Async Functions</a></li>
          </ul>
        </li>
        <li><a href="#using-generics-right">Using Generics Right</a>
          <ul>
            <li><a href="#the-golden-rule-of-generics">The Golden Rule of Generics</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#declaration-files">Declaration Files</a>
      <ul>
        <li><a href="#declaring-runtime-values">Declaring Runtime Values</a>
          <ul>
            <li><a href="#global-values">Global Values</a></li>
            <li><a href="#global-interface-merging">Global Interface Merging</a></li>
            <li><a href="#global-augmentations">Global Augmentations</a></li>
          </ul>
        </li>
        <li><a href="#built-in-declarations">Built-In Declarations</a>
          <ul>
            <li><a href="#library-declarations">Library Declarations</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#enum">enum</a></li>
    <li><a href="#namespaces">NameSpaces</a></li>
  </ul>
</nav></div>
    </div>
</section>

  </div>
</aside>

      </div>
    </main>
   
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  <span itemprop="copyrightYear">  &copy; 
  2017 - 2024</span>
  <span class="with-love"><i class="fa fa-heart"></i></span>
  <span class="author" itemprop="copyrightHolder">Keep It Simple</span>
</div>




      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      <span id="scrollpercent"><span>0</span>%</span>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/jquery/index.js?v=2.1.3"></script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script> 
<script type="text/javascript" src="https://iihui.github.io/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/velocity/velocity.min.js?v=1.2.1"></script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="https://iihui.github.io/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>

<script src="https://iihui.github.io/js/vendor/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>

<script type="text/javascript" src="https://iihui.github.io/js/utils.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/motion.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/affix.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/schemes/pisces.js"></script>

<script type="text/javascript" src="https://iihui.github.io/js/scrollspy.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/post-details.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/toc.js"></script>

<script type="text/javascript" src="https://iihui.github.io/js/bootstrap.js"></script>

<script type="text/javascript" src="https://iihui.github.io/js/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
</body>
</html>