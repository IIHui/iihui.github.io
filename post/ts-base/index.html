<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
    <title>TypeScript基础 - Keep It Simple</title>
    <meta name="keywords" content="博客,思考,读书,笔记,技术,分享">
    
    <meta property="og:title" content="TypeScript基础">
    <meta property="og:site_name" content="Keep It Simple">
    <meta property="og:image" content="/img/author.jpg"> 
    <meta name="title" content="TypeScript基础 - Keep It Simple" />
    <meta name="description" content="Swift | Go | C&#43;&#43; "> 
    <link rel="shortcut icon" href="https://iihui.github.io/img/favicon.ico" />
    <link rel="apple-touch-icon" href="https://iihui.github.io/img/apple-touch-icon.png" />
    <link rel="apple-touch-icon-precomposed" href="https://iihui.github.io/img/apple-touch-icon.png" />
    <link href="https://iihui.github.io/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />
    <link href="https://iihui.github.io/js/vendor/fancybox/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />
    <link href="https://iihui.github.io/css/main.css" rel="stylesheet" type="text/css" />
    <link href="https://iihui.github.io/css/syntax.css" rel="stylesheet" type="text/css" />

    <script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
     fancybox: true, 
    motion: true
  };
</script>

    <link href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/monokai-sublime.min.css" rel="stylesheet">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/go.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/swift.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/objectivec.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/clojure.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/kotlin.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/yaml.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<div class="container one-collumn sidebar-position-left page-home  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-meta  custom-logo ">

  <div class="custom-logo-site-title">
    <a href="https://iihui.github.io/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Keep It Simple</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">靡不有初，鲜克有终</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
    <ul id="menu" class="menu">
      
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/tags/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-tag"></i> <br />标签
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/post/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/categories/%E7%BE%8E%E9%A3%9F/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-fire"></i> <br />美食
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/categories/%E5%90%8E%E6%9C%9F/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-edit"></i> <br />后期
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/categories/%E6%97%85%E8%A1%8C/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-leaf"></i> <br />旅行
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/about/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于
          </a>
        </li>
      
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger"> <i class="menu-item-icon fa fa-search fa-fw"></i> <br /> 搜索</a>
      </li>
    </ul>
    <div class="site-search">
      <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>

    </div>
</nav>
<script type="text/javascript"
        async
        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
		<!-- src = "http://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> <\!--  -\-> -->
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>

<!DOCTYPE html>
<html lang="en">


<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css" integrity="sha384-D+9gmBxUQogRLqvARvNLmA9hS2x//eK1FhVb9PiU86gmcrBrJAQT8okdJ4LMp2uv" crossorigin="anonymous">

    
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js" integrity="sha384-483A6DwYfKeDa0Q52fJmxFXkcPCFfnXMoXblOkJ4JcA8zATN6Tm78UNL72AKk+0O" crossorigin="anonymous"></script>
</head>
<body>

</body>
</html>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
<section id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="https://iihui.github.io/post/ts-base/" itemprop="url">
        TypeScript基础
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">创建: </span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2022-01-27">
    2022-01-27
</time>
</span>
&nbsp; | &nbsp;
<span class="post-updated-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-check-o"></i>
</span>
<span class="post-meta-item-text">更新: </span>
<time itemprop="dateUpdated" content="2022-01-27">
    2022-01-27
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类: </span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="https://iihui.github.io/categories/ts" itemprop="url" rel="index">
        <span itemprop="name">ts</span>
      </a>
      &nbsp; 
    </span>
  
</span>


      <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-file-word-o"></i>
</span>
<span class="post-meta-item-text">字数: </span>
<span class="leancloud-visitors-count">27909</span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-coffee"></i>
</span>
<span class="post-meta-item-text">阅读: </span>
<span class="leancloud-visitors-count">56 分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <p><code>TypeScript</code>的7种基本类型为：</p>
<ul>
<li><code>null</code></li>
<li><code>undefined</code></li>
<li><code>boolean</code></li>
<li><code>string</code></li>
<li><code>number</code></li>
<li><code>bigint</code></li>
<li><code>symbol</code></li>
</ul>
<p>若声明变量时不标注类型，编译器会认为该变量的类型为<code>any</code>，表示该变量可以赋值为任何类型值。如果声明变量时既不标注类型也不初始化，接着使用<code>typeof</code>得到的结果为<code>undefined</code>(编译成<code>JavaScript</code>后，因为未初始化变量的默认值为<code>undefined</code>)：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">rocker</span>; <span style="color:#75715e">// Type: any
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">rocker</span>) <span style="color:#75715e">// undefined
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">rocker</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Joan Jett&#34;</span>; <span style="color:#75715e">// 此时类型为string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">rocker</span>.<span style="color:#a6e22e">toUpperCase</span>(); <span style="color:#75715e">// JOAN JETT
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">rocker</span>, <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">rocker</span>) <span style="color:#75715e">// Joan Jett string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">rocker</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">19.58</span>; <span style="color:#75715e">// 此时类型为number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">rocker</span>, <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">rocker</span>) <span style="color:#75715e">// 19.58 number
</span></span></span></code></pre></div><p>函数的<font color=red>可选参数必须是最后一个参数</font>，若将可选参数放在必需参数前，会出现编译错误。下面代码编译时会出现<code>A required parameter cannot follow an optional parameter</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">hello3</span>(<span style="color:#a6e22e">x?</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：A required parameter cannot follow an optional parameter
</span></span></span></code></pre></div><p>具有<font color=red>默认值的参数若不位于参数列表的末尾，调用时不能省略该参数，如果要触发默认值，必须显式地传入<code>undefined</code></font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">hello3</span>(<span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>, <span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">hello3</span>(<span style="color:#66d9ef">undefined</span>, <span style="color:#ae81ff">890</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">3</span> <span style="color:#ae81ff">890</span>
</span></span></code></pre></div><h1 id="modules">Modules</h1>
<p><code>JavaScript</code>编程语言最近才规范了文件之间如何共享代码。<code>ECMAScript 2015</code>增加了<code>ECMAScript Modules</code>以规范文件间的<code>import</code>和<code>export</code>语法。</p>
<p>在<code>module</code>文件中声明的任何内容<font color=LightSeaGreen>都只能在该文件中使用，除非该文件中有明确的<code>export</code>语句</font>。下面代码<code>test.ts</code>文件从同级的<code>./values</code>文件中导入了一个值，并导出了一个<code>doubled</code>常量值:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">//values.ts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">12</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// test.ts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">import</span> {<span style="color:#a6e22e">value</span>} <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#34;./values&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">doubled</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>;
</span></span></code></pre></div><p>如果在某一个模块中声明的变量和另一个模块中声明的变量同名，一般不会冲突。只有当在一个文件中导入了另一个文件的同名变量时，才会产生冲突。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#75715e">// a.ts 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">shared</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Cher&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// b.ts 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">shared</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Cher&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// c.ts 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">import</span> { <span style="color:#a6e22e">shared</span> } <span style="color:#66d9ef">from</span> <span style="color:#e6db74">&#34;./a&#34;</span>; <span style="color:#75715e">// 编译错误：Import declaration conflicts with local declaration of &#39;shared&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">shared</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Cher&#34;</span>; <span style="color:#75715e">//编译错误： Individual declarations in merged declaration &#39;shared&#39; must be all exported or all local.
</span></span></span></code></pre></div><p>如果文件是脚本，<code>TypeScript</code>会<font color=red>将其视为全局作用域，这意味着其它所有脚本都可以访问其中的内容</font>。也就是说，在某个脚本文件中声明的变量不能与其它脚本文件中声明的变量同名。</p>
<p>下面<code>a.ts</code>和<code>b.ts</code>文件均会被认为是脚本，因为它们中没有<code>export</code>和<code>import</code>语句。意味着如果在这两个文件中有同名的变量，就会有冲突：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// a.ts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">shared</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Cher&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// b.ts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">shared</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Cher&#34;</span>; <span style="color:#75715e">// 编译错误：Cannot redeclare block-scoped variable &#39;shared&#39;.
</span></span></span></code></pre></div><p>根据<code>ECMAScript</code>规范，如果需要将一个没有<code>export</code>或<code>import</code>语句的文件变成模块，可以在文件的<font color=red>某个地方添加一个<code>export {};</code>语句来强制它成为一个模块</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// a.ts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">shared</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Cher&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// b.ts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">shared</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Cher&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">export</span> {};
</span></span></code></pre></div><h1 id="unions-and-literals">Unions and Literals</h1>
<blockquote>
<p>联合：将值的允许类型扩展为两种或两种以上的可能类型。窄化：减少值的允许类型，使其不属于一种或多种可能的类型。联合和窄化是一个强大的概念，允许对代码做出比其他主流语言更智能的推断。</p>
</blockquote>
<h2 id="union-types">Union Types</h2>
<p>下面变量<code>mathematician</code>的类型既可以是<code>undefined</code>，也可以是<code>string</code>，<font color=red>这种非此即彼的类型称为联合类型</font>。联合类型是一个奇妙的概念，它可以让我们在代码中处理这样的情况：暂时不知道某个值的确切类型，但知道它是两个或多个类型之一。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 变量类型为string | undefined
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">mathematician</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> <span style="color:#66d9ef">undefined</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Mark Goldberg&#34;</span>;
</span></span></code></pre></div><p><code>TypeScript</code>使用管道操作符<code>|</code>来连接可能的类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">mathematician</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> <span style="color:#66d9ef">undefined</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Mark Goldberg&#34;</span>;
</span></span></code></pre></div><p>变量在有初始值的情况下，也显式地将其类型标注为联合类型有时很有用。下面代码中，<code>thinker</code>一开始是<code>null</code>，但在某些情况下也可能是一个字符串。显式标注为<code>string | null</code>联合类型，意味着给它赋为字符串类型的值是允许的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">thinker</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">thinker</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Susanne Langer&#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">thinker</span>, <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">thinker</span>)  <span style="color:#75715e">// 每次执行时生成随机数不同，结果不同
</span></span></span></code></pre></div><p>联合类型标注可以放置在任何需要类型标注的地方。<font color=red>当已知值是一个联合类型时，<code>TypeScript</code>只允许访问联合中所有子类型都存在的共有成员属性</font>。如果尝试访问的属性不是所有子类型的共有属性，将会出现编译错误。</p>
<p>下面代码中，<code>physicist</code>是一个<code>number|string</code>联合类型变量。方法<code>toString()</code>在两种类型中都存在，但<code>toUpperCase</code>方法仅存在于<code>string</code>类型，<code>toFixed</code>方法仅存在于<code>number</code>类型。所以，直接调用<code>toUpperCase</code>和<code>toFixed</code>都会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// physicist变量类型为string | number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">physicist</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;Marie Curie&#34;</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">84</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">physicist</span>.<span style="color:#a6e22e">toString</span>()
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Property &#39;toUpperCase&#39; does not exist on type &#39;string | number&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Property &#39;toUpperCase&#39; does not exist on type &#39;number&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">physicist</span>.<span style="color:#a6e22e">toUpperCase</span>(); 
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Property &#39;toFixed&#39; does not exist on type &#39;string | number&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Property &#39;toFixed&#39; does not exist on type &#39;string&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">physicist</span>.<span style="color:#a6e22e">toFixed</span>();
</span></span></code></pre></div><p>限制访问并不存在于联合类型所有子类型的属性或方法是一种安全措施。如果一个对象还不确定是否为包含某个属性的子类型，<code>TypeScript</code>认为尝试使用其独有的属性是不安全的。</p>
<p>如果要使用仅存在于联合类型中某个子类型的属性或方法，我们的代码需向<code>TypeScript</code>表明在当前位置的值就是某个具体的子类型，这一过程被称为窄化（<code>narrowing</code>）。</p>
<h2 id="narrowing">Narrowing</h2>
<p>窄化是指在代码中推断出一个值的类型比其声明时的类型更具体。一旦知道一个值的类型比声明时的类型范围更窄，将允许将该值的类型视为这个更具体的类型。</p>
<p>用于<font color=LightSeaGreen>窄化类型范围的逻辑检查称为类型保护</font>。下面介绍<code>TypeScript</code>可以用来从代码中窄化类型的两种常见类型保护。</p>
<h3 id="assignment-narrowing">Assignment Narrowing</h3>
<p>如果直接赋值给一个联合类型变量，会将变量的类型缩小为该值的类型。下面示例代码中，变量<code>admiral</code>声明为<code>number | string</code>联合类型。一旦变量被赋值为字符串<code>&quot;Grace Hopper&quot;</code>，<code>TypeScript</code>就知道它是字符串类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">admiral</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">admiral</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Grace Hopper&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">admiral</span>.<span style="color:#a6e22e">toUpperCase</span>(); <span style="color:#75715e">// Ok: string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Property &#39;toFixed&#39; does not exist on type &#39;string&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">admiral</span>.<span style="color:#a6e22e">toFixed</span>(); 
</span></span></code></pre></div><p>当变量的类型显式地标注为联合类型并且同时有一个初始值时，赋值窄化就会发挥作用。编译器会知道，虽然变量以后可能会接收联合类型其它子类型的值，但它初始时只是初始值的类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">inventor</span>: <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Hedy Lamarr&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">inventor</span>.<span style="color:#a6e22e">toUpperCase</span>();
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Property &#39;toFixed&#39; does not exist on type &#39;string&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">inventor</span>.<span style="color:#a6e22e">toFixed</span>(); 
</span></span></code></pre></div><h3 id="conditional-checks">Conditional Checks</h3>
<p>窄化变量类型的常见方法是使用<code>if</code>语句，<font color=LightSeaGreen>检查变量是否等于已知值</font>。编译器非常聪明，它知道在<code>if</code>语句中，变量必须与已知值的类型相同：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">scientist</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;Rosalind Franklin&#34;</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">51</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">scientist</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;Rosalind Franklin&#34;</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">scientist</span>.<span style="color:#a6e22e">toUpperCase</span>()) <span style="color:#75715e">// ROSALIND FRANKLIN
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Property &#39;toUpperCase&#39; does not exist on type &#39;string | number&#39;. Property &#39;toUpperCase&#39; does not exist on type &#39;number&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">scientist</span>.<span style="color:#a6e22e">toUpperCase</span>() 
</span></span></code></pre></div><p>除了直接进行值检查，还可以使用<code>typeof</code>操作符窄化变量的类型范围：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">scientist</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;Rosalind Franklin&#34;</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">51</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">scientist</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;string&#39;</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">scientist</span>.<span style="color:#a6e22e">toUpperCase</span>())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>来自<code>!</code>和<code>else</code>语句的逻辑否定也同样有效：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 变量researcher类型为联合类型string | number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">researcher</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;Rosalind Franklin&#34;</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">51</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">researcher</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;string&#34;</span>)) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">researcher</span>.<span style="color:#a6e22e">toFixed</span>(); <span style="color:#75715e">// Ok: number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">researcher</span>.<span style="color:#a6e22e">toUpperCase</span>(); <span style="color:#75715e">// Ok: string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h2 id="literal-types">Literal Types</h2>
<p>介绍了联合和窄化用于处理可能是两种或两种以上类型的值后，再来介绍一下字面类型—基础类型的更具体版本。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">philosopher</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Hypatia&#34;</span>; <span style="color:#75715e">// 类型为&#34;Hypatia&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">philosopher</span>) <span style="color:#75715e">// string
</span></span></span></code></pre></div><p>上面代码中，<code>philosopher</code>是什么类型？乍一看，你可能会说是字符串，没错，<code>philosopher</code>常量的确是字符串。但是，<code>philosopher</code>并不是一个普通的字符串，它的具体值是<code>&quot;Hypatia&quot;</code>。因此，从技术上讲，<code>philosopher</code>常量的类型是更具体的<code>&quot;Hypatia&quot;</code>。</p>
<p>这就是字面类型的概念：是已知基本类型的某个特定值，<font color=red>而不是这些基本类型的任何其它值</font>。字符串基本类型代表了所有可能存在的字符串集合，而字面类型<code>&quot;Hypatia&quot;</code>只代表了这一个字符串。</p>
<p>如果将一个变量声明为<code>const</code>，并直接给它一个字面值，<code>TypeScript</code>将推断出这个变量的类型就是这个字面值类型。这就是为什么在IDE中将鼠标悬停在带有初始字面值的<code>const</code>常量上时，会显示常量的类型为字面值，而不是其基本类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 常量的类型为Hypatia
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">philosopher</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Hypatia&#34;</span>;
</span></span></code></pre></div><p>可以把每个基本类型看作是所有可能的字面值的联合类型。换句话说，基本类型是该类型所有可能字面值的集合。</p>
<p>除了<code>boolean</code>，<code>null</code>和<code>undefined</code>类型，所有其它基本类型（例如<code>number</code>和<code>string</code>）均有无限多的字面值类型。在<code>TypeScript</code>代码中会出现的常见类型如下：</p>
<ul>
<li><code>boolean</code>: 只有<code>true | false</code></li>
<li><code>null</code>和<code>undefined</code>只有一个字面值，就是它们自己</li>
<li><code>number</code>：<code>0 | 1 | 2 | ... | 0.1 | 0.2 | ...</code></li>
<li><code>string</code>:<code>&quot;&quot; | &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | ... | &quot;aa&quot; | &quot;ab&quot; | &quot;ac&quot; | ...</code></li>
</ul>
<p>联合类型可以将字面值类型和基本类型混合使用。例如，下面变量<code>lifespan</code>表示可以用任何数值或已知的几种字符串字面值来表示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">lifespan</span>: <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;ongoing&#34;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;uncertain&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">lifespan</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">89</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">lifespan</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;ongoing&#34;</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Type &#39;true&#39; is not assignable to type &#39;number | &#34;ongoing&#34; | &#34;uncertain&#34;&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">lifespan</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>; 
</span></span></code></pre></div><h3 id="literal-assignability">Literal Assignability</h3>
<p>我们已经知道，不同的基本类型（如<code>number</code>和<code>string</code>）是不能相互赋值的。同样，<font color=LightSeaGreen>同一基本类型中的不同字面值类型（如0和1）也不能互相赋值</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">specificallyAda</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Ada&#34;</span>; <span style="color:#75715e">// Ada string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">specificallyAda</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Ada&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 打印结果为string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">specificallyAda</span>) 
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误: Type &#39;&#34;B&#34;&#39; is not assignable to type &#39;&#34;Ada&#34;&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">specificallyAda</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;B&#39;</span> 
</span></span></code></pre></div><p>字面量类型可以赋值给相应的基本类型，因为任何特定的字面量字符串值仍然是字符串。所以，下面代码不会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">specificallyAda</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Ada&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">specificallyAda</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Ada&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">someString</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>; <span style="color:#75715e">// Type: string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 可以赋值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">someString</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">specificallyAda</span>
</span></span></code></pre></div><h2 id="strict-null-checking">Strict Null Checking</h2>
<p>在处理可能存在<code>undefined</code>值时，字面值联合的作用尤其明显。<code>TypeScript</code>是现代编程语言浪潮的一部分，这些语言利用严格的空值检查来解决可怕的<code>billion-dollar mistake</code>。</p>
<h4 id="billion-dollar-mistake">billion-dollar mistake</h4>
<p><code>billion-dollar mistake</code>是一个术语，指许多类型系统允许在需要不同类型的地方允许<code>null</code>值。在没有<code>strict null checking</code>的语言中，像下面这样将<code>null</code>赋值给<code>string</code>类型的变量是允许的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">firstName</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>; 
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 如果是严格类型检查就会出现错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Type &#39;null&#39; is not assignable to type &#39;string&#39;.
</span></span></span></code></pre></div><p><code>TypeScript</code>编译器包含大量选项，可以改变运行方式。严格空检查（<code>strictNullChecks</code>）是最有用的选项之一，它表示是否启用严格<code>null</code>值检查。粗略来讲，禁用<code>strictNullChecks</code>意味着会为代码中的每个类型添加<code>| null | undefined</code>，从而允许任何变量接收<code>null</code>或<code>undefined</code>。</p>
<p>如果将<code>strictNullChecks</code>选项设置为<code>false</code>，下面代码会被认为是安全的。但这种方式是错误的，当使用变量<code>nameMaybe</code>调用<code>toLowerCase</code>方法时，它可能是<code>undefined</code>的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">nameMaybe</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;Tony Hoare&#34;</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Potential runtime error: Cannot read property &#39;toLowerCase&#39; of undefined.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">nameMaybe</span>.<span style="color:#a6e22e">toLowerCase</span>() 
</span></span></code></pre></div><p>如果开启了严格空值检查，则下面代码会出现编译错误：<code>'nameMaybe' is possibly 'undefined'.</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">nameMaybe</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;Tony Hoare&#34;</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">//  &#39;nameMaybe&#39; is possibly &#39;undefined&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">nameMaybe</span>.<span style="color:#a6e22e">toLowerCase</span>()  
</span></span></code></pre></div><p>如果没有严格空值检查，就很难确定我们的代码是否会因意外的<code>null</code>或<code>undefined</code>而出错。最佳实践通常是启用<code>strictNullChecks</code>选项。这样做有助于防止崩溃，并消除<code>billion-dollar mistake</code>错误。</p>
<h3 id="truthiness-narrowing">Truthiness Narrowing</h3>
<p>在<code>JavaScript</code>中，除了<code>false, 0, -0, 0n, &quot;&quot;, null, undefined,NaN</code>为<code>falsy</code>值，其它的都是<code>truthy</code>值。如果变量的某些可能值是<code>truthy</code>的，还可以通过<code>truthiness</code>检查以窄化变量类型。</p>
<p>下面代码中，变量<code>geneticist</code>的类型是<code>string | undefined</code>，因为<code>undefined</code>是<code>falsy</code>值，<code>TypeScript</code>可以在<code>if</code>语句体中推断出它必须是<code>string</code>类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">geneticist</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;Barbara McClintock&#34;</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 如果变量真值是true，则一定不是undefined，那么一定是字符串
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">geneticist</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">geneticist</span>.<span style="color:#a6e22e">toUpperCase</span>()) <span style="color:#75715e">// BARBARA MCCLINTOCK
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>逻辑运算符执行真值检查也同样有效，即<code>&amp;&amp;</code>和 <code>?</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 变量geneticist类型为string | undefined
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">geneticist</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;Barbara McClintock&#34;</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">geneticist</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">geneticist</span>.<span style="color:#a6e22e">toUpperCase</span>()) <span style="color:#75715e">// undefined
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">geneticist</span><span style="color:#f92672">?</span>.<span style="color:#a6e22e">toUpperCase</span>()) <span style="color:#75715e">// undefined
</span></span></span></code></pre></div><p>需要注意的是，真值检查不能反过来使用。如果知道类型为<code>string | undefined</code>变量的值是<code>falsy</code>的，这并不能表明它是空字符串还是<code>undefined</code>。</p>
<p>下面代码中，变量<code>biologist</code>的类型为<code>string | false</code>，虽然在<code>if</code>语句体中可以窄化类型为字符串，但<code>else</code>语句体包含变量值为<code>&quot;&quot;</code>，也就是说在<code>else</code>语句体里变量还可以是字符串类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">biologist</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#e6db74">&#34;Rachel Carson&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">biologist</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">biologist</span>; <span style="color:#75715e">// Type一定为string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">biologist</span>; <span style="color:#75715e">// Type为false | string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h3 id="variables-without-initial-values">Variables Without Initial Values</h3>
<p>在<code>JavaScript</code>中变量若没有初始值，则其默认值是<code>undefined</code>。这在类型系统中出现了一个极端情况：如果将一个变量声明为不包括<code>undefined</code>的类型，然后尝试在赋值前使用它，会出现什么情况。<code>TypeScript</code>很聪明，知道在变量赋值之前，其值是<code>undefined</code>。如果在赋值前尝试使用该变量的值，会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">mathematician</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 即是使用?来访问属性，也会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//  Variable &#39;mathematician&#39; is used before being assigned.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">mathematician</span><span style="color:#f92672">?</span>.<span style="color:#a6e22e">length</span>; 
</span></span></code></pre></div><p>请注意，如果变量类型包括<code>undefined</code>，则不会出现编译错误。在变量类型中添加<code>| undefined</code>是向<code>TypeScript</code>说明，在使用前无需初始化，因为<code>undefined</code>是变量的有效值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">mathematician</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">mathematician</span><span style="color:#f92672">?</span>.<span style="color:#a6e22e">length</span>;
</span></span></code></pre></div><h2 id="type-aliases">Type Aliases</h2>
<p>在代码中看到的大多数联合类型的子类型一般只有两到三个。但是，有时可能会遇到一些较长的联合类型，如果出现次数较多，则不方便重复输入。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">rawDataFirst</span>: <span style="color:#66d9ef">boolean</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">rawDataSecond</span>: <span style="color:#66d9ef">boolean</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">rawDataThird</span>: <span style="color:#66d9ef">boolean</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>;
</span></span></code></pre></div><p><code>TypeScript</code>包含类型别名，可以为重复使用的类型分配更简单的名称。类型别名以如下方式声明，按照惯例，类型别名以大驼峰命名：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">MyName</span> <span style="color:#f92672">=</span> ...;
</span></span></code></pre></div><p>之前的联合类型，可以简写成如下形式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">RawData</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">boolean</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">rawDataFirst</span>: <span style="color:#66d9ef">RawData</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">rawDataSecond</span>: <span style="color:#66d9ef">RawData</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">rawDataThird</span>: <span style="color:#66d9ef">RawData</span>;
</span></span></code></pre></div><p>类型别名是一项便捷功能，只要代码中使用的类型开始变得复杂，就可以使用它。目前，只包括长联合类型，以后还将包括数组、函数和对象类型。</p>
<h3 id="type-aliases-are-not-javascript">Type Aliases Are Not JavaScript</h3>
<p>类型别名与类型标注一样，不会编译到输出的<code>JavaScript</code>文件中。<font color=LightSeaGreen>类型别名仅存在于类型系统</font>，因此不能在运行时的代码中引用它们。如果试图访问运行时不存在的内容，<code>TypeScript</code>会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">RawData</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">boolean</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：&#39;RawData&#39; only refers to a type, but is being used as a value here.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">RawData</span>) 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">rawData</span>: <span style="color:#66d9ef">RawData</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">rawData</span>, <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">rawData</span>) <span style="color:#75715e">// false boolean
</span></span></span></code></pre></div><h3 id="combining-type-aliases">Combining Type Aliases</h3>
<p>类型别名在<font color=LightSeaGreen>定义时也可以引用其它的类型别名</font>。类型别名相互引用有时会很有用，当一个类型别名是一个联合类型时，它可能包含另一个类型别名。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Id</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">IdMaybe</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Id</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span>;
</span></span></code></pre></div><p>类型别名<font color=red>不必按使用顺序声明</font>。可以让文件中较早声明的类型别名引用在文件中较后声明的别名。上面代码可以重写，将<code>IdMaybe</code>放在<code>Id</code>之前声明：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">IdMaybe</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Id</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Id</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">id</span>: <span style="color:#66d9ef">IdMaybe</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">id</span>)
</span></span></code></pre></div><h1 id="objects">Objects</h1>
<blockquote>
<p>对象字面值是键和值的集合，每个键和值都有自己的类型。前面的介绍的基本类型，只是<code>JavaScript</code>常用复杂对象类型的表面。如果不能表示对象，<code>TypeScript</code>将无法使用。</p>
</blockquote>
<h2 id="object-types">Object Types</h2>
<p>当使用<code>{}</code>创建对象字面量时，<code>TypeScript</code>会根据其属性将其视为新的对象类型。新对象类型将具有与对象字面量相同的属性名和对应的值类型。访问对象属性的值可以使用<code>value.member</code>或等同的<code>value['member']</code>语法。</p>
<p>下面代码中，<code>TypeScript</code>认为常量<code>poet</code>的类型是一个对象，该对象具有两个属性<code>born</code>和<code>name</code>。访问这两个属性是允许的，但<font color=LightSeaGreen>试图访问任何其它不存在的成员名称都会出现编译错误</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">poet</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">1935</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Mary Oliver&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">poet</span>.<span style="color:#a6e22e">born</span>, <span style="color:#a6e22e">poet</span>.<span style="color:#a6e22e">name</span>, <span style="color:#a6e22e">poet</span>[<span style="color:#e6db74">&#39;born&#39;</span>], <span style="color:#a6e22e">poet</span>[<span style="color:#e6db74">&#39;name&#39;</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Property &#39;end&#39; does not exist on type &#39;{ born: number; name: string; }&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">poet</span>.<span style="color:#a6e22e">end</span>; 
</span></span></code></pre></div><p>对象类型是<code>TypeScript</code>理解<code>JavaScript</code>代码的核心概念。除<code>null</code>和<code>undefined</code>之外的每个值都有一组成员，因此<code>TypeScript</code>必须了解对象类型中的每个值，才能对其进行类型检查。</p>
<h3 id="declaring-object-types">Declaring Object Types</h3>
<p>从现有的对象中直接推断出类型固然是好的，但有时还是想要显式声明对象的类型。这时需要一种方式描述对象类型，将其与满足其类型的对象值区分开来。</p>
<p>对象类型使用与对象字面量相似的语法来描述，但<font color=LightSeaGreen>与属性名对应的是其值的类型而不是相应的值</font>。若对象类型变量出现赋值错误，显示的也是声明对象时的语法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">poetLater</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">poetLater</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">123</span>, <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;678&#39;</span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">poetLater</span>) <span style="color:#75715e">// { born: 123, name: &#39;678&#39; }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Type &#39;number&#39; is not assignable to type &#39;{ born: number; name: string; }&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">poetLater</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">123</span> 
</span></span></code></pre></div><h3 id="aliased-object-types">Aliased Object Types</h3>
<p>重复写类似<code>{ born: number; name: string; }</code>这样的对象类型很快就会让人厌烦，也容易出错。常见的做法是使用类型别名，为每个类型赋予一个新名字。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Poet</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">poetLater</span>: <span style="color:#66d9ef">Poet</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">poetLater</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">1935</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Sara Teasdale&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Type &#39;string&#39; is not assignable to type &#39;Poet&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">poetLater</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Emily Dickinson&#34;</span>; 
</span></span></code></pre></div><h2 id="structural-typing">Structural Typing</h2>
<p><code>TypeScript</code>的类型系统是<code>structural typed</code>的，这意味着<font color=LightSeaGreen>任何满足类型的值都可以用作该类型的值</font>。换句话说，当标注一个参数或变量是一个特定对象类型时，就是在告诉<code>TypeScript</code>，<font color=red>无论使用什么对象值，它们都需要具有这些属性</font>。</p>
<p>下面<code>WithFirstName</code>和<code>WithLastName</code>别名对象类型都只声明了一个字符串类型的成员。常量<code>hasBoth</code>恰好同时有这两种成员，因此它可以赋值给这两种别名对象类型中的任何一种变量：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">WithFirstName</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">firstName</span>: <span style="color:#66d9ef">string</span>; };
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">WithLastName</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">lastName</span>: <span style="color:#66d9ef">string</span>; };
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">hasBoth</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">firstName</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Lucille&#34;</span>, <span style="color:#a6e22e">lastName</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Clifton&#34;</span>,};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">withFirstName</span>: <span style="color:#66d9ef">WithFirstName</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">hasBoth</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">withLastName</span>: <span style="color:#66d9ef">WithLastName</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">hasBoth</span>;
</span></span></code></pre></div><p><code>Structural typing</code>与<code>Duck typing</code>不同，后者源于「如果它看起来像鸭子，叫起来像鸭子，那它可能就是鸭子」这句话。<code>JavaScript</code>是<code>Duck typing</code>，而<code>TypeScript</code>是<code>Structural typing</code>的。</p>
<ul>
<li><code>Structural typing</code>是指<font color=LightSeaGreen>有一个静态系统来检查类型</font>，在<code>TypeScript</code>中这个静态系统就是类型检查器。</li>
<li><code>Duck typing</code>是指使用之前不检查对象类型，直到运行时才检查类型。</li>
</ul>
<h3 id="usage-checking">Usage Checking</h3>
<p>当向显式标注为对象类型的变量赋值时，编译器将检查该值是否可赋值给这个对象类型。首先，对象值<font color=LightSeaGreen>必须包含对象类型的所有必需属性</font>。如果对象中缺少对象类型所需的任何成员，将会出现编译错误。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">FirstAndLastNames</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">first</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">last</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">hasBoth</span>: <span style="color:#66d9ef">FirstAndLastNames</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">first</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Sarojini&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">last</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Naidu&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Property &#39;last&#39; is missing in type &#39;{ first: string; }&#39; but required in type &#39;FirstAndLastNames&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">hasOnlyOne</span>: <span style="color:#66d9ef">FirstAndLastNames</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">first</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Sappho&#34;</span>}; 
</span></span></code></pre></div><p>当使用对象字面量赋值时，也不允许两者之间值的类型不匹配。<font color=red>对象类型既指定了所需属性的名称，也指定了这些属性对应值的类型</font>。如果对象的属性值类型不匹配，也会出现编译错误。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">TimeRange</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">start</span>: <span style="color:#66d9ef">Date</span>; };
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误: Type &#39;string&#39; is not assignable to type &#39;Date&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">hasStartString</span>: <span style="color:#66d9ef">TimeRange</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">start</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;1879-02-13&#34;</span>, 
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 下面是正确的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">TimeRange</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">start</span>: <span style="color:#66d9ef">Date</span>; };
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">hasStartString</span>: <span style="color:#66d9ef">TimeRange</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">start</span>: <span style="color:#66d9ef">new</span> Date(),
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">hasStartString</span>)
</span></span></code></pre></div><h3 id="excess-property-checking">Excess Property Checking</h3>
<p>如果一个变量声明为对象类型，且<font color=LightSeaGreen>初始值中的字段多于其类型所描述的字段时，将会出现编译错误</font>。因此，将变量显式标注为对象类型是一种让类型检查程序确保变量只有该类型的预期字段的方法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Poet</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">poetMatch</span>: <span style="color:#66d9ef">Poet</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">1928</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Maya Angelou&#34;</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">extraProperty</span>: <span style="color:#66d9ef">Poet</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">activity</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;walking&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">1935</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Mary Oliver&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Object literal may only specify known properties, and &#39;activity&#39; does not exist in type &#39;Poet&#39;.
</span></span></span></code></pre></div><p>需要注意的是，只有在<font color=red>标注为对象类型的位置创建的对象字面量才会触发多余属性检查</font>。提供已有常量或变量保存的对象字面量可以绕过多余属性检查，下面示例代码绕过了多余属性检查：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Poet</span> <span style="color:#f92672">=</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">number</span>;  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;  
</span></span><span style="display:flex;"><span>}  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">poetMatch</span>: <span style="color:#66d9ef">Poet</span> <span style="color:#f92672">=</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">1928</span>,  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Maya Angelou&#34;</span>  
</span></span><span style="display:flex;"><span>};  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">existingObject</span> <span style="color:#f92672">=</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">activity</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;walking&#34;</span>,  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">1935</span>, <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Mary Oliver&#34;</span>,  
</span></span><span style="display:flex;"><span>};  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">extraProperty</span>: <span style="color:#66d9ef">Poet</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">existingObject</span>  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">poetMatch</span>) <span style="color:#75715e">// { activity: &#39;walking&#39;, born: 1935, name: &#39;Mary Oliver&#39; }
</span></span></span></code></pre></div><p>在需要对象类型的<font color=red>任何地方创建新对象时，都会触发多余属性检查</font>。禁止多余的属性能确保代码整洁并按照我们期望的方式运行。未在对象类型中声明的多余属性通常是输入错误的属性名。</p>
<h3 id="nested-object-types">Nested Object Types</h3>
<p>由于<code>JavaScript</code>对象中可以嵌入其它对象成员，因此<code>TypeScript</code>的对象类型也必须能够在类型系统中表示嵌套的对象类型。语法与以前相同，但使用<code>{ ... }</code>对象类型来代替基础类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 创建别名类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Poem</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">firstName</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">lastName</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">poemMatch</span>: <span style="color:#66d9ef">Poem</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">firstName</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Sylvia&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">lastName</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Plath&#34;</span>,
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Lady Lazarus&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误:Object literal may only specify known properties, and &#39;name&#39; does not exist in type &#39;{ firstName: string; lastName: string; }&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">poemMismatch</span>: <span style="color:#66d9ef">Poem</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Sylvia Plath&#34;</span>,
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Tulips&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>声明<code>Poem</code>类型的另一种方法是将<code>author</code>属性提取到它的别名对象类型<code>Author</code>中。将对象类型中的嵌套类型提取到别名类型中，有助于出现编译错误时提供更详细的信息。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Author</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">firstName</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">lastName</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Poem</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span>: <span style="color:#66d9ef">Author</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Object literal may only specify known properties, and &#39;name&#39; does not exist in type &#39;Author&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">poemMismatch</span>: <span style="color:#66d9ef">Poem</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Sylvia Plath&#34;</span>, 
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Tulips&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>通常来说，为嵌套对象类型创建一个别名类型是个好主意，这样既能使代码更易读，也能使<code>TypeScript</code>的错误信息更易读。</p>
<h3 id="optional-properties">Optional Properties</h3>
<p>对象类型的属性不一定都是必需属性，可以在属性的类型标注的<code>:</code>前加上<code>?</code>来表示它是一个可选的属性。下面代码中，<code>Book</code>中的<code>author</code>属性是可选的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Book</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author?</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">ok</span>: <span style="color:#66d9ef">Book</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Rita Dove&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">80</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">normal</span>: <span style="color:#66d9ef">Book</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">80</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 不能缺少必需属性，否则出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Property &#39;pages&#39; is missing in type &#39;{ author: string; }&#39; but required in type &#39;Book&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">missing</span>: <span style="color:#66d9ef">Book</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Rita Dove&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>需要注意的是，可选属性与将属性的类型标注为包括<code>undefined</code>的联合类型是不同的。声明为可选属性，属性可以不存在。但使用<code>| undefined</code>声明的属性，其值必须存在，即使值是<code>undefined</code>的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Writers</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">editor?</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">hasRequired</span>: <span style="color:#66d9ef">Writers</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span>: <span style="color:#66d9ef">undefined</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 触发属性检查，author属性必须有，且必须提供值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">missingRequired</span>: <span style="color:#66d9ef">Writers</span> <span style="color:#f92672">=</span> {}; <span style="color:#75715e">//  Property &#39;author&#39; is missing in type &#39;{}&#39; but required in type &#39;Writers&#39;.
</span></span></span></code></pre></div><h2 id="unions-of-object-types">Unions of Object Types</h2>
<p>如果变量的初始值可能是多种对象类型之一，<code>TypeScript</code>将推断变量的类型为对象类型的联合。该联合类型为每种可能的类型提供一个成分。类型上的每种可能属性都将出现在每个组成元素中，尽管它们<font color=LightSeaGreen>在没有初始值的任何类型中都是可选类型</font>。</p>
<h3 id="inferred-object-type-unions">Inferred Object-Type Unions</h3>
<p>下面代码中，常量<code>poem</code>值一定有<code>name</code>属性，可能有<code>pages</code>或<code>rhymes</code>属性。常量<code>poem</code>的类型被推断为<code>{name: string, pages: number, rhymes?: undefined} | {name: string, rhymes: boolean, pages?: undefined}</code> ：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// poem的类型被推断为{name: string, pages: number, rhymes?: undefined} | {name: string, rhymes: boolean, pages?: undefined}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">poem</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;The Double Image&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">7</span>
</span></span><span style="display:flex;"><span>} <span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Her Kind&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">rhymes</span>: <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">name</span>  <span style="color:#75715e">// string 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">pages</span>; <span style="color:#75715e">// number 或 undefined
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">rhymes</span>; <span style="color:#75715e">// booleans 或 undefined
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">name</span>, <span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">pages</span>, <span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">rhymes</span>, <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">poem</span>) <span style="color:#75715e">// 可能的结果:The Double Image 7 undefined object
</span></span></span></code></pre></div><h3 id="explicit-object-type-unions">Explicit Object-Type Unions</h3>
<p>也可以通过对象类型的联合来更明确地标注对象类型。这样做需要写更多的代码，好处是可以对对象类型有更多的控制。需要注意的是，如果是对象类型的联合，则<font color=red>只允许访问存在于联合类型所有子类型上的属性</font>。这与上面将变量推断为对象类型的联合有明显的区别：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">PoemWithPages</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">PoemWithRhymes</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">rhymes</span>: <span style="color:#66d9ef">boolean</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Poem</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">PoemWithPages</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">PoemWithRhymes</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">poem</span>: <span style="color:#66d9ef">Poem</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span>  <span style="color:#f92672">?</span> {<span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;The Double Image&#34;</span>, <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">7</span>} <span style="color:#f92672">:</span> {<span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Her Kind&#34;</span>, <span style="color:#a6e22e">rhymes</span>: <span style="color:#66d9ef">true</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// OK
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">name</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Property &#39;pages&#39; does not exist on type &#39;Poem&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">pages</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Property &#39;rhymes&#39; does not exist on type &#39;Poem&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">rhymes</span>;
</span></span></code></pre></div><h3 id="narrowing-object-types">Narrowing Object Types</h3>
<p>如果类型检查器发现在某个位置的代码只有在联合类型值包含特定属性的情况下才能运行，那么会将联合类型窄化到只包含该属性的子类型。换句话说，如果在代码中检查对象，类型窄化功能也适用于对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#e6db74">&#34;pages&#34;</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">poem</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">pages</span>)
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">rhymes</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>请注意，<code>TypeScript</code>不允许使用像<code>if (poem.pages)</code>这样的真值检查。<font color=red>试图访问可能不存在的对象属性会被视为类型错误，即使使用的方式看起来像是类型保护</font>。</p>
<h3 id="discriminated-unions">Discriminated Unions</h3>
<p><code>JavaScript</code>和<code>TypeScript</code>中另一种流行的联合类型对象形式是在对象上设置一个属性，用于指示对象具体是哪种类型。这种类型被称为判别联合（<code>discriminated union</code>），指示对象类型的属性就是<code>discriminant</code>。<code>TypeScript</code>对<code>discriminant</code>属性进行类型保护的代码执行类型窄化。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">PoemWithPages</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;pages&#39;</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">PoemWithRhymes</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">rhymes</span>: <span style="color:#66d9ef">boolean</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;rhymes&#39;</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Poem</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">PoemWithPages</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">PoemWithRhymes</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">poem</span>: <span style="color:#66d9ef">Poem</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;The Double Image&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">7</span>, 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;pages&#34;</span>
</span></span><span style="display:flex;"><span>} <span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Her Kind&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">rhymes</span>: <span style="color:#66d9ef">true</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;rhymes&#34;</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">poem</span>.<span style="color:#66d9ef">type</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;pages&#34;</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`It&#39;s got pages: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">pages</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`It rhymes: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">rhymes</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="intersection-types">Intersection Types</h2>
<p><code>TypeScript</code>中的联合类型表示一个值的类型可能是两个或多个不同类型中的一个。<code>TypeScript</code>允许同时表示多种类型的交集，即交叉类型。交叉类型通常与别名对象类型一起使用，以创建结合多个现有类型的新类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Artwork</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">genre</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Writing</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">WrittenArt</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Artwork</span> <span style="color:#f92672">&amp;</span> <span style="color:#a6e22e">Writing</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 必须同时具有name,pages和genre属性
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">writtenAndArt</span>: <span style="color:#66d9ef">WrittenArt</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;test&#39;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">genre</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;man&#39;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">123</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>交叉类型可以与联合类型结合，某些场景有助于在一种类型中描述<code>discriminated unions</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ShortPoem</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">author</span>: <span style="color:#66d9ef">string</span> } <span style="color:#f92672">&amp;</span> (<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">kigo</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;haiku&#34;</span>;
</span></span><span style="display:flex;"><span>} <span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">meter</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;villanelle&#34;</span>;
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">morningGlory</span>: <span style="color:#66d9ef">ShortPoem</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Fukuda Chiyo-ni&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">kigo</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Morning Glory&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;haiku&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 下面会出现编译错误： Type &#39;{ author: string; type: &#34;villanelle&#34;; }&#39; is not assignable to type &#39;{ author: string; } &amp; { meter: number; type: &#34;villanelle&#34;; }&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">oneArt</span>: <span style="color:#66d9ef">ShortPoem</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Elizabeth Bishop&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;villanelle&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="dangers-of-intersection-types">Dangers of Intersection Types</h3>
<p>交叉类型是一个有用的概念，但使用时很容易让自己或<code>TypeScript</code>编译器感到困惑。建议<font color=LightSeaGreen>在使用交叉类型时尽量简化代码</font>。</p>
<p>当创建了复杂的交叉类型（例如与联合类型交叉）时，赋值错误信息就会变得难以理解。这是<code>TypeScript</code>的类型系统以及一般的类型化编程语言的一个共同主题：创建的类型越复杂，就越难理解来自类型检查器的错误信息。</p>
<p>以前面代码片段中的<code>ShortPoem</code>为例，如果将该类型拆分为一系列别名对象类型，<code>TypeScript</code>就可以打印这些别名，可读性就会大大提高：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ShortPoemBase</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span>: <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Haiku</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">ShortPoemBase</span> <span style="color:#f92672">&amp;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">kigo</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;haiku&#34;</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Villanelle</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">ShortPoemBase</span> <span style="color:#f92672">&amp;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">meter</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;villanelle&#34;</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ShortPoem</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Haiku</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">Villanelle</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Type &#39;{ author: string; type: &#34;villanelle&#34;; }&#39; is not assignable to type &#39;ShortPoem&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">oneArt</span>: <span style="color:#66d9ef">ShortPoem</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Elizabeth Bishop&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;villanelle&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="never">never</h3>
<p>交叉类型很容易被滥用，创建出一种不可能的类型。基本类型不能作为交叉类型组合在一起，因为一个值不可能同时是多个基本类型（除了<code>null</code>和<code>undefined</code>）。如果尝试将两个基本类型交叉在一起，就会产生由关键字<code>never</code>表示的<code>never</code>类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">NotPossible</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">string</span>
</span></span></code></pre></div><p>类型<code>never</code>称为底层类型或空类型。<font color=red>底层类型是指没有可能的值，也是无法到达的类型</font>。不能向类型为底层类型的位置提供任何类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">NotPossible</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Type &#39;number&#39; is not assignable to type &#39;never&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">notNumber</span>: <span style="color:#66d9ef">NotPossible</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; 
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Type &#39;number&#39; is not assignable to type &#39;never&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">notString</span>: <span style="color:#66d9ef">never</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>; 
</span></span></code></pre></div><p>多数<code>TypeScript</code>项目很少使用<code>never</code>类型，<code>never</code>偶尔会出现在代码中表示不可能的状态。但多数情况下，很可能是误用交叉类型造成的错误。</p>
<h1 id="functions">Functions</h1>
<blockquote>
<p>前面介绍了如何使用类型标注来表明变量类型。现在，可以看到如何对函数参数和返回类型进行同样的标注。</p>
</blockquote>
<h2 id="function-parameters">Function Parameters</h2>
<p>下面定义了一个函数，参数为<code>song</code>，在函数体中打印了这个参数的值。在声明该函数时参数并没有显式地标注类型，那么<code>TypeScript</code>会认为这个参数的类型是<code>any</code>类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">sing</span>(<span style="color:#a6e22e">song</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Singing: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span><span style="color:#e6db74">}</span><span style="color:#e6db74">!`</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果编译选项设置的是严格模式，上面代码运行会出现编译错误：<code>Parameter 'song' implicitly has an 'any' type</code>。与变量一样，允许使用类型标注函数参数的类型。可以使用<code>: string</code>来告诉编译器参数<code>song</code>的类型是字符串：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">sing</span>(<span style="color:#a6e22e">song</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Singing: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span><span style="color:#e6db74">}</span><span style="color:#e6db74">!`</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="required-parameters">Required Parameters</h3>
<p><code>JavaScript</code>函数允许使用任意数量的实参(<code>arguments</code>)调用函数，而<code>TypeScript</code><font color=LightSeaGreen>假定函数中声明的所有参数都是必需的</font>。如果使用错误的实参数目调用函数，将会出现编译错误。</p>
<p>如果函数调用的实参过少或过多，<code>TypeScript</code>的实参计数就会发挥作用。下面函数<code>singTwo</code>要求有两个参数，因此传递<code>1</code>个或<code>3</code>个参数都是不允许的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">singTwo</span>(<span style="color:#a6e22e">first</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">second</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">first</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> / </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">second</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Expected 2 arguments, but got 1.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">singTwo</span>(<span style="color:#e6db74">&#34;Ball and Chain&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Expected 2 arguments, but got 3.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">singTwo</span>(<span style="color:#e6db74">&#34;Go Your Own Way&#34;</span>, <span style="color:#e6db74">&#34;The Chain&#34;</span>, <span style="color:#e6db74">&#34;Dreams&#34;</span>);
</span></span></code></pre></div><p><font color="#e36c09">强制要求向函数提供必需的参数</font>，有助于执行类型安全。如果不能确保这些参数值都存在，可能会导致代码出现意外行为。</p>
<p>形参（<code>parameter</code>）是指函数声明的预期参数。实参（<code>arguments</code>）是指函数调用时提供给形参的值。在前面的示例中，<code>first</code>和<code>second</code>是形参，而<code>&quot;Dream&quot;</code>等字符串是实参。</p>
<h3 id="optional-parameters">Optional Parameters</h3>
<p><code>TypeScript</code>允许将形参标注为可选参数，即在其类型标注的<code>:</code>之前添加<code>?</code>（类似于对象类型的可选属性）。函数调用不需要向可选参数提供实参。因此，它们的类型总是以<code>| undefined</code>作为联合类型。</p>
<p>下面函数中，<code>singer</code>形参被标记为可选参数。它的类型是<code>string | undefined</code>，函数的调用者无需提供实参（此时其值为<code>undefined</code>）。如果主动提供了<code>singer</code>，它可能是一个字符串值或<code>undefined</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// singer为可选参数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">announceSong</span>(<span style="color:#a6e22e">song</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">singer?</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Song: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">singer</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Singer: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">singer</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">announceSong</span>(<span style="color:#e6db74">&#34;Greensleeves&#34;</span>); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">announceSong</span>(<span style="color:#e6db74">&#34;Greensleeves&#34;</span>, <span style="color:#66d9ef">undefined</span>); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">announceSong</span>(<span style="color:#e6db74">&#34;Chandelier&#34;</span>, <span style="color:#e6db74">&#34;Sia&#34;</span>); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">Song</span>: <span style="color:#66d9ef">Greensleeves</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Song</span>: <span style="color:#66d9ef">Greensleeves</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Song</span>: <span style="color:#66d9ef">Chandelier</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Singer</span>: <span style="color:#66d9ef">Sia</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">announceSong</span>(<span style="color:#a6e22e">song</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">singer?</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Song: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">singer</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Singer: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">singer</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Singer: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">singer</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">announceSong</span>(<span style="color:#e6db74">&#34;test&#34;</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">Song</span>: <span style="color:#66d9ef">test</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Singer</span>: <span style="color:#66d9ef">undefined</span> <span style="color:#75715e">// 未传入参数时，值为undefined
</span></span></span></code></pre></div><p>可选参数与包含<code>| undefined</code>的联合类型参数不同。没有用<code>?</code>标记为可选的参数必需提供实参，即使其值是<code>undefined</code>。函数的<font color=red>可选参数必须是最后一个参数</font>，若将可选参数放在必需参数前，会出现编译错误。</p>
<h3 id="default-parameters">Default Parameters</h3>
<p>如果参数有默认值且没有指明类型，将会根据默认值推断参数的类型。下面的<code>rateSong</code>函数中，参数<code>rating</code>被推断为<code>number</code>类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">rateSong</span>(<span style="color:#a6e22e">song</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">rating</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> gets </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">rating</span><span style="color:#e6db74">}</span><span style="color:#e6db74">/5 stars!`</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">rateSong</span>(<span style="color:#e6db74">&#34;Photograph&#34;</span>); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">rateSong</span>(<span style="color:#e6db74">&#34;Set Fire to the Rain&#34;</span>, <span style="color:#ae81ff">5</span>); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">rateSong</span>(<span style="color:#e6db74">&#34;Set Fire to the Rain&#34;</span>, <span style="color:#66d9ef">undefined</span>); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Argument of type &#39;string&#39; is not assignable to parameter of type &#39;number&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">rateSong</span>(<span style="color:#e6db74">&#34;At Last!&#34;</span>, <span style="color:#e6db74">&#34;100&#34;</span>); 
</span></span></code></pre></div><p>具有默认值的参数<font color="#e36c09">如果不位于形参列表的末尾，调用时则不能省略该参数，如果要触发默认值，必须显式地传入<code>undefined</code></font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">hello3</span>(<span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>, <span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">hello3</span>(<span style="color:#66d9ef">undefined</span>, <span style="color:#ae81ff">890</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">3</span> <span style="color:#ae81ff">890</span>
</span></span></code></pre></div><h3 id="rest-parameters">Rest Parameters</h3>
<p>在<code>JavaScript</code>中<code>...</code>展开操作符可以放在函数声明的<font color="#e36c09">最后一个参数上</font>，表示从该参数开始传递给函数的所有<code>&quot;rest&quot;</code>参数都应存储在一个数组中。</p>
<p>在<code>TypeScript</code>中允许标注<code>rest</code>参数的类型，与普通参数类似，只是在末尾添加了<code>[]</code>语法，以表示这是一个参数数组。下面函数<code>singAllTheSongs</code>允许接受0个或多个字符串类型的实参：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">singAllTheSongs</span>(<span style="color:#a6e22e">singer</span>: <span style="color:#66d9ef">string</span>, ...<span style="color:#a6e22e">songs</span>: <span style="color:#66d9ef">string</span>[]) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">song</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">songs</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, by </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">singer</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">singAllTheSongs</span>(<span style="color:#e6db74">&#34;Alicia Keys&#34;</span>); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">singAllTheSongs</span>(<span style="color:#e6db74">&#34;Lady Gaga&#34;</span>, <span style="color:#e6db74">&#34;Bad Romance&#34;</span>, <span style="color:#e6db74">&#34;Just Dance&#34;</span>, <span style="color:#e6db74">&#34;Poker Face&#34;</span>); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">Bad</span> <span style="color:#a6e22e">Romance</span>, <span style="color:#a6e22e">by</span> <span style="color:#a6e22e">Lady</span> <span style="color:#a6e22e">Gaga</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Just</span> <span style="color:#a6e22e">Dance</span>, <span style="color:#a6e22e">by</span> <span style="color:#a6e22e">Lady</span> <span style="color:#a6e22e">Gaga</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Poker</span> <span style="color:#a6e22e">Face</span>, <span style="color:#a6e22e">by</span> <span style="color:#a6e22e">Lady</span> <span style="color:#a6e22e">Gaga</span>
</span></span></code></pre></div><h2 id="return-types">Return Types</h2>
<p>如果知道函数的所有可能返回值，编译器就能推断出函数返回什么类型。下面代码中，<code>TypeScript</code>推断函数<code>singSongs</code>返回一个<code>number</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">singSongs</span>(<span style="color:#a6e22e">songs</span>: <span style="color:#66d9ef">string</span>[]) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">song</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">songs</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">songs</span>.<span style="color:#a6e22e">length</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果函数包含多个不同的返回语句，<code>TypeScript</code>将返回类型<font color="#e36c09">推断为所有可能返回类型的联合</font>。下面函数<code>getSongAt</code>的返回类型将被推断为<code>string | undefined</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getSongAt</span>(<span style="color:#a6e22e">songs</span>: <span style="color:#66d9ef">string</span>[], <span style="color:#a6e22e">index</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">index</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">songs</span>.<span style="color:#a6e22e">length</span> <span style="color:#f92672">?</span> <span style="color:#a6e22e">songs</span>[<span style="color:#a6e22e">index</span>] <span style="color:#f92672">:</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="explicit-return-types">Explicit Return Types</h3>
<p>与变量一样，通常不建议使用类型标注来显式声明函数的返回值类型。不过，在某些情况下，显式类型标注对函数很有用：</p>
<ul>
<li>可能希望强制具有多种可能返回值的函数始终返回相同类型的值。</li>
<li><code>TypeScript</code>拒绝尝试推理递归函数的返回类型。</li>
<li>加快超大型项目中的<code>TypeScript</code>类型检查速度。</li>
</ul>
<p>函数声明的返回类型标注位于参数列表的后圆括号之后。对于函数声明来说，这恰好位于左大括号<code>{</code>之前：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">singSongsRecursive</span>(<span style="color:#a6e22e">songs</span>: <span style="color:#66d9ef">string</span>[], <span style="color:#a6e22e">count</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">songs</span>.<span style="color:#a6e22e">length</span> <span style="color:#f92672">?</span> <span style="color:#a6e22e">singSongsRecursive</span>(<span style="color:#a6e22e">songs</span>.<span style="color:#a6e22e">slice</span>(<span style="color:#ae81ff">1</span>), <span style="color:#a6e22e">count</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">:</span> <span style="color:#a6e22e">count</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>对于箭头函数（也称为<code>lambdas</code>表达式）来说，返回类型标注正好位于<code>=&gt;</code>之前：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">singSongsRecursive</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">songs</span>: <span style="color:#66d9ef">string</span>[], <span style="color:#a6e22e">count</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">songs</span>.<span style="color:#a6e22e">length</span> <span style="color:#f92672">?</span> <span style="color:#a6e22e">singSongsRecursive</span>(<span style="color:#a6e22e">songs</span>.<span style="color:#a6e22e">slice</span>(<span style="color:#ae81ff">1</span>), <span style="color:#a6e22e">count</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">:</span> <span style="color:#a6e22e">count</span>;
</span></span></code></pre></div><p>如果函数体中返回语句对应的值<font color="#e36c09">不能赋值给函数标注的返回类型</font>，将会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getSongRecordingDate</span>(<span style="color:#a6e22e">song</span>: <span style="color:#66d9ef">string</span>)<span style="color:#f92672">:</span> Date <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">switch</span> (<span style="color:#a6e22e">song</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;Strange Fruit&#34;</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> Date(<span style="color:#e6db74">&#39;April 20, 1939&#39;</span>); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;Greensleeves&#34;</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 编译错误: Type &#39;string&#39; is not assignable to type &#39;Date&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;unknown&#34;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">undefined</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="function-types">Function Types</h2>
<p><code>JavaScript</code>允许将函数作为值传递。这意味着需要一种方法来声明用于存放函数类型的参数或变量。<font color=LightSeaGreen>函数类型标注语法与箭头函数类似，只是用类型代替了函数体</font>。下面变量<code>nothingInGivesString</code>的类型标注描述了一个无参数，返回字符串值的函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">nothingInGivesString</span><span style="color:#f92672">:</span> () <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">string</span>;
</span></span></code></pre></div><p>下面变量<code>inputAndOutput</code>的类型是一个函数，这个函数有一个<code>string[]</code>类型的形参，一个可选的形参<code>count</code>，并且返回一个<code>number</code>值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">inputAndOutput</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">songs</span>: <span style="color:#66d9ef">string</span>[], <span style="color:#a6e22e">count?</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">number</span>;
</span></span></code></pre></div><p>函数类型常用于描述回调：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">runOnSongs</span>(<span style="color:#a6e22e">getSongAt</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">index</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">songs</span>.<span style="color:#a6e22e">length</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">getSongAt</span>(<span style="color:#a6e22e">i</span>));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getSongAt</span>(<span style="color:#a6e22e">index</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">songs</span>[<span style="color:#a6e22e">index</span>]<span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">runOnSongs</span>(<span style="color:#a6e22e">getSongAt</span>); <span style="color:#75715e">// Ok
</span></span></span></code></pre></div><h3 id="function-type-parentheses">Function Type Parentheses</h3>
<p>函数类型可以放置在任何需要类型标注的地方，包括联合类型。在联合类型中，可以<font color="#e36c09">使用圆括号来表示哪一部分是函数返回值哪一部分是联合类型的函数子类型</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// Type is a function that returns a union: string | undefined
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">returnsStringOrUndefined</span><span style="color:#f92672">:</span> () <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type is either undefined or a function that returns a string 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">maybeReturnsString</span><span style="color:#f92672">:</span> (() <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">string</span>) <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>;
</span></span></code></pre></div><h3 id="parameter-type-inferences">Parameter Type Inferences</h3>
<p>如果必须为编写的每个函数（包括用作参数的内联函数）声明参数类型，将会非常麻烦。幸运的是，可以推断出函数中的参数类型，即使用声明时相同位置的参数类型。</p>
<p>下面示例代码中，变量<code>singer</code>是一个接收字符串类型参数的函数，因此赋值给<code>singer</code>的函数中的<code>song</code>参数也是一个字符串类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">singer</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">song</span>: <span style="color:#66d9ef">string</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type of song: string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">singer</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">song</span>) { 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">`Singing: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span>.<span style="color:#a6e22e">toUpperCase</span>()<span style="color:#e6db74">}</span><span style="color:#e6db74">!`</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>作为实参传递给函数类型形参的函数，其参数类型也能被推断出来。下面示例代码中，参数<code>song</code>和<code>index</code>被推断为<code>string</code>和<code>number</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">songs</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;Call Me&#34;</span>, <span style="color:#e6db74">&#34;Jolene&#34;</span>, <span style="color:#e6db74">&#34;The Chain&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">songs</span>.<span style="color:#a6e22e">forEach</span>((<span style="color:#a6e22e">song</span>, <span style="color:#a6e22e">index</span>) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> is at index </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">index</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>});
</span></span></code></pre></div><h3 id="function-type-aliases">Function Type Aliases</h3>
<p>创建类型命名的<code>type</code>也可以用于函数，下面代码中类型别名<code>StringToNumber</code>是一个接收<code>string</code>并返回<code>number</code>的函数，这意味着别名类型<code>StringToNumber</code>可以用来标注函数变量的类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">StringToNumber</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">string</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">stringToNumber</span>: <span style="color:#66d9ef">StringToNumber</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// input被推断为字符串类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">stringToNumber</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">input</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">input</span>.<span style="color:#a6e22e">length</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">stringToNumber</span>(<span style="color:#e6db74">&#39;1233&#39;</span>))  <span style="color:#75715e">// 4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">stringToNumber</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">input</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">123</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">stringToNumber</span>(<span style="color:#e6db74">&#39;3455&#39;</span>)) <span style="color:#75715e">// 123
</span></span></span></code></pre></div><p>类似地，函数的类型别名也可以用于函数形参的声明：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">NumberToString</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">usesNumberToString</span>(<span style="color:#a6e22e">numberToString</span>: <span style="color:#66d9ef">NumberToString</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`The string is: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">numberToString</span>(<span style="color:#ae81ff">1234</span>)<span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="more-return-types">More Return Types</h2>
<p>有些函数并不返回任何值，它们要么没有返回语句，要么只有无返回值的<code>return</code>语句。<code>TypeScript</code>允许使用<code>void</code>关键字来说明这种不返回任何值的函数的返回类型。返回类型为<code>void</code>的函数不能返回值，下面<code>logSong</code>函数被声明为返回<code>void</code>，因此不允许有返回值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">logSong</span>(<span style="color:#a6e22e">song</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">void</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">song</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 出现编译错误：Type &#39;boolean&#39; is not assignable to type &#39;void&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 无返回值的函数不能返回值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>; 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>void</code>可以作为函数类型标注中的返回类型。在函数类型标注时使用<code>void</code>时，<font color=Blue>表示函数的任何返回值都将被忽</font>。下面代码中，<code>songLogger</code>变量代表了一个函数，它接受一个<code>string</code>参数，并且不返回值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">songLogger</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">song</span>: <span style="color:#66d9ef">string</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">void</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">songLogger</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">song</span>) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">songLogger</span>(<span style="color:#e6db74">&#34;Heart of Glass&#34;</span>); <span style="color:#75715e">// Ok
</span></span></span></code></pre></div><p>请注意，尽管<code>JavaScript</code>函数在没有返回值的情况下会默认返回<code>undefined</code>，但<font color="#e36c09"><code>void</code>并不等同于<code>undefined</code>。<code>void</code>意味着函数的返回值将被忽略，而<code>undefined</code>则是要返回的字面量</font>。如果尝试将<code>void</code>类型的值赋给类型包括<code>undefined</code>的变量，将会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">returnsVoid() {</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">lazyValue</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Type &#39;void&#39; is not assignable to type &#39;string | undefined&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">lazyValue</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">returnsVoid</span>(); 
</span></span></code></pre></div><p>返回值<code>undefined</code>和<code>void</code>之间的区别，对于忽略传递到形参返回值类型标注为<code>void</code>的实参函数的任何返回值特别有用。例如，数组的内置<code>forEach</code>方法接收返回<code>void</code>的函数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// forEach的定义
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">forEach</span>(<span style="color:#a6e22e">callbackfn</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">T</span>, <span style="color:#a6e22e">index</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">array</span>: <span style="color:#66d9ef">T</span>[]) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">void</span>, <span style="color:#a6e22e">thisArg?</span>: <span style="color:#66d9ef">any</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">void</span>;
</span></span></code></pre></div><p>下面<code>saveRecords</code>函数中，<code>records.push(record)</code>返回一个数字（数组<code>push()</code>方法的返回值），但仍允许作为传递给<code>newRecords.forEach</code>箭头函数的返回值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">saveRecords</span>(<span style="color:#a6e22e">newRecords</span>: <span style="color:#66d9ef">string</span>[]) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">newRecords</span>.<span style="color:#a6e22e">forEach</span>(<span style="color:#a6e22e">record</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">records</span>.<span style="color:#a6e22e">push</span>(<span style="color:#a6e22e">record</span>));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">saveRecords</span>([<span style="color:#e6db74">&#39;21&#39;</span>, <span style="color:#e6db74">&#39;Come On Over&#39;</span>, <span style="color:#e6db74">&#39;The Bodyguard&#39;</span>])
</span></span></code></pre></div><p><code>void</code>类型不属于<code>JavaScript</code>，是<code>TypeScript</code>的一个关键字，用于声明函数的返回类型。请记住，<font color=red>它表示函数的返回值不打算被使用，而不是表示返回值可以被返回</font>。</p>
<h3 id="never-returns">Never Returns</h3>
<p>有些函数不仅不返回值，而且根本不返回。永不返回的函数是那些总是抛出错误或运行无限循环的函数（通常是故意的）。</p>
<p>如果一个函数永远不会返回，那么显式添加一个<code>: never</code>类型标注表示调用该函数后的任何代码都不会运行。下面<code>fail</code>函数只抛出一个错误，它有助于<code>TypeScript</code>的控制流分析，将参数<code>param</code>窄化为<code>string</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">fail</span>(<span style="color:#a6e22e">message</span>: <span style="color:#66d9ef">string</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">never</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> Error(<span style="color:#e6db74">`Invariant failure: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">message</span><span style="color:#e6db74">}</span><span style="color:#e6db74">.`</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">workWithUnsafeParam</span>(<span style="color:#a6e22e">param</span>: <span style="color:#66d9ef">unknown</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">param</span> <span style="color:#f92672">!==</span> <span style="color:#e6db74">&#34;string&#34;</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fail</span>(<span style="color:#e6db74">`param should be a string, not </span><span style="color:#e6db74">${</span><span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">param</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">param</span>.<span style="color:#a6e22e">toUpperCase</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>需要注意的是，返回类型<code>void</code>指的是函数不返回任何内容，而<code>never</code>指的是函数执行后永远不返回内容。</p>
<h2 id="function-overloads">Function Overloads</h2>
<p>有些<code>JavaScript</code>函数可以使用完全不同的实参来调用，而这些实参集不能只用可选参数或可变参数来表示。这些函数可以使用一种名为重载签名（<code>overload signatures</code>）的语法来描述：<font color="#f79646">在最终实现签名和函数体之前，多次声明不同版本的函数名称、形参和返回类型</font>。</p>
<p>在决定是否对重载函数的调用发出语法错误时，<code>TypeScript</code>只会查看函数的重载签名。实现签名只用于函数的内部逻辑。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">createDate</span>(<span style="color:#a6e22e">timestamp</span>: <span style="color:#66d9ef">number</span>)<span style="color:#f92672">:</span> Date;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">createDate</span>(<span style="color:#a6e22e">month</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">day</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">year</span>: <span style="color:#66d9ef">number</span>)<span style="color:#f92672">:</span> Date;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">createDate</span>(<span style="color:#a6e22e">monthOrTimestamp</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">day?</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">year?</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">day</span> <span style="color:#f92672">===</span> <span style="color:#66d9ef">undefined</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">year</span> <span style="color:#f92672">===</span> <span style="color:#66d9ef">undefined</span> <span style="color:#f92672">?</span> <span style="color:#66d9ef">new</span> Date(<span style="color:#a6e22e">monthOrTimestamp</span>) <span style="color:#f92672">:</span> <span style="color:#66d9ef">new</span> Date(<span style="color:#a6e22e">year</span>, <span style="color:#a6e22e">monthOrTimestamp</span>, <span style="color:#a6e22e">day</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">createDate</span>(<span style="color:#ae81ff">554356800</span>); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">createDate</span>(<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">27</span>, <span style="color:#ae81ff">1987</span>); <span style="color:#75715e">// Ok
</span></span></span></code></pre></div><p>重载签名与类型系统的其它语法一样，在编译<code>TypeScript</code>输出为<code>JavaScript</code>后会被删除。函数重载通常是复杂、难以描述的函数类型的最后手段。<font color="#e36c09">一般来说，最好保持函数简单，尽可能避免使用函数重载</font>。</p>
<h3 id="call-signature-compatibility">Call-Signature Compatibility</h3>
<p>重载函数的实现所使用的签名就是该函数的实现所使用的参数类型和返回类型。因此，<font color="#e36c09">函数重载签名中的返回类型和每个参数都必须可以可赋值给实现签名中同一索引处的参数</font>。</p>
<p>换句话说，重载函数的<font color="#0070c0">实现签名必须与所有重载签名兼容</font>。下面示例代码中，因为实现签名和所有的重载签名不兼容，会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">format</span>(<span style="color:#a6e22e">data</span>: <span style="color:#66d9ef">string</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">format</span>(<span style="color:#a6e22e">data</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">needle</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">haystack</span>: <span style="color:#66d9ef">string</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// This overload signature is not compatible with its implementation signature.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">format</span>(<span style="color:#a6e22e">getData</span><span style="color:#f92672">:</span> () <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">string</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">format</span>(<span style="color:#a6e22e">data</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">needle?</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">haystack?</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">needle</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">haystack</span> <span style="color:#f92672">?</span> <span style="color:#a6e22e">data</span>.<span style="color:#a6e22e">replace</span>(<span style="color:#a6e22e">needle</span>, <span style="color:#a6e22e">haystack</span>) <span style="color:#f92672">:</span> <span style="color:#a6e22e">data</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="arrays">Arrays</h1>
<p><code>TypeScript</code>通过记住数组中最初的数据类型，并只允许数组对该数据类型进行操作，从而遵守了每个数组只使用一种数据类型的最佳实践。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">warriors</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;Artemisia&#34;</span>, <span style="color:#e6db74">&#34;Boudica&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Ok: &#34;Zenobia&#34; is a string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">warriors</span>.<span style="color:#a6e22e">push</span>(<span style="color:#e6db74">&#34;Zenobia&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Argument of type &#39;boolean&#39; is not assignable to parameter of type &#39;string&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">warriors</span>.<span style="color:#a6e22e">push</span>(<span style="color:#66d9ef">true</span>);
</span></span></code></pre></div><p>可以认为根据数组的初始成员推断数组类型与根据变量的初始值推断变量类型类似。<code>TypeScript</code>通常会尝试从赋值来推断预期类型，数组也不例外。</p>
<h2 id="array-types">Array Types</h2>
<p>如同其它变量声明，数组变量声明时也可以不初始化。同样地，<span style="background:#ff4d4f">如果数组变量未初始化之前就使用会出现编译错误</span>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">arrayOfNumbers</span>: <span style="color:#66d9ef">number</span>[];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译报错： Variable &#39;arrayOfNumbers&#39; is used before being assigned.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">arrayOfNumbers</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">arrayOfNumbers</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">23</span>, <span style="color:#ae81ff">42</span>];
</span></span></code></pre></div><h3 id="array-and-function-types">Array and Function Types</h3>
<p>涉及数组和函数类型时<font color="#245bdb">可能需要使用圆括号来区分数组类型中的内容</font>。圆括号可用于指明类型中哪一部分是函数的返回值，哪一部分是数组内容。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// Type is a function that returns an array of strings
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">createStrings</span><span style="color:#f92672">:</span> () <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">string</span>[];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type is an array of functions that each return a string 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">stringCreators</span><span style="color:#f92672">:</span> (() <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">string</span>)[];
</span></span></code></pre></div><h3 id="union-type-arrays">Union-Type Arrays</h3>
<p>可以使用联合类型来标注数组中元素是多个可能的类型。将数组类型与联合类型一起使用时，可能<font color="#de7802">需要使用圆括号来指明中哪一部分是数组的内容，哪一部分是联合类型的内容</font>。在数组联合类型中使用圆括号非常重要，以下两种类型并不相同：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// Type is either a number or an array of strings
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">stringOrArrayOfNumbers</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">number</span>[];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type is an array of elements that are each either a number or a string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">arrayOfStringOrNumbers</span><span style="color:#f92672">:</span> (<span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">number</span>)[];
</span></span></code></pre></div><p>如果同一个数组中的元素类型不同，<code>TypeScript</code>就会从数组的声明中推断它是一个<code>union</code>类型数组。<font color=red>换句话说，数组元素的类型是数组中所有可能元素类型的联合</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// namesMaybe&#39;s type is (string | undefined)[]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">namesMaybe</span> <span style="color:#f92672">=</span> [
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;Aqualtune&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;Blenda&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">undefined</span>,
</span></span><span style="display:flex;"><span>];
</span></span></code></pre></div><h3 id="evolving-any-arrays">Evolving Any Arrays</h3>
<p>若初始值为空的数组变量不加上类型声明，数组类型被认为是<code>any[]</code>。这意味着该数组可以接收任何内容，允许添加可能不正确的值，这会抵消类型检查器的好处。如果编译器开启了严格类型检查，下面代码会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// Type: any[]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">values</span> <span style="color:#f92672">=</span> [];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: string[]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">values</span>.<span style="color:#a6e22e">push</span>(<span style="color:#e6db74">&#39;&#39;</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: (number | string)[]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">values</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span></code></pre></div><p>如同变量，如果允许数组是<code>any</code>类型，部分地违背了类型检查的目的。当知道变量应该是什么类型时，它就会工作得更好。</p>
<h3 id="multidimensional-arrays">Multidimensional Arrays</h3>
<p>一个二维数组，有两个<code>[]</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 声明二维数组，下面两种方式均可以
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">arrayOfArraysOfNumbers1</span>: <span style="color:#66d9ef">number</span>[][];  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">arrayOfArraysOfNumbers2</span><span style="color:#f92672">:</span> (<span style="color:#66d9ef">number</span>[])[];  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">arrayOfArraysOfNumbers1</span> <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>], [<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">6</span>], [<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">9</span>],];  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">arrayOfArraysOfNumbers2</span> <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>], [<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">8</span>], [<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">11</span>],];  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">arrayOfArraysOfNumbers1</span>, <span style="color:#a6e22e">arrayOfArraysOfNumbers2</span>)
</span></span></code></pre></div><p>三维数组有3个<code>[]</code>，四维数组有4个<code>[]</code>，5个数组有5个<code>[]</code>。</p>
<h2 id="array-members">Array Members</h2>
<p><code>TypeScript</code>基于索引访问数组中的元素，下面常量<code>defenders</code>的类型为<code>string []</code> ，因此常量<code>defender</code>的类型是<code>string</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">defenders</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;Clarenza&#34;</span>, <span style="color:#e6db74">&#34;Dina&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">defender</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">defenders</span>[<span style="color:#ae81ff">0</span>];
</span></span></code></pre></div><p>联合类型数组的成员是同一种联合类型。下面常量<code>soldiersOrDates</code>的类型为<code>(string | Date)[]</code>，因此常量<code>soldierOrDate</code>的类型也为<code>string | Date</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">soldiersOrDates</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;Deborah Sampson&#34;</span>, <span style="color:#66d9ef">new</span> Date(<span style="color:#ae81ff">1782</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">3</span>)];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: Date | string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">soldierOrDate</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">soldiersOrDates</span>[<span style="color:#ae81ff">0</span>];
</span></span></code></pre></div><h3 id="caveat-unsound-members">Caveat: Unsound Members</h3>
<p>众所周知，<code>TypeScript</code>的<span style="background:#40a9ff">类型系统在技术上是不健全的，它可以使类型在多数情况下是正确的</span>，但有时对值类型的理解可能是不正确的，<font color=red>数组尤其是类型系统不健全的根源</font>。</p>
<p>默认情况下，<code>TypeScript</code>假设所有数组成员的访问都会返回该相应的成员，尽管在<code>JavaScript</code>中，访问数组元素的索引大于数组的长度会得到<code>undefined</code>。在编译器默认设置下，下面这段代码<font color="#245bdb">编译没有任何问题，但运行时会报错</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">withElements</span>(<span style="color:#a6e22e">elements</span>: <span style="color:#66d9ef">string</span>[]) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// No type error
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">elements</span>[<span style="color:#ae81ff">9001</span>].<span style="color:#a6e22e">length</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 运行时错误：Cannot read properties of undefined (reading &#39;length&#39;)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">withElements</span>([<span style="color:#e6db74">&#34;It&#39;s&#34;</span>, <span style="color:#e6db74">&#34;over&#34;</span>]);
</span></span></code></pre></div><p><code>TypeScript</code><font color="#de7802">故意不确保检索到的数组成员是否存在</font>，它认为上面代码片段中的<code>elements[9001]</code>是字符串类型，而不是<code>undefined</code>类型。</p>
<h2 id="spreads-and-rests">Spreads and Rests</h2>
<h3 id="spreads">Spreads</h3>
<p>可以使用<code>...</code>展开操作符将数组连接在一起，结果数组将包含来自输入数组的所有值。如果输入数组类型相同，则结果数组的类型也相同。如果将两个不同类型的数组展开在一起创建一个新数组，<font color="#de7802">新数组将被推断为联合类型数组</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// Type: string[]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">soldiers</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;Harriet Tubman&#34;</span>, <span style="color:#e6db74">&#34;Joan of Arc&#34;</span>, <span style="color:#e6db74">&#34;Khutulun&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: number[]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">soldierAges</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">90</span>, <span style="color:#ae81ff">19</span>, <span style="color:#ae81ff">45</span>];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: (string | number)[]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">conjoined</span> <span style="color:#f92672">=</span> [...<span style="color:#a6e22e">soldiers</span>, ...<span style="color:#a6e22e">soldierAges</span>]; <span style="color:#75715e">// [ &#39;Harriet Tubman&#39;, &#39;Joan of Arc&#39;, &#39;Khutulun&#39;, 90, 19, 45 ]
</span></span></span></code></pre></div><h3 id="spreading-rest-parameters">Spreading Rest Parameters</h3>
<p><code>TypeScript</code>可识别<code>...</code>展开操作符，即可将一个数组展开作为可变参数的实参，并执行类型检查。<font color="#de7802">数组作为实参传递给可变形参时必须具有相同类型</font>，下面代码中展开<code>string[]</code>是允许的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">logWarriors</span>(<span style="color:#a6e22e">greeting</span>: <span style="color:#66d9ef">string</span>, ...<span style="color:#a6e22e">names</span>: <span style="color:#66d9ef">string</span>[]) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">name</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">names</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">greeting</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">name</span><span style="color:#e6db74">}</span><span style="color:#e6db74">!`</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">warriors</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;Cathay Williams&#34;</span>, <span style="color:#e6db74">&#34;Lozen&#34;</span>, <span style="color:#e6db74">&#34;Nzinga&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">logWarriors</span>(<span style="color:#e6db74">&#34;Hello&#34;</span>, ...<span style="color:#a6e22e">warriors</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">Hello</span>, <span style="color:#a6e22e">Cathay</span> <span style="color:#a6e22e">Williams</span><span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Hello</span>, <span style="color:#a6e22e">Lozen</span><span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Hello</span>, <span style="color:#a6e22e">Nzinga</span><span style="color:#f92672">!</span>
</span></span></code></pre></div><h2 id="tuples">Tuples</h2>
<p>虽然数组在理论上可以是任意大小，但有时使用固定大小的数组（称为元组）也很有用。<font color="#de7802">元组中的每个元素都有特定类型，这个类型可能比数组所有可能成员的联合类型更具体</font>。声明元组类型的语法与数组字面意义相似，只是用类型代替了元素值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 元组类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">yearAndWarrior</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">number</span>, <span style="color:#66d9ef">string</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">yearAndWarrior</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">530</span>, <span style="color:#e6db74">&#34;Tomyris&#34;</span>]; <span style="color:#75715e">// Ok
</span></span></span></code></pre></div><p>在<code>JavaScript</code>中，元组通常与数组解构一起使用，以便一次赋值多个变量。例如，可以根据条件设置两个变量的初始值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> [<span style="color:#a6e22e">year</span>, <span style="color:#a6e22e">warrior</span>] <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> [<span style="color:#ae81ff">340</span>, <span style="color:#e6db74">&#34;Archidamia&#34;</span>] <span style="color:#f92672">:</span> [<span style="color:#ae81ff">1828</span>, <span style="color:#e6db74">&#34;Rani of Jhansi&#34;</span>];
</span></span></code></pre></div><h3 id="tuple-assignability">Tuple Assignability</h3>
<p><code>TypeScript</code>将元组类型视为比变长数组更特殊的类型，<font color="#de7802">这意味着变长数组类型不能赋值给元组类型</font>。下面代码中，变量<code>pairLoose</code>是数组类型<code>(boolean | number)[]</code>，即数组中元素类型是<code>(boolean | number)</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 推断为数组类型，数组中元素的类型为 (boolean | number)[]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">pairLoose</span> <span style="color:#f92672">=</span> [<span style="color:#66d9ef">false</span>, <span style="color:#ae81ff">123</span>];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误:Type &#39;(number | boolean)[]&#39; is not assignable to type &#39;[boolean, number]&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">pairTupleLoose</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">boolean</span>, <span style="color:#66d9ef">number</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">pairLoose</span>;
</span></span></code></pre></div><p>上面代码中，如果将变量<code>pairLoose</code>的类型声明为<code>[boolean, number]</code>，那么赋值是允许的，不会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">pairLoose</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">boolean</span>, <span style="color:#66d9ef">number</span>] <span style="color:#f92672">=</span> [<span style="color:#66d9ef">false</span>, <span style="color:#ae81ff">123</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">pairTupleLoose</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">boolean</span>, <span style="color:#66d9ef">number</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">pairLoose</span>;
</span></span></code></pre></div><p>请注意，<font color=red>不同长度的元组也不能相互赋值</font>，因为<code>TypeScript</code>已经知道元组类型中有多少个成员：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">tupleThree</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">boolean</span>, <span style="color:#66d9ef">number</span>, <span style="color:#66d9ef">string</span>] <span style="color:#f92672">=</span> [<span style="color:#66d9ef">false</span>, <span style="color:#ae81ff">1583</span>, <span style="color:#e6db74">&#34;Nzinga&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">tupleTwoExact</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">boolean</span>, <span style="color:#66d9ef">number</span>] <span style="color:#f92672">=</span> [<span style="color:#a6e22e">tupleThree</span>[<span style="color:#ae81ff">0</span>], <span style="color:#a6e22e">tupleThree</span>[<span style="color:#ae81ff">1</span>]];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Type &#39;[boolean, number, string]&#39; is not assignable to type &#39;[boolean, number]&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">tupleTwoExtra</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">boolean</span>, <span style="color:#66d9ef">number</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">tupleThree</span>;
</span></span></code></pre></div><p>由于元组被视为数组，在长度和元素类型上有更具体的类型信息，因此对于存储传递给函数的实参特别有用。<code>TypeScript</code>能够<font color="#de7802">将作为实参传递给函数可变形参的元组提供精确的类型检查</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">logPair</span>(<span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">name</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> has </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">value</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// pairArray的类型为: (string|number)[]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">pairArray</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;Amage&#34;</span>, <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：A spread argument must either have a tuple type or be passed to a rest parameter.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">logPair</span>(...<span style="color:#a6e22e">pairArray</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">pairTupleIncorrect</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">number</span>, <span style="color:#66d9ef">string</span>] <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;Amage&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误:Argument of type &#39;number&#39; is not assignable to parameter of type &#39;string&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">logPair</span>(...<span style="color:#a6e22e">pairTupleIncorrect</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 元组类型被展开，编译不会报错
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">pairTupleCorrect</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">string</span>, <span style="color:#66d9ef">number</span>] <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;Amage&#34;</span>, <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">logPair</span>(...<span style="color:#a6e22e">pairTupleCorrect</span>); <span style="color:#75715e">// Ok
</span></span></span></code></pre></div><p>如果想随意使用可变形参元组，可以将它们与数组混合使用，为多个函数调用存储实参列表。下面代码中<code>trios.forEach(trio =&gt; logTrio(...trio))</code>是安全的，因为每个<code>...trio</code>恰好与<code>logTrio</code>的参数类型相匹配。然而，<code>trios.forEach(logTrio)</code> 不可赋值，因为它试图将整个<code>[string, number, boolean]</code>作为第一个参数传递，但实际上第一个参数类型是<code>string</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">logTrio</span>(<span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">value</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">number</span>, <span style="color:#66d9ef">boolean</span>]) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">name</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> has </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">value</span>[<span style="color:#ae81ff">0</span>]<span style="color:#e6db74">}</span><span style="color:#e6db74"> (</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">value</span>[<span style="color:#ae81ff">1</span>]<span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">trios</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">string</span>, [<span style="color:#66d9ef">number</span>, <span style="color:#66d9ef">boolean</span>]][] <span style="color:#f92672">=</span> [
</span></span><span style="display:flex;"><span>    [<span style="color:#e6db74">&#34;Amanitore&#34;</span>, [<span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">true</span>]],
</span></span><span style="display:flex;"><span>    [<span style="color:#e6db74">&#34;Æthelflæd&#34;</span>, [<span style="color:#ae81ff">2</span>, <span style="color:#66d9ef">false</span>]],
</span></span><span style="display:flex;"><span>    [<span style="color:#e6db74">&#34;Ann E. Dunwoody&#34;</span>, [<span style="color:#ae81ff">3</span>, <span style="color:#66d9ef">false</span>]]];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 下面方式不会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">trios</span>.<span style="color:#a6e22e">forEach</span>(<span style="color:#a6e22e">trio</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">logTrio</span>(...<span style="color:#a6e22e">trio</span>)); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 下面会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Argument of type &#39;(name: string, value: [number, boolean]) =&gt; void&#39; is not assignable to parameter of type &#39;(value: [string, [number, boolean]], index: number, array: [string, [number, boolean]][]) =&gt; void&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Types of parameters &#39;name&#39; and &#39;value&#39; are incompatible.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">trios</span>.<span style="color:#a6e22e">forEach</span>(<span style="color:#a6e22e">logTrio</span>);
</span></span></code></pre></div><h3 id="tuple-inferences">Tuple Inferences</h3>
<p><code>TypeScript</code><font color="#de7802">通常将创建的数组视为长度可变的数组，而不是元组</font>。如果<font color="#245bdb">看到一个数组被用作变量的初始值或函数的返回值，那么编译器将推断它是一个可变长度的数组</font>，而不是一个固定长度的元组。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">firstCharAndSize</span>(<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> [<span style="color:#a6e22e">input</span>[<span style="color:#ae81ff">0</span>], <span style="color:#a6e22e">input</span>.<span style="color:#a6e22e">length</span>];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// firstChar的类型为 string | number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// size的类型为string | number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">firstChar</span>, <span style="color:#a6e22e">size</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">firstCharAndSize</span>(<span style="color:#e6db74">&#34;Gudit&#34;</span>);
</span></span></code></pre></div><h4 id="explicit-tuple-types">Explicit tuple types</h4>
<p>元组可能会被用于类型声明，例如函数的返回值类型。<font color="#76923c">如果一个函数声明返回一个元组类型，并且在函数里面返回一个数组字面量，则这个数组字面量会被推推断为元组而不是可变数组。</font></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">firstCharAndSizeExplicit</span>(<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">string</span>)<span style="color:#f92672">:</span> [<span style="color:#66d9ef">string</span>, <span style="color:#66d9ef">number</span>] {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> [<span style="color:#a6e22e">input</span>[<span style="color:#ae81ff">0</span>], <span style="color:#a6e22e">input</span>.<span style="color:#a6e22e">length</span>];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// firstChar type: string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// size type: number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">firstChar</span>, <span style="color:#a6e22e">size</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">firstCharAndSizeExplicit</span>(<span style="color:#e6db74">&#34;Cathay Williams&#34;</span>);
</span></span></code></pre></div><h4 id="const-asserted-tuples">Const asserted tuples</h4>
<p>显式标注元组类型比较麻烦，<code>TypeScript</code>提供了<code>as const</code>操作符，称为<code>const</code>断言，放在值的后面。<code>const</code>断言告诉<code>TypeScript</code>在推断该值的类型时，<font color="#de7802">使用该值最直白的只读形式</font>。如果将<code>const</code>断言放在数组字面之后，表示数组应被视为元组，<span style="background:#40a9ff">并且元组类型被推断为字面量</span>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// Type: (string | number)[]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">unionArray</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1157</span>, <span style="color:#e6db74">&#34;Tomoe&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: readonly [1157, &#34;Tomoe&#34;]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">readonlyTuple</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1157</span>, <span style="color:#e6db74">&#34;Tomoe&#34;</span>] <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">const</span>;
</span></span></code></pre></div><p>请注意，<code>const</code>断言不仅将可变的数组转换为固定大小的元组。还向<code>TypeScript</code>表明，<font color="#de7802">元组是只读的，不能在希望允许修改值的地方使用</font>。</p>
<p>下面代码中，<code>pairMutable</code>允许修改，因为它是传统的元组类型。但是，<code>as const</code>使得值不能赋值给可变的<code>pairAlsoMutable</code>元组，常量<code>pairConst</code>的成员也不允许被修改：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">pairMutable</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">number</span>, <span style="color:#66d9ef">string</span>] <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1157</span>, <span style="color:#e6db74">&#34;Tomoe&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">pairMutable</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1247</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：The type &#39;readonly [1157, &#34;Tomoe&#34;]&#39; is &#39;readonly&#39; and cannot be assigned to the mutable type &#39;[number, string]&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">pairAlsoMutable</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">number</span>, <span style="color:#66d9ef">string</span>] <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1157</span>, <span style="color:#e6db74">&#34;Tomoe&#34;</span>] <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">const</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// pariConst的类型相当于字面量的[1157,&#34;Tomoe&#34;]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">pairConst</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1157</span>, <span style="color:#e6db74">&#34;Tomoe&#34;</span>] <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">const</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Cannot assign to &#39;0&#39; because it is a read-only property
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">pairConst</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1247</span>;
</span></span></code></pre></div><p>在实践中，只读元组作为函数返回值很方便。函数中返回的元组值通常会立即解构，因此只读元组不会妨碍函数的使用。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">firstCharAndSizeAsConst</span>(<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> [<span style="color:#a6e22e">input</span>[<span style="color:#ae81ff">0</span>], <span style="color:#a6e22e">input</span>.<span style="color:#a6e22e">length</span>] <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">const</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 函数返回的元组立即被解构
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">firstChar</span>, <span style="color:#a6e22e">size</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">firstCharAndSizeAsConst</span>(<span style="color:#e6db74">&#34;Ching Shih&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">firstChar</span>, <span style="color:#a6e22e">size</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 出现编译错误:Cannot assign to &#39;firstChar&#39; because it is a constant.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">firstChar</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;chear&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 函数返回的元组立即被解构  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> [<span style="color:#a6e22e">firstChar1</span>, <span style="color:#a6e22e">size1</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">firstCharAndSizeAsConst</span>(<span style="color:#e6db74">&#34;Ching Shih&#34;</span>);  
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">firstChar1</span>, <span style="color:#a6e22e">size1</span>)  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 不会出现编译错误，因为是使用let定义的解构
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">firstChar1</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;chear&#39;</span>
</span></span></code></pre></div><h1 id="interfaces">Interfaces</h1>
<blockquote>
<p>接口是声明具有相关名称对象的另一种方法。<font color="#de7802">接口在许多方面与别名对象类型相似，但由于其错误信息更易读、编译器性能更快以及与类的互操作性更好，通常更受青睐。</font></p>
</blockquote>
<h2 id="type-aliases-versus-interfaces">Type Aliases Versus Interfaces</h2>
<p>下面是定义别名类型描述对象的语法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Poet</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>下面是使用<code>interface</code>的等效语法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Poet</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面两种语法基本一致。喜欢使用分号的<code>TypeScript</code>开发人员<font color="#de7802">通常会将分号放在类型别名定义之后，而接口定义之后通常不加分号</font>。这种偏好反映了使用<code>;</code>声明变量，不使用<code>;</code>声明类或函数。</p>
<p>尽管相似，但<code>type</code>和<code>interface</code>有一些关键区别：</p>
<ul>
<li>接口可以<code>merge</code>在一起增强。</li>
<li>接口可以用来对类的结构进行类型检查，而类型别名则不能。</li>
<li>对于类型检查程序来说，<font color=LightSeaGreen>接口的工作速度通常更快</font>。因为它们声明了一个命名的类型，可以更容易地在内部缓存，而不是像类型别名那样动态复制粘贴一个新的对象字面量。</li>
<li>由于接口被认为是已命名的对象，而不是未命名对象字面量的别名，因此它们的错误信息可能在某些极端情况下更具可读性。</li>
</ul>
<h2 id="types-of-properties">Types of Properties</h2>
<h3 id="optional-properties-1">Optional Properties</h3>
<p>与对象类型一样，接口属性不一定都是对象的必需属性。可以在接口中属性类型标注的<code>:</code>前加上<code>?</code>来表示该属性是可选的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Book</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author?</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">ok</span>: <span style="color:#66d9ef">Book</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Rita Dove&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">80</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">missing</span>: <span style="color:#66d9ef">Book</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">80</span>
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="read-only-properties">Read-Only Properties</h3>
<p>有时，可能希望禁止重新赋值实现接口对象的某个属性值。<code>TypeScript</code>允许在属性名称前添加一个<code>readonly</code>修饰符，表示该属性一旦设置，就不能再修改。也就是说<code>readonly</code>属性可以正常读取，但不能被重新赋值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Page</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">readonly</span> <span style="color:#a6e22e">text</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">read</span>(<span style="color:#a6e22e">page</span>: <span style="color:#66d9ef">Page</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Ok: reading the text property doesn&#39;t attempt to modify it
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">page</span>.<span style="color:#a6e22e">text</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 编译错误：Cannot assign to &#39;text&#39; because it is a read-only property.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">page</span>.<span style="color:#a6e22e">text</span> <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;!&#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>需要注意的是，<code>readonly</code><font color="#de7802">修饰器只存在于类型系统</font>。</p>
<h3 id="functions-and-methods">Functions and Methods</h3>
<p>在<code>JavaScript</code>中对象成员为函数比较常见。因此，<code>TypeScript</code>允许将<code>interface</code>的成员声明为函数类型。<code>TypeScript</code>提供了两种将接口成员声明为函数的方法：</p>
<ul>
<li>方法语法：声明接口成员是一个打算作为对象成员调用的函数，如<code>member(): void</code>。</li>
<li>属性语法：声明接口成员等同于独立函数，如<code>member: () =&gt; void</code>。
下面接口声明中的<code>method</code>和<code>property</code>都是函数，可以不带实参调用，并返回一个字符串：</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">HasBothFunctionTypes</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">property</span><span style="color:#f92672">:</span> () <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">method</span>()<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">hasBoth</span>: <span style="color:#66d9ef">HasBothFunctionTypes</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">property</span><span style="color:#f92672">:</span> () <span style="color:#f92672">=&gt;</span> <span style="color:#e6db74">&#34;&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">method() {</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">hasBoth</span>.<span style="color:#a6e22e">property</span>();
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">hasBoth</span>.<span style="color:#a6e22e">method</span>()
</span></span></code></pre></div><p>这两种形式声明的函数都支持可选的修饰器<code>?</code>，表明它们不是必需的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">OptionalReadonlyFunctions</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">optionalProperty</span><span style="color:#f92672">?:</span> () <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">optionalMethod</span><span style="color:#f92672">?</span>()<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>方法和属性声明多数情况下可以互换，它们之间的主要区别如下：</p>
<ul>
<li>方法不能声明为<code>readonly</code>，但属性可以。</li>
<li><font color="#de7802">接口合并时，认为方法和属性是不同的</font>。
如果知道底层函数可能会引用<code>this</code>，建议使用方法，其它情况则建议使用属性。</li>
</ul>
<h3 id="call-signatures">Call Signatures</h3>
<p>接口和对象类型均可以声明<code>call signatures</code>（类型系统对值如何像函数一样被调用的描述）。只有按照<code>call signatures</code>方式声明的值才可以赋值给接口，即具有可赋值参数和返回类型的函数。<code>call signatures</code>与函数类型相似，只是用冒号代替<code>=&gt;</code>箭头。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">CallSignature</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 调用签名
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    (<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">string</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">typedFunctionAlias</span>: <span style="color:#66d9ef">FunctionAlias</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">input</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">input</span>.<span style="color:#a6e22e">length</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">typedCallSignature</span>: <span style="color:#66d9ef">CallSignature</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">input</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">input</span>.<span style="color:#a6e22e">length</span>; <span style="color:#75715e">// Ok
</span></span></span></code></pre></div><p><code>call signatures</code>可用于<font color="#f79646">描述附加了一些自定义属性的函数</font>。<code>TypeScript</code>会识别添加到函数声明中的属性，并将其添加到函数声明的类型中。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">FunctionWithCount</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">count</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    ()<span style="color:#f92672">:</span> <span style="color:#66d9ef">void</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">hasCallCount</span>: <span style="color:#66d9ef">FunctionWithCount</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">keepsTrackOfCalls() {</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">keepsTrackOfCalls</span>.<span style="color:#a6e22e">count</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`I&#39;ve been called </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">keepsTrackOfCalls</span>.<span style="color:#a6e22e">count</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> times!`</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">keepsTrackOfCalls</span>.<span style="color:#a6e22e">count</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">hasCallCount</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">keepsTrackOfCalls</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">doesNotHaveCount() {</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;No idea!&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误:Property &#39;count&#39; is missing in type &#39;() =&gt; void&#39; but required in type &#39;FunctionWithCount&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">hasCallCount</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">doesNotHaveCount</span>;
</span></span></code></pre></div><h3 id="index-signatures">Index Signatures</h3>
<p>有些<code>JavaScript</code>项目创建的对象可以使用任意字符串<code>key</code>存储值。对于这些「容器」对象来说，为接口的每一个可能的<code>key</code>声明一个属性是不切实际的。</p>
<p><code>TypeScript</code>提供了一种称为<code>index signature</code>的语法，允许接口接收任何的<code>key</code>，并返回该<code>key</code>下的特定类型。最常见的是字符串<code>index signature</code>，这是因为<code>JavaScript</code>对象查找属性时会将<code>key</code>隐式转换为字符串。索引签名看起来就像普通的属性定义，只是在键后面加上了类型，并用数组括号将其括起来：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">WordCounts</span> {
</span></span><span style="display:flex;"><span>    [<span style="color:#a6e22e">i</span>: <span style="color:#66d9ef">string</span>]<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">counts</span>: <span style="color:#66d9ef">WordCounts</span> <span style="color:#f92672">=</span> {};
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">counts</span>.<span style="color:#a6e22e">apple</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// Ok 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">counts</span>.<span style="color:#a6e22e">banana</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Type &#39;boolean&#39; is not assignable to type &#39;number&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">counts</span>.<span style="color:#a6e22e">cherry</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span></code></pre></div><p>索引签名便于将值赋值给对象，但并非完全类型安全。因为索引签名表示，<font color="#de7802">无论访问的是什么属性，对象都应返回一个值</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">DatesByName</span> {
</span></span><span style="display:flex;"><span>    [<span style="color:#a6e22e">i</span>: <span style="color:#66d9ef">string</span>]<span style="color:#f92672">:</span> Date;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">publishDates</span>: <span style="color:#66d9ef">DatesByName</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Frankenstein</span>: <span style="color:#66d9ef">new</span> Date(<span style="color:#e6db74">&#34;1 January 1818&#34;</span>),
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// webStrom中没有提示
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">publishDates</span>.<span style="color:#a6e22e">Frankenstein</span>) <span style="color:#75715e">// Type: Date
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">publishDates</span>.<span style="color:#a6e22e">Frankenstein</span>.<span style="color:#a6e22e">toString</span>());
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">publishDates</span>.<span style="color:#a6e22e">Beloved</span>) <span style="color:#75715e">// undefined
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 运行时错误：Cannot read properties of undefined (reading &#39;toString&#39;)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">publishDates</span>.<span style="color:#a6e22e">Beloved</span>.<span style="color:#a6e22e">toString</span>())
</span></span></code></pre></div><p>如果要存储键值对，并且无法提前知道键值，通常使用<code>Map</code>更安全。<code>Map</code>的<code>get</code>方法总是返回带有<code>| undefined</code>的类型，表示键可能不存在。</p>
<h4 id="mixing-properties-and-index-signatures">Mixing properties and index signatures</h4>
<p>接口可以包含显式命名属性和<code>catchall string</code>索引签名。但有一个限制：<font color="#de7802">每个显式命名属性的类型必须可以赋值给其catchall索引签名的类型</font>。可以认为将它们混合在一起就是告诉<code>TypeScript</code>，命名的属性会给出一个更具体的类型，而其它属性都会返回索引签名的类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">HistoricalNovels</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Oroonoko</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    [<span style="color:#a6e22e">i</span>: <span style="color:#66d9ef">string</span>]<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">novels</span>: <span style="color:#66d9ef">HistoricalNovels</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Outlander</span>: <span style="color:#66d9ef">1991</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Oroonoko</span>: <span style="color:#66d9ef">1688</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Property &#39;Oroonoko&#39; is missing in type &#39;{ Outlander: number; }&#39; but required in type &#39;HistoricalNovels&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">missingOroonoko</span>: <span style="color:#66d9ef">HistoricalNovels</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Outlander</span>: <span style="color:#66d9ef">1991</span>,
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h2 id="interface-extensions">Interface Extensions</h2>
<p>有时，可能会有多个看起来相似的<code>interface</code>。一个<code>interface</code>可能包含另一个<code>interface</code>的所有成员，只是增加了一些额外的成员。</p>
<p><code>TypeScript</code>允许一个接口<code>extend</code>另一个接口，即<font color="#de7802">声明它复制了另一个接口的所有成员</font>。可以在接口名后添加<code>extends</code>关键字和待扩展的接口名，以标记当前接口扩展了另一个接口。</p>
<p>在下面实例代码中，接口<code>Novella</code>扩展了接口<code>Writing</code>，因此要求对象至少同时拥有<code>Novella</code>的<code>pages</code>和<code>Writing</code>的<code>title</code>成员：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Writing</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">title</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Novella</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Writing</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">myNovella</span>: <span style="color:#66d9ef">Novella</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">195</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">title</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Ethan Frome&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Property &#39;pages&#39; is missing in type &#39;{ title: string; }&#39; but required in type &#39;Novella&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">missingPages</span>: <span style="color:#66d9ef">Novella</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">title</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;The Awakening&#34;</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Object literal may only specify known properties, and &#39;strategy&#39; does not exist in type &#39;Novella&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 对象字面量会触发多余属性检查
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">extraProperty</span>: <span style="color:#66d9ef">Novella</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">300</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">strategy</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;baseline&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">style</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Naturalism&#34;</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 使用变量暂存对象字面量以规避上面问题
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">extraProperty1</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">300</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">strategy</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;baseline&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">style</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Naturalism&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">title</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;test&#34;</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 这样赋值不会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">myNovella</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">extraProperty1</span>
</span></span></code></pre></div><h3 id="overridden-properties">Overridden Properties</h3>
<p>派生接口可以通过<font color="#de7802">再次声明同名的不同类型属性来覆盖或替换其基础接口的属性</font>。<span style="background:#40a9ff">类型检查器会强制要求覆盖的属性必须可赋值给其基础属性</span>。目的是确保派生接口类型的实例始终可赋值给基础接口类型变量。</p>
<p>大多数派生接口在重新声明属性时，<font color="#de7802">要么是为了使这些属性成为一个联合类型的更具体的子类型</font>，要么是为了使这些属性成为一个从基本接口类型扩展而来的类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">WithNullableName</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">WithNonNullableName</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">WithNullableName</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误，子接口的范围没有缩小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">WithNumericName</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">WithNullableName</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="extending-multiple-interfaces">Extending Multiple Interfaces</h3>
<p><code>TypeScript</code>中的接口定义时可以声明为<font color=red>扩展多个其它接口</font>。即派生接口的<code>extends</code>关键字之后，存在多个用逗号分隔的接口名。派生接口将接收所有基础接口的所有成员。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">GivesNumber</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">giveNumber</span>()<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">GivesString</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">giveString</span>()<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">GivesBothAndEither</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">GivesNumber</span>, <span style="color:#a6e22e">GivesString</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">giveEither</span>()<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">useGivesBoth</span>(<span style="color:#a6e22e">instance</span>: <span style="color:#66d9ef">GivesBothAndEither</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">instance</span>.<span style="color:#a6e22e">giveEither</span>(); <span style="color:#75715e">// Type: number | string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">instance</span>.<span style="color:#a6e22e">giveNumber</span>(); <span style="color:#75715e">// Type: number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">instance</span>.<span style="color:#a6e22e">giveString</span>(); <span style="color:#75715e">// Type: string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>将一个接口标注为扩展多个其它接口，既可以减少代码重复，又可以使对象更容易在不同的代码区域重复使用。</p>
<h2 id="interface-merging">Interface Merging</h2>
<p>接口的一个重要特性是可以合并。接口合并意味着，如果<font color="#f79646">在同一作用域中声明了两个名称相同的接口，它们就会合并成一个更大的接口</font>，并在该名称下包含所有声明的字段。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Merged</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fromFirst</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Merged</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fromSecond</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>接口<code>merge</code>并不经常使用，<span style="background:#40a9ff">建议在可能的情况下尽量避免使用该功能</span>。因为，如果在多个地方声明了一个接口，就很难理解代码。</p>
<p>然而，接口合并对于增强来自外部包或内置的全局接口（如<code>Window</code>）特别有用。例如，当使用默认的编译器选项时，在带有<code>myEnvironmentVariable</code>属性的文件中声明<code>Window</code>接口，就可以使用 <code>window.myEnvironmentVariable</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Window</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">myEnvironmentVariable</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>window.<span style="color:#a6e22e">myEnvironmentVariable</span>;
</span></span></code></pre></div><h3 id="member-naming-conflicts">Member Naming Conflicts</h3>
<p>请注意，合并后的接口不能以不同类型多次声明相同名称的属性。<font color="#548dd4">如果一个接口中已经声明了一个属性，那么以后合并的接口必须使用相同的类型</font>。但是，合并后的接口<font color=red>可以定义一个名称相同但签名不同的方法</font>。这样做会为该方法创建一个函数重载。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">MergedMethods</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">different</span>(<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">string</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">MergedMethods</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">different</span>(<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">number</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span>; <span style="color:#75715e">// Ok 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h1 id="classes">Classes</h1>
<blockquote>
<p>除了类型检查，<code>TypeScript</code>还强调了它的转换器（<code>transpiler</code>），类就是一个常见的例子。<code>TypeScript</code>中的类只是支持所有<code>JavaScript</code>语言特性的众多特性之一。<code>TypeScript</code>既不鼓励也不反对类的使用或任何其它流行的<code>JavaScript</code>模式。</p>
</blockquote>
<h2 id="class-methods">Class Methods</h2>
<p><code>TypeScript</code>对类中方法的理解与对独立函数的理解相同。<font color="#de7802">除非显式给出类型或默认值，否则方法形参的类型被推断为</font><code>any</code>。调用方法时<font color="#0070c0">需要给出正确的实参数量</font>，如果函数不是递归的，返回类型通常可以被推断出来。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Greeter</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">greet</span>(<span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">name</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, do your stuff!`</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Greeter</span>().<span style="color:#a6e22e">greet</span>(<span style="color:#e6db74">&#34;Miss Frizzle&#34;</span>) <span style="color:#75715e">// Miss Frizzle, do your stuff!
</span></span></span></code></pre></div><p>类构造函数的形参与其他方法相同。<code>TypeScript</code>会执行类型检查，以确保调用方法时提供了数量正确、类型正确的参数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Greeted</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>(<span style="color:#a6e22e">message</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`As I always say: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">message</span><span style="color:#e6db74">}</span><span style="color:#e6db74">!`</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Greeted</span>(<span style="color:#e6db74">&#34;take chances, make mistakes, get messy&#34;</span>); 
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">As</span> <span style="color:#a6e22e">I</span> <span style="color:#a6e22e">always</span> <span style="color:#a6e22e">say</span>: <span style="color:#66d9ef">take</span> <span style="color:#a6e22e">chances</span>, <span style="color:#a6e22e">make</span> <span style="color:#a6e22e">mistakes</span>, <span style="color:#66d9ef">get</span> <span style="color:#a6e22e">messy</span><span style="color:#f92672">!</span>
</span></span></code></pre></div><h2 id="class-properties">Class Properties</h2>
<p>在<code>TypeScript</code>中，若要读取或写入类的属性，必须在类中明确声明。类属性的声明语法与接口相同，名称后跟一个类型标注。<code>TypeScript</code><font color="#de7802">不会试图通过构造函数中的赋值来推断类中可能存在的成员</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FieldTrip</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">destination</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>(<span style="color:#a6e22e">destination</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">destination</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">destination</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`We&#39;re going to </span><span style="color:#e6db74">${</span><span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">destination</span><span style="color:#e6db74">}</span><span style="color:#e6db74">!`</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 编译错误：Property &#39;nonexistent&#39; does not exist on type &#39;FieldTrip&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">nonexistent</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">destination</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>显式地声明类的属性可以让<code>TypeScript</code>快速地了解类的实例中哪些属性是存在的，哪些是不存在的。<font color="#548dd4">若访问不存在的属性，会出现编译错误</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FieldTrip</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">destination</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>(<span style="color:#a6e22e">destination</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">destination</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">destination</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`We&#39;re going to </span><span style="color:#e6db74">${</span><span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">destination</span><span style="color:#e6db74">}</span><span style="color:#e6db74">!`</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">trip</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">FieldTrip</span>(<span style="color:#e6db74">&#34;planetarium&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 访问存在的属性，没有问题
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">trip</span>.<span style="color:#a6e22e">destination</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误:  Property &#39;nonexistent&#39; does not exist on type &#39;FieldTrip&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">trip</span>.<span style="color:#a6e22e">nonexistent</span>)
</span></span></code></pre></div><h3 id="function-properties">Function Properties</h3>
<p>下面<code>WithMethod</code>类定义了一个<code>myMethod</code>方法，所有实例都可以引用该方法。<font color="#de7802">这种方式定义的方法，不会为每个类的实例创建一个副本</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">WithMethod</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">myMethod() {</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果为true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">new</span> <span style="color:#a6e22e">WithMethod</span>().<span style="color:#a6e22e">myMethod</span> <span style="color:#f92672">===</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">WithMethod</span>().<span style="color:#a6e22e">myMethod</span>) 
</span></span></code></pre></div><p>另一种定义方法的语法是声明一个属性，其值恰好是一个函数。<font color="#de7802">这种方式将会为类的每个实例创建一个新函数</font>，这对于使用<code>()=&gt;</code>箭头函数可能很有用，因为箭头函数的<code>this</code>作用域应始终指向类的实例。</p>
<p>下面的<code>WithProperty</code>类定义了单个属性<code>myProperty</code>，它的类型为<code>() =&gt; void</code>，每个类的实例都会创建一个新副本：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">WithProperty</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">myProperty</span><span style="color:#f92672">:</span> () <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">myProperty</span> <span style="color:#f92672">=</span> () <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 赋值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">new</span> <span style="color:#a6e22e">WithProperty</span>().<span style="color:#a6e22e">myProperty</span> <span style="color:#f92672">===</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">WithProperty</span>().<span style="color:#a6e22e">myProperty</span>) 
</span></span></code></pre></div><p>属性函数的形参和返回类型与独立函数相同。因为，它们是分配给类成员的值，而该值恰好是一个函数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">WithPropertyParameters</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">takesParameters</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">boolean</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">input</span> <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;Yes&#34;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;No&#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">instance</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">WithPropertyParameters</span>();
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">instance</span>.<span style="color:#a6e22e">takesParameters</span>(<span style="color:#66d9ef">true</span>)) <span style="color:#75715e">// Yes
</span></span></span></code></pre></div><h3 id="initialization-checking">Initialization Checking</h3>
<p>如果启用了严格的编译器设置，<code>TypeScript</code>将检查所声明的每个属性（其类型不包括<code>undefined</code>）是否在构造函数中赋值。这种严格初始化检查非常有用，可以防止因意外忘记为属性赋值。下面定义的类<code>WithValue</code>在构造函数中没有为属性<code>unused</code>赋值，会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">WithValue</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">immediate</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">later</span>: <span style="color:#66d9ef">number</span>; <span style="color:#75715e">// Ok (set in the constructor)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">mayBeUndefined</span>: <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>; <span style="color:#75715e">// Ok (allowed to be undefined)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">unused</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">later</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误: Property &#39;unused&#39; has no initializer and is not definitely assigned in the constructor.
</span></span></span></code></pre></div><p>如果没有严格的初始化检查，类实例可能会被允许访问一个可能为<code>undefined</code>的值，即使类型系统规定不能这样做。</p>
<h4 id="definitely-assigned-properties">Definitely assigned properties</h4>
<p>尽管严格的初始检查在多数情况下是很有用的，但在某些情况下，可能会遇到故意在类构造函数之后取消检查类的某个属性的情况。</p>
<p>如果<font color="#245bdb">绝对确定某个属性不需要应用严格初始化检查</font>，可以在其名称后添加一个<code>!</code>来禁用检查。这样做可以向<code>TypeScript</code>申明，该属性将在首次使用前被赋值，而不是<code>undefined</code>的值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ActivitiesQueue</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pending</span><span style="color:#f92672">!:</span> <span style="color:#66d9ef">string</span>[]; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">initialize</span>(<span style="color:#a6e22e">pending</span>: <span style="color:#66d9ef">string</span>[]) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">pending</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">pending</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">next() {</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">pending</span>.<span style="color:#a6e22e">pop</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">activities</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">ActivitiesQueue</span>();
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">activities</span>.<span style="color:#a6e22e">initialize</span>([<span style="color:#e6db74">&#39;eat&#39;</span>, <span style="color:#e6db74">&#39;sleep&#39;</span>, <span style="color:#e6db74">&#39;learn&#39;</span>])
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">activities</span>.<span style="color:#a6e22e">next</span>();
</span></span></code></pre></div><h2 id="optional-properties-2">Optional Properties</h2>
<p>和接口相似，类可以声明可选的属性。可选属性的行为与属性类型恰巧是包含<code>| undefined</code>的联合类型属性大致相同。如果没有在构造函数中明确设置初始值，严格的初始化检查也不会在意。</p>
<p>下面的<code>OptionalProperty</code>类中，它的<code>property</code>属性是可选的。因此，无论是否有严格的属性初始化检查，都允许不在类构造函数中赋值可选属性：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MissingInitializer</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">property?</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">new</span> <span style="color:#a6e22e">MissingInitializer</span>().<span style="color:#a6e22e">property</span><span style="color:#f92672">?</span>.<span style="color:#a6e22e">length</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Object is possibly &#39;undefined&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">new</span> <span style="color:#a6e22e">MissingInitializer</span>().<span style="color:#a6e22e">property</span>.<span style="color:#a6e22e">length</span>)
</span></span></code></pre></div><h2 id="read-only-properties-1">Read-Only Properties</h2>
<p>类似接口，类也可以在属性前面添加<code>readonly</code>关键词。关键词<code>readonly</code>仅存在于类型系统，当编译为<code>JavaScript</code>文件后，关键字会被移除。</p>
<p>声明为<span style="background:#40a9ff">只读的属性只能在声明处或构造函数中分配初始值</span>。任何其它位置（包括类本身的方法）只能读取属性，而不能写入属性。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Quote</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">readonly</span> <span style="color:#a6e22e">text</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>(<span style="color:#a6e22e">text</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">text</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">text</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">emphasize() {</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 编译错误: Cannot assign to &#39;text&#39; because it is a read-only property.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">text</span> <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;!&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">quote</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Quote</span>(<span style="color:#e6db74">&#34;this is a test&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">quote</span>.<span style="color:#a6e22e">text</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 只读属性不能重新赋值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">quote</span>.<span style="color:#a6e22e">text</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Hello world&#34;</span>;
</span></span></code></pre></div><p>与其它属性相比，声明为只读且初始值为基本类型字面量的属性有一个特性：如果可能，<font color="#de7802">它们会被推断为其值的字面量类型，而不是基本类型</font>。</p>
<p><code>TypeScript</code>对于这种激进的初始类型窄化感觉良好，因为它知道其值以后不会改变。这类似于<code>const</code>变量比<code>let</code>变量使用更窄的类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">RandomQuote</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 显式声明为string类型，在初始化器中可以被修改
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">readonly</span> <span style="color:#a6e22e">explicit</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Home is the nicest word there is.&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 推断为字面量类型，不可修改
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">readonly</span> <span style="color:#a6e22e">implicit</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Home is the nicest word there is.&#34;</span>;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">explicit</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;We start learning the minute we&#39;re born.&#34;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 即使在构造函数中重新赋值也会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">implicit</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;We start learning the minute we&#39;re born.&#34;</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 错误信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">Type</span> <span style="color:#e6db74">&#39;&#34;We start learning the minute we&#39;</span><span style="color:#a6e22e">re</span> <span style="color:#a6e22e">born</span>.<span style="color:#e6db74">&#34;&#39; is not assignable to type &#39;&#34;</span><span style="color:#a6e22e">Home</span> <span style="color:#66d9ef">is</span> <span style="color:#a6e22e">the</span> <span style="color:#a6e22e">nicest</span> <span style="color:#a6e22e">word</span> <span style="color:#a6e22e">there</span> <span style="color:#66d9ef">is</span>.<span style="color:#960050;background-color:#1e0010">&#34;&#39;</span>.
</span></span></code></pre></div><h2 id="classes-as-types">Classes as Types</h2>
<p>类在类型系统中相对独特，因为类声明既创建了运行时值（类本身），也创建了可用于类型标注的类型。下面示例代码中，类<code>Teacher</code>用于标注变量<code>teacher</code>，以告诉<code>TypeScript</code>它应该只赋值给可赋值给<code>Teacher</code>类的值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Teacher</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sayHello() {</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Take chances, make mistakes, get messy!&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">teacher</span>: <span style="color:#66d9ef">Teacher</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">teacher</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Teacher</span>()
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">teacher</span>.<span style="color:#a6e22e">sayHello</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type &#39;string&#39; is not assignable to type &#39;Teacher&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">tearcher</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Wahoo!&#34;</span>
</span></span></code></pre></div><p>有趣的是，<code>TypeScript</code>会<font color="#de7802">将任何恰好包含当前类中所有相同成员的对象类型视为可赋值给当前类</font>。这是因为<code>TypeScript</code>中的<code>structural typing</code><span style="background:#40a9ff">只关心对象的形状，并不关心它们是如何声明的</span>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SchoolBus</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">getAbilities() {</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> [<span style="color:#e6db74">&#34;magic&#34;</span>, <span style="color:#e6db74">&#34;shapeshifting&#34;</span>];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">withSchoolBus</span>(<span style="color:#a6e22e">bus</span>: <span style="color:#66d9ef">SchoolBus</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">bus</span>.<span style="color:#a6e22e">getAbilities</span>());
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">withSchoolBus</span>(<span style="color:#66d9ef">new</span> <span style="color:#a6e22e">SchoolBus</span>());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 下面这种调用方式也是可以的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">withSchoolBus</span>({
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">getAbilities</span><span style="color:#f92672">:</span> () <span style="color:#f92672">=&gt;</span> [<span style="color:#e6db74">&#34;transmogrification&#34;</span>]
</span></span><span style="display:flex;"><span>})
</span></span></code></pre></div><h2 id="classes-and-interfaces">Classes and Interfaces</h2>
<p><code>TypeScript</code>允许类在名字后添加<code>implements</code>关键字，并在其后添加接口名称，从而将类声明为遵循这个接口。这样做是向<code>TypeScript</code>表明，类的实例可以赋值给这些接口中的任何一个。任何不匹配都会被类型检查器认为时类型错误。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Learner</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">study</span>(<span style="color:#a6e22e">hours</span>: <span style="color:#66d9ef">number</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">void</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Student</span> <span style="color:#66d9ef">implements</span> <span style="color:#a6e22e">Learner</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>(<span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">name</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">study</span>(<span style="color:#a6e22e">hours</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">hours</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;...studying...&#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>将一个类标记为实现了一个接口并不会改变该类的使用方式。如果该类已经与接口相匹配，<code>TypeScript</code>的类型检查器允许在需要接口实例的地方使用该类的实例。</p>
<h3 id="implementing-multiple-interfaces">Implementing Multiple Interfaces</h3>
<p><code>TypeScript</code>中<font color="#de7802">一个类可以实现任意多个接口，接口名称之间用逗号隔开</font>。下面示例代码中，类在实现接口<code>Graded</code>时必需具有<code>grades</code>属性，在实现接口<code>Reporter</code>时必需具有<code>report</code>属性。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Graded</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">grades</span>: <span style="color:#66d9ef">number</span>[];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Reporter</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">report</span><span style="color:#f92672">:</span> () <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 下面类ReportCard是正常的，因为实现了grades和report
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ReportCard</span> <span style="color:#66d9ef">implements</span> <span style="color:#a6e22e">Graded</span>, <span style="color:#a6e22e">Reporter</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">grades</span>: <span style="color:#66d9ef">number</span>[];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>(<span style="color:#a6e22e">grades</span>: <span style="color:#66d9ef">number</span>[]) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">grades</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">grades</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">report() {</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">grades</span>.<span style="color:#a6e22e">join</span>(<span style="color:#e6db74">&#34;, &#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 下面会出现编译错误，因为Empty没有真正实现接口
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Empty</span> <span style="color:#66d9ef">implements</span> <span style="color:#a6e22e">Graded</span>, <span style="color:#a6e22e">Reporter</span> {
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="generics">Generics</h1>
<h2 id="generic-interfaces">Generic Interfaces</h2>
<p>接口也可以声明为泛型，它们遵循与函数类似的泛型规则：可以在接口名称后面的<code>&lt;</code>和<code>&gt;</code>之间声明任意数量的类型参数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Box</span>&lt;<span style="color:#f92672">T</span>&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">inside</span>: <span style="color:#66d9ef">T</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">stringyBox</span>: <span style="color:#66d9ef">Box</span>&lt;<span style="color:#f92672">string</span>&gt; <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">inside</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;abc&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">numberBox</span>: <span style="color:#66d9ef">Box</span>&lt;<span style="color:#f92672">number</span>&gt; <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">inside</span>: <span style="color:#66d9ef">123</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误 Type &#39;boolean&#39; is not assignable to type &#39;number&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">incorrectBox</span>: <span style="color:#66d9ef">Box</span>&lt;<span style="color:#f92672">number</span>&gt; <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">inside</span>: <span style="color:#66d9ef">false</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="inferred-generic-interface-types">Inferred Generic Interface Types</h3>
<p>如同泛型函数，泛型接口类型的实参可以从使用中推断出来。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">LinkedNode</span>&lt;<span style="color:#f92672">Value</span>&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">next?</span>: <span style="color:#66d9ef">LinkedNode</span>&lt;<span style="color:#f92672">Value</span>&gt;;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">Value</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getLast</span>&lt;<span style="color:#f92672">Value</span>&gt;(<span style="color:#a6e22e">node</span>: <span style="color:#66d9ef">LinkedNode</span>&lt;<span style="color:#f92672">Value</span>&gt;)<span style="color:#f92672">:</span> <span style="color:#a6e22e">Value</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">next</span> <span style="color:#f92672">?</span> <span style="color:#a6e22e">getLast</span>(<span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">next</span>) <span style="color:#f92672">:</span> <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">value</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Inferred Value type argument: Date
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">lastDate</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">getLast</span>({
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">new</span> Date(<span style="color:#e6db74">&#34;09-13-1993&#34;</span>),
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Inferred Value type argument: string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">lastFruit</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">getLast</span>({
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">next</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">value</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;banana&#34;</span>,
</span></span><span style="display:flex;"><span>    }, <span style="color:#a6e22e">value</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;apple&#34;</span>,
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Inferred Value type argument: number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">lastMismatch</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">getLast</span>({
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">next</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">123</span>
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Error: type &#39;boolean&#39; is not assignable to type &#39;number&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">false</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>请注意，如果接口声明了泛型的类型参数，则任何引用该接口类型的地方都必须提供相应的类型参数。</p>
<h2 id="promises">Promises</h2>
<p><code>JavaScript</code>中的<code>Promise</code>表示<font color="#de7802">仍在等待处理的事情</font>，例如网络请求。每个<code>Promise</code>都提供了注册回调的方法，以防待执行操作<code>resolve</code>（成功完成）或 <code>reject</code>（抛出异常）。</p>
<p><code>Promise</code>能够在任意值类型上表示类似地操作，这与<code>TypeScript</code>泛型非常契合。在<code>TypeScript</code>类型系统中，<code>Promises</code>使用<code>Promise</code>类表示，该类有一个类型参数，代表最终解析的值。</p>
<h3 id="creating-promises">Creating Promises</h3>
<p><code>Promise</code>类的构造器中接受单个参数，这个参数的类型取决于泛型<code>Promise</code>类中声明的类型参数，<code>Promise</code>类的简化版本大致如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">PromiseLike</span>&lt;<span style="color:#f92672">Value</span>&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>(<span style="color:#a6e22e">executor</span><span style="color:#f92672">:</span> (
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">resolve</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">Value</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">void</span>,
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">reject</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">reason</span>: <span style="color:#66d9ef">unknown</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">void</span>,
</span></span><span style="display:flex;"><span>                ) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">void</span>,
</span></span><span style="display:flex;"><span>    ) { 
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">/* ... */</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>创建<code>Promise</code>实例时，最终是要解析出一个值。通常需要显式声明<code>Promise</code>的泛型类型实参，如果没有显式地泛型类型实参，<code>TypeScript</code>默认假设参数类型为<code>unknown</code>。向<code>Promise</code>构造函数明确提供类型实参，编译器会解析<code>Promise</code>实例的类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">resolvesUnknown</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Promise</span>((<span style="color:#a6e22e">resolve</span>) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">setTimeout</span>(() <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">resolve</span>(<span style="color:#e6db74">&#34;Done!&#34;</span>), <span style="color:#ae81ff">1000</span>);
</span></span><span style="display:flex;"><span>})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: Promise&lt;string&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">resolvesString</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Promise</span>&lt;<span style="color:#f92672">string</span>&gt;((<span style="color:#a6e22e">resolve</span>) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">setTimeout</span>(() <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">resolve</span>(<span style="color:#e6db74">&#34;Done!&#34;</span>), <span style="color:#ae81ff">1000</span>);
</span></span><span style="display:flex;"><span>});
</span></span></code></pre></div><p><code>Promise</code>的泛型<code>.then</code>方法引入了一个新的类型参数，代表<code>Promise</code>返回的解析值。下面示例中，创建了一个<code>textEventually</code>的<code>Promise</code>，它1秒后，<code>resolve</code>了一个<code>string</code>类型的值，还创建了一个<code>lengthEventually</code>，再等一秒<code>resolve</code>出<code>number</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// Type: Promise&lt;string&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">textEventually</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Promise</span>&lt;<span style="color:#f92672">string</span>&gt;((<span style="color:#a6e22e">resolve</span>) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">setTimeout</span>(() <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">resolve</span>(<span style="color:#e6db74">&#34;Done!&#34;</span>), <span style="color:#ae81ff">1000</span>);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: Promise&lt;number&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">lengthEventually</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">textEventually</span>.<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">text</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">text</span>.<span style="color:#a6e22e">length</span>)
</span></span></code></pre></div><h3 id="async-functions">Async Functions</h3>
<p>在<code>JavaScript</code>中任何以<code>async</code>关键字声明的函数都返回一个<code>Promise</code>。如果在<code>async</code>函数中返回的值不是<code>Thenable</code>的（一个对象和<code>.then</code>方法，几乎总是一个<code>Promise</code>），返回值会被封装在一个<code>Promise</code>中，就像调用了<code>Promise.resolve</code>一样。<code>TypeScript</code>可以识别这一点，并会推断<code>async</code>函数的返回类型始终是<code>Promise</code>，无论返回的是什么值。</p>
<p>下面示例代码中，函数<code>lengthAfterSecond</code>返回一个<code>Promise&lt;number&gt;</code>，而<code>lengthImmediately</code>被推断返回为返回<code>Promise&lt;number&gt;</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">lengthAfterSecond</span>(<span style="color:#a6e22e">text</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">await</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Promise</span>((<span style="color:#a6e22e">resolve</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">setTimeout</span>(<span style="color:#a6e22e">resolve</span>, <span style="color:#ae81ff">1000</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">text</span>.<span style="color:#a6e22e">length</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: (text: string) =&gt; Promise&lt;number&gt; 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">lengthImmediately</span>(<span style="color:#a6e22e">text</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">text</span>.<span style="color:#a6e22e">length</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>因此，在<code>async</code>函数上手动声明的任何返回类型都必须是<code>Promise</code>类型，即使函数在实现中没有明确提及 <code>Promise</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">givesPromiseForString</span>()<span style="color:#f92672">:</span> <span style="color:#a6e22e">Promise</span>&lt;<span style="color:#f92672">string</span>&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;Done!&#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">givesString</span>()<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ~~~~~~ // Error: The return type of an async function // or method must be the global Promise&lt;T&gt; type.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;Done!&#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="using-generics-right">Using Generics Right</h2>
<p>如前面的<code>Promise&lt;Value&gt;</code>实现一样，虽然泛型可为我们在代码中描述类型提供很大的灵活性，但它们也会很快变得相当复杂。刚接触<code>TypeScript</code>的程序员经常会经历一个过度使用泛型的阶段，以至于代码读起来令人困惑，使用起来过于复杂。<code>TypeScript</code>的最佳实践通常是在必要时才使用泛型，并明确泛型的用途。</p>
<h3 id="the-golden-rule-of-generics">The Golden Rule of Generics</h3>
<p>有一个快速测试方法可以帮助确定函数是否需要类型参数，那就是类型参数至少要使用两次。泛型描述的是类型之间的关系，因此如果一个泛型类型参数只出现在一个地方，它就不可能定义多个类型之间的关系。</p>
<p>每个函数类型参数都应该用于一个形参，然后还至少用于一个其他参数和/或函数的返回类型。下面示例中，<code>logInput</code>函数只使用它的<code>Input</code>类型形参一次：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">logInput</span>&lt;<span style="color:#f92672">Input</span> <span style="color:#a6e22e">extends</span> <span style="color:#a6e22e">string</span>&gt;(<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">Input</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Hi!&#34;</span>, <span style="color:#a6e22e">input</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="type-assert">type assert</h3>
<p>需要注意的是，<font color="#de7802">类型断言只能暂时欺骗编译器，无法避免运行时错误</font>。滥用类型断言可能会导致运行时错误，下面代码无编译错误，但会出现运行时错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Cat</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">run</span>()<span style="color:#f92672">:</span> <span style="color:#66d9ef">void</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Fish</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">swim</span>()<span style="color:#f92672">:</span> <span style="color:#66d9ef">void</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">isFish</span>(<span style="color:#a6e22e">animal</span>: <span style="color:#66d9ef">Cat</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">Fish</span>) {
</span></span><span style="display:flex;"><span>    (<span style="color:#a6e22e">animal</span> <span style="color:#66d9ef">as</span> <span style="color:#a6e22e">Fish</span>).<span style="color:#a6e22e">swim</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">cat</span>: <span style="color:#66d9ef">Cat</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Hello&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">run</span>()<span style="color:#f92672">:</span> <span style="color:#66d9ef">void</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">isFish</span>(<span style="color:#a6e22e">cat</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 出现运行时错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#a6e22e">animal</span>.<span style="color:#a6e22e">swim</span> <span style="color:#66d9ef">is</span> <span style="color:#a6e22e">not</span> <span style="color:#a6e22e">a</span> <span style="color:#66d9ef">function</span>
</span></span></code></pre></div><p>下面示例代码中，使用<code>instanceof</code>来判断变量是否是某个类的实例是合适的。但某些情况下，<code>ApiError</code>和<code>HttpError</code>不是一个类，而是接口类型。<font color=LightSeaGreen>接口是一个类型并不是一个真正的值，它在编译结果中会被删除</font>，因此无法使用<code>instanceof</code>来做运行时判断。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ApiError</span> <span style="color:#66d9ef">extends</span> Error {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">code</span>: <span style="color:#66d9ef">number</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">HttpError</span> <span style="color:#66d9ef">extends</span> Error {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">statusCode</span>: <span style="color:#66d9ef">number</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">200</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">isApiError</span>(<span style="color:#a6e22e">error</span>: <span style="color:#66d9ef">Error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">error</span> <span style="color:#66d9ef">instanceof</span> <span style="color:#a6e22e">ApiError</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>此时只能使用类型断言：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">ApiError</span> <span style="color:#66d9ef">extends</span> Error {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">code</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">HttpError</span> <span style="color:#66d9ef">extends</span> Error {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">statusCode</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">isApiError</span>(<span style="color:#a6e22e">error</span>: <span style="color:#66d9ef">Error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (<span style="color:#a6e22e">error</span> <span style="color:#66d9ef">as</span> <span style="color:#a6e22e">ApiError</span>).<span style="color:#a6e22e">code</span> <span style="color:#f92672">===</span> <span style="color:#ae81ff">23</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="enum">enum</h3>
<p>由于enum编译后是一个对象，所以<font color="#de7802">不能有与它同名的变量，对象，函数和类等</font>。如果存在同名的变量、对象、函数或类，将会出现编译错误。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 下面代码中由于枚举和变量名重复了，所以会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Enum declarations can only merge with namespace or other enum declarations.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Test1</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Local</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;local&#39;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Remote</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;remote&#39;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">Test1</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;890&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误 Enum declarations can only merge with namespace or other enum declarations.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Test2</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span>,  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">B</span>  
</span></span><span style="display:flex;"><span>}  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Test2</span> {  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>枚举的成员不强制赋初始值，若没有赋初始值，系统默认从0开始逐一增1，按顺序为每个成员赋值。下面示例代码中，枚举成员(或称属性)对应值分别为<code>0，1，2</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">B</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">C</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">Foo</span>.<span style="color:#a6e22e">A</span>, <span style="color:#a6e22e">Foo</span>.<span style="color:#a6e22e">B</span>, <span style="color:#a6e22e">Foo</span>.<span style="color:#a6e22e">C</span>) <span style="color:#75715e">// 0 1 2
</span></span></span></code></pre></div><p>enum属性的值可以是小数:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.12</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">B</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">C</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">Foo</span>.<span style="color:#a6e22e">A</span>, <span style="color:#a6e22e">Foo</span>.<span style="color:#a6e22e">B</span>, <span style="color:#a6e22e">Foo</span>.<span style="color:#a6e22e">C</span>) <span style="color:#75715e">// 0.12 1.12 2.12
</span></span></span></code></pre></div><p>enum属性（成员）的值不能是<code>BigInt</code>类型:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Type &#39;bigint&#39; is not assignable to type &#39;number&#39; as required for computed enum member values.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span><span style="color:#a6e22e">n</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>enum<font color=LightSeaGreen>属性对应的值可以相同，但属性名一定不能相同</font>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.12</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">B</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.1</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">C</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.12</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果只设置第一个属性的值，后面成员的值就会从这个值开始依次递增（默认在上一个值的基础上<code>+1</code>）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Color</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Red</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">7</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Green</span>, <span style="color:#75715e">// 8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">Blue</span>, <span style="color:#75715e">// 9
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 或者
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Color</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Red</span>, <span style="color:#75715e">// 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">Green</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">7</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Blue</span>, <span style="color:#75715e">// 8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>enum所有属性对应的值都是只读的，不能重新被赋值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Color</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Red</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Green</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Blue</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译报错:Cannot assign to &#39;Blue&#39; because it is a read-only property.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">Color</span>.<span style="color:#a6e22e">Red</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>; 
</span></span></code></pre></div><p>为了强调这一点，通常在<code>enum</code>关键字前面加上<code>const</code>修饰，表示这是常量，不能再次赋值。加上<code>const</code>还有一个好处，编译为<code>JavaScript</code>代码后，枚举的成员会被替换成对应的值，可以提升性能。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Color</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Red</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Green</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Blue</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>enum成员的值也可以是计算属性。但需要注意，如果在定义枚举时添加了<code>const</code>，<font color=LightSeaGreen>就不能再使用计算属性定义其中的成员</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Bool</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">No</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">123</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Yes</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>(),
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 正常
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Test</span> {
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">No</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">123</span>,
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">Yes</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">+</span> <span style="color:#a6e22e">numb</span>,
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">Third</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">getNum</span>(<span style="color:#ae81ff">12</span>)
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getNum</span>(<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span> {
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">return</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">+</span> <span style="color:#a6e22e">x</span>
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 出现编译错误:const enum member initializers must be constant expressions.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Test1</span> {
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">No</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">123</span>,
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">Yes</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">+</span> <span style="color:#a6e22e">numb</span>,
</span></span><span style="display:flex;"><span> }
</span></span></code></pre></div><p>enum成员的值除了设为数值，还可以设为字符串。也就是说，enum也可以作为一组字符串的集合。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Direction</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Up</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;UP&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Down</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;DOWN&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Left</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;LEFT&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Right</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;RIGHT&#34;</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>需要注意的是，<font color="#de7802">字符串枚举的所有成员都必须显式设置对应值</font>。如果成员值没有显式设置为字符串，成员值默认为数值，且其<font color=LightSeaGreen>位置必须在字符串成员之前</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span>, <span style="color:#75715e">// 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">B</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">C</span>, <span style="color:#75715e">// 报错 Enum member must have initializer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>enum成员可以字符串和数值的混合，如果要使用默认的数值，则成员必需放在字符串之前：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Foo</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">zero</span>,  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">One</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;One&#34;</span>,  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Two</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Two&#34;</span>,  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Three</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>,  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Four</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>,  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>enum的成员<font color="#de7802">除了数值和字符串，不允许使用其它值</font>。若变量类型是字符串enum，不能使用字符串直接赋值该变量，这跟数值enum变量不一样。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Enum</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">One</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;One&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Two</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Two&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Three</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Four</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">test</span>(<span style="color:#a6e22e">a</span>: <span style="color:#66d9ef">Enum</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">a</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">test</span>(<span style="color:#ae81ff">3</span>) <span style="color:#75715e">// 正常
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误:Argument of type &#39;&#34;One&#34;&#39; is not assignable to parameter of type &#39;Enum&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">test</span>(<span style="color:#e6db74">&#34;One&#34;</span>) 
</span></span></code></pre></div><p>需要注意的是，<font color=LightSeaGreen>enum的字符串类型成员值不能使用表达式赋值</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">MyEnum</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;one&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">B</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;T&#34;</span>, <span style="color:#e6db74">&#34;w&#34;</span>, <span style="color:#e6db74">&#34;o&#34;</span>].<span style="color:#a6e22e">join</span>(<span style="color:#e6db74">&#34;&#34;</span>),
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Type &#39;string&#39; is not assignable to type &#39;number&#39; as required for computed enum member values.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">MyEnum</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;one&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">B</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;T&#34;</span>.<span style="color:#a6e22e">repeat</span>(<span style="color:#ae81ff">12</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Type &#39;string&#39; is not assignable to type &#39;number&#39; as required for computed enum member values.
</span></span></span></code></pre></div><p>同名的enum可以合并，但是合并时，不能有同名的成员，否则会出现编译报错。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误:Duplicate identifier &#39;A&#39;.
</span></span></span></code></pre></div><p>同名enum合并时，只允许其中的一个同名枚举的第一个成员省略初始值，否则会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">B</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误:In an enum with multiple declarations, only one declaration can omit an initializer for its first enum element
</span></span></span></code></pre></div><p>同名enum合并的另一个限制，所有枚举定义必须同为<code>const</code>或者非<code>const</code>，不允许混合使用。同名enum合并的最大用处是补充外部定义的enum。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">B</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Enum declarations can only merge with namespace or other enum declarations.
</span></span></span></code></pre></div><p>枚举的反向映射，是指通过属性值获取到属性名：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">B</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">C</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">Foo</span>[<span style="color:#ae81ff">3</span>], <span style="color:#a6e22e">Foo</span>[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;C&#39;</span>) <span style="color:#75715e">// undefined true
</span></span></span></code></pre></div><p>枚举的反向映射只发生enum的数值成员，<font color=LightSeaGreen>对于字符串成员值，不存在反向映射</font>，因为字符串enum编译后只有一组赋值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Foo</span> {  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">A</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>,  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">B</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>,  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">C</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>,  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">D</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;CHEN&#39;</span>,  
</span></span><span style="display:flex;"><span>}  
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误:Cannot find name &#39;D&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">Foo</span>[<span style="color:#ae81ff">3</span>], <span style="color:#a6e22e">Foo</span>[<span style="color:#a6e22e">D</span>])
</span></span></code></pre></div><p><a href="https://typescript.p6p.net/typescript-tutorial/enum.html">参考资料1</a></p>
<h3 id="namespaces">NameSpaces</h3>
<p><code>namespace</code>用于建立一个容器，其<font color=LightSeaGreen>内部的所有变量和函数，默认都必须在这个容器里使用</font>。下面示例代码中，<code>isString</code>只能在命名空间<code>Utils</code>中使用，如果在外部直接使用函数<code>isString</code>，就会报错。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> <span style="color:#a6e22e">Utils</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">isString</span>(<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">any</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;string&#39;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 在内部使用不会报错
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">isString</span>(<span style="color:#e6db74">&#39;test&#39;</span>))
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 在外部直接使用报错Cannot find name &#39;isString&#39;. Did you mean &#39;String&#39;?
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">isString</span>(<span style="color:#e6db74">&#39;test&#39;</span>))
</span></span></code></pre></div><p>如果要在命名空间以外使用内部成员，就必须在该成员前面加上<code>export</code>关键字，表示对外导出该成员，否则会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> <span style="color:#a6e22e">Utils</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">isString</span>(<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">any</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;string&#39;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">isString</span>(<span style="color:#e6db74">&#39;test&#39;</span>))
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 下面会出现编译错误：Property &#39;isString&#39; does not exist on type &#39;typeof Utils&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">Utils</span>.<span style="color:#a6e22e">isString</span>(<span style="color:#e6db74">&#39;test&#39;</span>)) 
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> <span style="color:#a6e22e">Utils</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 只有添加export后才不会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">export</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">isString</span>(<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">any</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;string&#39;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">Utils</span>.<span style="color:#a6e22e">isString</span>(<span style="color:#e6db74">&#39;test&#39;</span>))
</span></span></code></pre></div><p>编译成<code>JavaScript</code>代码后，命名空间<code>Utils</code>变成了一个对象，<font color=LightSeaGreen>凡是在命名空间中<code>export</code>的内部成员，都成为了该对象的属性</font>。也就是说<code>namespace</code>会变成一个值，保留在编译后的代码中，这一点要小心，它不是纯类型代码。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> <span style="color:#a6e22e">Utils</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">export</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">isString</span>(<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">any</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;string&#39;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">isString</span>(<span style="color:#e6db74">&#39;test&#39;</span>))
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> <span style="color:#a6e22e">App</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">import</span> <span style="color:#a6e22e">isString</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Utils</span>.<span style="color:#a6e22e">isString</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">isString</span>(<span style="color:#e6db74">&#39;yes&#39;</span>))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>namespace</code>内部还可以使用<code>import</code>命令导入外部成员，<font color=LightSeaGreen>相当于给外部成员起别名</font>。当外部成员的名字比较长时，别名能够简化代码。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> <span style="color:#a6e22e">Utils</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">export</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">isString</span>(<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">any</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;string&#34;</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> <span style="color:#a6e22e">App</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">import</span> <span style="color:#a6e22e">isString</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Utils</span>.<span style="color:#a6e22e">isString</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">isString</span>(<span style="color:#e6db74">&#34;yes&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 等同于
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">Utils</span>.<span style="color:#a6e22e">isString</span>(<span style="color:#e6db74">&#34;yes&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><a href="https://ts.xcatliu.com/basics/declaration-files.html">参考资料2</a></p>
<p><a href="https://forums.developer.apple.com/forums/thread/110312">WK中使用sock5代理</a></p>
<p><a href="https://github.com/betafish-inc/OpenVPNAdapter">openAdapter</a></p>

    </div>
    <footer class="post-footer">
        
 
<div class="post-tags">     
     
    <a href="https://iihui.github.io/tags/ts" rel="tag" title="ts">#ts#</a>
    
</div>



        <div class="post-nav">
    <div class="post-nav-next post-nav-item">
    
        <a href="https://iihui.github.io/post/tool-rider/" rel="next" title="Rider 使用">
        <i class="fa fa-chevron-left"></i> Rider 使用
        </a>
    
    </div>

    <div class="post-nav-prev post-nav-item">
    
        <a href="https://iihui.github.io/post/ios-fundamentals/" rel="prev" title="iOS 14 编程基础">
        iOS 14 编程基础 <i class="fa fa-chevron-right"></i>
        </a>
    
    </div>
</div>
      
        <div class="post-nav">
    <div style="border: 1px dashed #e0e0e0; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
        <div style="float:left;margin-top:0px;">
            <img src="https://i.loli.net/2020/02/09/SvhUdz4XJsOr9Vk.jpg" width="128px" height="128px"/>
            <div style="text-align:center;">谢谢支持!</div>
        </div>
        <div>
            <p style="margin-top:10px;">
                标题：TypeScript基础
                <br />作者：阿呆<a target="_blank" href="https://iihui.github.io/"></a>
                
                <br />地址：https://iihui.github.io/post/ts-base/
                <br />声明：自由转载-非商用-保持署名（创作共享4.0许可证）
            </p>
        </div>
    </div>
    <div class="clear"></div>
</div>
        
        
        




    </footer>
  </article>
</section>

          </div>
        </div>
        <div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>
<aside id="sidebar" class="sidebar">
  <div class="sidebar-inner">

  <ul class="sidebar-nav motion-element">
    <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
      文章目录
    </li>
    <li class="sidebar-nav-overview" data-target="site-overview">
      站点概览
    </li>
  </ul>

    <section class="site-overview sidebar-panel ">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
        src="https://i.loli.net/2020/02/07/dVFzrvZkHRNq2lL.jpg"
        alt="" />
    <p class="site-author-name" itemprop="name"></p>
    <p class="site-description motion-element" itemprop="description"> 
        coder &amp; cook</p>
</div>
      <nav class="site-state motion-element">
    <div class="site-state-item site-state-posts">
      <a href="https://iihui.github.io/post/">
        <span class="site-state-item-count">142</span>
        <span class="site-state-item-name">日志</span>
      </a>
    </div>
    <div class="site-state-item site-state-categories">    
        <a href="https://iihui.github.io/categories/">      
         
        <span class="site-state-item-count">19</span>
        
        <span class="site-state-item-name">分类</span>
        
        </a>
    </div>

    <div class="site-state-item site-state-tags">
        <a href="https://iihui.github.io/tags/">
         
        <span class="site-state-item-count">30</span>
        
        <span class="site-state-item-name">标签</span>
        </a>
    </div>
</nav>
      
      
<div class="links-of-author motion-element">
    
        <span class="links-of-author-item">
        <a href="https://coolshell.cn" target="_blank" title="皓 大">
            <i class="fa fa-fw fa-globe"></i>
            皓 大
        </a>
        </span>
    
        <span class="links-of-author-item">
        <a href="http://www.ruanyifeng.com" target="_blank" title="阮 大">
            <i class="fa fa-fw fa-globe"></i>
            阮 大
        </a>
        </span>
    
        <span class="links-of-author-item">
        <a href="https://juejin.im/" target="_blank" title="掘 金">
            <i class="fa fa-fw fa-globe"></i>
            掘 金
        </a>
        </span>
    
</div>


      

      <div class="links-of-blogroll motion-element inline">
<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=&amp;m=0&amp;s=220&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;bv=35" async="async"></script>
</div>

    </section>
    
<section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
    <div class="post-toc">
        <div class="post-toc-content"><nav id="TableOfContents">
  <ul>
    <li><a href="#modules">Modules</a></li>
    <li><a href="#unions-and-literals">Unions and Literals</a>
      <ul>
        <li><a href="#union-types">Union Types</a></li>
        <li><a href="#narrowing">Narrowing</a>
          <ul>
            <li><a href="#assignment-narrowing">Assignment Narrowing</a></li>
            <li><a href="#conditional-checks">Conditional Checks</a></li>
          </ul>
        </li>
        <li><a href="#literal-types">Literal Types</a>
          <ul>
            <li><a href="#literal-assignability">Literal Assignability</a></li>
          </ul>
        </li>
        <li><a href="#strict-null-checking">Strict Null Checking</a>
          <ul>
            <li>
              <ul>
                <li><a href="#billion-dollar-mistake">billion-dollar mistake</a></li>
              </ul>
            </li>
            <li><a href="#truthiness-narrowing">Truthiness Narrowing</a></li>
            <li><a href="#variables-without-initial-values">Variables Without Initial Values</a></li>
          </ul>
        </li>
        <li><a href="#type-aliases">Type Aliases</a>
          <ul>
            <li><a href="#type-aliases-are-not-javascript">Type Aliases Are Not JavaScript</a></li>
            <li><a href="#combining-type-aliases">Combining Type Aliases</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#objects">Objects</a>
      <ul>
        <li><a href="#object-types">Object Types</a>
          <ul>
            <li><a href="#declaring-object-types">Declaring Object Types</a></li>
            <li><a href="#aliased-object-types">Aliased Object Types</a></li>
          </ul>
        </li>
        <li><a href="#structural-typing">Structural Typing</a>
          <ul>
            <li><a href="#usage-checking">Usage Checking</a></li>
            <li><a href="#excess-property-checking">Excess Property Checking</a></li>
            <li><a href="#nested-object-types">Nested Object Types</a></li>
            <li><a href="#optional-properties">Optional Properties</a></li>
          </ul>
        </li>
        <li><a href="#unions-of-object-types">Unions of Object Types</a>
          <ul>
            <li><a href="#inferred-object-type-unions">Inferred Object-Type Unions</a></li>
            <li><a href="#explicit-object-type-unions">Explicit Object-Type Unions</a></li>
            <li><a href="#narrowing-object-types">Narrowing Object Types</a></li>
            <li><a href="#discriminated-unions">Discriminated Unions</a></li>
          </ul>
        </li>
        <li><a href="#intersection-types">Intersection Types</a>
          <ul>
            <li><a href="#dangers-of-intersection-types">Dangers of Intersection Types</a></li>
            <li><a href="#never">never</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#functions">Functions</a>
      <ul>
        <li><a href="#function-parameters">Function Parameters</a>
          <ul>
            <li><a href="#required-parameters">Required Parameters</a></li>
            <li><a href="#optional-parameters">Optional Parameters</a></li>
            <li><a href="#default-parameters">Default Parameters</a></li>
            <li><a href="#rest-parameters">Rest Parameters</a></li>
          </ul>
        </li>
        <li><a href="#return-types">Return Types</a>
          <ul>
            <li><a href="#explicit-return-types">Explicit Return Types</a></li>
          </ul>
        </li>
        <li><a href="#function-types">Function Types</a>
          <ul>
            <li><a href="#function-type-parentheses">Function Type Parentheses</a></li>
            <li><a href="#parameter-type-inferences">Parameter Type Inferences</a></li>
            <li><a href="#function-type-aliases">Function Type Aliases</a></li>
          </ul>
        </li>
        <li><a href="#more-return-types">More Return Types</a>
          <ul>
            <li><a href="#never-returns">Never Returns</a></li>
          </ul>
        </li>
        <li><a href="#function-overloads">Function Overloads</a>
          <ul>
            <li><a href="#call-signature-compatibility">Call-Signature Compatibility</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#arrays">Arrays</a>
      <ul>
        <li><a href="#array-types">Array Types</a>
          <ul>
            <li><a href="#array-and-function-types">Array and Function Types</a></li>
            <li><a href="#union-type-arrays">Union-Type Arrays</a></li>
            <li><a href="#evolving-any-arrays">Evolving Any Arrays</a></li>
            <li><a href="#multidimensional-arrays">Multidimensional Arrays</a></li>
          </ul>
        </li>
        <li><a href="#array-members">Array Members</a>
          <ul>
            <li><a href="#caveat-unsound-members">Caveat: Unsound Members</a></li>
          </ul>
        </li>
        <li><a href="#spreads-and-rests">Spreads and Rests</a>
          <ul>
            <li><a href="#spreads">Spreads</a></li>
            <li><a href="#spreading-rest-parameters">Spreading Rest Parameters</a></li>
          </ul>
        </li>
        <li><a href="#tuples">Tuples</a>
          <ul>
            <li><a href="#tuple-assignability">Tuple Assignability</a></li>
            <li><a href="#tuple-inferences">Tuple Inferences</a>
              <ul>
                <li><a href="#explicit-tuple-types">Explicit tuple types</a></li>
                <li><a href="#const-asserted-tuples">Const asserted tuples</a></li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#interfaces">Interfaces</a>
      <ul>
        <li><a href="#type-aliases-versus-interfaces">Type Aliases Versus Interfaces</a></li>
        <li><a href="#types-of-properties">Types of Properties</a>
          <ul>
            <li><a href="#optional-properties-1">Optional Properties</a></li>
            <li><a href="#read-only-properties">Read-Only Properties</a></li>
            <li><a href="#functions-and-methods">Functions and Methods</a></li>
            <li><a href="#call-signatures">Call Signatures</a></li>
            <li><a href="#index-signatures">Index Signatures</a>
              <ul>
                <li><a href="#mixing-properties-and-index-signatures">Mixing properties and index signatures</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#interface-extensions">Interface Extensions</a>
          <ul>
            <li><a href="#overridden-properties">Overridden Properties</a></li>
            <li><a href="#extending-multiple-interfaces">Extending Multiple Interfaces</a></li>
          </ul>
        </li>
        <li><a href="#interface-merging">Interface Merging</a>
          <ul>
            <li><a href="#member-naming-conflicts">Member Naming Conflicts</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#classes">Classes</a>
      <ul>
        <li><a href="#class-methods">Class Methods</a></li>
        <li><a href="#class-properties">Class Properties</a>
          <ul>
            <li><a href="#function-properties">Function Properties</a></li>
            <li><a href="#initialization-checking">Initialization Checking</a>
              <ul>
                <li><a href="#definitely-assigned-properties">Definitely assigned properties</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#optional-properties-2">Optional Properties</a></li>
        <li><a href="#read-only-properties-1">Read-Only Properties</a></li>
        <li><a href="#classes-as-types">Classes as Types</a></li>
        <li><a href="#classes-and-interfaces">Classes and Interfaces</a>
          <ul>
            <li><a href="#implementing-multiple-interfaces">Implementing Multiple Interfaces</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#generics">Generics</a>
      <ul>
        <li><a href="#generic-interfaces">Generic Interfaces</a>
          <ul>
            <li><a href="#inferred-generic-interface-types">Inferred Generic Interface Types</a></li>
          </ul>
        </li>
        <li><a href="#promises">Promises</a>
          <ul>
            <li><a href="#creating-promises">Creating Promises</a></li>
            <li><a href="#async-functions">Async Functions</a></li>
          </ul>
        </li>
        <li><a href="#using-generics-right">Using Generics Right</a>
          <ul>
            <li><a href="#the-golden-rule-of-generics">The Golden Rule of Generics</a></li>
            <li><a href="#type-assert">type assert</a></li>
            <li><a href="#enum">enum</a></li>
            <li><a href="#namespaces">NameSpaces</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav></div>
    </div>
</section>

  </div>
</aside>

      </div>
    </main>
   
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  <span itemprop="copyrightYear">  &copy; 
  2017 - 2024</span>
  <span class="with-love"><i class="fa fa-heart"></i></span>
  <span class="author" itemprop="copyrightHolder">Keep It Simple</span>
</div>




      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      <span id="scrollpercent"><span>0</span>%</span>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/jquery/index.js?v=2.1.3"></script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script> 
<script type="text/javascript" src="https://iihui.github.io/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/velocity/velocity.min.js?v=1.2.1"></script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="https://iihui.github.io/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>

<script src="https://iihui.github.io/js/vendor/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>

<script type="text/javascript" src="https://iihui.github.io/js/utils.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/motion.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/affix.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/schemes/pisces.js"></script>

<script type="text/javascript" src="https://iihui.github.io/js/scrollspy.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/post-details.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/toc.js"></script>

<script type="text/javascript" src="https://iihui.github.io/js/bootstrap.js"></script>

<script type="text/javascript" src="https://iihui.github.io/js/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
</body>
</html>