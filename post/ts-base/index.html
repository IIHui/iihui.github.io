<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
    <title>TypeScript基础 - Keep It Simple</title>
    <meta name="keywords" content="博客,思考,读书,笔记,技术,分享">
    
    <meta property="og:title" content="TypeScript基础">
    <meta property="og:site_name" content="Keep It Simple">
    <meta property="og:image" content="/img/author.jpg"> 
    <meta name="title" content="TypeScript基础 - Keep It Simple" />
    <meta name="description" content="Swift | Go | C&#43;&#43; "> 
    <link rel="shortcut icon" href="https://iihui.github.io/img/favicon.ico" />
    <link rel="apple-touch-icon" href="https://iihui.github.io/img/apple-touch-icon.png" />
    <link rel="apple-touch-icon-precomposed" href="https://iihui.github.io/img/apple-touch-icon.png" />
    <link href="https://iihui.github.io/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />
    <link href="https://iihui.github.io/js/vendor/fancybox/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />
    <link href="https://iihui.github.io/css/main.css" rel="stylesheet" type="text/css" />
    <link href="https://iihui.github.io/css/syntax.css" rel="stylesheet" type="text/css" />

    <script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
     fancybox: true, 
    motion: true
  };
</script>

    <link href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/monokai-sublime.min.css" rel="stylesheet">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/go.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/swift.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/objectivec.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/clojure.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/kotlin.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/yaml.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<div class="container one-collumn sidebar-position-left page-home  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-meta  custom-logo ">

  <div class="custom-logo-site-title">
    <a href="https://iihui.github.io/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Keep It Simple</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">靡不有初，鲜克有终</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
    <ul id="menu" class="menu">
      
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/tags/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-tag"></i> <br />标签
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/post/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/categories/%E7%BE%8E%E9%A3%9F/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-fire"></i> <br />美食
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/categories/%E5%90%8E%E6%9C%9F/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-edit"></i> <br />后期
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/categories/%E6%97%85%E8%A1%8C/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-leaf"></i> <br />旅行
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/about/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于
          </a>
        </li>
      
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger"> <i class="menu-item-icon fa fa-search fa-fw"></i> <br /> 搜索</a>
      </li>
    </ul>
    <div class="site-search">
      <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>

    </div>
</nav>
<script type="text/javascript"
        async
        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
		<!-- src = "http://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> <\!--  -\-> -->
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>

<!DOCTYPE html>
<html lang="en">


<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css" integrity="sha384-D+9gmBxUQogRLqvARvNLmA9hS2x//eK1FhVb9PiU86gmcrBrJAQT8okdJ4LMp2uv" crossorigin="anonymous">

    
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js" integrity="sha384-483A6DwYfKeDa0Q52fJmxFXkcPCFfnXMoXblOkJ4JcA8zATN6Tm78UNL72AKk+0O" crossorigin="anonymous"></script>
</head>
<body>

</body>
</html>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
<section id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="https://iihui.github.io/post/ts-base/" itemprop="url">
        TypeScript基础
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">创建: </span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2022-01-27">
    2022-01-27
</time>
</span>
&nbsp; | &nbsp;
<span class="post-updated-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-check-o"></i>
</span>
<span class="post-meta-item-text">更新: </span>
<time itemprop="dateUpdated" content="2022-01-27">
    2022-01-27
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类: </span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="https://iihui.github.io/categories/ts" itemprop="url" rel="index">
        <span itemprop="name">ts</span>
      </a>
      &nbsp; 
    </span>
  
</span>


      <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-file-word-o"></i>
</span>
<span class="post-meta-item-text">字数: </span>
<span class="leancloud-visitors-count">20561</span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-coffee"></i>
</span>
<span class="post-meta-item-text">阅读: </span>
<span class="leancloud-visitors-count">42 分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <p><code>TypeScript</code>的7种基本类型为：</p>
<ul>
<li><code>null</code></li>
<li><code>undefined</code></li>
<li><code>boolean</code></li>
<li><code>string</code></li>
<li><code>number</code></li>
<li><code>bigint</code></li>
<li><code>symbol</code></li>
</ul>
<p>若声明变量的时候不指定类型，编译器会认为该变量的类型为<code>any</code>，表示该变量可以被赋值为任何类型的值。如果声明变量时既不指定类型也不初始化，立即使用<code>typeof</code>得到的结果为<code>undefined</code>(因为类型只在<code>TypeScript</code>中生效，编译成<code>JavaScript</code>后，未初始化变量的默认值为<code>undefined</code>)：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">rocker</span>; <span style="color:#75715e">// Type: any
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">rocker</span>) <span style="color:#75715e">// undefined
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">rocker</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Joan Jett&#34;</span>; <span style="color:#75715e">// 此时类型为string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">rocker</span>.<span style="color:#a6e22e">toUpperCase</span>(); <span style="color:#75715e">// JOAN JETT
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">rocker</span>, <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">rocker</span>) <span style="color:#75715e">// Joan Jett string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">rocker</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">19.58</span>; <span style="color:#75715e">// 此时类型为number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">rocker</span>, <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">rocker</span>) <span style="color:#75715e">// 19.58 number
</span></span></span></code></pre></div><p>函数的<font color=red>可选参数必须是最后一个参数</font>，若将可选参数放置在必需参数前，则会出现编译错误。下面代码会出现<code>A required parameter cannot follow an optional parameter</code>错误:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">hello3</span>(<span style="color:#a6e22e">x?</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：A required parameter cannot follow an optional parameter
</span></span></span></code></pre></div><p>具有默认值的参数<font color=red>如果不位于参数列表的末尾，调用时不能省略该参数，如果要触发默认值，必须显式地传入<code>undefined</code></font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">hello3</span>(<span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>, <span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">hello3</span>(<span style="color:#66d9ef">undefined</span>, <span style="color:#ae81ff">890</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">3</span> <span style="color:#ae81ff">890</span>
</span></span></code></pre></div><h2 id="modules">Modules</h2>
<p><code>JavaScript</code>编程语言最近才规范了文件之间如何共享代码。<code>ECMAScript 2015</code>增加了<code>ECMAScript Modules</code>以规范文件间的<code>import</code>和<code>export</code>语法。</p>
<p>在<code>module</code>文件中声明的任何内容都只能在该文件中使用，<font color=LightSeaGreen>除非该文件中有明确的<code>export</code>语句</font>。下面代码从同级的<code>./values</code>文件中导入了一个值，并导出了一个<code>doubled</code>常量值:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">//values.ts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">12</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// test.ts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">import</span> {<span style="color:#a6e22e">value</span>} <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#34;./values&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">doubled</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>;
</span></span></code></pre></div><p>如果在某一个模块中声明的变量和另一个模块中声明的变量同名，一般不会冲突。只有当在一个文件中导入了另一个文件的同名变量时，才会产生冲突。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#75715e">// a.ts 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">shared</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Cher&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// b.ts 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">shared</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Cher&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// c.ts 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">import</span> { <span style="color:#a6e22e">shared</span> } <span style="color:#66d9ef">from</span> <span style="color:#e6db74">&#34;./a&#34;</span>; <span style="color:#75715e">// 编译错误：Import declaration conflicts with local declaration of &#39;shared&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">shared</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Cher&#34;</span>; <span style="color:#75715e">//编译错误： Individual declarations in merged declaration &#39;shared&#39; must be all exported or all local.
</span></span></span></code></pre></div><p>如果文件是脚本，<code>TypeScript</code>会<font color=red>将其视为全局作用域，这意味着其它所有脚本都可以访问其内容</font>。也就是说，在某个脚本文件中声明的变量不能与其它脚本文件中声明的变量同名。</p>
<p>下面<code>a.ts</code>和<code>b.ts</code>文件均会被认为是脚本，因为它们没有<code>export</code>和<code>import</code>语句。这意味着如果在这两个文件中有同名的变量，就会有冲突：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// a.ts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">shared</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Cher&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// b.ts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">shared</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Cher&#34;</span>; <span style="color:#75715e">// 编译错误：Cannot redeclare block-scoped variable &#39;shared&#39;.
</span></span></span></code></pre></div><p>根据<code>ECMAScript</code>规范，如果需要将一个没有<code>export</code>或<code>import</code>语句的文件变成模块，可以在文件的<font color=red>某个地方添加一个<code>export {};</code>语句来强制它成为一个模块</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// a.ts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">shared</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Cher&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// b.ts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">shared</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Cher&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">export</span> {};
</span></span></code></pre></div><h2 id="unions-and-literals">Unions and Literals</h2>
<p>联合：将值的允许类型扩展为两种或两种以上的可能类型。窄化：减少值的允许类型，使其不属于一种或多种可能的类型。联合和窄化是一个强大的概念，它允许<code>TypeScript</code>对代码做出其他主流语言无法做出的明智推断。</p>
<h3 id="union-types">Union Types</h3>
<p>下面变量<code>mathematician</code>既可以是<code>undefined</code>类型，也可以是<code>string</code>类型。<font color=red>这种非此即彼的类型被称为联合类型</font>。联合类型是一个奇妙的概念，它可以让我们在代码中处理这样的情况：暂时不知道某个值的确切类型，但知道它是两个或多个类型之一。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// 类型为string | undefined
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">mathematician</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> <span style="color:#66d9ef">undefined</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Mark Goldberg&#34;</span>;
</span></span></code></pre></div><p><code>TypeScript</code>使用管道操作符<code>|</code>来连接可能的类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">mathematician</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> <span style="color:#66d9ef">undefined</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Mark Goldberg&#34;</span>;
</span></span></code></pre></div><p>在变量有初始值的情况下，也显式地声明变量为联合类型有时很有用。下面代码中，<code>thinker</code>一开始是<code>null</code>，但在某些情况下也可能是一个字符串。给它一个显式<code>string | null</code>联合类型，意味着允许给它赋为字符串类型的值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">thinker</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">thinker</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Susanne Langer&#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">thinker</span>, <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">thinker</span>)  <span style="color:#75715e">// 生成随机数不同，每次执行结果不同
</span></span></span></code></pre></div><p>联合类型声明可以放置在任何声明一个类型的地方。<font color=red>当已知值是一个联合类型时，<code>TypeScript</code>只允许访问联合中所有类型都存在的共有成员属性</font>。如果尝试访问的不是所有类型的共有属性，将会出现编译错误。</p>
<p>下面代码中，<code>physicist</code>是一个<code>number|string</code>联合类型变量。而<code>toString()</code>方法在两种类型中都存在，但<code>toUpperCase</code>方法仅存在于<code>string</code>类型，<code>toFixed</code>方法仅存在于<code>number</code>类型。所以，直接调用<code>toUpperCase</code>和<code>toFixed</code>都会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">physicist</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;Marie Curie&#34;</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">84</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">physicist</span>.<span style="color:#a6e22e">toString</span>()
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">physicist</span>.<span style="color:#a6e22e">toUpperCase</span>(); <span style="color:#75715e">//  编译错误：Property &#39;toUpperCase&#39; does not exist on type &#39;string | number&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">Property</span> <span style="color:#e6db74">&#39;toUpperCase&#39;</span> <span style="color:#a6e22e">does</span> <span style="color:#a6e22e">not</span> <span style="color:#a6e22e">exist</span> <span style="color:#a6e22e">on</span> <span style="color:#66d9ef">type</span> <span style="color:#e6db74">&#39;number&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">physicist</span>.<span style="color:#a6e22e">toFixed</span>();
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Property &#39;toFixed&#39; does not exist on type &#39;string | number&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">Property</span> <span style="color:#e6db74">&#39;toFixed&#39;</span> <span style="color:#a6e22e">does</span> <span style="color:#a6e22e">not</span> <span style="color:#a6e22e">exist</span> <span style="color:#a6e22e">on</span> <span style="color:#66d9ef">type</span> <span style="color:#e6db74">&#39;string&#39;</span>
</span></span></code></pre></div><p>限制访问并不存在于联合类型中所有子类型的属性是一种安全措施。如果一个对象还不确定是否是包含某个属性的子类型，<code>TypeScript</code>会认为尝试使用该属性是不安全的。</p>
<p>如果要使用仅存在于联合类型中某个子类型的属性或方法，我们的代码需要向<code>TypeScript</code>表明在该位置的值是就是某个具体的子类型，这一过程被称为窄化（<code>narrowing</code>）。</p>
<h3 id="narrowing">Narrowing</h3>
<p>窄化是指<code>TypeScript</code>从我们的代码中推断出一个值的类型比其定义或声明时的类型更具体。一旦 <code>TypeScript</code>知道一个值的类型比之前已知的类型范围更窄，将允许将该值视为更具体的类型。</p>
<p>用于窄化类型范围的逻辑检查称为类型保护。下面我们来介绍<code>TypeScript</code>可以用来从代码中窄化类型的两种常见类型保护。</p>
<h4 id="assignment-narrowing">Assignment Narrowing</h4>
<p>如果直接赋值给一个联合类型变量，<code>TypeScript</code>会将变量的类型缩小为该值的类型。下面代码中，变量<code>admiral</code>声明为<code>number | string</code>联合类型。一旦赋值为字符串<code>&quot;Grace Hopper&quot;</code>，<code>TypeScript</code>就知道它是字符串类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">admiral</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">admiral</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Grace Hopper&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">admiral</span>.<span style="color:#a6e22e">toUpperCase</span>(); <span style="color:#75715e">// Ok: string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">admiral</span>.<span style="color:#a6e22e">toFixed</span>(); <span style="color:#75715e">// 编译错误：Property &#39;toFixed&#39; does not exist on type &#39;string&#39;
</span></span></span></code></pre></div><p>当变量的类型显式地声明为联合类型并且同时有一个初始值时，赋值窄化就会发挥作用。<code>TypeScript</code>会知道，虽然变量以后可能会接收任何联合类型的值，但它初始时只是初始值的类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">inventor</span>: <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Hedy Lamarr&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">inventor</span>.<span style="color:#a6e22e">toUpperCase</span>();
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">inventor</span>.<span style="color:#a6e22e">toFixed</span>(); <span style="color:#75715e">// 编译错误：Property &#39;toFixed&#39; does not exist on type &#39;string&#39;
</span></span></span></code></pre></div><h4 id="conditional-checks">Conditional Checks</h4>
<p>让<code>TypeScript</code>缩小变量类型范围的常见方法是编写<code>if</code>语句，检查变量是否等于已知值。<code>TypeScript</code>非常聪明，它知道在<code>if</code>语句的主体中，变量必须与已知值的类型相同：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">scientist</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;Rosalind Franklin&#34;</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">51</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">scientist</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;Rosalind Franklin&#34;</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">scientist</span>.<span style="color:#a6e22e">toUpperCase</span>()) <span style="color:#75715e">// ROSALIND FRANKLIN
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">scientist</span>.<span style="color:#a6e22e">toUpperCase</span>() <span style="color:#75715e">// 编译错误：Property &#39;toUpperCase&#39; does not exist on type &#39;string | number&#39;. Property &#39;toUpperCase&#39; does not exist on type &#39;number&#39;.
</span></span></span></code></pre></div><p>除了直接进行值检查，可以使用<code>typeof</code>操作符缩窄变量的类型范围：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">scientist</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;Rosalind Franklin&#34;</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">51</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">scientist</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;string&#39;</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">scientist</span>.<span style="color:#a6e22e">toUpperCase</span>())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>来自<code>!</code>和<code>else</code>语句的逻辑否定也同样有效：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">researcher</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;Rosalind Franklin&#34;</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">51</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">researcher</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;string&#34;</span>)) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">researcher</span>.<span style="color:#a6e22e">toFixed</span>(); <span style="color:#75715e">// Ok: number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">researcher</span>.<span style="color:#a6e22e">toUpperCase</span>(); <span style="color:#75715e">// Ok: string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h3 id="literal-types">Literal Types</h3>
<p>介绍了联合类型和窄化类型用于处理可能是两种或两种以上可能类型的值之后，我想反其道而行之，介绍一下字面类型：基础类型的更具体版本。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">philosopher</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Hypatia&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">philosopher</span>) <span style="color:#75715e">// string
</span></span></span></code></pre></div><p>上面代码中，<code>philosopher</code>是什么类型？乍一看，你可能会说是字符串，没错，<code>philosopher</code>变量的确是字符串。但是，<code>philosopher</code>并不是一个普通的字符串，它的具体值是<code>&quot;Hypatia&quot;</code>。因此，从技术上讲，<code>philosopher</code>变量的类型是更具体的<code>&quot;Hypatia&quot;</code>。</p>
<p>这就是字面类型的概念：是已知基本类型的某个特定值，<font color=red>而不是这些基本类型的任何其他值</font>。字符串基本类型代表了所有可能存在的字符串集合，而字面类型<code>&quot;Hypatia&quot;</code>只代表了这一个字符串。</p>
<p>如果将一个变量声明为<code>const</code>，并直接给它一个字面值，<code>TypeScript</code>将推断出这个变量的类型就是这个字面值类型。这就是为什么在IDE中将鼠标悬停在带有初始字面值的<code>const</code>变量上时，它会显示变量的类型为字面值，而不是更通用的基本类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">philosopher</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Hypatia&#34;</span>;
</span></span></code></pre></div><p>我们可以把每个基本类型看作是所有可能的字面值的联合类型。换句话说，基本类型是该类型所有可能字面值的集合。</p>
<p>除了<code>boolean</code>，<code>null</code>和<code>undefined</code>类型，所有其他基本类型（例如<code>number</code>和<code>string</code>）均有无限多的字面值类型。在典型的<code>TypeScript</code>代码中会出现的常见类型如下：</p>
<ul>
<li><code>boolean</code>: 只有<code>true | false</code></li>
<li><code>null</code>和<code>undefined</code>只有一个字面值，就是它们自己</li>
<li><code>number</code>：<code>0 | 1 | 2 | ... | 0.1 | 0.2 | ...</code></li>
<li><code>string</code>:<code>&quot;&quot; | &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | ... | &quot;aa&quot; | &quot;ab&quot; | &quot;ac&quot; | ...</code></li>
</ul>
<p>联合类型可以将字面值类型和基本类型混合使用。例如，下面变量<code>lifespan</code>表示可以用任何数字或已知的几种字符串字面值类型来表示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">lifespan</span>: <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;ongoing&#34;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;uncertain&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">lifespan</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">89</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">lifespan</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;ongoing&#34;</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">lifespan</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>; <span style="color:#75715e">// 编译错误：Type &#39;true&#39; is not assignable to type &#39;number | &#34;ongoing&#34; | &#34;uncertain&#34;&#39;.
</span></span></span></code></pre></div><h4 id="literal-assignability">Literal Assignability</h4>
<p>我们已经知道，不同的基本类型（如<code>number</code>和<code>string</code>）是不能相互赋值的。同样，<font color=LightSeaGreen>同一基本类型中的不同字面值类型（如<code>0</code>和<code>1</code>）也不能互相赋值</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">specificallyAda</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Ada&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">specificallyAda</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Ada&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">specificallyAda</span>) <span style="color:#75715e">// Ada string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">specificallyAda</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;B&#39;</span> <span style="color:#75715e">// 编译错误: Type &#39;&#34;B&#34;&#39; is not assignable to type &#39;&#34;Ada&#34;&#39;.
</span></span></span></code></pre></div><p>但是，字面值类型可以赋值给相应的基本类型。因为任何特定的字面量字符串值仍然是字符串。所以，下面示例代码是合法的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">specificallyAda</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Ada&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">specificallyAda</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Ada&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">someString</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>; <span style="color:#75715e">// Type: string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">someString</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">specificallyAda</span>
</span></span></code></pre></div><h3 id="strict-null-checking">Strict Null Checking</h3>
<p>在处理可能存在<code>undefined</code>值时，字面值联合的作用尤其明显。<code>TypeScript</code>是现代编程语言浪潮的一部分，这些语言利用严格的空值检查来解决可怕的<code>billion-dollar mistake</code>。</p>
<h4 id="billion-dollar-mistake">billion-dollar mistake</h4>
<p><code>billion-dollar mistake</code>是一个术语，指许多类型系统允许在需要不同类型的地方允许<code>null</code>值。在没有<code>strict null checking</code>的语言中，像下面这样将<code>null</code>赋值给<code>string</code>类型的变量是允许的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">firstName</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>; 
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type &#39;null&#39; is not assignable to type &#39;string&#39;.
</span></span></span></code></pre></div><p><code>TypeScript</code>编译器包含大量选项，可以改变其运行方式。严格空检查（<code>strictNullChecks</code>）是最有用的选项之一，它可以切换是否启用严格<code>null</code>值检查。粗略地说，禁用<code>strictNullChecks</code>意味着会为代码中的每个类型添加<code>| null | undefined</code>，从而允许任何变量接收<code>null</code>或<code>undefined</code>。</p>
<p>如果将<code>strictNullChecks</code>选项设置为<code>false</code>，下面代码会被认为是安全的。但这种方式是错误的，当使用变量<code>nameMaybe</code>调用<code>toLowerCase</code>方法时，它可能是<code>undefined</code>的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">nameMaybe</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;Tony Hoare&#34;</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">nameMaybe</span>.<span style="color:#a6e22e">toLowerCase</span>() <span style="color:#75715e">// Potential runtime error: Cannot read property &#39;toLowerCase&#39; of undefined.
</span></span></span></code></pre></div><p>如果开启了严格空值检查，则下面代码会出现编译错误：<code>'nameMaybe' is possibly 'undefined'.</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">nameMaybe</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;Tony Hoare&#34;</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">nameMaybe</span>.<span style="color:#a6e22e">toLowerCase</span>()  <span style="color:#75715e">//  &#39;nameMaybe&#39; is possibly &#39;undefined&#39;.
</span></span></span></code></pre></div><p>如果没有严格空值检查，就很难确定我们的代码是否会因意外的<code>null</code>或<code>undefined</code>而出错。最佳实践通常是启用<code>strictNullChecks</code>选项。这样做有助于防止崩溃，并消除<code>billion-dollar mistake</code>错误。</p>
<h4 id="truthiness-narrowing">Truthiness Narrowing</h4>
<p>在<code>JavaScript</code>中，除了<code>false, 0, -0, 0n, &quot;&quot;, null, undefined,NaN</code>为<code>falsy</code>值，其它的都是<code>truthy</code>值。如果变量的某些可能值是<code>truthy</code>的，还可以通过<code>truthiness</code>检查以窄化变量类型的范围。</p>
<p>下面代码中，变量<code>geneticist</code>的类型是<code>string | undefined</code>，因为<code>undefined</code>是<code>falsy</code>值，<code>TypeScript</code>可以在<code>if</code>语句体中推断出它必须是<code>string</code>类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">geneticist</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;Barbara McClintock&#34;</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 如果变量真值是true，则一定不是undefined，那么一定是字符串
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">geneticist</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">geneticist</span>.<span style="color:#a6e22e">toUpperCase</span>()) <span style="color:#75715e">// BARBARA MCCLINTOCK
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>逻辑运算符执行真值检查也同样有效，即<code>&amp;&amp;</code>和 <code>?</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">geneticist</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;Barbara McClintock&#34;</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">geneticist</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">geneticist</span>.<span style="color:#a6e22e">toUpperCase</span>())
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">geneticist</span><span style="color:#f92672">?</span>.<span style="color:#a6e22e">toUpperCase</span>())
</span></span></code></pre></div><p>遗憾的是，真值检查不能反过来使用。如果知道类型为<code>string | undefined</code>变量的值是<code>falsy</code>的，这并不能表明它是空字符串还是<code>undefined</code>。</p>
<p>下面代码中，变量<code>biologist</code>的类型为<code>false | string</code>，虽然在<code>if</code>语句体中可以缩小了类型为字符串，但<code>else</code>语句体包含了如果变量值为<code>&quot;&quot;</code>，也就是说在<code>else</code>语句体里变量可以是字符串类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">biologist</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#e6db74">&#34;Rachel Carson&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">biologist</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">biologist</span>; <span style="color:#75715e">// Type: string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">biologist</span>; <span style="color:#75715e">// Type: false | string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h4 id="variables-without-initial-values">Variables Without Initial Values</h4>
<p>在<code>JavaScript</code>中变量没有初始值，则其默认值是<code>undefined</code>。这在类型系统中出现了一个极端情况：如果将一个变量声明为不包括<code>undefined</code>的类型，然后尝试在赋值前使用它，会出现什么情况。</p>
<p><code>TypeScript</code>很聪明，它知道在变量赋值之前，其值是<code>undefined</code>。如果在赋值前尝试使用该变量的值，会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">mathematician</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">mathematician</span><span style="color:#f92672">?</span>.<span style="color:#a6e22e">length</span>; <span style="color:#75715e">//  Variable &#39;mathematician&#39; is used before being assigned.
</span></span></span></code></pre></div><p>请注意，如果变量的类型包括<code>undefined</code>，则不会出现编译错误。在变量类型中添加 <code>| undefined</code>是向<code>TypeScript</code>说明，在使用前无需初始化，因为<code>undefined</code>是变量的有效类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">mathematician</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">mathematician</span><span style="color:#f92672">?</span>.<span style="color:#a6e22e">length</span>;
</span></span></code></pre></div><h3 id="type-aliases">Type Aliases</h3>
<p>在代码中看到的大多数联合类型的子类型一般只有两到三个。但是，有时可能会遇到一些较长的联合类型不方便重复输入。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">rawDataFirst</span>: <span style="color:#66d9ef">boolean</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">rawDataSecond</span>: <span style="color:#66d9ef">boolean</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">rawDataThird</span>: <span style="color:#66d9ef">boolean</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>;
</span></span></code></pre></div><p><code>TypeScript</code>包含类型别名，可以为重复使用的类型分配更简单的名称。类型别名以<code>type</code>关键字，新名称<code>=</code>和任意类型。按照惯例，类型别名以大驼峰命名：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">MyName</span> <span style="color:#f92672">=</span> ...;
</span></span></code></pre></div><p>之前的联合类型，可以简写成如下形式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">RawData</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">boolean</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">rawDataFirst</span>: <span style="color:#66d9ef">RawData</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">rawDataSecond</span>: <span style="color:#66d9ef">RawData</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">rawDataThird</span>: <span style="color:#66d9ef">RawData</span>;
</span></span></code></pre></div><p>类型别名是<code>TypeScript</code>中的一项便捷功能，只要使用的类型开始变得复杂，就可以使用它。目前，只包括长联合类型，以后还将包括数组、函数和对象类型。</p>
<h4 id="type-aliases-are-not-javascript">Type Aliases Are Not JavaScript</h4>
<p>类型别名与类型标注一样，不会编译到输出的<code>JavaScript</code>文件中。类型别名仅存在于类型系统，因此不能在运行时的代码中引用它们。如果试图访问运行时不存在的内容，<code>TypeScript</code>会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">RawData</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">boolean</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">RawData</span>) <span style="color:#75715e">//  &#39;RawData&#39; only refers to a type, but is being used as a value here.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">rawData</span>: <span style="color:#66d9ef">RawData</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">rawData</span>, <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">rawData</span>) <span style="color:#75715e">// false boolean
</span></span></span></code></pre></div><h4 id="combining-type-aliases">Combining Type Aliases</h4>
<p>类型别名定义时也可以引用其它的类型别名。类型别名相互引用有时会很有用，当一个类型别名是一个联合类型时，它可能包含另一个类型别名中的联合类型中的所有可能子类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Id</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">IdMaybe</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Id</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span>;
</span></span></code></pre></div><p>类型别名<font color=red>不必按使用顺序声明</font>。可以让文件中较早声明的类型别名引用文件中较迟声明的别名。上面示例代码可以重写，将<code>IdMaybe</code>放在<code>Id</code>之前声明：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">IdMaybe</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Id</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Id</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">id</span>: <span style="color:#66d9ef">IdMaybe</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">id</span>)
</span></span></code></pre></div><h2 id="objects">Objects</h2>
<p>对象字面值是键和值的集合，每个键和值都有自己的类型。</p>
<h3 id="object-types">Object Types</h3>
<p>当使用<code>{}</code>创建对象字面量时，<code>TypeScript</code>会根据其属性将其视为新的对象类型。新对象类型将具有与对象字面量相同的属性名和对应的值类型。访问对象属性的值可以使用<code>value.member</code>或等价的<code>value['member']</code>语法。</p>
<p>下面代码中，<code>TypeScript</code>认为<code>poet</code>变量的类型是一个对象，该对象具有两个属性<code>born</code>和<code>name</code>。访问这两个属性是允许的，但试图访问任何其它不存在的成员名称都会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">poet</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">1935</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Mary Oliver&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">poet</span>.<span style="color:#a6e22e">born</span>, <span style="color:#a6e22e">poet</span>.<span style="color:#a6e22e">name</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">poet</span>[<span style="color:#e6db74">&#39;born&#39;</span>]; <span style="color:#75715e">// Type: number 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">poet</span>.<span style="color:#a6e22e">name</span>; <span style="color:#75715e">// Type: string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">poet</span>.<span style="color:#a6e22e">end</span>; <span style="color:#75715e">// Property &#39;end&#39; does not exist on type &#39;{ born: number; name: string; }&#39;
</span></span></span></code></pre></div><p>对象类型是<code>TypeScript</code>理解<code>JavaScript</code>代码的核心概念。除<code>null</code>和<code>undefined</code>之外的每个值都有一组成员，因此<code>TypeScript</code>必须了解对象类型中的每个值，才能对其进行类型检查。</p>
<h4 id="declaring-object-types">Declaring Object Types</h4>
<p>从现有的对象中直接推断出类型固然是好的，但有时还是想要显式声明对象的类型。这时需要一种方式描述对象类型，将其与对象值区分开来。</p>
<p>对象类型使用与对象字面量相似的语法来描述，但与属性名对应的是类型而不是相应的值。对象类型变量赋值错误信息中显示的也是声明时的语法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">poetLater</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">poetLater</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">123</span>, <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;678&#39;</span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">poetLater</span>) <span style="color:#75715e">// { born: 123, name: &#39;678&#39; }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">poetLater</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">123</span> <span style="color:#75715e">// 编译错误：Type &#39;number&#39; is not assignable to type &#39;{ born: number; name: string; }&#39;.
</span></span></span></code></pre></div><h4 id="aliased-object-types">Aliased Object Types</h4>
<p>经常写类似<code>{ born: number; name: string; }</code> 这样的对象类型很快就会让人厌烦，也容易出错。常见的做法是使用类型别名，为每个类型赋予一个新名字。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Poet</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">poetLater</span>: <span style="color:#66d9ef">Poet</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">poetLater</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">1935</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Sara Teasdale&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">poetLater</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Emily Dickinson&#34;</span>; <span style="color:#75715e">// 编译错误：Type &#39;string&#39; is not assignable to type &#39;Poet&#39;.
</span></span></span></code></pre></div><h3 id="structural-typing">Structural Typing</h3>
<p><code>TypeScript</code>的类型系统是<code>structural typed</code>的，这意味着<font color=LightSeaGreen>任何满足类型的值都可以用作该类型的值</font>。换句话说，当声明一个参数或变量是一个特定的对象类型时，就是在告诉<code>TypeScript</code>，<font color=red>无论使用什么对象，它们都需要具有这些属性</font>。</p>
<p>下面的<code>WithFirstName</code>和<code>WithLastName</code>别名对象类型都只声明了一个字符串类型的成员。<code>hasBoth</code>变量恰好同时有这两种成员，因此它可以赋值给这两种别名对象类型中的任何一种变量：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">WithFirstName</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">firstName</span>: <span style="color:#66d9ef">string</span>; };
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">WithLastName</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">lastName</span>: <span style="color:#66d9ef">string</span>; };
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">hasBoth</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">firstName</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Lucille&#34;</span>, <span style="color:#a6e22e">lastName</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Clifton&#34;</span>,};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">withFirstName</span>: <span style="color:#66d9ef">WithFirstName</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">hasBoth</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">withLastName</span>: <span style="color:#66d9ef">WithLastName</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">hasBoth</span>;
</span></span></code></pre></div><p><code>Structural typing</code>与<code>Duck typing</code>不同，后者源于「如果它看起来像鸭子，叫起来像鸭子，那它可能就是鸭子」这句话。<code>JavaScript</code>是<code>Duck typing</code>，而<code>TypeScript</code>是结构类型。</p>
<ul>
<li><code>Structural typing</code>是指有一个静态系统来检查类型，在<code>TypeScript</code>中这个静态系统就是类型检查器。</li>
<li><code>Duck typing</code>是指使用之前不检查对象类型，直到运行时才检查类型。</li>
</ul>
<h4 id="usage-checking">Usage Checking</h4>
<p>当向显式声明为对象类型的变量提供值时，<code>TypeScript</code>将检查该值是否可赋值给这个对象类型。首先，值必须包含对象类型的所有必需属性。如果对象中缺少对象类型所需的任何成员，将会出现编译错误。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">FirstAndLastNames</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">first</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">last</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">hasBoth</span>: <span style="color:#66d9ef">FirstAndLastNames</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">first</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Sarojini&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">last</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Naidu&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">hasOnlyOne</span>: <span style="color:#66d9ef">FirstAndLastNames</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">first</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Sappho&#34;</span>}; <span style="color:#75715e">// Property &#39;last&#39; is missing in type &#39;{ first: string; }&#39; but required in type &#39;FirstAndLastNames&#39;.
</span></span></span></code></pre></div><p>也不允许两者之间的类型不匹配。<font color=red>对象类型既指定了所需属性的名称，也指定了这些属性对应值的类型</font>。如果对象的属性不匹配，也会出现编译错误。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">TimeRange</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">start</span>: <span style="color:#66d9ef">Date</span>; };
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Error: Type &#39;string&#39; is not assignable to type &#39;Date&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">hasStartString</span>: <span style="color:#66d9ef">TimeRange</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">start</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;1879-02-13&#34;</span>, 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="excess-property-checking">Excess Property Checking</h4>
<p>如果一个变量声明为对象类型，而其<font color=LightSeaGreen>初始值中的字段多于其类型所描述的字段</font>，将会出现编译错误。因此，将变量显式声明为对象类型是一种让类型检查程序确保变量只有该类型的预期字段的方法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Poet</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">poetMatch</span>: <span style="color:#66d9ef">Poet</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">1928</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Maya Angelou&#34;</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">extraProperty</span>: <span style="color:#66d9ef">Poet</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">activity</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;walking&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">1935</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Mary Oliver&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Object literal may only specify known properties, and &#39;activity&#39; does not exist in type &#39;Poet&#39;.
</span></span></span></code></pre></div><p>需要注意的是，只有在<font color=red>声明为对象类型的位置创建的对象字面量才会触发多余属性检查</font>。提供现有的对象字面量可以绕过多余属性检查，下面示例代码绕过了多余属性检查：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Poet</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">poetMatch</span>: <span style="color:#66d9ef">Poet</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">1928</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Maya Angelou&#34;</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">existingObject</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">activity</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;walking&#34;</span>, <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">1935</span>, <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Mary Oliver&#34;</span>,};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">extraProperty</span>: <span style="color:#66d9ef">Poet</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">existingObject</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">poetMatch</span>) <span style="color:#75715e">// { activity: &#39;walking&#39;, born: 1935, name: &#39;Mary Oliver&#39; }
</span></span></span></code></pre></div><p>在需要对象类型的<font color=red>任何地方创建新对象时，都会触发多余属性检查</font>。禁止多余的属性能确保代码整洁并按照我们期望的方式运行。未在对象类型中声明的多余属性通常是输入错误的属性名。</p>
<h4 id="nested-object-types">Nested Object Types</h4>
<p>由于<code>JavaScript</code>对象中可以嵌入其它对象成员，因此<code>TypeScript</code>的对象类型也必须能够在类型系统中表示嵌套的对象类型。语法与以前相同，但使用 <code>{ ... }</code> 对象类型来代替基础类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Poem</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">firstName</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">lastName</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">poemMatch</span>: <span style="color:#66d9ef">Poem</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">firstName</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Sylvia&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">lastName</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Plath&#34;</span>,
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Lady Lazarus&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Object literal may only specify known properties, and &#39;name&#39; does not exist in type &#39;{ firstName: string; lastName: string; }&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">poemMismatch</span>: <span style="color:#66d9ef">Poem</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Sylvia Plath&#34;</span>,
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Tulips&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>声明<code>Poem</code>类型的另一种方法是将<code>author</code>属性提取到它的别名对象类型<code>Author</code>中。将嵌套类型提取到别名类型中，有助于<code>TypeScript</code>提供更详细的错误信息。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Author</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">firstName</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">lastName</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Poem</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span>: <span style="color:#66d9ef">Author</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Object literal may only specify known properties, and &#39;name&#39; does not exist in type &#39;Author&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">poemMismatch</span>: <span style="color:#66d9ef">Poem</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Sylvia Plath&#34;</span>, 
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Tulips&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>一般来说，为嵌套对象类型创建一个别名类型是个好主意，这样既能使代码更易读，也能使<code>TypeScript</code>的错误信息更易读。</p>
<h4 id="optional-properties">Optional Properties</h4>
<p>对象类型属性不一定都是必需属性，可以在对象属性的类型声明中的<code>:</code>前加上<code>?</code>来表示它是一个可选的属性。下面代码中，<code>Book</code>中的<code>author</code>属性就是可选的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Book</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author?</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">ok</span>: <span style="color:#66d9ef">Book</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Rita Dove&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">80</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">normal</span>: <span style="color:#66d9ef">Book</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">80</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 不能缺少必需属性
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Property &#39;pages&#39; is missing in type &#39;{ author: string; }&#39; but required in type &#39;Book&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">missing</span>: <span style="color:#66d9ef">Book</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Rita Dove&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>需要注意的是，可选属性与联合类型中包括<code>undefined</code>是不同的。声明为可选属性，属性可以不存在。但使用 <code>| undefined</code>声明的属性，其值必须存在，即使值是<code>undefined</code>的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Writers</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">editor?</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">hasRequired</span>: <span style="color:#66d9ef">Writers</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span>: <span style="color:#66d9ef">undefined</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">missingRequired</span>: <span style="color:#66d9ef">Writers</span> <span style="color:#f92672">=</span> {}; <span style="color:#75715e">//  Property &#39;author&#39; is missing in type &#39;{}&#39; but required in type &#39;Writers&#39;.
</span></span></span></code></pre></div><h3 id="unions-of-object-types">Unions of Object Types</h3>
<p>如果变量的初始值可能是多种对象类型之一，<code>TypeScript</code>将推断变量的类型是多个对象类型的联合。该类型的每种可能属性都存在于联合类型中每个子类型中。</p>
<h4 id="inferred-object-type-unions">Inferred Object-Type Unions</h4>
<p>下面代码中，变量<code>poem</code>值一定有<code>name</code>属性，可能有<code>pages</code>或<code>rhymes</code>属性。对象<code>poem</code>的属性<code>name</code>类型为<code>string</code>，而<code>poem</code>的属性<code>pages</code>类型为<code>number | undefined</code> ，属性<code>rhymes</code>的类型为<code>booleans | undefined</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">poem</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;The Double Image&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">7</span>
</span></span><span style="display:flex;"><span>} <span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Her Kind&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">rhymes</span>: <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">name</span>  <span style="color:#75715e">// string 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">pages</span>; <span style="color:#75715e">// number | undefined
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">rhymes</span>; <span style="color:#75715e">// booleans | undefined
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">name</span>, <span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">pages</span>, <span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">rhymes</span>, <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">poem</span>) <span style="color:#75715e">// 可能的结果:The Double Image 7 undefined object
</span></span></span></code></pre></div><h4 id="explicit-object-type-unions">Explicit Object-Type Unions</h4>
<p>也可以通过对象类型的联合来更明确地声明对象类型。这样做需要写更多的代码，好处是可以对对象类型有更多的控制。需要注意的是，如果是对象类型的联合，则<font color=red>只允许访问存在于联合类型所有子类型上的属性</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">PoemWithPages</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">PoemWithRhymes</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">rhymes</span>: <span style="color:#66d9ef">boolean</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Poem</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">PoemWithPages</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">PoemWithRhymes</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">poem</span>: <span style="color:#66d9ef">Poem</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span>  <span style="color:#f92672">?</span> {<span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;The Double Image&#34;</span>, <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">7</span>} <span style="color:#f92672">:</span> {<span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Her Kind&#34;</span>, <span style="color:#a6e22e">rhymes</span>: <span style="color:#66d9ef">true</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// OK
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">name</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Property &#39;pages&#39; does not exist on type &#39;Poem&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">pages</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Property &#39;rhymes&#39; does not exist on type &#39;Poem&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">rhymes</span>;
</span></span></code></pre></div><h4 id="narrowing-object-types">Narrowing Object Types</h4>
<p>如果类型检查器发现在某个区域的代码只有在联合类型值包含特定属性的情况下才能运行，那么会将联合类型缩小到只包含该属性的子类型。换句话说，如果在代码中检查对象，类型窄化功能也适用于对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#e6db74">&#34;pages&#34;</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">poem</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">pages</span>)
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">rhymes</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>请注意，<code>TypeScript</code>不允许像<code>if (poem.pages)</code>这样的真值检查。<font color=red>试图访问可能不存在的对象属性会被视为类型错误，即使使用的方式看起来像类型防护</font>。</p>
<h4 id="discriminated-unions">Discriminated Unions</h4>
<p><code>JavaScript</code>和<code>TypeScript</code>中另一种流行的联合类型对象形式是在对象上设置一个属性，用于指示对象具体是哪种类型。这种类型被称为判别联合（<code>discriminated union</code>），指示对象类型的属性就是<code>discriminant</code>。<code>TypeScript</code>对<code>discriminant</code>属性进行类型保护的代码执行类型窄化。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">PoemWithPages</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;pages&#39;</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">PoemWithRhymes</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">rhymes</span>: <span style="color:#66d9ef">boolean</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;rhymes&#39;</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Poem</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">PoemWithPages</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">PoemWithRhymes</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">poem</span>: <span style="color:#66d9ef">Poem</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;The Double Image&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">7</span>, 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;pages&#34;</span>
</span></span><span style="display:flex;"><span>} <span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Her Kind&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">rhymes</span>: <span style="color:#66d9ef">true</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;rhymes&#34;</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">poem</span>.<span style="color:#66d9ef">type</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;pages&#34;</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`It&#39;s got pages: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">pages</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`It rhymes: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">poem</span>.<span style="color:#a6e22e">rhymes</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="intersection-types">Intersection Types</h3>
<p><code>TypeScript</code>中的联合类型表示一个值的类型可能是两个或多个不同类型中的一个。<code>TypeScript</code>允许同时表示多种类型的交集，即交叉类型。交叉类型通常与别名对象类型一起使用，以创建结合多个现有对象类型的新类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Artwork</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">genre</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Writing</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">WrittenArt</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Artwork</span> <span style="color:#f92672">&amp;</span> <span style="color:#a6e22e">Writing</span>;
</span></span></code></pre></div><p>交叉类型可以与联合类型结合，有时有助于在一种类型中描述<code>discriminated unions</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ShortPoem</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">author</span>: <span style="color:#66d9ef">string</span> } <span style="color:#f92672">&amp;</span> (<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">kigo</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;haiku&#34;</span>;
</span></span><span style="display:flex;"><span>} <span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">meter</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;villanelle&#34;</span>;
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">morningGlory</span>: <span style="color:#66d9ef">ShortPoem</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Fukuda Chiyo-ni&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">kigo</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Morning Glory&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;haiku&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">oneArt</span>: <span style="color:#66d9ef">ShortPoem</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Elizabeth Bishop&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;villanelle&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h4 id="dangers-of-intersection-types">Dangers of Intersection Types</h4>
<p>交叉类型是一个有用的概念，但使用时很容易让自己或<code>TypeScript</code>编译器感到困惑。建议在使用交叉类型时尽量简化代码。</p>
<p>当创建了复杂的交叉类型（例如与联合类型相结合的类型）时，<code>TypeScript</code>的赋值错误信息就变得更加难以理解。这将是<code>TypeScript</code>的类型系统（以及一般的类型化编程语言）的一个共同主题：创建的类型越复杂，就越难理解来自类型检查器的错误信息。</p>
<p>以前面代码片段中的<code>ShortPoem</code>为例，如果将该类型拆分为一系列别名对象类型，<code>TypeScript</code>就可以打印这些别名，可读性就会大大提高：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ShortPoemBase</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span>: <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Haiku</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">ShortPoemBase</span> <span style="color:#f92672">&amp;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">kigo</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;haiku&#34;</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Villanelle</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">ShortPoemBase</span> <span style="color:#f92672">&amp;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">meter</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;villanelle&#34;</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ShortPoem</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Haiku</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">Villanelle</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type &#39;{ author: string; type: &#34;villanelle&#34;; }&#39; is not assignable to type &#39;ShortPoem&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">oneArt</span>: <span style="color:#66d9ef">ShortPoem</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Elizabeth Bishop&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;villanelle&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h4 id="never">never</h4>
<p>交叉类型很容易被滥用，创建出一种不可能的类型。基本类型不能作为交叉类型组合在一起，因为一个值不可能同时是多个基本类型（除了<code>null</code>和<code>undefined</code>）。如果尝试将两个基本类型交叉在一起，就会产生由关键字<code>never</code>表示的<code>never</code>类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">NotPossible</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">string</span>
</span></span></code></pre></div><p>编程语言将<code>never</code>类型称为底层类型或空类型。<font color=red>底层类型是指没有可能的值，也是无法到达的类型</font>。不能向类型为底层类型的位置提供任何类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">NotPossible</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">notNumber</span>: <span style="color:#66d9ef">NotPossible</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// Type &#39;number&#39; is not assignable to type &#39;never&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">notString</span>: <span style="color:#66d9ef">never</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>; <span style="color:#75715e">// Type &#39;number&#39; is not assignable to type &#39;never&#39;.
</span></span></span></code></pre></div><p>多数<code>TypeScript</code>项目很少使用<code>never</code>类型。它偶尔会出现在代码中表示不可能的状态。但大多数情况下，很可能是误用交叉类型造成的错误。</p>
<h2 id="functions">Functions</h2>
<h3 id="function-parameters">Function Parameters</h3>
<p>下面定义了一个函数，参数为<code>song</code>，并打印了这个参数的值。在声明该函数时参数并没有显式的声明类型，那么<code>TypeScript</code>会认为这个参数的类型是<code>any</code>类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">sing</span>(<span style="color:#a6e22e">song</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Singing: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span><span style="color:#e6db74">}</span><span style="color:#e6db74">!`</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>与变量一样，允许使用类型声明函数参数的类型。现在，我们可以使用<code>: string</code>来告诉<code>TypeScript</code>参数<code>song</code>的类型是字符串：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">sing</span>(<span style="color:#a6e22e">song</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Singing: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span><span style="color:#e6db74">}</span><span style="color:#e6db74">!`</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="required-parameters">Required Parameters</h4>
<p><code>JavaScript</code>函数允许使用任意数量的实参(<code>arguments</code>)调用函数，而<code>TypeScript</code>不同，它假定函数中声明的所有参数都是必需的。如果使用错误的参数数调用函数，<code>TypeScript</code>将以类型错误的形式提出抗议。</p>
<p>如果函数调用的实参过少或过多，<code>TypeScript</code>的实参计数就会发挥作用。下面函数<code>singTwo</code>要求有两个参数，因此传递<code>1</code>个或<code>3</code>个参数都是不允许的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">singTwo</span>(<span style="color:#a6e22e">first</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">second</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">first</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> / </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">second</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Expected 2 arguments, but got 1.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">singTwo</span>(<span style="color:#e6db74">&#34;Ball and Chain&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Expected 2 arguments, but got 3.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">singTwo</span>(<span style="color:#e6db74">&#34;Go Your Own Way&#34;</span>, <span style="color:#e6db74">&#34;The Chain&#34;</span>, <span style="color:#e6db74">&#34;Dreams&#34;</span>);
</span></span></code></pre></div><p>强制要求向函数提供必需的参数，有助于执行类型安全。如果不能确保这些参数值都存在，可能会导致代码出现意外行为，例如之前的<code>singTwo</code>函数记录<code>undefined</code>或忽略参数。</p>
<p>形参（<code>parameter</code>）是指函数声明的预期参数。实参（<code>arguments</code>）是指函数调用时提供给形参的值。在前面的示例中，<code>first</code>和<code>second</code>是形参，而<code>&quot;Dream&quot;</code>等字符串是实参。</p>
<h4 id="optional-parameters">Optional Parameters</h4>
<p><code>TypeScript</code>允许将形参数标注为可选参数，方法是在其类型注释中的<code>:</code>之前添加<code>?</code>（类似于对象类型的可选属性）。函数调用不需要提供可选参数。因此，它们的类型总是以 <code>| undefined</code>作为联合类型。</p>
<p>在下面函数中，<code>singer</code>形参被标记为可选参数。它的类型是<code>string | undefined</code>，函数的调用者无需提供。如果提供了<code>singer</code>，它可能是一个字符串值或<code>undefined</code>值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">announceSong</span>(<span style="color:#a6e22e">song</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">singer?</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Song: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">singer</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Singer: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">singer</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">announceSong</span>(<span style="color:#e6db74">&#34;Greensleeves&#34;</span>); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">announceSong</span>(<span style="color:#e6db74">&#34;Greensleeves&#34;</span>, <span style="color:#66d9ef">undefined</span>); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">announceSong</span>(<span style="color:#e6db74">&#34;Chandelier&#34;</span>, <span style="color:#e6db74">&#34;Sia&#34;</span>); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">Song</span>: <span style="color:#66d9ef">Greensleeves</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Song</span>: <span style="color:#66d9ef">Greensleeves</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Song</span>: <span style="color:#66d9ef">Chandelier</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Singer</span>: <span style="color:#66d9ef">Sia</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">announceSong</span>(<span style="color:#a6e22e">song</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">singer?</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Song: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">singer</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Singer: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">singer</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Singer: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">singer</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">announceSong</span>(<span style="color:#e6db74">&#34;test&#34;</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">Song</span>: <span style="color:#66d9ef">test</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Singer</span>: <span style="color:#66d9ef">undefined</span>
</span></span></code></pre></div><p>可选参数与包含<code>| undefined</code>的联合类型参数不同。没有用<code>?</code>标记为可选的参数必需提供，即使其值是<code>undefined</code>。函数的<font color=red>可选参数必须是函数的最后一个参数</font>，若将可选参数放置在必需参数前，则会出现编译错误。</p>
<h4 id="default-parameters">Default Parameters</h4>
<p><code>TypeScript</code>的类型推断对函数默认参数值的作用与对初始变量值的作用类似。如果参数有默认值且没有类型标注，将会根据默认值推断参数的类型。</p>
<p>在下面的<code>rateSong</code>函数中，参数<code>rating</code>被推断为<code>number</code>类型，但在调用该函数的代码中，<code>rating</code>是一个可选的<code>number | undefined</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">rateSong</span>(<span style="color:#a6e22e">song</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">rating</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> gets </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">rating</span><span style="color:#e6db74">}</span><span style="color:#e6db74">/5 stars!`</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">rateSong</span>(<span style="color:#e6db74">&#34;Photograph&#34;</span>); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">rateSong</span>(<span style="color:#e6db74">&#34;Set Fire to the Rain&#34;</span>, <span style="color:#ae81ff">5</span>); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">rateSong</span>(<span style="color:#e6db74">&#34;Set Fire to the Rain&#34;</span>, <span style="color:#66d9ef">undefined</span>); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">rateSong</span>(<span style="color:#e6db74">&#34;At Last!&#34;</span>, <span style="color:#e6db74">&#34;100&#34;</span>); <span style="color:#75715e">// Argument of type &#39;string&#39; is not assignable to parameter of type &#39;number&#39;.
</span></span></span></code></pre></div><h4 id="rest-parameters">Rest Parameters</h4>
<p>下面函数<code>singAllTheSongs</code>允许接受0个或多个字符串类型的实参：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">singAllTheSongs</span>(<span style="color:#a6e22e">singer</span>: <span style="color:#66d9ef">string</span>, ...<span style="color:#a6e22e">songs</span>: <span style="color:#66d9ef">string</span>[]) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">song</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">songs</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, by </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">singer</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">singAllTheSongs</span>(<span style="color:#e6db74">&#34;Alicia Keys&#34;</span>); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">singAllTheSongs</span>(<span style="color:#e6db74">&#34;Lady Gaga&#34;</span>, <span style="color:#e6db74">&#34;Bad Romance&#34;</span>, <span style="color:#e6db74">&#34;Just Dance&#34;</span>, <span style="color:#e6db74">&#34;Poker Face&#34;</span>); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 执行结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">Bad</span> <span style="color:#a6e22e">Romance</span>, <span style="color:#a6e22e">by</span> <span style="color:#a6e22e">Lady</span> <span style="color:#a6e22e">Gaga</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Just</span> <span style="color:#a6e22e">Dance</span>, <span style="color:#a6e22e">by</span> <span style="color:#a6e22e">Lady</span> <span style="color:#a6e22e">Gaga</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Poker</span> <span style="color:#a6e22e">Face</span>, <span style="color:#a6e22e">by</span> <span style="color:#a6e22e">Lady</span> <span style="color:#a6e22e">Gaga</span>
</span></span></code></pre></div><h3 id="return-types">Return Types</h3>
<p><code>TypeScript</code>是敏感的，如果知道函数返回的所有可能值，就能推断出函数返回什么类型。下面代码中，<code>TypeScript</code>认为函数<code>singSongs</code>返回一个<code>number</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">singSongs</span>(<span style="color:#a6e22e">songs</span>: <span style="color:#66d9ef">string</span>[]) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">song</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">songs</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">songs</span>.<span style="color:#a6e22e">length</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果函数包含多个不同的返回语句，<code>TypeScript</code>将返回类型推断为所有可能返回类型的联合类型。下面函数的返回类型将被推断为<code>string | undefined</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getSongAt</span>(<span style="color:#a6e22e">songs</span>: <span style="color:#66d9ef">string</span>[], <span style="color:#a6e22e">index</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">index</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">songs</span>.<span style="color:#a6e22e">length</span> <span style="color:#f92672">?</span> <span style="color:#a6e22e">songs</span>[<span style="color:#a6e22e">index</span>] <span style="color:#f92672">:</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="explicit-return-types">Explicit Return Types</h4>
<p>与变量一样，通常不建议使用类型标注来显式声明函数的返回值类型。不过，在某些情况下，类型标注对函数还是很有用的：</p>
<ul>
<li>可能希望强制具有多种可能返回值的函数始终返回相同类型的值。</li>
<li><code>TypeScript</code>拒绝尝试推理递归函数的返回类型。</li>
<li>加快超大型项目中的<code>TypeScript</code>类型检查速度。</li>
</ul>
<p>函数声明的返回类型标注位于参数列表的后圆括号<code>)</code>之后。对于函数声明来说，这恰好位于<code>{</code>之前：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">singSongsRecursive</span>(<span style="color:#a6e22e">songs</span>: <span style="color:#66d9ef">string</span>[], <span style="color:#a6e22e">count</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">songs</span>.<span style="color:#a6e22e">length</span> <span style="color:#f92672">?</span> <span style="color:#a6e22e">singSongsRecursive</span>(<span style="color:#a6e22e">songs</span>.<span style="color:#a6e22e">slice</span>(<span style="color:#ae81ff">1</span>), <span style="color:#a6e22e">count</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">:</span> <span style="color:#a6e22e">count</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>对于箭头函数（也称为<code>lambdas</code>表达式）来说，这正好位于<code>=&gt;</code>之前：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">singSongsRecursive</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">songs</span>: <span style="color:#66d9ef">string</span>[], <span style="color:#a6e22e">count</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">songs</span>.<span style="color:#a6e22e">length</span> <span style="color:#f92672">?</span> <span style="color:#a6e22e">singSongsRecursive</span>(<span style="color:#a6e22e">songs</span>.<span style="color:#a6e22e">slice</span>(<span style="color:#ae81ff">1</span>), <span style="color:#a6e22e">count</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">:</span> <span style="color:#a6e22e">count</span>;
</span></span></code></pre></div><p>如果函数中的返回语句对应的返回的值不能赋值给函数的返回类型，<code>TypeScript</code>将给出一个编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getSongRecordingDate</span>(<span style="color:#a6e22e">song</span>: <span style="color:#66d9ef">string</span>)<span style="color:#f92672">:</span> Date <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">switch</span> (<span style="color:#a6e22e">song</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;Strange Fruit&#34;</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> Date(<span style="color:#e6db74">&#39;April 20, 1939&#39;</span>); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;Greensleeves&#34;</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Error: Type &#39;string&#39; is not assignable to type &#39;Date&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;unknown&#34;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">undefined</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="function-types">Function Types</h3>
<p><code>JavaScript</code>允许将函数作为值传递。这意味着需要一种方法来声明用于存放函数的参数或变量的类型。函数类型语法与箭头函数类似，只是用类型代替了函数体。下面<code>nothingInGivesString</code>变量的类型描述了一个无参数，返回字符串值的函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">nothingInGivesString</span><span style="color:#f92672">:</span> () <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">string</span>;
</span></span></code></pre></div><p>下面的变量<code>inputAndOutput</code>声明了一个函数，这个函数有一个<code>string[]</code>类型的形参，一个可选的形参<code>count</code>，并且返回一个<code>number</code>值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">inputAndOutput</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">songs</span>: <span style="color:#66d9ef">string</span>[], <span style="color:#a6e22e">count?</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">number</span>;
</span></span></code></pre></div><p>函数类型常用于描述回调参数（作为函数调用的参数）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">runOnSongs</span>(<span style="color:#a6e22e">getSongAt</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">index</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">songs</span>.<span style="color:#a6e22e">length</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">getSongAt</span>(<span style="color:#a6e22e">i</span>));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getSongAt</span>(<span style="color:#a6e22e">index</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">songs</span>[<span style="color:#a6e22e">index</span>]<span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">runOnSongs</span>(<span style="color:#a6e22e">getSongAt</span>); <span style="color:#75715e">// Ok
</span></span></span></code></pre></div><h4 id="function-type-parentheses">Function Type Parentheses</h4>
<p>函数类型可以放置在任何需要类型的地方，包括联合类型。在联合类型中，可以使用圆括号来表示哪一部分是函数返回值哪一部分是联合类型的函数子类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// Type is a function that returns a union: string | undefined
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">returnsStringOrUndefined</span><span style="color:#f92672">:</span> () <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type is either undefined or a function that returns a string 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">maybeReturnsString</span><span style="color:#f92672">:</span> (() <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">string</span>) <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>;
</span></span></code></pre></div><h4 id="parameter-type-inferences">Parameter Type Inferences</h4>
<p>如果必须为编写的每个函数（包括用作参数的内联函数）声明参数类型，那将会非常麻烦。幸运的是，<code>TypeScript</code>可以推断出函数中的参数类型，并将其提供给已声明类型的位置。</p>
<p>下面示例代码中，<code>singer</code>变量是一个接收字符串类型参数的函数，因此赋值给<code>singer</code>的函数中的<code>song</code>参数也是一个字符串类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">singer</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">song</span>: <span style="color:#66d9ef">string</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type of song: string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">singer</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">song</span>) { 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">`Singing: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span>.<span style="color:#a6e22e">toUpperCase</span>()<span style="color:#e6db74">}</span><span style="color:#e6db74">!`</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>作为实参传递给具有函数类型的形参的函数，参数类型也能被推断出来。下面示例中，参数<code>song</code>和<code>index</code>被推断为<code>string</code>和<code>number</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">songs</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;Call Me&#34;</span>, <span style="color:#e6db74">&#34;Jolene&#34;</span>, <span style="color:#e6db74">&#34;The Chain&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">songs</span>.<span style="color:#a6e22e">forEach</span>((<span style="color:#a6e22e">song</span>, <span style="color:#a6e22e">index</span>) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> is at index </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">index</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>});
</span></span></code></pre></div><h4 id="function-type-aliases">Function Type Aliases</h4>
<p><code>type</code>也可以用于函数，下面代码中类型别名<code>StringToNumber</code>是一个接收字符串并返回<code>number</code>的函数，这意味着它可以用来描述函数变量的类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">StringToNumber</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">string</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">stringToNumber</span>: <span style="color:#66d9ef">StringToNumber</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">stringToNumber</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">input</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">input</span>.<span style="color:#a6e22e">length</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">stringToNum</span>(<span style="color:#e6db74">&#39;1233&#39;</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">stringToNum</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">input</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">123</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">stringToNum</span>(<span style="color:#e6db74">&#39;3455&#39;</span>))
</span></span></code></pre></div><p>同样，函数的类型别名也可以用于函数形参的声明：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">NumberToString</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">usesNumberToString</span>(<span style="color:#a6e22e">numberToString</span>: <span style="color:#66d9ef">NumberToString</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`The string is: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">numberToString</span>(<span style="color:#ae81ff">1234</span>)<span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="more-return-types">More Return Types</h3>
<p>有些函数并不返回任何值，它们要么没有返回语句，要么只有不返回值的<code>return</code>语句。<code>TypeScript</code>允许使用<code>void</code>关键字来说明这种不返回任何值的函数的返回类型。返回类型为<code>void</code>的函数不能返回值，下面<code>logSong</code>函数被声明为返回<code>void</code>，因此不允许有返回值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">logSong</span>(<span style="color:#a6e22e">song</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">void</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">song</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>; <span style="color:#75715e">// Error: Type &#39;boolean&#39; is not assignable to type &#39;void&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p><code>void</code>可以作为函数类型声明中的返回类型。在函数类型声明中使用<code>void</code>时，表示函数的任何返回值都将被忽略。下面代码中，<code>songLogger</code>变量代表了一个函数，它接受一个<code>song: string</code>参数，并且不返回值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">songLogger</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">song</span>: <span style="color:#66d9ef">string</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">void</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">songLogger</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">song</span>) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">song</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">songLogger</span>(<span style="color:#e6db74">&#34;Heart of Glass&#34;</span>); <span style="color:#75715e">// Ok
</span></span></span></code></pre></div><p>请注意，尽管<code>JavaScript</code>函数在没有返回值的情况下会默认返回<code>undefined</code>，但<font color=LightSeaGreen><code>void</code>并不等同于<code>undefined</code>。<code>void</code>意味着函数的返回值类型将被忽略，而<code>undefined</code>则是要返回的字面量</font>。如果尝试将<code>void</code>类型的值赋给类型包括<code>undefined</code>的变量，会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">returnsVoid() {</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">lazyValue</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">lazyValue</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">returnsVoid</span>(); <span style="color:#75715e">// Type &#39;void&#39; is not assignable to type &#39;string | undefined&#39;.
</span></span></span></code></pre></div><p>返回值<code>undefined</code>和<code>void</code>之间的区别，对于忽略传递到类型声明为<code>void</code>的位置的函数的任何返回值特别有用。例如，数组的内置<code>forEach</code>方法会接收返回<code>void</code>的回调。下面的<code>saveRecords</code>函数中，<code>records.push(record)</code>返回一个数字（数组<code>.push()</code>的返回值），但仍允许作为传递给<code>newRecords.forEach</code>的箭头函数的返回值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">saveRecords</span>(<span style="color:#a6e22e">newRecords</span>: <span style="color:#66d9ef">string</span>[]) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">newRecords</span>.<span style="color:#a6e22e">forEach</span>(<span style="color:#a6e22e">record</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">records</span>.<span style="color:#a6e22e">push</span>(<span style="color:#a6e22e">record</span>));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">saveRecords</span>([<span style="color:#e6db74">&#39;21&#39;</span>, <span style="color:#e6db74">&#39;Come On Over&#39;</span>, <span style="color:#e6db74">&#39;The Bodyguard&#39;</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// forEach的定义
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">forEach</span>(<span style="color:#a6e22e">callbackfn</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">T</span>, <span style="color:#a6e22e">index</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">array</span>: <span style="color:#66d9ef">T</span>[]) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">void</span>, <span style="color:#a6e22e">thisArg?</span>: <span style="color:#66d9ef">any</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">void</span>;
</span></span></code></pre></div><p><code>void</code>类型不是<code>JavaScript</code>的。它是<code>TypeScript</code>的一个关键字，用于声明函数的返回类型。请记住，<font color=red>它表示函数的返回值不打算被使用，而不是表示返回值本身可以被返回</font>。</p>
<h4 id="never-returns">Never Returns</h4>
<p>有些函数不仅不返回值，而且根本不返回。永不返回的函数是那些总是抛出错误或运行无限循环的函数（希望是故意的！）。</p>
<p>如果一个函数永远不会返回，那么添加一个显式的<code>: never</code>类型就表示调用该函数后的任何代码都不会运行。下面<code>fail</code>函数只会抛出一个错误，因此它有助于<code>TypeScript</code>的控制流分析，将参数类型窄化为字符串：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">fail</span>(<span style="color:#a6e22e">message</span>: <span style="color:#66d9ef">string</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">never</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> Error(<span style="color:#e6db74">`Invariant failure: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">message</span><span style="color:#e6db74">}</span><span style="color:#e6db74">.`</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">workWithUnsafeParam</span>(<span style="color:#a6e22e">param</span>: <span style="color:#66d9ef">unknown</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">param</span> <span style="color:#f92672">!==</span> <span style="color:#e6db74">&#34;string&#34;</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fail</span>(<span style="color:#e6db74">`param should be a string, not </span><span style="color:#e6db74">${</span><span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">param</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">param</span>.<span style="color:#a6e22e">toUpperCase</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>需要注意的是，<code>void</code>指的是不返回任何内容的函数，而<code>never</code>指的是永远不返回内容的函数。</p>
<h3 id="function-overloads">Function Overloads</h3>
<p>有些<code>JavaScript</code>函数可以使用完全不同的参数集来调用，而这些参数集不能只用可选参数和/或其余参数来表示。这些函数可以使用一种名为重载签名（<code>overload signatures</code>）的<code>TypeScript</code>语法来描述：<font color=red>在一个最终实现签名和函数体之前，多次声明不同版本的函数名称、参数和返回类型</font>。</p>
<p>在决定是否对重载函数的调用发出语法错误时，TypeScript只会查看函数的重载签名。实现签名只用于函数的内部逻辑。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">createDate</span>(<span style="color:#a6e22e">timestamp</span>: <span style="color:#66d9ef">number</span>)<span style="color:#f92672">:</span> Date;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">createDate</span>(<span style="color:#a6e22e">month</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">day</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">year</span>: <span style="color:#66d9ef">number</span>)<span style="color:#f92672">:</span> Date;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">createDate</span>(<span style="color:#a6e22e">monthOrTimestamp</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">day?</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">year?</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">day</span> <span style="color:#f92672">===</span> <span style="color:#66d9ef">undefined</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">year</span> <span style="color:#f92672">===</span> <span style="color:#66d9ef">undefined</span> <span style="color:#f92672">?</span> <span style="color:#66d9ef">new</span> Date(<span style="color:#a6e22e">monthOrTimestamp</span>) <span style="color:#f92672">:</span> <span style="color:#66d9ef">new</span> Date(<span style="color:#a6e22e">year</span>, <span style="color:#a6e22e">monthOrTimestamp</span>, <span style="color:#a6e22e">day</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">createDate</span>(<span style="color:#ae81ff">554356800</span>); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">createDate</span>(<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">27</span>, <span style="color:#ae81ff">1987</span>); <span style="color:#75715e">// Ok
</span></span></span></code></pre></div><p>重载签名与其他类型系统语法一样，在编译<code>TypeScript</code>输出为<code>JavaScript</code>时会被删除。函数重载通常是复杂、难以描述的函数类型的最后手段。<font color=red>一般来说，最好保持函数简单，尽可能避免使用函数重载</font>。</p>
<h4 id="call-signature-compatibility">Call-Signature Compatibility</h4>
<p>重载函数的实现所使用的签名就是该函数的实现所使用的参数类型和返回类型。因此，函数重载签名中的返回类型和每个参数都必须可以可赋值给实现签名中同一索引处的参数。换句话说，<font color=red>实现签名必须与所有重载签名兼容</font>。下面的实现签名和所有的重载签名不兼容，会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">format</span>(<span style="color:#a6e22e">data</span>: <span style="color:#66d9ef">string</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">format</span>(<span style="color:#a6e22e">data</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">needle</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">haystack</span>: <span style="color:#66d9ef">string</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// This overload signature is not compatible with its implementation signature.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">format</span>(<span style="color:#a6e22e">getData</span><span style="color:#f92672">:</span> () <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">string</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">format</span>(<span style="color:#a6e22e">data</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">needle?</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">haystack?</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">needle</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">haystack</span> <span style="color:#f92672">?</span> <span style="color:#a6e22e">data</span>.<span style="color:#a6e22e">replace</span>(<span style="color:#a6e22e">needle</span>, <span style="color:#a6e22e">haystack</span>) <span style="color:#f92672">:</span> <span style="color:#a6e22e">data</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="arrays">Arrays</h2>
<p>TypeScript通过记住数组中最初的数据类型，并只允许数组对该数据类型进行操作，从而遵守了每个数组只使用一种数据类型的最佳实践。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">warriors</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;Artemisia&#34;</span>, <span style="color:#e6db74">&#34;Boudica&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Ok: &#34;Zenobia&#34; is a string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">warriors</span>.<span style="color:#a6e22e">push</span>(<span style="color:#e6db74">&#34;Zenobia&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Argument of type &#39;boolean&#39; is not assignable to parameter of type &#39;string&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">warriors</span>.<span style="color:#a6e22e">push</span>(<span style="color:#66d9ef">true</span>);
</span></span></code></pre></div><p>可以认为TypeScript根据数组的初始成员推断数组类型与根据变量的初始值推断变量类型类似。TypeScript通常会尝试从赋值来推断预期类型，数组也不例外。</p>
<h3 id="array-types">Array Types</h3>
<p>如同其他的变量声明，存储数组的变量声明的时候可以不初始化，变量一开始可以是<code>undefined</code>的，之后会收到一个数组值。同样地，如果在变量未初始化之前就使用会出现编译错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">arrayOfNumbers</span>: <span style="color:#66d9ef">number</span>[];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译报错： Variable &#39;arrayOfNumbers&#39; is used before being assigned.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">arrayOfNumbers</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">arrayOfNumbers</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">23</span>, <span style="color:#ae81ff">42</span>];
</span></span></code></pre></div><h4 id="array-and-function-types">Array and Function Types</h4>
<p>涉及数组和函数类型时可能需要使用圆括号来区分数组类型中的内容。圆括号可用于指明类型中哪一部分是函数返回值或周围的数组类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// Type is a function that returns an array of strings
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">createStrings</span><span style="color:#f92672">:</span> () <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">string</span>[];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type is an array of functions that each return a string 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">stringCreators</span><span style="color:#f92672">:</span> (() <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">string</span>)[];
</span></span></code></pre></div><h4 id="union-type-arrays">Union-Type Arrays</h4>
<p>可以使用联合类型来说明数组中的元素是多个可能的类型。将数组类型与联合类型一起使用时，可能需要使用括号来指明中哪一部分是数组的内容，哪一部分是联合类型的内容。在数组联合类型中使用括号非常重要&ndash;以下两种类型并不相同：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// Type is either a number or an array of strings
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">stringOrArrayOfNumbers</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">number</span>[];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type is an array of elements that are each either a number or a string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">arrayOfStringOrNumbers</span><span style="color:#f92672">:</span> (<span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">number</span>)[];
</span></span></code></pre></div><p>如果数组包含一种以上的元素类型，<code>TypeScript</code>就会从数组的声明中推断它是一个<code>union</code>类型的数组。<font color=red>换句话说，数组元素的类型是数组中所有可能元素类型的联合</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// Type is (string | undefined)[]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">namesMaybe</span> <span style="color:#f92672">=</span> [
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;Aqualtune&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;Blenda&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">undefined</span>,
</span></span><span style="display:flex;"><span>];
</span></span></code></pre></div><h4 id="evolving-any-arrays">Evolving Any Arrays</h4>
<p>如果不在初始设置为空数组的变量上加上类型，<code>TypeScript</code>将把数组视为<code>any[]</code>，这意味着它可以接收任何内容。它们允许添加可能不正确的值，从而部分抵消了<code>TypeScript</code>类型检查器的好处。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// Type: any[]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">values</span> <span style="color:#f92672">=</span> [];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: string[]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">values</span>.<span style="color:#a6e22e">push</span>(<span style="color:#e6db74">&#39;&#39;</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: (number | string)[]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">values</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span></code></pre></div><p>如同变量，如果允许数组是<code>any</code>类型，部分地违背了TypeScript类型检查的目的。当TypeScript知道你的值应该是什么类型时，它就会工作得最好。</p>
<h4 id="multidimensional-arrays">Multidimensional Arrays</h4>
<p>一个二维数组，有两个<code>[]</code>，</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">arrayOfArraysOfNumbers</span>: <span style="color:#66d9ef">number</span>[][];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">arrayOfArraysOfNumbers</span><span style="color:#f92672">:</span> (<span style="color:#66d9ef">number</span>[])[]; <span style="color:#75715e">// 两种方式都可以
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">arrayOfArraysOfNumbers</span> <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>], [<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">6</span>], [<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">9</span>],];
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">arrayOfArraysOfNumbers</span>)
</span></span></code></pre></div><p>三维数组有3个<code>[]</code>，四维数组有4个<code>[]</code>，5个数组有5个<code>[]</code>。</p>
<h3 id="array-members">Array Members</h3>
<p>TypeScript是基于索引访问数组元素，下面的数组<code>defenders</code>类型为<code>string []</code> ，因此变量<code>defender</code>的类型是<code>string</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">defenders</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;Clarenza&#34;</span>, <span style="color:#e6db74">&#34;Dina&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">defender</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">defenders</span>[<span style="color:#ae81ff">0</span>];
</span></span></code></pre></div><p>联合类型数组的成员本是同一联合类型。下面<code>soldiersOrDates</code>变量的类型为<code>(string | Date)[]</code>，因此变量<code>soldierOrDate</code>的类型也为<code>string | Date</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">soldiersOrDates</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;Deborah Sampson&#34;</span>, <span style="color:#66d9ef">new</span> Date(<span style="color:#ae81ff">1782</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">3</span>)];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: Date | string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">soldierOrDate</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">soldiersOrDates</span>[<span style="color:#ae81ff">0</span>];
</span></span></code></pre></div><h4 id="caveat-unsound-members">Caveat: Unsound Members</h4>
<p>众所周知，TypeScript的类型系统<font color=red>在技术上是不健全的，它的类型大多是正确的</font>，但有时它对值的类型的理解可能是不正确的。<font color=red>数组尤其是类型系统不健全的根源</font>。在默认情况下，TypeScript 假设所有数组成员的访问都会返回该数组的成员，尽管在 JavaScript 中，访问数组元素的索引大于数组的长度会产生undefined的结果。在默认的 TypeScript 编译器设置下，这段代码没有任何问题：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">withElements</span>(<span style="color:#a6e22e">elements</span>: <span style="color:#66d9ef">string</span>[]) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// No type error
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">elements</span>[<span style="color:#ae81ff">9001</span>].<span style="color:#a6e22e">length</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">withElements</span>([<span style="color:#e6db74">&#34;It&#39;s&#34;</span>, <span style="color:#e6db74">&#34;over&#34;</span>]);
</span></span></code></pre></div><p>TypeScript故意不确定检索到的数组成员是否存在。它认为代码片段中的<code>elements[9001]</code>是字符串类型，而不是<code>undefined</code>类型。</p>
<h3 id="spreads-and-rests">Spreads and Rests</h3>
<h4 id="spreads">Spreads</h4>
<p>可以使用&hellip;展开操作符将数组连接在一起。根据TypeScript的理解，结果数组将包含来自输入数组的所有值。如果输入数组的类型相同，则输出数组的类型也相同。如果将两个不同类型的数组展开在一起创建一个新数组，新数组将被理解为由两个初始类型元素组成的联合类型数组。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// Type: string[]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">soldiers</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;Harriet Tubman&#34;</span>, <span style="color:#e6db74">&#34;Joan of Arc&#34;</span>, <span style="color:#e6db74">&#34;Khutulun&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: number[]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">soldierAges</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">90</span>, <span style="color:#ae81ff">19</span>, <span style="color:#ae81ff">45</span>];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: (string | number)[]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">conjoined</span> <span style="color:#f92672">=</span> [...<span style="color:#a6e22e">soldiers</span>, ...<span style="color:#a6e22e">soldierAges</span>];
</span></span></code></pre></div><h4 id="spreading-rest-parameters">Spreading Rest Parameters</h4>
<p>TypeScript可识别并对JavaScript中<code>...</code>执行类型检查：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">logWarriors</span>(<span style="color:#a6e22e">greeting</span>: <span style="color:#66d9ef">string</span>, ...<span style="color:#a6e22e">names</span>: <span style="color:#66d9ef">string</span>[]) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">name</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">names</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">greeting</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">name</span><span style="color:#e6db74">}</span><span style="color:#e6db74">!`</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">warriors</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;Cathay Williams&#34;</span>, <span style="color:#e6db74">&#34;Lozen&#34;</span>, <span style="color:#e6db74">&#34;Nzinga&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">logWarriors</span>(<span style="color:#e6db74">&#34;Hello&#34;</span>, ...<span style="color:#a6e22e">warriors</span>);
</span></span></code></pre></div><h3 id="tuples">Tuples</h3>
<p>虽然JavaScript数组在理论上可以是任意大小，但有时使用固定大小的数组（也称为元组）也很有用。<font color=red>元组中的每个索引都有一个特定的已知类型，这个类型可能比数组所有可能成员的联合类型更具体</font>。声明元组类型的语法与数组字面意义相似，只是用类型代替了元素值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">yearAndWarrior</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">number</span>, <span style="color:#66d9ef">string</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">yearAndWarrior</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">530</span>, <span style="color:#e6db74">&#34;Tomyris&#34;</span>]; <span style="color:#75715e">// Ok
</span></span></span></code></pre></div><p>在 JavaScript 中，元组通常与数组解构一起使用，以便一次赋多个值，例如根据一个条件将两个变量设置为初始值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> [<span style="color:#a6e22e">year</span>, <span style="color:#a6e22e">warrior</span>] <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">random</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">?</span> [<span style="color:#ae81ff">340</span>, <span style="color:#e6db74">&#34;Archidamia&#34;</span>] <span style="color:#f92672">:</span> [<span style="color:#ae81ff">1828</span>, <span style="color:#e6db74">&#34;Rani of Jhansi&#34;</span>];
</span></span></code></pre></div><h4 id="tuple-assignability">Tuple Assignability</h4>
<p><code>TypeScript</code>将元组类型视为比变长数组更特殊的类型。<font color=red>这意味着变长数组类型不能赋值给元组类型</font>。下面代码中，变量<code>pairLoose</code>是数组类型<code>(boolean | number)[]</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// Type: (boolean | number)[]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">pairLoose</span> <span style="color:#f92672">=</span> [<span style="color:#66d9ef">false</span>, <span style="color:#ae81ff">123</span>];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误:Type &#39;(number | boolean)[]&#39; is not assignable to type &#39;[boolean, number]&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">pairTupleLoose</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">boolean</span>, <span style="color:#66d9ef">number</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">pairLoose</span>;
</span></span></code></pre></div><p>上面代码中，如果变量<code>pairLoose</code>声明为<code>[boolean, number]</code>，那么赋值是允许的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">pairLoose</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">boolean</span>, <span style="color:#66d9ef">number</span>] <span style="color:#f92672">=</span> [<span style="color:#66d9ef">false</span>, <span style="color:#ae81ff">123</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">pairTupleLoose</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">boolean</span>, <span style="color:#66d9ef">number</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">pairLoose</span>;
</span></span></code></pre></div><p>请注意，<font color=red>不同长度的元组也不能相互赋值</font>，因为<code>TypeScript</code>知道元组类型中有多少个成员：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">tupleThree</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">boolean</span>, <span style="color:#66d9ef">number</span>, <span style="color:#66d9ef">string</span>] <span style="color:#f92672">=</span> [<span style="color:#66d9ef">false</span>, <span style="color:#ae81ff">1583</span>, <span style="color:#e6db74">&#34;Nzinga&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">tupleTwoExact</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">boolean</span>, <span style="color:#66d9ef">number</span>] <span style="color:#f92672">=</span> [<span style="color:#a6e22e">tupleThree</span>[<span style="color:#ae81ff">0</span>], <span style="color:#a6e22e">tupleThree</span>[<span style="color:#ae81ff">1</span>]];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：Type &#39;[boolean, number, string]&#39; is not assignable to type &#39;[boolean, number]&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">tupleTwoExtra</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">boolean</span>, <span style="color:#66d9ef">number</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">tupleThree</span>;
</span></span></code></pre></div><p>由于元组被视为数组，在长度和元素类型上具有更具体的类型信息，因此对于存储传递给函数的参数特别有用。TypeScript能够将作为<code>rest</code>参数传递的元组提供精确的类型检查。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">logPair</span>(<span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">name</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> has </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">value</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// pairArray的类型为: (string|number)[]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">pairArray</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;Amage&#34;</span>, <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误：A spread argument must either have a tuple type or be passed to a rest parameter.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">logPair</span>(...<span style="color:#a6e22e">pairArray</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">pairTupleIncorrect</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">number</span>, <span style="color:#66d9ef">string</span>] <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;Amage&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误:Argument of type &#39;number&#39; is not assignable to parameter of type &#39;string&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">logPair</span>(...<span style="color:#a6e22e">pairTupleIncorrect</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 元组类型被展开
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">pairTupleCorrect</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">string</span>, <span style="color:#66d9ef">number</span>] <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;Amage&#34;</span>, <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">logPair</span>(...<span style="color:#a6e22e">pairTupleCorrect</span>); <span style="color:#75715e">// Ok
</span></span></span></code></pre></div><p>如果想随意使用rest参数元组，可以将它们与数组混合使用，为多个函数调用存储参数列表。下面代码中<code>trios.forEach(trio =&gt; logTrio(...trio))</code> 是安全的，因为每个<code>...trio</code>恰好与<code>logTrio</code>的参数类型相匹配。然而，<code>trios.forEach(logTrio)</code> 不可赋值，因为它试图将整个<code>[string, number, boolean]</code>作为第一个参数传递，实际上第一个参数类型是<code>string</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">logTrio</span>(<span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">value</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">number</span>, <span style="color:#66d9ef">boolean</span>]) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">name</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> has </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">value</span>[<span style="color:#ae81ff">0</span>]<span style="color:#e6db74">}</span><span style="color:#e6db74"> (</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">value</span>[<span style="color:#ae81ff">1</span>]<span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">trios</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">string</span>, [<span style="color:#66d9ef">number</span>, <span style="color:#66d9ef">boolean</span>]][] <span style="color:#f92672">=</span> [
</span></span><span style="display:flex;"><span>    [<span style="color:#e6db74">&#34;Amanitore&#34;</span>, [<span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">true</span>]],
</span></span><span style="display:flex;"><span>    [<span style="color:#e6db74">&#34;Æthelflæd&#34;</span>, [<span style="color:#ae81ff">2</span>, <span style="color:#66d9ef">false</span>]],
</span></span><span style="display:flex;"><span>    [<span style="color:#e6db74">&#34;Ann E. Dunwoody&#34;</span>, [<span style="color:#ae81ff">3</span>, <span style="color:#66d9ef">false</span>]]];
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">trios</span>.<span style="color:#a6e22e">forEach</span>(<span style="color:#a6e22e">trio</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">logTrio</span>(...<span style="color:#a6e22e">trio</span>)); <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Argument of type &#39;(name: string, value: [number, boolean]) =&gt; void&#39; is not assignable to parameter of type &#39;(value: [string, [number, boolean]], index: number, array: [string, [number, boolean]][]) =&gt; void&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Types of parameters &#39;name&#39; and &#39;value&#39; are incompatible.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">trios</span>.<span style="color:#a6e22e">forEach</span>(<span style="color:#a6e22e">logTrio</span>);
</span></span></code></pre></div><h4 id="tuple-inferences">Tuple Inferences</h4>
<p><code>TypeScript</code><font color=red>通常将创建的数组视为长度可变的数组，而不是元组</font>。如果看到一个数组被用作变量的初始值或函数的返回值，那么将假定它是一个可变长度的数组，而不是一个固定长度的元组。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">firstCharAndSize</span>(<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> [<span style="color:#a6e22e">input</span>[<span style="color:#ae81ff">0</span>], <span style="color:#a6e22e">input</span>.<span style="color:#a6e22e">length</span>];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// firstChar type: string | number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// size type: string | number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">firstChar</span>, <span style="color:#a6e22e">size</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">firstCharAndSize</span>(<span style="color:#e6db74">&#34;Gudit&#34;</span>);
</span></span></code></pre></div><p>元组可能会被用于类型声明，例如函数的返回值类型。<font color=LightSeaGreen>如果一个函数声明返回一个元组类型，并且在函数里面返回一个数组字面量，则这个数组字面量会被推推断为元组而不是可变数组。</font></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">firstCharAndSizeExplicit</span>(<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">string</span>)<span style="color:#f92672">:</span> [<span style="color:#66d9ef">string</span>, <span style="color:#66d9ef">number</span>] {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> [<span style="color:#a6e22e">input</span>[<span style="color:#ae81ff">0</span>], <span style="color:#a6e22e">input</span>.<span style="color:#a6e22e">length</span>];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// firstChar type: string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// size type: number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">firstChar</span>, <span style="color:#a6e22e">size</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">firstCharAndSizeExplicit</span>(<span style="color:#e6db74">&#34;Cathay Williams&#34;</span>);
</span></span></code></pre></div><p>在显式类型标注中输入元组类型比较麻烦，<code>TypeScript</code>提供了一个<code>as const</code>操作符，称为<code>const</code>断言，可以放在值的后面。<code>const</code>断言告诉<code>TypeScript</code>在推断值的类型时，使用该值最直白的只读形式。如果将<code>const assertio</code>放在数组字面之后，表示数组应被视为元组：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// Type: (string | number)[]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">unionArray</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1157</span>, <span style="color:#e6db74">&#34;Tomoe&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Type: readonly [1157, &#34;Tomoe&#34;]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">readonlyTuple</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1157</span>, <span style="color:#e6db74">&#34;Tomoe&#34;</span>] <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">const</span>;
</span></span></code></pre></div><p>请注意，const断言不仅将可变的数组转换为固定大小的元组。还向<code>TypeScript</code>表明，<font color=red>元组是只读的</font>，不能在希望允许修改值的地方使用。</p>
<p>下面代码中，<code>pairMutable</code>允许修改，因为它具有传统的显式元组类型。然而，<code>as const</code> 使值不能赋值给可变的<code>pairAlsoMutable</code>，常量<code>pairConst</code>的成员也不允许被修改：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">pairMutable</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">number</span>, <span style="color:#66d9ef">string</span>] <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1157</span>, <span style="color:#e6db74">&#34;Tomoe&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">pairMutable</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1247</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// The type &#39;readonly [1157, &#34;Tomoe&#34;]&#39; is &#39;readonly&#39; and cannot be assigned to the mutable type &#39;[number, string]&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">pairAlsoMutable</span><span style="color:#f92672">:</span> [<span style="color:#66d9ef">number</span>, <span style="color:#66d9ef">string</span>] <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1157</span>, <span style="color:#e6db74">&#34;Tomoe&#34;</span>] <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">const</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// pariConst的类型相当于字面量的[1157,&#34;Tomoe&#34;]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">pairConst</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1157</span>, <span style="color:#e6db74">&#34;Tomoe&#34;</span>] <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">const</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Cannot assign to &#39;0&#39; because it is a read-only property
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">pairConst</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1247</span>;
</span></span></code></pre></div><p>在实践中，只读元组作为函数返回值很方便。函数中返回的元组值通常会立即解构，因此只读元组不会妨碍函数的使用。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">firstCharAndSizeAsConst</span>(<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> [<span style="color:#a6e22e">input</span>[<span style="color:#ae81ff">0</span>], <span style="color:#a6e22e">input</span>.<span style="color:#a6e22e">length</span>] <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">const</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 函数返回的元组立即被解构
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">firstChar</span>, <span style="color:#a6e22e">size</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">firstCharAndSizeAsConst</span>(<span style="color:#e6db74">&#34;Ching Shih&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">firstChar</span>, <span style="color:#a6e22e">size</span>)
</span></span></code></pre></div><h2 id="interfaces">Interfaces</h2>
<p>接口是声明具有相关名称对象的另一种方法。<font color=red>接口在许多方面与别名对象类型相似，但由于其错误信息更易读、编译器性能更快以及与类的互操作性更好，通常更受青睐</font>。</p>
<h3 id="type-aliases-versus-interfaces">Type Aliases Versus Interfaces</h3>
<p>下面是别名对象类型描述对象的语法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Poet</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>下面是使用<code>interface</code>定义的等效语法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Poet</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">born</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面两种语法基本一致。</p>
<p>喜欢使用分号的<code>TypeScript</code>开发人员<font color=LightSeaGreen>通常会将分号放在类型别名定义之后</font>，而接口定义之后通常不加分号。这种偏好反映了使用<code>;</code> 声明变量，不使用<code>;</code>声明类或函数。</p>
<p><code>type</code>和<code>interface</code>有一些关键区别：</p>
<ul>
<li>接口可以<code>merge</code>在一起以进行增强。</li>
<li>接口可以用来对类声明的结构进行类型检查，而类型别名则不能。</li>
<li>对于<code>TypeScript</code>类型检查程序来说，接口的工作速度通常更快。因为它们声明了一个命名的类型，可以更容易地在内部缓存，而不是像类型别名那样动态复制粘贴一个新的对象字面。</li>
<li>由于接口被认为是已命名的对象，而不是未命名对象字面量的别名，因此它们的错误信息可能在极端情况下更具可读性。</li>
</ul>
<h3 id="types-of-properties">Types of Properties</h3>
<h4 id="optional-properties-1">Optional Properties</h4>
<p>与对象类型一样，接口属性不一定都是对象的必需属性。可以在接口中的类型声明<code>:</code>前加上<code>?</code> 来表示接口属性是可选的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Book</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author?</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">ok</span>: <span style="color:#66d9ef">Book</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">author</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Rita Dove&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">80</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">missing</span>: <span style="color:#66d9ef">Book</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">80</span>
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h4 id="read-only-properties">Read-Only Properties</h4>
<p>有时，可能希望禁止用户重新赋值实现接口对象的属性值。<code>TypeScript</code>允许在属性名称前添加一个<code>readonly</code>修饰符，表示该属性一旦设置，就不能再修改为其它值。这些<code>readonly</code>属性可以正常读取，但不能重新赋值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Page</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">readonly</span> <span style="color:#a6e22e">text</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">read</span>(<span style="color:#a6e22e">page</span>: <span style="color:#66d9ef">Page</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Ok: reading the text property doesn&#39;t attempt to modify it
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">page</span>.<span style="color:#a6e22e">text</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 编译错误：Cannot assign to &#39;text&#39; because it is a read-only property.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">page</span>.<span style="color:#a6e22e">text</span> <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;!&#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>需要注意的是，<font color=LightSeaGreen><code>readonly</code>修饰器只存在于类型系统，并且只适用于接口的使用</font>。<code>readonly</code>不适用于对象，除非该对象被用于声明它属于该接口的位置。</p>
<h4 id="functions-and-methods">Functions and Methods</h4>
<p>在<code>JavaScript</code>中对象成员为函数比较常见。因此，<code>TypeScript</code>允许将接<code>interface</code>的成员声明为函数类型。<code>TypeScript</code>提供了两种将接口成员声明为函数的方法：</p>
<ul>
<li>方法语法：声明接口成员是一个打算作为对象成员调用的函数，如 <code>member(): void</code>。</li>
<li>属性语法：声明接口成员等同于独立函数，如 <code>member: () =&gt; void</code>。</li>
</ul>
<p>下面接口中声明的<code>method</code>和<code>property</code>都是函数，可以不带参数调用，并返回一个字符串：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">HasBothFunctionTypes</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">property</span><span style="color:#f92672">:</span> () <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">method</span>()<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">hasBoth</span>: <span style="color:#66d9ef">HasBothFunctionTypes</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">property</span><span style="color:#f92672">:</span> () <span style="color:#f92672">=&gt;</span> <span style="color:#e6db74">&#34;&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">method() {</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">hasBoth</span>.<span style="color:#a6e22e">property</span>();
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">hasBoth</span>.<span style="color:#a6e22e">method</span>()
</span></span></code></pre></div><p>这两种形式都支持可选的修饰器<code>?</code>，表明它们不是必需的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">OptionalReadonlyFunctions</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">optionalProperty</span><span style="color:#f92672">?:</span> () <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">optionalMethod</span><span style="color:#f92672">?</span>()<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>方法和属性声明在大多数情况下可以互换，它们之间的主要区别如下：</p>
<ul>
<li>方法不能声明为<code>readonly</code>，但属性可以。</li>
<li>接口合并时，认为方法和属性是不同的。</li>
</ul>
<p>如果知道底层函数可能会引用<code>this</code>，建议使用方法，最常见的是类的实例。其它情况则建议使用属性。</p>
<h4 id="call-signatures">Call Signatures</h4>
<p>接口和对象类型均可以声明<code>call signatures</code>（类型系统对值如何像函数一样被调用的描述）。只有可以按照<code>call signatures</code>声明的方式调用的值才可以赋值给接口，即具有可赋值参数和返回类型的函数。<code>call signatures</code>与函数类型相似，只是用冒号代替了 <code>=&gt;</code> 箭头。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">CallSignature</span> {
</span></span><span style="display:flex;"><span>    (<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">string</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">typedFunctionAlias</span>: <span style="color:#66d9ef">FunctionAlias</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">input</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">input</span>.<span style="color:#a6e22e">length</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">typedCallSignature</span>: <span style="color:#66d9ef">CallSignature</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">input</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">input</span>.<span style="color:#a6e22e">length</span>; <span style="color:#75715e">// Ok
</span></span></span></code></pre></div><p>调用签名可用于描述附加了一些用户定义属性的函数。<code>TypeScript</code>会识别添加到函数声明中的属性，并将其添加到函数声明的类型中。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">FunctionWithCount</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">count</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    ()<span style="color:#f92672">:</span> <span style="color:#66d9ef">void</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">hasCallCount</span>: <span style="color:#66d9ef">FunctionWithCount</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">keepsTrackOfCalls() {</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">keepsTrackOfCalls</span>.<span style="color:#a6e22e">count</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`I&#39;ve been called </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">keepsTrackOfCalls</span>.<span style="color:#a6e22e">count</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> times!`</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">keepsTrackOfCalls</span>.<span style="color:#a6e22e">count</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">hasCallCount</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">keepsTrackOfCalls</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">doesNotHaveCount() {</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;No idea!&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译报错 Property &#39;count&#39; is missing in type &#39;() =&gt; void&#39; but required in type &#39;FunctionWithCount&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">hasCallCount</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">doesNotHaveCount</span>;
</span></span></code></pre></div><h4 id="index-signatures">Index Signatures</h4>
<p>有些<code>JavaScript</code>项目创建的对象可以在任意字符串<code>key</code>下存储值。对于这些容器对象来说，为每一个可能的键声明一个带有字段的接口是不切实际的，甚至是不可能的。</p>
<p><code>TypeScript</code>提供了一种称为索引签名的语法，用于表示允许接口对象接收任何键，并返回该键下的特定类型。它们最常用于字符串键，因为<code>JavaScript</code>对象属性查找会将键隐式转换为字符串。索引签名看起来就像普通的属性定义，只是在键后面加上了类型，并用数组括号将其包围起来，如 <code>{ [i: string]: ... }</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">WordCounts</span> {
</span></span><span style="display:flex;"><span>    [<span style="color:#a6e22e">i</span>: <span style="color:#66d9ef">string</span>]<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">counts</span>: <span style="color:#66d9ef">WordCounts</span> <span style="color:#f92672">=</span> {};
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">counts</span>.<span style="color:#a6e22e">apple</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// Ok counts.banana = 1; // Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//  Type &#39;boolean&#39; is not assignable to type &#39;number&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">counts</span>.<span style="color:#a6e22e">cherry</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span></code></pre></div><p>索引签名便于为对象赋值，但并非完全类型安全。因为它们表示，无论访问的是什么属性，对象都应返回一个值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">DatesByName</span> {
</span></span><span style="display:flex;"><span>    [<span style="color:#a6e22e">i</span>: <span style="color:#66d9ef">string</span>]<span style="color:#f92672">:</span> Date;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">publishDates</span>: <span style="color:#66d9ef">DatesByName</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Frankenstein</span>: <span style="color:#66d9ef">new</span> Date(<span style="color:#e6db74">&#34;1 January 1818&#34;</span>),
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// webStrom中没有提示
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">publishDates</span>.<span style="color:#a6e22e">Frankenstein</span>) <span style="color:#75715e">// Type: Date
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">publishDates</span>.<span style="color:#a6e22e">Frankenstein</span>.<span style="color:#a6e22e">toString</span>());
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">publishDates</span>.<span style="color:#a6e22e">Beloved</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// console.log(publishDates.Beloved.toString())
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">publishDates</span>.<span style="color:#a6e22e">Beloved</span>.<span style="color:#a6e22e">toString</span>())
</span></span></code></pre></div><p>在可能的情况下，如果要存储键值对，并且无法提前知道键值，通常使用<code>Map</code>更为安全。<code>Map</code>的<code>get</code>方法总是返回带有<code>| undefined</code>的类型，表示键可能不存在。</p>
<p>接口可以包含显式命名属性和包罗万象的字符串索引签名。但有一个限制：每个命名属性的类型必须可以赋值给其 <code>catchall</code>索引签名的类型。可以认为将它们混合在一起就是告诉<code>TypeScript</code>，命名的属性会给出一个更具体的类型，而任何其他属性都会返回到索引签名的类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">HistoricalNovels</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Oroonoko</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>    [<span style="color:#a6e22e">i</span>: <span style="color:#66d9ef">string</span>]<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">novels</span>: <span style="color:#66d9ef">HistoricalNovels</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Outlander</span>: <span style="color:#66d9ef">1991</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Oroonoko</span>: <span style="color:#66d9ef">1688</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译报错：Property &#39;Oroonoko&#39; is missing in type &#39;{ Outlander: number; }&#39; but required in type &#39;HistoricalNovels&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">missingOroonoko</span>: <span style="color:#66d9ef">HistoricalNovels</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Outlander</span>: <span style="color:#66d9ef">1991</span>,
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="interface-extensions">Interface Extensions</h3>
<p>有时，可能会有多个看起来相似的<code>interface</code>。一个<code>interface</code>可能包含另一个<code>interface</code>的所有成员，只是增加了一些额外的成员。</p>
<p><code>TypeScript</code>允许一个接口<code>extend</code>另一个接口，即<font color=red>声明它复制了另一个接口的所有成员</font>。一个接口可以通过在其名称后添加<code>extends</code>关键字来标记为扩展另一个接口，然后再添加要扩展的接口名称。这样做向TypeScript 表明，所有遵循派生接口的对象也必须拥有基接口的所有成员。</p>
<p>在下面例子中，接口<code>Novella</code>扩展了接口<code>Writing</code>，因此要求对象至少同时拥有<code>Novella</code>的<code>pages</code>和<code>Writing</code>的<code>title</code>成员：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Writing</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">title</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Novella</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Writing</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">myNovella</span>: <span style="color:#66d9ef">Novella</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">195</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">title</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Ethan Frome&#34;</span>,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#75715e">//  Property &#39;pages&#39; is missing in type &#39;{ title: string; }&#39; but required in type &#39;Novella&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">missingPages</span>: <span style="color:#66d9ef">Novella</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">title</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;The Awakening&#34;</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//   Object literal may only specify known properties, and &#39;strategy&#39; does not exist in type &#39;Novella&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">extraProperty</span>: <span style="color:#66d9ef">Novella</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">300</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">strategy</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;baseline&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">style</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Naturalism&#34;</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 使用变量暂存以规避问题
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">extraProperty1</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pages</span>: <span style="color:#66d9ef">300</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">strategy</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;baseline&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">style</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Naturalism&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">title</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;test&#34;</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 这样赋值不会出现编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">myNovella</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">extraProperty1</span>
</span></span></code></pre></div><p>通过接口扩展，可以避免在多个接口中重复输入相同的代码来表示这种关系。</p>
<h4 id="overridden-properties">Overridden Properties</h4>
<p>派生接口可以通过<font color=red>再次声明不同类型的属性来覆盖或替换其基础接口的属性</font>。<code>TypeScript</code>的类型检查器会强制要求覆盖的属性必须可赋值给其基础属性。这样做的目的是确保派生接口类型的实例始终可赋值给基接口类型。</p>
<p>大多数派生接口在重新声明属性时，要么是为了使这些属性成为一个类型联合的更具体的子集，要么是为了使这些属性成为一个从基本接口类型扩展而来的类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">WithNullableName</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">WithNonNullableName</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">WithNullableName</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编译错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">WithNumericName</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">WithNullableName</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="extending-multiple-interfaces">Extending Multiple Interfaces</h4>
<p><code>TypeScript</code>中的接口可以声明为<font color=red>扩展多个其他接口</font>。在派生接口名称后面的<code>extends</code>关键字之后，可以使用任意多个用逗号分隔的接口名称。派生接口将接收所有基础接口的所有成员。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">GivesNumber</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">giveNumber</span>()<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">GivesString</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">giveString</span>()<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">GivesBothAndEither</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">GivesNumber</span>, <span style="color:#a6e22e">GivesString</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">giveEither</span>()<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">useGivesBoth</span>(<span style="color:#a6e22e">instance</span>: <span style="color:#66d9ef">GivesBothAndEither</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">instance</span>.<span style="color:#a6e22e">giveEither</span>(); <span style="color:#75715e">// Type: number | string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">instance</span>.<span style="color:#a6e22e">giveNumber</span>(); <span style="color:#75715e">// Type: number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">instance</span>.<span style="color:#a6e22e">giveString</span>(); <span style="color:#75715e">// Type: string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>通过将一个接口标记为扩展多个其他接口，既可以减少代码重复，又可以使对象更容易在不同的代码区域重复使用。</p>
<h3 id="interface-merging">Interface Merging</h3>
<p>接口的一个重要特性是可以相互合并。接口合并意味着，如果<font color=red>在同一作用域中声明了两个名称相同的接口，它们就会合并成一个更大的接口</font>，并在该名称下包含所有声明的字段。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Merged</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fromFirst</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Merged</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fromSecond</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>接口合并并不是 TypeScript日常开发中经常使用的功能。建议在可能的情况下尽量避免使用该功能，因为如果在多个地方声明了一个接口，就很难理解代码。</p>
<p>然而，接口合并对于增强来自外部包或内置全局接口（如 <code>Window</code>）的接口特别有用。例如，当使用默认的 <code>TypeScript</code>编译器选项时，在带有<code>myEnvironmentVariable</code>属性的文件中声明 <code>Window</code> 接口，就可以使用 <code>window.myEnvironmentVariable</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Window</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">myEnvironmentVariable</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>window.<span style="color:#a6e22e">myEnvironmentVariable</span>;
</span></span></code></pre></div><h4 id="member-naming-conflicts">Member Naming Conflicts</h4>
<p>请注意，合并后的接口不得以不同类型多次声明相同名称的属性。<font color=red>如果一个接口中已经声明了一个属性，那么以后合并的接口必须使用相同的类型</font>。</p>
<p>但是，合并后的接口<font color=red>可以定义一个名称相同但签名不同的方法</font>。这样做会为该方法创建一个函数重载。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">MergedMethods</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">different</span>(<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">string</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">MergedMethods</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">different</span>(<span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">number</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span>; <span style="color:#75715e">// Ok 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h2 id="classes">Classes</h2>
<p>除了类型检查，<code>TypeScript</code>还强调了它的转换器（<code>transpiler</code>），类就是一个常见的例子。如今，<code>TypeScript</code> 的类只是支持所有<code>JavaScript</code>语言特性的众多特性中的一个。<code>TypeScript</code>既不鼓励也不反对类的使用或任何其他流行的<code>JavaScript</code>模式。</p>
<h3 id="class-methods">Class Methods</h3>
<p><code>TypeScript</code>对方法的理解通常与对独立函数的理解相同。除非给出类型或默认值，否则参数类型默认为<code>any</code>；调用方法需要可接受的参数数量；如果函数不是递归的，返回类型通常可以被推断出来。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Greeter</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">greet</span>(<span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">name</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, do your stuff!`</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Greeter</span>().<span style="color:#a6e22e">greet</span>(<span style="color:#e6db74">&#34;Miss Frizzle&#34;</span>) <span style="color:#75715e">// Miss Frizzle, do your stuff!
</span></span></span></code></pre></div><p>在参数方面，类构造函数被视为典型的类方法。<code>TypeScript</code>将执行类型检查，以确保为方法调用提供了数量正确、类型正确的参数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Greeted</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>(<span style="color:#a6e22e">message</span>: <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`As I always say: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">message</span><span style="color:#e6db74">}</span><span style="color:#e6db74">!`</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Greeted</span>(<span style="color:#e6db74">&#34;take chances, make mistakes, get messy&#34;</span>); <span style="color:#75715e">// As I always say: take chances, make mistakes, get messy!
</span></span></span></code></pre></div><h1 id="heading"></h1>

    </div>
    <footer class="post-footer">
        
 
<div class="post-tags">     
     
    <a href="https://iihui.github.io/tags/ts" rel="tag" title="ts">#ts#</a>
    
</div>



        <div class="post-nav">
    <div class="post-nav-next post-nav-item">
    
        <a href="https://iihui.github.io/post/tool-rider/" rel="next" title="Rider 使用">
        <i class="fa fa-chevron-left"></i> Rider 使用
        </a>
    
    </div>

    <div class="post-nav-prev post-nav-item">
    
        <a href="https://iihui.github.io/post/ios-fundamentals/" rel="prev" title="iOS 14 编程基础">
        iOS 14 编程基础 <i class="fa fa-chevron-right"></i>
        </a>
    
    </div>
</div>
      
        <div class="post-nav">
    <div style="border: 1px dashed #e0e0e0; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
        <div style="float:left;margin-top:0px;">
            <img src="https://i.loli.net/2020/02/09/SvhUdz4XJsOr9Vk.jpg" width="128px" height="128px"/>
            <div style="text-align:center;">谢谢支持!</div>
        </div>
        <div>
            <p style="margin-top:10px;">
                标题：TypeScript基础
                <br />作者：阿呆<a target="_blank" href="https://iihui.github.io/"></a>
                
                <br />地址：https://iihui.github.io/post/ts-base/
                <br />声明：自由转载-非商用-保持署名（创作共享4.0许可证）
            </p>
        </div>
    </div>
    <div class="clear"></div>
</div>
        
        
        




    </footer>
  </article>
</section>

          </div>
        </div>
        <div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>
<aside id="sidebar" class="sidebar">
  <div class="sidebar-inner">

  <ul class="sidebar-nav motion-element">
    <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
      文章目录
    </li>
    <li class="sidebar-nav-overview" data-target="site-overview">
      站点概览
    </li>
  </ul>

    <section class="site-overview sidebar-panel ">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
        src="https://i.loli.net/2020/02/07/dVFzrvZkHRNq2lL.jpg"
        alt="" />
    <p class="site-author-name" itemprop="name"></p>
    <p class="site-description motion-element" itemprop="description"> 
        coder &amp; cook</p>
</div>
      <nav class="site-state motion-element">
    <div class="site-state-item site-state-posts">
      <a href="https://iihui.github.io/post/">
        <span class="site-state-item-count">141</span>
        <span class="site-state-item-name">日志</span>
      </a>
    </div>
    <div class="site-state-item site-state-categories">    
        <a href="https://iihui.github.io/categories/">      
         
        <span class="site-state-item-count">19</span>
        
        <span class="site-state-item-name">分类</span>
        
        </a>
    </div>

    <div class="site-state-item site-state-tags">
        <a href="https://iihui.github.io/tags/">
         
        <span class="site-state-item-count">30</span>
        
        <span class="site-state-item-name">标签</span>
        </a>
    </div>
</nav>
      
      
<div class="links-of-author motion-element">
    
        <span class="links-of-author-item">
        <a href="https://coolshell.cn" target="_blank" title="皓 大">
            <i class="fa fa-fw fa-globe"></i>
            皓 大
        </a>
        </span>
    
        <span class="links-of-author-item">
        <a href="http://www.ruanyifeng.com" target="_blank" title="阮 大">
            <i class="fa fa-fw fa-globe"></i>
            阮 大
        </a>
        </span>
    
        <span class="links-of-author-item">
        <a href="https://juejin.im/" target="_blank" title="掘 金">
            <i class="fa fa-fw fa-globe"></i>
            掘 金
        </a>
        </span>
    
</div>


      

      <div class="links-of-blogroll motion-element inline">
<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=&amp;m=0&amp;s=220&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;bv=35" async="async"></script>
</div>

    </section>
    
<section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
    <div class="post-toc">
        <div class="post-toc-content"><nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#modules">Modules</a></li>
        <li><a href="#unions-and-literals">Unions and Literals</a>
          <ul>
            <li><a href="#union-types">Union Types</a></li>
            <li><a href="#narrowing">Narrowing</a>
              <ul>
                <li><a href="#assignment-narrowing">Assignment Narrowing</a></li>
                <li><a href="#conditional-checks">Conditional Checks</a></li>
              </ul>
            </li>
            <li><a href="#literal-types">Literal Types</a>
              <ul>
                <li><a href="#literal-assignability">Literal Assignability</a></li>
              </ul>
            </li>
            <li><a href="#strict-null-checking">Strict Null Checking</a>
              <ul>
                <li><a href="#billion-dollar-mistake">billion-dollar mistake</a></li>
                <li><a href="#truthiness-narrowing">Truthiness Narrowing</a></li>
                <li><a href="#variables-without-initial-values">Variables Without Initial Values</a></li>
              </ul>
            </li>
            <li><a href="#type-aliases">Type Aliases</a>
              <ul>
                <li><a href="#type-aliases-are-not-javascript">Type Aliases Are Not JavaScript</a></li>
                <li><a href="#combining-type-aliases">Combining Type Aliases</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#objects">Objects</a>
          <ul>
            <li><a href="#object-types">Object Types</a>
              <ul>
                <li><a href="#declaring-object-types">Declaring Object Types</a></li>
                <li><a href="#aliased-object-types">Aliased Object Types</a></li>
              </ul>
            </li>
            <li><a href="#structural-typing">Structural Typing</a>
              <ul>
                <li><a href="#usage-checking">Usage Checking</a></li>
                <li><a href="#excess-property-checking">Excess Property Checking</a></li>
                <li><a href="#nested-object-types">Nested Object Types</a></li>
                <li><a href="#optional-properties">Optional Properties</a></li>
              </ul>
            </li>
            <li><a href="#unions-of-object-types">Unions of Object Types</a>
              <ul>
                <li><a href="#inferred-object-type-unions">Inferred Object-Type Unions</a></li>
                <li><a href="#explicit-object-type-unions">Explicit Object-Type Unions</a></li>
                <li><a href="#narrowing-object-types">Narrowing Object Types</a></li>
                <li><a href="#discriminated-unions">Discriminated Unions</a></li>
              </ul>
            </li>
            <li><a href="#intersection-types">Intersection Types</a>
              <ul>
                <li><a href="#dangers-of-intersection-types">Dangers of Intersection Types</a></li>
                <li><a href="#never">never</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#functions">Functions</a>
          <ul>
            <li><a href="#function-parameters">Function Parameters</a>
              <ul>
                <li><a href="#required-parameters">Required Parameters</a></li>
                <li><a href="#optional-parameters">Optional Parameters</a></li>
                <li><a href="#default-parameters">Default Parameters</a></li>
                <li><a href="#rest-parameters">Rest Parameters</a></li>
              </ul>
            </li>
            <li><a href="#return-types">Return Types</a>
              <ul>
                <li><a href="#explicit-return-types">Explicit Return Types</a></li>
              </ul>
            </li>
            <li><a href="#function-types">Function Types</a>
              <ul>
                <li><a href="#function-type-parentheses">Function Type Parentheses</a></li>
                <li><a href="#parameter-type-inferences">Parameter Type Inferences</a></li>
                <li><a href="#function-type-aliases">Function Type Aliases</a></li>
              </ul>
            </li>
            <li><a href="#more-return-types">More Return Types</a>
              <ul>
                <li><a href="#never-returns">Never Returns</a></li>
              </ul>
            </li>
            <li><a href="#function-overloads">Function Overloads</a>
              <ul>
                <li><a href="#call-signature-compatibility">Call-Signature Compatibility</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#arrays">Arrays</a>
          <ul>
            <li><a href="#array-types">Array Types</a>
              <ul>
                <li><a href="#array-and-function-types">Array and Function Types</a></li>
                <li><a href="#union-type-arrays">Union-Type Arrays</a></li>
                <li><a href="#evolving-any-arrays">Evolving Any Arrays</a></li>
                <li><a href="#multidimensional-arrays">Multidimensional Arrays</a></li>
              </ul>
            </li>
            <li><a href="#array-members">Array Members</a>
              <ul>
                <li><a href="#caveat-unsound-members">Caveat: Unsound Members</a></li>
              </ul>
            </li>
            <li><a href="#spreads-and-rests">Spreads and Rests</a>
              <ul>
                <li><a href="#spreads">Spreads</a></li>
                <li><a href="#spreading-rest-parameters">Spreading Rest Parameters</a></li>
              </ul>
            </li>
            <li><a href="#tuples">Tuples</a>
              <ul>
                <li><a href="#tuple-assignability">Tuple Assignability</a></li>
                <li><a href="#tuple-inferences">Tuple Inferences</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#interfaces">Interfaces</a>
          <ul>
            <li><a href="#type-aliases-versus-interfaces">Type Aliases Versus Interfaces</a></li>
            <li><a href="#types-of-properties">Types of Properties</a>
              <ul>
                <li><a href="#optional-properties-1">Optional Properties</a></li>
                <li><a href="#read-only-properties">Read-Only Properties</a></li>
                <li><a href="#functions-and-methods">Functions and Methods</a></li>
                <li><a href="#call-signatures">Call Signatures</a></li>
                <li><a href="#index-signatures">Index Signatures</a></li>
              </ul>
            </li>
            <li><a href="#interface-extensions">Interface Extensions</a>
              <ul>
                <li><a href="#overridden-properties">Overridden Properties</a></li>
                <li><a href="#extending-multiple-interfaces">Extending Multiple Interfaces</a></li>
              </ul>
            </li>
            <li><a href="#interface-merging">Interface Merging</a>
              <ul>
                <li><a href="#member-naming-conflicts">Member Naming Conflicts</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#classes">Classes</a>
          <ul>
            <li><a href="#class-methods">Class Methods</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#heading"></a></li>
  </ul>
</nav></div>
    </div>
</section>

  </div>
</aside>

      </div>
    </main>
   
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  <span itemprop="copyrightYear">  &copy; 
  2017 - 2024</span>
  <span class="with-love"><i class="fa fa-heart"></i></span>
  <span class="author" itemprop="copyrightHolder">Keep It Simple</span>
</div>




      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      <span id="scrollpercent"><span>0</span>%</span>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/jquery/index.js?v=2.1.3"></script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script> 
<script type="text/javascript" src="https://iihui.github.io/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/velocity/velocity.min.js?v=1.2.1"></script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="https://iihui.github.io/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>

<script src="https://iihui.github.io/js/vendor/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>

<script type="text/javascript" src="https://iihui.github.io/js/utils.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/motion.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/affix.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/schemes/pisces.js"></script>

<script type="text/javascript" src="https://iihui.github.io/js/scrollspy.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/post-details.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/toc.js"></script>

<script type="text/javascript" src="https://iihui.github.io/js/bootstrap.js"></script>

<script type="text/javascript" src="https://iihui.github.io/js/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
</body>
</html>