<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
    <title>C&#43;&#43; 常见知识点 - Keep It Simple</title>
    <meta name="keywords" content="博客,思考,读书,笔记,技术,分享">
    
    <meta property="og:title" content="C&#43;&#43; 常见知识点">
    <meta property="og:site_name" content="Keep It Simple">
    <meta property="og:image" content="/img/author.jpg"> 
    <meta name="title" content="C&#43;&#43; 常见知识点 - Keep It Simple" />
    <meta name="description" content="Swift | Go | C&#43;&#43; "> 
    <link rel="shortcut icon" href="https://iihui.github.io/img/favicon.ico" />
    <link rel="apple-touch-icon" href="https://iihui.github.io/img/apple-touch-icon.png" />
    <link rel="apple-touch-icon-precomposed" href="https://iihui.github.io/img/apple-touch-icon.png" />
    <link href="https://iihui.github.io/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />
    <link href="https://iihui.github.io/js/vendor/fancybox/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />
    <link href="https://iihui.github.io/css/main.css" rel="stylesheet" type="text/css" />
    <link href="https://iihui.github.io/css/syntax.css" rel="stylesheet" type="text/css" />

    <script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
     fancybox: true, 
    motion: true
  };
</script>

    <link href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/monokai-sublime.min.css" rel="stylesheet">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/go.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/swift.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/objectivec.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/clojure.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/kotlin.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/yaml.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<div class="container one-collumn sidebar-position-left page-home  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-meta  custom-logo ">

  <div class="custom-logo-site-title">
    <a href="https://iihui.github.io/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Keep It Simple</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">靡不有初，鲜克有终</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
    <ul id="menu" class="menu">
      
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/tags/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-tag"></i> <br />标签
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/post/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/categories/%E7%BE%8E%E9%A3%9F/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-fire"></i> <br />美食
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/categories/%E5%90%8E%E6%9C%9F/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-edit"></i> <br />后期
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/categories/%E6%97%85%E8%A1%8C/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-leaf"></i> <br />旅行
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/about/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于
          </a>
        </li>
      
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger"> <i class="menu-item-icon fa fa-search fa-fw"></i> <br /> 搜索</a>
      </li>
    </ul>
    <div class="site-search">
      <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>

    </div>
</nav>
<script type="text/javascript"
        async
        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
		<!-- src = "http://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> <\!--  -\-> -->
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>

<!DOCTYPE html>
<html lang="en">


<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css" integrity="sha384-D+9gmBxUQogRLqvARvNLmA9hS2x//eK1FhVb9PiU86gmcrBrJAQT8okdJ4LMp2uv" crossorigin="anonymous">

    
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js" integrity="sha384-483A6DwYfKeDa0Q52fJmxFXkcPCFfnXMoXblOkJ4JcA8zATN6Tm78UNL72AKk+0O" crossorigin="anonymous"></script>
</head>
<body>

</body>
</html>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
<section id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="https://iihui.github.io/post/cpp-base/" itemprop="url">
        C&#43;&#43; 常见知识点
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">创建: </span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2018-05-05">
    2018-05-05
</time>
</span>
&nbsp; | &nbsp;
<span class="post-updated-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-check-o"></i>
</span>
<span class="post-meta-item-text">更新: </span>
<time itemprop="dateUpdated" content="2018-05-05">
    2018-05-05
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类: </span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="https://iihui.github.io/categories/code" itemprop="url" rel="index">
        <span itemprop="name">code</span>
      </a>
      &nbsp; 
    </span>
  
</span>


      <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-file-word-o"></i>
</span>
<span class="post-meta-item-text">字数: </span>
<span class="leancloud-visitors-count">6985</span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-coffee"></i>
</span>
<span class="post-meta-item-text">阅读: </span>
<span class="leancloud-visitors-count">14 分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <h2 id="static的作用">static的作用</h2>
<ul>
<li>
<p>对<font color=red>普通函数和全局变量</font>而言<code>static</code>具有隐藏作用：将其修饰的全局变量和函数的<font color=Blue>作用域限定在本文件中</font>。不加<code>static</code>修饰的函数和全局变量具有全局可见性。</p>
</li>
<li>
<p>普通局部变量而言</p>
<ul>
<li>
<p>未初始化的<code>static</code>普通局部变量，编译器会将其初始化为<code>0</code>，因为<code>BSS</code>段(未初始化数据段）中所有的字节都默认为<code>0x00</code>。</p>
</li>
<li>
<p>使用<code>static</code>修饰的普通局部变量的<font color=red>生存期为整个源程序</font>，即初始化一次便具有<font color=Blue>记忆性</font>。但是，<font color=blue>作用域只在定义该变量的函数中</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">testLocalStaticVar</span>(){
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span>  x<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> x <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">**</span>argv) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">3</span>; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>   testLocalStaticVar();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}  <span style="color:#75715e">// 5,6,7
</span></span></span></code></pre></div></li>
</ul>
</li>
<li>
<p>成员变量：</p>
<ul>
<li>
<p>属于类的，只有一份，每个对象共享，可以使用类名直接调用。</p>
</li>
<li>
<p>除了<font color=red>基本整型的<code>const static</code>整型可以在类的定义体中初始化</font>，<font color=Blue>其他的必须在类外初始化</font>。</p>
</li>
<li>
<p><code>sizeof</code>计算的时候<font color=red>不会计算静态数据成员</font>，因为它不放在栈区，放在全局（静态）存储区。</p>
</li>
</ul>
</li>
<li>
<p>成员函数：</p>
<ul>
<li>
<p>不与任何对象实例关联，所以没有<code>this</code>指针，因此<font color=red>不能访问非静态成员变量和成员函数</font>。</p>
</li>
<li>
<p><code>static</code>成员函数<font color=red>不能声明为<code>const</code>。</font>毕竟将函数声明为<code>const</code>就承诺不会修改该函数所属对象，而<code>static</code>成员函数不属于任何对象实例。</p>
</li>
<li>
<p>因为没有<code>this</code>指针的开销，所以静态成员函数与类的非静态成员函数相比速度上有少许增长。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="const的作用">const的作用</h2>
<p>对于普通变量而言<code>const</code>修饰符的目的<font color=Blue>为了替代宏定义</font>，与宏定义对比，总<font color=red>共有<code>5</code>点区别</font>：</p>
<ul>
<li>
<p><code>const</code>常量有类型，编译器对其进行类型安全检查；而宏定义没有类型，编译器只对宏定义进行字符替换。</p>
</li>
<li>
<p><code>#define</code>是一个编译时概念，在预处理的时候展开，<font color=red>进行直接替换，存储在代码段，不分配内存，生命周期止于编译时期</font>；而<code>const</code>常量存在于数据段，分配内存，属于运行时的概念。</p>
</li>
<li>
<p>宏定义可以使用<code>#undef</code>来使之前的宏定义失效；<code>const</code>常量定义后将在定义域内永久有效。</p>
</li>
<li>
<p>使用<code>const</code>常量可能比使用<code>#define</code>产生更小的目标代码（例如代码中使用<code>100</code>次同一个宏定义）。</p>
</li>
<li>
<p>常量折叠（编译期间简化常量表达式&ndash;对常量表达式求值,并将求得的值替换表达式，放入到常量表中)。</p>
</li>
</ul>
<hr>
<p>普通变量与<code>const</code>修饰符需<font color=red>注意的<code>3</code>点</font>：</p>
<ul>
<li>
<p>声明<code>const</code>变量时必须进行初始化</p>
</li>
<li>
<p><code>const</code>对象的动态数组：必须提供数组的初始化</p>
</li>
<li>
<p><code>const</code>全局变量：<font color=Blue>在全局作用域中声明的<code>const</code>变量是定义该对象的文件的局部变量，此变量只存在于那个文件中，不能被其他文件所访问。</font></p>
</li>
</ul>
<hr>
<p>指针变量和<code>const</code>修饰符：</p>
<ul>
<li>
<p><code>const</code>指针：一旦初始化便不能再指向别的对象，但是可以<font color=red>通过解引用来改变所绑定对象的值</font>。</p>
</li>
<li>
<p>指向<code>const</code>对象的指针：不能通过解引用来改变所指的对象的值，但是可以更改所指向的对象，即解除绑定，重新再绑定。</p>
</li>
<li>
<p>指向<code>const</code>对象的<code>const</code>指针：一旦初始化便不能再指向别的对象，也不能通过解引用来改变所指的对象的值。</p>
</li>
</ul>
<hr>
<p>函数与<code>const</code>修饰符：</p>
<ol>
<li>
<p>函数的返回值和<code>const</code>修饰符：</p>
<ul>
<li>如果返回值是值类型(非指针、引用类型），对于内部数据类型来说，返回值是否是常量并没有关系。而对<font color=Blue>类类型如果返回值为某个对象的<code>const</code>或某个对象的引用<code>const</code>，则返回值具有<code>const</code>属性，只能访问返回值的公有(可能也可以保护成员）数据成员和<code>const</code>成员函数，并且不允许进行赋值操作。</font></li>
</ul>
</li>
</ol>
<ul>
<li>如果返回值是指针类型，<font color=red>函数不能返回局部变量的指针，因为函数调用之后栈被清理</font>，只能返回指向堆区的分配的存储空间的指针，或者指向静态存储区的指针，因为在函数返回后它们依然有效。</li>
</ul>
<ol start="2">
<li>
<p>函数的参数和<code>const</code>修饰符：</p>
<ul>
<li>
<p>如果是传值：对函数调用者的约束不太大，可以传入一个<code>const</code>变量也可以传入一个普通变量，<font color=Blue>只能说明在函数中不会改变其值</font>。</p>
</li>
<li>
<p>如果是传指针：对于指向非<code>const</code>变量的指针参数，只能传入一个指向非<code>const</code>变量的指针，不能传入一个<code>const</code>指针，因为指明不能通过解引用来改变值。因此，若是<font color=red>传地址，则无论什么时候传递一个地址给函数，应该尽可能用<code>const</code>修饰它（除非此实参在函数内需要修改）</font>，如果不这么做，就使得指向<code>const</code>的指针不能做实参。</p>
</li>
</ul>
</li>
</ol>
<ul>
<li>函数参数为<code>const</code>引用时可以接收临时对象。</li>
</ul>
<hr>
<p>成员变量和<code>const</code>修饰符：</p>
<ul>
<li>
<p>对于类来说<code>const</code>变量是可变的，但是对于对象实例来说是不可变的。</p>
</li>
<li>
<p>必须在构造函数的成<font color=Blue>初始化列表中初始化。</font></p>
</li>
</ul>
<hr>
<p>成员函数和<code>const</code>修饰符：</p>
<ul>
<li>
<p><code>this</code>指针类型由<code>obj * const</code> 变为 <code>const obj  * const</code></p>
</li>
<li>
<p><code>const</code>对象实例、指向<code>const</code>对象的指针、指向<code>const</code>对象的引<font color=Blue>都只能调用<code>const</code>成员函数</font>。<code>const</code>实施于成员函数的目的，确保该成员函数可作用于<code>const</code>对象实例。<font color=Blue>如果不存在<code>const</code>成员函数，则<code>const</code>对象实例无法调用任何成员函数。</font></p>
</li>
<li>
<p>对于非<code>const</code>对象而言<font color=Blue>可以调用<code>const</code>成员函数和非<code>const</code>成员函数。</font></p>
</li>
</ul>
<hr>
<h2 id="c构造函数">C++构造函数</h2>
<h3 id="构造函数的特点">构造函数的特点</h3>
<p>构造函数是一种特殊的成员函数， 它具有如下特点：</p>
<ul>
<li>
<p>名字与类名相同。</p>
</li>
<li>
<p>没有返回值。</p>
</li>
<li>
<p>在对象创建时自动调用，但是<font color=red>不能被显式调用</font>。</p>
</li>
</ul>
<hr>
<h3 id="构造函数的作用">构造函数的作用</h3>
<ul>
<li>
<p>给创建的对象建立一个标识符;</p>
</li>
<li>
<p>为对象数据成员开辟内存空间;</p>
</li>
<li>
<p>完成对象数据成员的初始化。</p>
<p>![c600](<a href="http://oqe76o492.bkt.clouddn.com/">http://oqe76o492.bkt.clouddn.com/</a>屏幕快照 2017-05-02 上午8.27.52.png)</p>
</li>
</ul>
<hr>
<h3 id="构造函数的分类">构造函数的分类</h3>
<p>构造函数可以分为普通的构造函数和拷贝(复制)构造函数：</p>
<ul>
<li>
<p>普通的构造函数</p>
</li>
<li>
<p>拷贝构造函数: 对于一个构造函数的第一个参数为如下的几种，<font color=red>而且其他参数都有默认值</font>，称为拷贝构造函数：</p>
<ul>
<li><code>A &amp;</code></li>
<li><code>const A &amp;</code></li>
<li><code>volatile A &amp;</code>  其中<code>volatile</code>（不稳定的）编译器访问该变量的代码不再进行优化</li>
<li><code>const volatile A &amp; </code></li>
</ul>
</li>
<li>
<p>防止默认拷贝发生：<font color=red>声明一个私有的拷贝构造函数</font></p>
</li>
</ul>
<p>因此一个类其实可以有多个拷贝构造函数，拷贝构造函数又分为：</p>
<ul>
<li>
<p>浅拷贝：只对对象中的数据成员进行简单的赋值。</p>
</li>
<li>
<p>深拷贝：对于对象中<font color=red>动态成员重新分配空间</font>。</p>
</li>
</ul>
<hr>
<h2 id="mallocfree和newdelete的区别">malloc/free和new/delete的区别</h2>
<ol>
<li>
<p><code>malloc/free</code>是标准库函数，而<code>new/delete</code>是<code>C++</code><font color=Blue>运算符</font>。</p>
</li>
<li>
<p><code>new</code>自动计算需要分配的空间，而<code>malloc</code>需要手工计算字节数。</p>
</li>
<li>
<p><code>new</code>是类型安全的，因为<code>new</code>中内置了<code>sizeof</code>, 具有类型转换和类型安全检查功能，而<code>malloc</code>不是类型安全的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">float</span>[<span style="color:#ae81ff">2</span>]; <span style="color:#75715e">//编译时指出错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>p  <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span>)malloc(<span style="color:#ae81ff">2</span><span style="color:#f92672">*</span><span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">double</span>)); <span style="color:#75715e">//编译时无法指出错误
</span></span></span></code></pre></div></li>
<li>
<p><code>new</code>首先调用<code>operator new</code>标准库函数，分配足够大的原始的未类型化的空间。接下来调用相关对象的构造函数，以初始化对象。最后返回新分配并构造的对象的指针。而<code>malloc</code>不能调用构造函数；<code>delete</code>将调用该实例的析构函数，然后调用<code>operator delete</code>标准库函数以施放该实例占用的空间，<code>free</code>不能调用析构函数。
![c600](<a href="http://oqe76o492.bkt.clouddn.com/">http://oqe76o492.bkt.clouddn.com/</a>屏幕快照 2017-05-02 上午8.27.52.png)</p>
</li>
<li>
<p><code>malloc/free</code>需要头文件支持，而<code>new/delete</code>不需要。</p>
</li>
<li>
<p><code>new</code>操作<font color=red>自由存储区<code>(free store)</code></font>上为对象动态分配内存空间，而<code>malloc</code>函数从堆上动态分配内存。</p>
<ul>
<li>
<p>自由存储区是<code>C++</code>基于<code>new</code>操作符的一个抽象概念，凡是通过<code>new</code>操作符进行内存申请，该内存即为自由存储区。</p>
</li>
<li>
<p>堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，<code>C</code>语言使用<code>malloc</code>从堆上分配内存，使用<code>free</code>释放已分配的对应内存。</p>
</li>
<li>
<p>那么自由存储区是否能够是堆（<font color=red>问题等价于<code>new</code>是否能在堆上动态分配内存），这取决于<code>operator new</code>的实现细节。</font>自由存储区不仅可以是堆，还可以是静态存储区，这都看<code>operator new</code>在哪里为对象分配内存。</p>
</li>
<li>
<p>特别地，<code>new</code><font color=Blue>甚至可以不为对象分配内存</font>。定位<code>new</code>的功能可以办到这一点：
![c600](<a href="http://oqe76o492.bkt.clouddn.com/">http://oqe76o492.bkt.clouddn.com/</a>屏幕快照 2017-05-02 上午8.26.28.png)</p>
</li>
</ul>
</li>
<li>
<p><code>new</code>内存分配失败时<font color=red>会抛出<code>bad_alloc</code>异常</font>，它不会返回<code>NULL</code>；<code>malloc</code>分配内存失败时返回<code>NULL</code>。</p>
</li>
<li>
<p>是否可以被重载
![c600](<a href="http://oqe76o492.bkt.clouddn.com/">http://oqe76o492.bkt.clouddn.com/</a>屏幕快照 2017-05-02 上午8.29.22.png)</p>
</li>
<li>
<p><code>new</code>与<code>malloc</code>是否可以相互调用：<code>operator new /operator delete</code>的实现可以基于<code>malloc</code>，而<code>malloc</code>的实现不可以去调用<code>new</code>。</p>
</li>
<li>
<p>能够直观地重新分配内存：使用<code>malloc</code>分配的内存后，如果在使用过程中发现内存不足，<font color=red>可以使用<code>realloc</code>函数进行内存重新分配实现内存的扩充。</font><code>realloc</code>先判断当前的指针所指内存是否有足够的连续空间，如果有，原地扩大可分配的内存地址，并且返回原来的地址指针。如果空间不够，先按照新指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存区域。</p>
</li>
<li>
<p>内存分配不足的处理：在<code>operator new</code>抛出异常以反映一个未获得满足的需求之前，它<font color=red>先调用一个用户指定的错误处理函数，这就是<code>new-handler</code>。</font>
![c600](<a href="http://oqe76o492.bkt.clouddn.com/">http://oqe76o492.bkt.clouddn.com/</a>屏幕快照 2017-05-02 上午8.32.56.png)
![c600](<a href="http://oqe76o492.bkt.clouddn.com/">http://oqe76o492.bkt.clouddn.com/</a>屏幕快照 2017-05-02 上午8.30.59.png)</p>
</li>
</ol>
<hr>
<h2 id="堆和栈的区别">堆和栈的区别</h2>
<p>堆和栈的区别，<font color=red>总共分为<code>6</code>点： </font>
<img src="http://oqe76o492.bkt.clouddn.com/10005.png" alt="c600"></p>
<hr>
<h2 id="c空类默认生成的成员函数">C++空类默认生成的成员函数</h2>
<ul>
<li>
<p>构造函数</p>
</li>
<li>
<p>拷贝构造函数</p>
</li>
<li>
<p>赋值操作符</p>
</li>
<li>
<p>析构函数</p>
</li>
<li>
<p>取址运算符</p>
</li>
<li>
<p>取址运算符<code>const</code>版本</p>
</li>
</ul>
<p><img src="http://oqe76o492.bkt.clouddn.com/1010.png" alt="c600"></p>
<hr>
<h2 id="delete和delete的区别">delete和delete[]的区别</h2>
<ul>
<li>
<p>针对基本数据类型：使用<code>new</code>分配后的不管是数组还是非数组形式内存空间用两种方式均可，原因是：<font color=red>分配简单类型内存时，内存大小已经确定，系统可以记忆并且进行管理，在析构时，系统并不会调用析构函数。</font></p>
</li>
<li>
<p>针对类类型：</p>
<ul>
<li>
<p><code>delete   ptr;</code>代表用来释放内存，且只用来释放ptr指向的内存。</p>
</li>
<li>
<p><code>delete[] ptr;</code> 用来释放ptr指向的内存，还<font color=red>逐一调用数组中每个对象的<code>destructor</code>。</font>
![c600](<a href="http://oqe76o492.bkt.clouddn.com/">http://oqe76o492.bkt.clouddn.com/</a>屏幕快照 2017-05-01 下午2.51.46.png)</p>
</li>
<li>
<p><code>delete a;</code>仅释放了<code>a</code>指针指向的内存空间 , 也就是<font color=red>只调用了 <code>a[0]</code>对象的析构函数</font>， 剩下的从<code>a[1]</code>到<code>a[9]</code>这<code>9</code>个用户自行分配的<code>m_cBuffer</code>对应内存空间将不能释放从而<font color=red>造成内存泄漏</font>。</p>
</li>
<li>
<p><code>delete [] a;</code>释放了<code>a</code>指针指向的全部内存空间，也就是调用<code>a[0]</code>到<code>a[9]</code>对象的析构函数释放分配的内存空间。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="虚函数表">虚函数表</h2>
<p>![c600](<a href="http://oqe76o492.bkt.clouddn.com/">http://oqe76o492.bkt.clouddn.com/</a>屏幕快照 2017-05-01 下午11.09.32.png)</p>
<p>![c600](<a href="http://oqe76o492.bkt.clouddn.com/">http://oqe76o492.bkt.clouddn.com/</a>屏幕快照 2017-05-01 下午11.10.04.png)</p>
<hr>
<h3 id="一般继承">一般继承</h3>
<p>![c600](<a href="http://oqe76o492.bkt.clouddn.com/">http://oqe76o492.bkt.clouddn.com/</a>屏幕快照 2017-05-01 下午11.10.31.png)</p>
<h3 id="多重继承-无虚函数覆盖">多重继承-无虚函数覆盖</h3>
<p><font color=red> 多重继承时，有几个基类就有几个vptr</font></p>
<p>![c600](<a href="http://oqe76o492.bkt.clouddn.com/">http://oqe76o492.bkt.clouddn.com/</a>屏幕快照 2017-05-01 下午11.11.02.png)</p>
<p>这样做就是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数。</p>
<hr>
<h3 id="多重继承-有虚函数覆盖">多重继承-有虚函数覆盖</h3>
<p>![c600](<a href="http://oqe76o492.bkt.clouddn.com/">http://oqe76o492.bkt.clouddn.com/</a>屏幕快照 2017-05-01 下午11.11.54.png)</p>
<hr>
<h2 id="哪些函数不能为虚函数">哪些函数不能为虚函数</h2>
<ul>
<li>
<p>普通函数 ： 只能重载不能被重写,<font color=red>即不能被继承</font></p>
</li>
<li>
<p>静态成员函数: 不属于任何对象实例，因而没有动态绑定的</p>
</li>
<li>
<p>构造函数</p>
<p>![c600](<a href="http://oqe76o492.bkt.clouddn.com/">http://oqe76o492.bkt.clouddn.com/</a>屏幕快照 2017-05-01 下午11.07.52.png)
按照 <font color=red>动态绑定原理，此时B的构造函数会覆盖掉A的构造函数</font></p>
</li>
<li>
<p>友元函数： C++不支持友元函数的继承</p>
</li>
<li>
<p>内联函数：</p>
</li>
<li>
<p>赋值操作符重载函数</p>
<p>![c600](<a href="http://oqe76o492.bkt.clouddn.com/">http://oqe76o492.bkt.clouddn.com/</a>屏幕快照 2017-05-01 下午11.08.16.png)</p>
</li>
</ul>
<hr>
<h2 id="c对象布局">C++对象布局</h2>
<ul>
<li>
<p>单一的一般继承
<img src="http://oqe76o492.bkt.clouddn.com/10002.png" alt="c600"></p>
</li>
<li>
<p>多重继承
<img src="http://oqe76o492.bkt.clouddn.com/10003.png" alt="c600"></p>
</li>
<li>
<p>重复继承
<img src="http://oqe76o492.bkt.clouddn.com/10004.png" alt="c600"></p>
</li>
<li>
<p>菱形继承
![c600](<a href="http://oqe76o492.bkt.clouddn.com/">http://oqe76o492.bkt.clouddn.com/</a>屏幕快照 2017-05-01 下午11.06.45.png)
<img src="http://oqe76o492.bkt.clouddn.com/Snipaste_2018-03-29_10-33-52.png" alt="c600"></p>
</li>
</ul>
<hr>
<h2 id="内存溢出">内存溢出</h2>
<p>内存溢出(<code>out of memory</code>）：<font color=red>是指程序在申请内存时，没有足够的内存空间供其使用。</font>导致不够用的原因很多,泄漏只是其中一种。通常在运行大型软件或游戏时，软件或游戏所需要的内存远远超出了你主机内安装的内存所承受大小，就叫内存溢出。</p>
<p>内存溢出的几种情况：</p>
<ul>
<li>
<p>比如系统只有存放<code>integer</code>的空间，但你却申请了存放<code>long</code>，那就是内存溢出。</p>
</li>
<li>
<p>比方定义了<code>20</code>个字节大小的内存空间，却写入了<code>21</code>个字节的数据。通俗的说，就是内存不够，没办法支持当前程序。（当发生内存溢出时，程序将无法进行，强制终止。）</p>
</li>
</ul>
<hr>
<h2 id="内存泄漏">内存泄漏</h2>
<p>内存泄漏是指你向系统申请分配内存进行使用(<code>new</code>)，可是使用完了以后却不归还(<code>delete</code>)，<font color=red>结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。</font>一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。</p>
<p>内存泄漏的分类：</p>
<ol>
<li>
<p>常发性内存泄漏。发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。</p>
</li>
<li>
<p>偶发性内存泄漏。发生内存泄漏的代码<font color=red>只有在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的。</font>对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。</p>
</li>
<li>
<p>一次性内存泄漏。发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。比如，在类的构造函数中分配内存，在析构函数中却没有释放该内存，所以内存泄漏只会发生一次。</p>
</li>
<li>
<p>隐式内存泄漏。<font color=red>程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。</font> 但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。</p>
</li>
</ol>
<hr>
<h2 id="c中哪些操作符是不能重载的">C++中哪些操作符是不能重载的</h2>
<ul>
<li>
<p><code>. </code> （成员访问运算符)</p>
</li>
<li>
<p><code>.*</code>  (成员指针访问运算符）</p>
</li>
<li>
<p><code>::</code>  （域运算符）</p>
</li>
<li>
<p><code>sizeof</code></p>
</li>
<li>
<p><code>?:</code> (条件运算符）</p>
</li>
<li>
<p><code>typeid</code>  域运算符和<code>sizeof</code>运算符的<font color=red>运算对象是类型而不是变量或者一般的表达式，不具备重载的特征</font></p>
</li>
</ul>
<hr>
<h2 id="c强制类型转换">C++强制类型转换</h2>
<h3 id="static_cast">static_cast</h3>
<ul>
<li>
<p><code>static_cast</code>也可以用在于基类与派生类指针或引用类型之间的转换。然而<font color=LightSeaGreen>它不做运行时的检查，不如<code>dynamic_cast</code>安全。</font><code>static_cast</code>仅仅是依靠类型转换语句中提供的信息来进行转换，而<code>dynamic_cast</code>则会<font color=red>遍历整个类继承体系进行类型检查,</font>因此<code>dynamic_cast</code>在执行效率上比<code>static_cast</code>要差一些。</p>
</li>
<li>
<p>编译器隐式执行的任何类型转换都可以由<code>static_cast</code>来完成，比如<code>int</code>与<code>float</code>、<code>double</code>与<code>char、enum</code>与<code>int</code>之间的转换等。</p>
<p>![c600](<a href="http://oqe76o492.bkt.clouddn.com/">http://oqe76o492.bkt.clouddn.com/</a>屏幕快照 2017-05-02 上午9.45.33.png)</p>
</li>
</ul>
<hr>
<h3 id="const_cast">const_cast</h3>
<ol>
<li>将转换掉表达式的<code>const</code>性质。
![c600](<a href="http://oqe76o492.bkt.clouddn.com/">http://oqe76o492.bkt.clouddn.com/</a>屏幕快照 2017-05-02 上午9.39.34.png)</li>
</ol>
<p>那既然const变量的值是肯定不会发生变化的，还需要这个<code>const_cast</code>类型转化有何用？这就引出了<code>const_cast</code>的最常用用法：</p>
<p>如果 <font color=red>有一个函数，它的形参是<code>non-const</code>类型变量，而且函数不会对实参的值进行改动，这时我们可以使用类型为<code>const</code>的变量来调用函数，此时<code>const_cast</code>就派上用场了。</font></p>
<p>![c600](<a href="http://oqe76o492.bkt.clouddn.com/">http://oqe76o492.bkt.clouddn.com/</a>屏幕快照 2017-05-02 上午9.41.33.png)</p>
<p><code>const_cast</code>绝对<font color=red>不是为了改变<code>const</code>变量的值而设计的！在函数参数的传递上<code>const_cast</code>的作用才显现出来。</font></p>
<ol start="2">
<li>
<p>只有使用<code>const_cast</code>才能将const性质性质转化掉。试图使用其他三种形式的强制转换都会导致编译时的错误。（添加const还可以用其他转换符，如<code>static_const</code>）</p>
</li>
<li>
<p>除了添加<code>const</code>或删除<code>const</code>特性，使用<code>const_cast</code>符来执行其他任何类型的转换都会引起编译错误。</p>
</li>
</ol>
<hr>
<h3 id="dynamic_cast">dynamic_cast</h3>
<ul>
<li>
<p>类型必须为类的<font color=red>指针，引用、<code>void*</code></font></p>
</li>
<li>
<p>需要<font color=Orange>检查运行时类型信息，而这个信息存储在虚函数表中</font>，所以只有定义了虚函数的类才可以使用，否则会出现编译错误</p>
</li>
<li>
<p>如果绑定到引用或指针对象的类型<font color=red>不是目标类型，则<code>dynamci_cast</code>失败，指针会返回0，引用会抛出<code>bad_cast</code>异常。</font></p>
</li>
</ul>
<hr>
<h3 id="reinterpret_cast">reinterpret_cast</h3>
<p>仅仅<font color=red>重新解释类型，但没有进行二进制的转换</font>:</p>
<ul>
<li>
<p>转换的类型必须是一个指针、引用、算术类型、函数指针或者成员指针</p>
</li>
<li>
<p>在比特位级别上进行转换。它<font color=LightSeaGreen>可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针</font>（先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值）</p>
</li>
<li>
<p>最普通的用途就是在函数指针类型之间进行转换</p>
</li>
</ul>
<hr>
<h2 id="c-中的引用">C++ 中的引用</h2>
<ul>
<li>
<p>引用是变量的别名，定义引用的时候<font color=LightSeaGreen>必须先初始化</font></p>
</li>
<li>
<p>不能<font color=Orange>定义引用数组</font></p>
</li>
<li>
<p>不能定义引用的引用</p>
</li>
<li>
<p>引用可以减少构造开销</p>
</li>
<li>
<p>当函数返回引用类型时，没有复制返回值，<font color=red>返回的是对象本身，所以不要返回局部对象的引用</font></p>
</li>
<li>
<p>函数参数为<code>const</code>引用时<font color=red>可以接收临时对象</font></p>
</li>
</ul>
<hr>

    </div>
    <footer class="post-footer">
        
 
<div class="post-tags">     
     
    <a href="https://iihui.github.io/tags/c&#43;&#43;" rel="tag" title="C&#43;&#43;">#C&#43;&#43;#</a>
    
</div>



        <div class="post-nav">
    <div class="post-nav-next post-nav-item">
    
        <a href="https://iihui.github.io/post/tool-vb-resize/" rel="next" title="VirtualBox 虚拟机扩容">
        <i class="fa fa-chevron-left"></i> VirtualBox 虚拟机扩容
        </a>
    
    </div>

    <div class="post-nav-prev post-nav-item">
    
        <a href="https://iihui.github.io/about/" rel="prev" title="关于我">
        关于我 <i class="fa fa-chevron-right"></i>
        </a>
    
    </div>
</div>
      
        <div class="post-nav">
    <div style="border: 1px dashed #e0e0e0; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
        <div style="float:left;margin-top:0px;">
            <img src="https://i.loli.net/2020/02/09/SvhUdz4XJsOr9Vk.jpg" width="128px" height="128px"/>
            <div style="text-align:center;">谢谢支持!</div>
        </div>
        <div>
            <p style="margin-top:10px;">
                标题：C&#43;&#43; 常见知识点
                <br />作者：阿呆<a target="_blank" href="https://iihui.github.io/"></a>
                
                <br />地址：https://iihui.github.io/post/cpp-base/
                <br />声明：自由转载-非商用-保持署名（创作共享4.0许可证）
            </p>
        </div>
    </div>
    <div class="clear"></div>
</div>
        
        
        




    </footer>
  </article>
</section>

          </div>
        </div>
        <div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>
<aside id="sidebar" class="sidebar">
  <div class="sidebar-inner">

  <ul class="sidebar-nav motion-element">
    <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
      文章目录
    </li>
    <li class="sidebar-nav-overview" data-target="site-overview">
      站点概览
    </li>
  </ul>

    <section class="site-overview sidebar-panel ">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
        src="https://i.loli.net/2020/02/07/dVFzrvZkHRNq2lL.jpg"
        alt="" />
    <p class="site-author-name" itemprop="name"></p>
    <p class="site-description motion-element" itemprop="description"> 
        coder &amp; cook</p>
</div>
      <nav class="site-state motion-element">
    <div class="site-state-item site-state-posts">
      <a href="https://iihui.github.io/post/">
        <span class="site-state-item-count">140</span>
        <span class="site-state-item-name">日志</span>
      </a>
    </div>
    <div class="site-state-item site-state-categories">    
        <a href="https://iihui.github.io/categories/">      
         
        <span class="site-state-item-count">17</span>
        
        <span class="site-state-item-name">分类</span>
        
        </a>
    </div>

    <div class="site-state-item site-state-tags">
        <a href="https://iihui.github.io/tags/">
         
        <span class="site-state-item-count">29</span>
        
        <span class="site-state-item-name">标签</span>
        </a>
    </div>
</nav>
      
      
<div class="links-of-author motion-element">
    
        <span class="links-of-author-item">
        <a href="https://coolshell.cn" target="_blank" title="皓 大">
            <i class="fa fa-fw fa-globe"></i>
            皓 大
        </a>
        </span>
    
        <span class="links-of-author-item">
        <a href="http://www.ruanyifeng.com" target="_blank" title="阮 大">
            <i class="fa fa-fw fa-globe"></i>
            阮 大
        </a>
        </span>
    
        <span class="links-of-author-item">
        <a href="https://juejin.im/" target="_blank" title="掘 金">
            <i class="fa fa-fw fa-globe"></i>
            掘 金
        </a>
        </span>
    
        <span class="links-of-author-item">
        <a href="http://www.ideamsg.com" target="_blank" title="灵 感">
            <i class="fa fa-fw fa-globe"></i>
            灵 感
        </a>
        </span>
    
</div>


      

      <div class="links-of-blogroll motion-element inline">
<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=&amp;m=0&amp;s=220&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;bv=35" async="async"></script>
</div>

    </section>
    
<section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
    <div class="post-toc">
        <div class="post-toc-content"><nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#static的作用">static的作用</a></li>
        <li><a href="#const的作用">const的作用</a></li>
        <li><a href="#c构造函数">C++构造函数</a>
          <ul>
            <li><a href="#构造函数的特点">构造函数的特点</a></li>
            <li><a href="#构造函数的作用">构造函数的作用</a></li>
            <li><a href="#构造函数的分类">构造函数的分类</a></li>
          </ul>
        </li>
        <li><a href="#mallocfree和newdelete的区别">malloc/free和new/delete的区别</a></li>
        <li><a href="#堆和栈的区别">堆和栈的区别</a></li>
        <li><a href="#c空类默认生成的成员函数">C++空类默认生成的成员函数</a></li>
        <li><a href="#delete和delete的区别">delete和delete[]的区别</a></li>
        <li><a href="#虚函数表">虚函数表</a>
          <ul>
            <li><a href="#一般继承">一般继承</a></li>
            <li><a href="#多重继承-无虚函数覆盖">多重继承-无虚函数覆盖</a></li>
            <li><a href="#多重继承-有虚函数覆盖">多重继承-有虚函数覆盖</a></li>
          </ul>
        </li>
        <li><a href="#哪些函数不能为虚函数">哪些函数不能为虚函数</a></li>
        <li><a href="#c对象布局">C++对象布局</a></li>
        <li><a href="#内存溢出">内存溢出</a></li>
        <li><a href="#内存泄漏">内存泄漏</a></li>
        <li><a href="#c中哪些操作符是不能重载的">C++中哪些操作符是不能重载的</a></li>
        <li><a href="#c强制类型转换">C++强制类型转换</a>
          <ul>
            <li><a href="#static_cast">static_cast</a></li>
            <li><a href="#const_cast">const_cast</a></li>
            <li><a href="#dynamic_cast">dynamic_cast</a></li>
            <li><a href="#reinterpret_cast">reinterpret_cast</a></li>
          </ul>
        </li>
        <li><a href="#c-中的引用">C++ 中的引用</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
    </div>
</section>

  </div>
</aside>

      </div>
    </main>
   
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  <span itemprop="copyrightYear">  &copy; 
  2017 - 2022</span>
  <span class="with-love"><i class="fa fa-heart"></i></span>
  <span class="author" itemprop="copyrightHolder">Keep It Simple</span>
</div>




      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      <span id="scrollpercent"><span>0</span>%</span>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/jquery/index.js?v=2.1.3"></script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script> 
<script type="text/javascript" src="https://iihui.github.io/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/velocity/velocity.min.js?v=1.2.1"></script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="https://iihui.github.io/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>

<script src="https://iihui.github.io/js/vendor/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>

<script type="text/javascript" src="https://iihui.github.io/js/utils.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/motion.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/affix.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/schemes/pisces.js"></script>

<script type="text/javascript" src="https://iihui.github.io/js/scrollspy.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/post-details.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/toc.js"></script>

<script type="text/javascript" src="https://iihui.github.io/js/bootstrap.js"></script>

<script type="text/javascript" src="https://iihui.github.io/js/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
</body>
</html>