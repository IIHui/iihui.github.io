<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Keep It Simple</title>
    <link>https://iihui.github.io/post/</link>
    <description>Recent content in Posts on Keep It Simple</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Fri, 05 Jan 2024 11:40:32 +0000</lastBuildDate><atom:link href="https://iihui.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Hugo Next 主题</title>
      <link>https://iihui.github.io/post/hugo-next/</link>
      <pubDate>Fri, 07 Feb 2020 11:27:41 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/hugo-next/</guid>
      <description>从兰陵子处下载了Next主题，修改了主题目录下的config.toml配置文件(配置文件路径为themes/next/config.toml)。但发现有很多地方还是需要修改才能满足自己的需求，对前端了解较少，以此为记。 修改主题 首先从这里下载</description>
    </item>
    
    <item>
      <title>一些问题的解决方案2021</title>
      <link>https://iihui.github.io/post/ios-solutions-2021/</link>
      <pubDate>Fri, 16 Jul 2021 17:34:07 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-solutions-2021/</guid>
      <description>在开发过程中，会遇到各种问题，有时候某个问题当时已经找到了解决方案，但过了一段时间又可能会忘记。这篇文章记录一些问题的解决方案，以便后续查找。 强制竖屏 最近使用其它SDK，业务方要求打开某个页面时强制竖屏，按对方要求传了相应参数未生效，依然能</description>
    </item>
    
    <item>
      <title>一些问题的解决方案2022</title>
      <link>https://iihui.github.io/post/ios-solutions-2022/</link>
      <pubDate>Fri, 21 Oct 2022 23:09:49 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-solutions-2022/</guid>
      <description>Missing Package Product 在github上拉取了uPic工程源代码，编译时出现了包缺失的错误(Missing Package Product)，具体报错信息如下图所示： 参考这个解决方案，首先打开工程，然后在菜单栏的File--&amp;gt;Packages--&amp;gt;Reset Pa</description>
    </item>
    
    <item>
      <title>一些问题的解决方案2023</title>
      <link>https://iihui.github.io/post/ios-solutions-2023/</link>
      <pubDate>Thu, 12 Jan 2023 12:34:07 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-solutions-2023/</guid>
      <description>开启高版本调试 在macOS中调试使用WKWebViewj加载的网页，发现即使在真机上的Safari浏览器上开启了网页检测器（设置&amp;ndash;&amp;gt;高级&amp;ndash;&amp;gt;网页检测器）也无法调试，需要开启iOS 16.4及以上系统WKWe</description>
    </item>
    
    <item>
      <title>ArkTs</title>
      <link>https://iihui.github.io/post/arkts-base/</link>
      <pubDate>Fri, 05 Jan 2024 11:40:32 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/arkts-base/</guid>
      <description>基本知识 类型 ArkTS是一种静态类型语言，所有数据的类型都必须在编译时确定，但如果一个变量或常量的声明包含了初始值，那么开发者就不需要显式指定其类型。 void类型 类型void只有一个值，也是void。void类型用于指定函数没有返回值，不能</description>
    </item>
    
    <item>
      <title>Ruby基础</title>
      <link>https://iihui.github.io/post/ruby/</link>
      <pubDate>Sun, 14 Aug 2022 23:12:38 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ruby/</guid>
      <description>Ruby是数百种编程语言中之一，但它很特别，对许多程序员来说，它很像一种自然语言（会让人感觉出奇地像英语），同时又具有计算机所要求的清晰性。例如，如果运行下面的代码，将会打印Hello, world!字符串10次。 10.times do print &amp;#34;Hello, world!&amp;#34; end 在irb中，上面</description>
    </item>
    
    <item>
      <title>Parallels Desktop 使用</title>
      <link>https://iihui.github.io/post/tool-parallel/</link>
      <pubDate>Fri, 04 Mar 2022 23:00:51 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/tool-parallel/</guid>
      <description>安装Windows 使用Parallels Desktop 17.1.1安装Windows 10虚拟机时出现报错信息：NetWork initialization failed. Your virtual machine will contine working normally but will have no network connection.，如下图所示： 参考这篇文章，此时需要以管理员身份修改/Library/Pref</description>
    </item>
    
    <item>
      <title>Rider 使用</title>
      <link>https://iihui.github.io/post/tool-rider/</link>
      <pubDate>Thu, 03 Mar 2022 08:42:04 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/tool-rider/</guid>
      <description>在CrossOver上安装 在Mac上使用CrossOver可以安装Windows软件，正常来说应该也可以利用CrossOver安装Windows版的Rider。因为Rider 2021.3.3只支持64位系统，如果想要在CrossOver中安</description>
    </item>
    
    <item>
      <title>TypeScript基础</title>
      <link>https://iihui.github.io/post/ts-base/</link>
      <pubDate>Thu, 27 Jan 2022 22:53:20 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ts-base/</guid>
      <description>TypeScript的7种基本类型为： null undefined boolean string number bigint symbol 若声明变量时不显式标注类型，编译器会推断该变量的类型为any，表示该变量可以被赋为任何类型的值。如果声明变量时既不标注类型也不初始化，接着立即使用typeof得到的结果为undefined</description>
    </item>
    
    <item>
      <title>iOS 14 编程基础</title>
      <link>https://iihui.github.io/post/ios-fundamentals/</link>
      <pubDate>Sat, 28 Aug 2021 19:45:24 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-fundamentals/</guid>
      <description>Object 在Swift中，万物皆为对象，这是什么意思呢？这取决于我们所说的「对象」是什么，以及所说的「万物」是指什么。简单地说，对象就是可以向其发送消息的东西，而消息指的是一个命令式指令。在Swift中，发送消息的语法是点表示法：以对象开始，然后紧</description>
    </item>
    
    <item>
      <title>Swift协议</title>
      <link>https://iihui.github.io/post/ios-protocol/</link>
      <pubDate>Sat, 07 Aug 2021 12:24:59 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-protocol/</guid>
      <description>2015年苹果声称Swift是第一个面向协议的编程语言。从它的名字来看，很可能会认为面向协议编程都是关于协议的，但这是不正确的。面向协议的编程所涉及的不仅仅是协议，它实际上是一种新的方式，不仅是编写应用程序，而且是我们如何思考应用程序的设计</description>
    </item>
    
    <item>
      <title>KingFisher 使用</title>
      <link>https://iihui.github.io/post/ios-kingfisher/</link>
      <pubDate>Fri, 30 Jul 2021 16:33:01 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-kingfisher/</guid>
      <description>最近App联系人头像改成了url的形式，不再使用带大堆信息的post请求。因为头像涉及到缓存和更新机制，因此需要使用KingFisher组件。 设置图片 如果想要设置UIImageView的图片，则可以使用KingFisher的扩展方法xxx.</description>
    </item>
    
    <item>
      <title>使用Leaks内存检测</title>
      <link>https://iihui.github.io/post/ios-leaks/</link>
      <pubDate>Fri, 09 Jul 2021 21:55:28 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-leaks/</guid>
      <description>最近有用户反馈App出现了闪退现象，但后台并未发现有崩溃日志上传，猜测发生了内存溢出，导致App直接被系统杀掉而没有崩溃日志产生。为了验证此猜测，需要使用XCode的Leaks工具，这篇文章简单介绍使用Leaks的步骤。 Setting 首先在XCode的</description>
    </item>
    
    <item>
      <title>视图</title>
      <link>https://iihui.github.io/post/ios-views/</link>
      <pubDate>Fri, 28 May 2021 23:17:52 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-views/</guid>
      <description>视图view的层次结构是其组织的主要模式。一个视图可以有多个子视图，但只能有一个直接父视图。若一个视图被从界面中被移除，则它的子视图也会被移除；若一个视图被隐藏，则它的子视图都会被隐藏；如果一个视图被移动，它的子视图也都会随之移动。也就是说</description>
    </item>
    
    <item>
      <title>Swift 5.3 新特性</title>
      <link>https://iihui.github.io/post/swift-5.3/</link>
      <pubDate>Sat, 08 May 2021 08:52:46 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/swift-5.3/</guid>
      <description>Swift 5.3引入了很多新特性，包括多尾闭包、多模式catch、枚举比较、闭包中self省略以及Swift Package Manager等一些重要改变。 多尾闭包 以前 在Swift 5.3前尾闭包提供了精简写法，但仅限于函数最后一个参数为函数闭包。当一个函数有多个函</description>
    </item>
    
    <item>
      <title>Swift 5.2 新特性</title>
      <link>https://iihui.github.io/post/swift-5.2/</link>
      <pubDate>Thu, 06 May 2021 23:01:46 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/swift-5.2/</guid>
      <description>Swift 5.2于2020.03.24发布，新增了许多特性。新版本专注于改善开发体验并增加了一些新功能，新功能大部分以增强函数式编程风格为导向。 KeyPath 在Swift 5.2中允许使用key path表达式替代key path函数。下面代码中，使用了cars.f</description>
    </item>
    
    <item>
      <title>Xcode编译报错问题</title>
      <link>https://iihui.github.io/post/ios-compiler/</link>
      <pubDate>Wed, 05 May 2021 10:06:46 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-compiler/</guid>
      <description>xxx-Swift.h未找到 如果报xxx-Swift.h未找到，则需要检查设置中的Swift Compiler - General下的Objective-C Generated Interface Header Name是否有对应的文件： iOS 14.5.1编译报错 使用XCode 12.4在iOS 14.5.1的真机上</description>
    </item>
    
    <item>
      <title>Swift 基础</title>
      <link>https://iihui.github.io/post/swift-base/</link>
      <pubDate>Sun, 02 May 2021 09:06:07 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/swift-base/</guid>
      <description>语句 一个Swift文件包含多行文本。换行对于Swift来说是有意义的，代表一条语句的结束，因此Swift中一般一行只写一条语句。如果需要在一行中写多条语句，则需要分号隔开，但不推荐这样做。 print(&amp;#34;hello&amp;#34;) print(&amp;#34;world&amp;#34;) print(&amp;#34;hello&amp;#34;); print(&amp;#34;world&amp;#34;) 常量和变量 Swift的常量或者变量使用前必须</description>
    </item>
    
    <item>
      <title>UISearchController</title>
      <link>https://iihui.github.io/post/ios-uisearchcontroller/</link>
      <pubDate>Sun, 25 Apr 2021 11:44:21 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-uisearchcontroller/</guid>
      <description>苹果 解决 // 先override viewDidLayoutSubviews方法 override func viewDidLayoutSubviews() { super.viewDidLayoutSubviews() super.setNavigationBarHidden(true, animated: false) } // 然后再push的时候关闭动画 from.navigationController?.pushViewController(vc, animated: true)</description>
    </item>
    
    <item>
      <title>Moya</title>
      <link>https://iihui.github.io/post/ios-moya/</link>
      <pubDate>Fri, 16 Apr 2021 10:49:11 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-moya/</guid>
      <description>Moya是一个高度抽象的网络库，它的目标是让使用者不必关心网络请求的底层实现细节，只需要关注业务。Moya采用桥接和组合来进行封装，默认桥接了Alamofire。Moya具有很强的扩展性，可以轻松地将RxSwift、PromiseKit和O</description>
    </item>
    
    <item>
      <title>MDM</title>
      <link>https://iihui.github.io/post/tool-mdm/</link>
      <pubDate>Thu, 15 Apr 2021 22:10:22 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/tool-mdm/</guid>
      <description>MDM是Moblie Device Management移动设备管理的简称，目的就是让企业能够方便的管理iPhone和Pad等移动设备。当企业大量的使用移动设备办公或涉及到一些安全限制时设备管理的作用就能明显的体现出来，通过MDM，IT人员能够在企业环境</description>
    </item>
    
    <item>
      <title>iOS PWA</title>
      <link>https://iihui.github.io/post/ios-pwa/</link>
      <pubDate>Mon, 12 Apr 2021 12:02:24 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-pwa/</guid>
      <description>PWA PWA（Progressive web apps）译为渐进式Web应用，指的是运用现代的Web API以及传统的渐进式增强策略来创建跨平台Web应用程序。PWA没有统一的定义，可以理解为使用Web技术来创建App，不用打包，不用签名，可以离线工作，</description>
    </item>
    
    <item>
      <title>SwiftUI</title>
      <link>https://iihui.github.io/post/swiftui/</link>
      <pubDate>Fri, 02 Apr 2021 15:54:22 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/swiftui/</guid>
      <description>Chapter 1 单个词的变量名可能很好，但有时希望使用多个单词来使变量或常量名有更好的可读性。当组合多个单词形成变量或常量名时，通常使用camelCase命名法： var ageOfPet: Int = 8 var weightInKilograms: Double = 13.48 var directionToTurn: String = &amp;#34;Right&amp;#34; 除了将相关项目进行物理分组，如函数和变量分别放在一起，也可以</description>
    </item>
    
    <item>
      <title></title>
      <link>https://iihui.github.io/post/ios-async/</link>
      <pubDate>Thu, 01 Apr 2021 10:09:29 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-async/</guid>
      <description>第1本 asyn &amp;amp; await 方法定义中的async关键字让编译器知道代码是在一个异步上下文中运行。换句话说，它表示代码可以随意暂停和恢复。另外，无论该方法需要多长时间完成，它最终都会像同步方法一样返回一个值。 func availableSymbols() async throws -&amp;gt; [String] { guard let url = URL(string: &amp;#34;http://localhost:8080/littlejohn/symbols&amp;#34;) else { throw &amp;#34;The URL could not be created.&amp;#34; } }</description>
    </item>
    
    <item>
      <title>Programming for Beginners</title>
      <link>https://iihui.github.io/post/ios-beginner/</link>
      <pubDate>Fri, 26 Mar 2021 19:01:33 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-beginner/</guid>
      <description>Xcode界面 工具栏：用于构建和运行应用程序，以及查看运行任务的进度。 导航区：提供对项目各个部分的快速访问，默认情况下会显示项目导航器。 编辑器区：允许编辑源代码、用户界面和其他资源。 检查器区：允许查看和编辑在导航器区域或编辑器区域中选择的项</description>
    </item>
    
    <item>
      <title>AES 实现</title>
      <link>https://iihui.github.io/post/ios-aes/</link>
      <pubDate>Wed, 17 Mar 2021 17:24:04 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-aes/</guid>
      <description>高级加密标准(AES,Advanced Encryption Standard)，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用是最常见的对称加密算法，它是一种对称加密算法（对称加密是指加密和解密使用相同的密</description>
    </item>
    
    <item>
      <title>Cookie简介</title>
      <link>https://iihui.github.io/post/cookie/</link>
      <pubDate>Sat, 20 Feb 2021 19:05:10 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/cookie/</guid>
      <description>简介 标准的http协议是无状态的，即服务端对于客户端的每次请求都认为它是一个新的请求，上一次的会话和下一次的会话之间没有任何联系。当用户访问服务端并进行登录后，之后的客户端请求服务端依然无法对其身份进行识别。如果将客户端与服务器之间的多次交</description>
    </item>
    
    <item>
      <title>Java 基础</title>
      <link>https://iihui.github.io/post/java-base/</link>
      <pubDate>Fri, 12 Feb 2021 17:27:42 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/java-base/</guid>
      <description>数据类型 在Java中数据分为两大类，一类是基本数据类型primitive types，另一类是引用类型reference types。基本类型所占的内存大小是固定的，在内存中存放的是数据值本身。引用类型在内存中存放的是指向该数据的地址，不是数值</description>
    </item>
    
    <item>
      <title>鼠须管配置</title>
      <link>https://iihui.github.io/post/tool-squirrel/</link>
      <pubDate>Fri, 12 Feb 2021 08:25:42 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/tool-squirrel/</guid>
      <description>鼠须管是macOS上一款高度可定制的输入法软件，它当前没有自带图形设置界面，需通过修改yaml配置文件来实现设置变更。这篇文章记录折腾鼠须管0.15.1版本时遇到的一些问题和解决方案，并且只在0.15.1上验证过有效性。 横排显示 鼠须管默认是</description>
    </item>
    
    <item>
      <title>UIView 使用</title>
      <link>https://iihui.github.io/post/ios-uiview/</link>
      <pubDate>Sun, 07 Feb 2021 12:53:06 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-uiview/</guid>
      <description>layoutIfNeeded与setNeedsLayout setNeedsLayout setNeedsLayout当需要调整UIView子视图布局时，需要在主线程调用此方法。此方法记录调整布局请求并立即返回「即异步执行」，等待下一个更新周期更新视图。也就是说，这个方</description>
    </item>
    
    <item>
      <title>PromiseKit使用</title>
      <link>https://iihui.github.io/post/ios-promisekit/</link>
      <pubDate>Wed, 03 Feb 2021 10:33:04 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-promisekit/</guid>
      <description>PromiseKit是简化异步编程的一种非必要方式，使用它可以提高代码的可读性和维护性，让代码更加优雅，它主要用于解决回调地狱问题。 回调地狱 为了保证异步代码按顺序执行，通常将异步代码嵌套在回调函数中。如果异步方法过多，就会产生过多回调，一层</description>
    </item>
    
    <item>
      <title>Ruby 基础</title>
      <link>https://iihui.github.io/post/ruby-base/</link>
      <pubDate>Tue, 12 Jan 2021 08:28:26 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ruby-base/</guid>
      <description>最近做组件的源码和二进制切换时遇到一些问题，在查资料时发现了cocoapods-imy-bin这个插件，打算以这个插件为基础进行改造，写一个适合自己业务场景的插件。但之前未接触ruby和cocoapods插件开发，这篇文章是一点学习笔记，方</description>
    </item>
    
    <item>
      <title>属性包装</title>
      <link>https://iihui.github.io/post/ios-propertywrapper/</link>
      <pubDate>Fri, 08 Jan 2021 18:19:29 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-propertywrapper/</guid>
      <description>属性包装器propertyWrapper的作用对象是属性，它的思想是只可以通过wrappedValue的get和set方法来访问属性，这样就可以通过get和set方法来对属性进行包装，提供特定功能的属性。属性包装器是一种通用结构，它封装了w</description>
    </item>
    
    <item>
      <title>调试</title>
      <link>https://iihui.github.io/post/ios-debug/</link>
      <pubDate>Mon, 04 Jan 2021 14:15:45 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-debug/</guid>
      <description>LLDB LLDB是一个庞大的工具,内置了许多有用的命令。 命令语法结构 &amp;lt;command&amp;gt; [&amp;lt;subcommand&amp;gt; [&amp;lt;subcommand&amp;gt;...]] &amp;lt;action&amp;gt; [-options [option-value]] [argument [argument...]] 其中： command和subcommand为LLDB调试命令的名称，命令和子命令按照层级结构来排列：一个命令对象为跟随其的子命令对象创建一个上下文，子命令又为其子</description>
    </item>
    
    <item>
      <title>KSCrash</title>
      <link>https://iihui.github.io/post/ios-kscrash/</link>
      <pubDate>Sat, 26 Dec 2020 17:33:11 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-kscrash/</guid>
      <description>KSCrash是崩溃日志收集框架，总共分为三个部分，Crash Recording，Crash Reporting以及Installation。其中Installation用来启动KSCrash，并且指定Crash收集方式。Crash收集方式包</description>
    </item>
    
    <item>
      <title>Shell 常用命令</title>
      <link>https://iihui.github.io/post/shell-base/</link>
      <pubDate>Sun, 29 Nov 2020 10:50:55 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/shell-base/</guid>
      <description>本文记录工作中用的shell命令，以便下次使用的时候查阅。 软链接 创建 ln ~/.cocoapods/repos-art/CocoaPods-cmb ~/.cocoapods/repos 删除 unlink cocoaPods-github</description>
    </item>
    
    <item>
      <title>Python 基础</title>
      <link>https://iihui.github.io/post/python-base/</link>
      <pubDate>Mon, 23 Nov 2020 23:36:18 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/python-base/</guid>
      <description>字符串 在python中，用引号括起来的都是字符串，其中的引号可以是单引号，也可以是双引号。这种灵活性让我们能够在字符串中包含引号或单引号： print(&amp;#39;This is a string&amp;#39;) print(&amp;#34;This is also a string&amp;#34;) print(&amp;#39;I told my friend, &amp;#34;python is my favorite language&amp;#34;&amp;#39;) print(&amp;#34;The language &amp;#39;Python&amp;#39; is named after Monty Python, not the snake&amp;#34;) This is a string This is also a string I told my friend, &amp;#34;python is my favorite language&amp;#34; The language &amp;#39;Python&amp;#39; is</description>
    </item>
    
    <item>
      <title>Swift Tips</title>
      <link>https://iihui.github.io/post/swift-tips/</link>
      <pubDate>Thu, 12 Nov 2020 08:27:33 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/swift-tips/</guid>
      <description>柯里化 柯里化(curry)：把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下参数而且返回结果的新函数。 func addTo(_ adder: Int) -&amp;gt; (Int) -&amp;gt; Int { return { num in return num + adder } } let addTwo = addTo(2) // addTwo: Int -&amp;gt; Int let result = addTwo(6) // result = 8 柯⾥化是⼀种量产相似⽅法</description>
    </item>
    
    <item>
      <title>Kotlin基础</title>
      <link>https://iihui.github.io/post/kotlin-base/</link>
      <pubDate>Tue, 10 Nov 2020 08:07:17 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/kotlin-base/</guid>
      <description>变量和函数 常量 Kotlin中使用val来声明常量「val是value的缩写」，val声明的常量不可以再重新赋值，否则会报错。val对应Java中的final。 val str = &amp;#34;Hello world&amp;#34; 变量 Kotlin中使用var来声明变量「var是variable的缩写」</description>
    </item>
    
    <item>
      <title>使用charles</title>
      <link>https://iihui.github.io/post/tool-charles/</link>
      <pubDate>Fri, 18 Sep 2020 10:09:24 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/tool-charles/</guid>
      <description>charles是一款用于iOS抓包的工具，可以将它设置成网络访问的代理服务器，使得所有网络访问请求都通过它来完成，从而实现网络封包的截取和分析，以作为网络访问的监视器。当App连接charles代理访问互联网时，charles可以监控这个A</description>
    </item>
    
    <item>
      <title>刘海屏适配</title>
      <link>https://iihui.github.io/post/ios-layout/</link>
      <pubDate>Mon, 17 Aug 2020 08:00:07 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-layout/</guid>
      <description>自从苹果推出刘海屏之后，App开发就要做相应的适配，适配过程通常会用到topLayoutGuide和bottomLayoutGuide或者safeAreaLayoutGuide。topLayoutGuide和bottomLayoutGuid</description>
    </item>
    
    <item>
      <title>UITabBarController</title>
      <link>https://iihui.github.io/post/ios-uitabbar/</link>
      <pubDate>Sun, 02 Aug 2020 21:04:47 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-uitabbar/</guid>
      <description>添加Tab 既可以直接添加UITabBarController到storyboard中，也可以在现有的ViewController中添加UITabBarController。 直接添加 如下图所示，在Xcode 12右上角点击+号，然后输入Tab，</description>
    </item>
    
    <item>
      <title>Go枚举</title>
      <link>https://iihui.github.io/post/go-iota/</link>
      <pubDate>Sat, 01 Aug 2020 20:19:22 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/go-iota/</guid>
      <description>Go中没明确意义上的enum定义，但是可以借助iota来生成一组自增常量值来实现枚举，iota是一个比较奇怪的存在，它只能用在const的声明中，是一个从0开始的行数索引器。 iota 按行递增 首先，iota是一个行数索引器,它是按行递增的。 const ( x1 =</description>
    </item>
    
    <item>
      <title>Go常量</title>
      <link>https://iihui.github.io/post/go-let/</link>
      <pubDate>Sat, 01 Aug 2020 18:02:05 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/go-let/</guid>
      <description>常量值必须是编译期间可确定的字符、字符串、数字或者布尔值。常量的类型可以指定，或者由编译器通过初始化值推断，不支持C或者C++数字类型后缀。可在函数代码块中定义常量，不使用的常量不会引发编译错误。 const x, y int = 12, 0x12 const s = &amp;#34;hello world&amp;#34; const c = &amp;#39;我&amp;</description>
    </item>
    
    <item>
      <title>Go变量</title>
      <link>https://iihui.github.io/post/go-var/</link>
      <pubDate>Sat, 01 Aug 2020 16:05:43 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/go-var/</guid>
      <description>Go中每一个文件都以package声明开头，表明文件属于哪一个包。package声明后面是import声明，然后是不区分顺序的包级别的类型，变量、常量和函数的声明。对于包级别的声明不仅对于包含其声明的源文件可见，而且对于同一包里面的所有的源</description>
    </item>
    
    <item>
      <title>snapkit 使用</title>
      <link>https://iihui.github.io/post/ios-snapkit/</link>
      <pubDate>Fri, 31 Jul 2020 10:10:07 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-snapkit/</guid>
      <description>inset和offset 在描述view与superview关系时，应该使用inset，而描述view与同一层级的其它view时，应该使用offset。 使用offset来设置距离子控件相对于父控件边距时，对于右边和下方的约束都需要加-号。这和</description>
    </item>
    
    <item>
      <title>富文本</title>
      <link>https://iihui.github.io/post/ios-richtext/</link>
      <pubDate>Wed, 29 Jul 2020 18:59:27 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-richtext/</guid>
      <description>在文字后面添加红点 /// 使用富文本的方式在UILabel文本后面添加红点 /// - Parameter add: isNeedAdd 为true表示要加红点，否则不需要 /// - Returns: 处理后的富文本 func addRedDot(isNeedAdd: Bool) -&amp;gt; NSMutableAttributedString { var text: String = (self.text ?? &amp;#34;&amp;#34;) if isNeedAdd { text += &amp;#34; &amp;#34; let contentText = NSMutableAttributedString(string: text) let attach = NSTextAttachment() let dotImg = UIImage(named: &amp;#34;reddot&amp;#34;) let width: CGFloat = 10 attach.bounds = CGRect(x: 0, y: 0.5, width: width, height: width) attach.image = dotImg let attrText</description>
    </item>
    
    <item>
      <title>Live JavaScript debug</title>
      <link>https://iihui.github.io/post/safari-debug/</link>
      <pubDate>Tue, 07 Jul 2020 23:32:47 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/safari-debug/</guid>
      <description>从2020年4月开始，Safari支持Live JavaScript debug，使得在使用safari调试时可以使用本地文件覆盖从服务端下载的资源文件。Safari浏览器支持3种方式创建本地覆盖。 创建本地覆盖 第一种 首先选中某个文件，然后点击右上角创建覆盖的图标</description>
    </item>
    
    <item>
      <title></title>
      <link>https://iihui.github.io/post/ios-customizeuiview/</link>
      <pubDate>Fri, 03 Jul 2020 16:54:07 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-customizeuiview/</guid>
      <description>class RecommendView: UIView { @IBOutlet weak var imageView: UIImageView! @IBOutlet weak var subTitleLbl: UILabel! @IBOutlet weak var titleLbl: UILabel! @IBOutlet var contentView: UIView! override init(frame: CGRect) { //每一步都必须实现父初始化 super.init(frame: frame) contentView = loadViewFromNib() contentView.frame = bounds addSubview(contentView) } //可视化IB初始化调用 required init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder) contentView = loadViewFromNib() contentView.frame = bounds addSubview(contentView) } //MARK：自定义方法 func loadViewFromNib() -&amp;gt; UIView { let nib = UINib(nibName: String(describing: RecommendView.self), bundle: Bundle(for: RecommendView.self)) let view = nib.instantiate(withOwner: self, options: nil)[0] as! UIView return view } } 参考资</description>
    </item>
    
    <item>
      <title>Swift 范型</title>
      <link>https://iihui.github.io/post/swift-generirs/</link>
      <pubDate>Tue, 30 Jun 2020 08:58:17 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/swift-generirs/</guid>
      <description>范型类型 Swift允许自定义的范型类型包括类、结构体、枚举类型。 struct Stack { var items = [Int]() mutating func push(_ item:Int){ items.append(item) } mutating func pop(_ item:Int) -&amp;gt; Int { return items.removeLast() } } //调用 var stack_int = Stack() stack_int.push(7) stack_int.push(3) stack_int.push(2) print(stack_int)//Stack(items: [7, 3, 2]) 类型约束 范型函数和范型类型虽然可以和任何类型一起使用，但有时需要限制使用的类型，此时就需要使用类型</description>
    </item>
    
    <item>
      <title>Swift中defer</title>
      <link>https://iihui.github.io/post/swift-defer/</link>
      <pubDate>Sun, 28 Jun 2020 09:25:49 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/swift-defer/</guid>
      <description>从语言设计上来说，defer是为了进行资源清理和返回前避免重复执行相关代码。它不是用来取巧实现某些功能，如果这样做只会让代码的可读性降低。 典型用法 Swift中defer声明的block会在当前代码块执行退出后调用。这种延迟调用特性，一般用来</description>
    </item>
    
    <item>
      <title>屏幕旋转</title>
      <link>https://iihui.github.io/post/ios-rotate/</link>
      <pubDate>Mon, 08 Jun 2020 20:07:26 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-rotate/</guid>
      <description>iOS开发时经常会遇到要将某些界面强制竖屏或者横屏。要做到某个页面能强制横竖屏的前提是允许屏幕旋转，然后再在具体的界面强制横竖屏。但是要区分这个具体的界面时push还是present呈现的。 全局允许横竖屏 第一种方式，是在Target中的Ge</description>
    </item>
    
    <item>
      <title>WCDB</title>
      <link>https://iihui.github.io/post/ios-wcdb/</link>
      <pubDate>Mon, 25 May 2020 23:18:53 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-wcdb/</guid>
      <description>自定义类型入库 自定义类型要遵循ColumnCodable才能入库： enum UserOrgType: String, ColumnCodable { case CMB = &amp;#34;CMB&amp;#34; case ODC = &amp;#34;3&amp;#34; static var columnType: ColumnType = .text init(with value: FundamentalValue) { self = UserOrgType(rawValue: value.stringValue) ?? UserOrgType.CMB } func archivedValue() -&amp;gt; FundamentalValue { return FundamentalValue(self.rawValue) } } /// 查看用户表是否为空 func isEmpty() -&amp;gt; Bool { do { let count = try DBManager_V2.shared.userDb.getValue(on: UserInfoModel_V2.CodingKeys.openId.count(), fromTable: tableName).int64Value return count == 0 } catch let error { printError(msg: error.localizedDescription, type: .db) return true } }</description>
    </item>
    
    <item>
      <title>UIAlertViewController</title>
      <link>https://iihui.github.io/post/ios-alertviewcontroller/</link>
      <pubDate>Mon, 20 Apr 2020 22:58:33 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-alertviewcontroller/</guid>
      <description>最近使用UIAlertViewController时，需要定制其背景颜色，在网上找到一个解决方案，基本思路是为UIAlertViewController设置一个计算属性，这个属性改变时即将UIAlertViewController的背景色修</description>
    </item>
    
    <item>
      <title>linux 命令大全</title>
      <link>https://iihui.github.io/post/linux-base/</link>
      <pubDate>Sat, 18 Apr 2020 22:23:57 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/linux-base/</guid>
      <description>这篇笔记是学习Linux命令大全的读书笔记，用于记录那些个人认为有用的命令，供后续查询。 shell 是什么 df df命令用于磁盘驱动器当前的可用空间 free free命令可以显示可用内存</description>
    </item>
    
    <item>
      <title>vim 学习</title>
      <link>https://iihui.github.io/post/tool-vim/</link>
      <pubDate>Sat, 18 Apr 2020 21:18:10 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/tool-vim/</guid>
      <description>配置文件 vim从一个名为.vimrc（在类Unix系统中，以.开头的文件为隐藏文件，为了看到这些文件，可以运行ls -a命令行）的文件中读取配置信息。 syntax on &amp;#34;支持语法高亮显示 filetype plugin indent on &amp;#34;启用根据文件类型缩进 set autoindent &amp;#34;开启新行时</description>
    </item>
    
    <item>
      <title>Mach-O 文件</title>
      <link>https://iihui.github.io/post/ios-macho/</link>
      <pubDate>Wed, 01 Apr 2020 08:09:20 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-macho/</guid>
      <description>Mach-O为Mach Object文件格式的缩写，它是一种用于可执行文件、目标代码、动态库的文件格式。 文件类型 常见的MachO文件有下面这些，可以通过file+文件路径来查看文件的类型信息： 目标文件.o 库文件.a | .dylib | xxx.framework/xxx 可执行文件 符号表文件</description>
    </item>
    
    <item>
      <title>创建私有库</title>
      <link>https://iihui.github.io/post/ios-private-pods/</link>
      <pubDate>Tue, 31 Mar 2020 19:52:58 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-private-pods/</guid>
      <description>使用cocoapods可以创建远程私有库，供项目使用。首先需要在github上创建一个远程索引库，然后使用cocopods在本地创建文件夹，并与远程私有库进行关联。再在github上创建远程组件库，接着使用pod创建本地工程，然后修改组件库</description>
    </item>
    
    <item>
      <title>指定Podfile中source</title>
      <link>https://iihui.github.io/post/ios-pods-question/</link>
      <pubDate>Tue, 31 Mar 2020 08:08:00 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-pods-question/</guid>
      <description>在笔记本上安装好Cocoapods之后，执行pod install后报trunk repo update failed，解决方案是在Podfile中指定另一个源仓库。 报错信息 解决方案 解决方案是在Podfile中指定source，如下所示： platform :ios, &amp;#39;8.0&amp;#39; source &amp;#39;https://github.com/CocoaPods/Specs.git&amp;#39; use_frameworks! target &amp;#39;NewWCDB&amp;#39; do pod &amp;#39;WCDB.swift&amp;#39; end 如</description>
    </item>
    
    <item>
      <title>AutoLayout</title>
      <link>https://iihui.github.io/post/ios-autolayout/</link>
      <pubDate>Wed, 25 Mar 2020 11:52:16 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-autolayout/</guid>
      <description>苹果公司推出的AutoLayout是一个基于约束，动态计算视图大小和位置的库。它以布局引擎系统Layout Engine为核心，采用了Cassowary布局算法，在简化布局思路的同时，还保证了布局的高效性。布局算法Cassowary能够有效解</description>
    </item>
    
    <item>
      <title>不常见的关键字</title>
      <link>https://iihui.github.io/post/ios-keywords/</link>
      <pubDate>Wed, 25 Mar 2020 10:22:29 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-keywords/</guid>
      <description>使用Swift写代码时，经常会遇到一些不常见的关键词或者常用关键词的特殊使用场景，因为比较少使用，通常这些不常见的关键词或者特殊场景很容易忘记。 便利构造函数 关键字convenience用于初始化器（构造函数）中，称之为便利初始化器（构造函数</description>
    </item>
    
    <item>
      <title>Keyboard Maestro 使用</title>
      <link>https://iihui.github.io/post/tool-maestro/</link>
      <pubDate>Tue, 24 Mar 2020 11:28:02 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/tool-maestro/</guid>
      <description>Keyboard Maestro是一款神奇的软件，在我心里它与Alfred同样重要，也是装机必备软件。使用它可以省去安装很多软件，这篇文章记录平常工作中使用它的一些特性或技巧，以便后续查阅。 快捷输入 粘贴方式输入 模拟键盘输入 打开应用 可以设置全局快捷键打开某个</description>
    </item>
    
    <item>
      <title>git 使用</title>
      <link>https://iihui.github.io/post/tool-git/</link>
      <pubDate>Tue, 24 Mar 2020 09:36:27 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/tool-git/</guid>
      <description>清理文件 如果本地.git文件太大，可以使用git gc命令清理不必要的文件并优化本地存储库。gc是garbage collection的缩写: git gc [--aggressive] [--auto] [--quiet] [--prune=&amp;lt;date&amp;gt; | --no-prune] [--force] [--keep-largest-pack] 大小写敏感 默认情况下git追踪的项目对文件名大小写是不敏感的，但是git提供了命令</description>
    </item>
    
    <item>
      <title>CLion 添加Google test</title>
      <link>https://iihui.github.io/post/clion-test/</link>
      <pubDate>Fri, 06 Mar 2020 18:00:27 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/clion-test/</guid>
      <description>首先在github下载最新的googletest，解压之后重命名为googletest。然后将其放入到CLion工程目录下，接着修改工程的CMakeList.txt文件。最后，修改main函数，编写单元测试用例。 下载 在github下载最新的</description>
    </item>
    
    <item>
      <title>where 关键字</title>
      <link>https://iihui.github.io/post/ios-where/</link>
      <pubDate>Sat, 22 Feb 2020 20:49:20 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-where/</guid>
      <description>Swift中的where关键字主要用于限定条件，既可在switch语句中使用，也可以在for中使用，还可以用在扩展中用于限定应该遵循某种协议。 Usage in a switch 在switch语句中使用，关键字where一般是配合case let一起用于限定条件： let names =</description>
    </item>
    
    <item>
      <title>Swift 方法交换中的addMethod</title>
      <link>https://iihui.github.io/post/ios-addmethod/</link>
      <pubDate>Fri, 21 Feb 2020 10:18:17 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-addmethod/</guid>
      <description>Swizzle是OC的黑魔法之一，可以在运行时对两个方法的实现进行交换，也就是s用户可以用自己的方法替换原来的方法实现，做一些其它事情。Swift也可以使用运行时的方法交换，如果要了解Swift的方法交换，首先应该了解class_addMe</description>
    </item>
    
    <item>
      <title>Any,AnyObject,AnyClass</title>
      <link>https://iihui.github.io/post/ios-any/</link>
      <pubDate>Tue, 18 Feb 2020 21:14:39 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-any/</guid>
      <description>最近在看Swift中的方法交换，遇到Any、AnyObject与AnyClass次数较多，所以在网上找了一些文章看了一下他们的区别，以此篇为记。 AnyObject AnyObject类似于OC中的id类型，表示任意的class类型。但在Swift中由于Str</description>
    </item>
    
    <item>
      <title>UIControl</title>
      <link>https://iihui.github.io/post/ios-uicontrol/</link>
      <pubDate>Fri, 14 Feb 2020 20:53:50 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-uicontrol/</guid>
      <description>UIControl是UIView的子类，也是UIResponder的子类。是UIButton，UISwitch，UITextField等控件的父类。它本身定义了一些属性和方法，但是不能直接使用。 方法交换 extension UIControl { class func swizzleMethod() { struct Static { static var token = NSUUID().uuidString } // 确保</description>
    </item>
    
    <item>
      <title>Swift 中的反射</title>
      <link>https://iihui.github.io/post/ios-reflection/</link>
      <pubDate>Fri, 14 Feb 2020 17:19:38 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-reflection/</guid>
      <description>reflection是指计算机程序在runtime时可以访问、检测和修改它本身状态或行为的一种能力。比较形象的说法就是，反射是程序在运行的时候能够观察并且修改自己的行为。 @objc Swift是一门静态语言，和OC不同，不能在运行时做很多复杂的操作。</description>
    </item>
    
    <item>
      <title>KVC 键值编码</title>
      <link>https://iihui.github.io/post/ios-kvc/</link>
      <pubDate>Thu, 13 Feb 2020 13:10:08 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-kvc/</guid>
      <description>KVC(Key Value Coding)键值编码，指允许通过Key名字来直接访问对象的属性，而不需要调用明确的存取方法。这样，便能在运行时动态地访问和修改对象的属性值。在iOS中，无论是Swift还是OC，KVC都是通过对NSObject的扩展来实现的。所以，继</description>
    </item>
    
    <item>
      <title>工具使用文档</title>
      <link>https://iihui.github.io/post/tool-usage/</link>
      <pubDate>Thu, 13 Feb 2020 11:50:55 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/tool-usage/</guid>
      <description>使用Mac开发时会使用各种软件，例如Visual Studio Code，Xcode，iTerm，AppCode等。在这些工具的使用过程中，会遇到一些出现频率较低的问题，解决之后也容易忘记，这篇文章用来记录解决方法，以期后续节省时间。 Visual Studio Code 列选择模式 如果</description>
    </item>
    
    <item>
      <title>iOS 可视化埋点</title>
      <link>https://iihui.github.io/post/ios-log-point/</link>
      <pubDate>Sun, 09 Feb 2020 16:54:52 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-log-point/</guid>
      <description>埋点方案大体上可以归为3类：代码埋点，可视化埋点，无埋点。代码埋点，由开发人员在触发事件的具体方法里，植入多行代码把需要上传的数据发送至服务端。可视化埋点，根据标识来识别每一个事件，针对指定的事件进行取参埋点。而事件的标识与参数信息都写在配</description>
    </item>
    
    <item>
      <title>Objective-C Runtime</title>
      <link>https://iihui.github.io/post/oc-runtime/</link>
      <pubDate>Tue, 04 Feb 2020 13:15:10 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/oc-runtime/</guid>
      <description>Objective-C扩展了C语言，并加入了面向对象特性和Smalltalk式的消息传递机制。而这个扩展的核心是一个用C写的Runtime库，它是OC面向对象和动态机制的基石。OC的Runtime用于创建类对象、进行消息传递和转发。理解OC</description>
    </item>
    
    <item>
      <title>陈小厨作品</title>
      <link>https://iihui.github.io/post/food-2020/</link>
      <pubDate>Mon, 03 Feb 2020 13:28:05 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/food-2020/</guid>
      <description>2020年给自己定了些年度目标，用心下厨是其中一项。我是一个喜欢倒腾吃的人，每次看到自己做的东西既美味又有颜值的时候，总会很开心，但多数时候都忘了记录大致的步骤和拍照留存，2020年想给自己多留点值得回忆的东西，故以此为记。 二月作品 猪血丸子</description>
    </item>
    
    <item>
      <title>macOS 安装Homebrew 报错</title>
      <link>https://iihui.github.io/post/qa_install_brew/</link>
      <pubDate>Fri, 31 Jan 2020 16:28:55 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/qa_install_brew/</guid>
      <description>重装了macOS Catalina 10.15.2，但使用/usr/bin/ruby -e &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;安装Homebrew时报</description>
    </item>
    
    <item>
      <title>Almofire的使用</title>
      <link>https://iihui.github.io/post/ios-alamofire/</link>
      <pubDate>Sat, 28 Dec 2019 21:08:45 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-alamofire/</guid>
      <description>如果使用过OC进行开发，那么知道AFNetworking这个网络操作库。Mattt Thompson作为AFNetworking的发起人，又基于Swift语言开发了一个新的网络操作库 Alamofire。Alamofire的优雅之处在于它完完全</description>
    </item>
    
    <item>
      <title>UITableView 使用</title>
      <link>https://iihui.github.io/post/ios-uitableview/</link>
      <pubDate>Tue, 17 Dec 2019 14:08:45 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-uitableview/</guid>
      <description>在iOS开发中，UITableView的使用频率较高，这篇文章主要用于记录一些常用的使用方法和问题解决方案。 点击cell不变色 func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&amp;gt; UITableViewCell { let cell = tableView.dequeueReusableCell(withIdentifier: cellId, for: indexPath) as! NoteDetailInfoCell cell.selectionStyle = .none //点击该cell不变色 return cell } Cell异步更新 在UITableView</description>
    </item>
    
    <item>
      <title>Cocoapods 使用</title>
      <link>https://iihui.github.io/post/ios-cocoapods-storage/</link>
      <pubDate>Fri, 01 Mar 2019 09:34:41 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-cocoapods-storage/</guid>
      <description>放入制品库 项目需要引入百度语音合成SDK，但这个第三方库中包含的.a文件过于庞大，按规定不能直接放到代码仓库里，需要移到Cocoapods制品库中，然后再在项目中依赖这个组件。用已有的模板，只要按照要求修改对应文件，然后执行相应上传命令即可</description>
    </item>
    
    <item>
      <title>引入百度语音合成</title>
      <link>https://iihui.github.io/post/ios-synthesizer/</link>
      <pubDate>Thu, 28 Feb 2019 11:08:15 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-synthesizer/</guid>
      <description>项目中需要用百度语音合成SDK，因此自己先建了一个Demo工程作为测试，总结下来为准备--&amp;gt; 导入 --&amp;gt; 创建应用 --&amp;gt; 测试。 准备 首先从百度官网下载百度语音合成的SDK,如下图所示首先在左边选择语音合成，然后在右边选择iOS版的离在线融合SDK:</description>
    </item>
    
    <item>
      <title>半透明的悬浮提示窗</title>
      <link>https://iihui.github.io/post/ios-alert-window/</link>
      <pubDate>Sun, 24 Feb 2019 19:50:43 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-alert-window/</guid>
      <description>项目中需要一个悬浮提示窗，从网上找到一篇以OC为示例的文章，因为公司项目是Swift写的，因此需要将OC转为Swift。 OC代码 .h文件 //CustomAlertWindow.h #import &amp;lt;UIKit/UIKit.h&amp;gt; typedef NS_ENUM(NSInteger, AlertWindowPositionOption) { AlertWindowPositionTopMiddle = 0, AlertWindowPositionCenter, AlertWindowPositionBottomMiddle }; @interface CustomAlertWindow : UIWindow + (instancetype)aletWindowWithPositionOption:(AlertWindowPositionOption)positionType andInfoText:(NSString *)text; //显示 - (void)show; // 消失 - (void)dismiss; @end .m文件 //CustomAlertWindow.m #import &amp;#34;CustomAlertWindow.h&amp;#34; #define LABEL_MARGIN 10 //Label的外</description>
    </item>
    
    <item>
      <title>JS事件捕获</title>
      <link>https://iihui.github.io/post/js-event/</link>
      <pubDate>Fri, 25 Jan 2019 11:13:43 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/js-event/</guid>
      <description>DOM事件从发生到开始经历了三个阶段，分别为捕获阶段、命中阶段以及冒泡阶段。捕获阶段表示从最上层开始，直到最下层(点击的那个target元素)，路过的所有节点都可以捕获到该事件。命中阶段:如果某个事件到达了target，它就会进行处理。冒泡</description>
    </item>
    
    <item>
      <title>使用Visual Code的文件对比功能</title>
      <link>https://iihui.github.io/post/qa-compare/</link>
      <pubDate>Tue, 22 Jan 2019 08:39:53 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/qa-compare/</guid>
      <description>在使用坚果云的时候，由于较长时间没有同步，导致本地文件和云端文件冲突，再次同步时，坚果云保留了两个版本。为了弄清两个文件的差异，以进行修改，需要一个工具来比对。最初是想下载一个专门的文件对比软件，但转念一想或许Visual Code可以呢，一</description>
    </item>
    
    <item>
      <title>创建新的Target</title>
      <link>https://iihui.github.io/post/ios-new-target/</link>
      <pubDate>Thu, 10 Jan 2019 11:18:46 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-new-target/</guid>
      <description>项目需要新建一条众测流水线，因此首先需要基于DEV环境新建一个Target，然后将新建的Target配置到新建的流水线上。 Duplicate 新Target的创建一般以已有的Target为模板，如下图所示，首先选中模板Target，然后右键点击选中Dupli</description>
    </item>
    
    <item>
      <title>Range的保存与恢复</title>
      <link>https://iihui.github.io/post/js-focus-save/</link>
      <pubDate>Wed, 09 Jan 2019 16:58:44 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/js-focus-save/</guid>
      <description>在iOS 11.3以下的UIWebview中插入图片时，因图片选择器的弹出导致UIWebview失去焦点，故在插入图片前需先保存图片将要插入的位置。 保存range区域 图片选择器打开前，利用一个全局的Range对象保存插入前光标所在的位置的Ra</description>
    </item>
    
    <item>
      <title>Swift访问权限</title>
      <link>https://iihui.github.io/post/swift-access-controller/</link>
      <pubDate>Wed, 09 Jan 2019 09:18:25 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/swift-access-controller/</guid>
      <description>访问权限用于限制部分代码被其它源文件或者模块访问，目的是隐藏某些代码的实现细节。在Swift中可以设置类型(类、结构和枚举)的访问权限，也可以设置属性和方法的访问权限。Swift提供了5个访问级别，这些访问级别以模块和源文件为区分粒度。 模块</description>
    </item>
    
    <item>
      <title>img添加和取消点击监听</title>
      <link>https://iihui.github.io/post/js-image-addclicklistener/</link>
      <pubDate>Tue, 08 Jan 2019 19:46:39 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/js-image-addclicklistener/</guid>
      <description>一篇图文笔记可能有多张图片，目前的需求为单击图片后开始预览图片。想到的解决思路有两种，第一种是为每张图片添加点击事件的监听，这种方式的麻烦在于要监听是否有新图片插入，一旦有新图片插入时则要对其加入点击事件的监听；第二种则是全局监听点击事件，</description>
    </item>
    
    <item>
      <title>img点击监听</title>
      <link>https://iihui.github.io/post/js-image-clickedlistener/</link>
      <pubDate>Tue, 08 Jan 2019 19:46:39 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/js-image-clickedlistener/</guid>
      <description>一篇图文笔记可能有多张图片，目前的需求为单击图片后开始预览图片。想到的解决思路有两种，第一种是为每张图片添加点击事件的监听，这种方式的麻烦在于要监听是否有新图片插入，一旦有新图片插入时则要对其加入点击事件的监听；第二种则是全局监听点击事件，</description>
    </item>
    
    <item>
      <title>单例模式</title>
      <link>https://iihui.github.io/post/ios-singleton/</link>
      <pubDate>Mon, 07 Jan 2019 23:29:33 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-singleton/</guid>
      <description>单例模式(Singleton Pattern)属于创建型模式，该模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有一个单例对象被创建。 第一种方式 第一种方式是利用Swift中全局变量懒加载和全局变量初始化时默认使用dispatch_o</description>
    </item>
    
    <item>
      <title>Papers教程</title>
      <link>https://iihui.github.io/post/tool-papers/</link>
      <pubDate>Sun, 06 Jan 2019 22:39:26 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/tool-papers/</guid>
      <description>Papers软件对自己的定位为个人科研图书馆，其主要功能为文献收集(Find)、文献整理(Organize)、文献阅读(Read)和文献引用(Cite)。这篇教程主要关注Papers的引用功能。 四个功能 首先对上面提到的4个功能进行简介，以对</description>
    </item>
    
    <item>
      <title>Swift中for循环</title>
      <link>https://iihui.github.io/post/swift-for-in/</link>
      <pubDate>Fri, 04 Jan 2019 08:16:45 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/swift-for-in/</guid>
      <description>Swift中只有一种形式for循环，即for in。但是for-in有多种形式，既包括常规用法又包括区间循环。 常规用法 常规用法一般用于直接访问数组中的元素，可以分为直接访问和按索引访问： let arr = [34, 78, 789, -12] for item in arr { debugPrint(item) } 在OC中是通过索引i来访问数</description>
    </item>
    
    <item>
      <title>基本内排序算法Swift实现</title>
      <link>https://iihui.github.io/post/swift-sort/</link>
      <pubDate>Mon, 31 Dec 2018 09:21:01 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/swift-sort/</guid>
      <description>排序就是重新排列表中的元素，使表中的元素满足按关键字递增或者递减的排列过程。排序算法分为内排序和外排序。内排序是指排序期间元素全部放在内存中的排序；而外排序是指在排序期间元素太多，不能同时全部存放在内存中，必须在排序过程中根据要求，不断在内</description>
    </item>
    
    <item>
      <title>Framework</title>
      <link>https://iihui.github.io/post/ios-framework/</link>
      <pubDate>Tue, 25 Dec 2018 11:45:01 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-framework/</guid>
      <description>链接库 库是一种共享程序代码的方式，分为静态库和动态库。静态库链接时被完整地拷贝到可执行文件，多次使用时就会有多个副本。 而动态库在链接时不复制，程序运行时由系统动态加载到内存，供程序调用。动态库只加载一次到内存，然后供多个程序共用，以节省内存</description>
    </item>
    
    <item>
      <title>桥接文件</title>
      <link>https://iihui.github.io/post/ios-bridge/</link>
      <pubDate>Mon, 24 Dec 2018 23:41:52 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-bridge/</guid>
      <description>因为历史原因，在使用Swift编程时，常常需要用到OC类中的方法，此时就需要使用桥接文件来引入OC中的头文件，以告诉Swift。 手动创建桥接文件 第一步 首先使用快捷键Command+N来新建一个文件： 第二步 选择Header File: 第三步 给Heade</description>
    </item>
    
    <item>
      <title>JS的prototype</title>
      <link>https://iihui.github.io/post/js-prototype/</link>
      <pubDate>Thu, 20 Dec 2018 19:43:47 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/js-prototype/</guid>
      <description>在JS中，每当定义一个对象(函数也是对象)时，对象中都会包含一些预定义的属性；每个对象都有一个prototype对象，这个属性指向函数的原型对象。 原型对象 缘由 Brendan Eich在设计JS时，将所有的数据类型都设计为对象，因此需要有一种机制将这些对象</description>
    </item>
    
    <item>
      <title>javascript中this指针</title>
      <link>https://iihui.github.io/post/js-this/</link>
      <pubDate>Wed, 19 Dec 2018 15:59:17 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/js-this/</guid>
      <description>在JavaScript中，this是动态绑定，或称为运行期绑定的，这导致JavaScript中的this关键字具有多重含义。它可以是全局对象、当前对象或者任意对象，这完全取决于函数的调用方式。 作为对象方法调用 在JS中，函数也是对象，因此函数</description>
    </item>
    
    <item>
      <title>selection 对象</title>
      <link>https://iihui.github.io/post/js-selection/</link>
      <pubDate>Mon, 17 Dec 2018 16:46:24 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/js-selection/</guid>
      <description>在富文本编辑器中，需要控制光标的各种状态信息，位置信息。浏览器提供了selection对象和range对象来操作光标。 selection Selection对象表示用户选择的文本范围或插入符号的当前位置。它代表页面中的文本选区可能横跨多个元素(element</description>
    </item>
    
    <item>
      <title>KVO 介绍</title>
      <link>https://iihui.github.io/post/ios-kvo/</link>
      <pubDate>Mon, 17 Dec 2018 15:09:08 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-kvo/</guid>
      <description>在应用开发中，经常需要使用观察者模式，以监听某些对象属性的变化，然后进行相应操作。OC提供了一套简洁优雅的观察方式——KVO。KVO(key-value observing)是一种通知机制，当指定的被观察者对象的属性被修改时，KVO会自动通知</description>
    </item>
    
    <item>
      <title>给图片添加点击监听</title>
      <link>https://iihui.github.io/post/js-img/</link>
      <pubDate>Mon, 17 Dec 2018 08:34:15 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/js-img/</guid>
      <description>给所有图片添加监听 function setImagesClick(){ $(&amp;#39;body&amp;#39;).on(&amp;#39;click&amp;#39;,&amp;#39;img&amp;#39;,function(){ let position = this.offsetTop; //当前元素距离顶部的距离 //window.scrollTo(0,position) let result = {}; result.position = position.toString() let jsonString = JSON.stringify(result); let escapedJsonString = encodeURI(jsonString); //重新编码 let scheme = &amp;#34;position://&amp;#34;; document.location.href = scheme + &amp;#34;#&amp;#34; + escapedJsonString; //向ios发送 }); } 参考资料</description>
    </item>
    
    <item>
      <title>RunLoop</title>
      <link>https://iihui.github.io/post/ios-runloop/</link>
      <pubDate>Fri, 14 Dec 2018 08:21:26 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-runloop/</guid>
      <description>概念 一般来讲，一个线程一次只能执行一个任务，执行完成后，线程就会退出。若我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是下面这样的： function loop() { initialize(); do { var message = get_next_message(); process_message(message); } while (message != quit); } 这种模型被称为Event Loop,实现这种模型的关键点在</description>
    </item>
    
    <item>
      <title>权限检查</title>
      <link>https://iihui.github.io/post/ios-authority/</link>
      <pubDate>Thu, 13 Dec 2018 20:25:33 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-authority/</guid>
      <description>相机权限检查 相机和音频的权限分为4种，分别是.denied,restricted,.authorized,.notDetermined,.authorized四种: .denied 未授权，用户曾经选择过拒绝授权。 .authorized 已经授权。 .restricted 未授权，例如家长控制。 .notDetermined 没有</description>
    </item>
    
    <item>
      <title>CABasicAnimation</title>
      <link>https://iihui.github.io/post/ios-animation/</link>
      <pubDate>Thu, 13 Dec 2018 10:50:31 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-animation/</guid>
      <description>关键帧动画 所谓关键帧动画，就是将Layer的属性作为KeyPath来注册，只要指定动画的起始帧和结束帧，然后自动计算和实现中间的过度的一种动画方式。 func recordingButtonAnimation(){ let animation = CABasicAnimation(keyPath: &amp;#34;opacity&amp;#34;) animation.fromValue = 1.0 animation.toValue = 0.3 animation.fillMode = kCAFillModeForwards animation.isRemovedOnCompletion = false animation.duration = self.animationDuration self.recordButton.layer.add(animation, forKey: nil) } //添加定时器 if recordingAnimationTimer == nil{ recordingAnimationTimer = Timer.scheduledTimer(timeInterval: self.animationDuration, target: self, selector: #selector(recordingButtonAnimation), userInfo:</description>
    </item>
    
    <item>
      <title>透明度渐变动画</title>
      <link>https://iihui.github.io/post/ios-opicity-animation/</link>
      <pubDate>Thu, 13 Dec 2018 10:50:31 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-opicity-animation/</guid>
      <description>CABasicAnimation关键帧动画 所谓关键帧动画，就是将Layer的属性作为KeyPath来注册，只要指定动画的起始帧和结束帧，然后自动计算和实现中间的过度的一种动画方式。 func recordingButtonAnimation(){ let animation = CABasicAnimation(keyPath: &amp;#34;opacity&amp;#34;) animation.fromValue = 1.0 animation.toValue = 0.3 animation.fillMode = kCAFillModeForwards animation.isRemovedOnCompletion = false animation.duration = self.animationDuration self.recordButton.layer.add(animation, forKey: nil) } //添加</description>
    </item>
    
    <item>
      <title>iOS视频开发入门</title>
      <link>https://iihui.github.io/post/ios-video/</link>
      <pubDate>Wed, 12 Dec 2018 10:55:40 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-video/</guid>
      <description>视频实质 纯粹的视频（不包括音频）实质上就是一组帧图片，经过视频编码成为视频(video)文件再把音频（audio）文件以及字幕文件组装在一起成为视频（movie）文件。 1秒内出现的图片数就是帧率，图片间隔越小画面就越流畅，所以帧率越高效果就</description>
    </item>
    
    <item>
      <title>HTML入门</title>
      <link>https://iihui.github.io/post/htm-primer/</link>
      <pubDate>Thu, 06 Dec 2018 19:22:27 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/htm-primer/</guid>
      <description>简介 HTML指的是超文本标记语言 (Hyper Text Markup Language)，它不是一种编程语言，而是一种标志语言，标记语言是一套标记标签，使用标记标签来描述网页。 .htm or .html 当保存HTML文件时，可以使用.htm,也可以使用.html文件后缀。使用.htm,这只是</description>
    </item>
    
    <item>
      <title>CSS 入门</title>
      <link>https://iihui.github.io/post/css-primer/</link>
      <pubDate>Thu, 06 Dec 2018 10:43:48 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/css-primer/</guid>
      <description>关注点分离和混合 关注点分离 关注点分离的意思是：各种技术只负责自己的领域，不要混合在一起，形成耦合。对于网页开发来说，主要是三种技术分离。 HTML:负责网页的结构，称为语义层。 CSS:负责网页的样式，称为视觉层。 JavaScript:负责网页</description>
    </item>
    
    <item>
      <title>Xcode</title>
      <link>https://iihui.github.io/post/xcode-quick/</link>
      <pubDate>Tue, 27 Nov 2018 15:20:06 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/xcode-quick/</guid>
      <description>快捷键 键盘图标 ⌘——Command () ⌃ ——Control ⌥——Option (alt) ⇧——Shift ⇪——Caps Lock 快捷键 Command+R 运行 Command+B 编译 Command+. 停止 Command + Shift + K 清除工程 Command + K 清除控制台信息 Command + N 新建文件 Command + Shift + N 创建新工程 导航栏 Command+0~9 工程导航 Command + 0 快速打开实</description>
    </item>
    
    <item>
      <title>OC 入门</title>
      <link>https://iihui.github.io/post/oc-tour/</link>
      <pubDate>Wed, 19 Sep 2018 14:29:51 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/oc-tour/</guid>
      <description>Objective-C简称OC， 是C语言的严格超集——任何C语言程序不经过修改都可以直接通过OC的编译器，在OC中使用C语言代码也是完全合法的。OC被描述为覆盖在C语言上的一层，因为OC的原意就是在C语言的主体上加入面向对象的特性。 文件扩展</description>
    </item>
    
    <item>
      <title>swift中的方法</title>
      <link>https://iihui.github.io/post/swift-method/</link>
      <pubDate>Fri, 14 Sep 2018 09:31:40 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/swift-method/</guid>
      <description>在Swift中方法是关联了特定类型的函数。类，结构体，枚举类型都能定义实例方法，方法封装了给定类型特定的任务和功能。 实例方法 实例方法是属于特定实例（类实例、结构体实例或者枚举实例）的函数。实例方法只能在类型的具体实例里被调用，不能独立于实例</description>
    </item>
    
    <item>
      <title>JavaScript 数据类型</title>
      <link>https://iihui.github.io/post/js-data-struct/</link>
      <pubDate>Mon, 20 Aug 2018 21:57:31 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/js-data-struct/</guid>
      <description>JavaScript不需要进行类型声明，因此它是一种弱类型的语言，这意味着可以在任何阶段改变变量的数据类型。 字符串 字符串是由零个或者多个字符组成，必须包含在引号中，单引号和双引号都可以。 数值 如果想给一个变量赋一个数值，不必限定它必须是一个整</description>
    </item>
    
    <item>
      <title>泼辣修图中的人像工具</title>
      <link>https://iihui.github.io/post/pixel-portrait/</link>
      <pubDate>Wed, 27 Jun 2018 08:48:35 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/pixel-portrait/</guid>
      <description>在泼辣修图中有22个强大且易用的人像调整工具，涵盖了面部结构、五官大小、肤色亮度等等的调整。当图片中出现一张脸时，泼辣修图会智能的识别脸部并区分其五官，选中相应的区域然后调整对应的参数即可。 自动调整 点击自动增强，程序可以自动优化五官、结构和</description>
    </item>
    
    <item>
      <title>泼辣修图后期术语3</title>
      <link>https://iihui.github.io/post/pixel-term3/</link>
      <pubDate>Sat, 02 Jun 2018 09:17:38 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/pixel-term3/</guid>
      <description>质感 质感：质感是指物体的材质与质量所带给人的感觉。在泼辣修图中，质感选项下的调整包括清晰度、锐化、降噪色彩、降噪明度。 清晰度 清晰度用来调整画面的清晰程度。提高清晰度数值可以让画面更加清晰，可以用来修复轻微失焦的画面。降低清晰度数值可以画面更</description>
    </item>
    
    <item>
      <title>泼辣修图后期术语2</title>
      <link>https://iihui.github.io/post/pixel-term2/</link>
      <pubDate>Fri, 01 Jun 2018 20:53:31 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/pixel-term2/</guid>
      <description>曝光 曝光：用于调整画面的明亮程度。提高曝光值会让画面变得更加明亮，整体显得干净而又轻盈；降低曝光值会让画面变得更加昏暗，整体显得沉重而又严肃。 高光、白色色阶、黑色色阶、阴影 可以按照曝光去划分照片的区域，例如把照片划分为最亮的区域、较亮的区域</description>
    </item>
    
    <item>
      <title>泼辣修图后期术语1</title>
      <link>https://iihui.github.io/post/pixel-term1/</link>
      <pubDate>Fri, 01 Jun 2018 17:17:42 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/pixel-term1/</guid>
      <description>对比度 维基百科对比度的解释为：画面黑与白的比值，即从黑到白的渐变层次。比值越大，从黑到白的渐变层次越多，从而色彩表现越丰富。对比度对于视觉的影响非常关键，一般说来对比度越大，图像越清晰越醒目，色彩也越鲜明亮丽；对比度小，则让整个画面灰蒙蒙的</description>
    </item>
    
    <item>
      <title>使用pixelmator pro修改证件照背景颜色</title>
      <link>https://iihui.github.io/post/pixel-background/</link>
      <pubDate>Fri, 01 Jun 2018 14:16:20 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/pixel-background/</guid>
      <description>现有一张白底的证件照需要修改为蓝底的。使用pixelmator pro这款软件，自己摸索出了2种方法来实现这个需求。 第一种方法 第一种方法的思路，首先将头像抠出来，然后新建一个同样大小的文件，再将抠出来图层粘贴到新建的图层，最后改变背景的颜色。</description>
    </item>
    
    <item>
      <title>Go 实现各种内排序算法</title>
      <link>https://iihui.github.io/post/go-sort/</link>
      <pubDate>Mon, 28 May 2018 12:13:06 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/go-sort/</guid>
      <description>内排序是指在排序过程中，数据都能够放在内存中处理，排序时不涉及数据的内、外交换。 插入类排序 直接插入排序 func InsertSort(data []int) { var i, j, cur int length := len(data) //获得切片对应数组的长度 for i = 1; i &amp;lt; length; i++ { cur = data[i] for j = i - 1; j &amp;gt;= 0; j-- { if data[j] &amp;gt; cur { data[j+1] = data[j] } else { break } } data[j+1] = cur } } 二分</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 常见知识点</title>
      <link>https://iihui.github.io/post/cpp-base/</link>
      <pubDate>Sat, 05 May 2018 17:24:44 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/cpp-base/</guid>
      <description>static的作用 对普通函数和全局变量而言static具有隐藏作用：将其修饰的全局变量和函数的作用域限定在本文件中。不加static修饰的函数和全局变量具有全局可见性。 普通局部变量而言 未初始化的static普通局部变量，编译器会将其初始化为</description>
    </item>
    
    <item>
      <title>线性表</title>
      <link>https://iihui.github.io/post/arith-linear-list/</link>
      <pubDate>Wed, 25 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/arith-linear-list/</guid>
      <description>线性表是由 $n$个具有相同特性的元素$(n \ge 0)$ 组成的一个有限序列，是一种逻辑结构。它的特征在于：①表中所有数据元素类型相同。②表由有限个数据元素构成。③表中数据元素是位置相关的（这一点表明线性表不同于集合)，并且每个元素都有一个对应的序号，</description>
    </item>
    
    <item>
      <title>Go 标签</title>
      <link>https://iihui.github.io/post/go-label/</link>
      <pubDate>Mon, 06 Nov 2017 16:11:37 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/go-label/</guid>
      <description>在for,switch或者select中都可以配合标签形式的标识符使用——某一行第一个以冒号结尾的单词（因为gofmt会自动将后续代码移动至下一行）。 一个实例 package main import &amp;#34;fmt&amp;#34; func main() { LABEL1: for i := 0; i &amp;lt;= 5; i++ { for j := 0; j &amp;lt;= 5; j++ { if j == 4 { continue LABEL1 } fmt.Printf(&amp;#34;i is: %d, and j is: %d\n&amp;#34;,</description>
    </item>
    
    <item>
      <title>Go 中if语句</title>
      <link>https://iihui.github.io/post/go-if/</link>
      <pubDate>Thu, 02 Nov 2017 19:53:47 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/go-if/</guid>
      <description>if是用于测试某个条件（布尔型，又被称为逻辑型）的语句，如果该条件成立，则会执行if后由大括号括起来的代码块，否则就忽略该代码块继续执行后续的代码。Go中if语句总共有三种形式，分别是： 不带else的if； 带一个else的if语句； 带els</description>
    </item>
    
    <item>
      <title>位运算</title>
      <link>https://iihui.github.io/post/arith-bits/</link>
      <pubDate>Sat, 28 Oct 2017 11:12:12 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/arith-bits/</guid>
      <description>判断是否为2的n次方 对于正整数来说，如果一个数为$x=2^n$,那么必然有一位为1，右边其它位全为0。那么$(x-1)$在其对应为1的位置上为0，对应位右边全部为1。因此，x&amp;amp;(x-1)的值则为0。 // 要求x是正整数 (x&amp;amp;(x-1) == 0) 位运算实现加</description>
    </item>
    
    <item>
      <title>败者树</title>
      <link>https://iihui.github.io/post/arith-loser-tree/</link>
      <pubDate>Fri, 29 Sep 2017 21:09:50 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/arith-loser-tree/</guid>
      <description>胜者树和败者树都是完全二叉树，是树形选择排序的一种变型。每个叶子结点相当于一个选手，每个中间结点相当于一场比赛，每一层相当于一轮比赛。不同的是，胜者树的中间结点记录的是胜者的标号；而败者树的中间结点记录的败者的标号。胜者树与败者树都可以在$</description>
    </item>
    
    <item>
      <title>剑指offer题集1</title>
      <link>https://iihui.github.io/post/arith-sword-1/</link>
      <pubDate>Wed, 16 Aug 2017 09:46:10 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/arith-sword-1/</guid>
      <description>二维数组中查找 在一个二维数组中，每一行都按从左到右递增的顺序排序，每一列都按从上到下递增的顺序排列，试从该二维数组查找给定的元素。 首先应该从右上角的元素(记为cur)开始比较，如果当前要查找的元素key的值比cur大，那么就应该往cur所在</description>
    </item>
    
    <item>
      <title>C&#43;&#43;智能指针</title>
      <link>https://iihui.github.io/post/cpp-smart-pointer/</link>
      <pubDate>Sun, 13 Aug 2017 16:01:53 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/cpp-smart-pointer/</guid>
      <description>智能指针是一个类，它对普通指针进行封装，使智能指针类对象具有普通指针类型一样的操作。具体而言，复制对象时，副本和原对象都指向同一存储区域，如果通过一个副本改变其所指的值，则通过另一对象访问的值也会改变。与普通指针所不同的是，智能指针能够对内</description>
    </item>
    
    <item>
      <title>Go 中映射(字典）</title>
      <link>https://iihui.github.io/post/go-map/</link>
      <pubDate>Sat, 05 Aug 2017 19:25:17 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/go-map/</guid>
      <description>映射(或称为字典)是一种数据结构，用于存储一系列无序的键值对，它是基于键来存储值。映射的键可以是任何值，只要这个值可以使用==运算符做比较即可。切片、函数以及包含切片的结构类型这些类型由于具有引用语义， 不能作为映射的键。 创建和初始化 使用ma</description>
    </item>
    
    <item>
      <title>Go 切片</title>
      <link>https://iihui.github.io/post/go-slice/</link>
      <pubDate>Fri, 04 Aug 2017 15:37:58 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/go-slice/</guid>
      <description>定义 切片是围绕动态数组的概念来构建的，但是本身并非动态数组或数组指针，它通过内部指针引用底层数组，设定相关属性，将数据读写操作限定到指定区域。切片这个名字来自于——创建一个新的切片就是把底层数组切出一部分。 type slice struct{ array unsafe.Pointer // slice中指向底层数</description>
    </item>
    
    <item>
      <title>Go 数组</title>
      <link>https://iihui.github.io/post/go-array/</link>
      <pubDate>Thu, 03 Aug 2017 15:11:37 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/go-array/</guid>
      <description>定义 在Go语言里，数组是一个长度固定的数据类型，用于连续存储多个具有相同的类型的元素。数组存储的类型可以是内置类型，如整型或者字符串，也可以是某种结构类型。 ![c600](http://oqe76o492.bkt.clouddn.com/屏</description>
    </item>
    
    <item>
      <title>Go 未命名类型</title>
      <link>https://iihui.github.io/post/go-undef-type/</link>
      <pubDate>Thu, 03 Aug 2017 11:04:39 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/go-undef-type/</guid>
      <description>未命名类型 在Go中数组、切片、字典、通道类型与具体元素类型或长度属性相关，故被称为未命名类型。具有相同声明的未命名类型被称为同一类型，在 Go 中未命名类型共有8类。 具有相同基础类型的指针 具有相同元素类型和长度的数组array 具有相同元素类型的切</description>
    </item>
    
    <item>
      <title>Go 接口</title>
      <link>https://iihui.github.io/post/go-interface/</link>
      <pubDate>Wed, 02 Aug 2017 09:13:45 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/go-interface/</guid>
      <description>接口定义 接口代表一种调用契约，是多个方法声明的集合。在某些动态语言中接口(interface)也被称为协议(protocol)。准备交互的双方，共同遵守事先的约定规则，使得在无须知道对方身份的情况下进行协作。接口关心的是做什么，而不关心怎么</description>
    </item>
    
    <item>
      <title>Go 定义类型</title>
      <link>https://iihui.github.io/post/go-struct/</link>
      <pubDate>Tue, 01 Aug 2017 09:43:30 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/go-struct/</guid>
      <description>值的类型给编译器提供两部分信息：①需要分配多少内存给这个值；②这段内存表示什么。Go语言允许用户定义类型，当用户声明一个新类型时，这个声明就给编译器提供一个框架，告知必要的内存大小和表示信息。 结构体 Go语言中声明用户定义的类型有两种方法，①</description>
    </item>
    
    <item>
      <title>Go 延迟调用</title>
      <link>https://iihui.github.io/post/go-defer/</link>
      <pubDate>Mon, 31 Jul 2017 08:55:09 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/go-defer/</guid>
      <description>关键字defer允许我们推迟到函数返回前一刻(或任意位置执行return语句之后)才执行某个语句或函数。 为什么要在返回之后才执行这些语句？因为return语句同样可以包含一些操作，而不是单纯地返回某个值，实际上此时return语句要做三件事</description>
    </item>
    
    <item>
      <title>Go 方法</title>
      <link>https://iihui.github.io/post/go-method/</link>
      <pubDate>Sun, 30 Jul 2017 21:06:07 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/go-method/</guid>
      <description>方法 在Go中结构体就像是类的一种简化形式，方法就像类中的方法。方法是与对象实例绑定的特殊函数，方法和函数定义语法区别在于:方法有前置实例接收参数receiver，编译器以此确定方法所属类型。 接收者类型几乎可以是任何类型，不仅仅是结构体类型，</description>
    </item>
    
    <item>
      <title>Go 包</title>
      <link>https://iihui.github.io/post/go-package/</link>
      <pubDate>Sat, 29 Jul 2017 10:02:56 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/go-package/</guid>
      <description>包是结构化的一种方式,所有Go语言的程序都会组织成若干组文件，每组文件被称为一个包。每个文件都属于且仅属于一个包，一个包中可以包含许多以.go为扩展名的源文件。 包中源文件 源文件都使用UTF-8编码，每个源文件都属于包的一部分，在文件头部用p</description>
    </item>
    
    <item>
      <title>Go 数据</title>
      <link>https://iihui.github.io/post/go-data/</link>
      <pubDate>Fri, 28 Jul 2017 10:32:19 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/go-data/</guid>
      <description>数据类型 Go 中数据分为基本类型，数组，引用，字典（映射)，通道，函数，结构体，接口等等。 切片slice可实现类似动态数组的功能y := make([]int, 0, 5); append(y,7)。 将字典map类型内置，可以直接从运行层面获得性能优化。 所谓ok-idiom模式，就</description>
    </item>
    
    <item>
      <title>Go 函数</title>
      <link>https://iihui.github.io/post/go-func/</link>
      <pubDate>Thu, 27 Jul 2017 21:58:12 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/go-func/</guid>
      <description>Go中有3种类型的函数，第一种是普通带名字的函数，第二种是匿名函数(或者被称为lambda函数)，第三种是方法（含有接收者的特殊函数）。 特点 在Go中关键字func用于定义函数，相比于其他语言，Go中函数有以下的特点： 函数是一等公民，即可作为</description>
    </item>
    
    <item>
      <title>Go 表达式</title>
      <link>https://iihui.github.io/post/go-expression/</link>
      <pubDate>Wed, 26 Jul 2017 20:14:46 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/go-expression/</guid>
      <description>运算符 在Go中，一元运算符优先级最高，二元则分为5个级别，二元运算符遵循相同优先级从左到右依次计算，二元运算符从高到低的5个等级为： * / % &amp;lt;&amp;lt; &amp;gt;&amp;gt; &amp;amp; &amp;amp;^ + - | ^ == != &amp;lt; &amp;lt;= &amp;gt; &amp;gt;= &amp;amp;&amp;amp; || 二元运算符中除了移位操作外，操作数类型必须相同。如果其中一个是无显式类</description>
    </item>
    
    <item>
      <title>Go 常量</title>
      <link>https://iihui.github.io/post/go-const/</link>
      <pubDate>Tue, 25 Jul 2017 09:45:49 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/go-const/</guid>
      <description>常量是一种表达式，其可以保证在编译阶段计算出表达式的值，并不需要等到运行时，从而使编译器得以知晓其值。常量值必须是编译期可确定的字符、字符串、数字或布尔值。可指定常量类型，或由编译器通过初始值推断。 特别说明 Go中常量可以是任意基本类型，也包</description>
    </item>
    
    <item>
      <title>Go 基本类型</title>
      <link>https://iihui.github.io/post/go-type/</link>
      <pubDate>Mon, 24 Jul 2017 10:34:44 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/go-type/</guid>
      <description>Go语言中定义了清晰完备的预定义基本类型（共21类），使得开发跨平台应用时无须过多考虑符号和长度差异，具体如下表： ![c600](http://oqe76o492.bkt.clouddn.com/屏幕快照 2017-12-21 下午2.36.532.jpg) 整型</description>
    </item>
    
    <item>
      <title>memcpy 的实现</title>
      <link>https://iihui.github.io/post/cpp-memcpy/</link>
      <pubDate>Thu, 01 Jun 2017 11:44:24 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/cpp-memcpy/</guid>
      <description>地址重叠 void *memcpy(void *dst, const void *src, size_t n); //If copying takes place between objects that overlap, the behavior is undefined. 注意注释，对于地址重叠的情况，该函数的行为是未定义的。事实上所说的陷阱也在于此，自己动手实现memcpy时就需要考虑地址重叠的情况。 另外，标准库也提供了地址重叠时的内存拷贝函数：memmove</description>
    </item>
    
    <item>
      <title>基本排序算法</title>
      <link>https://iihui.github.io/post/arith-sort/</link>
      <pubDate>Tue, 23 May 2017 17:54:57 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/arith-sort/</guid>
      <description>基本概念 排序算法的稳定性：如果待排序的数据中，存在多个关键字相同的元素，经过排序后这些相同关键字的元素之间的相对次序保持不变，则称这种排序算法是稳定的，反之则为不稳定。 内排序：排序过程中，整个表都是放在内存中处理，排序时不涉及数据的内、外交</description>
    </item>
    
    <item>
      <title></title>
      <link>https://iihui.github.io/post/ios-profile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-profile/</guid>
      <description>iPhone XS Max iOS 13.7 Total pre-main time: 1.9 seconds (100.0%) dylib loading time: 538.45 milliseconds (28.3%) rebase/binding time: 397.03 milliseconds (20.8%) ObjC setup time: 482.18 milliseconds (25.3%) initializer time: 483.96 milliseconds (25.4%) slowest intializers : libSystem.B.dylib : 9.05 milliseconds (0.4%) MobileRTC : 87.87 milliseconds (4.6%) BizConfSDK : 73.70 milliseconds (3.8%) IpCall : 70.74 milliseconds (3.7%) CMBMobileST : 162.20 milliseconds (8.5%) total time: 3.4 seconds (100.0%) total images loaded: 556 (534 from dyld shared cache) total segments mapped: 77, into 64676 pages total images loading time: 2.0 seconds (58.7%) total load time in ObjC: 482.18 milliseconds (13.9%) total debugger pause time: 1.4 seconds (43.1%) total dtrace DOF registration time: 0.00 milliseconds (0.0%) total rebase fixups: 1,108,451 total rebase fixups time:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://iihui.github.io/post/ios-time2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-time2/</guid>
      <description>iPhone XR iOS 12.4.1 生产5.13.5 Total pre-main time: 988.59 milliseconds (100.0%) dylib loading time: 398.75 milliseconds (40.3%) rebase/binding time: 193.73 milliseconds (19.5%) ObjC setup time: 90.53 milliseconds (9.1%) initializer time: 305.29 milliseconds (30.8%) slowest intializers : libSystem.B.dylib : 7.61 milliseconds (0.7%) libMainThreadChecker.dylib : 22.48 milliseconds (2.2%) libMTLInterpose.dylib : 46.70 milliseconds (4.7%) MobileRTC : 63.41 milliseconds (6.4%) CMBMobile : 105.77 milliseconds (10.6%) total time: 2.7 seconds (100.0%) total images loaded: 483 (457 from dyld shared cache) total segments mapped: 87, into 65168 pages with 2784 pages pre-fetched total images loading time: 2.0 seconds (75.5%) total load time in ObjC: 90.53 milliseconds (3.3%) total debugger pause time: 1.6 seconds (60.8%) total dtrace DOF registration time:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://iihui.github.io/post/ios-time3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://iihui.github.io/post/ios-time3/</guid>
      <description>iPhone XR iOS 12.4.1 招乎5.13.5 5.13.5启动时间viewDidAppear为:1.226625919342041秒 5.13.5启动时间viewDidAppear为:1.2704359292984009秒 5.13.5启动时间viewDidAppe</description>
    </item>
    
  </channel>
</rss>
