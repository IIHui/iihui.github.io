<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
    <title>视图 - Keep It Simple</title>
    <meta name="keywords" content="博客,思考,读书,笔记,技术,分享">
    
    <meta property="og:title" content="视图">
    <meta property="og:site_name" content="Keep It Simple">
    <meta property="og:image" content="/img/author.jpg"> 
    <meta name="title" content="视图 - Keep It Simple" />
    <meta name="description" content="Swift | Go | C&#43;&#43; "> 
    <link rel="shortcut icon" href="https://iihui.github.io/img/favicon.ico" />
    <link rel="apple-touch-icon" href="https://iihui.github.io/img/apple-touch-icon.png" />
    <link rel="apple-touch-icon-precomposed" href="https://iihui.github.io/img/apple-touch-icon.png" />
    <link href="https://iihui.github.io/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />
    <link href="https://iihui.github.io/js/vendor/fancybox/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />
    <link href="https://iihui.github.io/css/main.css" rel="stylesheet" type="text/css" />
    <link href="https://iihui.github.io/css/custom.css" rel="stylesheet" type="text/css" />
    <link href="https://iihui.github.io/css/syntax.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
     fancybox: true, 
    motion: true
  };
</script>

    <link href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/monokai-sublime.min.css" rel="stylesheet">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/go.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/swift.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/objectivec.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/clojure.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/cpp.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>


</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<div class="container one-collumn sidebar-position-left page-home  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-meta  custom-logo ">

  <div class="custom-logo-site-title">
    <a href="https://iihui.github.io/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Keep It Simple</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">靡不有初，鲜克有终</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
    <ul id="menu" class="menu">
      
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/tags/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-tag"></i> <br />标签
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/post/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/categories/%E7%BE%8E%E9%A3%9F/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-fire"></i> <br />美食
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/categories/%E5%90%8E%E6%9C%9F/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-edit"></i> <br />后期
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/categories/%E6%97%85%E8%A1%8C/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-leaf"></i> <br />旅行
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/about/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于
          </a>
        </li>
      
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger"> <i class="menu-item-icon fa fa-search fa-fw"></i> <br /> 搜索</a>
      </li>
    </ul>
    <div class="site-search">
      <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>

    </div>
</nav>
<script type="text/javascript"
        async
        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
		<!-- src = "http://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> <\!--  -\-> -->
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>

<!DOCTYPE html>
<html lang="en">


<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css" integrity="sha384-D+9gmBxUQogRLqvARvNLmA9hS2x//eK1FhVb9PiU86gmcrBrJAQT8okdJ4LMp2uv" crossorigin="anonymous">

    
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js" integrity="sha384-483A6DwYfKeDa0Q52fJmxFXkcPCFfnXMoXblOkJ4JcA8zATN6Tm78UNL72AKk+0O" crossorigin="anonymous"></script>
</head>
<body>

</body>
</html>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
<section id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="https://iihui.github.io/post/ios-views/" itemprop="url">
        视图
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">创建: </span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2021-05-28">
    2021-05-28
</time>
</span>
&nbsp; | &nbsp;
<span class="post-updated-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-check-o"></i>
</span>
<span class="post-meta-item-text">更新: </span>
<time itemprop="dateUpdated" content="2021-05-28">
    2021-05-28
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类: </span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="https://iihui.github.io/categories/ios" itemprop="url" rel="index">
        <span itemprop="name">iOS</span>
      </a>
      &nbsp; 
    </span>
  
</span>


      <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-file-word-o"></i>
</span>
<span class="post-meta-item-text">字数: </span>
<span class="leancloud-visitors-count">16540</span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-coffee"></i>
</span>
<span class="post-meta-item-text">阅读: </span>
<span class="leancloud-visitors-count">34 分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <blockquote>
<p>视图<code>view</code>的层次结构是其组织的主要模式。<!-- raw HTML omitted -->一个视图可以有多个子视图，但只能有一个直接父视图<!-- raw HTML omitted -->。若一个视图被从界面中被移除，则它的子视图也会被移除；若一个视图被隐藏，则它的子视图都会被隐藏；如果一个视图被移动，它的子视图也都会随之移动。也就是说，<!-- raw HTML omitted -->一个视图的变化会作用到它的子视图中<!-- raw HTML omitted -->。</p>
</blockquote>
<p><code>UIView</code>是<code>UIResponder</code>的子类，即它<!-- raw HTML omitted -->不仅是用户能看到的界面，也是用户交互所用界面<!-- raw HTML omitted -->。也就是说<!-- raw HTML omitted -->视图的层次结构也是响应者链的基础<!-- raw HTML omitted -->，但它与响应者链不完全相同。</p>
<p>一个视图的创建可能来自<code>nib</code>，也可能来自代码。不能绝对地说哪种方式更好一些，这取决于个人需求和程序的整体架构。</p>
<h1 id="window-和-root-view">window 和 root View</h1>
<p>视图层级结构的<!-- raw HTML omitted -->最顶层<!-- raw HTML omitted -->是<code>window</code>。<code>window</code>为<code>UIWindow</code>或<code>UIWindow</code>子类的实例，其中<code>UIWindow</code>也是<code>UIView</code>的一个子类。</p>
<p>在<code>App</code><!-- raw HTML omitted -->启动时会创建和显示一个<code>window</code><!-- raw HTML omitted -->，否则只会看到一片黑色。从<code>iOS 13</code>开始，<code>App</code>可在<code>iPad</code>上支持多个<code>window</code>；如果你的<code>App</code>在<code>iPad</code>上不支持多<code>window</code>或在<code>iPhone</code>上运行，则只有一个<code>window</code>，即<code>the main window</code>。</p>
<p>一个可见的<code>window</code><!-- raw HTML omitted -->构成了所有其他可见<code>view</code>的背景<!-- raw HTML omitted -->，也是所有可见视图的父视图。一个<code>view</code>如果是可见的，那么它一定是某个可见<code>window</code>的子视图。</p>
<p>在实际编程中，一般<!-- raw HTML omitted -->不会手动或者直接用子视图来填充<!-- raw HTML omitted --><code>window</code>，因为<code>window</code>和它所包含的视图之间的连接是<!-- raw HTML omitted -->根视图控制器<!-- raw HTML omitted -->，即其<code>rootViewController</code>属性。</p>
<p>一旦一个<code>ViewController</code>被实例化，并且赋值给<code>window</code>的<code>rootViewController</code>属性，则此<code>ViewController</code>的主视图（即<code>view</code>属性），将会填充整个<code>window</code>，<!-- raw HTML omitted -->这个主视图也将是<code>window</code>的唯一直接子视图<!-- raw HTML omitted -->。其他所有可见的视图在一定深度上都是<code>rootViewController</code>主视图的某个子视图。</p>
<h2 id="window-scene-architecture">window scene architecture</h2>
<p>从<code>iOS 13</code>开始<code>App</code>的<code>window</code><!-- raw HTML omitted -->默认由<code>UIWindowScene</code>来提供<!-- raw HTML omitted -->，这与<code>iOS 12</code>及之前的版本相比，是架构上最大的变化：</p>
<ul>
<li>
<p>在<code>iOS 12</code>及以前，是基于<code>window</code>的架构，<code>window</code>是<code>AppDelegate</code>的一个属性。如果项目是在<code>XCode 10</code>或者之前创建的，则默认使用这种老架构。</p>
</li>
<li>
<p>在<code>iOS 13</code>及以后，是基于<code>scene</code>的架构，<code>window</code>是<code>SceneDelegate</code>的一个属性。如果项目是在<code>XCode 11</code>或之后创建的，则默认使用的是这种新架构。</p>
</li>
</ul>
<p>使用老<code>window</code>架构的<code>App</code>，如果在<code>iOS 13</code>及以后的版本中运行时，它会被赋予一个<code>UIWindowScene</code>，但是它不知道这个事实，<!-- raw HTML omitted -->并且功能不受影响，仍然运行在老架构上<!-- raw HTML omitted -->。但是，<!-- raw HTML omitted -->新<code>window</code>架构的<code>App</code>不能运行在<code>iOS 12</code>及以前的系统<!-- raw HTML omitted -->。</p>
<p>如果需要新架构的<code>App</code>支持<code>iOS 12</code>以之前的系统，则需要<!-- raw HTML omitted -->将<code>SceneDelegate</code>的<code>window</code>属性复制到<code>AppDelegate</code>类中<!-- raw HTML omitted -->。然后在<code>AppDelegate</code>类中<!-- raw HTML omitted -->将所有涉及<!-- raw HTML omitted --><code>UISceneSession</code>的方法标记为<code>@available(iOS 13.0, *)</code>。最后在<code>SceneDelegate</code>类前将<!-- raw HTML omitted -->整个类<!-- raw HTML omitted -->标记为<code>@available(iOS 13.0, *)</code>即可。</p>
<p>进行如上的改动后，如果<code>App</code>运行在<code>iOS 13</code>及以后的系统中，则<!-- raw HTML omitted -->使用的是新架构<!-- raw HTML omitted -->，并且<code>SceneDelegate</code>持有<code>window</code>。如果在<code>iOS 12</code>及以前的系统中，则使用的是旧架构，<code>AppDelegate</code>持有<code>window</code>。</p>
<p>如果想要在<code>XCode 11</code>以上创建的工程使用旧<code>window</code>架构，则需要<!-- raw HTML omitted -->先删除所有<code>UISceneSession</code>和<code>SceneDelegate</code>相关的代码<!-- raw HTML omitted -->，然后在<code>info.plist</code>中删除<code>Application Scene Manifest</code>入口，最后在<code>AppDelegate</code>中<!-- raw HTML omitted -->手动添加<!-- raw HTML omitted --><code>var window: UIWindow?</code>即可<!-- raw HTML omitted -->。</p>
<h2 id="app-launches">App Launches</h2>
<p>在启动时，应用程序如何初始化<code>window</code>，以及该<code>window</code>如何被填充和显示？如果应用使用<code>main storyboard</code>，<code>window</code>的初始化和显示<!-- raw HTML omitted -->都会自动完成<!-- raw HTML omitted -->。但是，「自动」并不意味着「通过魔术」。</p>
<p>应用的启动时的程序是直接和确定的，我们的代码可以在其中起作用。知道一个应用程序是如何启动的是非常有用的，尤其是当配置错误，应用程序的启动出现问题时，就可以找出原因了。</p>
<p><code>App</code>启动时<!-- raw HTML omitted -->最终包括一次<code>UIApplicationMain</code>函数的调用<!-- raw HTML omitted -->。与<code>OC</code>不同，一个典型的<code>Swift</code>项目不会在代码中明确地进行这一调用，都是<!-- raw HTML omitted -->自动完成调用的<!-- raw HTML omitted -->。<code>UIApplicationMain</code>函数的调用<!-- raw HTML omitted -->创建了一些最重要的初始实例<!-- raw HTML omitted -->；如果你的应用程序使用<code>main storyboard</code>，则这些实例包括<code>window</code>和它的根视图控制器。</p>
<p><code>UIApplicationMain</code>的处理是如何进行的，取决于你的应用程序是使用旧的<code>window</code>架构还是新的<code>window</code>架构，它们将会是两种完全不同的启动过程。</p>
<h3 id="新架构">新架构</h3>
<p>以下是<code>UIApplicationMain</code>如何在<code>iOS 13</code>及更高版本上启动支持<code>window scene</code>的应用程序:</p>
<ol>
<li>
<p><code>UIAppplicationMain</code>首先实例化<code>UIApplication</code>，并保留这个实例，<!-- raw HTML omitted -->将其作为共享的实例<!-- raw HTML omitted -->，可以在代码中可以使用<code>UIApplication.shared</code>来访问。接着根据<code>@UIApplicationMain</code>或<code>@main</code>来实例化<code>AppDelegate</code>，并保留这个实例，使得它在应用程序中的整个生命周期中都存在，可以使用<code>UIApplication.shared.delegate</code>来访问。</p>
</li>
<li>
<p>接着<code>UIApplicationMain</code>会调用<code>AppDelegate</code>的<code>application(_:didFinishLaunchingWithOptions:)</code>方法，<!-- raw HTML omitted -->在这个方法中可以插入我们自己的代码<!-- raw HTML omitted -->。</p>
</li>
<li>
<p>然后<code>UIAppplicationMain</code>创建<code>UISceneSession</code>和<code>UIWindowScene</code>以及<code>UIWindwScene</code>代理类<code>UIWindowSceneDelegate</code>的实例。
<img src="https://i.loli.net/2021/06/14/iBw3vo62DLgqdSC.jpg" alt="-c"></p>
</li>
<li>
<p><code>UIAppplicationMain</code>查看初始<code>scene</code><!-- raw HTML omitted -->是否使用了<code>storyboard</code><!-- raw HTML omitted -->，即查看<code>info.plist</code>中<code>Application Scene Manifest</code>字典下的<code>Scene Configuration</code>是否有<code>Storyboard Name</code>。若有，则对<code>storybaord</code>中指定的初始<code>viewController</code>进行实例化。</p>
</li>
<li>
<p>如果<code>scene</code>使用了<code>storyboard</code>，<code>UIAppplicationMain</code>则会实例化一个<code>UIWindow</code>并将这个实例赋值给<code>SceneDelegate</code>的<code>window</code>属性。</p>
</li>
<li>
<p>如果<code>scene</code>使用了<code>storyboard</code>，则将<code>storyboard</code>中那个已经实例化的<!-- raw HTML omitted -->初始<!-- raw HTML omitted --><code>ViewController</code>赋值给上一步已经实例化<code>window</code>的<code>rootViewController</code>属性。此时，初始<code>ViewController</code>的<code>view</code>变成了<code>Window</code>的唯一子视图。</p>
</li>
<li>
<p><code>UIApplicationMain</code>通过调用<code>UIWindow</code>实例方法<code>makeKeyAndVisible</code>，使你的应用程序的界面出现。</p>
</li>
<li>
<p><code>scene</code>的<code>(_:willConnectTo:options:)</code>被调用，在这个方法中也可以插入自己的代码。</p>
</li>
</ol>
<p>如果<code>App</code>启动时未使用<code>storyboard</code>，也就是说在<!-- raw HTML omitted -->老的架构中<code>Info.plist</code>中没有<code>Main storyboard file base name</code>条目<!-- raw HTML omitted -->。而在新的架构中，这意味着在<code>Application Scene Manifest</code>字典的<code>Application Scene Configuration</code>下没有<code>Storyboard Name</code>条目。</p>
<p>此时需要在代码中完成有<code>storyboard</code>的情况下<!-- raw HTML omitted -->自动完成的所有事情<!-- raw HTML omitted -->。在旧的架构下，需要在<code>app delegate</code>的<code>application(_:didFinishLaunchingWithOptions:)</code>中做这些事情。</p>
<p>而在新的架构下，需要在<code>SceneDelegate</code>中的<code>scene（_:willConnectTo:options:）</code>方法做下面这些事情:</p>
<ol>
<li>
<p>创建一个<code>UIWindow</code>的实例，并且将其赋值给<code>SceneDelegate</code>的<code>window</code>属性。通过<!-- raw HTML omitted -->调用<code>UIWindow</code>的初始化方法<code>init(windowScene:)</code>使得<code>window</code>和<code>window scene</code>来建立连接<!-- raw HTML omitted -->。</p>
</li>
<li>
<p>初始化一个视图控制器，并根据需要对其进行设置。</p>
</li>
<li>
<p>将上一步实例化的视图控制器赋值给<code>window</code>的<code>rootViewController</code>属性。</p>
</li>
<li>
<p>调用<code>window</code>的<code>makeKeyAndVisible</code>进行显示。</p>
<p><img src="https://i.loli.net/2021/06/13/3Hik8Vt5TBoQ2uL.jpg" alt="-c"></p>
<p><img src="https://i.loli.net/2021/06/13/NRzKBDfkLiSstFe.jpg" alt="-c"></p>
</li>
</ol>
<h2 id="引用window">引用window</h2>
<p>一旦<code>app</code>运行，有多种方法引用<code>window</code>：➊从视图中引用；➋从<code>SceneDelegate</code>中引用；➌从<code>application</code>中引用。</p>
<h3 id="view">view</h3>
<p>如果一个视图在界面中，则该视图<!-- raw HTML omitted -->能通过自己的<code>window</code>属性引用到包含它的<code>window</code><!-- raw HTML omitted -->。你的代码可能会在一个有<code>main view</code>的视图控制器中运行，此时<code>self.view.window</code>是引用<code>window</code>的<!-- raw HTML omitted -->最佳方式<!-- raw HTML omitted -->。</p>
<p>也可以使用<code>UIView</code>的<code>window</code>属性<!-- raw HTML omitted -->来询问它是否最终被嵌入到<code>window</code>中<!-- raw HTML omitted -->。如果未嵌入到<code>window</code>中，则它的<code>window</code>属性为<code>nil</code>。一个<code>window</code>属性为<code>nil</code>的视图是<!-- raw HTML omitted -->对用户不可见的<!-- raw HTML omitted -->。</p>
<h3 id="scenedelegate-或appdelegate">sceneDelegate 或appDelegate</h3>
<p><code>SceneDelegate</code>实例保存了<code>window</code>的引用，可以通过<code>window</code>属性来访问。即使用<code>sceneDelegate.window</code>来访问。但访问<code>sceneDelegate</code>需要先使用<code>let sceneDelegate = UIApplication.shared.connectedScenes.first?.delegate as? SceneDelegate</code>来获取。</p>
<p>如果使用的是旧<code>window</code>架构，则需要使用<code>AppDelegate</code>来访问，即<code> UIApplication.shared.delegate?.window</code>。</p>
<h3 id="application">application</h3>
<p><!-- raw HTML omitted -->共享的<code>application</code>实例也保存了<code>window</code>的引用<!-- raw HTML omitted -->，可以通过其<code>window</code>属性来访问，即<code>let w = UIApplication.shared.windows.first!</code>。</p>
<h1 id="subview-and-superview">subview and superview</h1>
<p>在以前，一个视图<!-- raw HTML omitted -->恰好拥有自己的矩形区域，即任何不属于该视图的子视图的视图都不能出现在该视图的里面<!-- raw HTML omitted -->。因为当该视图重新绘制其矩形区域时，<!-- raw HTML omitted -->它会擦除其他视图的重叠部分<!-- raw HTML omitted -->。视图的子视图的任何部分都不能出现在它的外面，因为该视图对它自己的矩形区域负责，而不是其他。</p>
<p>从<code>macOS 10.5</code>开始，Apple为视图绘制引入了一个全新的架构，<!-- raw HTML omitted -->完全解除了上面的所说的那些限制<!-- raw HTML omitted -->。在<code>iOS</code>中，一个子视图的<!-- raw HTML omitted -->部分或全部可以出现在它的父视图之外<!-- raw HTML omitted -->，一个视图可以与另一个视图重叠，可以部分或全部画在它的前面，而不成为它的子视图。</p>
<p>如下图所示，有<code>3</code>个不同背景色的视图，每个视图和其他视图都有重叠。仅从视觉效果上是无法了解视图的层次结构的：</p>
<p><img src="https://i.loli.net/2021/06/26/7HWhtNXYSLz9U16.jpg" alt="-c"></p>
<p>一个视图<!-- raw HTML omitted -->在视图层次结构中的位置是非常重要的<!-- raw HTML omitted -->。首先，视图的层次结构决定了视图的绘制顺序。同一父视图的同级子视图有明确的绘制顺序：较早的同级子视图画在较晚的同级子视图之前，所以如果它们重叠，较早的子视图会出现在较晚的子视图后面。同样地，一个父视图被画在它的子视图之前，所以如果子视图与它们的父视图重叠，父视图就会出现在它们后面。</p>
<p>如果是在<code>storyboard</code>中创建的视图或者<code>nib</code>，则视图的层级结构可以通过菜单栏的<code>Editor--&gt;Arrange</code>下面的子选项来改变：</p>
<p><img src="https://i.loli.net/2021/06/26/BGSrqMRfnz1CVDh.jpg" alt="-c"></p>
<ul>
<li>
<p>如果一个视图从它的父视图中移除，则它的所有子视图也会被移除</p>
</li>
<li>
<p>一个视图的<!-- raw HTML omitted -->透明度会被它的子视图所继承<!-- raw HTML omitted -->。</p>
</li>
<li>
<p>视图可以选择性地限制其子视图的绘制，<!-- raw HTML omitted -->使其在视图之外的任何部分都不被显示<!-- raw HTML omitted -->，这就是所谓的剪裁，<!-- raw HTML omitted -->可以通过视图的<code>clipsToBounds</code>属性来设置<!-- raw HTML omitted -->。</p>
</li>
<li>
<p>在内存管理的意义上，父视图拥有它的子视图，就像一个数组拥有它的元素一样：它保留它的子视图，并且当一个子视图从这个视图的子视图集合中移除时，或者当父级视图本身不存在时，才会释放该子视图。</p>
</li>
<li>
<p>如果一个视图的大小改变了，它的子视图也可能会自动调整大小。</p>
</li>
</ul>
<p>每个视图均有<code>superview</code>和<code>subviews</code>属性，使用这两个属性可以<!-- raw HTML omitted -->追踪视图的层次结构<!-- raw HTML omitted -->。使用视图的<code>isDescendant(of:)</code>方法可以判断一个视图是否是另一个视图的子视图（任意深度）。</p>
<p>如果想要<!-- raw HTML omitted -->引用特定的某个视图<!-- raw HTML omitted -->，可能需要为视图事先安排一个标记，<!-- raw HTML omitted -->可以是<code>outlet</code><!-- raw HTML omitted -->；也可以为视图<!-- raw HTML omitted -->事先设置<code>tag</code>属性值<!-- raw HTML omitted -->，然后通过调用<code>viewWithTag(_:)</code>来获取该特定的视图。</p>
<p>视图的添加、删除和移动等都有相应的事件，<!-- raw HTML omitted -->这些事件的响应需要子类化<!-- raw HTML omitted -->。然后通过覆盖如下的方法便可以看到对应的调用：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift">willRemoveSubview(<span style="color:#66d9ef">_</span>:)
didAddSubview(<span style="color:#66d9ef">_</span>:)
willMove(toSuperview:)
didMoveToSuperview
willMove(toWindow:)
didMoveToWindow
</code></pre></div><p>如果<code>addSubview(_:)</code>被调用，则视图将放在父视图的所有子视图的最后边「即最上边」，也就是最后才绘制，这意味着<!-- raw HTML omitted -->它将出现在最前面<!-- raw HTML omitted -->。</p>
<p>视图的<!-- raw HTML omitted -->子视图是有索引的<!-- raw HTML omitted -->，从0开始。可以在给定的索引或特定视图的下面（后面）或上面（前面）插入一个子视图；也可以通过索引交换两个同级视图；还可以将一个子视图一直移动到其同级的前面或后面。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift">insertSubview(<span style="color:#66d9ef">_</span>:at:)
insertSubview(<span style="color:#66d9ef">_</span>:belowSubview:)
insertSubview(<span style="color:#66d9ef">_</span>:aboveSubview:)
exchangeSubview(at:withSubviewAt:)
bringSubviewToFront(<span style="color:#66d9ef">_</span>:)
sendSubviewToBack(<span style="color:#66d9ef">_</span>:)
</code></pre></div><p>但是，<!-- raw HTML omitted -->没有提供一次性删除一个视图的所有子视图的方法<!-- raw HTML omitted -->。一个视图的子视图数组是内部子视图列表的一个不可变的副本。因此，需要使用<code>for</code>循环来删除所有子视图：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift">myView.subviews.forEach {$0.removeFromSuperview()}
</code></pre></div><h2 id="color">color</h2>
<p>视图可以通过其<code>backgroundColor</code>属性设置一个背景色，<!-- raw HTML omitted -->如果<code>backgroundColor</code>属性值为<code>nil</code>，则视图的背景色为透明<!-- raw HTML omitted -->。<code>backgroundColor</code>即是<code>UIColor</code>的实例，通常使用<code>red,blue,green</code>和<code>alpha</code>（其值为<code>0~1</code>）来定义：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift">v.backgroundColor = UIColor(red: <span style="color:#ae81ff">0</span>, green: <span style="color:#ae81ff">0.1</span>, blue: <span style="color:#ae81ff">0.1</span>, alpha: <span style="color:#ae81ff">1</span>)
</code></pre></div><p>自<code>iOS 13</code>开始出现了深色模式，为了适配需要使用<!-- raw HTML omitted -->动态颜色<!-- raw HTML omitted -->，即使用<code>UIColor</code>的初始化函数<code>init(dynamicProvider:)</code>来进行适配，下面是创建一个自定义的动态颜色：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift">v1.backgroundColor = UIColor { tc <span style="color:#66d9ef">in</span>
    <span style="color:#66d9ef">switch</span> tc.userInterfaceStyle {
    <span style="color:#66d9ef">case</span> .dark:
        <span style="color:#66d9ef">return</span> UIColor(red: <span style="color:#ae81ff">0.3</span>, green: <span style="color:#ae81ff">0.4</span>, blue: <span style="color:#ae81ff">0.4</span>, alpha: <span style="color:#ae81ff">1</span>)
    <span style="color:#66d9ef">case</span> .light:
        <span style="color:#66d9ef">return</span> UIColor(red: <span style="color:#ae81ff">0</span>, green: <span style="color:#ae81ff">0.1</span>, blue: <span style="color:#ae81ff">0.1</span>, alpha: <span style="color:#ae81ff">1</span>)
    }
}
</code></pre></div><p>从<code>iOS 13</code>开始，系统提供了许多预置的动态颜色，其中大部分的名称都是以<code>.system</code>开头的，比如<code>.systemYellow</code>，其它的则是描述其作用的语义名称，比如<code>.label</code>。</p>
<p>现在可以在资产目录中设计一个自定义命名的颜色。当创建一个新的颜色集时，属性检查器中的 「外观」弹出菜单显示为「任意」、「暗色」，并且有两个颜色色块，一个用于深色模式，另一个用于其它一切；依次选择每个色块并在属性检查器中设计颜色：</p>
<p><img src="https://i.loli.net/2021/06/27/knrG5zj296RLqmD.jpg" alt="-c"></p>
<p>上面自定义命名的颜色，就是动态的。比方说，我们在资产目录中的颜色集被称为<code>myDarkColor</code>，那么可以使用如下方式使用:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift">v.backgroundColor = UIColor(named: <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">myDarkColor</span><span style="color:#e6db74">&#34;</span>)
</code></pre></div><p>当你选择一个视图时，资产目录中的自定义命名颜色也会出现在库中和属性检查器中的颜色弹出菜单中，如下图所示：</p>
<p><img src="https://i.loli.net/2021/06/27/6S3L2ejsEcHtanC.jpg" alt="-c"></p>
<h1 id="可见性和透明度">可见性和透明度</h1>
<p>视图的可见性和不透明度与<code>3</code>个属性相关，它们分别是<code>isHidden</code>，<code>alpha</code>和<code>isOpaque</code>，下面开始逐个介绍。</p>
<h2 id="ishidden">isHidden</h2>
<p>视图可以通过将<code>isHidden</code>属性设置为<code>true</code>而变得不可见，并通过将其设置为<code>false</code> 而再次变成可见，因为隐藏视图并不会导致该视图从其层级结构中删除。<!-- raw HTML omitted -->被隐藏的视图（通常）不会收到触摸事件<!-- raw HTML omitted -->，所以对用户来说，就如同该视图不存在一样。</p>
<h2 id="alpha">alpha</h2>
<p>一个视图可以通过其<code>alpha</code>属性使其部分或完全透明。<code>alpha</code>属性的取值可以在<code>0～1.0</code>，<code>1.0</code>表示完全不透明，<code>0.0</code>表示完全透明。<code>alpha</code>属性既能影响视图的背景色也会影响其内容的透明度。</p>
<p>如果一个视图中显示了一个图像，并且有一个背景颜色，而它的<code>alpha</code>值小于<code>1.0</code>，那么<!-- raw HTML omitted -->背景颜色就会渗入到这个图像中<!-- raw HTML omitted -->。</p>
<p>如果一个父视图的<code>alpha</code>值为<code>0.5</code>，则它的所有子视图的<code>alpha</code>都将小于<code>0.5</code>，因为无论这些子视图的<code>alpha</code>属性值是多少，都是相对于父视图的<code>0.5</code>来进行绘制的。</p>
<p>一个完全透明（或非常接近完全透明）的视图就像一个<code>isHidden</code>为<code>true</code>的视图：它和它的子视图都是不可见的，而且（通常）不能被触摸到。</p>
<p>颜色也有一个<code>alpha</code>属性，这个值对于视图也有影响。一个视图的<code>alpha</code>值可以是<code>1.0</code>，但仍然可能有一个透明的背景色，因为它的背景颜色的<code>alpha</code>值可能小于<code>1.0</code>。</p>
<h2 id="isopaque">isOpaque</h2>
<p><code>isOpaque</code>属性不同于<code>isHidden</code>和<code>alpha</code>，改变<code>isOpaque</code>属性值<!-- raw HTML omitted -->对视图的外观没有影响，只是对视图系统的绘制提示<!-- raw HTML omitted -->。</p>
<p>如果一个视图完全由不透明的物质填充并且它的<code>alpha</code>属性设置为<code>1.0</code>，那么视图就是完全不透明的，此时如果将视图的<code>isOpaque</code>属性设置为<code>true</code>，就可以更有效地进行绘制（<!-- raw HTML omitted -->对性能的拖累更小<!-- raw HTML omitted -->），否则应当将<code>isOpaque</code>设置为<code>false</code>。</p>
<p>当设置<code>isHidden</code>和<code>alpha</code>的值时，<code>isOpaque</code>属性值<!-- raw HTML omitted -->并不会跟着变化<!-- raw HTML omitted -->。<code>isOpaque</code>属性值的设置完全取决你自己，它的默认值为<code>true</code>。</p>
<h1 id="frame">Frame</h1>
<p>每个<code>view</code>都有<code>frame</code>属性（是一个由<code>CGRect</code>表示的矩形，表示在<!-- raw HTML omitted -->父视图的坐标系统中的位置<!-- raw HTML omitted -->。默认情况下，父视图的坐标系将以左上角为原点，<code>X</code>坐标向右正向增长，<code>Y</code>坐标向下正向增长。</p>
<p>设置视图的<code>frame</code>值<!-- raw HTML omitted -->既可以重新改变视图的位置，也可以调整视图的大小，或者同时改变位置和大小<!-- raw HTML omitted -->。<code>UIView</code>的指定初始化方法是<code>init(frame:)</code>，可以通过这种方式指定视图的<code>frame</code>。若视图的<code>frame</code>属性值为<code>CGRect.zero</code>的话，则视图是不可见。</p>
<p>如果一个视图有一个你希望它采用的标准尺寸，特别是相对于它的内容（例如<code>UIButton</code>相对于它的标题）而言，除了改变<code>frame</code>，还可以调用其<code>sizeToFit</code>方法。</p>
<p>如果一个视图使用<code>nib</code>进行初始化，<!-- raw HTML omitted -->那么不会调用其<code>init(frame:)</code>，调用的为<code>init(coder:)</code>方法<!-- raw HTML omitted -->。</p>
<h1 id="bounds-and-center">Bounds and Center</h1>
<h2 id="bounds">Bounds</h2>
<p>如下图所示，假设有一个父视图和子视图，子视图需要有<code>10</code>个<code>point</code>的镶边，首先想到的是设置子视图的<code>frame</code>，但该怎么设置？</p>
<p><img src="https://i.loli.net/2021/06/13/QWCVUiwYv8MarSI.jpg" alt="-c"></p>
<p><code>CGRect</code>有个<code>insetBy(dx:dy:)</code>方法可以从一个矩形中衍生出另一个矩形并嵌入。但是应该从哪个矩形中嵌入呢？不是从父视图的<code>frame</code>，因为<code>frame</code>代表一个视图在其父视图中的位置，并且是父视图的坐标系中的位置。</p>
<p>应当找一个用来描述在其自身坐标中与父视图矩形相关的<code>CGRect</code>，因为这是子视图的<code>frame</code>所要表达的坐标。描述视图在其自身坐标中的矩形<code>CGRect</code>是视图的<code>bounds</code>属性。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#66d9ef">let</span> v1 = UIView(frame:CGRect(<span style="color:#ae81ff">113</span>, <span style="color:#ae81ff">111</span>, <span style="color:#ae81ff">132</span>, <span style="color:#ae81ff">194</span>)) 
v1.backgroundColor = UIColor(red: <span style="color:#ae81ff">1</span>, green: <span style="color:#ae81ff">0.4</span>, blue: <span style="color:#ae81ff">1</span>, alpha: <span style="color:#ae81ff">1</span>) 
<span style="color:#66d9ef">let</span> v2 = UIView(frame:v1.bounds.insetBy(dx: <span style="color:#ae81ff">10</span>, dy: <span style="color:#ae81ff">10</span>)) 
v2.backgroundColor = UIColor(red: <span style="color:#ae81ff">0.5</span>, green: <span style="color:#ae81ff">1</span>, blue: <span style="color:#ae81ff">0</span>, alpha: <span style="color:#ae81ff">1</span>)
<span style="color:#66d9ef">self</span>.view.addSubview(v1) 
v1.addSubview(v2) 
</code></pre></div><p><img src="https://i.loli.net/2021/06/13/QWCVUiwYv8MarSI.jpg" alt="-c"></p>
<p>如果改变一个视图的<code>bounds</code>的<code>size</code>，那么它的<code>frame</code>也会发生变化。视图的<code>frame</code>的变化是围绕其<code>center</code>来的&mdash;<!-- raw HTML omitted -->中心点不变<!-- raw HTML omitted -->。下面的代码只出现一个矩形，子视图完全覆盖父视图：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#66d9ef">let</span> v1 = UIView(frame:CGRect(<span style="color:#ae81ff">113</span>, <span style="color:#ae81ff">111</span>, <span style="color:#ae81ff">132</span>, <span style="color:#ae81ff">194</span>)) 
v1.backgroundColor = UIColor(red: <span style="color:#ae81ff">1</span>, green: <span style="color:#ae81ff">0.4</span>, blue: <span style="color:#ae81ff">1</span>, alpha: <span style="color:#ae81ff">1</span>) 
<span style="color:#66d9ef">let</span> v2 = UIView(frame:v1.bounds.insetBy(dx: <span style="color:#ae81ff">10</span>, dy: <span style="color:#ae81ff">10</span>)) 
v2.backgroundColor = UIColor(red: <span style="color:#ae81ff">0.5</span>, green: <span style="color:#ae81ff">1</span>, blue: <span style="color:#ae81ff">0</span>, alpha: <span style="color:#ae81ff">1</span>)
<span style="color:#66d9ef">self</span>.view.addSubview(v1) 
v1.addSubview(v2) 
v2.bounds.size.height <span style="color:#f92672">+=</span> <span style="color:#ae81ff">20</span> 
v2.bounds.size.width <span style="color:#f92672">+=</span> <span style="color:#ae81ff">20</span>
</code></pre></div><p><img src="https://i.loli.net/2021/06/13/HMi89mERjtUOfIZ.jpg" alt="-c"></p>
<p>如果改变一个视图的<code>bounds</code>原点，就会移动其内部坐标系的原点。当创建一个<code>UIView</code>时，它的边界坐标系的原点<code>(0.0,0.0)</code>就在它的左上方。因为一个子视图是相对于它的父视图的坐标系定位的，所以父视图的边界原点的改变也会改变子视图的显示位置，如下代码会导致父视图的大小和位置没有发生任何变化，但是子视图已经向左上角移动了：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#66d9ef">let</span> v1 = UIView(frame:CGRect(<span style="color:#ae81ff">113</span>, <span style="color:#ae81ff">111</span>, <span style="color:#ae81ff">132</span>, <span style="color:#ae81ff">194</span>)) 
v1.backgroundColor = UIColor(red: <span style="color:#ae81ff">1</span>, green: <span style="color:#ae81ff">0.4</span>, blue: <span style="color:#ae81ff">1</span>, alpha: <span style="color:#ae81ff">1</span>) 
<span style="color:#66d9ef">let</span> v2 = UIView(frame:v1.bounds.insetBy(dx: <span style="color:#ae81ff">10</span>, dy: <span style="color:#ae81ff">10</span>)) 
v2.backgroundColor = UIColor(red: <span style="color:#ae81ff">0.5</span>, green: <span style="color:#ae81ff">1</span>, blue: <span style="color:#ae81ff">0</span>, alpha: <span style="color:#ae81ff">1</span>) 
<span style="color:#66d9ef">self</span>.view.addSubview(v1) 
v1.addSubview(v2) 
v1.bounds.origin.x <span style="color:#f92672">+=</span> <span style="color:#ae81ff">10</span> 
v1.bounds.origin.y <span style="color:#f92672">+=</span> <span style="color:#ae81ff">10</span>
</code></pre></div><p><img src="https://i.loli.net/2021/06/13/9wZkBVegPQyscpd.jpg" alt="-c"></p>
<h2 id="center">center</h2>
<p>同样地，<!-- raw HTML omitted -->若改变一个视图的<code>frame</code>属性的<code>size</code>值，也会改变其<code>bounds</code>属性的<code>size</code>值<!-- raw HTML omitted -->。但是，改变<code>bounds</code>的<code>size</code>大小时，不会改变其<code>center</code>属性。</p>
<p><!-- raw HTML omitted --><code>center</code>代表子视图在父视图坐标系中的位置<!-- raw HTML omitted -->，确切地说，它表示子视图的<code>bounds center</code>在父视图中的位置：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#66d9ef">let</span> c = CGPoint(theView.bounds.midX, theView.bounds.midY)
</code></pre></div><p>改变视图的<code>bounds</code>不会改变的它的<code>center</code>，相应地改变视图的<code>center</code>不会改变<code>bounds</code>。即视图的<code>center</code>和<code>bounds</code>是<!-- raw HTML omitted -->相互独立的<!-- raw HTML omitted -->。<code>bounds</code>用于描述视图的大小，<code>center</code>用于描述视图在父视图中的位置。</p>
<p>实际上<!-- raw HTML omitted -->视图的<code>frame</code>属性是<code>bounds</code>和<code>center</code>的简便形式<!-- raw HTML omitted -->。当改变视图的<code>frame</code>属性时，<code>bounds</code>和<code>center</code>也会随之发生变化，当改变<code>bounds</code>和<code>center</code>时，视图的<code>frame</code>也会随之发生改变。尽管如此，调整一个视图在父视图中的<!-- raw HTML omitted -->可靠方式是使用<code>bounds</code>和<code>center</code>属性<!-- raw HTML omitted -->。</p>
<p>每个视图都有自己的坐标系统（使用<code>bounds</code>来表达），并且一个视图坐标系统的与它的父视图的坐标系统有一个明确的关系，即<code>center</code>属性。因此，可以在同一窗口中的任何两个视图的坐标之间进行转换：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift">open <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">convert</span>(<span style="color:#66d9ef">_</span> point: CGPoint, to view: UIView?) -&gt; CGPoint
open <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">convert</span>(<span style="color:#66d9ef">_</span> point: CGPoint, from view: UIView?) -&gt; CGPoint
open <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">convert</span>(<span style="color:#66d9ef">_</span> rect: CGRect, to view: UIView?) -&gt; CGRect
open <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">convert</span>(<span style="color:#66d9ef">_</span> rect: CGRect, from view: UIView?) -&gt; CGRect
</code></pre></div><p>在<code>convert</code>方法中，第一个参数既可以是<code>CGPoint</code>也可以是<code>CGRect</code>，第二个参数是<code>UIView</code>，如果第二个参数为<code>nil</code>，则会认为是<code>window</code>。下面的例子是将<code>v2</code>放到<code>v1</code>的中心：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift">v2.center = v1.convert(v1.center, from:v1.superview)
</code></pre></div><p>另外一种更常见的方式是将子视图的中心放在父视图<code>bounds</code>的中心位置，如下所示：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift">v2.center = CGPoint(v1.bounds.midX,v1.bounds.midY)
</code></pre></div><h1 id="transform">transform</h1>
<h2 id="transform-1">transform</h2>
<p>视图的<code>transform</code>属性可以改变视图的绘制方式，显示大小，位置和方向，<!-- raw HTML omitted -->但不会改变<code>bounds</code>和<code>center</code>属性<!-- raw HTML omitted -->。<code>transform</code>属性值是一个<code>CGAffineTransform</code>结构体，代表代表3×3变换矩阵9个值中的6个（另外3个值是常数，所以没有必要在结构中表示它们）：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">CGAffineTransform</span> {

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">var</span> a: CGFloat

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">var</span> b: CGFloat

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">var</span> c: CGFloat

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">var</span> d: CGFloat

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">var</span> tx: CGFloat

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">var</span> ty: CGFloat

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">init</span>()

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">init</span>(a: CGFloat, b: CGFloat, c: CGFloat, d: CGFloat, tx: CGFloat, ty: CGFloat)
}
</code></pre></div><p>默认情况下，一个视图的变换矩阵是<code>CGAffineTransform.identity</code>，即同一变换，它没有可见的效果，所以你不知道它的存在。任何变换都是<!-- raw HTML omitted -->围绕视图的中心进行的，这个中心点一定是保持不变的<!-- raw HTML omitted -->。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#66d9ef">let</span> v1 = UIView(frame:CGRect(<span style="color:#ae81ff">113</span>, <span style="color:#ae81ff">111</span>, <span style="color:#ae81ff">132</span>, <span style="color:#ae81ff">194</span>)) 
v1.backgroundColor = UIColor(red: <span style="color:#ae81ff">1</span>, green: <span style="color:#ae81ff">0.4</span>, blue: <span style="color:#ae81ff">1</span>, alpha: <span style="color:#ae81ff">1</span>) 
<span style="color:#66d9ef">let</span> v2 = UIView(frame:v1.bounds.insetBy(dx: <span style="color:#ae81ff">10</span>, dy: <span style="color:#ae81ff">10</span>)) 
v2.backgroundColor = UIColor(red: <span style="color:#ae81ff">0.5</span>, green: <span style="color:#ae81ff">1</span>, blue: <span style="color:#ae81ff">0</span>, alpha: <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">self</span>.view.addSubview(v1) 
v1.addSubview(v2) 
v1.transform = CGAffineTransform(rotationAngle: <span style="color:#ae81ff">45</span> <span style="color:#f92672">*</span> .pi<span style="color:#f92672">/</span><span style="color:#ae81ff">180</span>) print(v1.frame)
</code></pre></div><h2 id="transform3d">transform3D</h2>
<p>从<code>iOS 13</code>开始，视图有一个新的<code>transform3D</code>属性。这个属性其实是底层<code>layer</code>的<code>transform</code>属性，现在通过视图暴露出来了。</p>
<h1 id="window坐标和屏幕座标">Window坐标和屏幕座标</h1>
<p>设备的屏幕没有<code>frame</code>，但有<code>bounds</code>。<code>window</code>没有父视图，但是<!-- raw HTML omitted -->它的<code>frame</code>是自动和设备屏幕的<code>bounds</code>相匹配的<!-- raw HTML omitted -->。<code>window</code>一般一开始就填满屏幕，并且通常会继续填满屏幕，因此<!-- raw HTML omitted -->大多数情况下，窗口坐标就是屏幕坐标<!-- raw HTML omitted -->。</p>
<p>在<code>iOS 7</code>及之前，屏幕坐标是不变的，<code>transform</code>属性是应用旋转能力的核心：因为<code>window</code>的<code>frame</code>和<code>bounds</code>被锁定在屏幕上，应用的界面通过对根视图应用旋转变换来补偿设备方向的变化，从而使其原点移动到用户现在看到的视图的左上方。</p>
<p>但<code>iOS 8</code>引入了一个重大变化：当应用程序旋转以补偿设备的旋转时，屏幕（以及随之而来的窗口）是旋转的。当应用程序的界面旋转时，故事中的任何视图&ndash;无论是窗口、根视图还是其任何子视图&ndash;都没有收到旋转变换。取而代之的是屏幕边界尺寸的换位（以及窗口边界和根视图边界尺寸的相应换位）：在纵向方向上，尺寸是高过宽，但在横向方向上，尺寸是宽过高。</p>
<h1 id="trait-collections">Trait Collections</h1>
<p>由于视图所处的大环境<!-- raw HTML omitted -->具有动态性质<!-- raw HTML omitted -->。如果有一个描述环境的对象，<!-- raw HTML omitted -->它可以通过视图控制器和视图的层次结构向下传播，同时也可以提醒该层次结构中的每个元素环境已经改变<!-- raw HTML omitted -->，是非常有用的。实际上，这是通过<code>trait collection</code>来管理的。</p>
<p><code>trait collection</code>源于屏幕（即<code>UIScreen</code>），并通过<code>window</code>和视图控制器一路向下，直到每个单独的子视图。所有相关的类（<code>UIScreen</code>、<code>UIViewController</code>和<code>UIPresentationController</code>以及<code>UIView</code>）都实现了<code>UITraitEnvironment</code>协议，它提供了<code>traitCollection</code>属性和<code>traitCollectionDidChange</code>方法。</p>
<p><code>traitCollection</code>是<code>UITraitCollection</code>类型，属于值类型，它带有相当数量的描述环境的属性。例如，<code>displayScale</code>能告诉你屏幕分辨率，<code>userInterfaceIdiom</code>说明设备类型&ndash;<code>iPhone</code>或<code>iPad</code>，它还能报告诸如设备的强制触摸能力和显示色域等等。</p>
<p>当<code>app</code>运行时，如果<code>traitCollection</code>的任何属性发生变化，<code>traitCollectionDidChange(_:)</code>消息就会在<code>UITraitEnvironments</code>的层次结构中传播，旧的特性集合（如果有的话）被作为参数提供，新的特性集合可以作为<code>self.traitCollection</code>被检索。</p>
<p>如果要实现<code>traitCollectionDidChange(_:)</code>方法，首先应该调用<code>super</code>的方法，对于一个初学者来说，很容易忘记调用对应的<code>super</code>方法：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#66d9ef">override</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">traitCollectionDidChange</span>(<span style="color:#66d9ef">_</span> previousTraitCollection: UITraitCollection?) {
    <span style="color:#66d9ef">super</span>.traitCollectionDidChange(previousTraitCollection)
}
</code></pre></div><p>我们也可以构造自己的<code>traitCollection</code>，但<!-- raw HTML omitted -->不能直接<!-- raw HTML omitted -->设置任何<code>traitCollection</code>的属性值。可以通过<code>init</code>方法构造一个<code>traitCollection</code>，但是<!-- raw HTML omitted -->初始化器每次只能确定一个属性<!-- raw HTML omitted -->。如果想进一步增加属性值，可以通过调用<code>init(traitsFrom:)</code>初始化器，将一个<code>traitCollection</code>数组传入以组合成新的<code>traitCollection</code>，如下所示：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#66d9ef">let</span> tcdisp = UITraitCollection(displayScale: UIScreen.main.scale)
<span style="color:#66d9ef">let</span> tcphone = UITraitCollection(userInterfaceIdiom: .phone)
<span style="color:#66d9ef">let</span> tc1 = UITraitCollection(traitsFrom: [tcdisp, tcphone])
</code></pre></div><p>初始化器<code>init(traitsFrom:)</code>中<!-- raw HTML omitted -->数组的工作方式与继承类似——进行有序的交叉<!-- raw HTML omitted -->。如果两个<code>traitCollection</code>被合并，并且它们都设置了相同的属性，那么<!-- raw HTML omitted -->获胜者是出现在数组后面或继承层次结构中更远的<code>traitCollection</code><!-- raw HTML omitted -->。如果一个设置了一个属性，而另一个没有，那么设置该属性的那个就获胜。如果你创建了一个<code>traitCollection</code>，如果<code>traitCollection</code>在继承层次中，任何未指定的属性的值都将被继承。</p>
<p>如果需要比较<code>traitCollection</code>，可以调用<code>containsTraits(in:)</code>方法。如果参数<code>traitCollection</code>的每个属性的值与待比较的<code>traitCollection</code>中的属性值相匹配，则返回<code>true</code>。</p>
<p>对于<code>UIViews</code>来说，主要关注的<code>traitCollection</code>属性是是<code>interface style</code>和<code>size class</code>，所以接下来将会介绍这两者。</p>
<h1 id="interface-style">Interface Style</h1>
<p>使用<code>trait collection</code>中的属性值<code>userInterfaceStyle</code>来报告大环境是<code>light</code>模式还是<code>dark</code>模式。如果界面上使用的颜色是<!-- raw HTML omitted -->动态颜色<!-- raw HTML omitted -->，切换<code>userInterfaceStyle</code>时，则界面会自动更改颜色。</p>
<p>然而，在某些情况下，你可能会手动管理一些颜色，你会想知道什么时候<code>userInterfaceStyle</code>发生了变化，这样就可以改变颜色作为回应。</p>
<p>假如我们要把资产目录中一个自定义的动态颜色应用到视图的<code>borader</code>上。这实际上是在视图的<code>layer</code>上完成的，要求我们使用该颜色的<code>cgColor</code>属性:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#66d9ef">self</span>.otherView.layer.borderWidth = <span style="color:#ae81ff">4</span> 
<span style="color:#66d9ef">self</span>.otherView.layer.borderColor = UIColor(named: <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">myDarkColor</span><span style="color:#e6db74">&#34;</span>)?.cgColor
</code></pre></div><p>上面代码的问题是，无论是<code>layer</code>上还是颜色的<code>cgColor</code>都不知道任何关于<code>trait collection</code>的信息。所以这就需要我们监听<code>trait collection</code>的变化，并在知道<code>userInterfaceStyle</code>发生变化后再次使用我们的动态颜色。多亏了<code>trait collection</code>的<code>hasDifferentColorAppearance</code>方法，可以避免做不必要的工作：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#66d9ef">override</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">traitCollectionDidChange</span>(<span style="color:#66d9ef">_</span> prevtc: UITraitCollection?) {
    <span style="color:#66d9ef">super</span>.traitCollectionDidChange(prevtc)
    <span style="color:#66d9ef">if</span> prevtc?.hasDifferentColorAppearance(comparedTo: traitCollection) ?? <span style="color:#66d9ef">true</span> {
        otherView.layer.borderColor = UIColor(named: <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">myDarkColor</span><span style="color:#e6db74">&#34;</span>)?.cgColor
    }
}
</code></pre></div><p>请注意，在上面的代码中不必知道<code>userInterfaceStyle</code>目前到底取什么值，只需要把动态颜色的<code>cgColor</code>取出来使用即可。这是因为从<code>asset</code>目录中<code>UIColor(named: &quot;myDarkColor&quot;)</code><!-- raw HTML omitted -->访问动态颜色的行为是在先访问一个全局值<code>UITraitCollection.current</code>的情况下发生的<!-- raw HTML omitted -->。</p>
<p>在<code>traitCollectionDidChange</code>方法中和其他各种运行时正在绘制或执行布局的地方，这个值为我们自动设置，因此我们的动态颜色会在<code>userInterfaceStyle</code>变动时正确的取到，同时<code>cgColor</code>也能取到正确的值。在<code>UITraitCollection.current</code>没有被自动设置的情况下，我们可以自由地手动设置它，确保涉及动态颜色的后续操作将在正确的环境中进行。</p>
<p>同时，<code>trait collection</code>也是理解一个动态颜色到底是什么颜色的关键。<code>.systemYellow</code>是什么颜色？这取决于<code>trait collection</code>。所以要想知道动态颜色目前到底是怎么值，必须提供一个<code>trait collection</code>。这很容易，因为你可以创建一个<code>trait collection</code>，之后再调用 <code>resolvedColor</code>即可:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#66d9ef">let</span> yellow = UIColor.systemYellow
<span style="color:#66d9ef">let</span> light = UITraitCollection(userInterfaceStyle: .light)
<span style="color:#66d9ef">let</span> dark = UITraitCollection(userInterfaceStyle: .dark)
<span style="color:#66d9ef">let</span> yellowLight = yellow.resolvedColor(with: light) <span style="color:#75715e">//</span><span style="color:#75715e"> </span><span style="color:#75715e">1</span><span style="color:#75715e"> </span><span style="color:#75715e">0</span><span style="color:#75715e">.</span><span style="color:#75715e">8</span><span style="color:#75715e"> </span><span style="color:#75715e">0</span><span style="color:#75715e"> </span><span style="color:#75715e">1</span>
<span style="color:#66d9ef">let</span> yellowDark = yellow.resolvedColor(with: dark) <span style="color:#75715e">//</span><span style="color:#75715e"> </span><span style="color:#75715e">1</span><span style="color:#75715e"> </span><span style="color:#75715e">0</span><span style="color:#75715e">.</span><span style="color:#75715e">8</span><span style="color:#75715e">3</span><span style="color:#75715e">9</span><span style="color:#75715e">2</span><span style="color:#75715e">1</span><span style="color:#75715e">6</span><span style="color:#75715e"> </span><span style="color:#75715e">0</span><span style="color:#75715e">.</span><span style="color:#75715e">0</span><span style="color:#75715e">3</span><span style="color:#75715e">9</span><span style="color:#75715e">2</span><span style="color:#75715e">1</span><span style="color:#75715e">5</span><span style="color:#75715e">7</span><span style="color:#75715e"> </span><span style="color:#75715e">1</span>
</code></pre></div><p>除了<code>userInterfaceStyle</code>之外，<code>trait collection</code>还有一个<code>userInterfaceLevel</code>属性，它的取值为<code>.base</code>或<code>.elevated</code>。这个属性会影响到动态背景颜色，通常只有主界面前面的有限区域会受到影响。每个<code>Alert</code>都有一个<code>.elevated</code>界面级别，即使<code>Alert</code>后面的主界面没有。</p>
<h1 id="size-classes">Size Classes</h1>
<p>关于应用程序旋转和类似旋转，最重要的事实不是旋转本身，而是应用程序的<!-- raw HTML omitted -->尺寸比例<!-- raw HTML omitted -->的变化。想象一下，<code>root view</code>的一个子视图，当设备处于纵向时位于屏幕的右下方。如果根视图的边界宽度和边界高度被改变，那么这个子视图就会在边界高度之外，从而离开屏幕&ndash;除非你的应用程序以某种方式对这种变化做出反应，重新定位它（这样的反应被称为布局，这个主题将占据本章的大部分篇幅）。</p>
<p>环境的维度特征体现在一对<code>size classes</code>中，这对尺寸亦是<code>trait collection</code>属性值:<code>horizontalSizeClass</code>和<code>verticalSizeClass</code>：</p>
<p>上面的这两个属性都是<code>UIUserInterfaceSizeClsass</code>类型，取值为<code>.regular</code>和<code>.compact</code>。当应用程序的窗口占据整个屏幕时，这一对<code>size classes</code>有如下含义：</p>
<ol>
<li>在<code>iPad</code>上运行时，水平和垂直尺寸类都是<code>.regular</code>。</li>
<li>在<code>iPhone</code>上以<code>portrait</code>方向运行时，水平尺寸类是<code>.compact</code>，而垂直尺寸类是<code>.regular</code>。</li>
<li>在大的<code>iPhone</code>上以<code>landscape</code>方向运行时，水平尺寸类是<code>.regular</code>，而垂直尺寸类是<code>.compact</code>。大的手机是指<code>iPhone 6/7/8 Plus, iPhone XR, iPhone XS Max, iPhone 11, and iPhone 11 Pro Max</code></li>
<li>在小的<code>iPhone</code>上以<code>landscape</code>方向运行时，水平和垂直尺寸类都是<code>.regular</code>。</li>
</ol>
<p>从上面的情况来看，通过<code>traitCollectionDidChange</code>去监听<code>size classes</code>的变化，并不能知道界面是否已经旋转。<code>size classes</code>并不区分纵向的<code>iPad</code>和横向的<code>iPad</code>。它们区分的是最重要的极端情况：如果<code>horizontal size class</code>从<code>.regular</code>变成<code>.compact</code>，<code>App</code>会突然变得又高又窄，你可能想通过改变界面的某种方式来进行补偿。然而，根据我的经验，你通常不会为了监听<code>size classes</code>的变化而重写<code>traitCollectionDidChange</code>方法。相反，<code>size classes</code>是为了需要应对其他事件而监听。</p>
<h1 id="overriding-trait-collections">Overriding Trait Collections</h1>
<p>在某些情况下，隔断部分的<code>UITraitEnvironment</code>，并且谎报<code>trait collection</code>的内容是很有用的。因为，我们可能想让层次结构的一部分相信我们是在一个横向的<code>iPhone</code>上，而实际上我们是在一个纵向的<code>iPhone</code>上，或者你的应用程序的<!-- raw HTML omitted -->某些区域不应该对明暗模式之间的变化做出反应<!-- raw HTML omitted -->。</p>
<p>你不能仅仅通过设置视图的<code>trait collection</code>来直接将<code>trait collection</code>插入继承层次中，因为<code>traitCollection</code>不是一个可设置的属性。但是，在<code>UIViewController</code>中，你可以通过:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#66d9ef">override</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">overrideTraitCollection</span>(forChild childViewController: UIViewController) -&gt; UITraitCollection? {
    <span style="color:#75715e">//</span>
}
</code></pre></div><p>来注入你自己的<code>trait collection</code>。同样的<code>UIPresentationController</code>也有一个类似的方法。</p>
<p>对于<code>user interface style</code>,<code>UIViewController</code>和<code>UIView</code>有一个更简单的方式，即使用<code>override var overrideUserInterfaceStyle: UIUserInterfaceStyle</code>。其中<code>overrideUserInterfaceStyle</code>是一个<code>UIUserInterfaceStyle</code>实例，默认值是<code>.unspecified</code>，含义为<code>interface style</code>应该是按层次结构向下传递的。但是你一旦将它设置为<code>.light</code>或<code>.dark</code>，就会阻止从层次结构中的那一点开始，将原本只继承<code>trait collection</code>的<code>userInterfaceStyle</code>属性，替代成自定义设置。</p>
<h1 id="layout">layout</h1>
<p>当一个父视图的边界原点改变时，子视图会随着移动。但是，当父视图的尺寸改变时，子视图会发生什么变化呢？</p>
<p>实际上是什么也没发生变化，子视图的边界和中心没有改变，父视图的边界原点也没有移动，所以子视图保持在相对于其父视图左上方的相同位置。在现实生活中，这通常不是你想要的结果。你会<!-- raw HTML omitted -->希望子视图在其超视图的尺寸发生变化时能被调整大小和重新定位，这就是所谓的布局<!-- raw HTML omitted -->。</p>
<p>以下是父视图可能被动态调整大小的方式：</p>
<ul>
<li>
<p>你的应用程序可能会通过旋转自己来补偿用户将设备旋转<code>90</code>度，使其顶部移动到屏幕的新顶部，以匹配其新的方向&ndash;因此，其边界的宽度和高度值会被移位。</p>
</li>
<li>
<p>一个iPhone应用程序可能会在不同长宽比的屏幕上启动：例如，iPhone SE的屏幕比后来的iPhone型号的屏幕相对较短，应用程序的界面可能需要适应这种差异。</p>
</li>
<li>
<p>一个通用的应用程序可能在<code>iPad</code>或<code>iPhone</code>上启动。应用程序的界面可能需要适应它所运行的屏幕的大小。</p>
</li>
<li>
<p>从<code>nib</code>实例化的视图，如视图控制器的主视图或表视图单元，可能会被调整大小以适应它所处的界面。</p>
</li>
<li>
<p>视图可能会对其周围视图的变化做出反应。例如，当一个导航栏被动态地显示或隐藏时，其余的界面可能会缩小或增长来补偿，以填补可用空间。</p>
</li>
<li>
<p>用户可能会在<code>iPad上</code>改变你的应用程序窗口的宽度，作为<code>iPad</code>多任务界面的一部分。</p>
</li>
</ul>
<p>在上述任何一种情况下以及其他情况下，可能都需要进行布局。视图的子视图如果尺寸发生了变化，就需要移位、改变尺寸、重新分布，或者以其他方式进行补偿，以便界面看起来还不错，并保持可用。</p>
<p>布局通常有3种基本的方式：</p>
<ul>
<li>
<p>手动布局：每当父视图被调整大小时，它就会发送<code>layoutSubviews</code>消息。所以，要手动布局子视图，请提供你自己的子类并重写<code>layoutSubviews</code>。很明显，这可能会带来很多工作，但这意味着你可以做任何你喜欢的事情。</p>
</li>
<li>
<p>自动调整大小：自动调整大小是自动执行布局的最古老的方式。当它的上层视图被调整大小时，子视图将按照它自己的<code>autoresizingMask</code>属性值所规定的规则进行响应，该属性<!-- raw HTML omitted -->描述了子视图和它的上层视图之间的大小调整关系<!-- raw HTML omitted -->。</p>
</li>
<li>
<p>自动布局：自动布局依赖于视图的约束。约束是一个成熟的对象，它的数值描述了一个视图的尺寸或位置的某些方面，<!-- raw HTML omitted -->通常是就其他视图而言的<!-- raw HTML omitted -->。它比<code>autoresizingMask</code>更复杂，描述性更强。多个约束可以适用于单个视图，它们可以描述任何两个视图之间的关系（不仅仅是一个子视图和它的上层视图）。自动布局是在<code>layoutSubviews</code>的幕后实现的。实际上，约束允许你在没有代码的情况下编写复杂的<code>layoutSubviews</code>功能。</p>
</li>
</ul>
<p>你的布局策略可以使用上面3种的任何组合。需要手动布局的情况很少，但如果你需要，你可以实现它。自动调整大小是默认的。自动布局是自动调整大小的替代选择。但在现实生活中，很可能你的所有视图都会选择加入自动布局，因为它非常强大，最适合帮助你的界面适应很大的屏幕尺寸范围。<!-- raw HTML omitted -->视图的默认布局行为取决于它的创建方式<!-- raw HTML omitted -->：</p>
<ul>
<li>
<p>如果是从代码中创建的视图，默认情况下使用自动调整大小，而不是自动布局。如果你想让这样的视图使用自动布局，你必须故意抑制它对自动调整大小的使用。</p>
</li>
<li>
<p>所有新的<code>.storyboard</code>和<code>.xib</code>文件都选择加入自动布局。他们的视图已经准备好自动布局。但如果你愿意，<code>nib</code>编辑器中的视图仍然可以使用自动调整大小。</p>
</li>
</ul>
<h1 id="autoresizing">Autoresizing</h1>
<p>自动调整大小是在概念上指定一个子视图 &ldquo;弹簧和支杆&quot;的问题。弹簧可以膨胀和收缩；支杆则不能。弹簧和支杆可以在内部或外部、水平或垂直地分配。有了两个内部弹簧或支杆，你就可以指定视图是否可以以及如何调整大小；有了四个外部弹簧或支杆，你就可以指定视图是否可以以及如何重新定位。</p>
<ul>
<li>
<p>一个子视图在其上层视图中居中，并保持居中，但随着上层视图的调整而调整自己的大小。它在外部有四个支柱，内部有两个弹簧。</p>
</li>
<li>
<p>一个子视图在它的超视图中居中，并保持居中，而且不会随着父视图的调整而调整自己的大小。它在外部有四个弹簧，内部有两个支柱。</p>
</li>
<li>
<p>一个OK按钮要停留在其超级视图的右下方。它内部有两个支柱，外部有两个来自其右侧和底部的支柱，外部有两个来自其顶部和左侧的弹簧。</p>
</li>
<li>
<p>一个文本字段要保持在其超视图的顶部。它将随着超视图的扩大而扩大。它的外部有三根支柱，底部有一个弹簧；内部有一个垂直支柱和一个水平弹簧。</p>
</li>
</ul>
<p>在代码中，弹簧和支杆的组合是通过视图的<code>autoresizingMask</code>属性来设置的，它是一个位掩码（<code>UIView.AutoresizingMask</code>），这样你就可以组合选项。选项代表弹簧，没有指定的都是<code>strut</code>。默认是空集，显然是指所有的<code>struts</code>&ndash;但当然不可能真的是所有的<code>struts</code>，因为如果父视图被调整大小，就需要改变一些东西，所以实际上空的<code>autoresizingMask</code>与<code>.flexibleRightMargin</code>和<code>.flexibleBottomMargin</code>一样，意味着视图被<code>struts</code>钉在左上方。</p>
<p>在<code>debug</code>的时候，当你把一个<code>UIView</code>打印到控制台时，它的<code>autoresizingMask</code>会用<code>autoresize</code>这个词和一个弹簧的列表来报告。外部弹簧是LM、RM、TM和BM；内部弹簧是W和H。<code>autoresize = LM+TM</code>意味着有来自左侧和顶部的外部弹簧；<code>autoresize = W+BM</code>意味着有一个内部水平弹簧和一个来自底部的弹簧。</p>
<h1 id="autolayout-and-constraints">Autolayout and Constraints</h1>
<p>在单独的视图层面，<!-- raw HTML omitted -->自动布局是一种可选的技术<!-- raw HTML omitted -->。可以在同一界面的不同区域使用自动调整大小和自动布局；一个同级视图可以使用自动布局，而另一个同级视图不使用；一个父视图可以使用自动布局，而其部分或全部子视图不使用。</p>
<p>但是，自动布局是通过父视图链来实现的，<!-- raw HTML omitted -->如果一个视图使用了自动布局，那么它的所有父视图也会使用自动布局<!-- raw HTML omitted -->。如果（几乎可以肯定的是）这些视图中的一个是视图控制器的主视图，那么该视图控制器就会收到自动布局相关的事件。</p>
<h1 id="view-controllers">view Controllers</h1>
<p>视图控制器是<code>UIViewController</code>的一个实例，实际上，它将是一个<code>UIViewController</code>子类的实例；<code>UIViewController</code>被设计成可以被子类化。你可以编写你自己的<code>UIViewController</code>子类；也可以使用一个内置的子类，如<code>UINavigationController</code>或<code>UITabBarController</code>；或者你可以对一个内置的子类进行子类化，如<code>UITableViewController</code>。</p>
<p>视图控制器管理着一个视图以及该视图的子视图，它们的子视图等等。处于该层次结构顶端的<!-- raw HTML omitted -->单一超级视图是视图控制器的主视图，或者简单说是它的视图<!-- raw HTML omitted -->，即视图控制器的<code>view</code>属性指向它。视图控制器的主视图<!-- raw HTML omitted -->没有明确的指针指向管理它的视图控制器<!-- raw HTML omitted -->，但视图控制器是一个<code>UIResponder</code>，在响应者链中就在其视图之上，所以它是其视图的下一个响应者。</p>
<p>为了让视图控制器发挥作用，它的视图必须以某种方式进入可见界面。视图控制器通常负责这个工作，但通常不是其视图的视图控制器，<!-- raw HTML omitted -->而是某个视图已经进入界面的视图控制器<!-- raw HTML omitted -->。在许多情况下，这将自动发生（我会在下一节中更多地谈论这个问题），但你可以参与这个过程，对于某些视图控制器，你可能必须自己做这项工作。一个来了的视图最终也可能会离开，负责将一个视图放入界面的视图控制器通常也会负责将其删除。</p>
<p>视图控制器通常会在视图出现或消失时提供界面的动画。内置的视图控制器子类，以及召唤或移除视图控制器及其视图的内置方法，都有内置的动画。我们都很熟悉轻击某个东西使新的界面从屏幕一侧滑入，然后再轻击一个返回按钮使该界面再次滑出。<!-- raw HTML omitted -->谁负责让视图控制器的视图进入界面，谁就负责提供动画<!-- raw HTML omitted -->。</p>
<p>最强大的视图控制器是顶层的视图控制器。这可能是一个全屏呈现的视图控制器，我将在本章后面解释。但大多数时候，它将是你的应用程序的根视图控制器。这是管理根视图的视图控制器，根视图位于整个视图层次结构的顶端，是窗口的唯一直接子视图，作为应用程序其他界面的超级视图。根视图控制器之所以能达到这个崇高的位置，是因为<code>UIApplicationMain</code>或者你的代码把它放在那里，把它实例化并分配给了窗口的<code>rootViewController</code>属性。窗口的反应是采用视图控制器的主视图，给它一个正确的框架（必要时调整其大小），并使其成为自己的子视图。</p>

    </div>
    <footer class="post-footer">
        
 
<div class="post-tags">     
     
    <a href="https://iihui.github.io/tags/ios" rel="tag" title="iOS">#iOS#</a>
    
</div>



        <div class="post-nav">
    <div class="post-nav-next post-nav-item">
    
        <a href="https://iihui.github.io/post/ios-leaks/" rel="next" title="使用Leaks内存检测">
        <i class="fa fa-chevron-left"></i> 使用Leaks内存检测
        </a>
    
    </div>

    <div class="post-nav-prev post-nav-item">
    
        <a href="https://iihui.github.io/post/swift-5.3/" rel="prev" title="Swift 5.3 新特性">
        Swift 5.3 新特性 <i class="fa fa-chevron-right"></i>
        </a>
    
    </div>
</div>
      
        <div class="post-nav">
    <div style="border: 1px dashed #e0e0e0; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
        <div style="float:left;margin-top:0px;">
            <img src="https://i.loli.net/2020/02/09/SvhUdz4XJsOr9Vk.jpg" width="128px" height="128px"/>
            <div style="text-align:center;">谢谢支持!</div>
        </div>
        <div>
            <p style="margin-top:10px;">
                标题：视图
                <br />作者：阿呆<a target="_blank" href="https://iihui.github.io/"></a>
                
                <br />地址：https://iihui.github.io/post/ios-views/
                <br />声明：自由转载-非商用-保持署名（创作共享4.0许可证）
            </p>
        </div>
    </div>
    <div class="clear"></div>
</div>
        
        
        




    </footer>
  </article>
</section>

          </div>
        </div>
        <div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>
<aside id="sidebar" class="sidebar">
  <div class="sidebar-inner">

  <ul class="sidebar-nav motion-element">
    <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
      文章目录
    </li>
    <li class="sidebar-nav-overview" data-target="site-overview">
      站点概览
    </li>
  </ul>

    <section class="site-overview sidebar-panel ">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
        src="https://i.loli.net/2020/02/07/dVFzrvZkHRNq2lL.jpg"
        alt="" />
    <p class="site-author-name" itemprop="name"></p>
    <p class="site-description motion-element" itemprop="description"> 
        coder &amp; cook</p>
</div>
      <nav class="site-state motion-element">
    <div class="site-state-item site-state-posts">
      <a href="https://iihui.github.io/post/">
        <span class="site-state-item-count">141</span>
        <span class="site-state-item-name">日志</span>
      </a>
    </div>
    <div class="site-state-item site-state-categories">    
        <a href="https://iihui.github.io/categories/">      
         
        <span class="site-state-item-count">17</span>
        
        <span class="site-state-item-name">分类</span>
        
        </a>
    </div>

    <div class="site-state-item site-state-tags">
        <a href="https://iihui.github.io/tags/">
         
        <span class="site-state-item-count">28</span>
        
        <span class="site-state-item-name">标签</span>
        </a>
    </div>
</nav>
      
      
<div class="links-of-author motion-element">
    
        <span class="links-of-author-item">
        <a href="https://coolshell.cn" target="_blank" title="皓 大">
            <i class="fa fa-fw fa-globe"></i>
            皓 大
        </a>
        </span>
    
        <span class="links-of-author-item">
        <a href="http://www.ruanyifeng.com" target="_blank" title="阮 大">
            <i class="fa fa-fw fa-globe"></i>
            阮 大
        </a>
        </span>
    
        <span class="links-of-author-item">
        <a href="https://juejin.im/" target="_blank" title="掘 金">
            <i class="fa fa-fw fa-globe"></i>
            掘 金
        </a>
        </span>
    
        <span class="links-of-author-item">
        <a href="http://www.ideamsg.com" target="_blank" title="灵 感">
            <i class="fa fa-fw fa-globe"></i>
            灵 感
        </a>
        </span>
    
</div>


      

      <div class="links-of-blogroll motion-element inline">
<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=&amp;m=0&amp;s=220&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;bv=35" async="async"></script>
</div>

    </section>
    
<section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
    <div class="post-toc">
        <div class="post-toc-content"><nav id="TableOfContents">
  <ul>
    <li><a href="#window-和-root-view">window 和 root View</a>
      <ul>
        <li><a href="#window-scene-architecture">window scene architecture</a></li>
        <li><a href="#app-launches">App Launches</a>
          <ul>
            <li><a href="#新架构">新架构</a></li>
          </ul>
        </li>
        <li><a href="#引用window">引用window</a>
          <ul>
            <li><a href="#view">view</a></li>
            <li><a href="#scenedelegate-或appdelegate">sceneDelegate 或appDelegate</a></li>
            <li><a href="#application">application</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#subview-and-superview">subview and superview</a>
      <ul>
        <li><a href="#color">color</a></li>
      </ul>
    </li>
    <li><a href="#可见性和透明度">可见性和透明度</a>
      <ul>
        <li><a href="#ishidden">isHidden</a></li>
        <li><a href="#alpha">alpha</a></li>
        <li><a href="#isopaque">isOpaque</a></li>
      </ul>
    </li>
    <li><a href="#frame">Frame</a></li>
    <li><a href="#bounds-and-center">Bounds and Center</a>
      <ul>
        <li><a href="#bounds">Bounds</a></li>
        <li><a href="#center">center</a></li>
      </ul>
    </li>
    <li><a href="#transform">transform</a>
      <ul>
        <li><a href="#transform-1">transform</a></li>
        <li><a href="#transform3d">transform3D</a></li>
      </ul>
    </li>
    <li><a href="#window坐标和屏幕座标">Window坐标和屏幕座标</a></li>
    <li><a href="#trait-collections">Trait Collections</a></li>
    <li><a href="#interface-style">Interface Style</a></li>
    <li><a href="#size-classes">Size Classes</a></li>
    <li><a href="#overriding-trait-collections">Overriding Trait Collections</a></li>
    <li><a href="#layout">layout</a></li>
    <li><a href="#autoresizing">Autoresizing</a></li>
    <li><a href="#autolayout-and-constraints">Autolayout and Constraints</a></li>
    <li><a href="#view-controllers">view Controllers</a></li>
  </ul>
</nav></div>
    </div>
</section>

  </div>
</aside>

      </div>
    </main>
   
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  <span itemprop="copyrightYear">  &copy; 
  2017 - 2022</span>
  <span class="with-love"><i class="fa fa-heart"></i></span>
  <span class="author" itemprop="copyrightHolder">Keep It Simple</span>
</div>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      <span id="scrollpercent"><span>0</span>%</span>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/jquery/index.js?v=2.1.3"></script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script> 
<script type="text/javascript" src="https://iihui.github.io/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/velocity/velocity.min.js?v=1.2.1"></script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="https://iihui.github.io/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>

<script src="https://iihui.github.io/js/vendor/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>

<script type="text/javascript" src="https://iihui.github.io/js/utils.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/motion.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/affix.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/schemes/pisces.js"></script>

<script type="text/javascript" src="https://iihui.github.io/js/scrollspy.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/post-details.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/toc.js"></script>

<script type="text/javascript" src="https://iihui.github.io/js/bootstrap.js"></script>

<script type="text/javascript" src="https://iihui.github.io/js/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
</body>
</html>