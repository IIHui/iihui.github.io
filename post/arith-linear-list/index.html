<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
    <title>线性表 - Keep It Simple</title>
    <meta name="keywords" content="博客,思考,读书,笔记,技术,分享">
    
    <meta property="og:title" content="线性表">
    <meta property="og:site_name" content="Keep It Simple">
    <meta property="og:image" content="/img/author.jpg"> 
    <meta name="title" content="线性表 - Keep It Simple" />
    <meta name="description" content="Swift | Go | C&#43;&#43; "> 
    <link rel="shortcut icon" href="https://iihui.github.io/img/favicon.ico" />
    <link rel="apple-touch-icon" href="https://iihui.github.io/img/apple-touch-icon.png" />
    <link rel="apple-touch-icon-precomposed" href="https://iihui.github.io/img/apple-touch-icon.png" />
    <link href="https://iihui.github.io/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />
    <link href="https://iihui.github.io/js/vendor/fancybox/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />
    <link href="https://iihui.github.io/css/main.css" rel="stylesheet" type="text/css" />
    <link href="https://iihui.github.io/css/syntax.css" rel="stylesheet" type="text/css" />

    <script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
     fancybox: true, 
    motion: true
  };
</script>

    <link href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/monokai-sublime.min.css" rel="stylesheet">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/go.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/swift.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/objectivec.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/clojure.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/kotlin.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/yaml.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<div class="container one-collumn sidebar-position-left page-home  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-meta  custom-logo ">

  <div class="custom-logo-site-title">
    <a href="https://iihui.github.io/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Keep It Simple</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">靡不有初，鲜克有终</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
    <ul id="menu" class="menu">
      
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/tags/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-tag"></i> <br />标签
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/post/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/categories/%E7%BE%8E%E9%A3%9F/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-fire"></i> <br />美食
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/categories/%E5%90%8E%E6%9C%9F/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-edit"></i> <br />后期
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/categories/%E6%97%85%E8%A1%8C/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-leaf"></i> <br />旅行
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/about/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于
          </a>
        </li>
      
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger"> <i class="menu-item-icon fa fa-search fa-fw"></i> <br /> 搜索</a>
      </li>
    </ul>
    <div class="site-search">
      <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>

    </div>
</nav>
<script type="text/javascript"
        async
        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
		<!-- src = "http://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> <\!--  -\-> -->
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>

<!DOCTYPE html>
<html lang="en">


<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css" integrity="sha384-D+9gmBxUQogRLqvARvNLmA9hS2x//eK1FhVb9PiU86gmcrBrJAQT8okdJ4LMp2uv" crossorigin="anonymous">

    
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js" integrity="sha384-483A6DwYfKeDa0Q52fJmxFXkcPCFfnXMoXblOkJ4JcA8zATN6Tm78UNL72AKk+0O" crossorigin="anonymous"></script>
</head>
<body>

</body>
</html>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
<section id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="https://iihui.github.io/post/arith-linear-list/" itemprop="url">
        线性表
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">创建: </span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2018-04-25">
    2018-04-25
</time>
</span>
&nbsp; | &nbsp;
<span class="post-updated-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-check-o"></i>
</span>
<span class="post-meta-item-text">更新: </span>
<time itemprop="dateUpdated" content="2018-04-25">
    2018-04-25
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类: </span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="https://iihui.github.io/categories/%E7%AE%97%E6%B3%95" itemprop="url" rel="index">
        <span itemprop="name">算法</span>
      </a>
      &nbsp; 
    </span>
  
</span>


      <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-file-word-o"></i>
</span>
<span class="post-meta-item-text">字数: </span>
<span class="leancloud-visitors-count">6135</span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-coffee"></i>
</span>
<span class="post-meta-item-text">阅读: </span>
<span class="leancloud-visitors-count">13 分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <blockquote>
<p>线性表是由 $n$个具有相同特性的元素$(n \ge 0)$ 组成的一个有限序列，是一种逻辑结构。它的特征在于：①表中所有<font color=red>数据元素类型相同</font>。②表由<font color=Blue>有限个数据元素构成</font>。③表中<font color=red>数据元素是位置相关的</font>（这一点表明线性表不同于集合)，并且每个元素都有一个对应的序号，表中<font color=red>元素可以重复出现。</font></p>
</blockquote>
<h1 id="逻辑结构">逻辑结构</h1>
<p>线性表是一种逻辑结构，其一般表示为: ($a_1,a_2,&hellip;,a_{i-1},a_i,a_{i+1},&hellip;,a_n$)</p>
<ul>
<li>
<p>除了<font color=red>起始元素$a_1$没有前驱元素</font>之外，其他元素$a_i$<font color=Blue>有且仅有一个</font>前驱元素$a_{i-1}$。</p>
</li>
<li>
<p>除了<font color=Blue>终端元素$a_n$没有后继元素</font>外，其他元素$a_i$<font color=Blue>有且仅有一个</font>后继元素$a_{i+1}$。</p>
</li>
</ul>
<p>根据上面的表示，在线性表中，每个元素至多只有一个前驱元素，并且至多只有一个后继元素。</p>
<h1 id="存储结构">存储结构</h1>
<p>线性表是一种<font color=red>逻辑结构</font>，其存储结构有两种：</p>
<ul>
<li>
<p>顺序存储：顺序表</p>
</li>
<li>
<p>链式存储：单链表</p>
</li>
</ul>
<h1 id="顺序表">顺序表</h1>
<p>线性表的顺序存储是指<font color=red>一组地址连续的存储单元依次存储线性表中的各个元素</font>，使得线性表中在<font color=Blue>逻辑结构上相邻的数据元素存储在相邻的物理存储单元中</font>。即通过数据元素<font color=GoldenRod>物理存储的相邻关系来反映数据元素之间逻辑上的相邻关系</font>，采用顺序存储结构的线性表通常称为顺序表。</p>
<h2 id="顺序表的特点">顺序表的特点</h2>
<p>根据顺序表的定义，总结顺序表有以下的特征：</p>
<ul>
<li>
<p>属于直接映射——<font color=Blue>逻辑上相邻的元素，其物理位置也相邻</font>。</p>
</li>
<li>
<p>具有随机存取特性，通过<font color=GoldenRod>首地址和元素序号</font>可以在 $O(1)$ 时间内找到指定元素。</p>
</li>
<li>
<p>存储密度高，其值为$1$。$存储密度=\frac{节点数据本身所占用的存储量}{节点结构占用的存储量}$</p>
</li>
<li>
<p>删除和插入元素需要移动大量元素：</p>
<ul>
<li>
<p>插入元素移动的平均次数$=\frac{1}{n}\sum_{i=1}^{n}(n-i+1)=\frac{n}{2}$, 因此时间复杂度为$O(n)$。</p>
</li>
<li>
<p>删除元素移动的平均次数$=\frac{1}{n}\sum_{i=1}^{n}(n-i)=\frac{n-1}{2}$，因此时间复杂度为$O(n)$。</p>
</li>
</ul>
</li>
</ul>
<h2 id="描述顺序表的结构">描述顺序表的结构</h2>
<p>为了描述顺序表，需要知道：① 顺序表的起始地址；② 顺序表的最大长度；③ 顺序表的当前长度。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#define MaxSize 1000
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> data[MaxSize];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> length;
</span></span><span style="display:flex;"><span>} SqList;
</span></span></code></pre></div><h1 id="一些习题">一些习题</h1>
<h2 id="最长平台">最长平台</h2>
<p>给定一个有$n$个元素的整型数组$data$,其中连续的<font color=GoldenRod>相等元素构成的子序列</font>称为平台，请设计一个算法求 $data$ 中最长平台的长度。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> linerArith<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>maximumPlatform(T <span style="color:#f92672">*</span>data, <span style="color:#66d9ef">int</span> length) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> start <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> maxLen <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> curLen <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> length; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (data[i] <span style="color:#f92672">==</span> data[start]) {
</span></span><span style="display:flex;"><span>            curLen<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (curLen <span style="color:#f92672">&gt;</span> maxLen) {
</span></span><span style="display:flex;"><span>                maxLen <span style="color:#f92672">=</span> curLen;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            curLen <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            start <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//可能最后一个连续的子序列为最大平台
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (curLen <span style="color:#f92672">&gt;</span> maxLen) {
</span></span><span style="display:flex;"><span>        maxLen <span style="color:#f92672">=</span> curLen;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> maxLen;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="以key为轴调整">以key为轴调整</h2>
<p>设有一个数组 $data$， 其元素为整型数据，设计一个算法将 $data$ 中所有小于 $key$ 的整数放在前半部分，大于等于 $key$ 的整数放在后半部分。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> linerArith<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>rotate(T <span style="color:#f92672">*</span>data, <span style="color:#66d9ef">int</span> length, <span style="color:#66d9ef">int</span> key) {
</span></span><span style="display:flex;"><span>    assert(length <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> start <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, end <span style="color:#f92672">=</span> length <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (start <span style="color:#f92672">&lt;</span> end) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (start <span style="color:#f92672">&lt;</span> end <span style="color:#f92672">&amp;&amp;</span> data[start] <span style="color:#f92672">&lt;</span> key) {
</span></span><span style="display:flex;"><span>            start<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (start <span style="color:#f92672">&lt;</span> end <span style="color:#f92672">&amp;&amp;</span> data[end] <span style="color:#f92672">&gt;=</span> key) {
</span></span><span style="display:flex;"><span>            end<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (start <span style="color:#f92672">&lt;</span> end) {
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>swap(data[start], data[end]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="以第一个元素为轴调整">以第一个元素为轴调整</h2>
<p>设有一个数组 $data$，其元素为整型。设计一个尽可能高效的算法，<font color=GoldenRod>以第一个元素为分界线</font>，将所有小于等于它的元素移到该元素前面，将所有大于它的元素移到该元素的后面。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> linerArith<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>rotateByFirst(T <span style="color:#f92672">*</span>data, <span style="color:#66d9ef">int</span> length) {
</span></span><span style="display:flex;"><span>    assert(length <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> start <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, end <span style="color:#f92672">=</span> length <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    T pivot <span style="color:#f92672">=</span> data[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (start <span style="color:#f92672">&lt;</span> end) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (start <span style="color:#f92672">&lt;</span> end <span style="color:#f92672">&amp;&amp;</span> data[start] <span style="color:#f92672">&lt;=</span> pivot) {
</span></span><span style="display:flex;"><span>            start<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (start <span style="color:#f92672">&lt;</span> end <span style="color:#f92672">&amp;&amp;</span> data[end] <span style="color:#f92672">&gt;</span> pivot) {
</span></span><span style="display:flex;"><span>            end<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (start <span style="color:#f92672">&lt;</span> end) {
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>swap(data[start], data[end]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//因为忽略了第一个元素，因此这里需要检查最终位置的那个元素和第一个元素的大小关系
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (data[start] <span style="color:#f92672">&lt;</span> pivot) {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>swap(data[start], data[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> linerArith<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>rotateByFirstVersion2(T <span style="color:#f92672">*</span>data, <span style="color:#66d9ef">int</span> length) {
</span></span><span style="display:flex;"><span>    assert(length <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> start <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, end <span style="color:#f92672">=</span> length <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> pivot <span style="color:#f92672">=</span> data[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (start <span style="color:#f92672">&lt;</span> end) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (start <span style="color:#f92672">&lt;</span> end <span style="color:#f92672">&amp;&amp;</span> data[end] <span style="color:#f92672">&gt;</span> pivot) {
</span></span><span style="display:flex;"><span>            end<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (start <span style="color:#f92672">&lt;</span> end) {
</span></span><span style="display:flex;"><span>            data[start<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> data[end];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (start <span style="color:#f92672">&lt;</span> end <span style="color:#f92672">&amp;&amp;</span> data[start] <span style="color:#f92672">&lt;=</span> pivot) {
</span></span><span style="display:flex;"><span>            start<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (start <span style="color:#f92672">&lt;</span> end) {
</span></span><span style="display:flex;"><span>            data[end<span style="color:#f92672">--</span>] <span style="color:#f92672">=</span> data[start];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    data[start] <span style="color:#f92672">=</span> pivot; <span style="color:#75715e">//找到最终位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 剑指offer里快速排序的思路,该方法保持相对次序不变
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> linerArith<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>rotateByFirstVersion3(T <span style="color:#f92672">*</span>data, <span style="color:#66d9ef">int</span> length) {
</span></span><span style="display:flex;"><span>    assert(length <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    T pivot <span style="color:#f92672">=</span> data[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span> length; <span style="color:#f92672">++</span>j) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//是小于不是&lt;=,因为第一个元素要被替换掉
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (data[j] <span style="color:#f92672">&lt;</span> pivot) {
</span></span><span style="display:flex;"><span>            i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&lt;</span> j) {
</span></span><span style="display:flex;"><span>                std<span style="color:#f92672">::</span>swap(data[i], data[j]);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//最后交换下标为0的元素和下标为i的元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>swap(data[<span style="color:#ae81ff">0</span>],data[i]);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">move1</span>(SqList <span style="color:#f92672">&amp;</span>L) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    j <span style="color:#f92672">=</span> L.length <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> pivot <span style="color:#f92672">=</span> L.data[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> tmp;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;</span> j) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;</span> j <span style="color:#f92672">&amp;&amp;</span> L.data[j] <span style="color:#f92672">&gt;</span> pivot)
</span></span><span style="display:flex;"><span>            j<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;</span> j <span style="color:#f92672">&amp;&amp;</span> L.data[i] <span style="color:#f92672">&lt;=</span> pivot)  <span style="color:#75715e">//第一个元素肯定会被忽略掉
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//此处可以添加一个 i &lt; j 的判断，这里省略掉是因为前面已经判断i&lt;j,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//所以到这里的时候最多也是i==j, 这时候直接交换也是没有副作用的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        tmp <span style="color:#f92672">=</span> L.data[i];
</span></span><span style="display:flex;"><span>        L.data[i] <span style="color:#f92672">=</span> L.data[j];
</span></span><span style="display:flex;"><span>        L.data[j] <span style="color:#f92672">=</span> tmp;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (L.data[i] <span style="color:#f92672">&lt;</span> pivot)<span style="color:#75715e">//因为忽略了第一个元素，因此这里需要检查最终位置的那个元素和第一个元素的大小关系
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    {
</span></span><span style="display:flex;"><span>        tmp <span style="color:#f92672">=</span> L.data[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>        L.data[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> L.data[i];
</span></span><span style="display:flex;"><span>        L.data[i] <span style="color:#f92672">=</span> tmp;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">move2</span>(SqList <span style="color:#f92672">&amp;</span>L) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, j <span style="color:#f92672">=</span> L.length <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> pivot <span style="color:#f92672">=</span> L.data[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;</span> j) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;</span> j <span style="color:#f92672">&amp;&amp;</span> L.data[j] <span style="color:#f92672">&gt;</span> pivot) j<span style="color:#f92672">--</span>; <span style="color:#75715e">//先从最后开始，因为第一个元素需要首先被替换
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&lt;</span> j) {
</span></span><span style="display:flex;"><span>            L.data[i] <span style="color:#f92672">=</span> L.data[j];
</span></span><span style="display:flex;"><span>            i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;</span> j <span style="color:#f92672">&amp;&amp;</span> L.data[i] <span style="color:#f92672">&lt;=</span> pivot) i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&lt;</span> j) {
</span></span><span style="display:flex;"><span>            L.data[j] <span style="color:#f92672">=</span> L.data[i];
</span></span><span style="display:flex;"><span>            j<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    L.data[i] <span style="color:#f92672">=</span> pivot;  <span style="color:#75715e">//最后找到最终的位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">move3</span>(SqList <span style="color:#f92672">&amp;</span>L) <span style="color:#75715e">//剑指offer里快速排序的思路
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{                     <span style="color:#75715e">//该算法可以保持相对次序不变
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> pivot <span style="color:#f92672">=</span> L.data[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> tmp;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span> L.length; j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (data[j] <span style="color:#f92672">&lt;</span> pivot) {
</span></span><span style="display:flex;"><span>            i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&lt;</span> j)  <span style="color:#75715e">//是小于不是&lt;=,因为第一个元素要被替换掉
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            {
</span></span><span style="display:flex;"><span>                tmp <span style="color:#f92672">=</span> L.data[i];
</span></span><span style="display:flex;"><span>                L.data[i] <span style="color:#f92672">=</span> L.data[j];
</span></span><span style="display:flex;"><span>                L.data[j] <span style="color:#f92672">=</span> tmp;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    tmp <span style="color:#f92672">=</span> L.data[<span style="color:#ae81ff">0</span>];  <span style="color:#75715e">//最后交换下标为0的元素和下标为i的元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    L.data[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> L.data[i];
</span></span><span style="display:flex;"><span>    L.data[i] <span style="color:#f92672">=</span> tmp;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="删除元素">删除元素</h2>
<p>已知长度为$n$的数组$data$，编写一个时间复杂度为$O(n)$,空间复杂度为$O(1)$ 的算法，该算法删除线性表中所有值为$value$的元素。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> linerArith<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>deleteSameElement(T <span style="color:#f92672">*</span>data, <span style="color:#66d9ef">int</span> length, <span style="color:#66d9ef">int</span> value) {
</span></span><span style="display:flex;"><span>    assert(length <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> base <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> length; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (data[i] <span style="color:#f92672">!=</span> value) {
</span></span><span style="display:flex;"><span>            data[base<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> data[i];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> base;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> linerArith<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>deleteSameElement(T <span style="color:#f92672">*</span>data, <span style="color:#66d9ef">int</span> length, <span style="color:#66d9ef">int</span> value) {
</span></span><span style="display:flex;"><span>    assert(length <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;   <span style="color:#75715e">//不同的是记录目前等于value的元素个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> length; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (data[i] <span style="color:#f92672">==</span> value) {
</span></span><span style="display:flex;"><span>            count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            data[i <span style="color:#f92672">-</span> count] <span style="color:#f92672">=</span> data[i];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> length <span style="color:#f92672">-</span> count;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>一般<font color=Blue>类似的题目</font>有：已知长度为 $n$ 的线性表 $L$ 采用顺序存储结构，试设计一个时间复杂度空间复杂度两方面都尽可能高效的算法，该算法删除线性表中元素值为$[x,y]$之间的所有数据元素。</p>
<h1 id="单链表">单链表</h1>
<p>单链表是<font color=Blue>任意一组存储单元存放线性表中的元素</font>，每个节点通过一个指针指向其后继节点。这组<font color=red>存储单元可以是连续的也可以是不连续的。</font>单链表具有如下的特点：</p>
<ul>
<li>
<p>通过首节点(带<font color=Blue>哨兵节点</font>或不带哨兵节点)的指针来标识一个单链表。</p>
</li>
<li>
<p>从一个已知节点出发，<font color=Green>只能访问该节点和通过 $next$ 指针访问其后继节点</font>，<font color=red>无法直接找到</font>该节点之前的其他节点。</p>
</li>
<li>
<p>在单链表中插入一个节点或者删除一个节点必须找到其前驱节点，<font color=Blue>插入和删除操作不需要移动节点</font>。「<font color=red>删除一个节点也可以不用知道其前驱节点</font>，只要将其后继节点的元素内容往前移到当前节点，并将当前节点的后继修改为其后继节点的后继节点，然后删除后继节点即可。<font color=Blue>但是要考虑该节点是否为最后一个节点，或者第一个节点」</font></p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">LinkedNode</span> {
</span></span><span style="display:flex;"><span>    T data;  <span style="color:#75715e">//T表示数据类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">LinkedNode</span> <span style="color:#f92672">*</span>next;
</span></span><span style="display:flex;"><span>} LinkedList;
</span></span></code></pre></div><h2 id="建立单链表">建立单链表</h2>
<p>建立单链表有两种方式，一种是从头部插入；另一种是从尾部插入。从头部插入节点生成的单链表，最后<font color=red>节点元素顺序与插入元素的顺序相反，即成逆序排列了。</font></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">creatLinkedList</span>(LinkedList <span style="color:#f92672">*&amp;</span>L, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>a, <span style="color:#66d9ef">int</span> n) {
</span></span><span style="display:flex;"><span>    LinkedList <span style="color:#f92672">*</span>cur;
</span></span><span style="display:flex;"><span>    L <span style="color:#f92672">=</span> (LinkedList <span style="color:#f92672">*</span>) malloc(<span style="color:#66d9ef">sizeof</span>(LinkedList));
</span></span><span style="display:flex;"><span>    L<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        cur <span style="color:#f92672">=</span> (LinkedList <span style="color:#f92672">*</span>)(malloc(<span style="color:#66d9ef">sizeof</span>(LinkedList)));
</span></span><span style="display:flex;"><span>        cur<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> a[i];
</span></span><span style="display:flex;"><span>        cur<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> L<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        L<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> cur;  <span style="color:#75715e">//当前节点成为哨兵节点的下一个节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>尾插法是在单链表的尾部插入节点元素，最后<font color=Blue>生成的单链表的节点元素顺序和插入元素的顺序是相同的</font>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">creatLinkedList</span>(LinkedList <span style="color:#f92672">*&amp;</span>L, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>a, <span style="color:#66d9ef">int</span> n) {
</span></span><span style="display:flex;"><span>    LinkedList <span style="color:#f92672">*</span>cur, <span style="color:#f92672">*</span>tail;
</span></span><span style="display:flex;"><span>    L <span style="color:#f92672">=</span> (LinkedList <span style="color:#f92672">*</span>) malloc(<span style="color:#66d9ef">sizeof</span>(LinkedList));
</span></span><span style="display:flex;"><span>    tail <span style="color:#f92672">=</span> L; <span style="color:#75715e">//tail始终指向最后的节点，开始时指向链表的头结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        cur <span style="color:#f92672">=</span> (LinkedList <span style="color:#f92672">*</span>) malloc(<span style="color:#66d9ef">sizeof</span>(LinkedList));
</span></span><span style="display:flex;"><span>        cur<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> a[i];
</span></span><span style="display:flex;"><span>        tail<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> cur;
</span></span><span style="display:flex;"><span>        tail <span style="color:#f92672">=</span> cur;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    tail<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="基本操作">基本操作</h2>
<ol>
<li>按序号查找节点值算法</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">findNode</span>(LinkedList <span style="color:#f92672">*</span>L,<span style="color:#66d9ef">int</span> i,<span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>result)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  LinkedList <span style="color:#f92672">*</span>cur<span style="color:#f92672">=</span>L;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span>(cur<span style="color:#f92672">!=</span>NULL <span style="color:#f92672">&amp;&amp;</span> j<span style="color:#f92672">&lt;</span>i)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    j<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    cur<span style="color:#f92672">=</span>cur<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(NULL<span style="color:#f92672">==</span>cur) <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>       
</span></span><span style="display:flex;"><span>  result<span style="color:#f92672">=</span>cur<span style="color:#f92672">-&gt;</span>data;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol start="2">
<li>按元素值查找序号算法</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">findNode</span>(LinkedList <span style="color:#f92672">*</span>L,<span style="color:#66d9ef">int</span> key)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  LinkedList <span style="color:#f92672">*</span>cur<span style="color:#f92672">=</span>L<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> index<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span>(cur<span style="color:#f92672">!=</span>NULL <span style="color:#f92672">&amp;&amp;</span> cur<span style="color:#f92672">-&gt;</span>data<span style="color:#f92672">!=</span>key)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    index<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    cur<span style="color:#f92672">=</span>cur<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(cur<span style="color:#f92672">!=</span>NULL) <span style="color:#66d9ef">return</span> index;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;  <span style="color:#75715e">//返回-1，表示没有找到该元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><hr>
<ol start="3">
<li>
<p>插入元素：将值为$x$的元素的新节点插入到第$i$个节点的位置上，即先在单链表中找到插入节点的前驱节点，即第$i-1$个节点，再在其后插入新节点。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span> cur<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>pre<span style="color:#f92672">-&gt;</span>next;  <span style="color:#75715e">//cur表示将要插入到链表中的节点,插入的位置是节点pre之后
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> pre<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>cur;
</span></span></code></pre></div></li>
<li>
<p>删除元素:将单链表中的第$i$个节点删除。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span> cur<span style="color:#f92672">=</span>pre<span style="color:#f92672">-&gt;</span>next;     <span style="color:#75715e">//pre-&gt;next是待删除的节点，cur是待删除节点的上一个节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> pre<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>cur<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span> free (cur);
</span></span></code></pre></div></li>
</ol>
<hr>
<h2 id="就地逆置">就地逆置</h2>
<p>有一个线性表$(a_1,a_2,&hellip;,a_n)$ 采用带哨兵节点的单链表$L$存储，设计一个就地算法将其就地逆置，<font color=Blue>所谓“就地”是指算法的辅助空间为$O(1)$。</font></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">reverse</span>(LinkedList <span style="color:#f92672">*</span> <span style="color:#f92672">&amp;</span> L) <span style="color:#75715e">//传入引用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>  LinkedList <span style="color:#f92672">*</span>cur<span style="color:#f92672">=</span>L<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>  LinkedList <span style="color:#f92672">*</span>next;
</span></span><span style="display:flex;"><span>  L<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>NULL;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span>(cur<span style="color:#f92672">!=</span>NULL)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    next<span style="color:#f92672">=</span>ptr<span style="color:#f92672">-&gt;</span>next;    <span style="color:#75715e">//先保存下一个节点，然后使用头插法进行逆置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    cur<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>L<span style="color:#f92672">-&gt;</span>next; 
</span></span><span style="display:flex;"><span>    L<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>cur;
</span></span><span style="display:flex;"><span>    cur<span style="color:#f92672">=</span>next;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h2 id="拆分链表">拆分链表</h2>
<p>设$C={a_1,b_1,a_2,b_2,&hellip;,a_n,b_n}$ 为一线性表，采用带哨兵节点的$hc$单链表存放，设计一个就地算法，将其拆分为两个线性表（它们都是用单链表存放）使得$A={a_1,a_2,&hellip;,a_n},B={b_n,b_{n-1},&hellip;,b_2,b_1}$，即$A$是正序排列，$B$是逆序排列。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//参数传入引用，ha存储是A，hb存储的是B
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">split</span>(LinkedList <span style="color:#f92672">*</span>hc,LinkedList <span style="color:#f92672">*&amp;</span>ha,LinkedList <span style="color:#f92672">*&amp;</span> hb)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  LinkedList <span style="color:#f92672">*</span>tail<span style="color:#f92672">=</span>ha;
</span></span><span style="display:flex;"><span>  LinkedList <span style="color:#f92672">*</span>cur<span style="color:#f92672">=</span>hc<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>  LinkedList <span style="color:#f92672">*</span>next;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  hb<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>NULL;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span>(cur <span style="color:#f92672">!=</span> NULL)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    tail<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>cur;      <span style="color:#75715e">//尾插法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    tail<span style="color:#f92672">=</span>cur;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    cur<span style="color:#f92672">=</span>cur<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    next<span style="color:#f92672">=</span>cur<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    cur<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span> hb<span style="color:#f92672">-&gt;</span>next;  <span style="color:#75715e">//头插法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    hb<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span> cur;
</span></span><span style="display:flex;"><span>    cur<span style="color:#f92672">=</span>next;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  tail<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>NULL;  <span style="color:#75715e">//别忘了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h2 id="递增排序">递增排序</h2>
<p>有一个带哨兵结点的单链表$L$,设计一个算法使其元素<font color=Blue>递增有序</font>。最基本的想法是使用<font color=red>直接插入排序</font>的思想，一个一个排，不同于数组排序，这里<font color=Blue>单链表只能从头开始查找。</font></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> sort<span style="color:#960050;background-color:#1e0010">（</span>LinkedList <span style="color:#f92672">*</span> <span style="color:#f92672">&amp;</span>L)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  LinkedList <span style="color:#f92672">*</span>cur<span style="color:#f92672">=</span>L<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>  LinkedList <span style="color:#f92672">*</span>next<span style="color:#f92672">=</span>cur<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>  LinkedList <span style="color:#f92672">*</span>pre,<span style="color:#f92672">*</span>assist; <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  
</span></span><span style="display:flex;"><span>  cur<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>NULL;   <span style="color:#75715e">//只含有一个元素的有序单链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  cur<span style="color:#f92672">=</span>next;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span>(cur<span style="color:#f92672">!=</span>NULL)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    next<span style="color:#f92672">=</span>cur<span style="color:#f92672">-&gt;</span>next;   <span style="color:#75715e">//首先保存下一个链表节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    pre<span style="color:#f92672">=</span>L;            <span style="color:#75715e">//单链表只能从头开始往后寻找节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    assist<span style="color:#f92672">=</span>pre<span style="color:#f92672">-&gt;</span>next; <span style="color:#75715e">//assist从头开始遍历
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span>(assist<span style="color:#f92672">!=</span>NULL <span style="color:#f92672">&amp;&amp;</span> assist<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">&lt;</span> cur<span style="color:#f92672">-&gt;</span>data)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      pre<span style="color:#f92672">=</span>assist;   <span style="color:#75715e">//pre记录插入位置的前一个节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      assist<span style="color:#f92672">=</span>assist<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    cur<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>pre<span style="color:#f92672">-&gt;</span>next; <span style="color:#75715e">//pre的下一个节点就是要插入的位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    pre<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>cur;       <span style="color:#75715e">//pre的下一个节点就是要插入的位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    cur<span style="color:#f92672">=</span>next;   
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h2 id="公共节点">公共节点</h2>
<p>给定两个单链表，编写算法找出其公共的节点。第一种方法分析：从头到尾扫描单链表$A$，判断当前元素是否在单链表$B$中出现，若在则插入到单链表$C$中。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">findSameNode</span>(LinkedList <span style="color:#f92672">*</span>A,LinkedList <span style="color:#f92672">*</span>B,LinkedList <span style="color:#f92672">*&amp;</span>C)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  LinkedList <span style="color:#f92672">*</span>curA<span style="color:#f92672">=</span>A<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>  LinkedList <span style="color:#f92672">*</span>curB<span style="color:#f92672">=</span>B<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>  LinkedList <span style="color:#f92672">*</span>tail;       <span style="color:#75715e">//尾插法构建新的单链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  
</span></span><span style="display:flex;"><span>  C<span style="color:#f92672">=</span>(LinkedList<span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(LinkedList));  <span style="color:#75715e">//静态存储区分配内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  C<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>NULL;
</span></span><span style="display:flex;"><span>  tail<span style="color:#f92672">=</span>C;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span>(curA<span style="color:#f92672">!=</span>NULL)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    curB<span style="color:#f92672">=</span>B<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(curB<span style="color:#f92672">!=</span>NULL <span style="color:#f92672">&amp;&amp;</span> curB<span style="color:#f92672">-&gt;</span>data<span style="color:#f92672">!=</span> curA<span style="color:#f92672">-&gt;</span>data)
</span></span><span style="display:flex;"><span>              curB<span style="color:#f92672">=</span>curB<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(curB<span style="color:#f92672">!=</span>NULL)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      tail<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>curA;
</span></span><span style="display:flex;"><span>      tail<span style="color:#f92672">=</span>curA;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    curA<span style="color:#f92672">=</span>curA<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  tail<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>NULL;  <span style="color:#75715e">//尾插法最后应该将尾巴的next域置空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>第二种方法分析：借用<font color=Blue>两个辅助栈，分别存储两个链表遍历时的序列，然后同时将两个辅助栈中元素弹出，直到弹出的元素不相等，</font>弹出时采用头插法进行构造新的单链表。</p>
<p>第三种方法分析：首先遍历两个链表，得到两个单链表的长度差$k$，然后长的单链表<font color=red>先走$k-1$步，</font>然后短的和长的同时走，直到遇到相等的元素，即为新的单链表的首节点。</p>
<hr>
<h1 id="精选习题">精选习题</h1>
<h2 id="循环左移">循环左移</h2>
<p>将$n$个整数存放到一维数组$R$中。试设计一个在时间和空间尽可能高的算法。将$R$中保存的序列循环左移$p （0 \lt q\lt n)$个位置，即将$R$中的数据由<code>$(X_0,X_1,...,X_{n-1})$</code>变换为<code>$(X_p,X_{p+1},...,X_{n-1},X_0,X_1,....,X_{p-1})$</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">reverse</span>(<span style="color:#66d9ef">int</span> R[],<span style="color:#66d9ef">int</span> start,<span style="color:#66d9ef">int</span> end)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>start,j<span style="color:#f92672">=</span>end;
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">int</span> assist;
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">while</span>(i<span style="color:#f92672">&lt;</span>j)
</span></span><span style="display:flex;"><span> {
</span></span><span style="display:flex;"><span>   assist<span style="color:#f92672">=</span>R[i];
</span></span><span style="display:flex;"><span>   R[i]<span style="color:#f92672">=</span>R[j];
</span></span><span style="display:flex;"><span>   R[j]<span style="color:#f92672">=</span>assist;
</span></span><span style="display:flex;"><span>   i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>   j<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">leftShift</span>(<span style="color:#66d9ef">int</span> R[],<span style="color:#66d9ef">int</span> n,<span style="color:#66d9ef">int</span> p)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(p<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span>p<span style="color:#f92672">&lt;</span>n)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>   reverse(R,<span style="color:#ae81ff">0</span>,n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>   reverse(R,<span style="color:#ae81ff">0</span>,n<span style="color:#f92672">-</span>p<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>   reverse(R,n<span style="color:#f92672">-</span>p,n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h2 id="寻找中位数">寻找中位数</h2>
<p>给定两个数组$A$和$B$,数组的长度为$n$,两个数组都分别有序，求出<font color=Blue>两个数组中的所有数排序后的中位数</font>「偶数序列中间两数的前一个为其中位数」。</p>
<h3 id="解法一">解法一</h3>
<p>因为数组$A$和$B$均有序，因此将两个数组排序后，<font color=red>第$n$个数</font>就是题目中所要找的中位数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">search</span>(<span style="color:#66d9ef">int</span> A[], <span style="color:#66d9ef">int</span> B[], <span style="color:#66d9ef">int</span> n) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, k <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;</span> n <span style="color:#f92672">&amp;&amp;</span> j <span style="color:#f92672">&lt;</span> n) {
</span></span><span style="display:flex;"><span>        k<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (A[i] <span style="color:#f92672">&lt;</span> B[j]) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (k <span style="color:#f92672">==</span> n)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> A[i];
</span></span><span style="display:flex;"><span>            i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (k <span style="color:#f92672">==</span> n)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> B[j];
</span></span><span style="display:flex;"><span>            j<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="解法二">解法二</h3>
<p>分别求出两个升序序列$A$，$B$的中位数，记为$a，b$。若$a=b$,则$a$或$b$即为所求，否则舍弃$a,b$中较小者所在序列的较小一半，同时舍弃较大者所在序列的较大一半，<font color=red>要求两次舍弃的元素个数相同（每次从左侧和右侧删除相同个数的元素后，新的两个数组，它们的中位数与原始数组的中位数是相同的）。</font>重复上述过程，直到<font color=Blue>两个序列均只含一个元素为止</font>，则较小的即为所求的中位数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">searchMid</span>(<span style="color:#66d9ef">int</span> A[], <span style="color:#66d9ef">int</span> B[], <span style="color:#66d9ef">int</span> n) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> startA, midA, endA;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    startA <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    endA <span style="color:#f92672">=</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    startB <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    endB <span style="color:#f92672">=</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (startA <span style="color:#f92672">!=</span> endA <span style="color:#f92672">||</span> startB <span style="color:#f92672">!=</span> endB) {
</span></span><span style="display:flex;"><span>        midA <span style="color:#f92672">=</span> (startA <span style="color:#f92672">+</span> endA) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>        midB <span style="color:#f92672">=</span> (startB <span style="color:#f92672">+</span> endB) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (A[midA] <span style="color:#f92672">==</span> B[midB])
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> A[midA];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (A[midA] <span style="color:#f92672">&lt;</span> B[midB]) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> ((startA <span style="color:#f92672">+</span> endA) <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)<span style="color:#75715e">//若元素个数为奇数时
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            {
</span></span><span style="display:flex;"><span>                startA <span style="color:#f92672">=</span> midA;  <span style="color:#75715e">//舍弃A中间点以前的部分且保留中间点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                endB <span style="color:#f92672">=</span> midB;    <span style="color:#75715e">//舍弃B中间点以后的部分且保留中间点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            } <span style="color:#66d9ef">else</span>  <span style="color:#75715e">//若元素个数为偶数时
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            {
</span></span><span style="display:flex;"><span>                startA <span style="color:#f92672">=</span> midA <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;  <span style="color:#75715e">//舍弃A的前半部分,每次舍弃的长度相同，可以保证同时到达
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                endB <span style="color:#f92672">=</span> midB;      <span style="color:#75715e">//舍弃B的后半部分
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (A[midA] <span style="color:#f92672">&gt;</span> B[midB]) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> ((startA <span style="color:#f92672">+</span> endA) <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)<span style="color:#75715e">//若元素个数为奇数时
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            {
</span></span><span style="display:flex;"><span>                endA <span style="color:#f92672">=</span> midA;  <span style="color:#75715e">//舍弃A中间点以后的部分且保留中间点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                startB <span style="color:#f92672">=</span> midB;<span style="color:#75715e">//舍弃B中间点以前的部分且保留中间点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            } <span style="color:#66d9ef">else</span>  <span style="color:#75715e">//若元素个数为偶数时
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            {
</span></span><span style="display:flex;"><span>                endA <span style="color:#f92672">=</span> midA;       <span style="color:#75715e">//舍弃A的后半部分
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                startB <span style="color:#f92672">=</span> midB <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;   <span style="color:#75715e">//舍弃B的前半部分
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> A[startA] <span style="color:#f92672">&lt;</span> B[startB] <span style="color:#f92672">?</span> A[startA] <span style="color:#f92672">:</span> B[startB]; <span style="color:#75715e">//较小者即为所求
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><ul>
<li>
<p>若$A$和$B$数组的长度为$2k+1$，取$A$数组的中位数为$A[k]$，$B$数组的中位数为$B[k]$，$A$和$B$组合起来的中位数应该是第$2k+1$大的那个数。如果$A[k]==B[k]$，则$A[k]$必定为第$2k+1$大的数，是所有数字的中位数。如果$A[k]\gt B[k]$，则$A[k]$至少为第$2k+2$大的数，$B[k]$至多为第$2k+1$大的数，中位数介于$B[k]$和$A[k]$之间。</p>
</li>
<li>
<p>若$A$和$B$数组的长度为$2k$，按照题目所述条件，则$A$的中位数为$A[k-1]$,则$B$的中位数为$B[k-1]$,$A$和$B$组合起来的中位数应该是第$2k$大的那个数，若$A[k-1]==B[k-1]$,则$B[k-1]$必为第$2k$大的那个数，即所有数字的中位数。如果$A[k-1]\gt B[k-1]$，则$A[k-1]$至少为第$2k$大的数，<font color=red>$B[k-1]$至多为第$2k-1$大的数，中位数介于$B[k-1]$和$A[k-1]$之间。</font></p>
</li>
</ul>
<hr>
<h2 id="次数大于一半">次数大于一半</h2>
<p>已知一个整数序列<code>$A=(a_0,a_1,...,a_{n-1})$</code>，在这个序列中若存在<font color=Blue>「不要求连续的序列」</font><code>$a_{p_1} = ... = a_{p_m} = x，0&lt;= a_{i} &lt; n, m &gt; n/2 , (0 &lt;= p_k &lt; n, 1&lt;=k&lt;=m)$</code>,则称 $x 为 A$ 的主元素，例如$A=(0,5,5,3,5,7,5,5)$,则$5$为主元素；又如$A=(0,5,5,3,5,1,5,7)$，则$A$中没有<font color=Blue>主元素</font>。假设$A$中的 $n$ 个元素保存在一个一维数组中，请设一个尽可能高效的算法，找出$A$的主元素。若存在主元素，则输出该元素，否则输出$-1$。</p>
<h3 id="解法一-1">解法一</h3>
<p>主元素问题方法一：对数组中元素进行计数，然后查看出现次数最多的元素，若次数大于一半，则为主元素。这种方式只需要对数组扫描一遍，时间复杂度为$O(n)$,空间复杂度为$O(n)$。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">moreThanHalf</span>(<span style="color:#66d9ef">int</span> A[],<span style="color:#66d9ef">int</span> n)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>count<span style="color:#f92672">=</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>)<span style="color:#f92672">*</span>n);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> index<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>) count[i]<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    count[A[i]]<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(count[A[i]) <span style="color:#f92672">&gt;</span> count[A[index]]) index<span style="color:#f92672">=</span>A[i];
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(count[index]<span style="color:#f92672">&gt;</span>(n<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>))  
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">return</span> index;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span> 
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h3 id="解法二-1">解法二</h3>
<p>首先使用快速排序，将元素排好序，然后统计相同元素出现的最大次数。统计的时候可以使用求最长平台的算法。时间复杂度为$O(nlogn)$,空间复杂度为$O(n)$。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">quickSort</span>(<span style="color:#66d9ef">int</span> A[],<span style="color:#66d9ef">int</span> start,<span style="color:#66d9ef">int</span> end)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>start,j<span style="color:#f92672">=</span>end;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span>(i<span style="color:#f92672">&lt;</span>j)
</span></span><span style="display:flex;"><span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(i<span style="color:#f92672">&lt;</span>j)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">while</span>(i<span style="color:#f92672">&lt;</span>j <span style="color:#f92672">&amp;&amp;</span> A[j]<span style="color:#f92672">&gt;</span>tmp) j<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>      A[i]<span style="color:#f92672">=</span>A[j];
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span>(i<span style="color:#f92672">&lt;</span>j)
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        A[i]<span style="color:#f92672">=</span>A[j];
</span></span><span style="display:flex;"><span>        i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>       } 
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">while</span>(i<span style="color:#f92672">&lt;</span>j <span style="color:#f92672">&amp;&amp;</span> A[i]<span style="color:#f92672">&lt;=</span>tmp) i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span>(i<span style="color:#f92672">&lt;</span>j)
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        A[j]<span style="color:#f92672">=</span>A[i];
</span></span><span style="display:flex;"><span>        j<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>       } 
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    quickSort(A,start,i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    quickSort(A, i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, end);
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//然后使用平台算法
</span></span></span></code></pre></div><hr>
<h3 id="解法三">解法三</h3>
<p>数组中存在主元素时，所有的非主元素个数和必少于一半。如<font color=red>让主元素与一个非主元素&quot;配对“，则最后多出来的元素（没有元素与之配对）就是主元素。</font>从前往后扫描数组元素，假定遇到的当前值选定为主元素，再次遇到它时计数加1，遇到不等的值时，计数减1。当计数减为0后，将遇到的下一个值重新选定为主元素。扫描完毕，当前选定的元素（计数值大于0）可能是主元素，但未必是主元素。还需要对数组再进行一次扫描，记录它出现的实际个数，以判定它是否是主元素。时间复杂度为$O(n)$,空间复杂度为 $O(1)$。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">moreThanHalf</span>(<span style="color:#66d9ef">int</span> A[],<span style="color:#66d9ef">int</span> n)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">int</span> pivot<span style="color:#f92672">=</span>A[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">int</span> count<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">int</span> count2<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span> {
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">if</span>(A[i]<span style="color:#f92672">==</span>base)
</span></span><span style="display:flex;"><span>      count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">else</span> 
</span></span><span style="display:flex;"><span>   {  
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">if</span>(count<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span>) count<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">else</span> 
</span></span><span style="display:flex;"><span>       {
</span></span><span style="display:flex;"><span>        pivot<span style="color:#f92672">=</span>A[i];
</span></span><span style="display:flex;"><span>        count<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>       }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span>(count <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>)   
</span></span><span style="display:flex;"><span> {
</span></span><span style="display:flex;"><span>    count2<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span>(pivot<span style="color:#f92672">==</span>A[i])
</span></span><span style="display:flex;"><span>        count2<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(count2 <span style="color:#f92672">&gt;</span> n<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> pivot;
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ERROR; <span style="color:#75715e">//ERROR 代表不会在序列中出现的那个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><hr>

    </div>
    <footer class="post-footer">
        
 
<div class="post-tags">     
     
    <a href="https://iihui.github.io/tags/%e7%ae%97%e6%b3%95" rel="tag" title="算法">#算法#</a>
    
</div>



        <div class="post-nav">
    <div class="post-nav-next post-nav-item">
    
        <a href="https://iihui.github.io/about/" rel="next" title="关于我">
        <i class="fa fa-chevron-left"></i> 关于我
        </a>
    
    </div>

    <div class="post-nav-prev post-nav-item">
    
        <a href="https://iihui.github.io/post/go-label/" rel="prev" title="Go 标签">
        Go 标签 <i class="fa fa-chevron-right"></i>
        </a>
    
    </div>
</div>
      
        <div class="post-nav">
    <div style="border: 1px dashed #e0e0e0; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
        <div style="float:left;margin-top:0px;">
            <img src="https://i.loli.net/2020/02/09/SvhUdz4XJsOr9Vk.jpg" width="128px" height="128px"/>
            <div style="text-align:center;">谢谢支持!</div>
        </div>
        <div>
            <p style="margin-top:10px;">
                标题：线性表
                <br />作者：阿呆<a target="_blank" href="https://iihui.github.io/"></a>
                
                <br />地址：https://iihui.github.io/post/arith-linear-list/
                <br />声明：自由转载-非商用-保持署名（创作共享4.0许可证）
            </p>
        </div>
    </div>
    <div class="clear"></div>
</div>
        
        
        




    </footer>
  </article>
</section>

          </div>
        </div>
        <div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>
<aside id="sidebar" class="sidebar">
  <div class="sidebar-inner">

  <ul class="sidebar-nav motion-element">
    <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
      文章目录
    </li>
    <li class="sidebar-nav-overview" data-target="site-overview">
      站点概览
    </li>
  </ul>

    <section class="site-overview sidebar-panel ">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
        src="https://i.loli.net/2020/02/07/dVFzrvZkHRNq2lL.jpg"
        alt="" />
    <p class="site-author-name" itemprop="name"></p>
    <p class="site-description motion-element" itemprop="description"> 
        coder &amp; cook</p>
</div>
      <nav class="site-state motion-element">
    <div class="site-state-item site-state-posts">
      <a href="https://iihui.github.io/post/">
        <span class="site-state-item-count">142</span>
        <span class="site-state-item-name">日志</span>
      </a>
    </div>
    <div class="site-state-item site-state-categories">    
        <a href="https://iihui.github.io/categories/">      
         
        <span class="site-state-item-count">17</span>
        
        <span class="site-state-item-name">分类</span>
        
        </a>
    </div>

    <div class="site-state-item site-state-tags">
        <a href="https://iihui.github.io/tags/">
         
        <span class="site-state-item-count">28</span>
        
        <span class="site-state-item-name">标签</span>
        </a>
    </div>
</nav>
      
      
<div class="links-of-author motion-element">
    
        <span class="links-of-author-item">
        <a href="https://coolshell.cn" target="_blank" title="皓 大">
            <i class="fa fa-fw fa-globe"></i>
            皓 大
        </a>
        </span>
    
        <span class="links-of-author-item">
        <a href="http://www.ruanyifeng.com" target="_blank" title="阮 大">
            <i class="fa fa-fw fa-globe"></i>
            阮 大
        </a>
        </span>
    
        <span class="links-of-author-item">
        <a href="https://juejin.im/" target="_blank" title="掘 金">
            <i class="fa fa-fw fa-globe"></i>
            掘 金
        </a>
        </span>
    
        <span class="links-of-author-item">
        <a href="http://www.ideamsg.com" target="_blank" title="灵 感">
            <i class="fa fa-fw fa-globe"></i>
            灵 感
        </a>
        </span>
    
</div>


      

      <div class="links-of-blogroll motion-element inline">
<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=&amp;m=0&amp;s=220&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;bv=35" async="async"></script>
</div>

    </section>
    
<section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
    <div class="post-toc">
        <div class="post-toc-content"><nav id="TableOfContents">
  <ul>
    <li><a href="#逻辑结构">逻辑结构</a></li>
    <li><a href="#存储结构">存储结构</a></li>
    <li><a href="#顺序表">顺序表</a>
      <ul>
        <li><a href="#顺序表的特点">顺序表的特点</a></li>
        <li><a href="#描述顺序表的结构">描述顺序表的结构</a></li>
      </ul>
    </li>
    <li><a href="#一些习题">一些习题</a>
      <ul>
        <li><a href="#最长平台">最长平台</a></li>
        <li><a href="#以key为轴调整">以key为轴调整</a></li>
        <li><a href="#以第一个元素为轴调整">以第一个元素为轴调整</a></li>
        <li><a href="#删除元素">删除元素</a></li>
      </ul>
    </li>
    <li><a href="#单链表">单链表</a>
      <ul>
        <li><a href="#建立单链表">建立单链表</a></li>
        <li><a href="#基本操作">基本操作</a></li>
        <li><a href="#就地逆置">就地逆置</a></li>
        <li><a href="#拆分链表">拆分链表</a></li>
        <li><a href="#递增排序">递增排序</a></li>
        <li><a href="#公共节点">公共节点</a></li>
      </ul>
    </li>
    <li><a href="#精选习题">精选习题</a>
      <ul>
        <li><a href="#循环左移">循环左移</a></li>
        <li><a href="#寻找中位数">寻找中位数</a>
          <ul>
            <li><a href="#解法一">解法一</a></li>
            <li><a href="#解法二">解法二</a></li>
          </ul>
        </li>
        <li><a href="#次数大于一半">次数大于一半</a>
          <ul>
            <li><a href="#解法一-1">解法一</a></li>
            <li><a href="#解法二-1">解法二</a></li>
            <li><a href="#解法三">解法三</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav></div>
    </div>
</section>

  </div>
</aside>

      </div>
    </main>
   
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  <span itemprop="copyrightYear">  &copy; 
  2017 - 2022</span>
  <span class="with-love"><i class="fa fa-heart"></i></span>
  <span class="author" itemprop="copyrightHolder">Keep It Simple</span>
</div>




      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      <span id="scrollpercent"><span>0</span>%</span>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/jquery/index.js?v=2.1.3"></script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script> 
<script type="text/javascript" src="https://iihui.github.io/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/velocity/velocity.min.js?v=1.2.1"></script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="https://iihui.github.io/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>

<script src="https://iihui.github.io/js/vendor/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>

<script type="text/javascript" src="https://iihui.github.io/js/utils.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/motion.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/affix.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/schemes/pisces.js"></script>

<script type="text/javascript" src="https://iihui.github.io/js/scrollspy.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/post-details.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/toc.js"></script>

<script type="text/javascript" src="https://iihui.github.io/js/bootstrap.js"></script>

<script type="text/javascript" src="https://iihui.github.io/js/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
</body>
</html>