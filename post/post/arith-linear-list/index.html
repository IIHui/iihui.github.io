<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
    <title>线性表 - Keep It Simple</title>
    <meta name="keywords" content="博客,思考,读书,笔记,技术,分享">
    
    <meta property="og:title" content="线性表">
    <meta property="og:site_name" content="Keep It Simple">
    <meta property="og:image" content="/img/author.jpg"> 
    <meta name="title" content="线性表 - Keep It Simple" />
    <meta name="description" content="Swift | Go | C&#43;&#43; "> 
    <link rel="shortcut icon" href="https://iihui.github.io/img/favicon.ico" />
    <link rel="apple-touch-icon" href="https://iihui.github.io/img/apple-touch-icon.png" />
    <link rel="apple-touch-icon-precomposed" href="https://iihui.github.io/img/apple-touch-icon.png" />
    <link href="https://iihui.github.io/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />
    <link href="https://iihui.github.io/js/vendor/fancybox/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />
    <link href="https://iihui.github.io/css/main.css" rel="stylesheet" type="text/css" />
    <link href="https://iihui.github.io/css/custom.css" rel="stylesheet" type="text/css" />
    <link href="https://iihui.github.io/css/syntax.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
     fancybox: true, 
    motion: true
  };
</script>

    <link href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/monokai-sublime.min.css" rel="stylesheet">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/go.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/swift.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/objectivec.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/clojure.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/cpp.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>


</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<div class="container one-collumn sidebar-position-left page-home  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-meta  custom-logo ">

  <div class="custom-logo-site-title">
    <a href="https://iihui.github.io/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Keep It Simple</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">靡不有初，鲜克有终</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
    <ul id="menu" class="menu">
      
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/tags/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-tag"></i> <br />标签
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/post/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/categories/%E7%BE%8E%E9%A3%9F/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-fire"></i> <br />美食
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/categories/%E5%90%8E%E6%9C%9F/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-edit"></i> <br />后期
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/categories/%E6%97%85%E8%A1%8C/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-leaf"></i> <br />旅行
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/about/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于
          </a>
        </li>
      
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger"> <i class="menu-item-icon fa fa-search fa-fw"></i> <br /> 搜索</a>
      </li>
    </ul>
    <div class="site-search">
      <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>

    </div>
</nav>
<script type="text/javascript"
        async
        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
		<!-- src = "http://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> <\!--  -\-> -->
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>

<!DOCTYPE html>
<html lang="en">


<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css" integrity="sha384-D+9gmBxUQogRLqvARvNLmA9hS2x//eK1FhVb9PiU86gmcrBrJAQT8okdJ4LMp2uv" crossorigin="anonymous">

    
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js" integrity="sha384-483A6DwYfKeDa0Q52fJmxFXkcPCFfnXMoXblOkJ4JcA8zATN6Tm78UNL72AKk+0O" crossorigin="anonymous"></script>
</head>
<body>

</body>
</html>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
<section id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="https://iihui.github.io/post/post/arith-linear-list/" itemprop="url">
        线性表
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">创建: </span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2018-04-25">
    2018-04-25
</time>
</span>
&nbsp; | &nbsp;
<span class="post-updated-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-check-o"></i>
</span>
<span class="post-meta-item-text">更新: </span>
<time itemprop="dateUpdated" content="2018-04-25">
    2018-04-25
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类: </span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="https://iihui.github.io/categories/%E7%AE%97%E6%B3%95" itemprop="url" rel="index">
        <span itemprop="name">算法</span>
      </a>
      &nbsp; 
    </span>
  
</span>


      <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-file-word-o"></i>
</span>
<span class="post-meta-item-text">字数: </span>
<span class="leancloud-visitors-count">6142</span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-coffee"></i>
</span>
<span class="post-meta-item-text">阅读: </span>
<span class="leancloud-visitors-count">13 分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <blockquote>
<p>线性表是由 $n$个具有相同特性的元素$(n \ge 0)$ 组成的一个有限序列，是一种逻辑结构。它的特征在于：①表中所有<!-- raw HTML omitted -->数据元素类型相同<!-- raw HTML omitted -->。②表由<!-- raw HTML omitted -->有限个数据元素构成<!-- raw HTML omitted -->。③表中<!-- raw HTML omitted -->数据元素是位置相关的<!-- raw HTML omitted -->（这一点表明线性表不同于集合)，并且每个元素都有一个对应的序号，表中<!-- raw HTML omitted -->元素可以重复出现。<!-- raw HTML omitted --></p>
</blockquote>
<h1 id="逻辑结构">逻辑结构</h1>
<p>线性表是一种逻辑结构，其一般表示为: ($a_1,a_2,&hellip;,a_{i-1},a_i,a_{i+1},&hellip;,a_n$)</p>
<ul>
<li>
<p>除了<!-- raw HTML omitted -->起始元素$a_1$没有前驱元素<!-- raw HTML omitted -->之外，其他元素$a_i$<!-- raw HTML omitted -->有且仅有一个<!-- raw HTML omitted -->前驱元素$a_{i-1}$。</p>
</li>
<li>
<p>除了<!-- raw HTML omitted -->终端元素$a_n$没有后继元素<!-- raw HTML omitted -->外，其他元素$a_i$<!-- raw HTML omitted -->有且仅有一个<!-- raw HTML omitted -->后继元素$a_{i+1}$。</p>
</li>
</ul>
<p>根据上面的表示，在线性表中，每个元素至多只有一个前驱元素，并且至多只有一个后继元素。</p>
<h1 id="存储结构">存储结构</h1>
<p>线性表是一种<!-- raw HTML omitted -->逻辑结构<!-- raw HTML omitted -->，其存储结构有两种：</p>
<ul>
<li>
<p>顺序存储：顺序表</p>
</li>
<li>
<p>链式存储：单链表</p>
</li>
</ul>
<h1 id="顺序表">顺序表</h1>
<p>线性表的顺序存储是指<!-- raw HTML omitted -->一组地址连续的存储单元依次存储线性表中的各个元素<!-- raw HTML omitted -->，使得线性表中在逻辑结构上相邻的数据元素存储在相邻的物理存储单元中。即通过数据元素<!-- raw HTML omitted -->物理存储的相邻关系来反映数据元素之间逻辑上的相邻关系<!-- raw HTML omitted -->，采用顺序存储结构的线性表通常称为顺序表。</p>
<h2 id="顺序表的特点">顺序表的特点</h2>
<p>根据顺序表的定义，总结顺序表有以下的特征：</p>
<ul>
<li>
<p>属于直接映射——<!-- raw HTML omitted -->逻辑上相邻的元素，其物理位置也相邻<!-- raw HTML omitted -->。</p>
</li>
<li>
<p>具有随机存取特性，通过<!-- raw HTML omitted -->首地址和元素序号<!-- raw HTML omitted -->可以在 $O(1)$ 时间内找到指定元素。</p>
</li>
<li>
<p>存储密度高，其值为$1$。$存储密度=\frac{节点数据本身所占用的存储量}{节点结构占用的存储量}$</p>
</li>
<li>
<p>删除和插入元素需要移动大量元素：</p>
<ul>
<li>
<p>插入元素移动的平均次数$=\frac{1}{n}\sum_{i=1}^{n}(n-i+1)=\frac{n}{2}$, 因此时间复杂度为$O(n)$。</p>
</li>
<li>
<p>删除元素移动的平均次数$=\frac{1}{n}\sum_{i=1}^{n}(n-i)=\frac{n-1}{2}$，因此时间复杂度为$O(n)$。</p>
</li>
</ul>
</li>
</ul>
<h2 id="描述顺序表的结构">描述顺序表的结构</h2>
<p>为了描述顺序表，需要知道：① 顺序表的起始地址；② 顺序表的最大长度；③ 顺序表的当前长度。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#define MaxSize 1000
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#66d9ef">int</span> data[MaxSize];
    <span style="color:#66d9ef">int</span> length;
} SqList;
</code></pre></div><h2 id="一些习题">一些习题</h2>
<h3 id="最长平台">最长平台</h3>
<p>给定一个有$n$个元素的整型数组$data$,其中连续的<!-- raw HTML omitted -->相等元素构成的子序列<!-- raw HTML omitted -->称为平台，请设计一个算法求 $data$ 中最长平台的长度。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">int</span> linerArith<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>maximumPlatform(T <span style="color:#f92672">*</span>data, <span style="color:#66d9ef">int</span> length) {
    <span style="color:#66d9ef">int</span> start <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">int</span> maxLen <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">int</span> curLen <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;

    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> length; <span style="color:#f92672">++</span>i) {
        <span style="color:#66d9ef">if</span> (data[i] <span style="color:#f92672">==</span> data[start]) {
            curLen<span style="color:#f92672">++</span>;
        } <span style="color:#66d9ef">else</span> {
            <span style="color:#66d9ef">if</span> (curLen <span style="color:#f92672">&gt;</span> maxLen) {
                maxLen <span style="color:#f92672">=</span> curLen;
            }
            curLen <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
            start <span style="color:#f92672">=</span> i;
        }
    }
    <span style="color:#75715e">//可能最后一个连续的子序列为最大平台
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (curLen <span style="color:#f92672">&gt;</span> maxLen) {
        maxLen <span style="color:#f92672">=</span> curLen;
    }
    <span style="color:#66d9ef">return</span> maxLen;
}
</code></pre></div><h3 id="以key为轴调整">以key为轴调整</h3>
<p>设有一个数组 $data$ , 其元素为整型数据，设计一个算法将 $data$ 中所有小于 $key$ 的整数放在前半部分，大于等于 $key$ 的整数放在后半部分。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> linerArith<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>rotate(T <span style="color:#f92672">*</span>data, <span style="color:#66d9ef">int</span> length, <span style="color:#66d9ef">int</span> key) {
    assert(length <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>);
    <span style="color:#66d9ef">int</span> start <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, end <span style="color:#f92672">=</span> length <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">while</span> (start <span style="color:#f92672">&lt;</span> end) {
        <span style="color:#66d9ef">while</span> (start <span style="color:#f92672">&lt;</span> end <span style="color:#f92672">&amp;&amp;</span> data[start] <span style="color:#f92672">&lt;</span> key) {
            start<span style="color:#f92672">++</span>;
        }
        <span style="color:#66d9ef">while</span> (start <span style="color:#f92672">&lt;</span> end <span style="color:#f92672">&amp;&amp;</span> data[end] <span style="color:#f92672">&gt;=</span> key) {
            end<span style="color:#f92672">--</span>;
        }
        <span style="color:#66d9ef">if</span> (start <span style="color:#f92672">&lt;</span> end) {
            std<span style="color:#f92672">::</span>swap(data[start], data[end]);
        }
    }
}
</code></pre></div><h3 id="以第一个元素为轴调整">以第一个元素为轴调整</h3>
<p>设有一个数组 $data$，其元素为整型。设计一个尽可能高效的算法，<!-- raw HTML omitted -->以第一个元素为分界线<!-- raw HTML omitted -->，将所有小于等于它的元素移到该元素前面，将所有大于它的元素移到该元素的后面。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> linerArith<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>rotateByFirst(T <span style="color:#f92672">*</span>data, <span style="color:#66d9ef">int</span> length) {
    assert(length <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>);
    <span style="color:#66d9ef">int</span> start <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, end <span style="color:#f92672">=</span> length <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
    T pivot <span style="color:#f92672">=</span> data[<span style="color:#ae81ff">0</span>];

    <span style="color:#66d9ef">while</span> (start <span style="color:#f92672">&lt;</span> end) {
        <span style="color:#66d9ef">while</span> (start <span style="color:#f92672">&lt;</span> end <span style="color:#f92672">&amp;&amp;</span> data[start] <span style="color:#f92672">&lt;=</span> pivot) {
            start<span style="color:#f92672">++</span>;
        }

        <span style="color:#66d9ef">while</span> (start <span style="color:#f92672">&lt;</span> end <span style="color:#f92672">&amp;&amp;</span> data[end] <span style="color:#f92672">&gt;</span> pivot) {
            end<span style="color:#f92672">--</span>;
        }

        <span style="color:#66d9ef">if</span> (start <span style="color:#f92672">&lt;</span> end) {
            std<span style="color:#f92672">::</span>swap(data[start], data[end]);
        }
    }
    <span style="color:#75715e">//因为忽略了第一个元素，因此这里需要检查最终位置的那个元素和第一个元素的大小关系
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (data[start] <span style="color:#f92672">&lt;</span> pivot) {
        std<span style="color:#f92672">::</span>swap(data[start], data[<span style="color:#ae81ff">0</span>]);
    }
}

<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> linerArith<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>rotateByFirstVersion2(T <span style="color:#f92672">*</span>data, <span style="color:#66d9ef">int</span> length) {
    assert(length <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>);
    <span style="color:#66d9ef">int</span> start <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, end <span style="color:#f92672">=</span> length <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">int</span> pivot <span style="color:#f92672">=</span> data[<span style="color:#ae81ff">0</span>];

    <span style="color:#66d9ef">while</span> (start <span style="color:#f92672">&lt;</span> end) {
        <span style="color:#66d9ef">while</span> (start <span style="color:#f92672">&lt;</span> end <span style="color:#f92672">&amp;&amp;</span> data[end] <span style="color:#f92672">&gt;</span> pivot) {
            end<span style="color:#f92672">--</span>;
        }
        <span style="color:#66d9ef">if</span> (start <span style="color:#f92672">&lt;</span> end) {
            data[start<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> data[end];
        }

        <span style="color:#66d9ef">while</span> (start <span style="color:#f92672">&lt;</span> end <span style="color:#f92672">&amp;&amp;</span> data[start] <span style="color:#f92672">&lt;=</span> pivot) {
            start<span style="color:#f92672">++</span>;
        }
        <span style="color:#66d9ef">if</span> (start <span style="color:#f92672">&lt;</span> end) {
            data[end<span style="color:#f92672">--</span>] <span style="color:#f92672">=</span> data[start];
        }
    }
    data[start] <span style="color:#f92672">=</span> pivot; <span style="color:#75715e">//找到最终位置
</span><span style="color:#75715e"></span>}

<span style="color:#75715e">//剑指offer里快速排序的思路,该算法可以保持相对次序不变
</span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> linerArith<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>rotateByFirstVersion3(T <span style="color:#f92672">*</span>data, <span style="color:#66d9ef">int</span> length) {
    assert(length <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>);
    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    T pivot <span style="color:#f92672">=</span> data[<span style="color:#ae81ff">0</span>];
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span> length; <span style="color:#f92672">++</span>j) {
        <span style="color:#75715e">//是小于不是&lt;=,因为第一个元素要被替换掉
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (data[j] <span style="color:#f92672">&lt;</span> pivot) {
            i<span style="color:#f92672">++</span>;
            <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&lt;</span> j) {
                std<span style="color:#f92672">::</span>swap(data[i], data[j]);
            }
        }
    }
    <span style="color:#75715e">//最后交换下标为0的元素和下标为i的元素
</span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>swap(data[<span style="color:#ae81ff">0</span>],data[i]);
}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">move1</span>(SqList <span style="color:#f92672">&amp;</span>L) {
    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    j <span style="color:#f92672">=</span> L.length <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">int</span> pivot <span style="color:#f92672">=</span> L.data[<span style="color:#ae81ff">0</span>];
    <span style="color:#66d9ef">int</span> tmp;

    <span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;</span> j) {
        <span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;</span> j <span style="color:#f92672">&amp;&amp;</span> L.data[j] <span style="color:#f92672">&gt;</span> pivot)
            j<span style="color:#f92672">--</span>;
        <span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;</span> j <span style="color:#f92672">&amp;&amp;</span> L.data[i] <span style="color:#f92672">&lt;=</span> pivot)  <span style="color:#75715e">//第一个元素肯定会被忽略掉
</span><span style="color:#75715e"></span>            i<span style="color:#f92672">++</span>;

        <span style="color:#75715e">//此处可以添加一个 i &lt; j 的判断，这里省略掉是因为前面已经判断i&lt;j,
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//所以到这里的时候最多也是i==j, 这时候直接交换也是没有副作用的
</span><span style="color:#75715e"></span>        tmp <span style="color:#f92672">=</span> L.data[i];
        L.data[i] <span style="color:#f92672">=</span> L.data[j];
        L.data[j] <span style="color:#f92672">=</span> tmp;

    }

    <span style="color:#66d9ef">if</span> (L.data[i] <span style="color:#f92672">&lt;</span> pivot)<span style="color:#75715e">//因为忽略了第一个元素，因此这里需要检查最终位置的那个元素和第一个元素的大小关系
</span><span style="color:#75715e"></span>    {
        tmp <span style="color:#f92672">=</span> L.data[<span style="color:#ae81ff">0</span>];
        L.data[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> L.data[i];
        L.data[i] <span style="color:#f92672">=</span> tmp;
    }
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">move2</span>(SqList <span style="color:#f92672">&amp;</span>L) {
    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, j <span style="color:#f92672">=</span> L.length <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">int</span> pivot <span style="color:#f92672">=</span> L.data[<span style="color:#ae81ff">0</span>];

    <span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;</span> j) {
        <span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;</span> j <span style="color:#f92672">&amp;&amp;</span> L.data[j] <span style="color:#f92672">&gt;</span> pivot) j<span style="color:#f92672">--</span>; <span style="color:#75715e">//先从最后开始，因为第一个元素需要首先被替换
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&lt;</span> j) {
            L.data[i] <span style="color:#f92672">=</span> L.data[j];
            i<span style="color:#f92672">++</span>;
        }

        <span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;</span> j <span style="color:#f92672">&amp;&amp;</span> L.data[i] <span style="color:#f92672">&lt;=</span> pivot) i<span style="color:#f92672">++</span>;
        <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&lt;</span> j) {
            L.data[j] <span style="color:#f92672">=</span> L.data[i];
            j<span style="color:#f92672">--</span>;
        }
    }
    L.data[i] <span style="color:#f92672">=</span> pivot;  <span style="color:#75715e">//最后找到最终的位置
</span><span style="color:#75715e"></span>}


<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">move3</span>(SqList <span style="color:#f92672">&amp;</span>L) <span style="color:#75715e">//剑指offer里快速排序的思路
</span><span style="color:#75715e"></span>{                     <span style="color:#75715e">//该算法可以保持相对次序不变
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">int</span> pivot <span style="color:#f92672">=</span> L.data[<span style="color:#ae81ff">0</span>];
    <span style="color:#66d9ef">int</span> tmp;

    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span> L.length; j<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">if</span> (data[j] <span style="color:#f92672">&lt;</span> pivot) {
            i<span style="color:#f92672">++</span>;
            <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&lt;</span> j)  <span style="color:#75715e">//是小于不是&lt;=,因为第一个元素要被替换掉
</span><span style="color:#75715e"></span>            {
                tmp <span style="color:#f92672">=</span> L.data[i];
                L.data[i] <span style="color:#f92672">=</span> L.data[j];
                L.data[j] <span style="color:#f92672">=</span> tmp;
            }
        }
    }
    tmp <span style="color:#f92672">=</span> L.data[<span style="color:#ae81ff">0</span>];  <span style="color:#75715e">//最后交换下标为0的元素和下标为i的元素
</span><span style="color:#75715e"></span>    L.data[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> L.data[i];
    L.data[i] <span style="color:#f92672">=</span> tmp;
}
</code></pre></div><h3 id="删除元素">删除元素</h3>
<p>已知长度为$n$的数组$data$，编写一个时间复杂度为$O(n)$,空间复杂度为$O(1)$ 的算法，该算法删除线性表中所有值为$value$的元素。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">int</span> linerArith<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>deleteSameElement(T <span style="color:#f92672">*</span>data, <span style="color:#66d9ef">int</span> length, <span style="color:#66d9ef">int</span> value) {
    assert(length <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>);
    <span style="color:#66d9ef">int</span> base <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> length; <span style="color:#f92672">++</span>i) {
        <span style="color:#66d9ef">if</span> (data[i] <span style="color:#f92672">!=</span> value) {
            data[base<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> data[i];
        }
    }
    <span style="color:#66d9ef">return</span> base;
}

<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">int</span> linerArith<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>deleteSameElement(T <span style="color:#f92672">*</span>data, <span style="color:#66d9ef">int</span> length, <span style="color:#66d9ef">int</span> value) {
    assert(length <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>);
    <span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;   <span style="color:#75715e">//不同的是记录目前等于value的元素个数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> length; <span style="color:#f92672">++</span>i) {
        <span style="color:#66d9ef">if</span> (data[i] <span style="color:#f92672">==</span> value) {
            count<span style="color:#f92672">++</span>;
        } <span style="color:#66d9ef">else</span> {
            data[i <span style="color:#f92672">-</span> count] <span style="color:#f92672">=</span> data[i];
        }
    }
    <span style="color:#66d9ef">return</span> length <span style="color:#f92672">-</span> count;
}
</code></pre></div><p>一般<!-- raw HTML omitted -->类似的题目<!-- raw HTML omitted -->有：已知长度为 $n$ 的线性表 $L$ 采用顺序存储结构，试设计一个时间复杂度空间复杂度两方面都尽可能高效的算法，该算法删除线性表中元素值为$[x,y]$之间的所有数据元素。</p>
<h1 id="单链表">单链表</h1>
<p>单链表是<!-- raw HTML omitted -->任意一组存储单元存放线性表中的元素<!-- raw HTML omitted -->，每个节点通过一个指针指向其后继节点。这组<!-- raw HTML omitted -->存储单元可以是连续的也可以是不连续的。<!-- raw HTML omitted -->单链表具有如下的特点：</p>
<ul>
<li>
<p>通过首节点(带<!-- raw HTML omitted -->哨兵节点<!-- raw HTML omitted -->或不带哨兵节点)的指针来标识一个单链表。</p>
</li>
<li>
<p>从一个已知节点出发，<!-- raw HTML omitted -->只能访问该节点和通过 $next$ 指针访问其后继节点<!-- raw HTML omitted -->，<!-- raw HTML omitted -->无法直接找到<!-- raw HTML omitted -->该节点之前的其他节点。</p>
</li>
<li>
<p>在单链表中插入一个节点或者删除一个节点必须找到其前驱节点，<!-- raw HTML omitted -->插入和删除操作不需要移动节点<!-- raw HTML omitted -->。「<!-- raw HTML omitted -->删除一个节点也可以不用知道其前驱节点<!-- raw HTML omitted -->，只要将其后继节点的元素内容往前移到当前节点，并将当前节点的后继修改为其后继节点的后继节点，然后删除后继节点即可。<!-- raw HTML omitted -->但是要考虑该节点是否为最后一个节点，或者第一个节点」<!-- raw HTML omitted --></p>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">LinkedNode</span> {
    T data;  <span style="color:#75715e">//T表示数据类型
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">LinkedNode</span> <span style="color:#f92672">*</span>next;
} LinkedList;
</code></pre></div><hr>
<h2 id="建立单链表">建立单链表</h2>
<p>建立单链表有两种方式，一种是从头部插入；另一种是从尾部插入。从头部插入节点生成的单链表，最后<!-- raw HTML omitted -->节点元素顺序与插入元素的顺序相反，即成逆序排列了。<!-- raw HTML omitted --></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">creatLinkedList</span>(LinkedList <span style="color:#f92672">*&amp;</span>L, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>a, <span style="color:#66d9ef">int</span> n) {
    LinkedList <span style="color:#f92672">*</span>cur;
    L <span style="color:#f92672">=</span> (LinkedList <span style="color:#f92672">*</span>) malloc(<span style="color:#66d9ef">sizeof</span>(LinkedList));
    L<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;

    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
        cur <span style="color:#f92672">=</span> (LinkedList <span style="color:#f92672">*</span>)(malloc(<span style="color:#66d9ef">sizeof</span>(LinkedList)));
        cur<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> a[i];
        cur<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> L<span style="color:#f92672">-&gt;</span>next;
        L<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> cur;  <span style="color:#75715e">//当前节点成为哨兵节点的下一个节点
</span><span style="color:#75715e"></span>    }
}
</code></pre></div><p>尾插法是在单链表的尾部插入节点元素，最后<!-- raw HTML omitted -->生成的单链表的节点元素顺序和插入元素的顺序是相同的<!-- raw HTML omitted -->。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">creatLinkedList</span>(LinkedList <span style="color:#f92672">*&amp;</span>L, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>a, <span style="color:#66d9ef">int</span> n) {
    LinkedList <span style="color:#f92672">*</span>cur, <span style="color:#f92672">*</span>tail;
    L <span style="color:#f92672">=</span> (LinkedList <span style="color:#f92672">*</span>) malloc(<span style="color:#66d9ef">sizeof</span>(LinkedList));
    tail <span style="color:#f92672">=</span> L; <span style="color:#75715e">//tail始终指向最后的节点，开始时指向链表的头结点
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
        cur <span style="color:#f92672">=</span> (LinkedList <span style="color:#f92672">*</span>) malloc(<span style="color:#66d9ef">sizeof</span>(LinkedList));
        cur<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> a[i];
        tail<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> cur;
        tail <span style="color:#f92672">=</span> cur;
    }
    tail<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
}
</code></pre></div><h2 id="基本操作">基本操作</h2>
<ol>
<li>按序号查找节点值算法</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">findNode</span>(LinkedList <span style="color:#f92672">*</span>L,<span style="color:#66d9ef">int</span> i,<span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>result)
{
  <span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
  LinkedList <span style="color:#f92672">*</span>cur<span style="color:#f92672">=</span>L;
  
  <span style="color:#66d9ef">while</span>(cur<span style="color:#f92672">!=</span>NULL <span style="color:#f92672">&amp;&amp;</span> j<span style="color:#f92672">&lt;</span>i)
  {
    j<span style="color:#f92672">++</span>;
    cur<span style="color:#f92672">=</span>cur<span style="color:#f92672">-&gt;</span>next;
  }
  <span style="color:#66d9ef">if</span>(NULL<span style="color:#f92672">==</span>cur) <span style="color:#66d9ef">return</span> false;
       
  result<span style="color:#f92672">=</span>cur<span style="color:#f92672">-&gt;</span>data;
  <span style="color:#66d9ef">return</span> true;
  
}
</code></pre></div><ol start="2">
<li>按元素值查找序号算法</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">findNode</span>(LinkedList <span style="color:#f92672">*</span>L,<span style="color:#66d9ef">int</span> key)
{
  LinkedList <span style="color:#f92672">*</span>cur<span style="color:#f92672">=</span>L<span style="color:#f92672">-&gt;</span>next;
  <span style="color:#66d9ef">int</span> index<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
  
  <span style="color:#66d9ef">while</span>(cur<span style="color:#f92672">!=</span>NULL <span style="color:#f92672">&amp;&amp;</span> cur<span style="color:#f92672">-&gt;</span>data<span style="color:#f92672">!=</span>key)
  {
    index<span style="color:#f92672">++</span>;
    cur<span style="color:#f92672">=</span>cur<span style="color:#f92672">-&gt;</span>next;
  }
  
  <span style="color:#66d9ef">if</span>(cur<span style="color:#f92672">!=</span>NULL) <span style="color:#66d9ef">return</span> index;
  <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;  <span style="color:#75715e">//返回-1，表示没有找到该元素
</span><span style="color:#75715e"></span>}
</code></pre></div><hr>
<ol start="3">
<li>
<p>插入元素：将值为$x$的元素的新节点插入到第$i$个节点的位置上，即先在单链表中找到插入节点的前驱节点，即第$i-1$个节点，再在其后插入新节点。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"> cur<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>pre<span style="color:#f92672">-&gt;</span>next;  <span style="color:#75715e">//cur表示将要插入到链表中的节点,插入的位置是节点pre之后
</span><span style="color:#75715e"></span> pre<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>cur;
</code></pre></div></li>
<li>
<p>删除元素:将单链表中的第$i$个节点删除。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"> cur<span style="color:#f92672">=</span>pre<span style="color:#f92672">-&gt;</span>next;     <span style="color:#75715e">//pre-&gt;next是待删除的节点，cur是待删除节点的上一个节点
</span><span style="color:#75715e"></span> pre<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>cur<span style="color:#f92672">-&gt;</span>next;
 free (cur);
</code></pre></div></li>
</ol>
<hr>
<h2 id="就地逆置">就地逆置</h2>
<p>有一个线性表$(a_1,a_2,&hellip;,a_n)$ 采用带哨兵节点的单链表$L$存储，设计一个就地算法将其就地逆置，<!-- raw HTML omitted -->所谓“就地”是指算法的辅助空间为$O(1)$。<!-- raw HTML omitted --></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">reverse</span>(LinkedList <span style="color:#f92672">*</span> <span style="color:#f92672">&amp;</span> L) <span style="color:#75715e">//传入引用
</span><span style="color:#75715e"></span>{
  LinkedList <span style="color:#f92672">*</span>cur<span style="color:#f92672">=</span>L<span style="color:#f92672">-&gt;</span>next;
  LinkedList <span style="color:#f92672">*</span>next;
  L<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>NULL;
  <span style="color:#66d9ef">while</span>(cur<span style="color:#f92672">!=</span>NULL)
  {
    next<span style="color:#f92672">=</span>ptr<span style="color:#f92672">-&gt;</span>next;    <span style="color:#75715e">//先保存下一个节点，然后使用头插法进行逆置
</span><span style="color:#75715e"></span>    cur<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>L<span style="color:#f92672">-&gt;</span>next; 
    L<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>cur;
    cur<span style="color:#f92672">=</span>next;
  }
}

</code></pre></div><hr>
<h2 id="拆分链表">拆分链表</h2>
<p>设$C={a_1,b_1,a_2,b_2,&hellip;,a_n,b_n}$ 为一线性表，采用带哨兵节点的$hc$单链表存放，设计一个就地算法，将其拆分为两个线性表（它们都是用单链表存放）使得$A={a_1,a_2,&hellip;,a_n},B={b_n,b_{n-1},&hellip;,b_2,b_1}$，即$A$是正序排列，$B$是逆序排列。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">//参数传入引用，ha存储是A，hb存储的是B
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">split</span>(LinkedList <span style="color:#f92672">*</span>hc,LinkedList <span style="color:#f92672">*&amp;</span>ha,LinkedList <span style="color:#f92672">*&amp;</span> hb)
{
  LinkedList <span style="color:#f92672">*</span>tail<span style="color:#f92672">=</span>ha;
  LinkedList <span style="color:#f92672">*</span>cur<span style="color:#f92672">=</span>hc<span style="color:#f92672">-&gt;</span>next;
  LinkedList <span style="color:#f92672">*</span>next;
  
  hb<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>NULL;
  <span style="color:#66d9ef">while</span>(cur <span style="color:#f92672">!=</span> NULL)
  {
    tail<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>cur;      <span style="color:#75715e">//尾插法
</span><span style="color:#75715e"></span>    tail<span style="color:#f92672">=</span>cur;
    
    cur<span style="color:#f92672">=</span>cur<span style="color:#f92672">-&gt;</span>next;
    
    next<span style="color:#f92672">=</span>cur<span style="color:#f92672">-&gt;</span>next;
    cur<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span> hb<span style="color:#f92672">-&gt;</span>next;  <span style="color:#75715e">//头插法
</span><span style="color:#75715e"></span>    hb<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span> cur;
    cur<span style="color:#f92672">=</span>next;
  }
  tail<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>NULL;  <span style="color:#75715e">//别忘了
</span><span style="color:#75715e"></span>}
</code></pre></div><h2 id="递增排序">递增排序</h2>
<p>有一个带哨兵结点的单链表$L$,设计一个算法使其元素<!-- raw HTML omitted -->递增有序<!-- raw HTML omitted -->。最基本的想法是使用<!-- raw HTML omitted -->直接插入排序<!-- raw HTML omitted -->的思想，一个一个排，不同于数组排序，这里<!-- raw HTML omitted -->单链表只能从头开始查找。<!-- raw HTML omitted --></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> sort<span style="color:#960050;background-color:#1e0010">（</span>LinkedList <span style="color:#f92672">*</span> <span style="color:#f92672">&amp;</span>L)
{
  LinkedList <span style="color:#f92672">*</span>cur<span style="color:#f92672">=</span>L<span style="color:#f92672">-&gt;</span>next;
  LinkedList <span style="color:#f92672">*</span>next<span style="color:#f92672">=</span>cur<span style="color:#f92672">-&gt;</span>next;
  LinkedList <span style="color:#f92672">*</span>pre,<span style="color:#f92672">*</span>assist; <span style="color:#75715e">//
</span><span style="color:#75715e"></span>  
  cur<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>NULL;   <span style="color:#75715e">//只含有一个元素的有序单链表
</span><span style="color:#75715e"></span>  cur<span style="color:#f92672">=</span>next;
  
  <span style="color:#66d9ef">while</span>(cur<span style="color:#f92672">!=</span>NULL)
  {
    next<span style="color:#f92672">=</span>cur<span style="color:#f92672">-&gt;</span>next;   <span style="color:#75715e">//首先保存下一个链表节点
</span><span style="color:#75715e"></span>    pre<span style="color:#f92672">=</span>L;            <span style="color:#75715e">//单链表只能从头开始往后寻找节点
</span><span style="color:#75715e"></span>    
    assist<span style="color:#f92672">=</span>pre<span style="color:#f92672">-&gt;</span>next; <span style="color:#75715e">//assist从头开始遍历
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span>(assist<span style="color:#f92672">!=</span>NULL <span style="color:#f92672">&amp;&amp;</span> assist<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">&lt;</span> cur<span style="color:#f92672">-&gt;</span>data)
    {
      pre<span style="color:#f92672">=</span>assist;   <span style="color:#75715e">//pre记录插入位置的前一个节点
</span><span style="color:#75715e"></span>      assist<span style="color:#f92672">=</span>assist<span style="color:#f92672">-&gt;</span>next;
    }
    
    cur<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>pre<span style="color:#f92672">-&gt;</span>next; <span style="color:#75715e">//pre的下一个节点就是要插入的位置
</span><span style="color:#75715e"></span>    pre<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>cur;       <span style="color:#75715e">//pre的下一个节点就是要插入的位置
</span><span style="color:#75715e"></span>    
    cur<span style="color:#f92672">=</span>next;   
  }
}
</code></pre></div><hr>
<h2 id="公共节点">公共节点</h2>
<p>给定两个单链表，编写算法找出其公共的节点。第一种方法分析：从头到尾扫描单链表$A$，判断当前元素是否在单链表$B$中出现，若在则插入到单链表$C$中。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">findSameNode</span>(LinkedList <span style="color:#f92672">*</span>A,LinkedList <span style="color:#f92672">*</span>B,LinkedList <span style="color:#f92672">*&amp;</span>C)
{
  LinkedList <span style="color:#f92672">*</span>curA<span style="color:#f92672">=</span>A<span style="color:#f92672">-&gt;</span>next;
  LinkedList <span style="color:#f92672">*</span>curB<span style="color:#f92672">=</span>B<span style="color:#f92672">-&gt;</span>next;
  LinkedList <span style="color:#f92672">*</span>tail;       <span style="color:#75715e">//尾插法构建新的单链表
</span><span style="color:#75715e"></span>  
  C<span style="color:#f92672">=</span>(LinkedList<span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(LinkedList));  <span style="color:#75715e">//静态存储区分配内存
</span><span style="color:#75715e"></span>  C<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>NULL;
  tail<span style="color:#f92672">=</span>C;
  <span style="color:#66d9ef">while</span>(curA<span style="color:#f92672">!=</span>NULL)
  {
    curB<span style="color:#f92672">=</span>B<span style="color:#f92672">-&gt;</span>next;
    <span style="color:#66d9ef">while</span>(curB<span style="color:#f92672">!=</span>NULL <span style="color:#f92672">&amp;&amp;</span> curB<span style="color:#f92672">-&gt;</span>data<span style="color:#f92672">!=</span> curA<span style="color:#f92672">-&gt;</span>data)
              curB<span style="color:#f92672">=</span>curB<span style="color:#f92672">-&gt;</span>next;
    
    <span style="color:#66d9ef">if</span>(curB<span style="color:#f92672">!=</span>NULL)
    {
      tail<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>curA;
      tail<span style="color:#f92672">=</span>curA;
    }
    curA<span style="color:#f92672">=</span>curA<span style="color:#f92672">-&gt;</span>next;
  }
  tail<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>NULL;  <span style="color:#75715e">//尾插法最后应该将尾巴的next域置空
</span><span style="color:#75715e"></span>}
</code></pre></div><p>第二种方法分析：借用<!-- raw HTML omitted -->两个辅助栈，分别存储两个链表遍历时的序列，然后同时将两个辅助栈中元素弹出，直到弹出的元素不相等，<!-- raw HTML omitted -->弹出时采用头插法进行构造新的单链表。</p>
<p>第三种方法分析：首先遍历两个链表，得到两个单链表的长度差$k$，然后长的单链表<!-- raw HTML omitted -->先走$k-1$步，<!-- raw HTML omitted -->然后短的和长的同时走，直到遇到相等的元素，即为新的单链表的首节点。</p>
<hr>
<h1 id="精选习题">精选习题</h1>
<h2 id="循环左移">循环左移</h2>
<p>将$n$个整数存放到一维数组$R$中。试设计一个在时间和空间尽可能高的算法。将$R$中保存的序列循环左移$p （0 \lt q\lt n)$个位置，即将$R$中的数据由<code>$(X_0,X_1,...,X_{n-1})$</code>变换为<code>$(X_p,X_{p+1},...,X_{n-1},X_0,X_1,....,X_{p-1})$</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">reverse</span>(<span style="color:#66d9ef">int</span> R[],<span style="color:#66d9ef">int</span> start,<span style="color:#66d9ef">int</span> end)
{
 <span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>start,j<span style="color:#f92672">=</span>end;
 <span style="color:#66d9ef">int</span> assist;
 <span style="color:#66d9ef">while</span>(i<span style="color:#f92672">&lt;</span>j)
 {
   assist<span style="color:#f92672">=</span>R[i];
   R[i]<span style="color:#f92672">=</span>R[j];
   R[j]<span style="color:#f92672">=</span>assist;
   i<span style="color:#f92672">++</span>;
   j<span style="color:#f92672">--</span>;
 }
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">leftShift</span>(<span style="color:#66d9ef">int</span> R[],<span style="color:#66d9ef">int</span> n,<span style="color:#66d9ef">int</span> p)
{
  <span style="color:#66d9ef">if</span>(p<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span>p<span style="color:#f92672">&lt;</span>n)
  {
   reverse(R,<span style="color:#ae81ff">0</span>,n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
   reverse(R,<span style="color:#ae81ff">0</span>,n<span style="color:#f92672">-</span>p<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
   reverse(R,n<span style="color:#f92672">-</span>p,n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
  }
}
</code></pre></div><hr>
<h2 id="寻找中位数">寻找中位数</h2>
<p>给定两个数组$A$和$B$,数组的长度为$n$,两个数组都分别有序，求出<!-- raw HTML omitted -->两个数组中的所有数排序后的中位数<!-- raw HTML omitted -->「偶数序列中间两数的前一个为其中位数」。</p>
<h3 id="解法一">解法一</h3>
<p>因为数组$A$和$B$均有序，因此将两个数组排序后，<!-- raw HTML omitted -->第$n$个数<!-- raw HTML omitted -->就是题目中所要找的中位数。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">search</span>(<span style="color:#66d9ef">int</span> A[], <span style="color:#66d9ef">int</span> B[], <span style="color:#66d9ef">int</span> n) {
    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, k <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

    <span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;</span> n <span style="color:#f92672">&amp;&amp;</span> j <span style="color:#f92672">&lt;</span> n) {
        k<span style="color:#f92672">++</span>;
        <span style="color:#66d9ef">if</span> (A[i] <span style="color:#f92672">&lt;</span> B[j]) {
            <span style="color:#66d9ef">if</span> (k <span style="color:#f92672">==</span> n)
                <span style="color:#66d9ef">return</span> A[i];
            i<span style="color:#f92672">++</span>;
        } <span style="color:#66d9ef">else</span> {
            <span style="color:#66d9ef">if</span> (k <span style="color:#f92672">==</span> n)
                <span style="color:#66d9ef">return</span> B[j];
            j<span style="color:#f92672">++</span>;
        }
    }
}
</code></pre></div><h3 id="解法二">解法二</h3>
<p>分别求出两个升序序列$A$，$B$的中位数，记为$a，b$。若$a=b$,则$a$或$b$即为所求，否则舍弃$a,b$中较小者所在序列的较小一半，同时舍弃较大者所在序列的较大一半，<!-- raw HTML omitted -->要求两次舍弃的元素个数相同（每次从左侧和右侧删除相同个数的元素后，新的两个数组，它们的中位数与原始数组的中位数是相同的）。<!-- raw HTML omitted -->重复上述过程，直到<!-- raw HTML omitted -->两个序列均只含一个元素为止<!-- raw HTML omitted -->，则较小的即为所求的中位数。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">searchMid</span>(<span style="color:#66d9ef">int</span> A[], <span style="color:#66d9ef">int</span> B[], <span style="color:#66d9ef">int</span> n) {
    <span style="color:#66d9ef">int</span> startA, midA, endA;

    startA <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    endA <span style="color:#f92672">=</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
    startB <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    endB <span style="color:#f92672">=</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;

    <span style="color:#66d9ef">while</span> (startA <span style="color:#f92672">!=</span> endA <span style="color:#f92672">||</span> startB <span style="color:#f92672">!=</span> endB) {
        midA <span style="color:#f92672">=</span> (startA <span style="color:#f92672">+</span> endA) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
        midB <span style="color:#f92672">=</span> (startB <span style="color:#f92672">+</span> endB) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;

        <span style="color:#66d9ef">if</span> (A[midA] <span style="color:#f92672">==</span> B[midB])
            <span style="color:#66d9ef">return</span> A[midA];

        <span style="color:#66d9ef">if</span> (A[midA] <span style="color:#f92672">&lt;</span> B[midB]) {
            <span style="color:#66d9ef">if</span> ((startA <span style="color:#f92672">+</span> endA) <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)<span style="color:#75715e">//若元素个数为奇数时
</span><span style="color:#75715e"></span>            {
                startA <span style="color:#f92672">=</span> midA;  <span style="color:#75715e">//舍弃A中间点以前的部分且保留中间点
</span><span style="color:#75715e"></span>                endB <span style="color:#f92672">=</span> midB;    <span style="color:#75715e">//舍弃B中间点以后的部分且保留中间点
</span><span style="color:#75715e"></span>            } <span style="color:#66d9ef">else</span>  <span style="color:#75715e">//若元素个数为偶数时
</span><span style="color:#75715e"></span>            {
                startA <span style="color:#f92672">=</span> midA <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;  <span style="color:#75715e">//舍弃A的前半部分,每次舍弃的长度相同，可以保证同时到达
</span><span style="color:#75715e"></span>                endB <span style="color:#f92672">=</span> midB;      <span style="color:#75715e">//舍弃B的后半部分
</span><span style="color:#75715e"></span>            }
        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (A[midA] <span style="color:#f92672">&gt;</span> B[midB]) {
            <span style="color:#66d9ef">if</span> ((startA <span style="color:#f92672">+</span> endA) <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)<span style="color:#75715e">//若元素个数为奇数时
</span><span style="color:#75715e"></span>            {
                endA <span style="color:#f92672">=</span> midA;  <span style="color:#75715e">//舍弃A中间点以后的部分且保留中间点
</span><span style="color:#75715e"></span>                startB <span style="color:#f92672">=</span> midB;<span style="color:#75715e">//舍弃B中间点以前的部分且保留中间点
</span><span style="color:#75715e"></span>            } <span style="color:#66d9ef">else</span>  <span style="color:#75715e">//若元素个数为偶数时
</span><span style="color:#75715e"></span>            {
                endA <span style="color:#f92672">=</span> midA;       <span style="color:#75715e">//舍弃A的后半部分
</span><span style="color:#75715e"></span>                startB <span style="color:#f92672">=</span> midB <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;   <span style="color:#75715e">//舍弃B的前半部分
</span><span style="color:#75715e"></span>            }
        }
    }

    <span style="color:#66d9ef">return</span> A[startA] <span style="color:#f92672">&lt;</span> B[startB] <span style="color:#f92672">?</span> A[startA] <span style="color:#f92672">:</span> B[startB]; <span style="color:#75715e">//较小者即为所求
</span><span style="color:#75715e"></span>}
</code></pre></div><ul>
<li>
<p>若$A$和$B$数组的长度为$2k+1$，取$A$数组的中位数为$A[k]$，$B$数组的中位数为$B[k]$，$A$和$B$组合起来的中位数应该是第$2k+1$大的那个数。如果$A[k]==B[k]$，则$A[k]$必定为第$2k+1$大的数，是所有数字的中位数。如果$A[k]\gt B[k]$，则$A[k]$至少为第$2k+2$大的数，$B[k]$至多为第$2k+1$大的数，中位数介于$B[k]$和$A[k]$之间。</p>
</li>
<li>
<p>若$A$和$B$数组的长度为$2k$，按照题目所述条件，则$A$的中位数为$A[k-1]$,则$B$的中位数为$B[k-1]$,$A$和$B$组合起来的中位数应该是第$2k$大的那个数，若$A[k-1]==B[k-1]$,则$B[k-1]$必为第$2k$大的那个数，即所有数字的中位数。如果$A[k-1]\gt B[k-1]$，则$A[k-1]$至少为第$2k$大的数，<!-- raw HTML omitted -->$B[k-1]$至多为第$2k-1$大的数，中位数介于$B[k-1]$和$A[k-1]$之间。<!-- raw HTML omitted --></p>
</li>
</ul>
<hr>
<h2 id="次数大于一半">次数大于一半</h2>
<p>已知一个整数序列<code>$A=(a_0,a_1,...,a_{n-1})$</code>，在这个序列中若存在<!-- raw HTML omitted -->「不要求连续的序列」<!-- raw HTML omitted --><code>$a_{p_1} = ... = a_{p_m} = x，0&lt;= a_{i} &lt; n, m &gt; n/2 , (0 &lt;= p_k &lt; n, 1&lt;=k&lt;=m)$</code>,则称 $x 为 A$ 的主元素，例如$A=(0,5,5,3,5,7,5,5)$,则$5$为主元素；又如$A=(0,5,5,3,5,1,5,7)$，则$A$中没有<!-- raw HTML omitted -->主元素<!-- raw HTML omitted -->。假设$A$中的 $n$ 个元素保存在一个一维数组中，请设一个尽可能高效的算法，找出$A$的主元素。若存在主元素，则输出该元素，否则输出$-1$。</p>
<h3 id="解法一-1">解法一</h3>
<p>主元素问题方法一：对数组中元素进行计数，然后查看出现次数最多的元素，若次数大于一半，则为主元素。这种方式只需要对数组扫描一遍，时间复杂度为$O(n)$,空间复杂度为$O(n)$。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">moreThanHalf</span>(<span style="color:#66d9ef">int</span> A[],<span style="color:#66d9ef">int</span> n)
{
  <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>count<span style="color:#f92672">=</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>)<span style="color:#f92672">*</span>n);
  <span style="color:#66d9ef">int</span> index<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
  
  <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>) count[i]<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
  
  <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>)
  {
    count[A[i]]<span style="color:#f92672">++</span>;
    <span style="color:#66d9ef">if</span>(count[A[i]) <span style="color:#f92672">&gt;</span> count[A[index]]) index<span style="color:#f92672">=</span>A[i];
  }
  
  <span style="color:#66d9ef">if</span>(count[index]<span style="color:#f92672">&gt;</span>(n<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>))  
     <span style="color:#66d9ef">return</span> index;
  <span style="color:#66d9ef">else</span> 
     <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
}
</code></pre></div><hr>
<h3 id="解法二-1">解法二</h3>
<p>首先使用快速排序，将元素排好序，然后统计相同元素出现的最大次数。统计的时候可以使用求最长平台的算法。时间复杂度为$O(nlogn)$,空间复杂度为$O(n)$。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">quickSort</span>(<span style="color:#66d9ef">int</span> A[],<span style="color:#66d9ef">int</span> start,<span style="color:#66d9ef">int</span> end)
{
 <span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>start,j<span style="color:#f92672">=</span>end;
  
 <span style="color:#66d9ef">if</span>(i<span style="color:#f92672">&lt;</span>j)
 {
    <span style="color:#66d9ef">while</span>(i<span style="color:#f92672">&lt;</span>j)
    {
      <span style="color:#66d9ef">while</span>(i<span style="color:#f92672">&lt;</span>j <span style="color:#f92672">&amp;&amp;</span> A[j]<span style="color:#f92672">&gt;</span>tmp) j<span style="color:#f92672">--</span>;
      A[i]<span style="color:#f92672">=</span>A[j];
      <span style="color:#66d9ef">if</span>(i<span style="color:#f92672">&lt;</span>j)
      {
        A[i]<span style="color:#f92672">=</span>A[j];
        i<span style="color:#f92672">++</span>;
       } 
      <span style="color:#66d9ef">while</span>(i<span style="color:#f92672">&lt;</span>j <span style="color:#f92672">&amp;&amp;</span> A[i]<span style="color:#f92672">&lt;=</span>tmp) i<span style="color:#f92672">++</span>;
      <span style="color:#66d9ef">if</span>(i<span style="color:#f92672">&lt;</span>j)
      {
        A[j]<span style="color:#f92672">=</span>A[i];
        j<span style="color:#f92672">--</span>;
       } 
    }
    quickSort(A,start,i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
    quickSort(A, i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, end);
 }
}
<span style="color:#75715e">//然后使用平台算法
</span></code></pre></div><hr>
<h3 id="解法三">解法三</h3>
<p>数组中存在主元素时，所有的非主元素个数和必少于一半。如<!-- raw HTML omitted -->让主元素与一个非主元素&quot;配对“，则最后多出来的元素（没有元素与之配对）就是主元素。<!-- raw HTML omitted -->从前往后扫描数组元素，假定遇到的当前值选定为主元素，再次遇到它时计数加1，遇到不等的值时，计数减1。当计数减为0后，将遇到的下一个值重新选定为主元素。扫描完毕，当前选定的元素（计数值大于0）可能是主元素，但未必是主元素。还需要对数组再进行一次扫描，记录它出现的实际个数，以判定它是否是主元素。时间复杂度为$O(n)$,空间复杂度为 $O(1)$。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">moreThanHalf</span>(<span style="color:#66d9ef">int</span> A[],<span style="color:#66d9ef">int</span> n)
{
 <span style="color:#66d9ef">int</span> pivot<span style="color:#f92672">=</span>A[<span style="color:#ae81ff">0</span>];
 <span style="color:#66d9ef">int</span> count<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
 <span style="color:#66d9ef">int</span> count2<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
 <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>)
 {
   <span style="color:#66d9ef">if</span>(A[i]<span style="color:#f92672">==</span>base)
      count<span style="color:#f92672">++</span>;
   <span style="color:#66d9ef">else</span> 
   {  
       <span style="color:#66d9ef">if</span>(count<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span>) count<span style="color:#f92672">--</span>;
       <span style="color:#66d9ef">else</span> 
       {
        pivot<span style="color:#f92672">=</span>A[i];
        count<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
       }
    }
 }
 
 <span style="color:#66d9ef">if</span>(count <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>)   
 {
    count2<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;  
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>)
    {
      <span style="color:#66d9ef">if</span>(pivot<span style="color:#f92672">==</span>A[i])
        count2<span style="color:#f92672">++</span>;
    }
    
    <span style="color:#66d9ef">if</span>(count2 <span style="color:#f92672">&gt;</span> n<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>)
        <span style="color:#66d9ef">return</span> pivot;
 }
    <span style="color:#66d9ef">return</span> ERROR; <span style="color:#75715e">//ERROR 代表不会在序列中出现的那个数
</span><span style="color:#75715e"></span>}
</code></pre></div><hr>

    </div>
    <footer class="post-footer">
        
 
<div class="post-tags">     
     
    <a href="https://iihui.github.io/tags/%e7%ae%97%e6%b3%95" rel="tag" title="算法">#算法#</a>
    
</div>



        <div class="post-nav">
    <div class="post-nav-next post-nav-item">
    
        <a href="https://iihui.github.io/post/arith-linear-list/" rel="next" title="线性表">
        <i class="fa fa-chevron-left"></i> 线性表
        </a>
    
    </div>

    <div class="post-nav-prev post-nav-item">
    
        <a href="https://iihui.github.io/about/" rel="prev" title="关于我">
        关于我 <i class="fa fa-chevron-right"></i>
        </a>
    
    </div>
</div>
      
        <div class="post-nav">
    <div style="border: 1px dashed #e0e0e0; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
        <div style="float:left;margin-top:0px;">
            <img src="https://i.loli.net/2020/02/09/SvhUdz4XJsOr9Vk.jpg" width="128px" height="128px"/>
            <div style="text-align:center;">谢谢支持!</div>
        </div>
        <div>
            <p style="margin-top:10px;">
                标题：线性表
                <br />作者：阿呆<a target="_blank" href="https://iihui.github.io/"></a>
                
                <br />地址：https://iihui.github.io/post/post/arith-linear-list/
                <br />声明：自由转载-非商用-保持署名（创作共享4.0许可证）
            </p>
        </div>
    </div>
    <div class="clear"></div>
</div>
        
        
        




    </footer>
  </article>
</section>

          </div>
        </div>
        <div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>
<aside id="sidebar" class="sidebar">
  <div class="sidebar-inner">

  <ul class="sidebar-nav motion-element">
    <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
      文章目录
    </li>
    <li class="sidebar-nav-overview" data-target="site-overview">
      站点概览
    </li>
  </ul>

    <section class="site-overview sidebar-panel ">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
        src="https://i.loli.net/2020/02/07/dVFzrvZkHRNq2lL.jpg"
        alt="" />
    <p class="site-author-name" itemprop="name"></p>
    <p class="site-description motion-element" itemprop="description"> 
        coder &amp; cook</p>
</div>
      <nav class="site-state motion-element">
    <div class="site-state-item site-state-posts">
      <a href="https://iihui.github.io/post/">
        <span class="site-state-item-count">272</span>
        <span class="site-state-item-name">日志</span>
      </a>
    </div>
    <div class="site-state-item site-state-categories">    
        <a href="https://iihui.github.io/categories/">      
         
        <span class="site-state-item-count">15</span>
        
        <span class="site-state-item-name">分类</span>
        
        </a>
    </div>

    <div class="site-state-item site-state-tags">
        <a href="https://iihui.github.io/tags/">
         
        <span class="site-state-item-count">29</span>
        
        <span class="site-state-item-name">标签</span>
        </a>
    </div>
</nav>
      
      
<div class="links-of-author motion-element">
    
        <span class="links-of-author-item">
        <a href="https://coolshell.cn" target="_blank" title="皓 大">
            <i class="fa fa-fw fa-globe"></i>
            皓 大
        </a>
        </span>
    
        <span class="links-of-author-item">
        <a href="http://www.ruanyifeng.com" target="_blank" title="阮 大">
            <i class="fa fa-fw fa-globe"></i>
            阮 大
        </a>
        </span>
    
        <span class="links-of-author-item">
        <a href="https://juejin.im/" target="_blank" title="掘 金">
            <i class="fa fa-fw fa-globe"></i>
            掘 金
        </a>
        </span>
    
        <span class="links-of-author-item">
        <a href="http://www.ideamsg.com" target="_blank" title="灵 感">
            <i class="fa fa-fw fa-globe"></i>
            灵 感
        </a>
        </span>
    
</div>


      

      <div class="links-of-blogroll motion-element inline">
<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=&amp;m=0&amp;s=220&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;bv=35" async="async"></script>
</div>

    </section>
    
<section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
    <div class="post-toc">
        <div class="post-toc-content"><nav id="TableOfContents">
  <ul>
    <li><a href="#逻辑结构">逻辑结构</a></li>
    <li><a href="#存储结构">存储结构</a></li>
    <li><a href="#顺序表">顺序表</a>
      <ul>
        <li><a href="#顺序表的特点">顺序表的特点</a></li>
        <li><a href="#描述顺序表的结构">描述顺序表的结构</a></li>
        <li><a href="#一些习题">一些习题</a>
          <ul>
            <li><a href="#最长平台">最长平台</a></li>
            <li><a href="#以key为轴调整">以key为轴调整</a></li>
            <li><a href="#以第一个元素为轴调整">以第一个元素为轴调整</a></li>
            <li><a href="#删除元素">删除元素</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#单链表">单链表</a>
      <ul>
        <li><a href="#建立单链表">建立单链表</a></li>
        <li><a href="#基本操作">基本操作</a></li>
        <li><a href="#就地逆置">就地逆置</a></li>
        <li><a href="#拆分链表">拆分链表</a></li>
        <li><a href="#递增排序">递增排序</a></li>
        <li><a href="#公共节点">公共节点</a></li>
      </ul>
    </li>
    <li><a href="#精选习题">精选习题</a>
      <ul>
        <li><a href="#循环左移">循环左移</a></li>
        <li><a href="#寻找中位数">寻找中位数</a>
          <ul>
            <li><a href="#解法一">解法一</a></li>
            <li><a href="#解法二">解法二</a></li>
          </ul>
        </li>
        <li><a href="#次数大于一半">次数大于一半</a>
          <ul>
            <li><a href="#解法一-1">解法一</a></li>
            <li><a href="#解法二-1">解法二</a></li>
            <li><a href="#解法三">解法三</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav></div>
    </div>
</section>

  </div>
</aside>

      </div>
    </main>
   
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  <span itemprop="copyrightYear">  &copy; 
  2017 - 2020</span>
  <span class="with-love"><i class="fa fa-heart"></i></span>
  <span class="author" itemprop="copyrightHolder">Keep It Simple</span>
</div>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      <span id="scrollpercent"><span>0</span>%</span>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/jquery/index.js?v=2.1.3"></script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script> 
<script type="text/javascript" src="https://iihui.github.io/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/velocity/velocity.min.js?v=1.2.1"></script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="https://iihui.github.io/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>

<script src="https://iihui.github.io/js/vendor/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>

<script type="text/javascript" src="https://iihui.github.io/js/utils.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/motion.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/affix.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/schemes/pisces.js"></script>

<script type="text/javascript" src="https://iihui.github.io/js/scrollspy.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/post-details.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/toc.js"></script>

<script type="text/javascript" src="https://iihui.github.io/js/bootstrap.js"></script>

<script type="text/javascript" src="https://iihui.github.io/js/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
</body>
</html>