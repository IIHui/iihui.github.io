<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
    <title>剑指offer题集1 - Keep It Simple</title>
    <meta name="keywords" content="博客,思考,读书,笔记,技术,分享">
    
    <meta property="og:title" content="剑指offer题集1">
    <meta property="og:site_name" content="Keep It Simple">
    <meta property="og:image" content="/img/author.jpg"> 
    <meta name="title" content="剑指offer题集1 - Keep It Simple" />
    <meta name="description" content="Swift | Go | C&#43;&#43; "> 
    <link rel="shortcut icon" href="https://iihui.github.io/img/favicon.ico" />
    <link rel="apple-touch-icon" href="https://iihui.github.io/img/apple-touch-icon.png" />
    <link rel="apple-touch-icon-precomposed" href="https://iihui.github.io/img/apple-touch-icon.png" />
    <link href="https://iihui.github.io/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />
    <link href="https://iihui.github.io/js/vendor/fancybox/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />
    <link href="https://iihui.github.io/css/main.css" rel="stylesheet" type="text/css" />
    <link href="https://iihui.github.io/css/custom.css" rel="stylesheet" type="text/css" />
    <link href="https://iihui.github.io/css/syntax.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
     fancybox: true, 
    motion: true
  };
</script>

    <link href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/monokai-sublime.min.css" rel="stylesheet">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/go.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/swift.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/objectivec.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/clojure.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/cpp.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>


</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<div class="container one-collumn sidebar-position-left page-home  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-meta  custom-logo ">

  <div class="custom-logo-site-title">
    <a href="https://iihui.github.io/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Keep It Simple</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">靡不有初，鲜克有终</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
    <ul id="menu" class="menu">
      
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/tags/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-tag"></i> <br />标签
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/post/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/categories/%E7%BE%8E%E9%A3%9F/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-fire"></i> <br />美食
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/categories/%E5%90%8E%E6%9C%9F/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-edit"></i> <br />后期
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/categories/%E6%97%85%E8%A1%8C/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-leaf"></i> <br />旅行
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://iihui.github.io/about/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于
          </a>
        </li>
      
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger"> <i class="menu-item-icon fa fa-search fa-fw"></i> <br /> 搜索</a>
      </li>
    </ul>
    <div class="site-search">
      <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>

    </div>
</nav>
<script type="text/javascript"
        async
        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
		<!-- src = "http://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> <\!--  -\-> -->
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>

<!DOCTYPE html>
<html lang="en">


<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css" integrity="sha384-D+9gmBxUQogRLqvARvNLmA9hS2x//eK1FhVb9PiU86gmcrBrJAQT8okdJ4LMp2uv" crossorigin="anonymous">

    
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js" integrity="sha384-483A6DwYfKeDa0Q52fJmxFXkcPCFfnXMoXblOkJ4JcA8zATN6Tm78UNL72AKk+0O" crossorigin="anonymous"></script>
</head>
<body>

</body>
</html>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
<section id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="https://iihui.github.io/post/post/arith-sword-1/" itemprop="url">
        剑指offer题集1
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">创建: </span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2017-08-16">
    2017-08-16
</time>
</span>
&nbsp; | &nbsp;
<span class="post-updated-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-check-o"></i>
</span>
<span class="post-meta-item-text">更新: </span>
<time itemprop="dateUpdated" content="2017-08-16">
    2017-08-16
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类: </span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="https://iihui.github.io/categories/%E7%AE%97%E6%B3%95" itemprop="url" rel="index">
        <span itemprop="name">算法</span>
      </a>
      &nbsp; 
    </span>
  
</span>


      <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-file-word-o"></i>
</span>
<span class="post-meta-item-text">字数: </span>
<span class="leancloud-visitors-count">4773</span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-coffee"></i>
</span>
<span class="post-meta-item-text">阅读: </span>
<span class="leancloud-visitors-count">10 分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <h2 id="二维数组中查找">二维数组中查找</h2>
<p>在一个二维数组中，<!-- raw HTML omitted -->每一行都按从左到右递增的顺序排序，每一列都按从上到下递增<!-- raw HTML omitted -->的顺序排列，试从该二维数组查找给定的元素。</p>
<p>首先应该从右上角的元素(记为<code>cur</code>)开始比较，如果当前要查找的元素<code>key</code>的值比<code>cur</code>大，那么就应该往<code>cur</code>所在行的下面开始寻找；如果<code>key</code>的值比<code>cur</code>小，那么应该往<code>cur</code>所在列的左边寻找，具体代码如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">findKeyInMatrix</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>matrix, <span style="color:#66d9ef">int</span> rows, <span style="color:#66d9ef">int</span> colums, <span style="color:#66d9ef">int</span> key) {
    <span style="color:#66d9ef">bool</span> found <span style="color:#f92672">=</span> false;

    <span style="color:#66d9ef">if</span> (matrix <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">&amp;&amp;</span> rows <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> colums <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>) {
        <span style="color:#66d9ef">int</span> row <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">int</span> column <span style="color:#f92672">=</span> colums <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">//row=0,column=colums-1表示定位到右上角的元素
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> cur <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

        <span style="color:#66d9ef">while</span> (row <span style="color:#f92672">&lt;</span> rows <span style="color:#f92672">&amp;&amp;</span> colums <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>) {
            cur <span style="color:#f92672">=</span> matrix[row <span style="color:#f92672">*</span> colums <span style="color:#f92672">+</span> column];
            <span style="color:#66d9ef">if</span> (cur <span style="color:#f92672">==</span> key) {
                found <span style="color:#f92672">=</span> true;
                <span style="color:#66d9ef">break</span>;
            } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (cur <span style="color:#f92672">&gt;</span> key) {
                column<span style="color:#f92672">--</span>;
            } <span style="color:#66d9ef">else</span> {
                row<span style="color:#f92672">++</span>;
            }
        };
    }
    <span style="color:#66d9ef">return</span> found;
}
</code></pre></div><hr>
<h2 id="字符串的赋值操作符重载">字符串的赋值操作符重载</h2>
<p>对于自定义的字符串类的赋值操作符的重载时，需要注意<code>4</code>点：①是否传入常引用<code>const A &amp;</code>。②传入的引用是否是自身。 ③是否释放掉原来的空间。 ④是否返回<code>*this</code>。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CMyString</span> {
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>pdata;
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    CMyString(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>ptr <span style="color:#f92672">=</span> NULL);

    CMyString(<span style="color:#66d9ef">const</span> CMyString <span style="color:#f92672">&amp;</span>str);

    CMyString <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> CMyString <span style="color:#f92672">&amp;</span>str);
}
<span style="color:#f92672">~</span>CMyString() {}

};

CMyString <span style="color:#f92672">&amp;</span>CMyString<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> CMyString <span style="color:#f92672">&amp;</span>str) {
    <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span> <span style="color:#f92672">!=</span> <span style="color:#f92672">&amp;</span>str) {
        CMyString <span style="color:#a6e22e">tmp</span>(str);
        <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>ptmp <span style="color:#f92672">=</span> tmp.pdata;
        tmp.pdata <span style="color:#f92672">=</span> pdata;
        pdata <span style="color:#f92672">=</span> ptmp;
    }
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
}
</code></pre></div><p>在这个赋值操作符重载函数中，首先创建了一个临时变量<code>tmp</code>，<!-- raw HTML omitted -->如果分配内存不成功的话，那么会抛出<code>bad_alloc</code>异常，此时也不会修改原来的对象实例<!-- raw HTML omitted -->。</p>
<p>如果正常分配的话，因为<!-- raw HTML omitted --><code>tmp</code>是临时变量，所以在<code>if</code>的作用域结束之后，那么会自动调用析构函数，此时就会析构掉<code>tmp.pdata</code>所指向的内存<!-- raw HTML omitted -->。因为<code>tmp.pdata</code>已经和<code>pdata</code>交换了，所以这相当于自动调用析构函数释放实例的内存。</p>
<hr>
<h2 id="从尾到头打印链表">从尾到头打印链表</h2>
<p>从尾到头打印链表中的元素，有两种解决方法，一种是递归算法，另一种是利用栈来实现非递归算法。下面是递归算法的实现：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">recPrintLinkedList</span>(LinkedNode <span style="color:#f92672">*</span>head)
{
    <span style="color:#66d9ef">if</span> (head <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>)
    {
        recPrintLinkedList(head<span style="color:#f92672">-&gt;</span>next);
        std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>head<span style="color:#f92672">-&gt;</span>data<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">&#34;</span>;
    }
}
</code></pre></div><p>非递归算法是<!-- raw HTML omitted -->借助栈的后进先出的特性<!-- raw HTML omitted -->，首先遍历链表的所有元素，并将它们存入到栈中。当遍历完栈的时候就可以出栈：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">nonRecPrintLinkedList</span>(LinkedNode <span style="color:#f92672">*</span>head)
{
    <span style="color:#66d9ef">if</span>(head <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>)
    {
        stack<span style="color:#f92672">&lt;</span>LinkedNode<span style="color:#f92672">*&gt;</span> st;
        LinkedNode <span style="color:#f92672">*</span> cur <span style="color:#f92672">=</span> head;
        
        <span style="color:#66d9ef">while</span>(cur <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>)
        {
            st.push(cur);
            cur <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>next;
        }
        
        <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>st.empty())
        {
            cur <span style="color:#f92672">=</span> st.top();
            st.pop();
            std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>cur<span style="color:#f92672">-&gt;</span>data<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#39;\t&#39;</span>;
        }
    }
}
</code></pre></div><hr>
<h2 id="两个栈实现队列">两个栈实现队列</h2>
<p>将<code>stack1</code>作为入队使用， 将<code>stack2</code>作为出队使用。当<code>stack2</code>不空时，就从<code>stack2</code>直接弹出元素，否则将<code>stack1</code>里元素先全部弹出到<code>stack2</code>中，再从<code>stack2</code>中弹出，这样便实现了先进先出。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">stackQueue</span> 
{
 <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
  stackQueue(<span style="color:#66d9ef">void</span>){};
  <span style="color:#f92672">~</span>stackQueue(){};
  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">push</span>(<span style="color:#66d9ef">const</span> T <span style="color:#f92672">&amp;</span>node);
  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">pop</span>();
  T <span style="color:#f92672">&amp;</span>top();

 <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
  stack<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> stack1;
  stack<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> stack2;
};

<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> stackQueue<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>push(<span style="color:#66d9ef">const</span> T <span style="color:#f92672">&amp;</span>node) 
{
  stack1.push(node);
}

<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> stackQueue<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>pop() 
{
  <span style="color:#66d9ef">if</span> (stack2.empty()) {
    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>stack1.empty()) 
    {
      stack2.push(stack1.top());
      stack1.pop();
    }
  }
  <span style="color:#66d9ef">if</span> (stack2.empty()) 
    <span style="color:#66d9ef">throw</span> string(<span style="color:#e6db74">&#34;queue is empty!&#34;</span>);
  
  stack2.pop();
}

<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
T <span style="color:#f92672">&amp;</span>stackQueue<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>top() 
{
  <span style="color:#66d9ef">return</span> stack2.top();
}
</code></pre></div><hr>
<h2 id="两个队列实现一个栈">两个队列实现一个栈</h2>
<p><!-- raw HTML omitted -->总是保持一个队列是空<!-- raw HTML omitted -->，出栈的时候将不空的那个队列的前$n-1$个元素都放到空的那个队列里，然后出剩下的那一个元素；入队的时候入到不空的那个队列里。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span>  T<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">queueStack</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    queueStack(<span style="color:#66d9ef">void</span>){};
    <span style="color:#f92672">~</span>queueStack(){};
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">push</span>(<span style="color:#66d9ef">const</span> T <span style="color:#f92672">&amp;</span> node);
    T <span style="color:#a6e22e">pop</span>();

<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    queue<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> queue1;
    queue<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> queue2;
};

<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span><span style="color:#66d9ef">void</span> queueStack<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>push(<span style="color:#66d9ef">const</span> T <span style="color:#f92672">&amp;</span>node)
{
    <span style="color:#66d9ef">if</span>(queue1.empty() <span style="color:#f92672">&amp;&amp;</span> queue2.empty())
    {
        queue1.push(node);
    }
    <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span>(queue1.empty())
    {
        queue1.push(node);
    }
    <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span>(queue2.empty())
    {
        queue2.push(node);
    }
    <span style="color:#66d9ef">else</span>
        <span style="color:#66d9ef">throw</span> <span style="color:#a6e22e">string</span>(<span style="color:#e6db74">&#34;Error!&#34;</span>);
}

<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>T queueStack<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>pop()
{
   <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>queue1.empty() <span style="color:#f92672">&amp;&amp;</span> queue2.empty())
   {
       <span style="color:#66d9ef">while</span>(queue1.size() <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span>)
       {
          queue2.push(queue1.front());
          queue1.pop();
       }
       T <span style="color:#f92672">&amp;</span> data <span style="color:#f92672">=</span> queue1.front();
       queue1.pop();
       <span style="color:#66d9ef">return</span>  data;
   }
    <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span>(queue1.empty() <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>queue2.empty())
   {
       <span style="color:#66d9ef">while</span>(queue2.size() <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span>)
       {
           queue1.push(queue2.front());
           queue2.pop();
       }
       T <span style="color:#f92672">&amp;</span> data <span style="color:#f92672">=</span> queue2.front();
       queue2.pop();
       <span style="color:#66d9ef">return</span>  data;
   }
    <span style="color:#66d9ef">else</span>
       <span style="color:#66d9ef">throw</span> <span style="color:#a6e22e">string</span>(<span style="color:#e6db74">&#34;Error!&#34;</span>);
}
</code></pre></div><hr>
<h2 id="快速排序">快速排序</h2>
<p>快速排序中，基准元素的选择有<code>3</code>种方式：①选择待排序区间左边的第一个元素。②选择待排序空间的中间元素。③随机从待排序区间中选择一个元素。下面的代码是随机选择基准元素：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">quickSortPartition</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>input, <span style="color:#66d9ef">int</span> length, <span style="color:#66d9ef">int</span> start, <span style="color:#66d9ef">int</span> end)
{
    <span style="color:#66d9ef">if</span> (input <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">||</span> start <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> length <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> end <span style="color:#f92672">&gt;=</span> length)
    {
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;  <span style="color:#75715e">// 参数错误
</span><span style="color:#75715e"></span>    }

    srand(time(NULL));  <span style="color:#75715e">//C风格
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">int</span> index <span style="color:#f92672">=</span> rand() <span style="color:#f92672">%</span> (end <span style="color:#f92672">-</span> start <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
    <span style="color:#66d9ef">int</span> small <span style="color:#f92672">=</span> start <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;

    swap(input[index], input[end]);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> start; i <span style="color:#f92672">&lt;</span> end; <span style="color:#f92672">++</span>i)
    {
        <span style="color:#66d9ef">if</span> (input[i] <span style="color:#f92672">&lt;</span> input[end])
        {
            small<span style="color:#f92672">++</span>;
            <span style="color:#66d9ef">if</span> (small <span style="color:#f92672">&lt;</span> i)
            {
                swap(input[small], input[i]);
            }
        }
    }
    
    small<span style="color:#f92672">++</span>;
    swap(input[small], input[end]);
    <span style="color:#66d9ef">return</span> small;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">quickSortMore</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>input, <span style="color:#66d9ef">int</span> length, <span style="color:#66d9ef">int</span> start, <span style="color:#66d9ef">int</span> end)
{
   <span style="color:#66d9ef">if</span> (start <span style="color:#f92672">==</span> end)
       <span style="color:#66d9ef">return</span>;
    
    <span style="color:#66d9ef">int</span> index <span style="color:#f92672">=</span> quickSortPartition(input,length,start,end);
    
    <span style="color:#66d9ef">if</span> (index <span style="color:#f92672">&gt;</span> start)
        quickSortMore(input,length,start,index<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
    
    <span style="color:#66d9ef">if</span> (end <span style="color:#f92672">&gt;</span> index)
        quickSortMore(input,length,index<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,end);
}
</code></pre></div><hr>
<h2 id="旋转数组中的最小值">旋转数组中的最小值</h2>
<p>把<!-- raw HTML omitted -->一个数组的最开始的若干元素移动到数组的末尾<!-- raw HTML omitted -->，称之为数组的旋转。输入一个递增的数组的一个旋转，找到数组中的最小元素。</p>
<p>最简单的方法是从头到尾遍历一遍数组，就可以找到最小的元素，但是<!-- raw HTML omitted -->这种方法没有用到旋转数组的前部和后部是有序这一特点<!-- raw HTML omitted -->。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">findSpinArrayMin</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>data, <span style="color:#66d9ef">int</span> length)
{
    <span style="color:#66d9ef">if</span> (data <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">||</span> length <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>)
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;

    <span style="color:#66d9ef">int</span> start <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">int</span> end <span style="color:#f92672">=</span> length <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">int</span> mid, result <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;

    <span style="color:#66d9ef">while</span> (data[start] <span style="color:#f92672">&gt;=</span> data[end])
    {
        <span style="color:#66d9ef">if</span> (end <span style="color:#f92672">-</span> start <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>)
        {
           mid <span style="color:#f92672">=</span> end;
           <span style="color:#66d9ef">break</span>;
        }
        mid <span style="color:#f92672">=</span> (start <span style="color:#f92672">+</span> end) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;

        <span style="color:#66d9ef">if</span> (data[start] <span style="color:#f92672">==</span> data[mid] <span style="color:#f92672">&amp;&amp;</span> data[mid] <span style="color:#f92672">==</span> data[end])
        {
            <span style="color:#66d9ef">return</span> minInOrder(data, start, end);
        }

        <span style="color:#66d9ef">if</span> (data[mid] <span style="color:#f92672">&gt;=</span> data[end])
            start <span style="color:#f92672">=</span> mid;

        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (data[mid] <span style="color:#f92672">&lt;=</span> data[end])
            end <span style="color:#f92672">=</span> mid;
    }

    <span style="color:#66d9ef">return</span> data[mid];
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">minInOrder</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>data, <span style="color:#66d9ef">int</span> start, <span style="color:#66d9ef">int</span> end)
{
    <span style="color:#66d9ef">int</span> result <span style="color:#f92672">=</span> data[start];

    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> start <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> end; <span style="color:#f92672">++</span>i)
    {
        <span style="color:#66d9ef">if</span> (result <span style="color:#f92672">&gt;</span> data[i])
            result <span style="color:#f92672">=</span> data[i];
    }
    <span style="color:#66d9ef">return</span> result;
}
</code></pre></div><hr>
<h2 id="斐波那契数列">斐波那契数列</h2>
<p>首先根据定义很容易想到递归算法，但是递归算法会重复计算很多次，所以实际上浪费了很多资源</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">recFibonacci</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> n)
{
    <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>)
        <span style="color:#66d9ef">return</span> n;
    <span style="color:#66d9ef">else</span>
        <span style="color:#66d9ef">return</span> recFibonacci(n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> recFibonacci(n <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>);
}
</code></pre></div><p>使用非递归解法，不必重复计算</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">nonRecFibonacci</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> n)
{
    <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>)
        <span style="color:#66d9ef">return</span> n;

    <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> first <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, second <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, result <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>)
    {
        result <span style="color:#f92672">=</span> first <span style="color:#f92672">+</span> second;
        first <span style="color:#f92672">=</span> second;
        second <span style="color:#f92672">=</span> result;
    }

    <span style="color:#66d9ef">return</span> result;
}
</code></pre></div><hr>
<h2 id="数组的整数次方">数组的整数次方</h2>
<p>实现函数<code>double power(double base,int exponent)</code>,求 <code>base</code>的<code>expoent</code>次方，不使用库函数，同时不考虑大数问题。但是在这个问题上需要考虑base接近于0的情况。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">double</span> <span style="color:#a6e22e">power</span>(<span style="color:#66d9ef">double</span> base, <span style="color:#66d9ef">int</span> exponent)
{
    <span style="color:#66d9ef">double</span> result <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0</span>;
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> absExponent <span style="color:#f92672">=</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span>) (exponent);

    <span style="color:#66d9ef">if</span> (base <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.000001</span> <span style="color:#f92672">&amp;&amp;</span> base <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0.000001</span> <span style="color:#f92672">&amp;&amp;</span> exponent <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>)
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;


    <span style="color:#66d9ef">if</span> (exponent <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>)
    {
        absExponent <span style="color:#f92672">=</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span>) (<span style="color:#f92672">-</span>exponent);
    }

    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">unsigned</span>  <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> absExponent; <span style="color:#f92672">++</span>i)
    {
        result <span style="color:#f92672">*=</span> base;
    }

    <span style="color:#66d9ef">if</span> (exponent <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>)
        result <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0</span> <span style="color:#f92672">/</span> result;


    <span style="color:#66d9ef">return</span> result;
}
</code></pre></div><p>优化的方法，使用如下方法</p>
<p>![c600](<a href="http://oqe76o492.bkt.clouddn.com/">http://oqe76o492.bkt.clouddn.com/</a>屏幕快照 2017-08-17 下午2.42.37.png)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">double</span> <span style="color:#a6e22e">powerOptimize</span>(<span style="color:#66d9ef">double</span> base, <span style="color:#66d9ef">int</span> exponent)
{
    <span style="color:#66d9ef">if</span> (exponent <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;

    <span style="color:#66d9ef">if</span> (exponent <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>)
        <span style="color:#66d9ef">return</span> base;

    <span style="color:#66d9ef">double</span> result <span style="color:#f92672">=</span> powerOptimize(base, exponent <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span>);
    result <span style="color:#f92672">*=</span> result;

    <span style="color:#66d9ef">if</span> ((exponent <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0x1</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>)
        result <span style="color:#f92672">*=</span> base;

    <span style="color:#66d9ef">return</span> result;
}
</code></pre></div><hr>
<h2 id="打印1到最大的n位数">打印1到最大的n位数</h2>
<p>输入数字 n，打印1到最大的 n 位十进制数</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">printNdigits</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> n)
{
    <span style="color:#66d9ef">auto</span> <span style="color:#f92672">*</span>digits <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">char</span>[n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
    memset(digits, <span style="color:#e6db74">&#39;0&#39;</span>, (n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">char</span>));
    digits[n] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;\0&#39;</span>;

    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>incrementByone(digits))
    {
        printNumber(digits);
    }
    <span style="color:#66d9ef">delete</span>[] digits;
}

<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">incrementByone</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>digits)
{
    <span style="color:#66d9ef">int</span> length <span style="color:#f92672">=</span> strlen(digits);
    <span style="color:#66d9ef">bool</span> isOverFlow <span style="color:#f92672">=</span> false;
    <span style="color:#66d9ef">int</span> takeOver <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">int</span> cur <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> i <span style="color:#f92672">=</span> length<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; <span style="color:#f92672">--</span>i)
    {
      cur <span style="color:#f92672">=</span> digits[i]<span style="color:#f92672">-</span><span style="color:#e6db74">&#39;0&#39;</span><span style="color:#f92672">+</span>takeOver;
       <span style="color:#66d9ef">if</span>( i<span style="color:#f92672">==</span>length<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) 
            cur <span style="color:#f92672">++</span>;
        
        <span style="color:#66d9ef">if</span>(cur <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">10</span>)
        {
            <span style="color:#66d9ef">if</span>(i <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
                isOverFlow <span style="color:#f92672">=</span> true;
            <span style="color:#66d9ef">else</span>
            {
                cur <span style="color:#f92672">-=</span> <span style="color:#ae81ff">10</span>;
                digits[i]<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;0&#39;</span><span style="color:#f92672">+</span>cur;
                takeOver <span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
            }
            
        }
        <span style="color:#66d9ef">else</span>
        {
            digits[i]<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;0&#39;</span><span style="color:#f92672">+</span>cur;
            <span style="color:#66d9ef">break</span>;
        }
    }

    <span style="color:#66d9ef">return</span> isOverFlow;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">printNumber</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>digits)
{
    <span style="color:#66d9ef">if</span> (digits <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>)
    {
        <span style="color:#66d9ef">while</span> (<span style="color:#f92672">*</span>digits <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;0&#39;</span>)
        {
            digits<span style="color:#f92672">++</span>;
        }
        cout <span style="color:#f92672">&lt;&lt;</span> digits <span style="color:#f92672">&lt;&lt;</span> endl;
    }
}
</code></pre></div><p>递归方式，如果将前面的数字补0的话，就会发现n位所有十进制数其实就是n个从0开始到9的全排列，就是把数字从0到9排列一遍，就得到了十进制的全排列。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">newPrintNdigts</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> n)
{
    <span style="color:#66d9ef">auto</span> <span style="color:#f92672">*</span>digits <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">char</span>[n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
    digits[n] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;\0&#39;</span>;

    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span>; <span style="color:#f92672">++</span>i)
    {
        digits[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span><span style="color:#66d9ef">char</span>(i<span style="color:#f92672">+</span><span style="color:#e6db74">&#39;0&#39;</span>);
        recPrintNdigits(digits,n,<span style="color:#ae81ff">0</span>);
    }
    <span style="color:#66d9ef">delete</span>[] digits;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">recPrintNdigits</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>digits, <span style="color:#66d9ef">int</span> length, <span style="color:#66d9ef">int</span> index)
{
    <span style="color:#66d9ef">if</span>(index <span style="color:#f92672">==</span> length<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
    {
        printNumber(digits);
        <span style="color:#66d9ef">return</span>;
    } 

    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span>; <span style="color:#f92672">++</span>i)
    {
        digits[index<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#66d9ef">char</span>(i<span style="color:#f92672">+</span><span style="color:#e6db74">&#39;0&#39;</span>);
        recPrintNdigits(digits,length,index<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
    }
}
</code></pre></div><hr>
<h2 id="在o1时间内删除节点">在O(1)时间内删除节点</h2>
<p>在 $O(1)$ 时间复杂度内删除某个节点,假设要删除的节点一定在链表中。如果删除的不是尾节点，则只要将它的下一个节点的数据移到该节点即可。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">deleteLinkedNode</span>(LinkedNode <span style="color:#f92672">*</span> <span style="color:#f92672">&amp;</span>root, LinkedNode <span style="color:#f92672">*</span> key)
{
    <span style="color:#66d9ef">if</span>( root <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>  <span style="color:#f92672">||</span> key <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>isNodeInLinkedList(root, key))
        <span style="color:#66d9ef">return</span>;

    <span style="color:#66d9ef">if</span>(key<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>)  <span style="color:#75715e">//删除的如果不是尾节点
</span><span style="color:#75715e"></span>    {
        LinkedNode <span style="color:#f92672">*</span> next <span style="color:#f92672">=</span> key<span style="color:#f92672">-&gt;</span>next;
        key<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> next<span style="color:#f92672">-&gt;</span>data;
        key<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> next<span style="color:#f92672">-&gt;</span>next;
        <span style="color:#66d9ef">delete</span> next;
        next <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
    }
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>( root<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>) <span style="color:#75715e">//删除的是尾节点，而且链表只有一个节点
</span><span style="color:#75715e"></span>    {
        <span style="color:#66d9ef">delete</span> root;
        root <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
    } <span style="color:#66d9ef">else</span> <span style="color:#75715e">//删除的是尾节点，且链表不止一个节点
</span><span style="color:#75715e"></span>    {
        LinkedNode <span style="color:#f92672">*</span> pre <span style="color:#f92672">=</span> root;
        LinkedNode <span style="color:#f92672">*</span> cur <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>next;

        <span style="color:#66d9ef">while</span>(cur <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span> )
        {
            pre <span style="color:#f92672">=</span> cur;
            cur <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>next;
        }
        pre<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
        <span style="color:#66d9ef">delete</span> cur;
        cur <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
    }
}
</code></pre></div><hr>
<h2 id="链表中的倒数第-k-个节点">链表中的倒数第 k 个节点</h2>
<p>输入一个链表，输出该链表中的倒数第 k 个节点，其中链表的尾节点为倒数第1个节点</p>
<p>基本思路是用两个指针，其中第一个游标先向前走 <code>k-1</code>次，然后和另外一个游标一起往前走，如果第一个游标走到尾节点，那么第二个游标也就到了倒数第 <code>k</code>个节点。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">LinkedNode <span style="color:#f92672">*</span><span style="color:#a6e22e">findLastKthNodeFaster</span>(LinkedNode <span style="color:#f92672">*</span>root, <span style="color:#66d9ef">int</span> k)
{
    <span style="color:#66d9ef">if</span>( root <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">||</span> k <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>)
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nullptr</span>;

    LinkedNode <span style="color:#f92672">*</span> cur <span style="color:#f92672">=</span> root;
    LinkedNode <span style="color:#f92672">*</span> result <span style="color:#f92672">=</span> root;

    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> k<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; <span style="color:#f92672">++</span>i)
    {
        <span style="color:#66d9ef">if</span> (cur<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>)  <span style="color:#75715e">//要考虑k的值是否超过了链表的总节点数目
</span><span style="color:#75715e"></span>            cur <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>next;
        <span style="color:#66d9ef">else</span>
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nullptr</span>;
    }
    <span style="color:#66d9ef">while</span> (cur <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>)
    {
        cur <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>next;
        result <span style="color:#f92672">=</span> result<span style="color:#f92672">-&gt;</span>next;
    }
    <span style="color:#66d9ef">return</span> result;
}

</code></pre></div><hr>
<h2 id="反转链表">反转链表</h2>
<p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头结点。分为递归和非递归解法，非递归使用头插法即可</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">LinkedNode <span style="color:#f92672">*</span> <span style="color:#a6e22e">reverseLinkedList</span>(LinkedNode <span style="color:#f92672">*</span>pHead)
{
    <span style="color:#66d9ef">if</span> (pHead <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>)
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nullptr</span>;
    
    LinkedNode <span style="color:#f92672">*</span>newHead <span style="color:#f92672">=</span> pHead;
    LinkedNode <span style="color:#f92672">*</span>cur <span style="color:#f92672">=</span> pHead<span style="color:#f92672">-&gt;</span>next;
    newHead<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;

    LinkedNode <span style="color:#f92672">*</span>next <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;

    <span style="color:#66d9ef">while</span> (cur <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>)
    {
        next <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>next;
        cur<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> newHead;
        newHead <span style="color:#f92672">=</span> cur;
        cur <span style="color:#f92672">=</span> next;
    }

    <span style="color:#66d9ef">return</span> newHead;
}
</code></pre></div><p>递归解法</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">LinkedNode <span style="color:#f92672">*</span><span style="color:#a6e22e">recurReversionLinkedList</span>(LinkedNode <span style="color:#f92672">*</span>head)
{
    LinkedNode <span style="color:#f92672">*</span>cur <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
    LinkedNode <span style="color:#f92672">*</span>tmp <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
    LinkedNode <span style="color:#f92672">*</span>recurHead <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;

    <span style="color:#66d9ef">if</span>(head <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>)
    {
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nullptr</span>;
    }

    <span style="color:#66d9ef">if</span>(head<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>)
        <span style="color:#66d9ef">return</span>  head;
    <span style="color:#66d9ef">else</span>
    {
        cur <span style="color:#f92672">=</span> head;
        tmp <span style="color:#f92672">=</span> head<span style="color:#f92672">-&gt;</span>next;
        recurHead <span style="color:#f92672">=</span> recurReversionLinkedList(tmp); <span style="color:#75715e">//得到反转之后的头节点
</span><span style="color:#75715e"></span>        tmp<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> cur; <span style="color:#75715e">//此时tmp就是最后一个节点了,应该将cur放到此时的最后一个节点tmp的后面
</span><span style="color:#75715e"></span>        cur<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
        <span style="color:#66d9ef">return</span>  recurHead;
    }
}
</code></pre></div><hr>
<h2 id="压缩字符串">压缩字符串</h2>
<p>给定一段字符串，仅压缩连续重复出现的字符，例如字符串<code>abcbc</code>压缩后为<code>1a1b1c</code>，<code>xxxyyyyzz</code>压缩后为<code>3x4y2z</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">compressString</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>src)
{
    assert(src <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>);
    <span style="color:#66d9ef">auto</span> length <span style="color:#f92672">=</span> strlen(src);

    <span style="color:#66d9ef">auto</span> <span style="color:#f92672">*</span>result <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">char</span>[<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> length <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];  <span style="color:#75715e">//当字符都不相同时，压缩后的字符串长度变为原来的2倍
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, k <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">char</span> cur;

    <span style="color:#66d9ef">while</span> (src[i] <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;\0&#39;</span>)
    {
        cur <span style="color:#f92672">=</span> src[i];
        j <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">while</span> (src[j] <span style="color:#f92672">==</span> cur)
        {
            j<span style="color:#f92672">++</span>;
        }

        result[k<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span>) (j <span style="color:#f92672">-</span> i <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39;0&#39;</span>);
        result[k<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> cur;
        i <span style="color:#f92672">=</span> j;
    }
    result[k] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;\0&#39;</span>;
    cout <span style="color:#f92672">&lt;&lt;</span> result <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">delete</span>[] result;
}
</code></pre></div><hr>
<h2 id="删除多余空格">删除多余空格</h2>
<p>在不开辟额外空间的情况下删除开始和结尾处的空格，并将中间的多个连续的空格合成一个。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">deleteSpaces2</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>str)
{
    <span style="color:#66d9ef">auto</span> length <span style="color:#f92672">=</span> strlen(str);
    <span style="color:#66d9ef">auto</span> i <span style="color:#f92672">=</span> length <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;

    <span style="color:#66d9ef">while</span> (str[i] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39; &#39;</span>)  i<span style="color:#f92672">--</span>;
    str[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;\0&#39;</span>;

    i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">while</span> (str[i] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39; &#39;</span>) i<span style="color:#f92672">++</span>;


    <span style="color:#66d9ef">while</span>(str[i] <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;\0&#39;</span>)
    {
        str[j<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> str[i<span style="color:#f92672">++</span>];

        <span style="color:#66d9ef">if</span>(str[i] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39; &#39;</span>)
        {
            <span style="color:#66d9ef">while</span>(str[i] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39; &#39;</span>) i<span style="color:#f92672">++</span>;
            str[j<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39; &#39;</span>;
        }
    }
    str[j] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;\0&#39;</span>;
    cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;***&#34;</span><span style="color:#f92672">&lt;&lt;</span>str<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;***&#34;</span><span style="color:#f92672">&lt;&lt;</span>endl;
}
</code></pre></div><hr>
<h2 id="合并两个有序的链表">合并两个有序的链表</h2>
<p>当得到两个链表中值较小的头节点并把它链接到已经合并的链表之后，<!-- raw HTML omitted -->两个链表剩余的节点依然是有序的<!-- raw HTML omitted -->，因此合并的步骤和之前的步骤一样。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">LinkedNode <span style="color:#f92672">*</span><span style="color:#a6e22e">mergeOrderLinkedList</span>(LinkedNode <span style="color:#f92672">*</span>head1, LinkedNode <span style="color:#f92672">*</span>head2)
{
    <span style="color:#66d9ef">if</span> (head1 <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>)
        <span style="color:#66d9ef">return</span> head2;
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (head2 <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>)
        <span style="color:#66d9ef">return</span> head1;

    LinkedNode <span style="color:#f92672">*</span>mergeHead <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;

    <span style="color:#66d9ef">if</span> (head1<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">&lt;=</span> head2<span style="color:#f92672">-&gt;</span>data)
    {
        mergeHead <span style="color:#f92672">=</span> head1;
        mergeHead<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> mergeOrderLinkedList(head1<span style="color:#f92672">-&gt;</span>next, head2);
    } <span style="color:#66d9ef">else</span>
    {
        mergeHead <span style="color:#f92672">=</span> head2;
        mergeHead<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> mergeOrderLinkedList(head1, head2<span style="color:#f92672">-&gt;</span>next);
    }

    <span style="color:#66d9ef">return</span> mergeHead;
}
</code></pre></div><hr>
<h2 id="树的子结构">树的子结构</h2>
<p>输入两棵二叉树 A 和 B，判断 B 是不是 A 的子树</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">hasSubTree</span>(BinTreeNode <span style="color:#f92672">*</span>root1, BinTreeNode <span style="color:#f92672">*</span>root2)
{
    <span style="color:#66d9ef">bool</span> result <span style="color:#f92672">=</span> false;
    <span style="color:#66d9ef">if</span>(root1 <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">&amp;&amp;</span> root2 <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span> )
    {
        <span style="color:#66d9ef">if</span>(root1<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">==</span> root2<span style="color:#f92672">-&gt;</span>data)
           result <span style="color:#f92672">=</span> DoesTree1HasTree2(root1,root2);
        
        <span style="color:#66d9ef">if</span>(false <span style="color:#f92672">==</span> result)
        {
            result <span style="color:#f92672">=</span> hasSubTree(root1<span style="color:#f92672">-&gt;</span>leftChild,root2);
        }
        
        <span style="color:#66d9ef">if</span>(false <span style="color:#f92672">==</span> result)
        {
            result <span style="color:#f92672">=</span> hasSubTree(root1<span style="color:#f92672">-&gt;</span>rightChild,root2);
        }
    }
    
    <span style="color:#66d9ef">return</span> result;
}

<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">DoesTree1HasTree2</span>(BinTreeNode <span style="color:#f92672">*</span>root1, BinTreeNode <span style="color:#f92672">*</span>root2)
{
    <span style="color:#66d9ef">if</span>(root2 <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>)
        <span style="color:#66d9ef">return</span> true;
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(root1 <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>)
        <span style="color:#66d9ef">return</span> false;
    
    <span style="color:#66d9ef">if</span>(root1<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">!=</span> root2<span style="color:#f92672">-&gt;</span>data)
        <span style="color:#66d9ef">return</span> false;
    
    
    <span style="color:#66d9ef">return</span> DoesTree1HasTree2(root1<span style="color:#f92672">-&gt;</span>rightChild,root2<span style="color:#f92672">-&gt;</span>leftChild) <span style="color:#f92672">&amp;&amp;</span> DoesTree1HasTree2(root1<span style="color:#f92672">-&gt;</span>rightChild,root2<span style="color:#f92672">-&gt;</span>rightChild);
}
</code></pre></div><hr>
<h2 id="树的镜像">树的镜像</h2>
<p>先前序遍历这棵树的每一个节点，如果遍历到的节点有子节点则交换它们，当交换完所有的非叶子节点的左右子节点之后，就得到了树的镜像</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">changeToMirror</span>(BinTreeNode <span style="color:#f92672">*</span>root)
{
    <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>)
        <span style="color:#66d9ef">return</span>;

    <span style="color:#66d9ef">if</span> (root<span style="color:#f92672">-&gt;</span>leftChild <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">&amp;&amp;</span> root<span style="color:#f92672">-&gt;</span>rightChild <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>)
        <span style="color:#66d9ef">return</span>;

    BinTreeNode <span style="color:#f92672">*</span>tmp;
    tmp <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>leftChild;
    root<span style="color:#f92672">-&gt;</span>leftChild <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>rightChild;
    root<span style="color:#f92672">-&gt;</span>rightChild <span style="color:#f92672">=</span> tmp;
    
    <span style="color:#66d9ef">if</span>(<span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">!=</span> root<span style="color:#f92672">-&gt;</span>leftChild)
        changeToMirror(root<span style="color:#f92672">-&gt;</span>leftChild);
    
    <span style="color:#66d9ef">if</span>(<span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">!=</span> root<span style="color:#f92672">-&gt;</span>rightChild)
        changeToMirror(root<span style="color:#f92672">-&gt;</span>rightChild);
}
</code></pre></div><hr>
<h2 id="顺时针打印矩阵">顺时针打印矩阵</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">clockwisePrintMatrix</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">**</span>input, <span style="color:#66d9ef">int</span> columns, <span style="color:#66d9ef">int</span> rows)
{
    <span style="color:#66d9ef">if</span> (input <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">||</span> columns <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>)
        <span style="color:#66d9ef">return</span>;

    <span style="color:#66d9ef">int</span> start <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">while</span> (columns <span style="color:#f92672">&gt;</span> start <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">&amp;&amp;</span> rows <span style="color:#f92672">&gt;</span> start <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>) <span style="color:#75715e">//打印进行的条件
</span><span style="color:#75715e"></span>    {
        printMatrixInCircle(input, columns, rows, start);
        start<span style="color:#f92672">++</span>;
    }
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">printMatrixInCircle</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">**</span>input, <span style="color:#66d9ef">int</span> rows, <span style="color:#66d9ef">int</span> columns, <span style="color:#66d9ef">int</span> start)
{
    <span style="color:#66d9ef">int</span> endX <span style="color:#f92672">=</span> columns <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> start; <span style="color:#75715e">//记录行的最右边
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> endY <span style="color:#f92672">=</span> rows <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> start;    <span style="color:#75715e">//记录列的最下边
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">//从左往右打印一行
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> start; i <span style="color:#f92672">&lt;=</span> endX ; <span style="color:#f92672">++</span>i)
    {
        cout<span style="color:#f92672">&lt;&lt;</span>input[start][i]<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">&#34;</span>;
    }

    <span style="color:#75715e">//从上往下打印一列
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> start<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;  i<span style="color:#f92672">&lt;=</span> endY; <span style="color:#f92672">++</span>i)
    {
        cout<span style="color:#f92672">&lt;&lt;</span>input[i][endX]<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">&#34;</span>;
    }

    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> endX<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&gt;=</span>start ; <span style="color:#f92672">--</span>i)
    {
        cout<span style="color:#f92672">&lt;&lt;</span>input[endY][i]<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">&#34;</span>;
    }

    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> endY<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&gt;</span> start ; <span style="color:#f92672">--</span>i)
    {
        cout<span style="color:#f92672">&lt;&lt;</span>input[i][start]<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">&#34;</span>;
    }
    
    cout<span style="color:#f92672">&lt;&lt;</span>endl;
}
</code></pre></div><hr>
<h2 id="包含min函数的栈">包含min函数的栈</h2>
<p>定义栈的数据结构，在该类型中实现一个能够得到栈的最小元素的<code>min</code>函数。</p>
<p>利用一个辅助栈，<!-- raw HTML omitted -->每次将最小的元素（当前最小和入栈压入的新元素比较）都保存在这个辅助栈中。当弹出元素时，辅助栈中的元素也弹出一个<!-- raw HTML omitted -->。</p>
<hr>
<h2 id="判断正确的出栈序列">判断正确的出栈序列</h2>
<p>输入两个整数序列，第一个表示栈的压入顺序，第二个表示弹出序列，判断弹出序列是否是第一个压入序列的有效弹出序列。</p>
<p>使用一个辅助栈来保存压入序列，如果下一个弹出的数字刚好是栈顶数字，那么直接弹出，<!-- raw HTML omitted -->如果下一个弹出的数字不在栈顶，则把压栈序列中还未压入的数字压入到栈中，直到把下一个需要弹出的数字压入到栈顶为止，<!-- raw HTML omitted -->如果所有数字都压入到栈中了还未找到下一个弹出的数字，那么该序列就不是合法的弹出序列。</p>
<p>下面这个是针对与栈中元素是整型变量的：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">isPopOrder</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>pushOrder, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>popOrder, <span style="color:#66d9ef">int</span> length)
{
    <span style="color:#66d9ef">bool</span> result <span style="color:#f92672">=</span> false;
    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>nextPush <span style="color:#f92672">=</span> pushOrder;
    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>nextPop <span style="color:#f92672">=</span> popOrder;
    stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> st;

    <span style="color:#66d9ef">if</span> (pushOrder <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">&amp;&amp;</span> popOrder <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">&amp;&amp;</span> length <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>)
    {
        <span style="color:#66d9ef">while</span> ((nextPop <span style="color:#f92672">-</span> popOrder) <span style="color:#f92672">&lt;</span> length)
        {
            <span style="color:#66d9ef">while</span> (st.empty() <span style="color:#f92672">||</span> <span style="color:#f92672">*</span>nextPop <span style="color:#f92672">!=</span> st.top())
            {
                <span style="color:#66d9ef">if</span> ((nextPush <span style="color:#f92672">-</span> pushOrder) <span style="color:#f92672">==</span> length)
                    <span style="color:#66d9ef">break</span>;

                st.push(<span style="color:#f92672">*</span>nextPush);
                nextPush<span style="color:#f92672">++</span>;
            }

            <span style="color:#66d9ef">if</span> (st.top() <span style="color:#f92672">!=</span> <span style="color:#f92672">*</span>nextPush)
                <span style="color:#66d9ef">break</span>;

            nextPop<span style="color:#f92672">++</span>;
            st.pop();
        }

        <span style="color:#66d9ef">if</span> (st.empty() <span style="color:#f92672">&amp;&amp;</span> (nextPop <span style="color:#f92672">-</span> popOrder <span style="color:#f92672">==</span> length))
            result <span style="color:#f92672">=</span> true;
    }

    <span style="color:#66d9ef">return</span> result;
}
</code></pre></div><p>这个是针对于栈中元素是字符型</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">isPopOrder</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>pushOrder, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>popOrder)
{
    <span style="color:#66d9ef">bool</span> result <span style="color:#f92672">=</span> false;
    <span style="color:#66d9ef">auto</span> length <span style="color:#f92672">=</span> strlen(pushOrder);

    <span style="color:#66d9ef">if</span>(popOrder <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">&amp;&amp;</span> pushOrder <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">&amp;&amp;</span> length <span style="color:#f92672">==</span> strlen(popOrder))
    {
        stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span> st;
        <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> nextPush <span style="color:#f92672">=</span> pushOrder;
        <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> nextPop <span style="color:#f92672">=</span> popOrder;

        <span style="color:#66d9ef">while</span>(<span style="color:#f92672">*</span>nextPop <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;\0&#39;</span>)
        {
            <span style="color:#66d9ef">while</span>(st.empty() <span style="color:#f92672">||</span> <span style="color:#f92672">*</span>nextPop <span style="color:#f92672">!=</span> st.top())
            {
                <span style="color:#66d9ef">if</span>(<span style="color:#f92672">*</span>nextPush <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;\0&#39;</span>)
                    <span style="color:#66d9ef">break</span>;

                st.push(<span style="color:#f92672">*</span>nextPush);
                nextPush<span style="color:#f92672">++</span>;
            }

            <span style="color:#66d9ef">if</span>(<span style="color:#f92672">*</span>nextPop <span style="color:#f92672">!=</span> st.top())
                <span style="color:#66d9ef">break</span>;

            nextPop<span style="color:#f92672">++</span>;
            st.pop();
        }

        <span style="color:#66d9ef">if</span>(st.empty() <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">*</span>nextPop <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;\0&#39;</span>)
            result <span style="color:#f92672">=</span> true;
    }

    <span style="color:#66d9ef">return</span> result;
}
</code></pre></div><hr>
<h2 id="二叉搜索树的后序遍历序列">二叉搜索树的后序遍历序列</h2>
<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果，如果是则返回true，不是则返回false</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">verifySquenceOfBST</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>input, <span style="color:#66d9ef">int</span> length)
{
    <span style="color:#66d9ef">bool</span> result <span style="color:#f92672">=</span> false;

    <span style="color:#66d9ef">if</span> (input <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">||</span> length <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>)
        <span style="color:#66d9ef">return</span> result;

    <span style="color:#66d9ef">int</span> cur <span style="color:#f92672">=</span> input[length <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];  <span style="color:#75715e">//根节点
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> index <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

    <span style="color:#66d9ef">while</span> (index <span style="color:#f92672">&lt;</span> length <span style="color:#f92672">&amp;&amp;</span> input[index] <span style="color:#f92672">&lt;</span> cur)
    {
        index<span style="color:#f92672">++</span>;
    }
    mid <span style="color:#f92672">=</span> index;

    <span style="color:#66d9ef">while</span> (index <span style="color:#f92672">&lt;</span> length <span style="color:#f92672">&amp;&amp;</span> input[index] <span style="color:#f92672">&gt;</span> cur)
    {
        index<span style="color:#f92672">++</span>;
    }

    <span style="color:#66d9ef">if</span> (index <span style="color:#f92672">==</span> length <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#75715e">//注意边界判断
</span><span style="color:#75715e"></span>    {
        <span style="color:#66d9ef">bool</span> left <span style="color:#f92672">=</span> false, right <span style="color:#f92672">=</span> false;
        <span style="color:#66d9ef">if</span> (mid <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>)
            left <span style="color:#f92672">=</span> verifySquenceOfBST(input, mid);

        <span style="color:#66d9ef">if</span> (mid <span style="color:#f92672">&lt;</span> length <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
            right <span style="color:#f92672">=</span> verifySquenceOfBST(input <span style="color:#f92672">+</span> mid, length <span style="color:#f92672">-</span> mid <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);

        result <span style="color:#f92672">=</span> left <span style="color:#f92672">&amp;&amp;</span> right;
    }

    <span style="color:#66d9ef">return</span> result;
}
</code></pre></div><hr>
<h2 id="二叉树中从根开始和为某一值的路径">二叉树中从根开始和为某一值的路径</h2>
<p>输入一棵二叉树和一个整数，打印二叉树中节点值的和为输入整数的所有路径。<!-- raw HTML omitted -->从树的根节点开始往下一直到<!-- raw HTML omitted -->某一节点<!-- raw HTML omitted -->所经过的节点形成一条路径<!-- raw HTML omitted -->。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">findPath</span>(BinTreeNode <span style="color:#f92672">*</span>root, <span style="color:#66d9ef">int</span> sum)
{
    <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>)
        <span style="color:#66d9ef">return</span>;

    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span> path;
    <span style="color:#66d9ef">int</span> currentSum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    findPath(root, path, sum, currentSum);
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">findPath</span>(BinTreeNode <span style="color:#f92672">*</span>root, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span>path, <span style="color:#66d9ef">int</span> sum, <span style="color:#66d9ef">int</span> currentsum)
{
    currentsum <span style="color:#f92672">+=</span> root<span style="color:#f92672">-&gt;</span>data;
    path.push_back(root<span style="color:#f92672">-&gt;</span>data);
    <span style="color:#66d9ef">if</span> (sum <span style="color:#f92672">==</span> currentsum)
    {
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> it <span style="color:#f92672">=</span> path.begin(); it <span style="color:#f92672">!=</span> path.end(); it<span style="color:#f92672">++</span>)
        {
            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>it <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\t&#39;</span>;
        }
        cout <span style="color:#f92672">&lt;&lt;</span> endl;
    }

    <span style="color:#66d9ef">if</span> (root<span style="color:#f92672">-&gt;</span>leftChild <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>)
    {
        findPath(root<span style="color:#f92672">-&gt;</span>leftChild, path, currentsum, sum);
    }

    <span style="color:#66d9ef">if</span> (root<span style="color:#f92672">-&gt;</span>rightChild <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>)
    {
        findPath(root<span style="color:#f92672">-&gt;</span>rightChild, path, currentsum, sum);
    }

    path.pop_back();
}
</code></pre></div><p>不用vector算法的写法：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">printSumPath</span>(BinTreeNode <span style="color:#f92672">*</span>root, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>path, <span style="color:#66d9ef">int</span> length, <span style="color:#66d9ef">int</span> sum)
{
    <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>)
        <span style="color:#66d9ef">return</span>;

    path[length] <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>data;
    sum <span style="color:#f92672">-=</span> root<span style="color:#f92672">-&gt;</span>data;
    length<span style="color:#f92672">++</span>;

    <span style="color:#66d9ef">if</span> (<span style="color:#ae81ff">0</span> <span style="color:#f92672">==</span> sum)
    {
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;=</span> length; <span style="color:#f92672">++</span>i)
        {
            cout <span style="color:#f92672">&lt;&lt;</span> path[i];
        }
        cout <span style="color:#f92672">&lt;&lt;</span> endl;
    }

    <span style="color:#66d9ef">if</span> (root<span style="color:#f92672">-&gt;</span>leftChild <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>)
    {
        printSumPath(root<span style="color:#f92672">-&gt;</span>leftChild, path, length, sum);
    }

    <span style="color:#66d9ef">if</span> (root<span style="color:#f92672">-&gt;</span>rightChild <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>)
    {
        printSumPath(root<span style="color:#f92672">-&gt;</span>rightChild, path, length, sum);
    }

    length<span style="color:#f92672">--</span>;  <span style="color:#75715e">//减不减其实无所谓
</span><span style="color:#75715e"></span>}
</code></pre></div><hr>
<h2 id="二叉树中和为某一值的路径">二叉树中和为某一值的路径</h2>
<p>一棵二叉树每个节点包含一个整数，设计一个算法输出所有满足条件的路径：在此路径上所有给定的节点之和为给定值，<!-- raw HTML omitted -->不必从根节点开始<!-- raw HTML omitted --></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">printSumPath</span>(BinTreeNode <span style="color:#f92672">*</span>root, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span>path, <span style="color:#66d9ef">int</span> sum, <span style="color:#66d9ef">int</span> level)
{
   <span style="color:#66d9ef">if</span>(root <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>)
   {
       path.push_back(root<span style="color:#f92672">-&gt;</span>data);
       
       <span style="color:#66d9ef">int</span> currentSum <span style="color:#f92672">=</span> sum;

       <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> level; i <span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span>; <span style="color:#f92672">++</span>i)
       {
           currentSum<span style="color:#f92672">-=</span>path[i];
           
           <span style="color:#66d9ef">if</span>(currentSum <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
               printSumPath(path,i,level);
       }
       level<span style="color:#f92672">++</span>;
       <span style="color:#66d9ef">if</span>(root<span style="color:#f92672">-&gt;</span>leftChild <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>)
           printSumPath(root<span style="color:#f92672">-&gt;</span>leftChild,path,sum,level);
       
       <span style="color:#66d9ef">if</span>(root<span style="color:#f92672">-&gt;</span>rightChild <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>)
           printSumPath(root<span style="color:#f92672">-&gt;</span>rightChild,path,sum,level);
       
       path.pop_back();
   }
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">printSumPath</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span> path, <span style="color:#66d9ef">int</span> start, <span style="color:#66d9ef">int</span> end)
{
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> start; i <span style="color:#f92672">&lt;=</span> end; <span style="color:#f92672">++</span>i)
    {
        cout<span style="color:#f92672">&lt;&lt;</span>path[i]<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#39;\t&#39;</span>;
    }
    cout<span style="color:#f92672">&lt;&lt;</span>endl;
}
</code></pre></div><hr>

    </div>
    <footer class="post-footer">
        
 
<div class="post-tags">     
     
    <a href="https://iihui.github.io/tags/%e7%ae%97%e6%b3%95" rel="tag" title="算法">#算法#</a>
    
</div>



        <div class="post-nav">
    <div class="post-nav-next post-nav-item">
    
        <a href="https://iihui.github.io/post/arith-sword-1/" rel="next" title="剑指offer题集1">
        <i class="fa fa-chevron-left"></i> 剑指offer题集1
        </a>
    
    </div>

    <div class="post-nav-prev post-nav-item">
    
        <a href="https://iihui.github.io/post/cpp-smart-pointer/" rel="prev" title="C&#43;&#43;智能指针">
        C&#43;&#43;智能指针 <i class="fa fa-chevron-right"></i>
        </a>
    
    </div>
</div>
      
        <div class="post-nav">
    <div style="border: 1px dashed #e0e0e0; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
        <div style="float:left;margin-top:0px;">
            <img src="https://i.loli.net/2020/02/09/SvhUdz4XJsOr9Vk.jpg" width="128px" height="128px"/>
            <div style="text-align:center;">谢谢支持!</div>
        </div>
        <div>
            <p style="margin-top:10px;">
                标题：剑指offer题集1
                <br />作者：阿呆<a target="_blank" href="https://iihui.github.io/"></a>
                
                <br />地址：https://iihui.github.io/post/post/arith-sword-1/
                <br />声明：自由转载-非商用-保持署名（创作共享4.0许可证）
            </p>
        </div>
    </div>
    <div class="clear"></div>
</div>
        
        
        




    </footer>
  </article>
</section>

          </div>
        </div>
        <div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>
<aside id="sidebar" class="sidebar">
  <div class="sidebar-inner">

  <ul class="sidebar-nav motion-element">
    <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
      文章目录
    </li>
    <li class="sidebar-nav-overview" data-target="site-overview">
      站点概览
    </li>
  </ul>

    <section class="site-overview sidebar-panel ">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
        src="https://i.loli.net/2020/02/07/dVFzrvZkHRNq2lL.jpg"
        alt="" />
    <p class="site-author-name" itemprop="name"></p>
    <p class="site-description motion-element" itemprop="description"> 
        coder &amp; cook</p>
</div>
      <nav class="site-state motion-element">
    <div class="site-state-item site-state-posts">
      <a href="https://iihui.github.io/post/">
        <span class="site-state-item-count">272</span>
        <span class="site-state-item-name">日志</span>
      </a>
    </div>
    <div class="site-state-item site-state-categories">    
        <a href="https://iihui.github.io/categories/">      
         
        <span class="site-state-item-count">15</span>
        
        <span class="site-state-item-name">分类</span>
        
        </a>
    </div>

    <div class="site-state-item site-state-tags">
        <a href="https://iihui.github.io/tags/">
         
        <span class="site-state-item-count">29</span>
        
        <span class="site-state-item-name">标签</span>
        </a>
    </div>
</nav>
      
      
<div class="links-of-author motion-element">
    
        <span class="links-of-author-item">
        <a href="https://coolshell.cn" target="_blank" title="皓 大">
            <i class="fa fa-fw fa-globe"></i>
            皓 大
        </a>
        </span>
    
        <span class="links-of-author-item">
        <a href="http://www.ruanyifeng.com" target="_blank" title="阮 大">
            <i class="fa fa-fw fa-globe"></i>
            阮 大
        </a>
        </span>
    
        <span class="links-of-author-item">
        <a href="https://juejin.im/" target="_blank" title="掘 金">
            <i class="fa fa-fw fa-globe"></i>
            掘 金
        </a>
        </span>
    
        <span class="links-of-author-item">
        <a href="http://www.ideamsg.com" target="_blank" title="灵 感">
            <i class="fa fa-fw fa-globe"></i>
            灵 感
        </a>
        </span>
    
</div>


      

      <div class="links-of-blogroll motion-element inline">
<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=&amp;m=0&amp;s=220&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;bv=35" async="async"></script>
</div>

    </section>
    
<section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
    <div class="post-toc">
        <div class="post-toc-content"><nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#二维数组中查找">二维数组中查找</a></li>
        <li><a href="#字符串的赋值操作符重载">字符串的赋值操作符重载</a></li>
        <li><a href="#从尾到头打印链表">从尾到头打印链表</a></li>
        <li><a href="#两个栈实现队列">两个栈实现队列</a></li>
        <li><a href="#两个队列实现一个栈">两个队列实现一个栈</a></li>
        <li><a href="#快速排序">快速排序</a></li>
        <li><a href="#旋转数组中的最小值">旋转数组中的最小值</a></li>
        <li><a href="#斐波那契数列">斐波那契数列</a></li>
        <li><a href="#数组的整数次方">数组的整数次方</a></li>
        <li><a href="#打印1到最大的n位数">打印1到最大的n位数</a></li>
        <li><a href="#在o1时间内删除节点">在O(1)时间内删除节点</a></li>
        <li><a href="#链表中的倒数第-k-个节点">链表中的倒数第 k 个节点</a></li>
        <li><a href="#反转链表">反转链表</a></li>
        <li><a href="#压缩字符串">压缩字符串</a></li>
        <li><a href="#删除多余空格">删除多余空格</a></li>
        <li><a href="#合并两个有序的链表">合并两个有序的链表</a></li>
        <li><a href="#树的子结构">树的子结构</a></li>
        <li><a href="#树的镜像">树的镜像</a></li>
        <li><a href="#顺时针打印矩阵">顺时针打印矩阵</a></li>
        <li><a href="#包含min函数的栈">包含min函数的栈</a></li>
        <li><a href="#判断正确的出栈序列">判断正确的出栈序列</a></li>
        <li><a href="#二叉搜索树的后序遍历序列">二叉搜索树的后序遍历序列</a></li>
        <li><a href="#二叉树中从根开始和为某一值的路径">二叉树中从根开始和为某一值的路径</a></li>
        <li><a href="#二叉树中和为某一值的路径">二叉树中和为某一值的路径</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
    </div>
</section>

  </div>
</aside>

      </div>
    </main>
   
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  <span itemprop="copyrightYear">  &copy; 
  2017 - 2020</span>
  <span class="with-love"><i class="fa fa-heart"></i></span>
  <span class="author" itemprop="copyrightHolder">Keep It Simple</span>
</div>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      <span id="scrollpercent"><span>0</span>%</span>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/jquery/index.js?v=2.1.3"></script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script> 
<script type="text/javascript" src="https://iihui.github.io/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/velocity/velocity.min.js?v=1.2.1"></script>
<script type="text/javascript" src="https://iihui.github.io/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="https://iihui.github.io/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>

<script src="https://iihui.github.io/js/vendor/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>

<script type="text/javascript" src="https://iihui.github.io/js/utils.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/motion.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/affix.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/schemes/pisces.js"></script>

<script type="text/javascript" src="https://iihui.github.io/js/scrollspy.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/post-details.js"></script>
<script type="text/javascript" src="https://iihui.github.io/js/toc.js"></script>

<script type="text/javascript" src="https://iihui.github.io/js/bootstrap.js"></script>

<script type="text/javascript" src="https://iihui.github.io/js/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
</body>
</html>